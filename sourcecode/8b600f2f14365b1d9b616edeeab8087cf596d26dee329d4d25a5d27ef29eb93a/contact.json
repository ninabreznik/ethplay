{
  "address": "0x0056a6ac46c0540b9b39bfeecae0c9482f80f809",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "BasicToken",
  "compilerVersion": "v0.4.19+commit.c4cbbb05",
  "optimization": false,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2017-12-25\n*/\n\npragma solidity ^0.4.18;\n\n\nlibrary SafeMath {\nfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\nif (a == 0) {\nreturn 0;\n}\nuint256 c = a * b;\nassert(c / a == b);\nreturn c;\n}\n\nfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n// assert(b > 0); // Solidity automatically throws when dividing by 0\nuint256 c = a / b;\n// assert(a == b * c + a % b); // There is no case in which this doesn't hold\nreturn c;\n}\n\nfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\nassert(b <= a);\nreturn a - b;\n}\n\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\nuint256 c = a + b;\nassert(c >= a);\nreturn c;\n}\n}\ncontract Ownable {\naddress public owner;\n\n\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n/**\n* @dev The Ownable constructor sets the original `owner` of the contract to the sender\n* account.\n*/\nfunction Ownable() public {\nowner = msg.sender;\n}\n\n\n/**\n* @dev Throws if called by any account other than the owner.\n*/\nmodifier onlyOwner() {\nrequire(msg.sender == owner);\n_;\n}\n\n\n/**\n* @dev Allows the current owner to transfer control of the contract to a newOwner.\n* @param newOwner The address to transfer ownership to.\n*/\nfunction transferOwnership(address newOwner) public onlyOwner {\nrequire(newOwner != address(0));\nOwnershipTransferred(owner, newOwner);\nowner = newOwner;\n}\n\n}\n\n\n/**\n* @title ERC20Basic\n* @dev Simpler version of ERC20 interface\n*/\ncontract ERC20Basic {\nuint256 public totalSupply;\nfunction balanceOf(address who) public view returns (uint256);\nfunction transfer(address to, uint256 value) public returns (bool);\nevent Transfer(address indexed from, address indexed to, uint256 value);\n}\n\ncontract ERC20 is ERC20Basic {\nfunction allowance(address owner, address spender) public view returns (uint256);\nfunction transferFrom(address from, address to, uint256 value) public returns (bool);\nfunction approve(address spender, uint256 value) public returns (bool);\nevent Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract BasicToken is ERC20Basic {\nusing SafeMath for uint256;\n\nmapping(address => uint256) balances;\n\n/**\n* @dev transfer token for a specified address\n* @param _to The address to transfer to.\n* @param _value The amount to be transferred.\n*/\nfunction transfer(address _to, uint256 _value) public returns (bool) {\nrequire(_to != address(0));\nrequire(_value <= balances[msg.sender]);\n\n// SafeMath.sub will throw if there is not enough balance.\nbalances[msg.sender] = balances[msg.sender].sub(_value);\nbalances[_to] = balances[_to].add(_value);\nTransfer(msg.sender, _to, _value);\nreturn true;\n}\n\n/**\n* @dev Gets the balance of the specified address.\n* @param _owner The address to query the the balance of.\n* @return An uint256 representing the amount owned by the passed address.\n*/\nfunction balanceOf(address _owner) public view returns (uint256 balance) {\nreturn balances[_owner];\n}\n\n\n\n\n\n\n}\n\ncontract StandardToken is ERC20, BasicToken {\n\nmapping (address => mapping (address => uint256)) internal allowed;\n\n\n\n\nfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\nrequire(_to != address(0));\nrequire(_value <= balances[_from]);\nrequire(_value <= allowed[_from][msg.sender]);\n\nbalances[_from] = balances[_from].sub(_value);\nbalances[_to] = balances[_to].add(_value);\nallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\nTransfer(_from, _to, _value);\nreturn true;\n}\n\n/**\n* @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n*\n* Beware that changing an allowance with this method brings the risk that someone may use both the old\n* and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n* race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n* https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n* @param _spender The address which will spend the funds.\n* @param _value The amount of tokens to be spent.\n*/\nfunction approve(address _spender, uint256 _value) public returns (bool) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nreturn true;\n}\n\n/**\n* @dev Function to check the amount of tokens that an owner allowed to a spender.\n* @param _owner address The address which owns the funds.\n* @param _spender address The address which will spend the funds.\n* @return A uint256 specifying the amount of tokens still available for the spender.\n*/\nfunction allowance(address _owner, address _spender) public view returns (uint256) {\nreturn allowed[_owner][_spender];\n}\n\n/**\n* approve should be called when allowed[_spender] == 0. To increment\n* allowed value is better to use this function to avoid 2 calls (and wait until\n* the first transaction is mined)\n* From MonolithDAO Token.sol\n*/\nfunction increaseApproval(address _spender, uint _addedValue) public returns (bool) {\nallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\nApproval(msg.sender, _spender, allowed[msg.sender][_spender]);\nreturn true;\n}\n\nfunction decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\nuint oldValue = allowed[msg.sender][_spender];\nif (_subtractedValue > oldValue) {\nallowed[msg.sender][_spender] = 0;\n} else {\nallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n}\nApproval(msg.sender, _spender, allowed[msg.sender][_spender]);\nreturn true;\n}\n\n}\n/**\n* @title SimpleToken\n* @dev Very simple ERC20 Token example, where all tokens are pre-assigned to the creator.\n* Note they can later distribute these tokens as they wish using `transfer` and other\n* `StandardToken` functions.\n*/\ncontract IranCoinToken is StandardToken, Ownable {\n\nstring public constant name = \"Zarig\";\nstring public constant symbol = \"ICD\";\nuint8 public constant decimals = 18;\nuint256 public constant rewards = 8000000 * (10 ** uint256(decimals));\nuint256 public constant INITIAL_SUPPLY = 17000000 * (10 ** uint256(decimals));\n\n/**\n* @dev Constructor that gives msg.sender all of existing tokens.\n*/\nfunction IranCoinToken() public {\ntotalSupply == INITIAL_SUPPLY.add(rewards);\nbalances[msg.sender] = INITIAL_SUPPLY;\n}\n}",
  "bytecode": "6060604052341561000f57600080fd5b6104028061001e6000396000f300606060405260043610610057576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806318160ddd1461005c57806370a0823114610085578063a9059cbb146100d2575b600080fd5b341561006757600080fd5b61006f61012c565b6040518082815260200191505060405180910390f35b341561009057600080fd5b6100bc600480803573ffffffffffffffffffffffffffffffffffffffff16906020019091905050610132565b6040518082815260200191505060405180910390f35b34156100dd57600080fd5b610112600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803590602001909190505061017b565b604051808215151515815260200191505060405180910390f35b60005481565b6000600160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050919050565b60008073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff16141515156101b857600080fd5b600160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054821115151561020657600080fd5b61025882600160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205461039f90919063ffffffff16565b600160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055506102ed82600160008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020546103b890919063ffffffff16565b600160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040518082815260200191505060405180910390a36001905092915050565b60008282111515156103ad57fe5b818303905092915050565b60008082840190508381101515156103cc57fe5b80915050929150505600a165627a7a7230582063fc77948de7ce231fb4e6c7d8cdf706365aa50c2c354a8eb955d93bff6698020029"
}