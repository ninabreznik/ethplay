{
  "address": "0x1cb5b2bb4030220ad5417229a7a1e3c373cdd2f6",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "DxLockWhitelisted4Rep",
  "compilerVersion": "v0.5.4+commit.9549d8ff",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2019-05-07\n*/\n\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @return the address of the owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner());\n        _;\n    }\n\n    /**\n     * @return true if `msg.sender` is the owner of the contract.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Allows the current owner to relinquish control of the contract.\n     * @notice Renouncing to ownership will leave the contract without an owner.\n     * It will not be possible to call the functions with the `onlyOwner`\n     * modifier anymore.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n// File: @daostack/infra/contracts/Reputation.sol\n\npragma solidity ^0.5.4;\n\n\n\n/**\n * @title Reputation system\n * @dev A DAO has Reputation System which allows peers to rate other peers in order to build trust .\n * A reputation is use to assign influence measure to a DAO'S peers.\n * Reputation is similar to regular tokens but with one crucial difference: It is non-transferable.\n * The Reputation contract maintain a map of address to reputation value.\n * It provides an onlyOwner functions to mint and burn reputation _to (or _from) a specific address.\n */\n\ncontract Reputation is Ownable {\n\n    uint8 public decimals = 18;             //Number of decimals of the smallest unit\n    // Event indicating minting of reputation to an address.\n    event Mint(address indexed _to, uint256 _amount);\n    // Event indicating burning of reputation for an address.\n    event Burn(address indexed _from, uint256 _amount);\n\n      /// @dev `Checkpoint` is the structure that attaches a block number to a\n      ///  given value, the block number attached is the one that last changed the\n      ///  value\n    struct Checkpoint {\n\n    // `fromBlock` is the block number that the value was generated from\n        uint128 fromBlock;\n\n          // `value` is the amount of reputation at a specific block number\n        uint128 value;\n    }\n\n      // `balances` is the map that tracks the balance of each address, in this\n      //  contract when the balance changes the block number that the change\n      //  occurred is also included in the map\n    mapping (address => Checkpoint[]) balances;\n\n      // Tracks the history of the `totalSupply` of the reputation\n    Checkpoint[] totalSupplyHistory;\n\n    /// @notice Constructor to create a Reputation\n    constructor(\n    ) public\n    {\n    }\n\n    /// @dev This function makes it easy to get the total number of reputation\n    /// @return The total number of reputation\n    function totalSupply() public view returns (uint256) {\n        return totalSupplyAt(block.number);\n    }\n\n  ////////////////\n  // Query balance and totalSupply in History\n  ////////////////\n    /**\n    * @dev return the reputation amount of a given owner\n    * @param _owner an address of the owner which we want to get his reputation\n    */\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balanceOfAt(_owner, block.number);\n    }\n\n      /// @dev Queries the balance of `_owner` at a specific `_blockNumber`\n      /// @param _owner The address from which the balance will be retrieved\n      /// @param _blockNumber The block number when the balance is queried\n      /// @return The balance at `_blockNumber`\n    function balanceOfAt(address _owner, uint256 _blockNumber)\n    public view returns (uint256)\n    {\n        if ((balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)) {\n            return 0;\n          // This will return the expected balance during normal situations\n        } else {\n            return getValueAt(balances[_owner], _blockNumber);\n        }\n    }\n\n      /// @notice Total amount of reputation at a specific `_blockNumber`.\n      /// @param _blockNumber The block number when the totalSupply is queried\n      /// @return The total amount of reputation at `_blockNumber`\n    function totalSupplyAt(uint256 _blockNumber) public view returns(uint256) {\n        if ((totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\n            return 0;\n          // This will return the expected totalSupply during normal situations\n        } else {\n            return getValueAt(totalSupplyHistory, _blockNumber);\n        }\n    }\n\n      /// @notice Generates `_amount` reputation that are assigned to `_owner`\n      /// @param _user The address that will be assigned the new reputation\n      /// @param _amount The quantity of reputation generated\n      /// @return True if the reputation are generated correctly\n    function mint(address _user, uint256 _amount) public onlyOwner returns (bool) {\n        uint256 curTotalSupply = totalSupply();\n        require(curTotalSupply + _amount >= curTotalSupply); // Check for overflow\n        uint256 previousBalanceTo = balanceOf(_user);\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n        updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\n        updateValueAtNow(balances[_user], previousBalanceTo + _amount);\n        emit Mint(_user, _amount);\n        return true;\n    }\n\n      /// @notice Burns `_amount` reputation from `_owner`\n      /// @param _user The address that will lose the reputation\n      /// @param _amount The quantity of reputation to burn\n      /// @return True if the reputation are burned correctly\n    function burn(address _user, uint256 _amount) public onlyOwner returns (bool) {\n        uint256 curTotalSupply = totalSupply();\n        uint256 amountBurned = _amount;\n        uint256 previousBalanceFrom = balanceOf(_user);\n        if (previousBalanceFrom < amountBurned) {\n            amountBurned = previousBalanceFrom;\n        }\n        updateValueAtNow(totalSupplyHistory, curTotalSupply - amountBurned);\n        updateValueAtNow(balances[_user], previousBalanceFrom - amountBurned);\n        emit Burn(_user, amountBurned);\n        return true;\n    }\n\n  ////////////////\n  // Internal helper functions to query and set a value in a snapshot array\n  ////////////////\n\n      /// @dev `getValueAt` retrieves the number of reputation at a given block number\n      /// @param checkpoints The history of values being queried\n      /// @param _block The block number to retrieve the value at\n      /// @return The number of reputation being queried\n    function getValueAt(Checkpoint[] storage checkpoints, uint256 _block) internal view returns (uint256) {\n        if (checkpoints.length == 0) {\n            return 0;\n        }\n\n          // Shortcut for the actual value\n        if (_block >= checkpoints[checkpoints.length-1].fromBlock) {\n            return checkpoints[checkpoints.length-1].value;\n        }\n        if (_block < checkpoints[0].fromBlock) {\n            return 0;\n        }\n\n          // Binary search of the value in the array\n        uint256 min = 0;\n        uint256 max = checkpoints.length-1;\n        while (max > min) {\n            uint256 mid = (max + min + 1) / 2;\n            if (checkpoints[mid].fromBlock<=_block) {\n                min = mid;\n            } else {\n                max = mid-1;\n            }\n        }\n        return checkpoints[min].value;\n    }\n\n      /// @dev `updateValueAtNow` used to update the `balances` map and the\n      ///  `totalSupplyHistory`\n      /// @param checkpoints The history of data being updated\n      /// @param _value The new number of reputation\n    function updateValueAtNow(Checkpoint[] storage checkpoints, uint256 _value) internal {\n        require(uint128(_value) == _value); //check value is in the 128 bits bounderies\n        if ((checkpoints.length == 0) || (checkpoints[checkpoints.length - 1].fromBlock < block.number)) {\n            Checkpoint storage newCheckPoint = checkpoints[checkpoints.length++];\n            newCheckPoint.fromBlock = uint128(block.number);\n            newCheckPoint.value = uint128(_value);\n        } else {\n            Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length-1];\n            oldCheckPoint.value = uint128(_value);\n        }\n    }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ninterface IERC20 {\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address who) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @title SafeMath\n * @dev Unsigned math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    /**\n    * @dev Multiplies two unsigned integers, reverts on overflow.\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n    * @dev Adds two unsigned integers, reverts on overflow.\n    */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n    * reverts when dividing by zero.\n    */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n\npragma solidity ^0.5.0;\n\n\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n * Originally based on code by FirstBlood:\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n *\n * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\n * all accounts just by listening to said events. Note that this isn't required by the specification, and other\n * compliant implementations may not do it.\n */\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowed;\n\n    uint256 private _totalSupply;\n\n    /**\n    * @dev Total number of tokens in existence\n    */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n    * @dev Gets the balance of the specified address.\n    * @param owner The address to query the balance of.\n    * @return An uint256 representing the amount owned by the passed address.\n    */\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\n\n    /**\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n     * @param owner address The address which owns the funds.\n     * @param spender address The address which will spend the funds.\n     * @return A uint256 specifying the amount of tokens still available for the spender.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\n\n    /**\n    * @dev Transfer token for a specified address\n    * @param to The address to transfer to.\n    * @param value The amount to be transferred.\n    */\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     */\n    function approve(address spender, uint256 value) public returns (bool) {\n        require(spender != address(0));\n\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev Transfer tokens from one address to another.\n     * Note that while this function emits an Approval event, this is not required as per the specification,\n     * and other compliant implementations may not emit the event.\n     * @param from address The address which you want to send tokens from\n     * @param to address The address which you want to transfer to\n     * @param value uint256 the amount of tokens to be transferred\n     */\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n        _transfer(from, to, value);\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\n        return true;\n    }\n\n    /**\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\n     * approve should be called when allowed_[_spender] == 0. To increment\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * Emits an Approval event.\n     * @param spender The address which will spend the funds.\n     * @param addedValue The amount of tokens to increase the allowance by.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0));\n\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n    /**\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n     * approve should be called when allowed_[_spender] == 0. To decrement\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * Emits an Approval event.\n     * @param spender The address which will spend the funds.\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        require(spender != address(0));\n\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n    /**\n    * @dev Transfer token for a specified addresses\n    * @param from The address to transfer from.\n    * @param to The address to transfer to.\n    * @param value The amount to be transferred.\n    */\n    function _transfer(address from, address to, uint256 value) internal {\n        require(to != address(0));\n\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Internal function that mints an amount of the token and assigns it to\n     * an account. This encapsulates the modification of balances such that the\n     * proper events are emitted.\n     * @param account The account that will receive the created tokens.\n     * @param value The amount that will be created.\n     */\n    function _mint(address account, uint256 value) internal {\n        require(account != address(0));\n\n        _totalSupply = _totalSupply.add(value);\n        _balances[account] = _balances[account].add(value);\n        emit Transfer(address(0), account, value);\n    }\n\n    /**\n     * @dev Internal function that burns an amount of the token of a given\n     * account.\n     * @param account The account whose tokens will be burnt.\n     * @param value The amount that will be burnt.\n     */\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0));\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    /**\n     * @dev Internal function that burns an amount of the token of a given\n     * account, deducting from the sender's allowance for said account. Uses the\n     * internal burn function.\n     * Emits an Approval event (reflecting the reduced allowance).\n     * @param account The account whose tokens will be burnt.\n     * @param value The amount that will be burnt.\n     */\n    function _burnFrom(address account, uint256 value) internal {\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\n        _burn(account, value);\n        emit Approval(account, msg.sender, _allowed[account][msg.sender]);\n    }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Burnable.sol\n\npragma solidity ^0.5.0;\n\n\n/**\n * @title Burnable Token\n * @dev Token that can be irreversibly burned (destroyed).\n */\ncontract ERC20Burnable is ERC20 {\n    /**\n     * @dev Burns a specific amount of tokens.\n     * @param value The amount of token to be burned.\n     */\n    function burn(uint256 value) public {\n        _burn(msg.sender, value);\n    }\n\n    /**\n     * @dev Burns a specific amount of tokens from the target address and decrements allowance\n     * @param from address The address which you want to send tokens from\n     * @param value uint256 The amount of token to be burned\n     */\n    function burnFrom(address from, uint256 value) public {\n        _burnFrom(from, value);\n    }\n}\n\n// File: @daostack/arc/contracts/controller/DAOToken.sol\n\npragma solidity ^0.5.4;\n\n\n\n\n\n/**\n * @title DAOToken, base on zeppelin contract.\n * @dev ERC20 compatible token. It is a mintable, burnable token.\n */\n\ncontract DAOToken is ERC20, ERC20Burnable, Ownable {\n\n    string public name;\n    string public symbol;\n    // solhint-disable-next-line const-name-snakecase\n    uint8 public constant decimals = 18;\n    uint256 public cap;\n\n    /**\n    * @dev Constructor\n    * @param _name - token name\n    * @param _symbol - token symbol\n    * @param _cap - token cap - 0 value means no cap\n    */\n    constructor(string memory _name, string memory _symbol, uint256 _cap)\n    public {\n        name = _name;\n        symbol = _symbol;\n        cap = _cap;\n    }\n\n    /**\n     * @dev Function to mint tokens\n     * @param _to The address that will receive the minted tokens.\n     * @param _amount The amount of tokens to mint.\n     */\n    function mint(address _to, uint256 _amount) public onlyOwner returns (bool) {\n        if (cap > 0)\n            require(totalSupply().add(_amount) <= cap);\n        _mint(_to, _amount);\n        return true;\n    }\n}\n\n// File: openzeppelin-solidity/contracts/utils/Address.sol\n\npragma solidity ^0.5.0;\n\n/**\n * Utility library of inline functions on addresses\n */\nlibrary Address {\n    /**\n     * Returns whether the target address is a contract\n     * @dev This function will return false if invoked during the constructor of a contract,\n     * as the code is not actually created until after the constructor finishes.\n     * @param account address of the account to check\n     * @return whether the target address is a contract\n     */\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        // XXX Currently there is no better way to check if there is a contract in an address\n        // than to check the size of the code at that address.\n        // See https://ethereum.stackexchange.com/a/14016/36603\n        // for more details about how this works.\n        // TODO Check this again before the Serenity release, because all addresses will be\n        // contracts then.\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n}\n\n// File: @daostack/arc/contracts/libs/SafeERC20.sol\n\n/*\n\nSafeERC20 by daostack.\nThe code is based on a fix by SECBIT Team.\n\nUSE WITH CAUTION & NO WARRANTY\n\nREFERENCE & RELATED READING\n- https://github.com/ethereum/solidity/issues/4116\n- https://medium.com/@chris_77367/explaining-unexpected-reverts-starting-with-solidity-0-4-22-3ada6e82308c\n- https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n- https://gist.github.com/BrendanChou/88a2eeb80947ff00bcf58ffdafeaeb61\n\n*/\npragma solidity ^0.5.4;\n\n\n\nlibrary SafeERC20 {\n    using Address for address;\n\n    bytes4 constant private TRANSFER_SELECTOR = bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\n    bytes4 constant private TRANSFERFROM_SELECTOR = bytes4(keccak256(bytes(\"transferFrom(address,address,uint256)\")));\n    bytes4 constant private APPROVE_SELECTOR = bytes4(keccak256(bytes(\"approve(address,uint256)\")));\n\n    function safeTransfer(address _erc20Addr, address _to, uint256 _value) internal {\n\n        // Must be a contract addr first!\n        require(_erc20Addr.isContract());\n\n        (bool success, bytes memory returnValue) =\n        // solhint-disable-next-line avoid-low-level-calls\n        _erc20Addr.call(abi.encodeWithSelector(TRANSFER_SELECTOR, _to, _value));\n        // call return false when something wrong\n        require(success);\n        //check return value\n        require(returnValue.length == 0 || (returnValue.length == 32 && (returnValue[31] != 0)));\n    }\n\n    function safeTransferFrom(address _erc20Addr, address _from, address _to, uint256 _value) internal {\n\n        // Must be a contract addr first!\n        require(_erc20Addr.isContract());\n\n        (bool success, bytes memory returnValue) =\n        // solhint-disable-next-line avoid-low-level-calls\n        _erc20Addr.call(abi.encodeWithSelector(TRANSFERFROM_SELECTOR, _from, _to, _value));\n        // call return false when something wrong\n        require(success);\n        //check return value\n        require(returnValue.length == 0 || (returnValue.length == 32 && (returnValue[31] != 0)));\n    }\n\n    function safeApprove(address _erc20Addr, address _spender, uint256 _value) internal {\n\n        // Must be a contract addr first!\n        require(_erc20Addr.isContract());\n\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero.\n        require((_value == 0) || (IERC20(_erc20Addr).allowance(address(this), _spender) == 0));\n\n        (bool success, bytes memory returnValue) =\n        // solhint-disable-next-line avoid-low-level-calls\n        _erc20Addr.call(abi.encodeWithSelector(APPROVE_SELECTOR, _spender, _value));\n        // call return false when something wrong\n        require(success);\n        //check return value\n        require(returnValue.length == 0 || (returnValue.length == 32 && (returnValue[31] != 0)));\n    }\n}\n\n// File: @daostack/arc/contracts/controller/Avatar.sol\n\npragma solidity ^0.5.4;\n\n\n\n\n\n\n\n/**\n * @title An Avatar holds tokens, reputation and ether for a controller\n */\ncontract Avatar is Ownable {\n    using SafeERC20 for address;\n\n    string public orgName;\n    DAOToken public nativeToken;\n    Reputation public nativeReputation;\n\n    event GenericCall(address indexed _contract, bytes _data, uint _value, bool _success);\n    event SendEther(uint256 _amountInWei, address indexed _to);\n    event ExternalTokenTransfer(address indexed _externalToken, address indexed _to, uint256 _value);\n    event ExternalTokenTransferFrom(address indexed _externalToken, address _from, address _to, uint256 _value);\n    event ExternalTokenApproval(address indexed _externalToken, address _spender, uint256 _value);\n    event ReceiveEther(address indexed _sender, uint256 _value);\n    event MetaData(string _metaData);\n\n    /**\n    * @dev the constructor takes organization name, native token and reputation system\n    and creates an avatar for a controller\n    */\n    constructor(string memory _orgName, DAOToken _nativeToken, Reputation _nativeReputation) public {\n        orgName = _orgName;\n        nativeToken = _nativeToken;\n        nativeReputation = _nativeReputation;\n    }\n\n    /**\n    * @dev enables an avatar to receive ethers\n    */\n    function() external payable {\n        emit ReceiveEther(msg.sender, msg.value);\n    }\n\n    /**\n    * @dev perform a generic call to an arbitrary contract\n    * @param _contract  the contract's address to call\n    * @param _data ABI-encoded contract call to call `_contract` address.\n    * @param _value value (ETH) to transfer with the transaction\n    * @return bool    success or fail\n    *         bytes - the return bytes of the called contract's function.\n    */\n    function genericCall(address _contract, bytes memory _data, uint256 _value)\n    public\n    onlyOwner\n    returns(bool success, bytes memory returnValue) {\n      // solhint-disable-next-line avoid-call-value\n        (success, returnValue) = _contract.call.value(_value)(_data);\n        emit GenericCall(_contract, _data, _value, success);\n    }\n\n    /**\n    * @dev send ethers from the avatar's wallet\n    * @param _amountInWei amount to send in Wei units\n    * @param _to send the ethers to this address\n    * @return bool which represents success\n    */\n    function sendEther(uint256 _amountInWei, address payable _to) public onlyOwner returns(bool) {\n        _to.transfer(_amountInWei);\n        emit SendEther(_amountInWei, _to);\n        return true;\n    }\n\n    /**\n    * @dev external token transfer\n    * @param _externalToken the token contract\n    * @param _to the destination address\n    * @param _value the amount of tokens to transfer\n    * @return bool which represents success\n    */\n    function externalTokenTransfer(IERC20 _externalToken, address _to, uint256 _value)\n    public onlyOwner returns(bool)\n    {\n        address(_externalToken).safeTransfer(_to, _value);\n        emit ExternalTokenTransfer(address(_externalToken), _to, _value);\n        return true;\n    }\n\n    /**\n    * @dev external token transfer from a specific account\n    * @param _externalToken the token contract\n    * @param _from the account to spend token from\n    * @param _to the destination address\n    * @param _value the amount of tokens to transfer\n    * @return bool which represents success\n    */\n    function externalTokenTransferFrom(\n        IERC20 _externalToken,\n        address _from,\n        address _to,\n        uint256 _value\n    )\n    public onlyOwner returns(bool)\n    {\n        address(_externalToken).safeTransferFrom(_from, _to, _value);\n        emit ExternalTokenTransferFrom(address(_externalToken), _from, _to, _value);\n        return true;\n    }\n\n    /**\n    * @dev externalTokenApproval approve the spender address to spend a specified amount of tokens\n    *      on behalf of msg.sender.\n    * @param _externalToken the address of the Token Contract\n    * @param _spender address\n    * @param _value the amount of ether (in Wei) which the approval is referring to.\n    * @return bool which represents a success\n    */\n    function externalTokenApproval(IERC20 _externalToken, address _spender, uint256 _value)\n    public onlyOwner returns(bool)\n    {\n        address(_externalToken).safeApprove(_spender, _value);\n        emit ExternalTokenApproval(address(_externalToken), _spender, _value);\n        return true;\n    }\n\n    /**\n    * @dev metaData emits an event with a string, should contain the hash of some meta data.\n    * @param _metaData a string representing a hash of the meta data\n    * @return bool which represents a success\n    */\n    function metaData(string memory _metaData) public onlyOwner returns(bool) {\n        emit MetaData(_metaData);\n        return true;\n    }\n\n\n}\n\n// File: @daostack/arc/contracts/globalConstraints/GlobalConstraintInterface.sol\n\npragma solidity ^0.5.4;\n\n\ncontract GlobalConstraintInterface {\n\n    enum CallPhase { Pre, Post, PreAndPost }\n\n    function pre( address _scheme, bytes32 _params, bytes32 _method ) public returns(bool);\n    function post( address _scheme, bytes32 _params, bytes32 _method ) public returns(bool);\n    /**\n     * @dev when return if this globalConstraints is pre, post or both.\n     * @return CallPhase enum indication  Pre, Post or PreAndPost.\n     */\n    function when() public returns(CallPhase);\n}\n\n// File: @daostack/arc/contracts/controller/ControllerInterface.sol\n\npragma solidity ^0.5.4;\n\n\n\n/**\n * @title Controller contract\n * @dev A controller controls the organizations tokens ,reputation and avatar.\n * It is subject to a set of schemes and constraints that determine its behavior.\n * Each scheme has it own parameters and operation permissions.\n */\ninterface ControllerInterface {\n\n    /**\n     * @dev Mint `_amount` of reputation that are assigned to `_to` .\n     * @param  _amount amount of reputation to mint\n     * @param _to beneficiary address\n     * @return bool which represents a success\n    */\n    function mintReputation(uint256 _amount, address _to, address _avatar)\n    external\n    returns(bool);\n\n    /**\n     * @dev Burns `_amount` of reputation from `_from`\n     * @param _amount amount of reputation to burn\n     * @param _from The address that will lose the reputation\n     * @return bool which represents a success\n     */\n    function burnReputation(uint256 _amount, address _from, address _avatar)\n    external\n    returns(bool);\n\n    /**\n     * @dev mint tokens .\n     * @param  _amount amount of token to mint\n     * @param _beneficiary beneficiary address\n     * @param _avatar address\n     * @return bool which represents a success\n     */\n    function mintTokens(uint256 _amount, address _beneficiary, address _avatar)\n    external\n    returns(bool);\n\n  /**\n   * @dev register or update a scheme\n   * @param _scheme the address of the scheme\n   * @param _paramsHash a hashed configuration of the usage of the scheme\n   * @param _permissions the permissions the new scheme will have\n   * @param _avatar address\n   * @return bool which represents a success\n   */\n    function registerScheme(address _scheme, bytes32 _paramsHash, bytes4 _permissions, address _avatar)\n    external\n    returns(bool);\n\n    /**\n     * @dev unregister a scheme\n     * @param _avatar address\n     * @param _scheme the address of the scheme\n     * @return bool which represents a success\n     */\n    function unregisterScheme(address _scheme, address _avatar)\n    external\n    returns(bool);\n\n    /**\n     * @dev unregister the caller's scheme\n     * @param _avatar address\n     * @return bool which represents a success\n     */\n    function unregisterSelf(address _avatar) external returns(bool);\n\n    /**\n     * @dev add or update Global Constraint\n     * @param _globalConstraint the address of the global constraint to be added.\n     * @param _params the constraint parameters hash.\n     * @param _avatar the avatar of the organization\n     * @return bool which represents a success\n     */\n    function addGlobalConstraint(address _globalConstraint, bytes32 _params, address _avatar)\n    external returns(bool);\n\n    /**\n     * @dev remove Global Constraint\n     * @param _globalConstraint the address of the global constraint to be remove.\n     * @param _avatar the organization avatar.\n     * @return bool which represents a success\n     */\n    function removeGlobalConstraint (address _globalConstraint, address _avatar)\n    external  returns(bool);\n\n  /**\n    * @dev upgrade the Controller\n    *      The function will trigger an event 'UpgradeController'.\n    * @param  _newController the address of the new controller.\n    * @param _avatar address\n    * @return bool which represents a success\n    */\n    function upgradeController(address _newController, Avatar _avatar)\n    external returns(bool);\n\n    /**\n    * @dev perform a generic call to an arbitrary contract\n    * @param _contract  the contract's address to call\n    * @param _data ABI-encoded contract call to call `_contract` address.\n    * @param _avatar the controller's avatar address\n    * @param _value value (ETH) to transfer with the transaction\n    * @return bool -success\n    *         bytes  - the return value of the called _contract's function.\n    */\n    function genericCall(address _contract, bytes calldata _data, Avatar _avatar, uint256 _value)\n    external\n    returns(bool, bytes memory);\n\n  /**\n   * @dev send some ether\n   * @param _amountInWei the amount of ether (in Wei) to send\n   * @param _to address of the beneficiary\n   * @param _avatar address\n   * @return bool which represents a success\n   */\n    function sendEther(uint256 _amountInWei, address payable _to, Avatar _avatar)\n    external returns(bool);\n\n    /**\n    * @dev send some amount of arbitrary ERC20 Tokens\n    * @param _externalToken the address of the Token Contract\n    * @param _to address of the beneficiary\n    * @param _value the amount of ether (in Wei) to send\n    * @param _avatar address\n    * @return bool which represents a success\n    */\n    function externalTokenTransfer(IERC20 _externalToken, address _to, uint256 _value, Avatar _avatar)\n    external\n    returns(bool);\n\n    /**\n    * @dev transfer token \"from\" address \"to\" address\n    *      One must to approve the amount of tokens which can be spend from the\n    *      \"from\" account.This can be done using externalTokenApprove.\n    * @param _externalToken the address of the Token Contract\n    * @param _from address of the account to send from\n    * @param _to address of the beneficiary\n    * @param _value the amount of ether (in Wei) to send\n    * @param _avatar address\n    * @return bool which represents a success\n    */\n    function externalTokenTransferFrom(\n    IERC20 _externalToken,\n    address _from,\n    address _to,\n    uint256 _value,\n    Avatar _avatar)\n    external\n    returns(bool);\n\n    /**\n    * @dev externalTokenApproval approve the spender address to spend a specified amount of tokens\n    *      on behalf of msg.sender.\n    * @param _externalToken the address of the Token Contract\n    * @param _spender address\n    * @param _value the amount of ether (in Wei) which the approval is referring to.\n    * @return bool which represents a success\n    */\n    function externalTokenApproval(IERC20 _externalToken, address _spender, uint256 _value, Avatar _avatar)\n    external\n    returns(bool);\n\n    /**\n    * @dev metaData emits an event with a string, should contain the hash of some meta data.\n    * @param _metaData a string representing a hash of the meta data\n    * @param _avatar Avatar\n    * @return bool which represents a success\n    */\n    function metaData(string calldata _metaData, Avatar _avatar) external returns(bool);\n\n    /**\n     * @dev getNativeReputation\n     * @param _avatar the organization avatar.\n     * @return organization native reputation\n     */\n    function getNativeReputation(address _avatar)\n    external\n    view\n    returns(address);\n\n    function isSchemeRegistered( address _scheme, address _avatar) external view returns(bool);\n\n    function getSchemeParameters(address _scheme, address _avatar) external view returns(bytes32);\n\n    function getGlobalConstraintParameters(address _globalConstraint, address _avatar) external view returns(bytes32);\n\n    function getSchemePermissions(address _scheme, address _avatar) external view returns(bytes4);\n\n    /**\n     * @dev globalConstraintsCount return the global constraint pre and post count\n     * @return uint256 globalConstraintsPre count.\n     * @return uint256 globalConstraintsPost count.\n     */\n    function globalConstraintsCount(address _avatar) external view returns(uint, uint);\n\n    function isGlobalConstraintRegistered(address _globalConstraint, address _avatar) external view returns(bool);\n}\n\n// File: @daostack/arc/contracts/schemes/Agreement.sol\n\npragma solidity ^0.5.4;\n\n/**\n * @title A scheme for conduct ERC20 Tokens auction for reputation\n */\n\n\ncontract Agreement {\n\n    bytes32 private agreementHash;\n\n    modifier onlyAgree(bytes32 _agreementHash) {\n        require(_agreementHash == agreementHash, \"Sender must send the right agreementHash\");\n        _;\n    }\n\n    /**\n     * @dev getAgreementHash\n     * @return bytes32 agreementHash\n     */\n    function getAgreementHash() external  view returns(bytes32)\n    {\n        return agreementHash;\n    }\n\n    /**\n     * @dev setAgreementHash\n     * @param _agreementHash is a hash of agreement required to be added to the TX by participants\n     */\n    function setAgreementHash(bytes32 _agreementHash) internal\n    {\n        require(agreementHash == bytes32(0), \"Can not set agreement twice\");\n        agreementHash = _agreementHash;\n    }\n\n\n}\n\n// File: @daostack/arc/contracts/schemes/Locking4Reputation.sol\n\npragma solidity ^0.5.4;\n\n\n\n/**\n * @title A locker contract\n */\n\ncontract Locking4Reputation is Agreement {\n    using SafeMath for uint256;\n\n    event Redeem(address indexed _beneficiary, uint256 _amount);\n    event Release(bytes32 indexed _lockingId, address indexed _beneficiary, uint256 _amount);\n    event Lock(address indexed _locker, bytes32 indexed _lockingId, uint256 _amount, uint256 _period);\n\n    struct Locker {\n        uint256 amount;\n        uint256 releaseTime;\n    }\n\n    Avatar public avatar;\n\n    // A mapping from lockers addresses their lock balances.\n    mapping(address => mapping(bytes32=>Locker)) public lockers;\n    // A mapping from lockers addresses to their scores.\n    mapping(address => uint) public scores;\n\n    uint256 public totalLocked;\n    uint256 public totalLockedLeft;\n    uint256 public totalScore;\n    uint256 public lockingsCounter; // Total number of lockings\n    uint256 public reputationReward;\n    uint256 public reputationRewardLeft;\n    uint256 public lockingEndTime;\n    uint256 public maxLockingPeriod;\n    uint256 public lockingStartTime;\n    uint256 public redeemEnableTime;\n\n    /**\n     * @dev redeem reputation function\n     * @param _beneficiary the beneficiary for the release\n     * @return uint256 reputation rewarded\n     */\n    function redeem(address _beneficiary) public returns(uint256 reputation) {\n        // solhint-disable-next-line not-rely-on-time\n        require(block.timestamp > redeemEnableTime, \"now > redeemEnableTime\");\n        require(scores[_beneficiary] > 0, \"score should be > 0\");\n        uint256 score = scores[_beneficiary];\n        scores[_beneficiary] = 0;\n        uint256 repRelation = score.mul(reputationReward);\n        reputation = repRelation.div(totalScore);\n\n        //check that the reputation is sum zero\n        reputationRewardLeft = reputationRewardLeft.sub(reputation);\n        require(\n        ControllerInterface(\n        avatar.owner())\n        .mintReputation(reputation, _beneficiary, address(avatar)), \"mint reputation should succeed\");\n\n        emit Redeem(_beneficiary, reputation);\n    }\n\n    /**\n     * @dev release function\n     * @param _beneficiary the beneficiary for the release\n     * @param _lockingId the locking id to release\n     * @return bool\n     */\n    function _release(address _beneficiary, bytes32 _lockingId) internal returns(uint256 amount) {\n        Locker storage locker = lockers[_beneficiary][_lockingId];\n        require(locker.amount > 0, \"amount should be > 0\");\n        amount = locker.amount;\n        locker.amount = 0;\n        // solhint-disable-next-line not-rely-on-time\n        require(block.timestamp > locker.releaseTime, \"check the lock period pass\");\n        totalLockedLeft = totalLockedLeft.sub(amount);\n\n        emit Release(_lockingId, _beneficiary, amount);\n    }\n\n    /**\n     * @dev lock function\n     * @param _amount the amount to lock\n     * @param _period the locking period\n     * @param _locker the locker\n     * @param _numerator price numerator\n     * @param _denominator price denominator\n     * @return lockingId\n     */\n    function _lock(\n        uint256 _amount,\n        uint256 _period,\n        address _locker,\n        uint256 _numerator,\n        uint256 _denominator,\n        bytes32 _agreementHash)\n        internal\n        onlyAgree(_agreementHash)\n        returns(bytes32 lockingId)\n        {\n        require(_amount > 0, \"locking amount should be > 0\");\n        require(_period <= maxLockingPeriod, \"locking period should be <= maxLockingPeriod\");\n        require(_period > 0, \"locking period should be > 0\");\n        // solhint-disable-next-line not-rely-on-time\n        require(now <= lockingEndTime, \"lock should be within the allowed locking period\");\n        // solhint-disable-next-line not-rely-on-time\n        require(now >= lockingStartTime, \"lock should start after lockingStartTime\");\n\n        lockingId = keccak256(abi.encodePacked(address(this), lockingsCounter));\n        lockingsCounter = lockingsCounter.add(1);\n\n        Locker storage locker = lockers[_locker][lockingId];\n        locker.amount = _amount;\n        // solhint-disable-next-line not-rely-on-time\n        locker.releaseTime = now + _period;\n        totalLocked = totalLocked.add(_amount);\n        totalLockedLeft = totalLockedLeft.add(_amount);\n        uint256 score = _period.mul(_amount).mul(_numerator).div(_denominator);\n        require(score > 0, \"score must me > 0\");\n        scores[_locker] = scores[_locker].add(score);\n        //verify that redeem will not overflow for this locker\n        require((scores[_locker] * reputationReward)/scores[_locker] == reputationReward,\n        \"score is too high\");\n        totalScore = totalScore.add(score);\n\n        emit Lock(_locker, lockingId, _amount, _period);\n    }\n\n    /**\n     * @dev _initialize\n     * @param _avatar the avatar to mint reputation from\n     * @param _reputationReward the total reputation this contract will reward\n     *        for eth/token locking\n     * @param _lockingStartTime the locking start time.\n     * @param _lockingEndTime the locking end time.\n     *        locking is disable after this time.\n     * @param _redeemEnableTime redeem enable time .\n     *        redeem reputation can be done after this time.\n     * @param _maxLockingPeriod maximum locking period allowed.\n     */\n    function _initialize(\n        Avatar _avatar,\n        uint256 _reputationReward,\n        uint256 _lockingStartTime,\n        uint256 _lockingEndTime,\n        uint256 _redeemEnableTime,\n        uint256 _maxLockingPeriod,\n        bytes32 _agreementHash )\n    internal\n    {\n        require(avatar == Avatar(0), \"can be called only one time\");\n        require(_avatar != Avatar(0), \"avatar cannot be zero\");\n        require(_lockingEndTime > _lockingStartTime, \"locking end time should be greater than locking start time\");\n        require(_redeemEnableTime >= _lockingEndTime, \"redeemEnableTime >= lockingEndTime\");\n\n        reputationReward = _reputationReward;\n        reputationRewardLeft = _reputationReward;\n        lockingEndTime = _lockingEndTime;\n        maxLockingPeriod = _maxLockingPeriod;\n        avatar = _avatar;\n        lockingStartTime = _lockingStartTime;\n        redeemEnableTime = _redeemEnableTime;\n        super.setAgreementHash(_agreementHash);\n    }\n\n}\n\n// File: @daostack/arc/contracts/schemes/PriceOracleInterface.sol\n\npragma solidity ^0.5.4;\n\ninterface PriceOracleInterface {\n\n    function getPrice(address token) external view returns (uint, uint);\n\n}\n\n// File: @daostack/arc/contracts/schemes/LockingToken4Reputation.sol\n\npragma solidity ^0.5.4;\n\n\n\n\n\n/**\n * @title A scheme for locking ERC20 Tokens for reputation\n */\n\ncontract LockingToken4Reputation is Locking4Reputation {\n    using SafeERC20 for address;\n\n    PriceOracleInterface public priceOracleContract;\n    //      lockingId => token\n    mapping(bytes32   => address) public lockedTokens;\n\n    event LockToken(bytes32 indexed _lockingId, address indexed _token, uint256 _numerator, uint256 _denominator);\n\n    /**\n     * @dev initialize\n     * @param _avatar the avatar to mint reputation from\n     * @param _reputationReward the total reputation this contract will reward\n     *        for the token locking\n     * @param _lockingStartTime locking starting period time.\n     * @param _lockingEndTime the locking end time.\n     *        locking is disable after this time.\n     * @param _redeemEnableTime redeem enable time .\n     *        redeem reputation can be done after this time.\n     * @param _maxLockingPeriod maximum locking period allowed.\n     * @param _priceOracleContract the price oracle contract which the locked token will be\n     *        validated against\n     */\n    function initialize(\n        Avatar _avatar,\n        uint256 _reputationReward,\n        uint256 _lockingStartTime,\n        uint256 _lockingEndTime,\n        uint256 _redeemEnableTime,\n        uint256 _maxLockingPeriod,\n        PriceOracleInterface _priceOracleContract,\n        bytes32 _agreementHash)\n    external\n    {\n        priceOracleContract = _priceOracleContract;\n        super._initialize(\n        _avatar,\n        _reputationReward,\n        _lockingStartTime,\n        _lockingEndTime,\n        _redeemEnableTime,\n        _maxLockingPeriod,\n        _agreementHash);\n    }\n\n    /**\n     * @dev release locked tokens\n     * @param _beneficiary the release _beneficiary\n     * @param _lockingId the locking id\n     * @return bool\n     */\n    function release(address _beneficiary, bytes32 _lockingId) public returns(bool) {\n        uint256 amount = super._release(_beneficiary, _lockingId);\n        lockedTokens[_lockingId].safeTransfer(_beneficiary, amount);\n\n        return true;\n    }\n\n    /**\n     * @dev lock function\n     * @param _amount the amount to lock\n     * @param _period the locking period\n     * @param _token the token to lock - this should be whitelisted at the priceOracleContract\n     * @return lockingId\n     */\n    function lock(uint256 _amount,\n        uint256 _period,\n        address _token,\n        bytes32 _agreementHash)\n    public returns(bytes32 lockingId) {\n\n        uint256 numerator;\n        uint256 denominator;\n\n        (numerator, denominator) = priceOracleContract.getPrice(_token);\n\n        require(numerator > 0, \"numerator should be > 0\");\n        require(denominator > 0, \"denominator should be > 0\");\n\n        _token.safeTransferFrom(msg.sender, address(this), _amount);\n\n        lockingId = super._lock(_amount, _period, msg.sender, numerator, denominator, _agreementHash);\n\n        lockedTokens[lockingId] = _token;\n\n        emit LockToken(lockingId, _token, numerator, denominator);\n    }\n}\n\n// File: contracts/schemes/bootstrap/DxLockWhitelisted4Rep.sol\n\npragma solidity ^0.5.4;\n\n\n/**\n * @title Scheme for locking GNO tokens for reputation\n */\ncontract DxLockWhitelisted4Rep is LockingToken4Reputation {\n    // TODO: Extend the new LockWhitelisted4Rep once it's implemented\n    constructor() public {}\n}",
  "abi": "[{\"constant\":true,\"inputs\":[],\"name\":\"redeemEnableTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"priceOracleContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockingStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"avatar\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAgreementHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"scores\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_avatar\",\"type\":\"address\"},{\"name\":\"_reputationReward\",\"type\":\"uint256\"},{\"name\":\"_lockingStartTime\",\"type\":\"uint256\"},{\"name\":\"_lockingEndTime\",\"type\":\"uint256\"},{\"name\":\"_redeemEnableTime\",\"type\":\"uint256\"},{\"name\":\"_maxLockingPeriod\",\"type\":\"uint256\"},{\"name\":\"_priceOracleContract\",\"type\":\"address\"},{\"name\":\"_agreementHash\",\"type\":\"bytes32\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"lockers\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"releaseTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_period\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_agreementHash\",\"type\":\"bytes32\"}],\"name\":\"lock\",\"outputs\":[{\"name\":\"lockingId\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"redeem\",\"outputs\":[{\"name\":\"reputation\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockingEndTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reputationRewardLeft\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxLockingPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalScore\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockingsCounter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalLockedLeft\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_lockingId\",\"type\":\"bytes32\"}],\"name\":\"release\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"lockedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reputationReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_lockingId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_numerator\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_denominator\",\"type\":\"uint256\"}],\"name\":\"LockToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Redeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_lockingId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Release\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_locker\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_lockingId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_period\",\"type\":\"uint256\"}],\"name\":\"Lock\",\"type\":\"event\"}]",
  "bytecode": "608060405234801561001057600080fd5b5061169c806100206000396000f3fe608060405234801561001057600080fd5b5060043610610149576000357c01000000000000000000000000000000000000000000000000000000009004806395a2251f116100ca578063c3201add1161008e578063c3201add146102ea578063c348a24b146102f2578063d7c2eec7146102fa578063e8d335881461033a578063ed1ff6d81461035757610149565b806395a2251f146102a4578063a8c33017146102ca578063afe0e33c146102d2578063bf0df445146102da578063c006719f146102e257610149565b8063696da92111610111578063696da921146101a457806376dd110f146101ac5780637ad88799146101d2578063838057421461022757806394d0cb6e1461026c57610149565b80633d1678f41461014e578063457454db1461016857806355bfec881461018c57806356891412146101945780635aef7de61461019c575b600080fd5b61015661035f565b60408051918252519081900360200190f35b610170610365565b60408051600160a060020a039092168252519081900360200190f35b610156610374565b61015661037a565b610170610380565b61015661038f565b610156600480360360208110156101c257600080fd5b5035600160a060020a0316610395565b61022560048036036101008110156101e957600080fd5b50600160a060020a03813581169160208101359160408201359160608101359160808201359160a08101359160c0820135169060e001356103a7565b005b6102536004803603604081101561023d57600080fd5b50600160a060020a0381351690602001356103e8565b6040805192835260208301919091528051918290030190f35b6101566004803603608081101561028257600080fd5b50803590602081013590600160a060020a03604082013516906060013561040c565b610156600480360360208110156102ba57600080fd5b5035600160a060020a0316610606565b6101566108fe565b610156610904565b61015661090a565b610156610910565b610156610916565b61015661091c565b6103266004803603604081101561031057600080fd5b50600160a060020a038135169060200135610922565b604080519115158252519081900360200190f35b6101706004803603602081101561035057600080fd5b5035610967565b610156610982565b600d5481565b600e54600160a060020a031681565b600c5481565b60045481565b600154600160a060020a031681565b60005490565b60036020526000908152604090205481565b600e805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0384161790556103de88888888888887610988565b5050505050505050565b60026020908152600092835260408084209091529082529020805460019091015482565b600e54604080517f41976e09000000000000000000000000000000000000000000000000000000008152600160a060020a03858116600483015282516000948594859493909116926341976e099260248083019392829003018186803b15801561047557600080fd5b505afa158015610489573d6000803e3d6000fd5b505050506040513d604081101561049f57600080fd5b508051602090910151909250905060008211610505576040805160e560020a62461bcd02815260206004820152601760248201527f6e756d657261746f722073686f756c64206265203e2030000000000000000000604482015290519081900360640190fd5b6000811161055d576040805160e560020a62461bcd02815260206004820152601960248201527f64656e6f6d696e61746f722073686f756c64206265203e203000000000000000604482015290519081900360640190fd5b610578600160a060020a03861633308a63ffffffff610b2416565b610586878733858589610d1c565b6000818152600f6020908152604091829020805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a038a16908117909155825186815291820185905282519396509286927f09ae2accb7909b2605e5e74e2584c7f5aa396bc6ab76290633ae3819ff650e9f928290030190a35050949350505050565b600d546000904211610662576040805160e560020a62461bcd02815260206004820152601660248201527f6e6f77203e2072656465656d456e61626c6554696d6500000000000000000000604482015290519081900360640190fd5b600160a060020a038216600090815260036020526040812054116106d0576040805160e560020a62461bcd02815260206004820152601360248201527f73636f72652073686f756c64206265203e203000000000000000000000000000604482015290519081900360640190fd5b600160a060020a038216600090815260036020526040812080549082905560085490919061070590839063ffffffff61112e16565b905061071c6006548261116090919063ffffffff16565b600954909350610732908463ffffffff61118416565b600955600154604080517f8da5cb5b0000000000000000000000000000000000000000000000000000000081529051600160a060020a0390921691638da5cb5b91600480820192602092909190829003018186803b15801561079357600080fd5b505afa1580156107a7573d6000803e3d6000fd5b505050506040513d60208110156107bd57600080fd5b5051600154604080517feaf994b200000000000000000000000000000000000000000000000000000000815260048101879052600160a060020a03888116602483015292831660448201529051919092169163eaf994b29160648083019260209291908290030181600087803b15801561083657600080fd5b505af115801561084a573d6000803e3d6000fd5b505050506040513d602081101561086057600080fd5b505115156108b8576040805160e560020a62461bcd02815260206004820152601e60248201527f6d696e742072657075746174696f6e2073686f756c6420737563636565640000604482015290519081900360640190fd5b604080518481529051600160a060020a038616917f222838db2794d11532d940e8dec38ae307ed0b63cd97c233322e221f998767a6919081900360200190a25050919050565b600a5481565b60095481565b600b5481565b60065481565b60075481565b60055481565b60008061092f8484611199565b6000848152600f602052604090205490915061095b90600160a060020a0316858363ffffffff6112d516565b60019150505b92915050565b600f60205260009081526040902054600160a060020a031681565b60085481565b600154600160a060020a0316156109e9576040805160e560020a62461bcd02815260206004820152601b60248201527f63616e2062652063616c6c6564206f6e6c79206f6e652074696d650000000000604482015290519081900360640190fd5b600160a060020a0387161515610a49576040805160e560020a62461bcd02815260206004820152601560248201527f6176617461722063616e6e6f74206265207a65726f0000000000000000000000604482015290519081900360640190fd5b848411610a8a5760405160e560020a62461bcd02815260040180806020018281038252603a8152602001806115c1603a913960400191505060405180910390fd5b83831015610acc5760405160e560020a62461bcd02815260040180806020018281038252602281526020018061164f6022913960400191505060405180910390fd5b60088690556009869055600a849055600b8290556001805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a038916179055600c859055600d839055610b1b816114cc565b50505050505050565b610b3684600160a060020a0316611529565b1515610b4157600080fd5b6000606085600160a060020a03166060604051908101604052806025815260200161154460259139805160209182012060408051600160a060020a03808b166024830152891660448201526064808201899052825180830390910181526084909101825292830180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff00000000000000000000000000000000000000000000000000000000909316929092178252518251909182918083835b60208310610c1c5780518252601f199092019160209182019101610bfd565b6001836020036101000a0380198251168184511680821785525050505050509050019150506000604051808303816000865af19150503d8060008114610c7e576040519150601f19603f3d011682016040523d82523d6000602084013e610c83565b606091505b5091509150811515610c9457600080fd5b80511580610d09575080516020148015610d09575080601f815181101515610cb857fe5b6020910101517f010000000000000000000000000000000000000000000000000000000000000090819004027fff000000000000000000000000000000000000000000000000000000000000001615155b1515610d1457600080fd5b505050505050565b6000805482908114610d625760405160e560020a62461bcd0281526004018080602001828103825260288152602001806115fb6028913960400191505060405180910390fd5b60008811610dba576040805160e560020a62461bcd02815260206004820152601c60248201527f6c6f636b696e6720616d6f756e742073686f756c64206265203e203000000000604482015290519081900360640190fd5b600b54871115610dfe5760405160e560020a62461bcd02815260040180806020018281038252602c815260200180611623602c913960400191505060405180910390fd5b60008711610e56576040805160e560020a62461bcd02815260206004820152601c60248201527f6c6f636b696e6720706572696f642073686f756c64206265203e203000000000604482015290519081900360640190fd5b600a54421115610e9a5760405160e560020a62461bcd0281526004018080602001828103825260308152602001806115916030913960400191505060405180910390fd5b600c54421015610ede5760405160e560020a62461bcd0281526004018080602001828103825260288152602001806115696028913960400191505060405180910390fd5b600754604080516c010000000000000000000000003002602080830191909152603480830185905283518084039091018152605490920190925280519101209250610f3090600163ffffffff61153116565b600755600160a060020a038616600090815260026020908152604080832085845290915290208881554288016001820155600454610f74908a63ffffffff61153116565b600455600554610f8a908a63ffffffff61153116565b6005556000610fbf86610fb389610fa78d8f63ffffffff61112e16565b9063ffffffff61112e16565b9063ffffffff61116016565b905060008111611019576040805160e560020a62461bcd02815260206004820152601160248201527f73636f7265206d757374206d65203e2030000000000000000000000000000000604482015290519081900360640190fd5b600160a060020a038816600090815260036020526040902054611042908263ffffffff61153116565b600160a060020a03891660009081526003602052604090208190556008549081810281151561106d57fe5b04146110c3576040805160e560020a62461bcd02815260206004820152601160248201527f73636f726520697320746f6f2068696768000000000000000000000000000000604482015290519081900360640190fd5b6006546110d6908263ffffffff61153116565b600655604080518b8152602081018b905281518692600160a060020a038c16927fd173f98f4a2080eab40a0bff4d9a575753270cb2401c74efdec1feb0ba31b426929081900390910190a35050509695505050505050565b600082151561113f57506000610961565b82820282848281151561114e57fe5b041461115957600080fd5b9392505050565b600080821161116e57600080fd5b6000828481151561117b57fe5b04949350505050565b60008282111561119357600080fd5b50900390565b600160a060020a0382166000908152600260209081526040808320848452909152812080548210611214576040805160e560020a62461bcd02815260206004820152601460248201527f616d6f756e742073686f756c64206265203e2030000000000000000000000000604482015290519081900360640190fd5b80546000825560018201549092504211611278576040805160e560020a62461bcd02815260206004820152601a60248201527f636865636b20746865206c6f636b20706572696f642070617373000000000000604482015290519081900360640190fd5b60055461128b908363ffffffff61118416565b600555604080518381529051600160a060020a0386169185917fcb7ab693259d2332e08e7666832578144deb74443e37a762847e848793fc29819181900360200190a35092915050565b6112e783600160a060020a0316611529565b15156112f257600080fd5b604080518082018252601981527f7472616e7366657228616464726573732c75696e7432353629000000000000006020918201528151600160a060020a0385811660248301526044808301869052845180840390910181526064909201845291810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fa9059cbb000000000000000000000000000000000000000000000000000000001781529251815160009460609489169392918291908083835b602083106113cd5780518252601f1990920191602091820191016113ae565b6001836020036101000a0380198251168184511680821785525050505050509050019150506000604051808303816000865af19150503d806000811461142f576040519150601f19603f3d011682016040523d82523d6000602084013e611434565b606091505b509150915081151561144557600080fd5b805115806114ba5750805160201480156114ba575080601f81518110151561146957fe5b6020910101517f010000000000000000000000000000000000000000000000000000000000000090819004027fff000000000000000000000000000000000000000000000000000000000000001615155b15156114c557600080fd5b5050505050565b60005415611524576040805160e560020a62461bcd02815260206004820152601b60248201527f43616e206e6f74207365742061677265656d656e742074776963650000000000604482015290519081900360640190fd5b600055565b6000903b1190565b60008282018381101561115957600080fdfe7472616e7366657246726f6d28616464726573732c616464726573732c75696e74323536296c6f636b2073686f756c64207374617274206166746572206c6f636b696e67537461727454696d656c6f636b2073686f756c642062652077697468696e2074686520616c6c6f776564206c6f636b696e6720706572696f646c6f636b696e6720656e642074696d652073686f756c642062652067726561746572207468616e206c6f636b696e672073746172742074696d6553656e646572206d7573742073656e64207468652072696768742061677265656d656e74486173686c6f636b696e6720706572696f642073686f756c64206265203c3d206d61784c6f636b696e67506572696f6472656465656d456e61626c6554696d65203e3d206c6f636b696e67456e6454696d65a165627a7a7230582014a2c043901f226c2abf683370cd7b5d1c78b4456b84ff4c6aa267e4608890990029"
}