{
  "address": "0x18361baeb2afd717e36e3c9b44ad12d084911ae0",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "Gilgamesh Token",
  "contractName": "GilgameshToken",
  "compilerVersion": "v0.4.19+commit.c4cbbb05",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2018-01-13\n*/\n\npragma solidity ^0.4.19;\n\n\ncontract SafeMath {\n\n\tfunction safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tuint256 c = a + b;\n\t\tassert(c >= a && c >= b);\n\t\treturn c;\n\t}\n\n\tfunction safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tassert(b <= a);\n\t\treturn a - b;\n\t}\n\n\tfunction safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tuint256 c = a * b;\n\t\tassert(a == 0 || c / a == b);\n\t\treturn c;\n\t}\n\n\tfunction safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tassert(b > 0);\n\t\tuint256 c = a / b;\n\t\tassert(a == b * c + a % b);\n\t\treturn c;\n\t}\n}\n\n\ncontract ERC20Token {\n\n\t// --------\n\t//\tEvents\n\t// ---------\n\n\t// publicize actions to external listeners.\n\t/// @notice Triggered when tokens are transferred.\n\tevent Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n\t/// @notice Triggered whenever approve(address _spender, uint256 _value) is called.\n\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n\t// --------\n\t//\tGetters\n\t// ---------\n\n\t/// @notice Get the total amount of token supply\n\tfunction totalSupply() public constant returns (uint256 _totalSupply);\n\n\t/// @notice Get the account balance of address _owner\n\t/// @param _owner The address from which the balance will be retrieved\n\t/// @return The balance\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance);\n\n\t/// @param _owner The address of the account owning tokens\n\t/// @param _spender The address of the account able to transfer the tokens\n\t/// @return Amount of remaining tokens allowed to spent by the _spender from _owner account\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n\n\t// --------\n\t//\tActions\n\t// ---------\n\n\t/// @notice send _value amount of tokens to _to address from msg.sender address\n\t/// @param _to The address of the recipient\n\t/// @param _value The amount of token to be transferred\n\t/// @return a boolean - whether the transfer was successful or not\n\tfunction transfer(address _to, uint256 _value) public returns (bool success);\n\n\t/// @notice send _value amount of tokens to _to address from _from address, on the condition it is approved by _from\n\t/// @param _from The address of the sender\n\t/// @param _to The address of the recipient\n\t/// @param _value The amount of token to be transferred\n\t/// @return a boolean - whether the transfer was successful or not\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n\n\t/// @notice msg.sender approves _spender to spend multiple times up to _value amount of tokens\n\t/// If this function is called again it overwrites the current allowance with _value.\n\t/// @param _spender The address of the account able to transfer the tokens\n\t/// @param _value The amount of tokens to be approved for transfer\n\t/// @return a boolean - whether the approval was successful or not\n\tfunction approve(address _spender, uint256 _value) public returns (bool success);\n}\n\n\ncontract SecureERC20Token is ERC20Token {\n\n\t// State variables\n\n\t// balances dictionary that maps addresses to balances\n\tmapping (address => uint256) private balances;\n\n\t// locked account dictionary that maps addresses to boolean\n\tmapping (address => bool) private lockedAccounts;\n\n\t // allowed dictionary that allow transfer rights to other addresses.\n\tmapping (address => mapping(address => uint256)) private allowed;\n\n\t// The Token's name: e.g. 'Gilgamesh Tokens'\n\tstring public name;\n\n\t// Symbol of the token: e.q 'GIL'\n\tstring public symbol;\n\n\t// Number of decimals of the smallest unit: e.g '18'\n\tuint8 public decimals;\n\n\t// Number of total tokens: e,g: '1000000000'\n\tuint256 public totalSupply;\n\n\t// token version\n\tuint8 public version = 1;\n\n\t// address of the contract admin\n\taddress public admin;\n\n\t// address of the contract minter\n\taddress public minter;\n\n\t// creationBlock is the block number that the Token was created\n\tuint256 public creationBlock;\n\n\t// Flag that determines if the token is transferable or not\n\t// disable actionable ERC20 token methods\n\tbool public isTransferEnabled;\n\n\tevent AdminOwnershipTransferred(address indexed previousAdmin, address indexed newAdmin);\n\tevent MinterOwnershipTransferred(address indexed previousMinter, address indexed newMinter);\n\tevent TransferStatus(address indexed sender, bool status);\n\n\t// @notice Constructor to create Gilgamesh ERC20 Token\n\tfunction SecureERC20Token(\n\t\tuint256 initialSupply,\n\t\tstring _name,\n\t\tstring _symbol,\n\t\tuint8 _decimals,\n\t\tbool _isTransferEnabled\n\t) public {\n\t\t// assign all tokens to the deployer\n\t\tbalances[msg.sender] = initialSupply;\n\n\t\ttotalSupply = initialSupply; // set initial supply of Tokens\n\t\tname = _name;\t\t\t\t // set token name\n\t\tdecimals = _decimals;\t\t // set the decimals\n\t\tsymbol = _symbol;\t\t\t // set the token symbol\n\t\tisTransferEnabled = _isTransferEnabled;\n\t\tcreationBlock = block.number;\n\t\tminter = msg.sender;\t\t// by default the contract deployer is the minter\n\t\tadmin = msg.sender;\t\t\t// by default the contract deployer is the admin\n\t}\n\n\t// --------------\n\t// ERC20 Methods\n\t// --------------\n\n\t/// @notice Get the total amount of token supply\n\tfunction totalSupply() public constant returns (uint256 _totalSupply) {\n\t\treturn totalSupply;\n\t}\n\n\t/// @notice Get the account balance of address _owner\n\t/// @param _owner The address from which the balance will be retrieved\n\t/// @return The balance\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance) {\n\t\treturn balances[_owner];\n\t}\n\n\t/// @notice send _value amount of tokens to _to address from msg.sender address\n\t/// @param _to The address of the recipient\n\t/// @param _value The amount of token to be transferred\n\t/// @return a boolean - whether the transfer was successful or not\n\tfunction transfer(address _to, uint256 _value) public returns (bool success) {\n\t\t// if transfer is not enabled throw an error and stop execution.\n\t\trequire(isTransferEnabled);\n\n\t\t// continue with transfer\n\t\treturn doTransfer(msg.sender, _to, _value);\n\t}\n\n\t/// @notice send _value amount of tokens to _to address from _from address, on the condition it is approved by _from\n\t/// @param _from The address of the sender\n\t/// @param _to The address of the recipient\n\t/// @param _value The amount of token to be transferred\n\t/// @return a boolean - whether the transfer was successful or not\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n\t\t// if transfer is not enabled throw an error and stop execution.\n\t\trequire(isTransferEnabled);\n\n\t\t// if from allowed transferrable rights to sender for amount _value\n\t\tif (allowed[_from][msg.sender] < _value) revert();\n\n\t\t// subtreact allowance\n\t\tallowed[_from][msg.sender] -= _value;\n\n\t\t// continue with transfer\n\t\treturn doTransfer(_from, _to, _value);\n\t}\n\n\t/// @notice msg.sender approves _spender to spend _value tokens\n\t/// @param _spender The address of the account able to transfer the tokens\n\t/// @param _value The amount of tokens to be approved for transfer\n\t/// @return a boolean - whether the approval was successful or not\n\tfunction approve(address _spender, uint256 _value)\n\tpublic\n\tis_not_locked(_spender)\n\treturns (bool success) {\n\t\t// if transfer is not enabled throw an error and stop execution.\n\t\trequire(isTransferEnabled);\n\n\t\t// user can only reassign an allowance of 0 if value is greater than 0\n\t\t// sender should first change the allowance to zero by calling approve(_spender, 0)\n\t\t// race condition is explained below:\n\t\t// https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\t\tif(_value != 0 && allowed[msg.sender][_spender] != 0) revert();\n\n\t\tif (\n\t\t\t// if sender balance is less than _value return false;\n\t\t\tbalances[msg.sender] < _value\n\t\t) {\n\t\t\t// transaction failure\n\t\t\treturn false;\n\t\t}\n\n\t\t// allow transfer rights from msg.sender to _spender for _value token amount\n\t\tallowed[msg.sender][_spender] = _value;\n\n\t\t// log approval event\n\t\tApproval(msg.sender, _spender, _value);\n\n\t\t// transaction successful\n\t\treturn true;\n\t}\n\n\t/// @param _owner The address of the account owning tokens\n\t/// @param _spender The address of the account able to transfer the tokens\n\t/// @return Amount of remaining tokens allowed to spent by the _spender from _owner account\n\tfunction allowance(address _owner, address _spender)\n\tpublic\n\tconstant\n\treturns (uint256 remaining) {\n\t\treturn allowed[_owner][_spender];\n\t}\n\n\t// --------------\n\t// Contract Custom Methods - Non ERC20\n\t// --------------\n\n\t/* Public Methods */\n\n\t/// @notice only the admin is allowed to lock accounts.\n\t/// @param _owner the address of the account to be locked\n\tfunction lockAccount(address _owner)\n\tpublic\n\tis_not_locked(_owner)\n\tvalidate_address(_owner)\n\tonlyAdmin {\n\t\tlockedAccounts[_owner] = true;\n\t}\n\n\t/// @notice only the admin is allowed to unlock accounts.\n\t/// @param _owner the address of the account to be unlocked\n\tfunction unlockAccount(address _owner)\n\tpublic\n\tis_locked(_owner)\n\tvalidate_address(_owner)\n\tonlyAdmin {\n\t\tlockedAccounts[_owner] = false;\n\t}\n\n\t/// @notice only the admin is allowed to burn tokens - in case if the user haven't verified identity or performed fraud\n\t/// @param _owner the address of the account that their tokens needs to be burnt\n\tfunction burnUserTokens(address _owner)\n\tpublic\n\tvalidate_address(_owner)\n\tonlyAdmin {\n\t\t// if user balance is 0 ignore\n\t\tif (balances[_owner] == 0) revert();\n\n\t\t// should never happen but just in case\n\t\tif (balances[_owner] > totalSupply) revert();\n\n\t\t// decrease the total supply\n\t\ttotalSupply -= balances[_owner];\n\n\t\t// burn it all\n\t\tbalances[_owner] = 0;\n\t}\n\n\t/// @notice only the admin is allowed to change the minter.\n\t/// @param newMinter the address of the minter\n\tfunction changeMinter(address newMinter)\n\tpublic\n\tvalidate_address(newMinter)\n\tonlyAdmin {\n\t\tif (minter == newMinter) revert();\n\t\tMinterOwnershipTransferred(minter, newMinter);\n\t\tminter = newMinter;\n\t}\n\n\t/// @notice only the admin is allowed to change the admin.\n\t/// @param newAdmin the address of the new admin\n\tfunction changeAdmin(address newAdmin)\n\tpublic\n\tvalidate_address(newAdmin)\n\tonlyAdmin {\n\t\tif (admin == newAdmin) revert();\n\t\tAdminOwnershipTransferred(admin, newAdmin);\n\t\tadmin = newAdmin;\n\t}\n\n\t/// @notice mint new tokens by the minter\n\t/// @param _owner the owner of the newly tokens\n\t/// @param _amount the amount of new token to be minted\n\tfunction mint(address _owner, uint256 _amount)\n\tpublic\n\tonlyMinter\n\tvalidate_address(_owner)\n\treturns (bool success) {\n\t\t// preventing overflow on the totalSupply\n\t\tif (totalSupply + _amount < totalSupply) revert();\n\n\t\t// preventing overflow on the receiver account\n\t\tif (balances[_owner] + _amount < balances[_owner]) revert();\n\n\t\t// increase the total supply\n\t\ttotalSupply += _amount;\n\n\t\t// assign the additional supply to the target account.\n\t\tbalances[_owner] += _amount;\n\n\t\t// contract has minted new token by the minter\n\t\tTransfer(0x0, msg.sender, _amount);\n\n\t\t// minter has transferred token to the target account\n\t\tTransfer(msg.sender, _owner, _amount);\n\n\t\treturn true;\n\t}\n\n\t/// @notice Enables token holders to transfer their tokens freely if true\n\t/// after the crowdsale is finished it will be true\n\t/// for security reasons can be switched to false\n\t/// @param _isTransferEnabled boolean\n\tfunction enableTransfers(bool _isTransferEnabled) public onlyAdmin {\n\t\tisTransferEnabled = _isTransferEnabled;\n\t\tTransferStatus(msg.sender, isTransferEnabled);\n\t}\n\n\t/* Internal Methods */\n\n\t///\t@dev this is the actual transfer function and it can only be called internally\n\t/// @notice send _value amount of tokens to _to address from _from address\n\t/// @param _to The address of the recipient\n\t/// @param _value The amount of token to be transferred\n\t/// @return a boolean - whether the transfer was successful or not\n\tfunction doTransfer(address _from, address _to, uint256 _value)\n\tvalidate_address(_to)\n\tis_not_locked(_from)\n\tinternal\n\treturns (bool success) {\n\t\tif (\n\t\t\t// if the value is not more than 0 fail\n\t\t\t_value <= 0 ||\n\t\t\t// if the sender doesn't have enough balance fail\n\t\t\tbalances[_from] < _value ||\n\t\t\t// if token supply overflows (total supply exceeds 2^256 - 1) fail\n\t\t\tbalances[_to] + _value < balances[_to]\n\t\t) {\n\t\t\t// transaction failed\n\t\t\treturn false;\n\t\t}\n\n\t\t// decrease the number of tokens from sender address.\n\t\tbalances[_from] -= _value;\n\n\t\t// increase the number of tokens for _to address\n\t\tbalances[_to] += _value;\n\n\t\t// log transfer event\n\t\tTransfer(_from, _to, _value);\n\n\t\t// transaction successful\n\t\treturn true;\n\t}\n\n\t// --------------\n\t// Modifiers\n\t// --------------\n\tmodifier onlyMinter() {\n\t\t// if sender is not the minter stop the execution\n\t\tif (msg.sender != minter) revert();\n\t\t// if the sender is the minter continue\n\t\t_;\n\t}\n\n\tmodifier onlyAdmin() {\n\t\t// if sender is not the admin stop the execution\n\t\tif (msg.sender != admin) revert();\n\t\t// if the sender is the admin continue\n\t\t_;\n\t}\n\n\tmodifier validate_address(address _address) {\n\t\tif (_address == address(0)) revert();\n\t\t_;\n\t}\n\n\tmodifier is_not_locked(address _address) {\n\t\tif (lockedAccounts[_address] == true) revert();\n\t\t_;\n\t}\n\n\tmodifier is_locked(address _address) {\n\t\tif (lockedAccounts[_address] != true) revert();\n\t\t_;\n\t}\n}\n\n\ncontract GilgameshToken is SecureERC20Token {\n\t// @notice Constructor to create Gilgamesh ERC20 Token\n\tfunction GilgameshToken()\n\tpublic\n\tSecureERC20Token(\n\t\t0, // no token in the begning\n\t\t\"Gilgamesh Token\", // Token Name\n\t\t\"GIL\", // Token Symbol\n\t\t18, // Decimals\n\t\tfalse // Enable token transfer\n\t) {}\n\n}\n\n\n/*\n\tCopyright 2017, Skiral Inc\n*/\ncontract GilgameshTokenSale is SafeMath{\n\n\t// creationBlock is the block number that the Token was created\n\tuint256 public creationBlock;\n\n\t// startBlock token sale starting block\n\tuint256 public startBlock;\n\n\t// endBlock token sale ending block\n\t// end block is not a valid block for crowdfunding. endBlock - 1 is the last valid block\n\tuint256 public endBlock;\n\n\t// total Wei rasised\n\tuint256 public totalRaised = 0;\n\n\t// Has Gilgamesh stopped the sale\n\tbool public saleStopped = false;\n\n\t// Has Gilgamesh finalized the sale\n\tbool public saleFinalized = false;\n\n\t// Minimum purchase - 0.1 Ether\n\tuint256 constant public minimumInvestment = 100 finney;\n\n\t// Maximum hard Cap\n\tuint256 public hardCap = 50000 ether;\n\n\t// number of wei GIL tokens for sale - 60 Million GIL Tokens\n\tuint256 public tokenCap = 60000000 * 10**18;\n\n\t// Minimum cap\n\tuint256 public minimumCap = 1250 ether;\n\n\t/* Contract Info */\n\n\t// the deposit address for the Eth that is raised.\n\taddress public fundOwnerWallet;\n\n\t// the deposit address for the tokens that is minted for the dev team.\n\taddress public tokenOwnerWallet;\n\n\t// owner the address of the contract depoloyer\n\taddress public owner;\n\n\t// List of stage bonus percentages in every stage\n\t// this will get generated in the constructor\n\tuint[] public stageBonusPercentage;\n\n\t// number of participants\n\tuint256 public totalParticipants;\n\n\t// a map of userId to wei\n\tmapping(uint256 => uint256) public paymentsByUserId;\n\n\t// a map of user address to wei\n\tmapping(address => uint256) public paymentsByAddress;\n\n\t// total number of bonus stages.\n\tuint8 public totalStages;\n\n\t// max bonus percentage on first stage\n\tuint8 public stageMaxBonusPercentage;\n\n\t// number of wei-GIL tokens for 1 wei (18 decimals)\n\tuint256 public tokenPrice;\n\n\t// the team owns 25% of the tokens - 3 times more than token purchasers.\n\tuint8 public teamTokenRatio = 3;\n\n\t// GIL token address\n\tGilgameshToken public token;\n\n\t// if Ether or Token cap has been reached\n\tbool public isCapReached = false;\n\n\t// log when token sale has been initialized\n\tevent LogTokenSaleInitialized(\n\t\taddress indexed owner,\n\t\taddress indexed fundOwnerWallet,\n\t\tuint256 startBlock,\n\t\tuint256 endBlock,\n\t\tuint256 creationBlock\n\t);\n\n\t// log each contribution\n\tevent LogContribution(\n\t\taddress indexed contributorAddress,\n\t\taddress indexed invokerAddress,\n\t\tuint256 amount,\n\t\tuint256 totalRaised,\n\t\tuint256 userAssignedTokens,\n\t\tuint256 indexed userId\n\t);\n\n\t// log when crowd fund is finalized\n\tevent LogFinalized(address owner, uint256 teamTokens);\n\n\t// Constructor\n\tfunction GilgameshTokenSale(\n\t\tuint256 _startBlock, // starting block number\n\t\tuint256 _endBlock, // ending block number\n\t\taddress _fundOwnerWallet, // fund owner wallet address - transfer ether to this address during and after fund has been closed\n\t\taddress _tokenOwnerWallet, // token fund owner wallet address - transfer GIL tokens to this address after fund is finalized\n\t\tuint8 _totalStages, // total number of bonus stages\n\t\tuint8 _stageMaxBonusPercentage, // maximum percentage for bonus in the first stage\n\t\tuint256 _tokenPrice, // price of each GIL token in wei\n\t\taddress _gilgameshToken, // address of the gilgamesh ERC20 token contract\n\t\tuint256 _minimumCap, // minimum cap, minimum amount of wei to be raised\n\t\tuint256 _tokenCap // tokenCap\n\t)\n\tpublic\n\tvalidate_address(_fundOwnerWallet) {\n\n\t\tif (\n\t\t\t_gilgameshToken == 0x0 ||\n\t\t\t_tokenOwnerWallet == 0x0 ||\n\t\t\t// start block needs to be in the future\n\t\t\t_startBlock < getBlockNumber()  ||\n\t\t\t// start block should be less than ending block\n\t\t\t_startBlock >= _endBlock  ||\n\t\t\t// minimum number of stages is 2\n\t\t\t_totalStages < 2 ||\n\t\t\t// verify stage max bonus\n\t\t\t_stageMaxBonusPercentage < 0  ||\n\t\t\t_stageMaxBonusPercentage > 100 ||\n\t\t\t// stage bonus percentage needs to be devisible by number of stages\n\t\t\t_stageMaxBonusPercentage % (_totalStages - 1) != 0 ||\n\t\t\t// total number of blocks needs to be devisible by the total stages\n\t\t\t(_endBlock - _startBlock) % _totalStages != 0\n\t\t) revert();\n\n\t\towner = msg.sender; // make the contract creator the `owner`\n\t\ttoken = GilgameshToken(_gilgameshToken);\n\t\tendBlock = _endBlock;\n\t\tstartBlock = _startBlock;\n\t\tcreationBlock = getBlockNumber();\n\t\tfundOwnerWallet = _fundOwnerWallet;\n\t\ttokenOwnerWallet = _tokenOwnerWallet;\n\t\ttokenPrice = _tokenPrice;\n\t\ttotalStages = _totalStages;\n\t\tminimumCap = _minimumCap;\n\t\tstageMaxBonusPercentage = _stageMaxBonusPercentage;\n\t\ttotalRaised = 0; //\ttotal number of wei raised\n\t\ttokenCap = _tokenCap;\n\n\t\t// spread bonuses evenly between stages - e.g 27 / 9 = 3%\n\t\tuint spread = stageMaxBonusPercentage / (totalStages - 1);\n\n\t\t// loop through [10 to 1] => ( 9 to 0) * 3% = [27%, 24%, 21%, 18%, 15%, 12%, 9%, 6%, 3%, 0%]\n\t\tfor (uint stageNumber = totalStages; stageNumber > 0; stageNumber--) {\n\t\t\tstageBonusPercentage.push((stageNumber - 1) * spread);\n\t\t}\n\n\t\tLogTokenSaleInitialized(\n\t\t\towner,\n\t\t\tfundOwnerWallet,\n\t\t\tstartBlock,\n\t\t\tendBlock,\n\t\t\tcreationBlock\n\t\t);\n\t}\n\n\t// --------------\n\t// Public Funtions\n\t// --------------\n\n\t/// @notice Function to stop sale for an emergency.\n\t/// @dev Only Gilgamesh Dev can do it after it has been activated.\n\tfunction emergencyStopSale()\n\tpublic\n\tonly_sale_active\n\tonlyOwner {\n\t\tsaleStopped = true;\n\t}\n\n\t/// @notice Function to restart stopped sale.\n\t/// @dev Only Gilgamesh Dev can do it after it has been disabled and sale has stopped.\n\t/// can it's in a valid time range for sale\n\tfunction restartSale()\n\tpublic\n\tonly_during_sale_period\n\tonly_sale_stopped\n\tonlyOwner {\n\t\t// if sale is finalized fail\n\t\tif (saleFinalized) revert();\n\t\tsaleStopped = false;\n\t}\n\n\t/// @notice Function to change the fund owner wallet address\n\t/// @dev Only Gilgamesh Dev can trigger this function\n\tfunction changeFundOwnerWalletAddress(address _fundOwnerWallet)\n\tpublic\n\tvalidate_address(_fundOwnerWallet)\n\tonlyOwner {\n\t\tfundOwnerWallet = _fundOwnerWallet;\n\t}\n\n\t/// @notice Function to change the token fund owner wallet address\n\t/// @dev Only Gilgamesh Dev can trigger this function\n\tfunction changeTokenOwnerWalletAddress(address _tokenOwnerWallet)\n\tpublic\n\tvalidate_address(_tokenOwnerWallet)\n\tonlyOwner {\n\t\ttokenOwnerWallet = _tokenOwnerWallet;\n\t}\n\n\t/// @notice finalize the sale\n\t/// @dev Only Gilgamesh Dev can trigger this function\n\tfunction finalizeSale()\n\tpublic\n\tonlyOwner {\n\t\tdoFinalizeSale();\n\t}\n\n\t/// @notice change hard cap and if it reaches hard cap finalize sale\n\tfunction changeCap(uint256 _cap)\n\tpublic\n\tonlyOwner {\n\t\tif (_cap < minimumCap) revert();\n\t\tif (_cap <= totalRaised) revert();\n\n\t\thardCap = _cap;\n\n\t\tif (totalRaised + minimumInvestment >= hardCap) {\n\t\t\tisCapReached = true;\n\t\t\tdoFinalizeSale();\n\t\t}\n\t}\n\n\t/// @notice change minimum cap, in case Ether price fluctuates.\n\tfunction changeMinimumCap(uint256 _cap)\n\tpublic\n\tonlyOwner {\n\t\tif (minimumCap < _cap) revert();\n\t\tminimumCap = _cap;\n\t}\n\n\t/// @notice remove conttact only when sale has been finalized\n\t/// transfer all the fund to the contract owner\n\t/// @dev only Gilgamesh Dev can trigger this function\n\tfunction removeContract()\n\tpublic\n\tonlyOwner {\n\t\tif (!saleFinalized) revert();\n\t\tselfdestruct(msg.sender);\n\t}\n\n\t/// @notice only the owner is allowed to change the owner.\n\t/// @param _newOwner the address of the new owner\n\tfunction changeOwner(address _newOwner)\n\tpublic\n\tvalidate_address(_newOwner)\n\tonlyOwner {\n\t\trequire(_newOwner != owner);\n\t\towner = _newOwner;\n\t}\n\n\t/// @dev The fallback function is called when ether is sent to the contract\n\t/// Payable is a required solidity modifier to receive ether\n\t/// every contract only has one unnamed function\n\t/// 2300 gas available for this function\n\t/*function () public payable {\n\t\treturn deposit();\n\t}*/\n\n\t/**\n\t* Pay on a behalf of the sender.\n\t*\n\t* @param customerId Identifier in the central database, UUID v4\n\t*\n\t*/\n\t/// @dev allow purchasers to deposit ETH for GIL Tokens.\n\tfunction depositForMySelf(uint256 userId)\n\tpublic\n\tonly_sale_active\n\tminimum_contribution()\n\tpayable {\n\t\tdeposit(userId, msg.sender);\n\t}\n\n\t///\t@dev deposit() is an public function that accepts a userId and userAddress\n\t///\tcontract receives ETH in return of GIL tokens\n\tfunction deposit(uint256 userId, address userAddress)\n\tpublic\n\tpayable\n\tonly_sale_active\n\tminimum_contribution()\n\tvalidate_address(userAddress) {\n\t\t// if it passes hard cap throw\n\t\tif (totalRaised + msg.value > hardCap) revert();\n\n\t\tuint256 userAssignedTokens = calculateTokens(msg.value);\n\n\t\t// if user tokens are 0 throw\n\t\tif (userAssignedTokens <= 0) revert();\n\n\t\t// if number of tokens exceed the token cap stop execution\n\t\tif (token.totalSupply() + userAssignedTokens > tokenCap) revert();\n\n\t\t// send funds to fund owner wallet\n\t\tif (!fundOwnerWallet.send(msg.value)) revert();\n\n\t\t// mint tokens for the user\n\t\tif (!token.mint(userAddress, userAssignedTokens)) revert();\n\n\t\t// save total number wei raised\n\t\ttotalRaised = safeAdd(totalRaised, msg.value);\n\n\t\t// if cap is reached mark it\n\t\tif (totalRaised >= hardCap) {\n\t\t\tisCapReached = true;\n\t\t}\n\n\t\t// if token supply has exceeded or reached the token cap stop\n\t\tif (token.totalSupply() >= tokenCap) {\n\t\t\tisCapReached = true;\n\t\t}\n\n\t\t// increase the number of participants for the first transaction\n\t\tif (paymentsByUserId[userId] == 0) {\n\t\t\ttotalParticipants++;\n\t\t}\n\n\t\t// increase the amount that the user has payed\n\t\tpaymentsByUserId[userId] += msg.value;\n\n\t\t// total wei based on address\n\t\tpaymentsByAddress[userAddress] += msg.value;\n\n\t\t// log contribution event\n\t\tLogContribution(\n\t\t\tuserAddress,\n\t\t\tmsg.sender,\n\t\t\tmsg.value,\n\t\t\ttotalRaised,\n\t\t\tuserAssignedTokens,\n\t\t\tuserId\n\t\t);\n\t}\n\n\t/// @notice calculate number of tokens need to be issued based on the amount received\n\t/// @param amount number of wei received\n\tfunction calculateTokens(uint256 amount)\n\tpublic\n\tview\n\treturns (uint256) {\n\t\t// return 0 if the crowd fund has ended or it hasn't started\n\t\tif (!isDuringSalePeriod(getBlockNumber())) return 0;\n\n\t\t// get the current stage number by block number\n\t\tuint8 currentStage = getStageByBlockNumber(getBlockNumber());\n\n\t\t// if current stage is more than the total stage return 0 - something is wrong\n\t\tif (currentStage > totalStages) return 0;\n\n\t\t// calculate number of tokens that needs to be issued for the purchaser\n\t\tuint256 purchasedTokens = safeMul(amount, tokenPrice);\n\t\t// calculate number of tokens that needs to be rewraded to the purchaser\n\t\tuint256 rewardedTokens = calculateRewardTokens(purchasedTokens, currentStage);\n\t\t// add purchasedTokens and rewardedTokens\n\t\treturn safeAdd(purchasedTokens, rewardedTokens);\n\t}\n\n\t/// @notice calculate reward based on amount of tokens that will be issued to the purchaser\n\t/// @param amount number tokens that will be minted for the purchaser\n\t/// @param stageNumber number of current stage in the crowd fund process\n\tfunction calculateRewardTokens(uint256 amount, uint8 stageNumber)\n\tpublic\n\tview\n\treturns (uint256 rewardAmount) {\n\t\t// throw if it's invalid stage number\n\t\tif (\n\t\t\tstageNumber < 1 ||\n\t\t\tstageNumber > totalStages\n\t\t) revert();\n\n\t\t// get stage index for the array\n\t\tuint8 stageIndex = stageNumber - 1;\n\n\t\t// calculate reward - e.q 100 token creates 100 * 20 /100 = 20 tokens for reward\n\t\treturn safeDiv(safeMul(amount, stageBonusPercentage[stageIndex]), 100);\n\t}\n\n\t/// @notice get crowd fund stage by block number\n\t/// @param _blockNumber block number\n\tfunction getStageByBlockNumber(uint256 _blockNumber)\n\tpublic\n\tview\n\treturns (uint8) {\n\t\t// throw error, if block number is out of range\n\t\tif (!isDuringSalePeriod(_blockNumber)) revert();\n\n\t\tuint256 totalBlocks = safeSub(endBlock, startBlock);\n\t\tuint256 numOfBlockPassed = safeSub(_blockNumber, startBlock);\n\n\t\t// since numbers round down we need to add one to number of stage\n\t\treturn uint8(safeDiv(safeMul(totalStages, numOfBlockPassed), totalBlocks) + 1);\n\t}\n\n\t// --------------\n\t// Internal Funtions\n\t// --------------\n\n\t/// @notice check if the block number is during the sale period\n\t/// @param _blockNumber block number\n\tfunction isDuringSalePeriod(uint256 _blockNumber)\n\tview\n\tinternal\n\treturns (bool) {\n\t\treturn (_blockNumber >= startBlock && _blockNumber < endBlock);\n\t}\n\n\t/// @notice finalize the crowdfun sale\n\t/// @dev Only Gilgamesh Dev can trigger this function\n\tfunction doFinalizeSale()\n\tinternal\n\tonlyOwner {\n\n\t\tif (saleFinalized) revert();\n\n\t\t// calculate the number of tokens that needs to be assigned to Gilgamesh team\n\t\tuint256 teamTokens = safeMul(token.totalSupply(), teamTokenRatio);\n\n\t\tif (teamTokens > 0){\n\t\t\t// mint tokens for the team\n\t\t\tif (!token.mint(tokenOwnerWallet, teamTokens)) revert();\n\t\t}\n\n\t\t// if there is any fund drain it\n\t\tif(this.balance > 0) {\n\t\t\t// send ether funds to fund owner wallet\n\t\t\tif (!fundOwnerWallet.send(this.balance)) revert();\n\t\t}\n\n\t\t// finalize sale flag\n\t\tsaleFinalized = true;\n\n\t\t// stop sale flag\n\t\tsaleStopped = true;\n\n\t\t// log finalized\n\t\tLogFinalized(tokenOwnerWallet, teamTokens);\n\t}\n\n\t/// @notice returns block.number\n\tfunction getBlockNumber() constant internal returns (uint) {\n\t\treturn block.number;\n\t}\n\n\t// --------------\n\t// Modifiers\n\t// --------------\n\n\t/// continue only when sale has stopped\n\tmodifier only_sale_stopped {\n\t\tif (!saleStopped) revert();\n\t\t_;\n\t}\n\n\n\t/// validates an address - currently only checks that it isn't null\n\tmodifier validate_address(address _address) {\n\t\tif (_address == 0x0) revert();\n\t\t_;\n\t}\n\n\t/// continue only during the sale period\n\tmodifier only_during_sale_period {\n\t\t// if block number is less than starting block fail\n\t\tif (getBlockNumber() < startBlock) revert();\n\t\t// if block number has reach to the end block fail\n\t\tif (getBlockNumber() >= endBlock) revert();\n\t\t// otherwise safe to continue\n\t\t_;\n\t}\n\n\t/// continue when sale is active and valid\n\tmodifier only_sale_active {\n\t\t// if sale is finalized fail\n\t\tif (saleFinalized) revert();\n\t\t// if sale is stopped fail\n\t\tif (saleStopped) revert();\n\t\t// if cap is reached\n\t\tif (isCapReached) revert();\n\t\t// if block number is less than starting block fail\n\t\tif (getBlockNumber() < startBlock) revert();\n\t\t// if block number has reach to the end block fail\n\t\tif (getBlockNumber() >= endBlock) revert();\n\t\t// otherwise safe to continue\n\t\t_;\n\t}\n\n\t/// continue if minimum contribution has reached\n\tmodifier minimum_contribution() {\n\t\tif (msg.value < minimumInvestment) revert();\n\t\t_;\n\t}\n\n\t/// continue when the invoker is the owner\n\tmodifier onlyOwner() {\n\t\tif (msg.sender != owner) revert();\n\t\t_;\n\t}\n}",
  "bytecode": "60606040526007805460ff19166001179055341561001c57600080fd5b6000604080519081016040908152600f82527f47696c67616d65736820546f6b656e000000000000000000000000000000000060208301528051908101604090815260038083527f47494c0000000000000000000000000000000000000000000000000000000000602080850191909152600160a060020a0333166000908152908190529182208590556006859055601291908480516100c092916020019061013b565b506005805460ff191660ff841617905560048380516100e392916020019061013b565b50600a805460ff1916911515919091179055505043600955505060088054600160a060020a03191633600160a060020a03169081179091556007805461010060a860020a0319166101009092029190911790556101d6565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061017c57805160ff19168380011785556101a9565b828001600101855582156101a9579182015b828111156101a957825182559160200191906001019061018e565b506101b59291506101b9565b5090565b6101d391905b808211156101b557600081556001016101bf565b90565b610d99806101e56000396000f30060606040526004361061011c5763ffffffff7c010000000000000000000000000000000000000000000000000000000060003504166306fdde03811461012157806307546172146101ab578063095ea7b3146101da578063176345141461021057806318160ddd1461023557806323b872dd146102485780632c4d4d1814610270578063313ce5671461029157806340c10f19146102ba57806347a64f44146102dc57806354fd4d50146102fb57806370a082311461030e5780638f2839701461032d578063905295e31461034c57806395d89b411461036b5780639bc853021461037e578063a9059cbb1461039d578063cca5dcb6146103bf578063dd62ed3e146103d2578063f41e60c5146103f7578063f851a4401461040f575b600080fd5b341561012c57600080fd5b610134610422565b60405160208082528190810183818151815260200191508051906020019080838360005b83811015610170578082015183820152602001610158565b50505050905090810190601f16801561019d5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b34156101b657600080fd5b6101be6104c0565b604051600160a060020a03909116815260200160405180910390f35b34156101e557600080fd5b6101fc600160a060020a03600435166024356104cf565b604051901515815260200160405180910390f35b341561021b57600080fd5b6102236105e2565b60405190815260200160405180910390f35b341561024057600080fd5b6102236105e8565b341561025357600080fd5b6101fc600160a060020a03600435811690602435166044356105ee565b341561027b57600080fd5b61028f600160a060020a0360043516610676565b005b341561029c57600080fd5b6102a4610733565b60405160ff909116815260200160405180910390f35b34156102c557600080fd5b6101fc600160a060020a036004351660243561073c565b34156102e757600080fd5b61028f600160a060020a0360043516610859565b341561030657600080fd5b6102a46108e8565b341561031957600080fd5b610223600160a060020a03600435166108f1565b341561033857600080fd5b61028f600160a060020a036004351661090c565b341561035757600080fd5b61028f600160a060020a03600435166109d9565b341561037657600080fd5b610134610a61565b341561038957600080fd5b61028f600160a060020a0360043516610acc565b34156103a857600080fd5b6101fc600160a060020a0360043516602435610b74565b34156103ca57600080fd5b6101fc610b9a565b34156103dd57600080fd5b610223600160a060020a0360043581169060243516610ba3565b341561040257600080fd5b61028f6004351515610bce565b341561041a57600080fd5b6101be610c44565b60038054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156104b85780601f1061048d576101008083540402835291602001916104b8565b820191906000526020600020905b81548152906001019060200180831161049b57829003601f168201915b505050505081565b600854600160a060020a031681565b600160a060020a0382166000908152600160208190526040822054849160ff909116151514156104fe57600080fd5b600a5460ff16151561050f57600080fd5b82158015906105425750600160a060020a0333811660009081526002602090815260408083209388168352929052205415155b1561054c57600080fd5b600160a060020a0333166000908152602081905260409020548390101561057657600091506105db565b600160a060020a03338116600081815260026020908152604080832094891680845294909152908190208690557f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b9259086905190815260200160405180910390a3600191505b5092915050565b60095481565b60065490565b600a5460009060ff16151561060257600080fd5b600160a060020a03808516600090815260026020908152604080832033909416835292905220548290101561063657600080fd5b600160a060020a038085166000908152600260209081526040808320339094168352929052208054839003905561066e848484610c58565b949350505050565b80600160a060020a038116151561068c57600080fd5b60075433600160a060020a0390811661010090920416146106ac57600080fd5b600854600160a060020a03838116911614156106c757600080fd5b600854600160a060020a0380841691167fde77229fa00b529105f0b70b944b5ec6e7967121b91074f4ab65f9907bbf976b60405160405180910390a3506008805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b60055460ff1681565b60085460009033600160a060020a0390811691161461075a57600080fd5b82600160a060020a038116151561077057600080fd5b600654838101101561078157600080fd5b600160a060020a03841660009081526020819052604090205483810110156107a857600080fd5b6006805484019055600160a060020a0380851660009081526020819052604080822080548701905533909216917fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef9086905190815260200160405180910390a383600160a060020a031633600160a060020a03167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef8560405190815260200160405180910390a35060019392505050565b600160a060020a038116600090815260016020819052604090912054829160ff9091161515141561088957600080fd5b81600160a060020a038116151561089f57600080fd5b60075433600160a060020a0390811661010090920416146108bf57600080fd5b5050600160a060020a03166000908152600160208190526040909120805460ff19169091179055565b60075460ff1681565b600160a060020a031660009081526020819052604090205490565b80600160a060020a038116151561092257600080fd5b60075433600160a060020a03908116610100909204161461094257600080fd5b600754600160a060020a0383811661010090920416141561096257600080fd5b600754600160a060020a03808416916101009004167f1747af0dff66eb7165b467825c51774199b063a569a06cdea4565bac5d1be8cf60405160405180910390a35060078054600160a060020a039092166101000274ffffffffffffffffffffffffffffffffffffffff0019909216919091179055565b600160a060020a038116600090815260016020819052604090912054829160ff909116151514610a0857600080fd5b81600160a060020a0381161515610a1e57600080fd5b60075433600160a060020a039081166101009092041614610a3e57600080fd5b5050600160a060020a03166000908152600160205260409020805460ff19169055565b60048054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156104b85780601f1061048d576101008083540402835291602001916104b8565b80600160a060020a0381161515610ae257600080fd5b60075433600160a060020a039081166101009092041614610b0257600080fd5b600160a060020a0382166000908152602081905260409020541515610b2657600080fd5b600654600160a060020a0383166000908152602081905260409020541115610b4d57600080fd5b50600160a060020a0316600090815260208190526040812080546006805491909103905555565b600a5460009060ff161515610b8857600080fd5b610b93338484610c58565b9392505050565b600a5460ff1681565b600160a060020a03918216600090815260026020908152604080832093909416825291909152205490565b60075433600160a060020a039081166101009092041614610bee57600080fd5b600a805460ff1916821515179081905533600160a060020a0316907f175c6709b75b0374a000960e3efe2fd0b15e523b8eff9f8afaf504b988157c939060ff16604051901515815260200160405180910390a250565b6007546101009004600160a060020a031681565b600082600160a060020a0381161515610c7057600080fd5b600160a060020a038516600090815260016020819052604090912054869160ff90911615151415610ca057600080fd5b600084111580610cc85750600160a060020a0386166000908152602081905260409020548490105b80610cec5750600160a060020a038516600090815260208190526040902054848101105b15610cfa5760009250610d64565b600160a060020a038087166000818152602081905260408082208054899003905592881680825290839020805488019055917fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef9087905190815260200160405180910390a3600192505b505093925050505600a165627a7a72305820d2fdbd80f95bb096fc491e347574331b8c4f6e3ede658747dba8032d852880cf0029"
}