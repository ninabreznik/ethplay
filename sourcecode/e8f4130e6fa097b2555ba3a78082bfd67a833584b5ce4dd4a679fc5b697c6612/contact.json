{
  "address": "0xea1853f9162ba2b6594fc18d60c66bf4b6211e0d",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "SpinWinLibrary",
  "compilerVersion": "v0.4.24+commit.e67f0147",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2019-05-07\n*/\n\npragma solidity ^0.4.24;\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tif (a == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tuint256 c = a * b;\n\t\tassert(c / a == b);\n\t\treturn c;\n\t}\n\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\n\t\tuint256 c = a / b;\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\t\treturn c;\n\t}\n\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tassert(b <= a);\n\t\treturn a - b;\n\t}\n\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tuint256 c = a + b;\n\t\tassert(c >= a);\n\t\treturn c;\n\t}\n}\n\n/**\n * @title SettingInterface\n */\ninterface SettingInterface {\n\tfunction uintSettings(bytes32 name) external constant returns (uint256);\n\tfunction boolSettings(bytes32 name) external constant returns (bool);\n\tfunction isActive() external constant returns (bool);\n\tfunction canBet(uint256 rewardValue, uint256 betValue, uint256 playerNumber, uint256 houseEdge) external constant returns (bool);\n\tfunction isExchangeAllowed(address playerAddress, uint256 tokenAmount) external constant returns (bool);\n\n\t/******************************************/\n\t/*          SPINWIN ONLY METHODS          */\n\t/******************************************/\n\tfunction spinwinSetUintSetting(bytes32 name, uint256 value) external;\n\tfunction spinwinIncrementUintSetting(bytes32 name) external;\n\tfunction spinwinSetBoolSetting(bytes32 name, bool value) external;\n\tfunction spinwinAddFunds(uint256 amount) external;\n\tfunction spinwinUpdateTokenToWeiExchangeRate() external;\n\tfunction spinwinRollDice(uint256 betValue) external;\n\tfunction spinwinUpdateWinMetric(uint256 playerProfit) external;\n\tfunction spinwinUpdateLoseMetric(uint256 betValue, uint256 tokenRewardValue) external;\n\tfunction spinwinUpdateLotteryContributionMetric(uint256 lotteryContribution) external;\n\tfunction spinwinUpdateExchangeMetric(uint256 exchangeAmount) external;\n\n\t/******************************************/\n\t/*      SPINLOTTERY ONLY METHODS          */\n\t/******************************************/\n\tfunction spinlotterySetUintSetting(bytes32 name, uint256 value) external;\n\tfunction spinlotteryIncrementUintSetting(bytes32 name) external;\n\tfunction spinlotterySetBoolSetting(bytes32 name, bool value) external;\n\tfunction spinlotteryUpdateTokenToWeiExchangeRate() external;\n\tfunction spinlotterySetMinBankroll(uint256 _minBankroll) external returns (bool);\n}\n\n/**\n * @title LotteryInterface\n */\ninterface LotteryInterface {\n\tfunction claimReward(address playerAddress, uint256 tokenAmount) external returns (bool);\n\tfunction calculateLotteryContributionPercentage() external constant returns (uint256);\n\tfunction getNumLottery() external constant returns (uint256);\n\tfunction isActive() external constant returns (bool);\n\tfunction getCurrentTicketMultiplierHonor() external constant returns (uint256);\n\tfunction getCurrentLotteryTargetBalance() external constant returns (uint256, uint256);\n}\n\n/**\n * @title SpinWinLibrary\n */\nlibrary SpinWinLibrary {\n\tusing SafeMath for uint256;\n\n\tuint256 constant public PERCENTAGE_DIVISOR = 10 ** 6;   // 1000000 = 100%\n\tuint256 constant public HOUSE_EDGE_DIVISOR = 1000;\n\tuint256 constant public CURRENCY_DIVISOR = 10**18;\n\tuint256 constant public TWO_DECIMALS = 100;\n\n\t/**\n\t * @dev Calculate winning ETH when player wins\n\t * @param betValue The amount of ETH for this bet\n\t * @param playerNumber The number that player chose\n\t * @param houseEdge The house edge for this bet\n\t * @return The amount of ETH to be sent to player if he/she wins\n\t */\n\tfunction calculateWinningReward(uint256 betValue, uint256 playerNumber, uint256 houseEdge) public pure returns (uint256) {\n\t\treturn ((betValue.mul(100-(playerNumber.sub(1)))).div(playerNumber.sub(1))).mul(houseEdge).div(HOUSE_EDGE_DIVISOR);\n\n\t}\n\n\t/**\n\t * @dev Calculates token reward amount when player loses\n\t * @param settingAddress The GameSetting contract address\n\t * @param betValue The amount of ETH for this bet\n\t * @param playerNumber The number that player chose\n\t * @param houseEdge The house edge for this bet\n\t * @return The amount of token to be sent to player if he/she loses\n\t */\n\tfunction calculateTokenReward(address settingAddress, uint256 betValue, uint256 playerNumber, uint256 houseEdge) public constant returns (uint256) {\n\t\tuint256 weiLost = SettingInterface(settingAddress).uintSettings('totalWeiLostHonor').add(betValue.div(2));\n\t\tuint256 ratio = _getTokenRatio(weiLost);\n\n\t\t/*\n\t\t * Let base = betValue * ratio\n\t\t * We know that _ratio is in two decimals so we need to divide it by TWO_DECIMALS\n\t\t * base = (betValue * ratio)/TWO_DECIMALS\n\t\t */\n\t\tuint256 base = betValue.mul(ratio).div(TWO_DECIMALS);\n\n\t\t/*\n\t\t * edgeMod = base * (houseEdge% * (2 - houseEdge%) * spinEdgeModifier)\n\t\t */\n\t\tuint256 edgeMod = _calculateEdgeMod(settingAddress, base, houseEdge);\n\n\t\t/*\n\t\t * houseMod = base *  (((minBankrollHonor - replacedBank)/minBankrollHonor)*spinBankModifier) * edgeOn\n\t\t */\n\t\tuint256 houseMod = _calculateHouseMod(settingAddress, base, houseEdge);\n\n\t\t/*\n\t\t * numberMod =  base * ((1 + ((100 - playerNumber)/100))*spinNumberModifier) * edgeOn;\n\t\t */\n\t\tuint256 numberMod = _calculateNumberMod(settingAddress, base, playerNumber, houseEdge);\n\n\t\treturn edgeMod.add(houseMod).add(numberMod);\n\t}\n\n\t/**\n\t * @dev Generates random number between 1-divisor\n\t * @param settingAddress The GameSetting contract address\n\t * @param betBlockNumber The bet block number\n\t * @param extraData Data to be included in keccak256 for security purposes\n\t * @param divisor The upper bound of the random number\n\t * @return Return integer from 1-divisor\n\t */\n\tfunction generateRandomNumber(address settingAddress, uint256 betBlockNumber, uint256 extraData, uint256 divisor) public constant returns (uint256) {\n\t\tuint256 blockNumberDifference = block.number.sub(betBlockNumber);\n\t\tuint256 maxBlockSecurityCount = SettingInterface(settingAddress).uintSettings('maxBlockSecurityCount');\n\t\tuint256 blockSecurityCount = SettingInterface(settingAddress).uintSettings('blockSecurityCount');\n\t\tif (blockNumberDifference < SettingInterface(settingAddress).uintSettings('maxBlockSecurityCount').sub(blockSecurityCount)) {\n\t\t\tuint256 targetBlockNumber = betBlockNumber.add(blockSecurityCount);\n\t\t} else {\n\t\t\ttargetBlockNumber = betBlockNumber.add(maxBlockSecurityCount.mul(blockNumberDifference.div(maxBlockSecurityCount))).add(blockSecurityCount);\n\t\t}\n\t\tuint256 randomNumber = 0;\n\t\tfor (uint256 i = 1; i < blockSecurityCount; i++) {\n\t\t\trandomNumber = ((uint256(keccak256(abi.encodePacked(randomNumber, blockhash(targetBlockNumber.sub(i)), extraData)))%divisor).add(1));\n\t\t}\n\t\treturn randomNumber;\n\t}\n\n\t/**\n\t * @dev Calculate clear bet block reward\n\t * @param settingAddress The GameSetting contract address\n\t * @param lotteryAddress The lottery contract address\n\t * @return The num of blocks reward for clearing bet\n\t */\n\tfunction calculateClearBetBlocksReward(address settingAddress, address lotteryAddress) public constant returns (uint256) {\n\t\tuint256 weiLost = SettingInterface(settingAddress).uintSettings('totalWeiLostHonor');\n\n\t\t// Calculate 1 Wei to SPIN Rate\n\t\tuint256 weiToSpinRate = _getTokenRatio(weiLost); // in decimals\n\n\t\t/*\n\t\t * Calculate 1 SPIN to Wei Rate\n\t\t * Inverse of weiToSpinRate\n\t\t * so spinToWeiRate = 1 / weiToSpinRate\n\t\t * but weiToSpinRate is in decimals\n\t\t * spinToWeiRate = 1 / (weiToSpinRate / TWO_DECIMALS)\n\t\t * spinToWeiRate = TWO_DECIMALS / weiToSpinRate\n\t\t * Mult by CURRENCY_DIVISOR/CURRENCY_DIVISOR to account for the decimals\n\t\t * spinToWeiRate = (CURRENCY_DIVISOR/CURRENCY_DIVISOR) * (TWO_DECIMALS / weiToSpinRate)\n\t\t * Take out the division by CURRENCY_DIVISOR for now and include it in the later calculation\n\t\t * spinToWeiRate = (CURRENCY_DIVISOR * TWO_DECIMALS) / weiToSpinRate\n\t\t */\n\t\tuint256 spinToWeiRate = SettingInterface(settingAddress).uintSettings('spinToWeiRate');\n\t\tif (weiToSpinRate > 0) {\n\t\t\tspinToWeiRate = (CURRENCY_DIVISOR.mul(TWO_DECIMALS)).div(weiToSpinRate); // in decimals\n\t\t}\n\n\t\t// Calculate 1 Spin to Block Rate\n\t\tuint256 spinToBlockRate = LotteryInterface(lotteryAddress).getCurrentTicketMultiplierHonor(); // in decimals\n\n\t\t/*\n\t\t * Calculate 1 Block to Spin Rate\n\t\t * Inverse of spinToBlockRate\n\t\t * so blockToSpinRate = 1 / spinToBlockRate\n\t\t * but spinToBlockRate is in decimals\n\t\t * blockToSpinRate = 1 / (spinToBlockRate / TWO_DECIMALS)\n\t\t * blockToSpinRate = TWO_DECIMALS / spinToBlockRate\n\t\t * Mult by CURRENCY_DIVISOR/CURRENCY_DIVISOR to account for two decimals\n\t\t * blockToSpinRate = (CURRENCY_DIVISOR/CURRENCY_DIVISOR) * (TWO_DECIMALS / spinToBlockRate)\n\t\t * Take out the division by CURRENCY_DIVISOR for now and include it in the later calculation\n\t\t * blockToSpinRate = (CURRENCY_DIVISOR * TWO_DECIMALS) / spinToBlockRate\n\t\t */\n\t\tuint256 blockToSpinRate = SettingInterface(settingAddress).uintSettings('blockToSpinRate');\n\t\tif (spinToBlockRate > 0) {\n\t\t\tblockToSpinRate = (CURRENCY_DIVISOR.mul(TWO_DECIMALS)).div(spinToBlockRate); // in decimals\n\t\t}\n\n\t\t/*\n\t\t * Calculate block to wei Rate\n\t\t * blockToWeiRate = blockToSpinRate * spinToWeiRate\n\t\t * since blockToSpinRate and spinToWeiRate are in decimals (from prev calculation)\n\t\t * need to include the division by CURRENCY_DIVISOR\n\t\t * blockToWeiRate = (blockToSpinRate/CURRENCY_DIVISOR)  * (spinToWeiRate/CURRENCY_DIVISOR)\n\t\t * But since we need to account for decimals\n\t\t * Mult the math about with CURRENCY_DIVISOR/CURRENCY_DIVISOR\n\t\t * blockToWeiRate = (CURRENCY_DIVISOR/CURRENCY_DIVISOR) * (blockToSpinRate/CURRENCY_DIVISOR)  * (spinToWeiRate/CURRENCY_DIVISOR)\n\t\t * Take out one division by CURRENCY_DIVISOR for now and include it in the later calculation\n\t\t * blockToWeiRate = (blockToSpinRate * spinToWeiRate) / CURRENCY_DIVISOR\n\t\t */\n\t\tuint256 blockToWeiRate = (blockToSpinRate.mul(spinToWeiRate)).div(CURRENCY_DIVISOR); // in decimals\n\n\t\t// Calculate wei cost to clear a bet\n\t\tuint256 weiCost = SettingInterface(settingAddress).uintSettings('gasForClearingBet').mul(SettingInterface(settingAddress).uintSettings('gasPrice'));\n\n\t\t/*\n\t\t * numBlocks = weiCost / blockToWeiRate\n\t\t * But since blockToWeiRate is in decimals, need to divide by CURRENCY_DIVISOR\n\t\t * numBlocks = weiCost / (blockToWeiRate / CURRENCY_DIVISOR)\n\t\t * numBlocks = (weiCost * CURRENCY_DIVISOR)/blockToWeiRate\n\t\t */\n\t\tif (blockToWeiRate == 0) {\n\t\t\tblockToWeiRate = SettingInterface(settingAddress).uintSettings('blockToWeiRate');\n\t\t}\n\t\treturn (weiCost.mul(CURRENCY_DIVISOR)).div(blockToWeiRate);\n\t}\n\n\t/**\n\t * @dev Calculate how much we should contribute to the lottery\n\t * @param settingAddress The GameSetting contract address\n\t * @param lotteryAddress The lottery contract address\n\t * @param betValue The bet value\n\t * @return The lottery contribution amount\n\t */\n\tfunction calculateLotteryContribution(address settingAddress, address lotteryAddress, uint256 betValue) public constant returns (uint256) {\n\t\tuint256 lotteryContribution = (betValue.mul(LotteryInterface(lotteryAddress).calculateLotteryContributionPercentage())).div(TWO_DECIMALS);\n\n\t\t// Check if this contribution will make lottery balance > current lottery target X multiple\n\t\tuint256 currentLotteryTarget;\n\t\tuint256 currentLotteryBankroll;\n\t\t(currentLotteryTarget, currentLotteryBankroll) = LotteryInterface(lotteryAddress).getCurrentLotteryTargetBalance();\n\t\tuint256 lotteryTargetMultiplier = SettingInterface(settingAddress).uintSettings('lotteryTargetMultiplier');\n\t\tif (currentLotteryBankroll.add(lotteryContribution) > currentLotteryTarget.mul(lotteryTargetMultiplier).div(TWO_DECIMALS)) {\n\t\t\tlotteryContribution = (currentLotteryTarget.mul(lotteryTargetMultiplier).div(TWO_DECIMALS)).sub(currentLotteryBankroll);\n\t\t}\n\t\treturn lotteryContribution;\n\t}\n\n\t/**\n\t * @dev Calculate the exchange values\n\t * @param settingAddress The GameSetting contract address\n\t * @param tokenAmount The amount of token to be exchanged\n\t * @return The converted wei value\n\t * @return The amount of wei to be received\n\t * @return The amount of token to be refunded (if contractBalance < weiValue)\n\t * @return The amount of token to be burned\n\t */\n\tfunction calculateExchangeTokenValue(address settingAddress, uint256 tokenAmount) public constant returns (uint256, uint256, uint256, uint256) {\n\t\tuint256 tokenToWeiExchangeRateHonor = SettingInterface(settingAddress).uintSettings('tokenToWeiExchangeRateHonor');\n\t\t// From GameSetting.sol, we know that tokenToWeiExchangeRate is ETH in 36 decimals or WEI in 18 decimals\n\t\t// So we need to divide tokenToWeiExchangeRateHonor by CURRENCY_DIVISOR\n\t\tuint256 weiValue = (tokenToWeiExchangeRateHonor.mul(tokenAmount)).div(CURRENCY_DIVISOR).div(CURRENCY_DIVISOR);\n\t\tuint256 contractExchangeBalance = SettingInterface(settingAddress).uintSettings('contractBalance').sub(SettingInterface(settingAddress).uintSettings('tokenExchangeMinBankroll')); // This is the maximum exchange ETH value that we can send to the player\n\t\tif (contractExchangeBalance >= weiValue) {\n\t\t\tuint256 sendWei = weiValue;\n\t\t\tuint256 tokenRemainder = 0;\n\t\t\tuint256 burnToken = tokenAmount;\n\t\t} else {\n\t\t\tsendWei = contractExchangeBalance;\n\t\t\ttokenRemainder = (weiValue.sub(contractExchangeBalance)).mul(CURRENCY_DIVISOR).mul(CURRENCY_DIVISOR).div(tokenToWeiExchangeRateHonor);\n\t\t\tburnToken = tokenAmount.sub(tokenRemainder);\n\t\t}\n\t\treturn (weiValue, sendWei, tokenRemainder, burnToken);\n\t}\n\n\n\t/******************************************/\n\t/*           PRIVATE METHODS              */\n\t/******************************************/\n\n\t/**\n\t * @dev Gets token ratio based on weiLost\n\t * @param weiLost The wei lost value\n\t * @return Return token ratio (ratio is in two decimals, needs to be divided with TWO_DECIMALS in calculation)\n\t */\n\tfunction _getTokenRatio(uint256 weiLost) private pure returns (uint256) {\n\t\tuint256 ethLost = weiLost.div(CURRENCY_DIVISOR);\n\t\t/**\n\t\t * We value players who are early in the game, that's why we reward them with more SPIN\n\t\t */\n\t\tif (ethLost >= 0 && ethLost <= 10) {\n\t\t\t// Case 1: 0 ETH >= ethLost < 10 ETH\n\t\t\tuint256 start = 1;                                  // start: 0 ETH\n\t\t\tuint256 end = 10;                                   // end: 10 ETH\n\t\t\tuint256 startRatio = 199000 * TWO_DECIMALS;         // start ratio: 199,000\n\t\t\tuint256 endRatio = 1000 * TWO_DECIMALS;             // end ratio: 1,000\n\t\t} else if (ethLost > 10 && ethLost <= 1000) {\n\t\t\t// Case 2: 10 ETH >= ethLost < 1000 ETH\n\t\t\tstart = 10;                                         // start: 10 ETH\n\t\t\tend = 1000;                                         // end: 1,000 ETH\n\t\t\tstartRatio = 1000 * TWO_DECIMALS;                   // start ratio: 1,000\n\t\t\tendRatio = 100 * TWO_DECIMALS;                      // end ratio: 100\n\t\t} else if (ethLost > 1000 && ethLost <= 10000) {\n\t\t\t// Case 3: 1,000 ETH >= ethLost < 10,000 ETH\n\t\t\tstart = 1000;                                       // start: 1,000 ETH\n\t\t\tend = 10000;                                        // end: 10,000 ETH\n\t\t\tstartRatio = 100 * TWO_DECIMALS;                    // start ratio: 100\n\t\t\tendRatio = 20 * TWO_DECIMALS;                       // end ratio: 20\n\t\t} else if (ethLost > 10000 && ethLost <= 100000) {\n\t\t\t// Case 4: 10,000 ETH >= ethLost < 100,000 ETH\n\t\t\tstart = 10000;                                      // start: 10,000 ETH\n\t\t\tend = 100000;                                       // end: 100,000 ETH\n\t\t\tstartRatio = 20 * TWO_DECIMALS;                     // start ratio: 20\n\t\t\tendRatio = 10 * TWO_DECIMALS;                       // end ratio: 10\n\t\t} else if (ethLost > 100000 && ethLost <= 1000000) {\n\t\t\t// Case 5: 100,000 ETH >= ethLost < 1,000,000 ETH\n\t\t\tstart = 100000;                                     // start: 100,000 ETH\n\t\t\tend = 1000000;                                      // end: 1,000,000 ETH\n\t\t\tstartRatio = 10 * TWO_DECIMALS;                     // start ratio: 10\n\t\t\tendRatio = 2 * TWO_DECIMALS;                        // end ratio: 2\n\t\t} else if (ethLost > 1000000 && ethLost <= 10000000) {\n\t\t\t// Case 6: 1,000,000 ETH >= ethLost < 10,000,000 ETH\n\t\t\tstart = 1000000;                                    // start: 1,000,000 ETH\n\t\t\tend = 10000000;                                     // end: 10,000,000 ETH\n\t\t\tstartRatio = 2 * TWO_DECIMALS;                      // start ratio: 2\n\t\t\tendRatio = 40;                                      // end ratio: 0.4\n\t\t} else if (ethLost > 10000000 && ethLost <= 100000000) {\n\t\t\t// Case 7: 10,000,000 ETH >= ethLost < 100,000,000 ETH\n\t\t\tstart = 10000000;                                   // start: 10,000,000 ETH\n\t\t\tend = 100000000;                                    // end: 100,000,000 ETH\n\t\t\tstartRatio = 40;                                    // start ratio: 0.4\n\t\t\tendRatio = 20;                                      // end ratio: 0.2\n\t\t} else if (ethLost > 100000000 && ethLost <= 1000000000) {\n\t\t\t// Case 8: 100,000,000 ETH >= ethLost < 1,000,000,000 ETH\n\t\t\tstart = 100000000;                                  // start: 100,000,000 ETH\n\t\t\tend = 1000000000;                                   // end: 1,000,000,000 ETH\n\t\t\tstartRatio = 20;                                    // start ratio: 0.2\n\t\t\tendRatio = 10;                                      // end ratio: 0.1\n\t\t} else {\n\t\t\t// Case 9: ethLost >= 1,000,000,000 ETH\n\t\t\tuint256 ratio = 10; // ratio: 0.1\n\t\t}\n\n\t\t// Calculate the ratio if necessary\n\t\t// Also, prevent division by 0\n\t\tif (ratio == 0 && (end - start) > 0) {\n\t\t\t/*\n\t\t\t * To prevent negative value for calculating ethLost-start\n\t\t\t * if ethLost = 0, set ethLost = start\n\t\t\t */\n\t\t\tif (ethLost == 0) {\n\t\t\t\tethLost = start;\n\t\t\t}\n\t\t\t/*\n\t\t\t * ratio = ((startRatio - endRatio) * (1-((ethLost - start)/(end-start)))) + endRatio;\n\t\t\t * Let temp = (1-((ethLost - start)/(end-start)))\n\t\t\t * So, ratio = ((startRatio - endRatio) * temp) + endRatio;\n\t\t\t *\n\t\t\t * Mult by TWO_DECIMALS/TWO_DECIMALS to account for two decimals\n\t\t\t * temp = (TWO_DECIMALS * ((1-((ethLost - start)/(end-start)))))/TWO_DECIMALS\n\t\t\t * temp = (TWO_DECIMALS - ((TWO_DECIMALS*(ethLost-start))/(end-start)))/TWO_DECIMALS\n\t\t\t * Take out the TWO_DECIMALS for now and include it in the later calculation\n\t\t\t * temp = TWO_DECIMALS - ((TWO_DECIMALS*(ethLost-start))/(end-start))\n\t\t\t */\n\t\t\tuint256 temp = TWO_DECIMALS.sub(TWO_DECIMALS.mul(ethLost.sub(start)).div(end.sub(start)));\n\t\t\tratio = ((startRatio.sub(endRatio)).mul(temp).div(TWO_DECIMALS)).add(endRatio);\n\t\t}\n\t\treturn ratio;\n\t}\n\n\t/**\n\t * @dev Helper function to help calculates edge modifier for token reward\n\t */\n\tfunction _calculateEdgeMod(address settingAddress, uint256 base, uint256 houseEdge) private constant returns (uint256) {\n\t\t/*\n\t\t * edgeMod = base * (houseEdge% * (2 - houseEdge%) * spinEdgeModifier)\n\t\t * we know houseEdge is the inverse of houseEdge%\n\t\t * so 0 houseEdge is 100%, and 1000 houseEdge is 0%\n\t\t * Therefore, houseEdge% = (HOUSE_EDGE_DIVISOR - houseEdge)/HOUSE_EDGE_DIVISOR\n\t\t *\n\t\t * edgeMod = base * ( ((HOUSE_EDGE_DIVISOR - houseEdge)/HOUSE_EDGE_DIVISOR) * ( 2 - ((HOUSE_EDGE_DIVISOR - houseEdge)/HOUSE_EDGE_DIVISOR)) * spinEdgeModifier)\n\t\t * edgeMod = base * ( ((HOUSE_EDGE_DIVISOR - houseEdge)/HOUSE_EDGE_DIVISOR) * ( 2*(HOUSE_EDGE_DIVISOR/HOUSE_EDGE_DIVISOR) - ((HOUSE_EDGE_DIVISOR - houseEdge)/HOUSE_EDGE_DIVISOR)) * spinEdgeModifier)\n\t\t * edgeMod = base * ( ((HOUSE_EDGE_DIVISOR - houseEdge)/HOUSE_EDGE_DIVISOR) * ( (2*HOUSE_EDGE_DIVISOR - HOUSE_EDGE_DIVISOR + houseEdge)/HOUSE_EDGE_DIVISOR) * spinEdgeModifier)\n\t\t * edgeMod = base * ( ((HOUSE_EDGE_DIVISOR - houseEdge)/HOUSE_EDGE_DIVISOR) * ( (HOUSE_EDGE_DIVISOR + houseEdge)/HOUSE_EDGE_DIVISOR) * spinEdgeModifier)\n\t\t * spinEdgeModifier is also in two decimals, so we need to divide it by TWO_DECIMALS\n\t\t * edgeMod = base * ( ((HOUSE_EDGE_DIVISOR - houseEdge)/HOUSE_EDGE_DIVISOR) * ( (HOUSE_EDGE_DIVISOR + houseEdge)/HOUSE_EDGE_DIVISOR) * (spinEdgeModifier/TWO_DECIMALS))\n\t\t * We multiply first than divide\n\t\t * edgeMod = (((base * (HOUSE_EDGE_DIVISOR - houseEdge) * (HOUSE_EDGE_DIVISOR + houseEdge) * spinEdgeModifier)/HOUSE_EDGE_DIVISOR)/HOUSE_EDGE_DIVISOR)/TWO_DECIMALS\n\t\t */\n\t\treturn (base.mul(HOUSE_EDGE_DIVISOR.sub(houseEdge)).mul(HOUSE_EDGE_DIVISOR.add(houseEdge)).mul(SettingInterface(settingAddress).uintSettings('spinEdgeModifier'))).div(HOUSE_EDGE_DIVISOR).div(HOUSE_EDGE_DIVISOR).div(TWO_DECIMALS);\n\t}\n\n\t/**\n\t * @dev Helper function to help calculates house modifier for token reward\n\t */\n\tfunction _calculateHouseMod(address settingAddress, uint256 base, uint256 houseEdge) private constant returns (uint256) {\n\t\tuint256 replacedBank = (SettingInterface(settingAddress).uintSettings('contractBalanceHonor') >= SettingInterface(settingAddress).uintSettings('minBankrollHonor')) ? SettingInterface(settingAddress).uintSettings('minBankrollHonor') : SettingInterface(settingAddress).uintSettings('contractBalanceHonor');\n\n\t\t/*\n\t\t * we know houseEdge is the inverse of houseEdge%\n\t\t * so 0 houseEdge is 100%, and 1000 houseEdge is 0%\n\t\t */\n\t\tuint256 edgeOn = (houseEdge == 1000) ? 0 : 1;\n\n\t\t/*\n\t\t * this will cap the multiple at the spinEdgeModifier value. NOTE: the 2 - houseEdge% addition. This curves the edge.\n\t\t * houseMod = base *  (((minBankrollHonor - replacedBank)/minBankrollHonor)*spinBankModifier) * edgeOn\n\t\t * spinBankModifier is also in two decimals, so we need to divide it by TWO_DECIMALS\n\t\t * houseMod = base *  ( ((minBankrollHonor - replacedBank) / minBankrollHonor) * (spinBankModifier/TWO_DECIMALS) ) * edgeOn\n\t\t * We multiply first than divide\n\t\t * houseMod = ((base * (minBankrollHonor - replacedBank) * spinBankModifier * edgeOn)/minBankrollHonor)/TWO_DECIMALS\n\t\t */\n\t\tuint256 dividend = (base.mul(SettingInterface(settingAddress).uintSettings('minBankrollHonor').sub(replacedBank)).mul(SettingInterface(settingAddress).uintSettings('spinBankModifier')).mul(edgeOn));\n\t\treturn dividend.div(SettingInterface(settingAddress).uintSettings('minBankrollHonor')).div(TWO_DECIMALS);\n\t}\n\n\t/**\n\t * @dev Helper function to help calculates number modifier for token reward\n\t */\n\tfunction _calculateNumberMod(address settingAddress, uint256 base, uint256 playerNumber, uint256 houseEdge) private constant returns (uint256) {\n\t\t/*\n\t\t * we know houseEdge is the inverse of houseEdge%\n\t\t * so 0 houseEdge is 100%, and 1000 houseEdge is 0%\n\t\t */\n\t\tuint256 edgeOn = (houseEdge == 1000) ? 0 : 1;\n\n\t\t/*\n\t\t * numberMod = base * ((1 + (100 - playerNumber)/100)*spinNumberModifier) * edgeOn\n\t\t * Let temp2 = (1 + (100 - playerNumber)/100)\n\t\t * Mult by TWO_DECIMALS/TWO_DECIMALS to account for two decimals\n\t\t * temp2 = (TWO_DECIMALS * ((1+((100 - playerNumber)/100))))/TWO_DECIMALS\n\t\t * temp2 = (TWO_DECIMALS + ((TWO_DECIMALS*(100-playerNumber))/100))/TWO_DECIMALS\n\t\t * Take out the TWO_DECIMALS for now and include it in the later calculation\n\t\t * temp2 = TWO_DECIMALS + ((TWO_DECIMALS*(100-playerNumber))/100)\n\t\t *\n\t\t * numberMod = base * (temp2/TWO_DECIMALS)*spinNumberModifier * edgeOn\n\t\t * spinNumberModifier is also in two decimals, so we need to divide it by TWO_DECIMALS\n\t\t * numberMod = base * (((temp2/TWO_DECIMALS)*spinNumberModifier)/TWO_DECIMALS) * edgeOn\n\t\t * We multiply first then divide\n\t\t * numberMod = ((base * temp2 * spinNumberModifier*edgeOn)/TWO_DECIMALS)/TWO_DECIMALS\n\t\t */\n\t\tuint256 temp2 = TWO_DECIMALS.add(TWO_DECIMALS.mul(100 - playerNumber).div(100));\n\t\treturn (base.mul(temp2).mul(SettingInterface(settingAddress).uintSettings('spinNumberModifier')).mul(edgeOn)).div(TWO_DECIMALS).div(TWO_DECIMALS);\n\t}\n}",
  "bytecode": "611892610030600b82828239805160001a6073146000811461002057610022565bfe5b5030600052607381538281f30073000000000000000000000000000000000000000030146080604052600436106100a15763ffffffff60e060020a6000350416631c1faa9b81146100a657806323a565c5146100d5578063378f4478146100f257806345a3b9c114610103578063b14ad5b814610140578063caf2976514610148578063dbf93f9814610150578063de7864bb14610158578063e9b32a3f14610172578063f11297681461017a575b600080fd5b6100c3600160a060020a0360043516602435604435606435610197565b60408051918252519081900360200190f35b6100c3600160a060020a03600435166024356044356064356104d7565b6100c360043560243560443561060f565b61011a600160a060020a0360043516602435610667565b604080519485526020850193909352838301919091526060830152519081900360800190f35b6100c36108bd565b6100c36108c2565b6100c36108c9565b6100c3600160a060020a03600435811690602435166108d5565b6100c3610d97565b6100c3600160a060020a0360043581169060243516604435610d9d565b60008080808080806101af438b63ffffffff610f8f16565b95508a600160a060020a03166382d9bfd96040518163ffffffff1660e060020a02815260040180807f6d6178426c6f636b5365637572697479436f756e7400000000000000000000008152506020019050602060405180830381600087803b15801561021a57600080fd5b505af115801561022e573d6000803e3d6000fd5b505050506040513d602081101561024457600080fd5b50516040805160e060020a6382d9bfd90281527f626c6f636b5365637572697479436f756e74000000000000000000000000000060048201529051919650600160a060020a038d16916382d9bfd9916024808201926020929091908290030181600087803b1580156102b557600080fd5b505af11580156102c9573d6000803e3d6000fd5b505050506040513d60208110156102df57600080fd5b50516040805160e060020a6382d9bfd90281527f6d6178426c6f636b5365637572697479436f756e7400000000000000000000006004820152905191955061038e918691600160a060020a038f16916382d9bfd9916024808201926020929091908290030181600087803b15801561035657600080fd5b505af115801561036a573d6000803e3d6000fd5b505050506040513d602081101561038057600080fd5b50519063ffffffff610f8f16565b8610156103ac576103a58a8563ffffffff610fa116565b92506103ef565b6103ec846103e06103d36103c68a8a63ffffffff610fbb16565b899063ffffffff610fd216565b8d9063ffffffff610fa116565b9063ffffffff610fa116565b92505b506000905060015b838110156104c9576104bf60018984610416878663ffffffff610f8f16565b408d60405160200180848152602001836000191660001916815260200182815260200193505050506040516020818303038152906040526040518082805190602001908083835b6020831061047c5780518252601f19909201916020918201910161045d565b5181516020939093036101000a60001901801990911692169190911790526040519201829003909120925050508115156104b257fe5b069063ffffffff610fa116565b91506001016103f7565b509998505050505050505050565b60008080808080806105946104f38b600263ffffffff610fbb16565b8c600160a060020a03166382d9bfd96040518163ffffffff1660e060020a02815260040180807f746f74616c5765694c6f7374486f6e6f720000000000000000000000000000008152506020019050602060405180830381600087803b15801561055c57600080fd5b505af1158015610570573d6000803e3d6000fd5b505050506040513d602081101561058657600080fd5b50519063ffffffff610fa116565b955061059f86610ffd565b94506105c260646105b68c8863ffffffff610fd216565b9063ffffffff610fbb16565b93506105cf8b858a61124e565b92506105dc8b858a611330565b91506105ea8b858b8b611749565b9050610600816103e0858563ffffffff610fa116565b9b9a5050505050505050505050565b600061065f6103e86105b68461065361062f88600163ffffffff610f8f16565b6105b66106438a600163ffffffff610f8f16565b8b9060640363ffffffff610fd216565b9063ffffffff610fd216565b949350505050565b6000806000806000806000806000808b600160a060020a03166382d9bfd96040518163ffffffff1660e060020a02815260040180807f746f6b656e546f57656945786368616e676552617465486f6e6f7200000000008152506020019050602060405180830381600087803b1580156106df57600080fd5b505af11580156106f3573d6000803e3d6000fd5b505050506040513d602081101561070957600080fd5b81019080805190602001909291905050509550610747670de0b6b3a76400006105b6670de0b6b3a76400006105b68f8b610fd290919063ffffffff16565b94506108598c600160a060020a03166382d9bfd96040518163ffffffff1660e060020a02815260040180807f746f6b656e45786368616e67654d696e42616e6b726f6c6c00000000000000008152506020019050602060405180830381600087803b1580156107b557600080fd5b505af11580156107c9573d6000803e3d6000fd5b505050506040513d60208110156107df57600080fd5b81019080805190602001909291905050508d600160a060020a03166382d9bfd96040518163ffffffff1660e060020a02815260040180807f636f6e747261637442616c616e636500000000000000000000000000000000008152506020019050602060405180830381600087803b15801561035657600080fd5b9350848410610870575083915060009050896108aa565b839250610895866105b6670de0b6b3a764000061065381818b8a63ffffffff610f8f16565b91506108a78b8363ffffffff610f8f16565b90505b939b919a50985091965090945050505050565b606481565b620f424081565b670de0b6b3a764000081565b60008060008060008060008089600160a060020a03166382d9bfd96040518163ffffffff1660e060020a02815260040180807f746f74616c5765694c6f7374486f6e6f720000000000000000000000000000008152506020019050602060405180830381600087803b15801561094a57600080fd5b505af115801561095e573d6000803e3d6000fd5b505050506040513d602081101561097457600080fd5b5051965061098187610ffd565b955089600160a060020a03166382d9bfd96040518163ffffffff1660e060020a02815260040180807f7370696e546f57656952617465000000000000000000000000000000000000008152506020019050602060405180830381600087803b1580156109ec57600080fd5b505af1158015610a00573d6000803e3d6000fd5b505050506040513d6020811015610a1657600080fd5b505194506000861115610a4357610a40866105b6670de0b6b3a7640000606463ffffffff610fd216565b94505b88600160a060020a031663697e47616040518163ffffffff1660e060020a028152600401602060405180830381600087803b158015610a8157600080fd5b505af1158015610a95573d6000803e3d6000fd5b505050506040513d6020811015610aab57600080fd5b50516040805160e060020a6382d9bfd90281527f626c6f636b546f5370696e52617465000000000000000000000000000000000060048201529051919550600160a060020a038c16916382d9bfd9916024808201926020929091908290030181600087803b158015610b1c57600080fd5b505af1158015610b30573d6000803e3d6000fd5b505050506040513d6020811015610b4657600080fd5b505192506000841115610b7357610b70846105b6670de0b6b3a7640000606463ffffffff610fd216565b92505b610b8f670de0b6b3a76400006105b6858863ffffffff610fd216565b9150610ccc8a600160a060020a03166382d9bfd96040518163ffffffff1660e060020a02815260040180807f67617350726963650000000000000000000000000000000000000000000000008152506020019050602060405180830381600087803b158015610bfd57600080fd5b505af1158015610c11573d6000803e3d6000fd5b505050506040513d6020811015610c2757600080fd5b50516040805160e060020a6382d9bfd90281527f676173466f72436c656172696e6742657400000000000000000000000000000060048201529051600160a060020a038e16916382d9bfd99160248083019260209291908290030181600087803b158015610c9457600080fd5b505af1158015610ca8573d6000803e3d6000fd5b505050506040513d6020811015610cbe57600080fd5b50519063ffffffff610fd216565b9050811515610d6d5789600160a060020a03166382d9bfd96040518163ffffffff1660e060020a02815260040180807f626c6f636b546f576569526174650000000000000000000000000000000000008152506020019050602060405180830381600087803b158015610d3e57600080fd5b505af1158015610d52573d6000803e3d6000fd5b505050506040513d6020811015610d6857600080fd5b505191505b610d89826105b683670de0b6b3a764000063ffffffff610fd216565b9a9950505050505050505050565b6103e881565b6000806000806000610e2460646105b689600160a060020a0316639585e46a6040518163ffffffff1660e060020a028152600401602060405180830381600087803b158015610deb57600080fd5b505af1158015610dff573d6000803e3d6000fd5b505050506040513d6020811015610e1557600080fd5b5051899063ffffffff610fd216565b935086600160a060020a0316633d5b602d6040518163ffffffff1660e060020a0281526004016040805180830381600087803b158015610e6357600080fd5b505af1158015610e77573d6000803e3d6000fd5b505050506040513d6040811015610e8d57600080fd5b5080516020918201516040805160e060020a6382d9bfd90281527f6c6f74746572795461726765744d756c7469706c69657200000000000000000060048201529051929650909450600160a060020a038b16926382d9bfd9926024808401938290030181600087803b158015610f0257600080fd5b505af1158015610f16573d6000803e3d6000fd5b505050506040513d6020811015610f2c57600080fd5b50519050610f4560646105b6858463ffffffff610fd216565b610f55838663ffffffff610fa116565b1115610f8357610f8082610f7460646105b6878663ffffffff610fd216565b9063ffffffff610f8f16565b93505b50919695505050505050565b600082821115610f9b57fe5b50900390565b600082820183811015610fb057fe5b8091505b5092915050565b6000808284811515610fc957fe5b04949350505050565b600080831515610fe55760009150610fb4565b50828202828482811515610ff557fe5b0414610fb057fe5b60008080808080808061101e89670de0b6b3a764000063ffffffff610fbb16565b9650600087101580156110325750600a8711155b156110515760019550600a945063012fa6609350620186a092506111bb565b600a8711801561106357506103e88711155b1561108157600a95506103e89450620186a0935061271092506111bb565b6103e88711801561109457506127108711155b156110b0576103e8955061271094508493506107d092506111bb565b612710871180156110c45750620186a08711155b156110e3576127109550620186a094506107d093506103e892506111bb565b620186a0871180156110f85750620f42408711155b1561111757620186a09550620f424094506103e8935060c892506111bb565b620f42408711801561112c5750629896808711155b1561114a57620f4240955062989680945060c89350602892506111bb565b629896808711801561116057506305f5e1008711155b1561117f576298968095506305f5e100945060289350601492506111bb565b6305f5e100871180156111965750633b9aca008711155b156111b6576305f5e1009550633b9aca00945060149350600a92506111bb565b600a91505b811580156111cb57506000868603115b15611242578615156111db578596505b6112206112126111f1878963ffffffff610f8f16565b6105b66112048b8b63ffffffff610f8f16565b60649063ffffffff610fd216565b60649063ffffffff610f8f16565b905061123f836103e060646105b6856106538a8663ffffffff610f8f16565b91505b50979650505050505050565b600061065f60646105b66103e86105b66103e86105b68a600160a060020a03166382d9bfd96040518163ffffffff1660e060020a02815260040180807f7370696e456467654d6f646966696572000000000000000000000000000000008152506020019050602060405180830381600087803b1580156112cd57600080fd5b505af11580156112e1573d6000803e3d6000fd5b505050506040513d60208110156112f757600080fd5b505161065361130e6103e88c63ffffffff610fa116565b6106536113236103e88e63ffffffff610f8f16565b8e9063ffffffff610fd216565b60008060008086600160a060020a03166382d9bfd96040518163ffffffff1660e060020a02815260040180806000805160206118478339815191528152506020019050602060405180830381600087803b15801561138d57600080fd5b505af11580156113a1573d6000803e3d6000fd5b505050506040513d60208110156113b757600080fd5b50516040805160e060020a6382d9bfd90281527f636f6e747261637442616c616e6365486f6e6f7200000000000000000000000060048201529051600160a060020a038a16916382d9bfd99160248083019260209291908290030181600087803b15801561142457600080fd5b505af1158015611438573d6000803e3d6000fd5b505050506040513d602081101561144e57600080fd5b505110156114f05786600160a060020a03166382d9bfd96040518163ffffffff1660e060020a02815260040180807f636f6e747261637442616c616e6365486f6e6f720000000000000000000000008152506020019050602060405180830381600087803b1580156114bf57600080fd5b505af11580156114d3573d6000803e3d6000fd5b505050506040513d60208110156114e957600080fd5b5051611574565b86600160a060020a03166382d9bfd96040518163ffffffff1660e060020a02815260040180806000805160206118478339815191528152506020019050602060405180830381600087803b15801561154757600080fd5b505af115801561155b573d6000803e3d6000fd5b505050506040513d602081101561157157600080fd5b50515b9250846103e814611586576001611589565b60005b60ff1691506116a48261065389600160a060020a03166382d9bfd96040518163ffffffff1660e060020a02815260040180807f7370696e42616e6b4d6f646966696572000000000000000000000000000000008152506020019050602060405180830381600087803b1580156115fe57600080fd5b505af1158015611612573d6000803e3d6000fd5b505050506040513d602081101561162857600080fd5b8101908080519060200190929190505050610653611697888d600160a060020a03166382d9bfd96040518163ffffffff1660e060020a02815260040180806000805160206118478339815191528152506020019050602060405180830381600087803b15801561035657600080fd5b8b9063ffffffff610fd216565b905061173e60646105b689600160a060020a03166382d9bfd96040518163ffffffff1660e060020a02815260040180806000805160206118478339815191528152506020019050602060405180830381600087803b15801561170557600080fd5b505af1158015611719573d6000803e3d6000fd5b505050506040513d602081101561172f57600080fd5b5051849063ffffffff610fbb16565b979650505050505050565b6000806000836103e81461175e576001611761565b60005b60ff16915061178e61178060646105b68189810363ffffffff610fd216565b60649063ffffffff610fa116565b905061173e60646105b660646105b6866106538d600160a060020a03166382d9bfd96040518163ffffffff1660e060020a02815260040180807f7370696e4e756d6265724d6f64696669657200000000000000000000000000008152506020019050602060405180830381600087803b15801561180a57600080fd5b505af115801561181e573d6000803e3d6000fd5b505050506040513d602081101561183457600080fd5b50516106538e8a63ffffffff610fd21656006d696e42616e6b726f6c6c486f6e6f7200000000000000000000000000000000a165627a7a72305820182720582c538e43268dd58402edcfa1531199c8498fd436cb8667e63d0c14820029"
}