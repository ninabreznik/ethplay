{
  "address": "0x7caec96607c5c7190d63b5a650e7ce34472352f5",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "Engine",
  "compilerVersion": "v0.4.25+commit.59dbf8f1",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2019-03-11\n*/\n\npragma solidity ^0.4.25;\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, reverts on overflow.\n  */\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (_a == 0) {\n      return 0;\n    }\n\n    uint256 c = _a * _b;\n    require(c / _a == _b);\n\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n  */\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    require(_b > 0); // Solidity only automatically asserts when dividing by 0\n    uint256 c = _a / _b;\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n  /**\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    require(_b <= _a);\n    uint256 c = _a - _b;\n\n    return c;\n  }\n\n  /**\n  * @dev Adds two numbers, reverts on overflow.\n  */\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    uint256 c = _a + _b;\n    require(c >= _a);\n\n    return c;\n  }\n\n  /**\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n  * reverts when dividing by zero.\n  */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0);\n    return a % b;\n  }\n}\n\ncontract DSMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n\n    function min(uint x, uint y) internal pure returns (uint z) {\n        return x <= y ? x : y;\n    }\n    function max(uint x, uint y) internal pure returns (uint z) {\n        return x >= y ? x : y;\n    }\n    function imin(int x, int y) internal pure returns (int z) {\n        return x <= y ? x : y;\n    }\n    function imax(int x, int y) internal pure returns (int z) {\n        return x >= y ? x : y;\n    }\n\n    uint constant WAD = 10 ** 18;\n    uint constant RAY = 10 ** 27;\n\n    function wmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n    function rmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    // This famous algorithm is called \"exponentiation by squaring\"\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\n    //\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\n    //\n    // These facts are why it works:\n    //\n    //  If n is even, then x^n = (x^2)^(n/2).\n    //  If n is odd,  then x^n = x * x^(n-1),\n    //   and applying the equation for even x gives\n    //    x^n = x * (x^2)^((n-1) / 2).\n    //\n    //  Also, EVM division is flooring and\n    //    floor[(n-1) / 2] = floor[n / 2].\n    //\n    function rpow(uint x, uint n) internal pure returns (uint z) {\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n * Altered from https://github.com/OpenZeppelin/openzeppelin-solidity/blob/a466e76d26c394b1faa6e2797aefe34668566392/contracts/token/ERC20/ERC20.sol\n */\ninterface ERC20 {\n  function totalSupply() public view returns (uint256);\n\n  function balanceOf(address _who) public view returns (uint256);\n\n  function allowance(address _owner, address _spender)\n    public view returns (uint256);\n\n  function transfer(address _to, uint256 _value) public returns (bool);\n\n  function approve(address _spender, uint256 _value) public returns (bool);\n\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n\n  event Transfer(\n    address indexed from,\n    address indexed to,\n    uint256 value\n  );\n\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}\n\n/// @dev Just adds extra functions that we use elsewhere\ncontract ERC20WithFields is ERC20 {\n    string public symbol;\n    string public name;\n    uint8 public decimals;\n}\n\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n * Rearranged from https://github.com/OpenZeppelin/openzeppelin-solidity/blob/a466e76d26c394b1faa6e2797aefe34668566392/contracts/token/ERC20/StandardToken.sol\n */\ncontract StandardToken is ERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) balances;\n\n    mapping (address => mapping (address => uint256)) allowed;\n\n    uint256 totalSupply_;\n\n    /**\n     * @dev Total number of tokens in existence\n     */\n    function totalSupply() public view returns (uint256) {\n        return totalSupply_;\n    }\n\n    /**\n     * @dev Gets the balance of the specified address.\n     * @param _owner The address to query the the balance of.\n     * @return An uint256 representing the amount owned by the passed address.\n     */\n    function balanceOf(address _owner) public view returns (uint256) {\n        return balances[_owner];\n    }\n\n    /**\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n     * @param _owner address The address which owns the funds.\n     * @param _spender address The address which will spend the funds.\n     * @return A uint256 specifying the amount of tokens still available for the spender.\n     */\n    function allowance(\n        address _owner,\n        address _spender\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return allowed[_owner][_spender];\n    }\n\n    /**\n    * @dev Transfer token for a specified address\n    * @param _to The address to transfer to.\n    * @param _value The amount to be transferred.\n    */\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_value <= balances[msg.sender]);\n        require(_to != address(0));\n\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    /**\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    * @param _spender The address which will spend the funds.\n        * @param _value The amount of tokens to be spent.\n        */\n    function approve(address _spender, uint256 _value) public returns (bool) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /**\n    * @dev Transfer tokens from one address to another\n    * @param _from address The address which you want to send tokens from\n    * @param _to address The address which you want to transfer to\n    * @param _value uint256 the amount of tokens to be transferred\n    */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        public\n        returns (bool)\n    {\n        require(_value <= balances[_from]);\n        require(_value <= allowed[_from][msg.sender]);\n        require(_to != address(0));\n\n        balances[_from] = balances[_from].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n        emit Approval(_from, msg.sender, allowed[_from][msg.sender]);\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n    * @dev Increase the amount of tokens that an owner allowed to a spender.\n    * approve should be called when allowed[_spender] == 0. To increment\n    * allowed value is better to use this function to avoid 2 calls (and wait until\n    * the first transaction is mined)\n    * From MonolithDAO Token.sol\n    * @param _spender The address which will spend the funds.\n    * @param _addedValue The amount of tokens to increase the allowance by.\n    */\n    function increaseApproval(\n        address _spender,\n        uint256 _addedValue\n    )\n        public\n        returns (bool)\n    {\n        allowed[msg.sender][_spender] = (allowed[msg.sender][_spender].add(_addedValue));\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    /**\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n     * approve should be called when allowed[_spender] == 0. To decrement\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * @param _spender The address which will spend the funds.\n     * @param _subtractedValue The amount of tokens to decrease the allowance by.\n     */\n    function decreaseApproval(\n        address _spender,\n        uint256 _subtractedValue\n    )\n        public\n        returns (bool)\n    {\n        uint256 oldValue = allowed[msg.sender][_spender];\n        if (_subtractedValue >= oldValue) {\n            allowed[msg.sender][_spender] = 0;\n        } else {\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n        }\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    /**\n    * @dev Internal function that mints an amount of the token and assigns it to\n    * an account. This encapsulates the modification of balances such that the\n    * proper events are emitted.\n    * @param _account The account that will receive the created tokens.\n    * @param _amount The amount that will be created.\n     */\n    function _mint(address _account, uint256 _amount) internal {\n        require(_account != 0);\n        totalSupply_ = totalSupply_.add(_amount);\n        balances[_account] = balances[_account].add(_amount);\n        emit Transfer(address(0), _account, _amount);\n    }\n\n    /**\n     * @dev Internal function that burns an amount of the token of a given\n     * account.\n     * @param _account The account whose tokens will be burnt.\n     * @param _amount The amount that will be burnt.\n     */\n    function _burn(address _account, uint256 _amount) internal {\n        require(_account != 0);\n        require(_amount <= balances[_account]);\n\n        totalSupply_ = totalSupply_.sub(_amount);\n        balances[_account] = balances[_account].sub(_amount);\n        emit Transfer(_account, address(0), _amount);\n    }\n\n    /**\n     * @dev Internal function that burns an amount of the token of a given\n     * account, deducting from the sender's allowance for said account. Uses the\n     * internal _burn function.\n     * @param _account The account whose tokens will be burnt.\n     * @param _amount The amount that will be burnt.\n     */\n    function _burnFrom(address _account, uint256 _amount) internal {\n        require(_amount <= allowed[_account][msg.sender]);\n        allowed[_account][msg.sender] = allowed[_account][msg.sender].sub(_amount);\n        emit Approval(_account, msg.sender, allowed[_account][msg.sender]);\n        _burn(_account, _amount);\n    }\n}\n\n\ncontract PreminedToken is StandardToken {\n    string public symbol;\n    string public  name;\n    uint8 public decimals;\n\n    constructor(string _symbol, uint8 _decimals, string _name) public {\n        symbol = _symbol;\n        decimals = _decimals;\n        name = _name;\n        totalSupply_ = 1000000 * 10**uint(decimals);\n        balances[msg.sender] = totalSupply_;\n        emit Transfer(address(0), msg.sender, totalSupply_);\n    }\n}\n\n\n/// @dev Just a wrapper for premined tokens which can actually be burnt\ncontract BurnableToken is PreminedToken {\n    constructor(string _symbol, uint8 _decimals, string _name)\n        public\n        PreminedToken(_symbol, _decimals, _name)\n    {}\n\n    function burn(uint _amount) public {\n        _burn(msg.sender, _amount);\n    }\n    \n    function burnFrom(address from, uint256 value) public {\n        _burnFrom(from, value);\n    }\n}\n\n\n/// @notice Must return a value for an asset\ninterface PriceSourceInterface {\n    event PriceUpdate(address[] token, uint[] price);\n\n    function getQuoteAsset() external view returns (address);\n    function getLastUpdate() external view returns (uint);\n\n    /// @notice Returns false if asset not applicable, or price not recent\n    function hasValidPrice(address) public view returns (bool);\n    function hasValidPrices(address[]) public view returns (bool);\n\n    /// @notice Return the last known price, and when it was issued\n    function getPrice(address _asset) public view returns (uint price, uint timestamp);\n    function getPrices(address[] _assets) public view returns (uint[] prices, uint[] timestamps);\n\n    /// @notice Get price info, and revert if not valid\n    function getPriceInfo(address _asset) view returns (uint price, uint decimals);\n    function getInvertedPriceInfo(address ofAsset) view returns (uint price, uint decimals);\n\n    function getReferencePriceInfo(address _base, address _quote) public view returns (uint referencePrice, uint decimal);\n    function getOrderPriceInfo(address sellAsset, address buyAsset, uint sellQuantity, uint buyQuantity) public view returns (uint orderPrice);\n    function existsPriceOnAssetPair(address sellAsset, address buyAsset) public view returns (bool isExistent);\n    function convertQuantity(\n        uint fromAssetQuantity,\n        address fromAsset,\n        address toAsset\n    ) public view returns (uint);\n}\n\n\ncontract DSAuthority {\n    function canCall(\n        address src, address dst, bytes4 sig\n    ) public view returns (bool);\n}\n\ncontract DSAuthEvents {\n    event LogSetAuthority (address indexed authority);\n    event LogSetOwner     (address indexed owner);\n}\n\ncontract DSAuth is DSAuthEvents {\n    DSAuthority  public  authority;\n    address      public  owner;\n\n    constructor() public {\n        owner = msg.sender;\n        emit LogSetOwner(msg.sender);\n    }\n\n    function setOwner(address owner_)\n        public\n        auth\n    {\n        owner = owner_;\n        emit LogSetOwner(owner);\n    }\n\n    function setAuthority(DSAuthority authority_)\n        public\n        auth\n    {\n        authority = authority_;\n        emit LogSetAuthority(address(authority));\n    }\n\n    modifier auth {\n        require(isAuthorized(msg.sender, msg.sig), \"ds-auth-unauthorized\");\n        _;\n    }\n\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else if (authority == DSAuthority(0)) {\n            return false;\n        } else {\n            return authority.canCall(src, address(this), sig);\n        }\n    }\n}\n\ncontract DSGuardEvents {\n    event LogPermit(\n        bytes32 indexed src,\n        bytes32 indexed dst,\n        bytes32 indexed sig\n    );\n\n    event LogForbid(\n        bytes32 indexed src,\n        bytes32 indexed dst,\n        bytes32 indexed sig\n    );\n}\n\ncontract DSGuard is DSAuth, DSAuthority, DSGuardEvents {\n    bytes32 constant public ANY = bytes32(uint(-1));\n\n    mapping (bytes32 => mapping (bytes32 => mapping (bytes32 => bool))) acl;\n\n    function canCall(\n        address src_, address dst_, bytes4 sig\n    ) public view returns (bool) {\n        bytes32 src = bytes32(bytes20(src_));\n        bytes32 dst = bytes32(bytes20(dst_));\n\n        return acl[src][dst][sig]\n            || acl[src][dst][ANY]\n            || acl[src][ANY][sig]\n            || acl[src][ANY][ANY]\n            || acl[ANY][dst][sig]\n            || acl[ANY][dst][ANY]\n            || acl[ANY][ANY][sig]\n            || acl[ANY][ANY][ANY];\n    }\n\n    function permit(bytes32 src, bytes32 dst, bytes32 sig) public auth {\n        acl[src][dst][sig] = true;\n        emit LogPermit(src, dst, sig);\n    }\n\n    function forbid(bytes32 src, bytes32 dst, bytes32 sig) public auth {\n        acl[src][dst][sig] = false;\n        emit LogForbid(src, dst, sig);\n    }\n\n    function permit(address src, address dst, bytes32 sig) public {\n        permit(bytes32(bytes20(src)), bytes32(bytes20(dst)), sig);\n    }\n    function forbid(address src, address dst, bytes32 sig) public {\n        forbid(bytes32(bytes20(src)), bytes32(bytes20(dst)), sig);\n    }\n\n}\n\ncontract DSGuardFactory {\n    mapping (address => bool)  public  isGuard;\n\n    function newGuard() public returns (DSGuard guard) {\n        guard = new DSGuard();\n        guard.setOwner(msg.sender);\n        isGuard[address(guard)] = true;\n    }\n}\n\n/// @notice Has one Hub\ncontract Spoke is DSAuth {\n    Hub public hub;\n    Hub.Routes public routes;\n    bool public initialized;\n\n    modifier onlyInitialized() {\n        require(initialized, \"Component not yet initialized\");\n        _;\n    }\n\n    modifier notShutDown() {\n        require(!hub.isShutDown(), \"Hub is shut down\");\n        _;\n    }\n\n    constructor(address _hub) {\n        hub = Hub(_hub);\n        setAuthority(hub);\n        setOwner(hub); // temporary, to allow initialization\n    }\n\n    function initialize(address[12] _spokes) external auth {\n        require(msg.sender == address(hub));\n        require(!initialized, \"Already initialized\");\n        routes = Hub.Routes(\n            _spokes[0],\n            _spokes[1],\n            _spokes[2],\n            _spokes[3],\n            _spokes[4],\n            _spokes[5],\n            _spokes[6],\n            _spokes[7],\n            _spokes[8],\n            _spokes[9],\n            _spokes[10],\n            _spokes[11]\n        );\n        initialized = true;\n        setOwner(address(0));\n    }\n\n    function engine() public view returns (address) { return routes.engine; }\n    function mlnToken() public view returns (address) { return routes.mlnToken; }\n    function priceSource() public view returns (address) { return routes.priceSource; }\n    function version() public view returns (address) { return routes.version; }\n    function registry() public view returns (address) { return routes.registry; }\n}\n\n\n/// @notice Router for communication between components\n/// @notice Has one or more Spokes\ncontract Hub is DSGuard {\n\n    event FundShutDown();\n\n    struct Routes {\n        address accounting;\n        address feeManager;\n        address participation;\n        address policyManager;\n        address shares;\n        address trading;\n        address vault;\n        address priceSource;\n        address registry;\n        address version;\n        address engine;\n        address mlnToken;\n    }\n\n    Routes public routes;\n    address public manager;\n    address public creator;\n    string public name;\n    bool public isShutDown;\n    bool public spokesSet;\n    bool public routingSet;\n    bool public permissionsSet;\n    uint public creationTime;\n    mapping (address => bool) public isSpoke;\n\n    constructor(address _manager, string _name) {\n        creator = msg.sender;\n        manager = _manager;\n        name = _name;\n        creationTime = block.timestamp;\n    }\n\n    modifier onlyCreator() {\n        require(msg.sender == creator, \"Only creator can do this\");\n        _;\n    }\n\n    function shutDownFund() external {\n        require(msg.sender == routes.version);\n        isShutDown = true;\n        emit FundShutDown();\n    }\n\n    function setSpokes(address[12] _spokes) external onlyCreator {\n        require(!spokesSet, \"Spokes already set\");\n        for (uint i = 0; i < _spokes.length; i++) {\n            isSpoke[_spokes[i]] = true;\n        }\n        routes.accounting = _spokes[0];\n        routes.feeManager = _spokes[1];\n        routes.participation = _spokes[2];\n        routes.policyManager = _spokes[3];\n        routes.shares = _spokes[4];\n        routes.trading = _spokes[5];\n        routes.vault = _spokes[6];\n        routes.priceSource = _spokes[7];\n        routes.registry = _spokes[8];\n        routes.version = _spokes[9];\n        routes.engine = _spokes[10];\n        routes.mlnToken = _spokes[11];\n        spokesSet = true;\n    }\n\n    function setRouting() external onlyCreator {\n        require(spokesSet, \"Spokes must be set\");\n        require(!routingSet, \"Routing already set\");\n        address[12] memory spokes = [\n            routes.accounting, routes.feeManager, routes.participation,\n            routes.policyManager, routes.shares, routes.trading,\n            routes.vault, routes.priceSource, routes.registry,\n            routes.version, routes.engine, routes.mlnToken\n        ];\n        Spoke(routes.accounting).initialize(spokes);\n        Spoke(routes.feeManager).initialize(spokes);\n        Spoke(routes.participation).initialize(spokes);\n        Spoke(routes.policyManager).initialize(spokes);\n        Spoke(routes.shares).initialize(spokes);\n        Spoke(routes.trading).initialize(spokes);\n        Spoke(routes.vault).initialize(spokes);\n        routingSet = true;\n    }\n\n    function setPermissions() external onlyCreator {\n        require(spokesSet, \"Spokes must be set\");\n        require(routingSet, \"Routing must be set\");\n        require(!permissionsSet, \"Permissioning already set\");\n        permit(routes.participation, routes.vault, bytes4(keccak256('withdraw(address,uint256)')));\n        permit(routes.trading, routes.vault, bytes4(keccak256('withdraw(address,uint256)')));\n        permit(routes.participation, routes.shares, bytes4(keccak256('createFor(address,uint256)')));\n        permit(routes.participation, routes.shares, bytes4(keccak256('destroyFor(address,uint256)')));\n        permit(routes.feeManager, routes.shares, bytes4(keccak256('createFor(address,uint256)')));\n        permit(routes.participation, routes.accounting, bytes4(keccak256('addAssetToOwnedAssets(address)')));\n        permit(routes.trading, routes.accounting, bytes4(keccak256('addAssetToOwnedAssets(address)')));\n        permit(routes.trading, routes.accounting, bytes4(keccak256('removeFromOwnedAssets(address)')));\n        permit(routes.accounting, routes.feeManager, bytes4(keccak256('rewardAllFees()')));\n        permit(manager, routes.policyManager, bytes4(keccak256('register(bytes4,address)')));\n        permit(manager, routes.policyManager, bytes4(keccak256('batchRegister(bytes4[],address[])')));\n        permit(manager, routes.participation, bytes4(keccak256('enableInvestment(address[])')));\n        permit(manager, routes.participation, bytes4(keccak256('disableInvestment(address[])')));\n        permissionsSet = true;\n    }\n\n    function vault() external view returns (address) { return routes.vault; }\n    function accounting() external view returns (address) { return routes.accounting; }\n    function priceSource() external view returns (address) { return routes.priceSource; }\n    function participation() external view returns (address) { return routes.participation; }\n    function trading() external view returns (address) { return routes.trading; }\n    function shares() external view returns (address) { return routes.shares; }\n    function registry() external view returns (address) { return routes.registry; }\n    function policyManager() external view returns (address) { return routes.policyManager; }\n}\n\n\n\n\ncontract Registry is DSAuth {\n\n    // EVENTS\n    event AssetUpsert (\n        address indexed asset,\n        string name,\n        string symbol,\n        uint decimals,\n        string url,\n        uint reserveMin,\n        uint[] standards,\n        bytes4[] sigs\n    );\n\n    event ExchangeAdapterUpsert (\n        address indexed exchange,\n        address indexed adapter,\n        bool takesCustody,\n        bytes4[] sigs\n    );\n\n    event AssetRemoval (address indexed asset);\n    event EfxWrapperRegistryChange(address indexed registry);\n    event EngineChange(address indexed engine);\n    event ExchangeAdapterRemoval (address indexed exchange);\n    event IncentiveChange(uint incentiveAmount);\n    event MGMChange(address indexed MGM);\n    event MlnTokenChange(address indexed mlnToken);\n    event NativeAssetChange(address indexed nativeAsset);\n    event PriceSourceChange(address indexed priceSource);\n    event VersionRegistration(address indexed version);\n\n    // TYPES\n    struct Asset {\n        bool exists;\n        string name;\n        string symbol;\n        uint decimals;\n        string url;\n        uint reserveMin;\n        uint[] standards;\n        bytes4[] sigs;\n    }\n\n    struct Exchange {\n        bool exists;\n        address exchangeAddress;\n        bool takesCustody;\n        bytes4[] sigs;\n    }\n\n    struct Version {\n        bool exists;\n        bytes32 name;\n    }\n\n    // CONSTANTS\n    uint public constant MAX_REGISTERED_ENTITIES = 20;\n    uint public constant MAX_FUND_NAME_BYTES = 66;\n\n    // FIELDS\n    mapping (address => Asset) public assetInformation;\n    address[] public registeredAssets;\n\n    // Mapping from adapter address to exchange Information (Adapters are unique)\n    mapping (address => Exchange) public exchangeInformation;\n    address[] public registeredExchangeAdapters;\n\n    mapping (address => Version) public versionInformation;\n    address[] public registeredVersions;\n\n    mapping (address => bool) public isFeeRegistered;\n\n    mapping (address => address) public fundsToVersions;\n    mapping (bytes32 => bool) public versionNameExists;\n    mapping (bytes32 => address) public fundNameHashToOwner;\n\n\n    uint public incentive = 10 finney;\n    address public priceSource;\n    address public mlnToken;\n    address public nativeAsset;\n    address public engine;\n    address public ethfinexWrapperRegistry;\n    address public MGM;\n\n    modifier onlyVersion() {\n        require(\n            versionInformation[msg.sender].exists,\n            \"Only a Version can do this\"\n        );\n        _;\n    }\n\n    // METHODS\n\n    constructor(address _postDeployOwner) {\n        setOwner(_postDeployOwner);\n    }\n\n    // PUBLIC METHODS\n\n    /// @notice Whether _name has only valid characters\n    function isValidFundName(string _name) public view returns (bool) {\n        bytes memory b = bytes(_name);\n        if (b.length > MAX_FUND_NAME_BYTES) return false;\n        for (uint i; i < b.length; i++){\n            bytes1 char = b[i];\n            if(\n                !(char >= 0x30 && char <= 0x39) && // 9-0\n                !(char >= 0x41 && char <= 0x5A) && // A-Z\n                !(char >= 0x61 && char <= 0x7A) && // a-z\n                !(char == 0x20 || char == 0x2D) && // space, dash\n                !(char == 0x2E || char == 0x5F) && // period, underscore\n                !(char == 0x2A) // *\n            ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /// @notice Whether _user can use _name for their fund\n    function canUseFundName(address _user, string _name) public view returns (bool) {\n        bytes32 nameHash = keccak256(_name);\n        return (\n            isValidFundName(_name) &&\n            (\n                fundNameHashToOwner[nameHash] == address(0) ||\n                fundNameHashToOwner[nameHash] == _user\n            )\n        );\n    }\n\n    function reserveFundName(address _owner, string _name)\n        external\n        onlyVersion\n    {\n        require(canUseFundName(_owner, _name), \"Fund name cannot be used\");\n        fundNameHashToOwner[keccak256(_name)] = _owner;\n    }\n\n    function registerFund(address _fund, address _owner, string _name)\n        external\n        onlyVersion\n    {\n        require(canUseFundName(_owner, _name), \"Fund name cannot be used\");\n        fundsToVersions[_fund] = msg.sender;\n    }\n\n    /// @notice Registers an Asset information entry\n    /// @dev Pre: Only registrar owner should be able to register\n    /// @dev Post: Address _asset is registered\n    /// @param _asset Address of asset to be registered\n    /// @param _name Human-readable name of the Asset\n    /// @param _symbol Human-readable symbol of the Asset\n    /// @param _url Url for extended information of the asset\n    /// @param _standards Integers of EIP standards this asset adheres to\n    /// @param _sigs Function signatures for whitelisted asset functions\n    function registerAsset(\n        address _asset,\n        string _name,\n        string _symbol,\n        string _url,\n        uint _reserveMin,\n        uint[] _standards,\n        bytes4[] _sigs\n    ) external auth {\n        require(registeredAssets.length < MAX_REGISTERED_ENTITIES);\n        require(!assetInformation[_asset].exists);\n        assetInformation[_asset].exists = true;\n        registeredAssets.push(_asset);\n        updateAsset(\n            _asset,\n            _name,\n            _symbol,\n            _url,\n            _reserveMin,\n            _standards,\n            _sigs\n        );\n    }\n\n    /// @notice Register an exchange information entry (A mapping from exchange adapter -> Exchange information)\n    /// @dev Adapters are unique so are used as the mapping key. There may be different adapters for same exchange (0x / Ethfinex)\n    /// @dev Pre: Only registrar owner should be able to register\n    /// @dev Post: Address _exchange is registered\n    /// @param _exchange Address of the exchange for the adapter\n    /// @param _adapter Address of exchange adapter\n    /// @param _takesCustody Whether this exchange takes custody of tokens before trading\n    /// @param _sigs Function signatures for whitelisted exchange functions\n    function registerExchangeAdapter(\n        address _exchange,\n        address _adapter,\n        bool _takesCustody,\n        bytes4[] _sigs\n    ) external auth {\n        require(!exchangeInformation[_adapter].exists, \"Adapter already exists\");\n        exchangeInformation[_adapter].exists = true;\n        require(registeredExchangeAdapters.length < MAX_REGISTERED_ENTITIES, \"Exchange limit reached\");\n        registeredExchangeAdapters.push(_adapter);\n        updateExchangeAdapter(\n            _exchange,\n            _adapter,\n            _takesCustody,\n            _sigs\n        );\n    }\n\n    /// @notice Versions cannot be removed from registry\n    /// @param _version Address of the version contract\n    /// @param _name Name of the version\n    function registerVersion(\n        address _version,\n        bytes32 _name\n    ) external auth {\n        require(!versionInformation[_version].exists, \"Version already exists\");\n        require(!versionNameExists[_name], \"Version name already exists\");\n        versionInformation[_version].exists = true;\n        versionNameExists[_name] = true;\n        versionInformation[_version].name = _name;\n        registeredVersions.push(_version);\n        emit VersionRegistration(_version);\n    }\n\n    function setIncentive(uint _weiAmount) external auth {\n        incentive = _weiAmount;\n        emit IncentiveChange(_weiAmount);\n    }\n\n    function setPriceSource(address _priceSource) external auth {\n        priceSource = _priceSource;\n        emit PriceSourceChange(_priceSource);\n    }\n\n    function setMlnToken(address _mlnToken) external auth {\n        mlnToken = _mlnToken;\n        emit MlnTokenChange(_mlnToken);\n    }\n\n    function setNativeAsset(address _nativeAsset) external auth {\n        nativeAsset = _nativeAsset;\n        emit NativeAssetChange(_nativeAsset);\n    }\n\n    function setEngine(address _engine) external auth {\n        engine = _engine;\n        emit EngineChange(_engine);\n    }\n\n    function setMGM(address _MGM) external auth {\n        MGM = _MGM;\n        emit MGMChange(_MGM);\n    }\n\n    function setEthfinexWrapperRegistry(address _registry) external auth {\n        ethfinexWrapperRegistry = _registry;\n        emit EfxWrapperRegistryChange(_registry);\n    }\n\n    /// @notice Updates description information of a registered Asset\n    /// @dev Pre: Owner can change an existing entry\n    /// @dev Post: Changed Name, Symbol, URL and/or IPFSHash\n    /// @param _asset Address of the asset to be updated\n    /// @param _name Human-readable name of the Asset\n    /// @param _symbol Human-readable symbol of the Asset\n    /// @param _url Url for extended information of the asset\n    function updateAsset(\n        address _asset,\n        string _name,\n        string _symbol,\n        string _url,\n        uint _reserveMin,\n        uint[] _standards,\n        bytes4[] _sigs\n    ) public auth {\n        require(assetInformation[_asset].exists);\n        Asset asset = assetInformation[_asset];\n        asset.name = _name;\n        asset.symbol = _symbol;\n        asset.decimals = ERC20WithFields(_asset).decimals();\n        asset.url = _url;\n        asset.reserveMin = _reserveMin;\n        asset.standards = _standards;\n        asset.sigs = _sigs;\n        emit AssetUpsert(\n            _asset,\n            _name,\n            _symbol,\n            asset.decimals,\n            _url,\n            _reserveMin,\n            _standards,\n            _sigs\n        );\n    }\n\n    function updateExchangeAdapter(\n        address _exchange,\n        address _adapter,\n        bool _takesCustody,\n        bytes4[] _sigs\n    ) public auth {\n        require(exchangeInformation[_adapter].exists, \"Exchange with adapter doesn't exist\");\n        Exchange exchange = exchangeInformation[_adapter];\n        exchange.exchangeAddress = _exchange;\n        exchange.takesCustody = _takesCustody;\n        exchange.sigs = _sigs;\n        emit ExchangeAdapterUpsert(\n            _exchange,\n            _adapter,\n            _takesCustody,\n            _sigs\n        );\n    }\n\n    /// @notice Deletes an existing entry\n    /// @dev Owner can delete an existing entry\n    /// @param _asset address for which specific information is requested\n    function removeAsset(\n        address _asset,\n        uint _assetIndex\n    ) external auth {\n        require(assetInformation[_asset].exists);\n        require(registeredAssets[_assetIndex] == _asset);\n        delete assetInformation[_asset];\n        delete registeredAssets[_assetIndex];\n        for (uint i = _assetIndex; i < registeredAssets.length-1; i++) {\n            registeredAssets[i] = registeredAssets[i+1];\n        }\n        registeredAssets.length--;\n        emit AssetRemoval(_asset);\n    }\n\n    /// @notice Deletes an existing entry\n    /// @dev Owner can delete an existing entry\n    /// @param _adapter address of the adapter of the exchange that is to be removed\n    /// @param _adapterIndex index of the exchange in array\n    function removeExchangeAdapter(\n        address _adapter,\n        uint _adapterIndex\n    ) external auth {\n        require(exchangeInformation[_adapter].exists, \"Exchange with adapter doesn't exist\");\n        require(registeredExchangeAdapters[_adapterIndex] == _adapter, \"Incorrect adapter index\");\n        delete exchangeInformation[_adapter];\n        delete registeredExchangeAdapters[_adapterIndex];\n        for (uint i = _adapterIndex; i < registeredExchangeAdapters.length-1; i++) {\n            registeredExchangeAdapters[i] = registeredExchangeAdapters[i+1];\n        }\n        registeredExchangeAdapters.length--;\n        emit ExchangeAdapterRemoval(_adapter);\n    }\n\n    function registerFees(address[] _fees) external auth {\n        for (uint i; i < _fees.length; i++) {\n            isFeeRegistered[_fees[i]] = true;\n        }\n    }\n\n    function deregisterFees(address[] _fees) external auth {\n        for (uint i; i < _fees.length; i++) {\n            delete isFeeRegistered[_fees[i]];\n        }\n    }\n\n    // PUBLIC VIEW METHODS\n\n    // get asset specific information\n    function getName(address _asset) external view returns (string) {\n        return assetInformation[_asset].name;\n    }\n    function getSymbol(address _asset) external view returns (string) {\n        return assetInformation[_asset].symbol;\n    }\n    function getDecimals(address _asset) external view returns (uint) {\n        return assetInformation[_asset].decimals;\n    }\n    function getReserveMin(address _asset) external view returns (uint) {\n        return assetInformation[_asset].reserveMin;\n    }\n    function assetIsRegistered(address _asset) external view returns (bool) {\n        return assetInformation[_asset].exists;\n    }\n    function getRegisteredAssets() external view returns (address[]) {\n        return registeredAssets;\n    }\n    function assetMethodIsAllowed(address _asset, bytes4 _sig)\n        external\n        view\n        returns (bool)\n    {\n        bytes4[] memory signatures = assetInformation[_asset].sigs;\n        for (uint i = 0; i < signatures.length; i++) {\n            if (signatures[i] == _sig) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // get exchange-specific information\n    function exchangeAdapterIsRegistered(address _adapter) external view returns (bool) {\n        return exchangeInformation[_adapter].exists;\n    }\n    function getRegisteredExchangeAdapters() external view returns (address[]) {\n        return registeredExchangeAdapters;\n    }\n    function getExchangeInformation(address _adapter)\n        public\n        view\n        returns (address, bool)\n    {\n        Exchange exchange = exchangeInformation[_adapter];\n        return (\n            exchange.exchangeAddress,\n            exchange.takesCustody\n        );\n    }\n    function exchangeForAdapter(address _adapter) external view returns (address) {\n        Exchange exchange = exchangeInformation[_adapter];\n        return exchange.exchangeAddress;\n    }\n    function getAdapterFunctionSignatures(address _adapter)\n        public\n        view\n        returns (bytes4[])\n    {\n        return exchangeInformation[_adapter].sigs;\n    }\n    function adapterMethodIsAllowed(\n        address _adapter, bytes4 _sig\n    )\n        external\n        view\n        returns (bool)\n    {\n        bytes4[] memory signatures = exchangeInformation[_adapter].sigs;\n        for (uint i = 0; i < signatures.length; i++) {\n            if (signatures[i] == _sig) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // get version and fund information\n    function getRegisteredVersions() external view returns (address[]) {\n        return registeredVersions;\n    }\n\n    function isFund(address _who) external view returns (bool) {\n        if (fundsToVersions[_who] != address(0)) {\n            return true; // directly from a hub\n        } else {\n            address hub = Hub(Spoke(_who).hub());\n            require(\n                Hub(hub).isSpoke(_who),\n                \"Call from either a spoke or hub\"\n            );\n            return fundsToVersions[hub] != address(0);\n        }\n    }\n\n    function isFundFactory(address _who) external view returns (bool) {\n        return versionInformation[_who].exists;\n    }\n}\n\n\n/// @notice Liquidity contract and token sink\ncontract Engine is DSMath {\n\n    event RegistryChange(address registry);\n    event SetAmguPrice(uint amguPrice);\n    event AmguPaid(uint amount);\n    event Thaw(uint amount);\n    event Burn(uint amount);\n\n    uint public constant MLN_DECIMALS = 18;\n\n    Registry public registry;\n    uint public amguPrice;\n    uint public frozenEther;\n    uint public liquidEther;\n    uint public lastThaw;\n    uint public thawingDelay;\n    uint public totalEtherConsumed;\n    uint public totalAmguConsumed;\n    uint public totalMlnBurned;\n\n    constructor(uint _delay, address _registry) {\n        lastThaw = block.timestamp;\n        thawingDelay = _delay;\n        _setRegistry(_registry);\n    }\n\n    modifier onlyMGM() {\n        require(\n            msg.sender == registry.MGM(),\n            \"Only MGM can call this\"\n        );\n        _;\n    }\n\n    /// @dev Registry owner is MTC\n    modifier onlyMTC() {\n        require(\n            msg.sender == registry.owner(),\n            \"Only MTC can call this\"\n        );\n        _;\n    }\n\n    function _setRegistry(address _registry) internal {\n        registry = Registry(_registry);\n        emit RegistryChange(registry);\n    }\n\n    /// @dev only callable by MTC\n    function setRegistry(address _registry)\n        external\n        onlyMTC\n    {\n        _setRegistry(_registry);\n    }\n\n    /// @dev set price of AMGU in MLN (base units)\n    /// @dev only callable by MGM\n    function setAmguPrice(uint _price)\n        external\n        onlyMGM\n    {\n        amguPrice = _price;\n        emit SetAmguPrice(_price);\n    }\n\n    function getAmguPrice() public view returns (uint) { return amguPrice; }\n\n    function premiumPercent() public view returns (uint) {\n        if (liquidEther < 1 ether) {\n            return 0;\n        } else if (liquidEther >= 1 ether && liquidEther < 5 ether) {\n            return 5;\n        } else if (liquidEther >= 5 ether && liquidEther < 10 ether) {\n            return 10;\n        } else if (liquidEther >= 10 ether) {\n            return 15;\n        }\n    }\n\n    function payAmguInEther() external payable {\n        require(\n            registry.isFundFactory(msg.sender) ||\n            registry.isFund(msg.sender),\n            \"Sender must be a fund or the factory\"\n        );\n        uint mlnPerAmgu = getAmguPrice();\n        uint ethPerMln;\n        (ethPerMln,) = priceSource().getPrice(address(mlnToken()));\n        uint amguConsumed;\n        if (mlnPerAmgu > 0 && ethPerMln > 0) {\n            amguConsumed = (mul(msg.value, 10 ** uint(MLN_DECIMALS))) / (mul(ethPerMln, mlnPerAmgu));\n        } else {\n            amguConsumed = 0;\n        }\n        totalEtherConsumed = add(totalEtherConsumed, msg.value);\n        totalAmguConsumed = add(totalAmguConsumed, amguConsumed);\n        frozenEther = add(frozenEther, msg.value);\n        emit AmguPaid(amguConsumed);\n    }\n\n    /// @notice Move frozen ether to liquid pool after delay\n    /// @dev Delay only restarts when this function is called\n    function thaw() external {\n        require(\n            block.timestamp >= add(lastThaw, thawingDelay),\n            \"Thawing delay has not passed\"\n        );\n        require(frozenEther > 0, \"No frozen ether to thaw\");\n        lastThaw = block.timestamp;\n        liquidEther = add(liquidEther, frozenEther);\n        emit Thaw(frozenEther);\n        frozenEther = 0;\n    }\n\n    /// @return ETH per MLN including premium\n    function enginePrice() public view returns (uint) {\n        uint ethPerMln;\n        (ethPerMln, ) = priceSource().getPrice(address(mlnToken()));\n        uint premium = (mul(ethPerMln, premiumPercent()) / 100);\n        return add(ethPerMln, premium);\n    }\n\n    function ethPayoutForMlnAmount(uint mlnAmount) public view returns (uint) {\n        return mul(mlnAmount, enginePrice()) / 10 ** uint(MLN_DECIMALS);\n    }\n\n    /// @notice MLN must be approved first\n    function sellAndBurnMln(uint mlnAmount) external {\n        require(registry.isFund(msg.sender), \"Only funds can use the engine\");\n        require(\n            mlnToken().transferFrom(msg.sender, address(this), mlnAmount),\n            \"MLN transferFrom failed\"\n        );\n        uint ethToSend = ethPayoutForMlnAmount(mlnAmount);\n        require(ethToSend > 0, \"No ether to pay out\");\n        require(liquidEther >= ethToSend, \"Not enough liquid ether to send\");\n        liquidEther = sub(liquidEther, ethToSend);\n        totalMlnBurned = add(totalMlnBurned, mlnAmount);\n        msg.sender.transfer(ethToSend);\n        mlnToken().burn(mlnAmount);\n        emit Burn(mlnAmount);\n    }\n\n    /// @dev Get MLN from the registry\n    function mlnToken()\n        public\n        view\n        returns (BurnableToken)\n    {\n        return BurnableToken(registry.mlnToken());\n    }\n\n    /// @dev Get PriceSource from the registry\n    function priceSource()\n        public\n        view\n        returns (PriceSourceInterface)\n    {\n        return PriceSourceInterface(registry.priceSource());\n    }\n}",
  "abi": "[{\"constant\":true,\"inputs\":[],\"name\":\"priceSource\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEtherConsumed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalAmguConsumed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"thaw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"payAmguInEther\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAmguPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalMlnBurned\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"mlnAmount\",\"type\":\"uint256\"}],\"name\":\"ethPayoutForMlnAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"liquidEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"frozenEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mlnToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MLN_DECIMALS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"mlnAmount\",\"type\":\"uint256\"}],\"name\":\"sellAndBurnMln\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_registry\",\"type\":\"address\"}],\"name\":\"setRegistry\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastThaw\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"premiumPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amguPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"enginePrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setAmguPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"thawingDelay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_delay\",\"type\":\"uint256\"},{\"name\":\"_registry\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"registry\",\"type\":\"address\"}],\"name\":\"RegistryChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amguPrice\",\"type\":\"uint256\"}],\"name\":\"SetAmguPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AmguPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Thaw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"}]",
  "bytecode": "608060405234801561001057600080fd5b506040516040806111a08339810160405280516020909101514260045560058290556100448164010000000061004b810204565b50506100a5565b60008054600160a060020a031916600160a060020a03838116919091179182905560408051929091168252517f5217946a1da07de64b3844039ef4846e81015e1130f212235a450aa822e86e55916020908290030190a150565b6110ec806100b46000396000f3006080604052600436106101035763ffffffff60e060020a60003504166320531bc9811461010857806337e1dfcc1461013957806338976b50146101605780635920375c146101755780635ce1fb541461018c578063709bb567146101945780637aada77b146101a95780637b103999146101be5780637e3fdf00146101d35780637eced8dc146101eb578063844541f1146102005780638a471df914610215578063927f8d121461022a57806394f7101d1461023f578063a91ee0dc14610257578063ab69c5be14610278578063c8412d021461028d578063cad9faf7146102a2578063d22741b8146102b7578063d69ec025146102cc578063e452bc48146102e4575b600080fd5b34801561011457600080fd5b5061011d6102f9565b60408051600160a060020a039092168252519081900360200190f35b34801561014557600080fd5b5061014e61037f565b60408051918252519081900360200190f35b34801561016c57600080fd5b5061014e610385565b34801561018157600080fd5b5061018a61038b565b005b61018a61049d565b3480156101a057600080fd5b5061014e61078c565b3480156101b557600080fd5b5061014e610792565b3480156101ca57600080fd5b5061011d610798565b3480156101df57600080fd5b5061014e6004356107a7565b3480156101f757600080fd5b5061014e6107d3565b34801561020c57600080fd5b5061014e6107d9565b34801561022157600080fd5b5061011d6107df565b34801561023657600080fd5b5061014e610833565b34801561024b57600080fd5b5061018a600435610838565b34801561026357600080fd5b5061018a600160a060020a0360043516610bc5565b34801561028457600080fd5b5061014e610cae565b34801561029957600080fd5b5061014e610cb4565b3480156102ae57600080fd5b5061014e610d49565b3480156102c357600080fd5b5061014e610d4f565b3480156102d857600080fd5b5061018a600435610e0c565b3480156102f057600080fd5b5061014e610f24565b60008060009054906101000a9004600160a060020a0316600160a060020a03166320531bc96040518163ffffffff1660e060020a028152600401602060405180830381600087803b15801561034d57600080fd5b505af1158015610361573d6000803e3d6000fd5b505050506040513d602081101561037757600080fd5b505190505b90565b60065481565b60075481565b610399600454600554610f2a565b4210156103f0576040805160e560020a62461bcd02815260206004820152601c60248201527f54686177696e672064656c617920686173206e6f742070617373656400000000604482015290519081900360640190fd5b60025460001061044a576040805160e560020a62461bcd02815260206004820152601760248201527f4e6f2066726f7a656e20657468657220746f2074686177000000000000000000604482015290519081900360640190fd5b4260045560035460025461045e9190610f2a565b60035560025460408051918252517f1d80c08fcaae77e805a6ea398f9bf4a855c663cfee51ccdf7144f627019190e79181900360200190a16000600255565b60008054604080517f9b8ce78f000000000000000000000000000000000000000000000000000000008152336004820152905183928392600160a060020a0390911691639b8ce78f9160248082019260209290919082900301818787803b15801561050757600080fd5b505af115801561051b573d6000803e3d6000fd5b505050506040513d602081101561053157600080fd5b5051806105cd575060008054604080517fc7153b890000000000000000000000000000000000000000000000000000000081523360048201529051600160a060020a039092169263c7153b89926024808401936020939083900390910190829087803b1580156105a057600080fd5b505af11580156105b4573d6000803e3d6000fd5b505050506040513d60208110156105ca57600080fd5b50515b1515610648576040805160e560020a62461bcd028152602060048201526024808201527f53656e646572206d75737420626520612066756e64206f72207468652066616360448201527f746f727900000000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b61065061078c565b925061065a6102f9565b600160a060020a03166341976e096106706107df565b6040805160e060020a63ffffffff8516028152600160a060020a03909216600483015280516024808401938290030181600087803b1580156106b157600080fd5b505af11580156106c5573d6000803e3d6000fd5b505050506040513d60408110156106db57600080fd5b505191506000831180156106ef5750600082115b15610721576106fe8284610f8b565b61071034670de0b6b3a7640000610f8b565b81151561071957fe5b049050610725565b5060005b61073160065434610f2a565b6006556007546107419082610f2a565b6007556002546107519034610f2a565b6002556040805182815290517f3e8b952cc45d489522879efd5adf94411f28dd2b821d4e532c7cda1af51050d79181900360200190a1505050565b60015490565b60085481565b600054600160a060020a031681565b6000670de0b6b3a76400006107c3836107be610d4f565b610f8b565b8115156107cc57fe5b0492915050565b60035481565b60025481565b60008060009054906101000a9004600160a060020a0316600160a060020a0316638a471df96040518163ffffffff1660e060020a028152600401602060405180830381600087803b15801561034d57600080fd5b601281565b60008054604080517fc7153b890000000000000000000000000000000000000000000000000000000081523360048201529051600160a060020a039092169163c7153b899160248082019260209290919082900301818787803b15801561089e57600080fd5b505af11580156108b2573d6000803e3d6000fd5b505050506040513d60208110156108c857600080fd5b50511515610920576040805160e560020a62461bcd02815260206004820152601d60248201527f4f6e6c792066756e64732063616e207573652074686520656e67696e65000000604482015290519081900360640190fd5b6109286107df565b604080517f23b872dd000000000000000000000000000000000000000000000000000000008152336004820152306024820152604481018590529051600160a060020a0392909216916323b872dd916064808201926020929091908290030181600087803b15801561099957600080fd5b505af11580156109ad573d6000803e3d6000fd5b505050506040513d60208110156109c357600080fd5b50511515610a1b576040805160e560020a62461bcd02815260206004820152601760248201527f4d4c4e207472616e7366657246726f6d206661696c6564000000000000000000604482015290519081900360640190fd5b610a24826107a7565b905060008111610a7e576040805160e560020a62461bcd02815260206004820152601360248201527f4e6f20657468657220746f20706179206f757400000000000000000000000000604482015290519081900360640190fd5b600354811115610ad8576040805160e560020a62461bcd02815260206004820152601f60248201527f4e6f7420656e6f756768206c697175696420657468657220746f2073656e6400604482015290519081900360640190fd5b610ae460035482610ffe565b600355600854610af49083610f2a565b600855604051339082156108fc029083906000818181858888f19350505050158015610b24573d6000803e3d6000fd5b50610b2d6107df565b600160a060020a03166342966c68836040518263ffffffff1660e060020a02815260040180828152602001915050600060405180830381600087803b158015610b7557600080fd5b505af1158015610b89573d6000803e3d6000fd5b50506040805185815290517fb90306ad06b2a6ff86ddc9327db583062895ef6540e62dc50add009db5b356eb9350908190036020019150a15050565b6000809054906101000a9004600160a060020a0316600160a060020a0316638da5cb5b6040518163ffffffff1660e060020a028152600401602060405180830381600087803b158015610c1757600080fd5b505af1158015610c2b573d6000803e3d6000fd5b505050506040513d6020811015610c4157600080fd5b5051600160a060020a03163314610ca2576040805160e560020a62461bcd02815260206004820152601660248201527f4f6e6c79204d54432063616e2063616c6c207468697300000000000000000000604482015290519081900360640190fd5b610cab81611059565b50565b60045481565b6000670de0b6b3a76400006003541015610cd05750600061037c565b670de0b6b3a764000060035410158015610cf35750674563918244f40000600354105b15610d005750600561037c565b674563918244f4000060035410158015610d235750678ac7230489e80000600354105b15610d305750600a61037c565b600354678ac7230489e800001161037c5750600f61037c565b60015481565b6000806000610d5c6102f9565b600160a060020a03166341976e09610d726107df565b6040805160e060020a63ffffffff8516028152600160a060020a03909216600483015280516024808401938290030181600087803b158015610db357600080fd5b505af1158015610dc7573d6000803e3d6000fd5b505050506040513d6040811015610ddd57600080fd5b505191506064610def836107be610cb4565b811515610df857fe5b049050610e058282610f2a565b9250505090565b6000809054906101000a9004600160a060020a0316600160a060020a031663aa8862ba6040518163ffffffff1660e060020a028152600401602060405180830381600087803b158015610e5e57600080fd5b505af1158015610e72573d6000803e3d6000fd5b505050506040513d6020811015610e8857600080fd5b5051600160a060020a03163314610ee9576040805160e560020a62461bcd02815260206004820152601660248201527f4f6e6c79204d474d2063616e2063616c6c207468697300000000000000000000604482015290519081900360640190fd5b60018190556040805182815290517f6e0f8250ad164a071ea409a83fa1deb674115a68d3eb82a93165573f228b2c5c9181900360200190a150565b60055481565b80820182811015610f85576040805160e560020a62461bcd02815260206004820152601460248201527f64732d6d6174682d6164642d6f766572666c6f77000000000000000000000000604482015290519081900360640190fd5b92915050565b6000811580610fa8575050808202828282811515610fa557fe5b04145b1515610f85576040805160e560020a62461bcd02815260206004820152601460248201527f64732d6d6174682d6d756c2d6f766572666c6f77000000000000000000000000604482015290519081900360640190fd5b80820382811115610f85576040805160e560020a62461bcd02815260206004820152601560248201527f64732d6d6174682d7375622d756e646572666c6f770000000000000000000000604482015290519081900360640190fd5b6000805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a03838116919091179182905560408051929091168252517f5217946a1da07de64b3844039ef4846e81015e1130f212235a450aa822e86e55916020908290030190a1505600a165627a7a7230582086e23a025da3dbfd60ddcbc7cd11bc0f4d67c99a0f9d119e4877aba3a45f115400290000000000000000000000000000000000000000000000000000000000278d000000000000000000000000001bfd21f7db126a5966d2c09492676807a68859ba",
  "constructorArguments": "0000000000000000000000000000000000000000000000000000000000278d000000000000000000000000001bfd21f7db126a5966d2c09492676807a68859ba"
}