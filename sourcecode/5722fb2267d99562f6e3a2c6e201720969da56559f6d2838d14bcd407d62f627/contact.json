{
  "address": "0xc64C4cBA055eFA614CE01F4BAD8A9F519C4f8FaB",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "WhitePaperInterestRateModel",
  "compilerVersion": "v0.5.8+commit.23d335f2",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2019-05-07\n*/\n\n// File: contracts/CarefulMath.sol\n\npragma solidity ^0.5.8;\n\n/**\n  * @title Careful Math\n  * @author Compound\n  * @notice Derived from OpenZeppelin's SafeMath library\n  *         https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n  */\ncontract CarefulMath {\n\n    /**\n     * @dev Possible error codes that we can return\n     */\n    enum MathError {\n        NO_ERROR,\n        DIVISION_BY_ZERO,\n        INTEGER_OVERFLOW,\n        INTEGER_UNDERFLOW\n    }\n\n    /**\n    * @dev Multiplies two numbers, returns an error on overflow.\n    */\n    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        if (a == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n\n        uint c = a * b;\n\n        if (c / a != b) {\n            return (MathError.INTEGER_OVERFLOW, 0);\n        } else {\n            return (MathError.NO_ERROR, c);\n        }\n    }\n\n    /**\n    * @dev Integer division of two numbers, truncating the quotient.\n    */\n    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        if (b == 0) {\n            return (MathError.DIVISION_BY_ZERO, 0);\n        }\n\n        return (MathError.NO_ERROR, a / b);\n    }\n\n    /**\n    * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        if (b <= a) {\n            return (MathError.NO_ERROR, a - b);\n        } else {\n            return (MathError.INTEGER_UNDERFLOW, 0);\n        }\n    }\n\n    /**\n    * @dev Adds two numbers, returns an error on overflow.\n    */\n    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        uint c = a + b;\n\n        if (c >= a) {\n            return (MathError.NO_ERROR, c);\n        } else {\n            return (MathError.INTEGER_OVERFLOW, 0);\n        }\n    }\n\n    /**\n    * @dev add a and b and then subtract c\n    */\n    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n        (MathError err0, uint sum) = addUInt(a, b);\n\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, 0);\n        }\n\n        return subUInt(sum, c);\n    }\n}\n\n// File: contracts/Exponential.sol\n\npragma solidity ^0.5.8;\n\n\n/**\n * @title Exponential module for storing fixed-decision decimals\n * @author Compound\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\n *         `Exp({mantissa: 5100000000000000000})`.\n */\ncontract Exponential is CarefulMath {\n    uint constant expScale = 1e18;\n    uint constant halfExpScale = expScale/2;\n    uint constant mantissaOne = expScale;\n\n    struct Exp {\n        uint mantissa;\n    }\n\n    /**\n     * @dev Creates an exponential from numerator and denominator values.\n     *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\n     *            or if `denom` is zero.\n     */\n    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\n        (MathError err0, uint scaledNumerator) = mulUInt(num, expScale);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        (MathError err1, uint rational) = divUInt(scaledNumerator, denom);\n        if (err1 != MathError.NO_ERROR) {\n            return (err1, Exp({mantissa: 0}));\n        }\n\n        return (MathError.NO_ERROR, Exp({mantissa: rational}));\n    }\n\n    /**\n     * @dev Adds two exponentials, returning a new exponential.\n     */\n    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n        (MathError error, uint result) = addUInt(a.mantissa, b.mantissa);\n\n        return (error, Exp({mantissa: result}));\n    }\n\n    /**\n     * @dev Subtracts two exponentials, returning a new exponential.\n     */\n    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n        (MathError error, uint result) = subUInt(a.mantissa, b.mantissa);\n\n        return (error, Exp({mantissa: result}));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, returning a new Exp.\n     */\n    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n        (MathError err0, uint scaledMantissa) = mulUInt(a.mantissa, scalar);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        return (MathError.NO_ERROR, Exp({mantissa: scaledMantissa}));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n     */\n    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\n        if (err != MathError.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (MathError.NO_ERROR, truncate(product));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\n     */\n    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\n        if (err != MathError.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return addUInt(truncate(product), addend);\n    }\n\n    /**\n     * @dev Divide an Exp by a scalar, returning a new Exp.\n     */\n    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n        (MathError err0, uint descaledMantissa) = divUInt(a.mantissa, scalar);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        return (MathError.NO_ERROR, Exp({mantissa: descaledMantissa}));\n    }\n\n    /**\n     * @dev Divide a scalar by an Exp, returning a new Exp.\n     */\n    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\n        /*\n          We are doing this as:\n          getExp(mulUInt(expScale, scalar), divisor.mantissa)\n\n          How it works:\n          Exp = a / b;\n          Scalar = s;\n          `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\n        */\n        (MathError err0, uint numerator) = mulUInt(expScale, scalar);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n        return getExp(numerator, divisor.mantissa);\n    }\n\n    /**\n     * @dev Divide a scalar by an Exp, then truncate to return an unsigned integer.\n     */\n    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\n        (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\n        if (err != MathError.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (MathError.NO_ERROR, truncate(fraction));\n    }\n\n    /**\n     * @dev Multiplies two exponentials, returning a new exponential.\n     */\n    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n\n        (MathError err0, uint doubleScaledProduct) = mulUInt(a.mantissa, b.mantissa);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        // We add half the scale before dividing so that we get rounding instead of truncation.\n        //  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717\n        // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\n        (MathError err1, uint doubleScaledProductWithHalfScale) = addUInt(halfExpScale, doubleScaledProduct);\n        if (err1 != MathError.NO_ERROR) {\n            return (err1, Exp({mantissa: 0}));\n        }\n\n        (MathError err2, uint product) = divUInt(doubleScaledProductWithHalfScale, expScale);\n        // The only error `div` can return is MathError.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\n        assert(err2 == MathError.NO_ERROR);\n\n        return (MathError.NO_ERROR, Exp({mantissa: product}));\n    }\n\n    /**\n     * @dev Multiplies two exponentials given their mantissas, returning a new exponential.\n     */\n    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\n        return mulExp(Exp({mantissa: a}), Exp({mantissa: b}));\n    }\n\n    /**\n     * @dev Multiplies three exponentials, returning a new exponential.\n     */\n    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\n        (MathError err, Exp memory ab) = mulExp(a, b);\n        if (err != MathError.NO_ERROR) {\n            return (err, ab);\n        }\n        return mulExp(ab, c);\n    }\n\n    /**\n     * @dev Divides two exponentials, returning a new exponential.\n     *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\n     *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\n     */\n    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n        return getExp(a.mantissa, b.mantissa);\n    }\n\n    /**\n     * @dev Truncates the given exp to a whole number value.\n     *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\n     */\n    function truncate(Exp memory exp) pure internal returns (uint) {\n        // Note: We are not using careful math here as we're performing a division that cannot fail\n        return exp.mantissa / expScale;\n    }\n\n    /**\n     * @dev Checks if first Exp is less than second Exp.\n     */\n    function lessThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n        return left.mantissa < right.mantissa; //TODO: Add some simple tests and this in another PR yo.\n    }\n\n    /**\n     * @dev Checks if left Exp <= right Exp.\n     */\n    function lessThanOrEqualExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n        return left.mantissa <= right.mantissa;\n    }\n\n    /**\n     * @dev returns true if Exp is exactly zero\n     */\n    function isZeroExp(Exp memory value) pure internal returns (bool) {\n        return value.mantissa == 0;\n    }\n}\n\n// File: contracts/InterestRateModel.sol\n\npragma solidity ^0.5.8;\n\n/**\n  * @title The Compound InterestRateModel Interface\n  * @author Compound\n  * @notice Any interest rate model should derive from this contract.\n  * @dev These functions are specifically not marked `pure` as implementations of this\n  *      contract may read from storage variables.\n  */\ninterface InterestRateModel {\n    /**\n      * @notice Gets the current borrow interest rate based on the given asset, total cash, total borrows\n      *         and total reserves.\n      * @dev The return value should be scaled by 1e18, thus a return value of\n      *      `(true, 1000000000000)` implies an interest rate of 0.000001 or 0.0001% *per block*.\n      * @param cash The total cash of the underlying asset in the CToken\n      * @param borrows The total borrows of the underlying asset in the CToken\n      * @param reserves The total reserves of the underlying asset in the CToken\n      * @return Success or failure and the borrow interest rate per block scaled by 10e18\n      */\n    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint, uint);\n\n    /**\n      * @notice Marker function used for light validation when updating the interest rate model of a market\n      * @dev Marker function used for light validation when updating the interest rate model of a market. Implementations should simply return true.\n      * @return Success or failure\n      */\n    function isInterestRateModel() external view returns (bool);\n}\n\n// File: contracts/WhitePaperInterestRateModel.sol\n\npragma solidity ^0.5.8;\n\n\n\n/**\n  * @title The Compound Standard Interest Rate Model with pluggable constants\n  * @author Compound\n  * @notice See Section 2.4 of the Compound Whitepaper\n  */\ncontract WhitePaperInterestRateModel is InterestRateModel, Exponential {\n    /**\n     * @notice Indicator that this is an InterestRateModel contract (for inspection)\n     */\n    bool public constant isInterestRateModel = true;\n\n    /**\n     * @notice The multiplier of utilization rate that gives the slope of the interest rate\n     */\n    uint public multiplier;\n\n    /**\n     * @notice The base interest rate which is the y-intercept when utilization rate is 0\n     */\n    uint public baseRate;\n\n    /**\n     * @notice The approximate number of blocks per year that is assumed by the interest rate model\n     */\n    uint public constant blocksPerYear = 2102400;\n\n    constructor(uint baseRate_, uint multiplier_) public {\n        baseRate = baseRate_;\n        multiplier = multiplier_;\n    }\n\n    enum IRError {\n        NO_ERROR,\n        FAILED_TO_ADD_CASH_PLUS_BORROWS,\n        FAILED_TO_GET_EXP,\n        FAILED_TO_MUL_UTILIZATION_RATE,\n        FAILED_TO_ADD_BASE_RATE\n    }\n\n    /*\n     * @dev Calculates the utilization rate (borrows / (cash + borrows)) as an Exp\n     */\n    function getUtilizationRate(uint cash, uint borrows) pure internal returns (IRError, Exp memory) {\n        if (borrows == 0) {\n            // Utilization rate is zero when there's no borrows\n            return (IRError.NO_ERROR, Exp({mantissa: 0}));\n        }\n\n        (MathError err0, uint cashPlusBorrows) = addUInt(cash, borrows);\n        if (err0 != MathError.NO_ERROR) {\n            return (IRError.FAILED_TO_ADD_CASH_PLUS_BORROWS, Exp({mantissa: 0}));\n        }\n\n        (MathError err1, Exp memory utilizationRate) = getExp(borrows, cashPlusBorrows);\n        if (err1 != MathError.NO_ERROR) {\n            return (IRError.FAILED_TO_GET_EXP, Exp({mantissa: 0}));\n        }\n\n        return (IRError.NO_ERROR, utilizationRate);\n    }\n\n    /*\n     * @dev Calculates the utilization and borrow rates for use by getBorrowRate function\n     */\n    function getUtilizationAndAnnualBorrowRate(uint cash, uint borrows) view internal returns (IRError, Exp memory, Exp memory) {\n        (IRError err0, Exp memory utilizationRate) = getUtilizationRate(cash, borrows);\n        if (err0 != IRError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}), Exp({mantissa: 0}));\n        }\n\n        // Borrow Rate is 5% + UtilizationRate * 45% (baseRate + UtilizationRate * multiplier);\n        // 45% of utilizationRate, is `rate * 45 / 100`\n        (MathError err1, Exp memory utilizationRateMuled) = mulScalar(utilizationRate, multiplier);\n        // `mulScalar` only overflows when the product is >= 2^256.\n        // utilizationRate is a real number on the interval [0,1], which means that\n        // utilizationRate.mantissa is in the interval [0e18,1e18], which means that 45 times\n        // that is in the interval [0e18,45e18]. That interval has no intersection with 2^256, and therefore\n        // this can never overflow for the standard rates.\n        if (err1 != MathError.NO_ERROR) {\n            return (IRError.FAILED_TO_MUL_UTILIZATION_RATE, Exp({mantissa: 0}), Exp({mantissa: 0}));\n        }\n\n        (MathError err2, Exp memory utilizationRateScaled) = divScalar(utilizationRateMuled, mantissaOne);\n        // 100 is a constant, and therefore cannot be zero, which is the only error case of divScalar.\n        assert(err2 == MathError.NO_ERROR);\n\n        // Add the 5% for (5% + 45% * Ua)\n        (MathError err3, Exp memory annualBorrowRate) = addExp(utilizationRateScaled, Exp({mantissa: baseRate}));\n        // `addExp` only fails when the addition of mantissas overflow.\n        // As per above, utilizationRateMuled is capped at 45e18,\n        // and utilizationRateScaled is capped at 4.5e17. mantissaFivePercent = 0.5e17, and thus the addition\n        // is capped at 5e17, which is less than 2^256. This only applies to the standard rates\n        if (err3 != MathError.NO_ERROR) {\n            return (IRError.FAILED_TO_ADD_BASE_RATE, Exp({mantissa: 0}), Exp({mantissa: 0}));\n        }\n\n        return (IRError.NO_ERROR, utilizationRate, annualBorrowRate);\n    }\n\n    /**\n      * @notice Gets the current borrow interest rate based on the given asset, total cash, total borrows\n      *         and total reserves.\n      * @dev The return value should be scaled by 1e18, thus a return value of\n      *      `(true, 1000000000000)` implies an interest rate of 0.000001 or 0.0001% *per block*.\n      * @param cash The total cash of the underlying asset in the CToken\n      * @param borrows The total borrows of the underlying asset in the CToken\n      * @param _reserves The total reserves of the underlying asset in the CToken\n      * @return Success or failure and the borrow interest rate per block scaled by 10e18\n      */\n    function getBorrowRate(uint cash, uint borrows, uint _reserves) public view returns (uint, uint) {\n        _reserves; // pragma ignore unused argument\n\n        (IRError err0, Exp memory _utilizationRate, Exp memory annualBorrowRate) = getUtilizationAndAnnualBorrowRate(cash, borrows);\n        if (err0 != IRError.NO_ERROR) {\n            return (uint(err0), 0);\n        }\n\n        // And then divide down by blocks per year.\n        (MathError err1, Exp memory borrowRate) = divScalar(annualBorrowRate, blocksPerYear); // basis points * blocks per year\n        // divScalar only fails when divisor is zero. This is clearly not the case.\n        assert(err1 == MathError.NO_ERROR);\n\n        _utilizationRate; // pragma ignore unused variable\n\n        // Note: mantissa is the rate scaled 1e18, which matches the expected result\n        return (uint(IRError.NO_ERROR), borrowRate.mantissa);\n    }\n}",
  "bytecode": "608060405234801561001057600080fd5b506040516040806106638339810180604052604081101561003057600080fd5b508051602090910151600191909155600055610612806100516000396000f3fe608060405234801561001057600080fd5b50600436106100575760003560e01c806315f240531461005c5780631b3ed7221461009e5780631f68f20a146100b85780632191f92a146100c0578063a385fb96146100dc575b600080fd5b6100856004803603606081101561007257600080fd5b50803590602081013590604001356100e4565b6040805192835260208301919091528051918290030190f35b6100a661017d565b60408051918252519081900360200190f35b6100a6610183565b6100c8610189565b604080519115158252519081900360200190f35b6100a661018e565b60008060006100f16105d3565b6100f96105d3565b6101038888610195565b91945092509050600083600481111561011857fe5b146101385782600481111561012957fe5b94506000935061017592505050565b60006101426105d3565b61014f8362201480610312565b9092509050600082600381111561016257fe5b1461016957fe5b51600096509450505050505b935093915050565b60005481565b60015481565b600181565b6220148081565b600061019f6105d3565b6101a76105d3565b60006101b16105d3565b6101bb878761037c565b909250905060008260048111156101ce57fe5b146101fc5750604080516020808201835260008083528351918201909352918252919450909250905061030b565b60006102066105d3565b6102128360005461043e565b9092509050600082600381111561022557fe5b14610257575050604080516020808201835260008083528351918201909352918252600396509450925061030b915050565b60006102616105d3565b61027383670de0b6b3a7640000610312565b9092509050600082600381111561028657fe5b1461028d57fe5b60006102976105d3565b6102b1836040518060200160405280600154815250610459565b909250905060008260038111156102c457fe5b146102fa57505060408051602080820183526000808352835191820190935291825260049a509850965061030b95505050505050565b60009a509598509496505050505050505b9250925092565b600061031c6105d3565b60008061032d866000015186610493565b9092509050600082600381111561034057fe5b1461035f57506040805160208101909152600081529092509050610375565b6040805160208101909152908152600093509150505b9250929050565b60006103866105d3565b826103a35750506040805160208101909152600080825290610375565b6000806103b086866104be565b909250905060008260038111156103c357fe5b146103e4575050604080516020810190915260008152600192509050610375565b60006103ee6105d3565b6103f887846104e4565b9092509050600082600381111561040b57fe5b1461042f575050604080516020810190915260008152600294509250610375915050565b60009890975095505050505050565b60006104486105d3565b60008061032d866000015186610594565b60006104636105d3565b600080610478866000015186600001516104be565b60408051602081019091529081529097909650945050505050565b600080826104a75750600190506000610375565b60008385816104b257fe5b04915091509250929050565b6000808383018481106104d657600092509050610375565b506002915060009050610375565b60006104ee6105d3565b60008061050386670de0b6b3a7640000610594565b9092509050600082600381111561051657fe5b1461053557506040805160208101909152600081529092509050610375565b6000806105428388610493565b9092509050600082600381111561055557fe5b1461057757506040805160208101909152600081529094509250610375915050565b604080516020810190915290815260009890975095505050505050565b600080836105a757506000905080610375565b838302838582816105b457fe5b04146105c857506002915060009050610375565b600092509050610375565b604051806020016040528060008152509056fea165627a7a7230582021d1e96de1a54e5aaf17c19ae397dd393fa0cd21afedd016b0e6d1fb0e4c74960029000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002c68af0bb140000",
  "constructorArguments": "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002c68af0bb140000"
}