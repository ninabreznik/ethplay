{
  "address": "0xa5c9ecf54790334b73e5dfa1ff5668eb425dc474",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "TokenNetwork",
  "compilerVersion": "v0.4.25+commit.59dbf8f1",
  "optimization": false,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2018-10-25\n*/\n\npragma solidity ^0.4.23;\n\n/// @title Utils\n/// @notice Utils contract for various helpers used by the Raiden Network smart\n/// contracts.\ncontract Utils {\n    string constant public contract_version = \"0.4.0\";\n\n    /// @notice Check if a contract exists\n    /// @param contract_address The address to check whether a contract is\n    /// deployed or not\n    /// @return True if a contract exists, false otherwise\n    function contractExists(address contract_address) public view returns (bool) {\n        uint size;\n\n        assembly {\n            size := extcodesize(contract_address)\n        }\n\n        return size > 0;\n    }\n}\n\n\ninterface Token {\n\n    /// @return total amount of tokens\n    function totalSupply() external view returns (uint256 supply);\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return The balance\n    function balanceOf(address _owner) external view returns (uint256 balance);\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return Whether the transfer was successful or not\n    function transfer(address _to, uint256 _value) external returns (bool success);\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of wei to be approved for transfer\n    /// @return Whether the approval was successful or not\n    function approve(address _spender, uint256 _value) external returns (bool success);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens allowed to spent\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    // Optionally implemented function to show the number of decimals for the token\n    function decimals() external view returns (uint8 decimals);\n}\n\n\nlibrary ECVerify {\n\n    function ecverify(bytes32 hash, bytes signature)\n        internal\n        pure\n        returns (address signature_address)\n    {\n        require(signature.length == 65);\n\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // The signature format is a compact form of:\n        //   {bytes32 r}{bytes32 s}{uint8 v}\n        // Compact means, uint8 is not padded to 32 bytes.\n        assembly {\n            r := mload(add(signature, 32))\n            s := mload(add(signature, 64))\n\n            // Here we are loading the last 32 bytes, including 31 bytes of 's'.\n            v := byte(0, mload(add(signature, 96)))\n        }\n\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible\n        if (v < 27) {\n            v += 27;\n        }\n\n        require(v == 27 || v == 28);\n\n        signature_address = ecrecover(hash, v, r, s);\n\n        // ecrecover returns zero on error\n        require(signature_address != address(0x0));\n\n        return signature_address;\n    }\n}\n\n\n/// @title SecretRegistry\n/// @notice SecretRegistry contract for registering secrets from Raiden Network\n/// clients.\ncontract SecretRegistry {\n\n    string constant public contract_version = \"0.4.0\";\n\n    // keccak256(secret) => block number at which the secret was revealed\n    mapping(bytes32 => uint256) private secrethash_to_block;\n\n    event SecretRevealed(bytes32 indexed secrethash, bytes32 secret);\n\n    /// @notice Registers a hash time lock secret and saves the block number.\n    /// This allows the lock to be unlocked after the expiration block.\n    /// @param secret The secret used to lock the hash time lock.\n    /// @return true if secret was registered, false if the secret was already\n    /// registered.\n    function registerSecret(bytes32 secret) public returns (bool) {\n        bytes32 secrethash = keccak256(abi.encodePacked(secret));\n        if (secret == bytes32(0x0) || secrethash_to_block[secrethash] > 0) {\n            return false;\n        }\n        secrethash_to_block[secrethash] = block.number;\n        emit SecretRevealed(secrethash, secret);\n        return true;\n    }\n\n    /// @notice Registers multiple hash time lock secrets and saves the block\n    /// number.\n    /// @param secrets The array of secrets to be registered.\n    /// @return true if all secrets could be registered, false otherwise.\n    function registerSecretBatch(bytes32[] secrets) public returns (bool) {\n        bool completeSuccess = true;\n        for(uint i = 0; i < secrets.length; i++) {\n            if(!registerSecret(secrets[i])) {\n                completeSuccess = false;\n            }\n        }\n        return completeSuccess;\n    }\n\n    /// @notice Get the stored block number at which the secret was revealed.\n    /// @param secrethash The hash of the registered secret `keccak256(secret)`.\n    /// @return The block number at which the secret was revealed.\n    function getSecretRevealBlockHeight(bytes32 secrethash) public view returns (uint256) {\n        return secrethash_to_block[secrethash];\n    }\n}\n\n\n\n/// @title TokenNetwork\n/// @notice Stores and manages all the Raiden Network channels that use the\n/// token specified\n/// in this TokenNetwork contract.\ncontract TokenNetwork is Utils {\n\n    string constant public contract_version = \"0.4.0\";\n\n    // Instance of the token used by the channels\n    Token public token;\n\n    // Instance of SecretRegistry used for storing secrets revealed in a\n    // mediating transfer.\n    SecretRegistry public secret_registry;\n\n    // Chain ID as specified by EIP155 used in balance proof signatures to\n    // avoid replay attacks\n    uint256 public chain_id;\n\n    uint256 public settlement_timeout_min;\n    uint256 public settlement_timeout_max;\n\n    uint256 constant public MAX_SAFE_UINT256 = (\n        115792089237316195423570985008687907853269984665640564039457584007913129639935\n    );\n\n    // Red Eyes release deposit limits\n    // The combined deposit of one channel is limited to 0.15 ETH.\n    // So 0.075 ETH per participant.\n    uint256 constant public channel_participant_deposit_limit = 75000000000000000 wei;\n    // The total combined deposit of all channels across the whole network is\n    // limited to 250 ETH.\n    uint256 constant public token_network_deposit_limit = 250000000000000000000 wei;\n\n    // Global, monotonically increasing counter that keeps track of all the\n    // opened channels in this contract\n    uint256 public channel_counter;\n\n    string public constant signature_prefix = '\\x19Ethereum Signed Message:\\n';\n\n    // Only for the limited Red Eyes release\n    address public deprecation_executor;\n    bool public safety_deprecation_switch = false;\n\n    // channel_identifier => Channel\n    // channel identifier is the channel_counter value at the time of opening\n    // the channel\n    mapping (uint256 => Channel) public channels;\n\n    // This is needed to enforce one channel per pair of participants\n    // The key is keccak256(participant1_address, participant2_address)\n    mapping (bytes32 => uint256) public participants_hash_to_channel_identifier;\n\n    // We keep the unlock data in a separate mapping to allow channel data\n    // structures to be removed when settling uncooperatively. If there are\n    // locked pending transfers, we need to store data needed to unlock them at\n    // a later time.\n    // The key is `keccak256(uint256 channel_identifier, address participant,\n    // address partner)` Where `participant` is the participant that sent the\n    // pending transfers We need `partner` for knowing where to send the\n    // claimable tokens\n    mapping(bytes32 => UnlockData) private unlock_identifier_to_unlock_data;\n\n    struct Participant {\n        // Total amount of tokens transferred to this smart contract through\n        // the `setTotalDeposit` function, for a specific channel, in the\n        // participant's benefit.\n        // This is a strictly monotonic value. Note that direct token transfer\n        // cannot be tracked and will be burned.\n        uint256 deposit;\n\n        // Total amount of tokens withdrawn by the participant during the\n        // lifecycle of this channel.\n        // This is a strictly monotonic value.\n        uint256 withdrawn_amount;\n\n        // This is a value set to true after the channel has been closed, only\n        // if this is the participant who closed the channel.\n        bool is_the_closer;\n\n        // keccak256 of the balance data provided after a closeChannel or an\n        // updateNonClosingBalanceProof call\n        bytes32 balance_hash;\n\n        // Monotonically increasing counter of the off-chain transfers,\n        // provided along with the balance_hash\n        uint256 nonce;\n    }\n\n    enum ChannelState {\n        NonExistent, // 0\n        Opened,      // 1\n        Closed,      // 2\n        Settled,     // 3; Note: The channel has at least one pending unlock\n        Removed      // 4; Note: Channel data is removed, there are no pending unlocks\n    }\n\n    enum MessageTypeId {\n        None,\n        BalanceProof,\n        BalanceProofUpdate,\n        Withdraw,\n        CooperativeSettle\n    }\n\n    struct Channel {\n        // After opening the channel this value represents the settlement\n        // window. This is the number of blocks that need to be mined between\n        // closing the channel uncooperatively and settling the channel.\n        // After the channel has been uncooperatively closed, this value\n        // represents the block number after which settleChannel can be called.\n        uint256 settle_block_number;\n\n        ChannelState state;\n\n        mapping(address => Participant) participants;\n    }\n\n    struct SettlementData {\n        uint256 deposit;\n        uint256 withdrawn;\n        uint256 transferred;\n        uint256 locked;\n    }\n\n    struct UnlockData {\n        // Merkle root of the pending transfers tree from the Raiden client\n        bytes32 locksroot;\n        // Total amount of tokens locked in the pending transfers corresponding\n        // to the `locksroot`\n        uint256 locked_amount;\n    }\n\n    event ChannelOpened(\n        uint256 indexed channel_identifier,\n        address indexed participant1,\n        address indexed participant2,\n        uint256 settle_timeout\n    );\n\n    event ChannelNewDeposit(\n        uint256 indexed channel_identifier,\n        address indexed participant,\n        uint256 total_deposit\n    );\n\n    // total_withdraw is how much the participant has withdrawn during the\n    // lifetime of the channel. The actual amount which the participant withdrew\n    // is `total_withdraw - total_withdraw_from_previous_event_or_zero`\n    /* event ChannelWithdraw(\n        uint256 indexed channel_identifier,\n        address indexed participant,\n        uint256 total_withdraw\n    ); */\n\n    event ChannelClosed(\n        uint256 indexed channel_identifier,\n        address indexed closing_participant,\n        uint256 indexed nonce\n    );\n\n    event ChannelUnlocked(\n        uint256 indexed channel_identifier,\n        address indexed participant,\n        address indexed partner,\n        bytes32 locksroot,\n        uint256 unlocked_amount,\n        uint256 returned_tokens\n    );\n\n    event NonClosingBalanceProofUpdated(\n        uint256 indexed channel_identifier,\n        address indexed closing_participant,\n        uint256 indexed nonce\n    );\n\n    event ChannelSettled(\n        uint256 indexed channel_identifier,\n        uint256 participant1_amount,\n        uint256 participant2_amount\n    );\n\n    modifier onlyDeprecationExecutor() {\n        require(msg.sender == deprecation_executor);\n        _;\n    }\n\n    modifier isSafe() {\n        require(safety_deprecation_switch == false);\n        _;\n    }\n\n    modifier isOpen(uint256 channel_identifier) {\n        require(channels[channel_identifier].state == ChannelState.Opened);\n        _;\n    }\n\n    modifier settleTimeoutValid(uint256 timeout) {\n        require(timeout >= settlement_timeout_min);\n        require(timeout <= settlement_timeout_max);\n        _;\n    }\n\n    constructor(\n        address _token_address,\n        address _secret_registry,\n        uint256 _chain_id,\n        uint256 _settlement_timeout_min,\n        uint256 _settlement_timeout_max,\n        address _deprecation_executor\n    )\n        public\n    {\n        require(_token_address != address(0x0));\n        require(_secret_registry != address(0x0));\n        require(_deprecation_executor != address(0x0));\n        require(_chain_id > 0);\n        require(_settlement_timeout_min > 0);\n        require(_settlement_timeout_max > _settlement_timeout_min);\n        require(contractExists(_token_address));\n        require(contractExists(_secret_registry));\n\n        token = Token(_token_address);\n\n        secret_registry = SecretRegistry(_secret_registry);\n        chain_id = _chain_id;\n        settlement_timeout_min = _settlement_timeout_min;\n        settlement_timeout_max = _settlement_timeout_max;\n\n        // Make sure the contract is indeed a token contract\n        require(token.totalSupply() > 0);\n\n        deprecation_executor = _deprecation_executor;\n    }\n\n    function deprecate() isSafe onlyDeprecationExecutor public {\n        safety_deprecation_switch = true;\n    }\n\n    /// @notice Opens a new channel between `participant1` and `participant2`.\n    /// Can be called by anyone.\n    /// @param participant1 Ethereum address of a channel participant.\n    /// @param participant2 Ethereum address of the other channel participant.\n    /// @param settle_timeout Number of blocks that need to be mined between a\n    /// call to closeChannel and settleChannel.\n    function openChannel(address participant1, address participant2, uint256 settle_timeout)\n        isSafe\n        settleTimeoutValid(settle_timeout)\n        public\n        returns (uint256)\n    {\n        bytes32 pair_hash;\n        uint256 channel_identifier;\n\n        // Red Eyes release token network limit\n        require(token.balanceOf(address(this)) < token_network_deposit_limit);\n\n        // First increment the counter\n        // There will never be a channel with channel_identifier == 0\n        channel_counter += 1;\n        channel_identifier = channel_counter;\n\n        pair_hash = getParticipantsHash(participant1, participant2);\n\n        // There must only be one channel opened between two participants at\n        // any moment in time.\n        require(participants_hash_to_channel_identifier[pair_hash] == 0);\n        participants_hash_to_channel_identifier[pair_hash] = channel_identifier;\n\n        Channel storage channel = channels[channel_identifier];\n\n        // We always increase the channel counter, therefore no channel data can already exist,\n        // corresponding to this channel_identifier. This check must never fail.\n        assert(channel.settle_block_number == 0);\n        assert(channel.state == ChannelState.NonExistent);\n\n        // Store channel information\n        channel.settle_block_number = settle_timeout;\n        channel.state = ChannelState.Opened;\n\n        emit ChannelOpened(\n            channel_identifier,\n            participant1,\n            participant2,\n            settle_timeout\n        );\n\n        return channel_identifier;\n    }\n\n    /// @notice Sets the channel participant total deposit value.\n    /// Can be called by anyone.\n    /// @param channel_identifier Identifier for the channel on which this\n    /// operation takes place.\n    /// @param participant Channel participant whose deposit is being set.\n    /// @param total_deposit The total amount of tokens that the participant\n    /// will have as a deposit.\n    /// @param partner Channel partner address, needed to compute the total\n    /// channel deposit.\n    function setTotalDeposit(\n        uint256 channel_identifier,\n        address participant,\n        uint256 total_deposit,\n        address partner\n    )\n        isSafe\n        isOpen(channel_identifier)\n        public\n    {\n        require(channel_identifier == getChannelIdentifier(participant, partner));\n        require(total_deposit > 0);\n        require(total_deposit <= channel_participant_deposit_limit);\n\n        uint256 added_deposit;\n        uint256 channel_deposit;\n\n        Channel storage channel = channels[channel_identifier];\n        Participant storage participant_state = channel.participants[participant];\n        Participant storage partner_state = channel.participants[partner];\n\n        // Calculate the actual amount of tokens that will be transferred\n        added_deposit = total_deposit - participant_state.deposit;\n\n        // The actual amount of tokens that will be transferred must be > 0\n        require(added_deposit > 0);\n\n        // Underflow check; we use <= because added_deposit == total_deposit for the first deposit\n\n        require(added_deposit <= total_deposit);\n\n        // This should never fail at this point. Added check for security, because we directly set\n        // the participant_state.deposit = total_deposit, while we transfer `added_deposit` tokens.\n        assert(participant_state.deposit + added_deposit == total_deposit);\n\n        // Red Eyes release token network limit\n        require(token.balanceOf(address(this)) + added_deposit <= token_network_deposit_limit);\n\n        // Update the participant's channel deposit\n        participant_state.deposit = total_deposit;\n\n        // Calculate the entire channel deposit, to avoid overflow\n        channel_deposit = participant_state.deposit + partner_state.deposit;\n        // Overflow check\n        require(channel_deposit >= participant_state.deposit);\n\n        emit ChannelNewDeposit(\n            channel_identifier,\n            participant,\n            participant_state.deposit\n        );\n\n        // Do the transfer\n        require(token.transferFrom(msg.sender, address(this), added_deposit));\n    }\n\n    /* /// @notice Allows `participant` to withdraw tokens from the channel that he\n    /// has with `partner`, without closing it. Can be called by anyone. Can\n    /// only be called once per each signed withdraw message.\n    /// @param channel_identifier Identifier for the channel on which this\n    /// operation takes place.\n    /// @param participant Channel participant, who will receive the withdrawn\n    /// amount.\n    /// @param total_withdraw Total amount of tokens that are marked as\n    /// withdrawn from the channel during the channel lifecycle.\n    /// @param participant_signature Participant's signature on the withdraw\n    /// data.\n    /// @param partner_signature Partner's signature on the withdraw data.\n    function setTotalWithdraw(\n        uint256 channel_identifier,\n        address participant,\n        uint256 total_withdraw,\n        bytes participant_signature,\n        bytes partner_signature\n    )\n        isOpen(channel_identifier)\n        external\n    {\n        uint256 total_deposit;\n        uint256 current_withdraw;\n        address partner;\n\n        require(total_withdraw > 0);\n\n        // Authenticate both channel partners via there signatures:\n        require(participant == recoverAddressFromWithdrawMessage(\n            channel_identifier,\n            participant,\n            total_withdraw,\n            participant_signature\n        ));\n        partner = recoverAddressFromWithdrawMessage(\n            channel_identifier,\n            participant,\n            total_withdraw,\n            partner_signature\n        );\n\n        // Validate that authenticated partners and the channel identifier match\n        require(channel_identifier == getChannelIdentifier(participant, partner));\n\n        // Read channel state after validating the function input\n        Channel storage channel = channels[channel_identifier];\n        Participant storage participant_state = channel.participants[participant];\n        Participant storage partner_state = channel.participants[partner];\n\n        total_deposit = participant_state.deposit + partner_state.deposit;\n\n        // Entire withdrawn amount must not be bigger than the current channel deposit\n        require((total_withdraw + partner_state.withdrawn_amount) <= total_deposit);\n        require(total_withdraw <= (total_withdraw + partner_state.withdrawn_amount));\n\n        // Using the total_withdraw (monotonically increasing) in the signed\n        // message ensures that we do not allow replay attack to happen, by\n        // using the same withdraw proof twice.\n        // Next two lines enforce the monotonicity of total_withdraw and check for an underflow:\n        // (we use <= because current_withdraw == total_withdraw for the first withdraw)\n        current_withdraw = total_withdraw - participant_state.withdrawn_amount;\n        require(current_withdraw <= total_withdraw);\n\n        // The actual amount of tokens that will be transferred must be > 0 to disable the reuse of\n        // withdraw messages completely.\n        require(current_withdraw > 0);\n\n        // This should never fail at this point. Added check for security, because we directly set\n        // the participant_state.withdrawn_amount = total_withdraw,\n        // while we transfer `current_withdraw` tokens.\n        assert(participant_state.withdrawn_amount + current_withdraw == total_withdraw);\n\n        emit ChannelWithdraw(\n            channel_identifier,\n            participant,\n            total_withdraw\n        );\n\n        // Do the state change and tokens transfer\n        participant_state.withdrawn_amount = total_withdraw;\n        require(token.transfer(participant, current_withdraw));\n\n        // This should never happen, as we have an overflow check in setTotalDeposit\n        assert(total_deposit >= participant_state.deposit);\n        assert(total_deposit >= partner_state.deposit);\n\n        // A withdraw should never happen if a participant already has a\n        // balance proof in storage. This should never fail as we use isOpen.\n        assert(participant_state.nonce == 0);\n        assert(partner_state.nonce == 0);\n\n    } */\n\n    /// @notice Close the channel defined by the two participant addresses. Only\n    /// a participant may close the channel, providing a balance proof signed by\n    /// its partner. Callable only once.\n    /// @param channel_identifier Identifier for the channel on which this\n    /// operation takes place.\n    /// @param partner Channel partner of the `msg.sender`, who provided the\n    /// signature.\n    /// @param balance_hash Hash of (transferred_amount, locked_amount,\n    /// locksroot).\n    /// @param additional_hash Computed from the message. Used for message\n    /// authentication.\n    /// @param nonce Strictly monotonic value used to order transfers.\n    /// @param signature Partner's signature of the balance proof data.\n    function closeChannel(\n        uint256 channel_identifier,\n        address partner,\n        bytes32 balance_hash,\n        uint256 nonce,\n        bytes32 additional_hash,\n        bytes signature\n    )\n        isOpen(channel_identifier)\n        public\n    {\n        require(channel_identifier == getChannelIdentifier(msg.sender, partner));\n\n        address recovered_partner_address;\n\n        Channel storage channel = channels[channel_identifier];\n\n        channel.state = ChannelState.Closed;\n        channel.participants[msg.sender].is_the_closer = true;\n\n        // This is the block number at which the channel can be settled.\n        channel.settle_block_number += uint256(block.number);\n\n        // Nonce 0 means that the closer never received a transfer, therefore\n        // never received a balance proof, or he is intentionally not providing\n        // the latest transfer, in which case the closing party is going to\n        // lose the tokens that were transferred to him.\n        if (nonce > 0) {\n            recovered_partner_address = recoverAddressFromBalanceProof(\n                channel_identifier,\n                balance_hash,\n                nonce,\n                additional_hash,\n                signature\n            );\n            // Signature must be from the channel partner\n            require(partner == recovered_partner_address);\n\n            updateBalanceProofData(\n                channel,\n                recovered_partner_address,\n                nonce,\n                balance_hash\n            );\n        }\n\n        emit ChannelClosed(channel_identifier, msg.sender, nonce);\n    }\n\n    /// @notice Called on a closed channel, the function allows the non-closing\n    /// participant to provide the last balance proof, which modifies the\n    /// closing participant's state. Can be called multiple times by anyone.\n    /// @param channel_identifier Identifier for the channel on which this\n    /// operation takes place.\n    /// @param closing_participant Channel participant who closed the channel.\n    /// @param non_closing_participant Channel participant who needs to update\n    /// the balance proof.\n    /// @param balance_hash Hash of (transferred_amount, locked_amount,\n    /// locksroot).\n    /// @param additional_hash Computed from the message. Used for message\n    /// authentication.\n    /// @param nonce Strictly monotonic value used to order transfers.\n    /// @param closing_signature Closing participant's signature of the balance\n    /// proof data.\n    /// @param non_closing_signature Non-closing participant signature of the\n    /// balance proof data.\n    function updateNonClosingBalanceProof(\n        uint256 channel_identifier,\n        address closing_participant,\n        address non_closing_participant,\n        bytes32 balance_hash,\n        uint256 nonce,\n        bytes32 additional_hash,\n        bytes closing_signature,\n        bytes non_closing_signature\n    )\n        external\n    {\n        require(channel_identifier == getChannelIdentifier(\n            closing_participant,\n            non_closing_participant\n        ));\n        require(balance_hash != bytes32(0x0));\n        require(nonce > 0);\n\n        address recovered_non_closing_participant;\n        address recovered_closing_participant;\n\n        Channel storage channel = channels[channel_identifier];\n\n        require(channel.state == ChannelState.Closed);\n        // Channel must be in the settlement window\n        require(channel.settle_block_number >= block.number);\n\n        // We need the signature from the non-closing participant to allow\n        // anyone to make this transaction. E.g. a monitoring service.\n        recovered_non_closing_participant = recoverAddressFromBalanceProofUpdateMessage(\n            channel_identifier,\n            balance_hash,\n            nonce,\n            additional_hash,\n            closing_signature,\n            non_closing_signature\n        );\n        require(non_closing_participant == recovered_non_closing_participant);\n\n        recovered_closing_participant = recoverAddressFromBalanceProof(\n            channel_identifier,\n            balance_hash,\n            nonce,\n            additional_hash,\n            closing_signature\n        );\n        require(closing_participant == recovered_closing_participant);\n\n        Participant storage closing_participant_state = channel.participants[closing_participant];\n        // Make sure the first signature is from the closing participant\n        require(closing_participant_state.is_the_closer);\n\n        // Update the balance proof data for the closing_participant\n        updateBalanceProofData(channel, closing_participant, nonce, balance_hash);\n\n        emit NonClosingBalanceProofUpdated(\n            channel_identifier,\n            closing_participant,\n            nonce\n        );\n    }\n\n    /// @notice Settles the balance between the two parties. Note that arguments\n    /// order counts: `participant1_transferred_amount +\n    /// participant1_locked_amount` <= `participant2_transferred_amount +\n    /// participant2_locked_amount`\n    /// @param channel_identifier Identifier for the channel on which this\n    /// operation takes place.\n    /// @param participant1 Channel participant.\n    /// @param participant1_transferred_amount The latest known amount of tokens\n    /// transferred from `participant1` to `participant2`.\n    /// @param participant1_locked_amount Amount of tokens owed by\n    /// `participant1` to `participant2`, contained in locked transfers that\n    /// will be retrieved by calling `unlock` after the channel is settled.\n    /// @param participant1_locksroot The latest known merkle root of the\n    /// pending hash-time locks of `participant1`, used to validate the unlocked\n    /// proofs.\n    /// @param participant2 Other channel participant.\n    /// @param participant2_transferred_amount The latest known amount of tokens\n    /// transferred from `participant2` to `participant1`.\n    /// @param participant2_locked_amount Amount of tokens owed by\n    /// `participant2` to `participant1`, contained in locked transfers that\n    /// will be retrieved by calling `unlock` after the channel is settled.\n    /// @param participant2_locksroot The latest known merkle root of the\n    /// pending hash-time locks of `participant2`, used to validate the unlocked\n    /// proofs.\n    function settleChannel(\n        uint256 channel_identifier,\n        address participant1,\n        uint256 participant1_transferred_amount,\n        uint256 participant1_locked_amount,\n        bytes32 participant1_locksroot,\n        address participant2,\n        uint256 participant2_transferred_amount,\n        uint256 participant2_locked_amount,\n        bytes32 participant2_locksroot\n    )\n        public\n    {\n        // There are several requirements that this function MUST enforce:\n        // - it MUST never fail; therefore, any overflows or underflows must be\n        // handled gracefully\n        // - it MUST ensure that if participants use the latest valid balance proofs,\n        // provided by the official Raiden client, the participants will be able\n        // to receive correct final balances at the end of the channel lifecycle\n        // - it MUST ensure that the participants cannot cheat by providing an\n        // old, valid balance proof of their partner; meaning that their partner MUST\n        // receive at least the amount of tokens that he would have received if\n        // the latest valid balance proofs are used.\n        // - the contract cannot determine if a balance proof is invalid (values\n        // are not within the constraints enforced by the official Raiden client),\n        // therefore it cannot ensure correctness. Users MUST use the official\n        // Raiden clients for signing balance proofs.\n\n        require(channel_identifier == getChannelIdentifier(participant1, participant2));\n\n        bytes32 pair_hash;\n\n        pair_hash = getParticipantsHash(participant1, participant2);\n        Channel storage channel = channels[channel_identifier];\n\n        require(channel.state == ChannelState.Closed);\n\n        // Settlement window must be over\n        require(channel.settle_block_number < block.number);\n\n        Participant storage participant1_state = channel.participants[participant1];\n        Participant storage participant2_state = channel.participants[participant2];\n\n        require(verifyBalanceHashData(\n            participant1_state,\n            participant1_transferred_amount,\n            participant1_locked_amount,\n            participant1_locksroot\n        ));\n\n        require(verifyBalanceHashData(\n            participant2_state,\n            participant2_transferred_amount,\n            participant2_locked_amount,\n            participant2_locksroot\n        ));\n\n        // We are calculating the final token amounts that need to be\n        // transferred to the participants now and the amount of tokens that\n        // need to remain locked in the contract. These tokens can be unlocked\n        // by calling `unlock`.\n        // participant1_transferred_amount = the amount of tokens that\n        //   participant1 will receive in this transaction.\n        // participant2_transferred_amount = the amount of tokens that\n        //   participant2 will receive in this transaction.\n        // participant1_locked_amount = the amount of tokens remaining in the\n        //   contract, representing pending transfers from participant1 to participant2.\n        // participant2_locked_amount = the amount of tokens remaining in the\n        //   contract, representing pending transfers from participant2 to participant1.\n        // We are reusing variables due to the local variables number limit.\n        // For better readability this can be refactored further.\n        (\n            participant1_transferred_amount,\n            participant2_transferred_amount,\n            participant1_locked_amount,\n            participant2_locked_amount\n        ) = getSettleTransferAmounts(\n            participant1_state,\n            participant1_transferred_amount,\n            participant1_locked_amount,\n            participant2_state,\n            participant2_transferred_amount,\n            participant2_locked_amount\n        );\n\n        // Remove the channel data from storage\n        delete channel.participants[participant1];\n        delete channel.participants[participant2];\n        delete channels[channel_identifier];\n\n        // Remove the pair's channel counter\n        delete participants_hash_to_channel_identifier[pair_hash];\n\n        // Store balance data needed for `unlock`, including the calculated\n        // locked amounts remaining in the contract.\n        storeUnlockData(\n            channel_identifier,\n            participant1,\n            participant2,\n            participant1_locked_amount,\n            participant1_locksroot\n        );\n        storeUnlockData(\n            channel_identifier,\n            participant2,\n            participant1,\n            participant2_locked_amount,\n            participant2_locksroot\n        );\n\n        emit ChannelSettled(\n            channel_identifier,\n            participant1_transferred_amount,\n            participant2_transferred_amount\n        );\n\n        // Do the actual token transfers\n        if (participant1_transferred_amount > 0) {\n            require(token.transfer(participant1, participant1_transferred_amount));\n        }\n\n        if (participant2_transferred_amount > 0) {\n            require(token.transfer(participant2, participant2_transferred_amount));\n        }\n    }\n\n    /// @notice Unlocks all pending off-chain transfers from `partner` to\n    /// `participant` and sends the locked tokens corresponding to locks with\n    /// secrets registered on-chain to the `participant`. Locked tokens\n    /// corresponding to locks where the secret was not revelead on-chain will\n    /// return to the `partner`. Anyone can call unlock.\n    /// @param channel_identifier Identifier for the channel on which this\n    /// operation takes place.\n    /// @param participant Address who will receive the claimable unlocked\n    /// tokens.\n    /// @param partner Address who sent the pending transfers and will receive\n    /// the unclaimable unlocked tokens.\n    /// @param merkle_tree_leaves The entire merkle tree of pending transfers\n    /// that `partner` sent to `participant`.\n    function unlock(\n        uint256 channel_identifier,\n        address participant,\n        address partner,\n        bytes merkle_tree_leaves\n    )\n        public\n    {\n        // Channel represented by channel_identifier must be settled and\n        // channel data deleted\n        require(channel_identifier != getChannelIdentifier(participant, partner));\n\n        // After the channel is settled the storage is cleared, therefore the\n        // value will be NonExistent and not Settled. The value Settled is used\n        // for the external APIs\n        require(channels[channel_identifier].state == ChannelState.NonExistent);\n\n        require(merkle_tree_leaves.length > 0);\n\n        bytes32 unlock_key;\n        bytes32 computed_locksroot;\n        uint256 unlocked_amount;\n        uint256 locked_amount;\n        uint256 returned_tokens;\n\n        // Calculate the locksroot for the pending transfers and the amount of\n        // tokens corresponding to the locked transfers with secrets revealed\n        // on chain.\n        (computed_locksroot, unlocked_amount) = getMerkleRootAndUnlockedAmount(\n            merkle_tree_leaves\n        );\n\n        // The partner must have a non-empty locksroot on-chain that must be\n        // the same as the computed locksroot.\n        // Get the amount of tokens that have been left in the contract, to\n        // account for the pending transfers `partner` -> `participant`.\n        unlock_key = getUnlockIdentifier(channel_identifier, partner, participant);\n        UnlockData storage unlock_data = unlock_identifier_to_unlock_data[unlock_key];\n        locked_amount = unlock_data.locked_amount;\n\n        // Locksroot must be the same as the computed locksroot\n        require(unlock_data.locksroot == computed_locksroot);\n\n        // There are no pending transfers if the locked_amount is 0.\n        // Transaction must fail\n        require(locked_amount > 0);\n\n        // Make sure we don't transfer more tokens than previously reserved in\n        // the smart contract.\n        unlocked_amount = min(unlocked_amount, locked_amount);\n\n        // Transfer the rest of the tokens back to the partner\n        returned_tokens = locked_amount - unlocked_amount;\n\n        // Remove partner's unlock data\n        delete unlock_identifier_to_unlock_data[unlock_key];\n\n        emit ChannelUnlocked(\n            channel_identifier,\n            participant,\n            partner,\n            computed_locksroot,\n            unlocked_amount,\n            returned_tokens\n        );\n\n        // Transfer the unlocked tokens to the participant. unlocked_amount can\n        // be 0\n        if (unlocked_amount > 0) {\n            require(token.transfer(participant, unlocked_amount));\n        }\n\n        // Transfer the rest of the tokens back to the partner\n        if (returned_tokens > 0) {\n            require(token.transfer(partner, returned_tokens));\n        }\n\n        // At this point, this should always be true\n        assert(locked_amount >= returned_tokens);\n        assert(locked_amount >= unlocked_amount);\n    }\n\n    /* /// @notice Cooperatively settles the balances between the two channel\n    /// participants and transfers the agreed upon token amounts to the\n    /// participants. After this the channel lifecycle has ended and no more\n    /// operations can be done on it.\n    /// @param channel_identifier Identifier for the channel on which this\n    /// operation takes place.\n    /// @param participant1_address Address of channel participant.\n    /// @param participant1_balance Amount of tokens that `participant1_address`\n    /// must receive when the channel is settled and removed.\n    /// @param participant2_address Address of the other channel participant.\n    /// @param participant2_balance Amount of tokens that `participant2_address`\n    /// must receive when the channel is settled and removed.\n    /// @param participant1_signature Signature of `participant1_address` on the\n    /// cooperative settle message.\n    /// @param participant2_signature Signature of `participant2_address` on the\n    /// cooperative settle message.\n    function cooperativeSettle(\n        uint256 channel_identifier,\n        address participant1_address,\n        uint256 participant1_balance,\n        address participant2_address,\n        uint256 participant2_balance,\n        bytes participant1_signature,\n        bytes participant2_signature\n    )\n        public\n    {\n        require(channel_identifier == getChannelIdentifier(\n            participant1_address,\n            participant2_address\n        ));\n        bytes32 pair_hash;\n        address participant1;\n        address participant2;\n        uint256 total_available_deposit;\n\n        pair_hash = getParticipantsHash(participant1_address, participant2_address);\n        Channel storage channel = channels[channel_identifier];\n\n        require(channel.state == ChannelState.Opened);\n\n        participant1 = recoverAddressFromCooperativeSettleSignature(\n            channel_identifier,\n            participant1_address,\n            participant1_balance,\n            participant2_address,\n            participant2_balance,\n            participant1_signature\n        );\n        // The provided address must be the same as the recovered one\n        require(participant1 == participant1_address);\n\n        participant2 = recoverAddressFromCooperativeSettleSignature(\n            channel_identifier,\n            participant1_address,\n            participant1_balance,\n            participant2_address,\n            participant2_balance,\n            participant2_signature\n        );\n        // The provided address must be the same as the recovered one\n        require(participant2 == participant2_address);\n\n        Participant storage participant1_state = channel.participants[participant1];\n        Participant storage participant2_state = channel.participants[participant2];\n\n        total_available_deposit = getChannelAvailableDeposit(\n            participant1_state,\n            participant2_state\n        );\n        // The sum of the provided balances must be equal to the total\n        // available deposit\n        require(total_available_deposit == (participant1_balance + participant2_balance));\n        // Overflow check for the balances addition from the above check.\n        // This overflow should never happen if the token.transfer function is implemented\n        // correctly. We do not control the token implementation, therefore we add this\n        // check for safety.\n        require(participant1_balance <= participant1_balance + participant2_balance);\n\n        // Remove channel data from storage before doing the token transfers\n        delete channel.participants[participant1];\n        delete channel.participants[participant2];\n        delete channels[channel_identifier];\n\n        // Remove the pair's channel counter\n        delete participants_hash_to_channel_identifier[pair_hash];\n\n        emit ChannelSettled(channel_identifier, participant1_balance, participant2_balance);\n\n        // Do the token transfers\n        if (participant1_balance > 0) {\n            require(token.transfer(participant1, participant1_balance));\n        }\n\n        if (participant2_balance > 0) {\n            require(token.transfer(participant2, participant2_balance));\n        }\n    } */\n\n    /// @notice Returns the unique identifier for the channel given by the\n    /// contract.\n    /// @param participant Address of a channel participant.\n    /// @param partner Address of the other channel participant.\n    /// @return Unique identifier for the channel. It can be 0 if channel does\n    /// not exist.\n    function getChannelIdentifier(address participant, address partner)\n        view\n        public\n        returns (uint256)\n    {\n        require(participant != address(0x0));\n        require(partner != address(0x0));\n        require(participant != partner);\n\n        bytes32 pair_hash = getParticipantsHash(participant, partner);\n        return participants_hash_to_channel_identifier[pair_hash];\n    }\n\n    /// @dev Returns the channel specific data.\n    /// @param channel_identifier Identifier for the channel on which this\n    /// operation takes place.\n    /// @param participant1 Address of a channel participant.\n    /// @param participant2 Address of the other channel participant.\n    /// @return Channel settle_block_number and state.\n    function getChannelInfo(\n        uint256 channel_identifier,\n        address participant1,\n        address participant2\n    )\n        view\n        external\n        returns (uint256, ChannelState)\n    {\n        bytes32 unlock_key1;\n        bytes32 unlock_key2;\n\n        Channel storage channel = channels[channel_identifier];\n        ChannelState state = channel.state;  // This must **not** update the storage\n\n        if (state == ChannelState.NonExistent &&\n            channel_identifier > 0 &&\n            channel_identifier <= channel_counter\n        ) {\n            // The channel has been settled, channel data is removed Therefore,\n            // the channel state in storage is actually `0`, or `NonExistent`\n            // However, for this view function, we return `Settled`, in order\n            // to provide a consistent external API\n            state = ChannelState.Settled;\n\n            // We might still have data stored for future unlock operations\n            // Only if we do not, we can consider the channel as `Removed`\n            unlock_key1 = getUnlockIdentifier(channel_identifier, participant1, participant2);\n            UnlockData storage unlock_data1 = unlock_identifier_to_unlock_data[unlock_key1];\n\n            unlock_key2 = getUnlockIdentifier(channel_identifier, participant2, participant1);\n            UnlockData storage unlock_data2 = unlock_identifier_to_unlock_data[unlock_key2];\n\n            if (unlock_data1.locked_amount == 0 && unlock_data2.locked_amount == 0) {\n                state = ChannelState.Removed;\n            }\n        }\n\n        return (\n            channel.settle_block_number,\n            state\n        );\n    }\n\n    /// @dev Returns the channel specific data.\n    /// @param channel_identifier Identifier for the channel on which this\n    /// operation takes place.\n    /// @param participant Address of the channel participant whose data will be\n    /// returned.\n    /// @param partner Address of the channel partner.\n    /// @return Participant's deposit, withdrawn_amount, whether the participant\n    /// has called `closeChannel` or not, balance_hash, nonce, locksroot,\n    /// locked_amount.\n    function getChannelParticipantInfo(\n            uint256 channel_identifier,\n            address participant,\n            address partner\n    )\n        view\n        external\n        returns (uint256, uint256, bool, bytes32, uint256, bytes32, uint256)\n    {\n        bytes32 unlock_key;\n\n        Participant storage participant_state = channels[channel_identifier].participants[\n            participant\n        ];\n        unlock_key = getUnlockIdentifier(channel_identifier, participant, partner);\n        UnlockData storage unlock_data = unlock_identifier_to_unlock_data[unlock_key];\n\n        return (\n            participant_state.deposit,\n            participant_state.withdrawn_amount,\n            participant_state.is_the_closer,\n            participant_state.balance_hash,\n            participant_state.nonce,\n            unlock_data.locksroot,\n            unlock_data.locked_amount\n        );\n    }\n\n    /// @dev Get the hash of the participant addresses, ordered\n    /// lexicographically.\n    /// @param participant Address of a channel participant.\n    /// @param partner Address of the other channel participant.\n    function getParticipantsHash(address participant, address partner)\n        pure\n        public\n        returns (bytes32)\n    {\n        require(participant != address(0x0));\n        require(partner != address(0x0));\n        require(participant != partner);\n\n        if (participant < partner) {\n            return keccak256(abi.encodePacked(participant, partner));\n        } else {\n            return keccak256(abi.encodePacked(partner, participant));\n        }\n    }\n\n    function getUnlockIdentifier(\n        uint256 channel_identifier,\n        address participant,\n        address partner\n    )\n        pure\n        public\n        returns (bytes32)\n    {\n        require(participant != partner);\n        return keccak256(abi.encodePacked(channel_identifier, participant, partner));\n    }\n\n    function updateBalanceProofData(\n        Channel storage channel,\n        address participant,\n        uint256 nonce,\n        bytes32 balance_hash\n    )\n        internal\n    {\n        Participant storage participant_state = channel.participants[participant];\n\n        // Multiple calls to updateNonClosingBalanceProof can be made and we\n        // need to store the last known balance proof data\n        require(nonce > participant_state.nonce);\n\n        participant_state.nonce = nonce;\n        participant_state.balance_hash = balance_hash;\n    }\n\n    function storeUnlockData(\n        uint256 channel_identifier,\n        address participant,\n        address partner,\n        uint256 locked_amount,\n        bytes32 locksroot\n    )\n        internal\n    {\n        // If there are transfers to unlock, store the locksroot and total\n        // amount of tokens\n        if (locked_amount == 0 || locksroot == 0) {\n            return;\n        }\n\n        bytes32 key = getUnlockIdentifier(channel_identifier, participant, partner);\n        UnlockData storage unlock_data = unlock_identifier_to_unlock_data[key];\n        unlock_data.locksroot = locksroot;\n        unlock_data.locked_amount = locked_amount;\n    }\n\n    function getChannelAvailableDeposit(\n        Participant storage participant1_state,\n        Participant storage participant2_state\n    )\n        view\n        internal\n        returns (uint256 total_available_deposit)\n    {\n        total_available_deposit = (\n            participant1_state.deposit +\n            participant2_state.deposit -\n            participant1_state.withdrawn_amount -\n            participant2_state.withdrawn_amount\n        );\n    }\n\n    /// @dev Function that calculates the amount of tokens that the participants\n    /// will receive when calling settleChannel.\n    /// Check https://github.com/raiden-network/raiden-contracts/issues/188 for the settlement\n    /// algorithm analysis and explanations.\n    function getSettleTransferAmounts(\n        Participant storage participant1_state,\n        uint256 participant1_transferred_amount,\n        uint256 participant1_locked_amount,\n        Participant storage participant2_state,\n        uint256 participant2_transferred_amount,\n        uint256 participant2_locked_amount\n    )\n        view\n        private\n        returns (uint256, uint256, uint256, uint256)\n    {\n        // The scope of this function is to compute the settlement amounts that\n        // the two channel participants will receive when calling settleChannel\n        // and the locked amounts that remain in the contract, to account for\n        // the pending, not finalized transfers, that will be received by the\n        // participants when calling `unlock`.\n\n        // The amount of tokens that participant1 MUST receive at the end of\n        // the channel lifecycle (after settleChannel and unlock) is:\n        // B1 = D1 - W1 + T2 - T1 + Lc2 - Lc1\n\n        // The amount of tokens that participant2 MUST receive at the end of\n        // the channel lifecycle (after settleChannel and unlock) is:\n        // B2 = D2 - W2 + T1 - T2 + Lc1 - Lc2\n\n        // B1 + B2 = TAD = D1 + D2 - W1 - W2\n        // TAD = total available deposit at settlement time\n\n        // L1 = Lc1 + Lu1\n        // L2 = Lc2 + Lu2\n\n        // where:\n        // B1 = final balance of participant1 after the channel is removed\n        // D1 = total amount deposited by participant1 into the channel\n        // W1 = total amount withdrawn by participant1 from the channel\n        // T2 = total amount transferred by participant2 to participant1 (finalized transfers)\n        // T1 = total amount transferred by participant1 to participant2 (finalized transfers)\n        // L1 = total amount of tokens locked in pending transfers, sent by\n        //   participant1 to participant2\n        // L2 = total amount of tokens locked in pending transfers, sent by\n        //   participant2 to participant1\n        // Lc2 = the amount that can be claimed by participant1 from the pending\n        //   transfers (that have not been finalized off-chain), sent by\n        //   participant2 to participant1. These are part of the locked amount\n        //   value from participant2's balance proof. They are considered claimed\n        //   if the secret corresponding to these locked transfers was registered\n        //   on-chain, in the SecretRegistry contract, before the lock's expiration.\n        // Lu1 = unclaimable locked amount from L1\n        // Lc1 = the amount that can be claimed by participant2 from the pending\n        //   transfers (that have not been finalized off-chain),\n        //   sent by participant1 to participant2\n        // Lu2 = unclaimable locked amount from L2\n\n        // Notes:\n        // 1) The unclaimble tokens from a locked amount will return to the sender.\n        // At the time of calling settleChannel, the TokenNetwork contract does\n        // not know what locked amounts are claimable or unclaimable.\n        // 2) There are some Solidity constraints that make the calculations\n        // more difficult: attention to overflows and underflows, that MUST be\n        // handled without throwing.\n\n        // Cases that require attention:\n        // case1. If participant1 does NOT provide a balance proof or provides\n        // an old balance proof.  participant2_transferred_amount can be [0,\n        // real_participant2_transferred_amount) We MUST NOT punish\n        // participant2.\n        // case2. If participant2 does NOT provide a balance proof or provides\n        // an old balance proof.  participant1_transferred_amount can be [0,\n        // real_participant1_transferred_amount) We MUST NOT punish\n        // participant1.\n        // case3. If neither participants provide a balance proof, we just\n        // subtract their withdrawn amounts from their deposits.\n\n        // This is why, the algorithm implemented in Solidity is:\n        // (explained at each step, below)\n        // RmaxP1 = (T2 + L2) - (T1 + L1) + D1 - W1\n        // RmaxP1 = min(TAD, RmaxP1)\n        // RmaxP2 = TAD - RmaxP1\n        // SL2 = min(RmaxP1, L2)\n        // S1 = RmaxP1 - SL2\n        // SL1 = min(RmaxP2, L1)\n        // S2 = RmaxP2 - SL1\n\n        // where:\n        // RmaxP1 = due to possible over/underflows that only appear when using\n        //    old balance proofs & the fact that settlement balance calculation\n        //    is symmetric (we can calculate either RmaxP1 and RmaxP2 first,\n        //    order does not affect result), this is a convention used to determine\n        //    the maximum receivable amount of participant1 at settlement time\n        // S1 = amount received by participant1 when calling settleChannel\n        // SL1 = the maximum amount from L1 that can be locked in the\n        //   TokenNetwork contract when calling settleChannel (due to overflows\n        //   that only happen when using old balance proofs)\n        // S2 = amount received by participant2 when calling settleChannel\n        // SL2 = the maximum amount from L2 that can be locked in the\n        //   TokenNetwork contract when calling settleChannel (due to overflows\n        //   that only happen when using old balance proofs)\n\n        uint256 participant1_amount;\n        uint256 participant2_amount;\n        uint256 total_available_deposit;\n\n        SettlementData memory participant1_settlement;\n        SettlementData memory participant2_settlement;\n\n        participant1_settlement.deposit = participant1_state.deposit;\n        participant1_settlement.withdrawn = participant1_state.withdrawn_amount;\n        participant1_settlement.transferred = participant1_transferred_amount;\n        participant1_settlement.locked = participant1_locked_amount;\n\n        participant2_settlement.deposit = participant2_state.deposit;\n        participant2_settlement.withdrawn = participant2_state.withdrawn_amount;\n        participant2_settlement.transferred = participant2_transferred_amount;\n        participant2_settlement.locked = participant2_locked_amount;\n\n        // TAD = D1 + D2 - W1 - W2 = total available deposit at settlement time\n        total_available_deposit = getChannelAvailableDeposit(\n            participant1_state,\n            participant2_state\n        );\n\n        // RmaxP1 = (T2 + L2) - (T1 + L1) + D1 - W1\n        // This amount is the maximum possible amount that participant1 can\n        // receive at settlement time and also contains the entire locked amount\n        //  of the pending transfers from participant2 to participant1.\n        participant1_amount = getMaxPossibleReceivableAmount(\n            participant1_settlement,\n            participant2_settlement\n        );\n\n        // RmaxP1 = min(TAD, RmaxP1)\n        // We need to bound this to the available channel deposit in order to\n        // not send tokens from other channels. The only case where TAD is\n        // smaller than RmaxP1 is when at least one balance proof is old.\n        participant1_amount = min(participant1_amount, total_available_deposit);\n\n        // RmaxP2 = TAD - RmaxP1\n        // Now it is safe to subtract without underflow\n        participant2_amount = total_available_deposit - participant1_amount;\n\n        // SL2 = min(RmaxP1, L2)\n        // S1 = RmaxP1 - SL2\n        // Both operations are done by failsafe_subtract\n        // We take out participant2's pending transfers locked amount, bounding\n        // it by the maximum receivable amount of participant1\n        (participant1_amount, participant2_locked_amount) = failsafe_subtract(\n            participant1_amount,\n            participant2_locked_amount\n        );\n\n        // SL1 = min(RmaxP2, L1)\n        // S2 = RmaxP2 - SL1\n        // Both operations are done by failsafe_subtract\n        // We take out participant1's pending transfers locked amount, bounding\n        // it by the maximum receivable amount of participant2\n        (participant2_amount, participant1_locked_amount) = failsafe_subtract(\n            participant2_amount,\n            participant1_locked_amount\n        );\n\n        // This should never throw:\n        // S1 and S2 MUST be smaller than TAD\n        assert(participant1_amount <= total_available_deposit);\n        assert(participant2_amount <= total_available_deposit);\n        // S1 + S2 + SL1 + SL2 == TAD\n        assert(total_available_deposit == (\n            participant1_amount +\n            participant2_amount +\n            participant1_locked_amount +\n            participant2_locked_amount\n        ));\n\n        return (\n            participant1_amount,\n            participant2_amount,\n            participant1_locked_amount,\n            participant2_locked_amount\n        );\n    }\n\n    function getMaxPossibleReceivableAmount(\n        SettlementData participant1_settlement,\n        SettlementData participant2_settlement\n    )\n        pure\n        internal\n        returns (uint256)\n    {\n        uint256 participant1_max_transferred;\n        uint256 participant2_max_transferred;\n        uint256 participant1_net_max_received;\n        uint256 participant1_max_amount;\n\n        // This is the maximum possible amount that participant1 could transfer\n        // to participant2, if all the pending lock secrets have been\n        // registered\n        participant1_max_transferred = failsafe_addition(\n            participant1_settlement.transferred,\n            participant1_settlement.locked\n        );\n\n        // This is the maximum possible amount that participant2 could transfer\n        // to participant1, if all the pending lock secrets have been\n        // registered\n        participant2_max_transferred = failsafe_addition(\n            participant2_settlement.transferred,\n            participant2_settlement.locked\n        );\n\n        // We enforce this check artificially, in order to get rid of hard\n        // to deal with over/underflows. Settlement balance calculation is\n        // symmetric (we can calculate either RmaxP1 and RmaxP2 first, order does\n        // not affect result). This means settleChannel must be called with\n        // ordered values.\n        require(participant2_max_transferred >= participant1_max_transferred);\n\n        assert(participant1_max_transferred >= participant1_settlement.transferred);\n        assert(participant2_max_transferred >= participant2_settlement.transferred);\n\n        // This is the maximum amount that participant1 can receive at settlement time\n        participant1_net_max_received = (\n            participant2_max_transferred -\n            participant1_max_transferred\n        );\n\n        // Next, we add the participant1's deposit and subtract the already\n        // withdrawn amount\n        participant1_max_amount = failsafe_addition(\n            participant1_net_max_received,\n            participant1_settlement.deposit\n        );\n\n        // Subtract already withdrawn amount\n        (participant1_max_amount, ) = failsafe_subtract(\n            participant1_max_amount,\n            participant1_settlement.withdrawn\n        );\n        return participant1_max_amount;\n    }\n\n    function verifyBalanceHashData(\n        Participant storage participant,\n        uint256 transferred_amount,\n        uint256 locked_amount,\n        bytes32 locksroot\n    )\n        view\n        internal\n        returns (bool)\n    {\n        // When no balance proof has been provided, we need to check this\n        // separately because hashing values of 0 outputs a value != 0\n        if (participant.balance_hash == 0 &&\n            transferred_amount == 0 &&\n            locked_amount == 0 &&\n            locksroot == 0\n        ) {\n            return true;\n        }\n\n        // Make sure the hash of the provided state is the same as the stored\n        // balance_hash\n        return participant.balance_hash == keccak256(abi.encodePacked(\n            transferred_amount,\n            locked_amount,\n            locksroot\n        ));\n    }\n\n    function recoverAddressFromBalanceProof(\n        uint256 channel_identifier,\n        bytes32 balance_hash,\n        uint256 nonce,\n        bytes32 additional_hash,\n        bytes signature\n    )\n        view\n        internal\n        returns (address signature_address)\n    {\n        // Length of the actual message: 20 + 32 + 32 + 32 + 32 + 32 + 32\n        string memory message_length = '212';\n\n        bytes32 message_hash = keccak256(abi.encodePacked(\n            signature_prefix,\n            message_length,\n            address(this),\n            chain_id,\n            uint256(MessageTypeId.BalanceProof),\n            channel_identifier,\n            balance_hash,\n            nonce,\n            additional_hash\n        ));\n\n        signature_address = ECVerify.ecverify(message_hash, signature);\n    }\n\n    function recoverAddressFromBalanceProofUpdateMessage(\n        uint256 channel_identifier,\n        bytes32 balance_hash,\n        uint256 nonce,\n        bytes32 additional_hash,\n        bytes closing_signature,\n        bytes non_closing_signature\n    )\n        view\n        internal\n        returns (address signature_address)\n    {\n        // Length of the actual message: 20 + 32 + 32 + 32 + 32 + 32 + 32 + 65\n        string memory message_length = '277';\n\n        bytes32 message_hash = keccak256(abi.encodePacked(\n            signature_prefix,\n            message_length,\n            address(this),\n            chain_id,\n            uint256(MessageTypeId.BalanceProofUpdate),\n            channel_identifier,\n            balance_hash,\n            nonce,\n            additional_hash,\n            closing_signature\n        ));\n\n        signature_address = ECVerify.ecverify(message_hash, non_closing_signature);\n    }\n\n    /* function recoverAddressFromCooperativeSettleSignature(\n        uint256 channel_identifier,\n        address participant1,\n        uint256 participant1_balance,\n        address participant2,\n        uint256 participant2_balance,\n        bytes signature\n    )\n        view\n        internal\n        returns (address signature_address)\n    {\n        // Length of the actual message: 20 + 32 + 32 + 32 + 20 + 32 + 20 + 32\n        string memory message_length = '220';\n\n        bytes32 message_hash = keccak256(abi.encodePacked(\n            signature_prefix,\n            message_length,\n            address(this),\n            chain_id,\n            uint256(MessageTypeId.CooperativeSettle),\n            channel_identifier,\n            participant1,\n            participant1_balance,\n            participant2,\n            participant2_balance\n        ));\n\n        signature_address = ECVerify.ecverify(message_hash, signature);\n    } */\n\n    /* function recoverAddressFromWithdrawMessage(\n        uint256 channel_identifier,\n        address participant,\n        uint256 total_withdraw,\n        bytes signature\n    )\n        view\n        internal\n        returns (address signature_address)\n    {\n        // Length of the actual message: 20 + 32 + 32 + 32 + 20 + 32\n        string memory message_length = '168';\n\n        bytes32 message_hash = keccak256(abi.encodePacked(\n            signature_prefix,\n            message_length,\n            address(this),\n            chain_id,\n            uint256(MessageTypeId.Withdraw),\n            channel_identifier,\n            participant,\n            total_withdraw\n        ));\n\n        signature_address = ECVerify.ecverify(message_hash, signature);\n    } */\n\n    /// @dev Calculates the merkle root for the pending transfers data and\n    //calculates the amount / of tokens that can be unlocked because the secret\n    //was registered on-chain.\n    function getMerkleRootAndUnlockedAmount(bytes merkle_tree_leaves)\n        view\n        internal\n        returns (bytes32, uint256)\n    {\n        uint256 length = merkle_tree_leaves.length;\n\n        // each merkle_tree lock component has this form:\n        // (locked_amount || expiration_block || secrethash) = 3 * 32 bytes\n        require(length % 96 == 0);\n\n        uint256 i;\n        uint256 total_unlocked_amount;\n        uint256 unlocked_amount;\n        bytes32 lockhash;\n        bytes32 merkle_root;\n\n        bytes32[] memory merkle_layer = new bytes32[](length / 96 + 1);\n\n        for (i = 32; i < length; i += 96) {\n            (lockhash, unlocked_amount) = getLockDataFromMerkleTree(merkle_tree_leaves, i);\n            total_unlocked_amount += unlocked_amount;\n            merkle_layer[i / 96] = lockhash;\n        }\n\n        length /= 96;\n\n        while (length > 1) {\n            if (length % 2 != 0) {\n                merkle_layer[length] = merkle_layer[length - 1];\n                length += 1;\n            }\n\n            for (i = 0; i < length - 1; i += 2) {\n                if (merkle_layer[i] == merkle_layer[i + 1]) {\n                    lockhash = merkle_layer[i];\n                } else if (merkle_layer[i] < merkle_layer[i + 1]) {\n                    lockhash = keccak256(abi.encodePacked(merkle_layer[i], merkle_layer[i + 1]));\n                } else {\n                    lockhash = keccak256(abi.encodePacked(merkle_layer[i + 1], merkle_layer[i]));\n                }\n                merkle_layer[i / 2] = lockhash;\n            }\n            length = i / 2;\n        }\n\n        merkle_root = merkle_layer[0];\n\n        return (merkle_root, total_unlocked_amount);\n    }\n\n    function getLockDataFromMerkleTree(bytes merkle_tree_leaves, uint256 offset)\n        view\n        internal\n        returns (bytes32, uint256)\n    {\n        uint256 expiration_block;\n        uint256 locked_amount;\n        uint256 reveal_block;\n        bytes32 secrethash;\n        bytes32 lockhash;\n\n        if (merkle_tree_leaves.length <= offset) {\n            return (lockhash, 0);\n        }\n\n        assembly {\n            expiration_block := mload(add(merkle_tree_leaves, offset))\n            locked_amount := mload(add(merkle_tree_leaves, add(offset, 32)))\n            secrethash := mload(add(merkle_tree_leaves, add(offset, 64)))\n        }\n\n        // Calculate the lockhash for computing the merkle root\n        lockhash = keccak256(abi.encodePacked(expiration_block, locked_amount, secrethash));\n\n        // Check if the lock's secret was revealed in the SecretRegistry The\n        // secret must have been revealed in the SecretRegistry contract before\n        // the lock's expiration_block in order for the hash time lock transfer\n        // to be successful.\n        reveal_block = secret_registry.getSecretRevealBlockHeight(secrethash);\n        if (reveal_block == 0 || expiration_block <= reveal_block) {\n            locked_amount = 0;\n        }\n\n        return (lockhash, locked_amount);\n    }\n\n    function min(uint256 a, uint256 b) pure internal returns (uint256)\n    {\n        return a > b ? b : a;\n    }\n\n    function max(uint256 a, uint256 b) pure internal returns (uint256)\n    {\n        return a > b ? a : b;\n    }\n\n    /// @dev Special subtraction function that does not fail when underflowing.\n    /// @param a Minuend\n    /// @param b Subtrahend\n    /// @return Minimum between the result of the subtraction and 0, the maximum\n    /// subtrahend for which no underflow occurs.\n    function failsafe_subtract(uint256 a, uint256 b)\n        pure\n        internal\n        returns (uint256, uint256)\n    {\n        return a > b ? (a - b, b) : (0, a);\n    }\n\n    /// @dev Special addition function that does not fail when overflowing.\n    /// @param a Addend\n    /// @param b Addend\n    /// @return Maximum between the result of the addition or the maximum\n    /// uint256 value.\n    function failsafe_addition(uint256 a, uint256 b)\n        pure\n        internal\n        returns (uint256)\n    {\n        uint256 sum = a + b;\n        return sum >= a ? sum : MAX_SAFE_UINT256;\n    }\n}",
  "abi": "[{\"constant\":false,\"inputs\":[{\"name\":\"channel_identifier\",\"type\":\"uint256\"},{\"name\":\"participant\",\"type\":\"address\"},{\"name\":\"partner\",\"type\":\"address\"},{\"name\":\"merkle_tree_leaves\",\"type\":\"bytes\"}],\"name\":\"unlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"participant1\",\"type\":\"address\"},{\"name\":\"participant2\",\"type\":\"address\"},{\"name\":\"settle_timeout\",\"type\":\"uint256\"}],\"name\":\"openChannel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deprecate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"settlement_timeout_max\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deprecation_executor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secret_registry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"chain_id\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token_network_deposit_limit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"participants_hash_to_channel_identifier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"channel_participant_deposit_limit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"channel_identifier\",\"type\":\"uint256\"},{\"name\":\"participant\",\"type\":\"address\"},{\"name\":\"total_deposit\",\"type\":\"uint256\"},{\"name\":\"partner\",\"type\":\"address\"}],\"name\":\"setTotalDeposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"channel_counter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_SAFE_UINT256\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"contract_address\",\"type\":\"address\"}],\"name\":\"contractExists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"participant\",\"type\":\"address\"},{\"name\":\"partner\",\"type\":\"address\"}],\"name\":\"getParticipantsHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"channel_identifier\",\"type\":\"uint256\"},{\"name\":\"participant1\",\"type\":\"address\"},{\"name\":\"participant2\",\"type\":\"address\"}],\"name\":\"getChannelInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"signature_prefix\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"participant\",\"type\":\"address\"},{\"name\":\"partner\",\"type\":\"address\"}],\"name\":\"getChannelIdentifier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"channel_identifier\",\"type\":\"uint256\"},{\"name\":\"participant1\",\"type\":\"address\"},{\"name\":\"participant1_transferred_amount\",\"type\":\"uint256\"},{\"name\":\"participant1_locked_amount\",\"type\":\"uint256\"},{\"name\":\"participant1_locksroot\",\"type\":\"bytes32\"},{\"name\":\"participant2\",\"type\":\"address\"},{\"name\":\"participant2_transferred_amount\",\"type\":\"uint256\"},{\"name\":\"participant2_locked_amount\",\"type\":\"uint256\"},{\"name\":\"participant2_locksroot\",\"type\":\"bytes32\"}],\"name\":\"settleChannel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contract_version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"safety_deprecation_switch\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"settlement_timeout_min\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"channel_identifier\",\"type\":\"uint256\"},{\"name\":\"partner\",\"type\":\"address\"},{\"name\":\"balance_hash\",\"type\":\"bytes32\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"additional_hash\",\"type\":\"bytes32\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"closeChannel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"channels\",\"outputs\":[{\"name\":\"settle_block_number\",\"type\":\"uint256\"},{\"name\":\"state\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"channel_identifier\",\"type\":\"uint256\"},{\"name\":\"participant\",\"type\":\"address\"},{\"name\":\"partner\",\"type\":\"address\"}],\"name\":\"getChannelParticipantInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"channel_identifier\",\"type\":\"uint256\"},{\"name\":\"closing_participant\",\"type\":\"address\"},{\"name\":\"non_closing_participant\",\"type\":\"address\"},{\"name\":\"balance_hash\",\"type\":\"bytes32\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"additional_hash\",\"type\":\"bytes32\"},{\"name\":\"closing_signature\",\"type\":\"bytes\"},{\"name\":\"non_closing_signature\",\"type\":\"bytes\"}],\"name\":\"updateNonClosingBalanceProof\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"channel_identifier\",\"type\":\"uint256\"},{\"name\":\"participant\",\"type\":\"address\"},{\"name\":\"partner\",\"type\":\"address\"}],\"name\":\"getUnlockIdentifier\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token_address\",\"type\":\"address\"},{\"name\":\"_secret_registry\",\"type\":\"address\"},{\"name\":\"_chain_id\",\"type\":\"uint256\"},{\"name\":\"_settlement_timeout_min\",\"type\":\"uint256\"},{\"name\":\"_settlement_timeout_max\",\"type\":\"uint256\"},{\"name\":\"_deprecation_executor\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"channel_identifier\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"participant1\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"participant2\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"settle_timeout\",\"type\":\"uint256\"}],\"name\":\"ChannelOpened\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"channel_identifier\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"participant\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"total_deposit\",\"type\":\"uint256\"}],\"name\":\"ChannelNewDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"channel_identifier\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"closing_participant\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"ChannelClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"channel_identifier\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"participant\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"partner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"locksroot\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"unlocked_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"returned_tokens\",\"type\":\"uint256\"}],\"name\":\"ChannelUnlocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"channel_identifier\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"closing_participant\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"NonClosingBalanceProofUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"channel_identifier\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"participant1_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"participant2_amount\",\"type\":\"uint256\"}],\"name\":\"ChannelSettled\",\"type\":\"event\"}]",
  "bytecode": "60806040526000600660146101000a81548160ff0219169083151502179055503480156200002c57600080fd5b5060405160c08062003e65833981018060405281019080805190602001909291908051906020019092919080519060200190929190805190602001909291908051906020019092919080519060200190929190505050600073ffffffffffffffffffffffffffffffffffffffff168673ffffffffffffffffffffffffffffffffffffffff1614151515620000bf57600080fd5b600073ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff1614151515620000fc57600080fd5b600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16141515156200013957600080fd5b6000841115156200014957600080fd5b6000831115156200015957600080fd5b82821115156200016857600080fd5b620001828662000369640100000000026401000000009004565b15156200018e57600080fd5b620001a88562000369640100000000026401000000009004565b1515620001b457600080fd5b856000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555084600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555083600281905550826003819055508160048190555060008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166318160ddd6040518163ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401602060405180830381600087803b158015620002d257600080fd5b505af1158015620002e7573d6000803e3d6000fd5b505050506040513d6020811015620002fe57600080fd5b81019080805190602001909291905050501115156200031c57600080fd5b80600660006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505050505050506200037c565b600080823b905060008111915050919050565b613ad9806200038c6000396000f30060806040526004361061016a576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806303d9d2531461016f5780630a798f24146102225780630fcc0c28146102a3578063224df42f146102ba57806323aa8174146102e557806324d73a931461033c5780633af973b1146103935780634845be76146103be578063524bef8a146103e95780635d6e441b1461042e57806363ea014314610459578063679b3763146104d057806371e75992146104fb5780637709bc78146105265780637c4734f414610581578063838d6e05146106005780638723423714610696578063938bcd67146107265780639cadb1591461079d578063b32c65c81461084e578063b7506d70146108de578063b8378f751461090d578063db45479b14610938578063e5949b5d146109f1578063ee4516d914610a47578063fadc554b14610b06578063fc0c546a14610bc9578063fe49ba1c14610c20575b600080fd5b34801561017b57600080fd5b5061022060048036038101908080359060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803590602001908201803590602001908080601f0160208091040260200160405190810160405280939291908181526020018383808284378201915050505050509192919290505050610ca9565b005b34801561022e57600080fd5b5061028d600480360381019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050611096565b6040518082815260200191505060405180910390f35b3480156102af57600080fd5b506102b8611355565b005b3480156102c657600080fd5b506102cf6113f0565b6040518082815260200191505060405180910390f35b3480156102f157600080fd5b506102fa6113f6565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b34801561034857600080fd5b5061035161141c565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b34801561039f57600080fd5b506103a8611442565b6040518082815260200191505060405180910390f35b3480156103ca57600080fd5b506103d3611448565b6040518082815260200191505060405180910390f35b3480156103f557600080fd5b506104186004803603810190808035600019169060200190929190505050611455565b6040518082815260200191505060405180910390f35b34801561043a57600080fd5b5061044361146d565b6040518082815260200191505060405180910390f35b34801561046557600080fd5b506104ce60048036038101908080359060200190929190803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611479565b005b3480156104dc57600080fd5b506104e56118d1565b6040518082815260200191505060405180910390f35b34801561050757600080fd5b506105106118d7565b6040518082815260200191505060405180910390f35b34801561053257600080fd5b50610567600480360381019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506118fb565b604051808215151515815260200191505060405180910390f35b34801561058d57600080fd5b506105e2600480360381019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff16906020019092919050505061190e565b60405180826000191660001916815260200191505060405180910390f35b34801561060c57600080fd5b5061066b60048036038101908080359060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611c06565b6040518083815260200182600481111561068157fe5b60ff1681526020019250505060405180910390f35b3480156106a257600080fd5b506106ab611d07565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156106eb5780820151818401526020810190506106d0565b50505050905090810190601f1680156107185780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b34801561073257600080fd5b50610787600480360381019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611d40565b6040518082815260200191505060405180910390f35b3480156107a957600080fd5b5061084c60048036038101908080359060200190929190803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190803590602001909291908035600019169060200190929190803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190803590602001909291908035600019169060200190929190505050611e27565b005b34801561085a57600080fd5b50610863612351565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156108a3578082015181840152602081019050610888565b50505050905090810190601f1680156108d05780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b3480156108ea57600080fd5b506108f361238a565b604051808215151515815260200191505060405180910390f35b34801561091957600080fd5b5061092261239d565b6040518082815260200191505060405180910390f35b34801561094457600080fd5b506109ef60048036038101908080359060200190929190803573ffffffffffffffffffffffffffffffffffffffff1690602001909291908035600019169060200190929190803590602001909291908035600019169060200190929190803590602001908201803590602001908080601f01602080910402602001604051908101604052809392919081815260200183838082843782019150505050505091929192905050506123a3565b005b3480156109fd57600080fd5b50610a1c6004803603810190808035906020019092919050505061255f565b60405180838152602001826004811115610a3257fe5b60ff1681526020019250505060405180910390f35b348015610a5357600080fd5b50610ab260048036038101908080359060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050612590565b60405180888152602001878152602001861515151581526020018560001916600019168152602001848152602001836000191660001916815260200182815260200197505050505050505060405180910390f35b348015610b1257600080fd5b50610bc760048036038101908080359060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803560001916906020019092919080359060200190929190803560001916906020019092919080359060200190820180359060200191909192939192939080359060200190820180359060200191909192939192939050505061266c565b005b348015610bd557600080fd5b50610bde6128fb565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b348015610c2c57600080fd5b50610c8b60048036038101908080359060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050612920565b60405180826000191660001916815260200191505060405180910390f35b600080600080600080610cbc8989611d40565b8a14151515610cca57600080fd5b60006004811115610cd757fe5b600760008c815260200190815260200160002060010160009054906101000a900460ff166004811115610d0657fe5b141515610d1257600080fd5b60008751111515610d2257600080fd5b610d2b87612a6e565b8095508196505050610d3e8a898b612920565b95506009600087600019166000191681526020019081526020016000209050806001015492508460001916816000015460001916141515610d7e57600080fd5b600083111515610d8d57600080fd5b610d978484612e86565b93508383039150600960008760001916600019168152602001908152602001600020600080820160009055600182016000905550508773ffffffffffffffffffffffffffffffffffffffff168973ffffffffffffffffffffffffffffffffffffffff168b7f8c03cf01b3d4e6068cc494e6fe02aa9e3d4af069d37c32ecc3b241af5c37e6c0888887604051808460001916600019168152602001838152602001828152602001935050505060405180910390a46000841115610f5e576000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb8a866040518363ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200182815260200192505050602060405180830381600087803b158015610f1757600080fd5b505af1158015610f2b573d6000803e3d6000fd5b505050506040513d6020811015610f4157600080fd5b81019080805190602001909291905050501515610f5d57600080fd5b5b6000821115611072576000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb89846040518363ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200182815260200192505050602060405180830381600087803b15801561102b57600080fd5b505af115801561103f573d6000803e3d6000fd5b505050506040513d602081101561105557600080fd5b8101908080519060200190929190505050151561107157600080fd5b5b81831015151561107e57fe5b83831015151561108a57fe5b50505050505050505050565b60008060008060001515600660149054906101000a900460ff1615151415156110be57600080fd5b8460035481101515156110d057600080fd5b60045481111515156110e157600080fd5b680d8d726b7177a800006000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050602060405180830381600087803b1580156111a757600080fd5b505af11580156111bb573d6000803e3d6000fd5b505050506040513d60208110156111d157600080fd5b81019080805190602001909291905050501015156111ee57600080fd5b6001600560008282540192505081905550600554925061120e888861190e565b935060006008600086600019166000191681526020019081526020016000205414151561123a57600080fd5b82600860008660001916600019168152602001908152602001600020819055506007600084815260200190815260200160002091506000826000015414151561127f57fe5b6000600481111561128c57fe5b8260010160009054906101000a900460ff1660048111156112a957fe5b1415156112b257fe5b85826000018190555060018260010160006101000a81548160ff021916908360048111156112dc57fe5b02179055508673ffffffffffffffffffffffffffffffffffffffff168873ffffffffffffffffffffffffffffffffffffffff16847f669a4b0ac0b9994c0f82ed4dbe07bb421fe74e5951725af4f139c7443ebf049d896040518082815260200191505060405180910390a4829450505050509392505050565b60001515600660149054906101000a900460ff16151514151561137757600080fd5b600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415156113d357600080fd5b6001600660146101000a81548160ff021916908315150217905550565b60045481565b600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b60025481565b680d8d726b7177a8000081565b60086020528060005260406000206000915090505481565b67010a741a4627800081565b6000806000806000801515600660149054906101000a900460ff1615151415156114a257600080fd5b88600160048111156114b057fe5b6007600083815260200190815260200160002060010160009054906101000a900460ff1660048111156114df57fe5b1415156114eb57600080fd5b6114f58988611d40565b8a14151561150257600080fd5b60008811151561151157600080fd5b67010a741a46278000881115151561152857600080fd5b600760008b815260200190815260200160002093508360020160008a73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002092508360020160008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002091508260000154880395506000861115156115db57600080fd5b8786111515156115ea57600080fd5b87868460000154011415156115fb57fe5b680d8d726b7177a80000866000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050602060405180830381600087803b1580156116c257600080fd5b505af11580156116d6573d6000803e3d6000fd5b505050506040513d60208110156116ec57600080fd5b8101908080519060200190929190505050011115151561170b57600080fd5b878360000181905550816000015483600001540194508260000154851015151561173457600080fd5b8873ffffffffffffffffffffffffffffffffffffffff168a7f2b55547a3b586ab51f65ee9ce4927fa6d25191388299988e89e059a02f9dd44585600001546040518082815260200191505060405180910390a36000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd3330896040518463ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018281526020019350505050602060405180830381600087803b15801561187f57600080fd5b505af1158015611893573d6000803e3d6000fd5b505050506040513d60208110156118a957600080fd5b810190808051906020019092919050505015156118c557600080fd5b50505050505050505050565b60055481565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81565b600080823b905060008111915050919050565b60008073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff161415151561194b57600080fd5b600073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff161415151561198757600080fd5b8173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff16141515156119c257600080fd5b8173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff161015611afd578282604051602001808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166c010000000000000000000000000281526014018273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166c01000000000000000000000000028152601401925050506040516020818303038152906040526040518082805190602001908083835b602083101515611ac95780518252602082019150602081019050602083039250611aa4565b6001836020036101000a03801982511681845116808217855250505050505090500191505060405180910390209050611c00565b8183604051602001808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166c010000000000000000000000000281526014018273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166c01000000000000000000000000028152601401925050506040516020818303038152906040526040518082805190602001908083835b602083101515611bd05780518252602082019150602081019050602083039250611bab565b6001836020036101000a038019825116818451168082178552505050505050905001915050604051809103902090505b92915050565b600080600080600080600080600760008c815260200190815260200160002093508360010160009054906101000a900460ff16925060006004811115611c4857fe5b836004811115611c5457fe5b148015611c61575060008b115b8015611c6f57506005548b11155b15611cef5760039250611c838b8b8b612920565b95506009600087600019166000191681526020019081526020016000209150611cad8b8a8c612920565b9450600960008660001916600019168152602001908152602001600020905060008260010154148015611ce4575060008160010154145b15611cee57600492505b5b83600001548397509750505050505050935093915050565b6040805190810160405280601a81526020017f19457468657265756d205369676e6564204d6573736167653a0a00000000000081525081565b600080600073ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff1614151515611d7f57600080fd5b600073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1614151515611dbb57600080fd5b8273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff1614151515611df657600080fd5b611e00848461190e565b90506008600082600019166000191681526020019081526020016000205491505092915050565b600080600080611e378c89611d40565b8d141515611e4457600080fd5b611e4e8c8961190e565b9350600760008e8152602001908152602001600020925060026004811115611e7257fe5b8360010160009054906101000a900460ff166004811115611e8f57fe5b141515611e9b57600080fd5b438360000154101515611ead57600080fd5b8260020160008d73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002091508260020160008973ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000209050611f3f828c8c8c612e9f565b1515611f4a57600080fd5b611f5681888888612e9f565b1515611f6157600080fd5b611f6f828c8c848b8b612f9b565b809950819d50829a50839e50505050508260020160008d73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008082016000905560018201600090556002820160006101000a81549060ff02191690556003820160009055600482016000905550508260020160008973ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008082016000905560018201600090556002820160006101000a81549060ff0219169055600382016000905560048201600090555050600760008e81526020019081526020016000206000808201600090556001820160006101000a81549060ff02191690555050600860008560001916600019168152602001908152602001600020600090556120cd8d8d8a8d8d6130aa565b6120da8d898e89896130aa565b8c7f0e239ef20c651bd0bc45e6f6a5fd46252d77d39d6602103e347add00cabdb0b48c89604051808381526020018281526020019250505060405180910390a260008b111561222e576000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb8d8d6040518363ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200182815260200192505050602060405180830381600087803b1580156121e757600080fd5b505af11580156121fb573d6000803e3d6000fd5b505050506040513d602081101561221157600080fd5b8101908080519060200190929190505050151561222d57600080fd5b5b6000871115612342576000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb89896040518363ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200182815260200192505050602060405180830381600087803b1580156122fb57600080fd5b505af115801561230f573d6000803e3d6000fd5b505050506040513d602081101561232557600080fd5b8101908080519060200190929190505050151561234157600080fd5b5b50505050505050505050505050565b6040805190810160405280600581526020017f302e342e3000000000000000000000000000000000000000000000000000000081525081565b600660149054906101000a900460ff1681565b60035481565b60008087600160048111156123b457fe5b6007600083815260200190815260200160002060010160009054906101000a900460ff1660048111156123e357fe5b1415156123ef57600080fd5b6123f93389611d40565b8914151561240657600080fd5b600760008a8152602001908152602001600020915060028260010160006101000a81548160ff0219169083600481111561243c57fe5b021790555060018260020160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060020160006101000a81548160ff021916908315150217905550438260000160008282540192505081905550600086111561250f576124c68988888888613117565b92508273ffffffffffffffffffffffffffffffffffffffff168873ffffffffffffffffffffffffffffffffffffffff1614151561250257600080fd5b61250e8284888a613358565b5b853373ffffffffffffffffffffffffffffffffffffffff168a7f5fe3d4a343010393184843ef4873386b572e844e89f6b41c9f60f5ab912fbdfe60405160405180910390a4505050505050505050565b60076020528060005260406000206000915090508060000154908060010160009054906101000a900460ff16905082565b600080600080600080600080600080600760008e815260200190815260200160002060020160008d73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002091506125ff8d8d8d612920565b92506009600084600019166000191681526020019081526020016000209050816000015482600101548360020160009054906101000a900460ff16846003015485600401548560000154866001015499509950995099509950995099505050509397509397509397909450565b60008060008061267c8d8d611d40565b8e14151561268957600080fd5b6000600102600019168b60001916141515156126a457600080fd5b60008a1115156126b357600080fd5b600760008f81526020019081526020016000209150600260048111156126d557fe5b8260010160009054906101000a900460ff1660048111156126f257fe5b1415156126fe57600080fd5b4382600001541015151561271157600080fd5b6127838e8c8c8c8c8c8080601f0160208091040260200160405190810160405280939291908181526020018383808284378201915050505050508b8b8080601f0160208091040260200160405190810160405280939291908181526020018383808284378201915050505050506133cc565b93508373ffffffffffffffffffffffffffffffffffffffff168c73ffffffffffffffffffffffffffffffffffffffff161415156127bf57600080fd5b6127fe8e8c8c8c8c8c8080601f016020809104026020016040519081016040528093929190818152602001838380828437820191505050505050613117565b92508273ffffffffffffffffffffffffffffffffffffffff168d73ffffffffffffffffffffffffffffffffffffffff1614151561283a57600080fd5b8160020160008e73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090508060020160009054906101000a900460ff16151561289a57600080fd5b6128a6828e8c8e613358565b898d73ffffffffffffffffffffffffffffffffffffffff168f7f09bd10d8ee6f30d654401133d6eac60e091a0d8e13f54005754de9394c11fbd360405160405180910390a45050505050505050505050505050565b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b60008173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff161415151561295d57600080fd5b838383604051602001808481526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166c010000000000000000000000000281526014018273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166c0100000000000000000000000002815260140193505050506040516020818303038152906040526040518082805190602001908083835b602083101515612a385780518252602082019150602081019050602083039250612a13565b6001836020036101000a038019825116818451168082178552505050505050905001915050604051809103902090509392505050565b6000806000806000806000806060895196506000606088811515612a8e57fe5b06141515612a9b57600080fd5b6001606088811515612aa957fe5b0401604051908082528060200260200182016040528015612ad95781602001602082028038833980820191505090505b509050602095505b86861015612b3e57612af38a87613663565b809550819450505083850194508281606088811515612b0e57fe5b04815181101515612b1b57fe5b906020019060200201906000191690816000191681525050606086019550612ae1565b606087811515612b4a57fe5b0496505b6001871115612e59576000600288811515612b6557fe5b06141515612bb5578060018803815181101515612b7e57fe5b906020019060200201518188815181101515612b9657fe5b9060200190602002019060001916908160001916815250506001870196505b600095505b60018703861015612e45578060018701815181101515612bd657fe5b90602001906020020151600019168187815181101515612bf257fe5b90602001906020020151600019161415612c25578086815181101515612c1457fe5b906020019060200201519250612e07565b8060018701815181101515612c3657fe5b90602001906020020151600019168187815181101515612c5257fe5b90602001906020020151600019161015612d38578086815181101515612c7457fe5b906020019060200201518160018801815181101515612c8f57fe5b906020019060200201516040516020018083600019166000191681526020018260001916600019168152602001925050506040516020818303038152906040526040518082805190602001908083835b602083101515612d045780518252602082019150602081019050602083039250612cdf565b6001836020036101000a03801982511681845116808217855250505050505090500191505060405180910390209250612e06565b8060018701815181101515612d4957fe5b906020019060200201518187815181101515612d6157fe5b906020019060200201516040516020018083600019166000191681526020018260001916600019168152602001925050506040516020818303038152906040526040518082805190602001908083835b602083101515612dd65780518252602082019150602081019050602083039250612db1565b6001836020036101000a038019825116818451168082178552505050505050905001915050604051809103902092505b5b8281600288811515612e1557fe5b04815181101515612e2257fe5b906020019060200201906000191690816000191681525050600286019550612bba565b600286811515612e5157fe5b049650612b4e565b806000815181101515612e6857fe5b90602001906020020151915081859850985050505050505050915091565b6000818311612e955782612e97565b815b905092915050565b600080600102856003015460001916148015612ebb5750600084145b8015612ec75750600083145b8015612eda575060006001028260001916145b15612ee85760019050612f93565b83838360405160200180848152602001838152602001826000191660001916815260200193505050506040516020818303038152906040526040518082805190602001908083835b602083101515612f555780518252602082019150602081019050602083039250612f30565b6001836020036101000a0380198251168184511680821785525050505050509050019150506040518091039020600019168560030154600019161490505b949350505050565b6000806000806000806000612fae613a84565b612fb6613a84565b8e600001548260000181815250508e600101548260200181815250508d8260400181815250508c8260600181815250508b600001548160000181815250508b600101548160200181815250508a816040018181525050898160600181815250506130208f8d61383d565b925061302c828261385e565b94506130388584612e86565b94508483039350613049858b6138f2565b809b50819650505061305b848e6138f2565b809e50819550505082851115151561306f57fe5b82841115151561307b57fe5b898d85870101018314151561308c57fe5b84848e8c985098509850985050505050509650965096509692505050565b60008060008414806130c3575060006001028360001916145b156130cd5761310e565b6130d8878787612920565b91506009600083600019166000191681526020019081526020016000209050828160000181600019169055508381600101819055505b50505050505050565b6000606060006040805190810160405280600381526020017f323132000000000000000000000000000000000000000000000000000000000081525091506040805190810160405280601a81526020017f19457468657265756d205369676e6564204d6573736167653a0a00000000000081525082306002546001600481111561319d57fe5b8c8c8c8c604051602001808a805190602001908083835b6020831015156131d957805182526020820191506020810190506020830392506131b4565b6001836020036101000a03801982511681845116808217855250505050505090500189805190602001908083835b60208310151561322c5780518252602082019150602081019050602083039250613207565b6001836020036101000a0380198251168184511680821785525050505050509050018873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166c010000000000000000000000000281526014018781526020018681526020018581526020018460001916600019168152602001838152602001826000191660001916815260200199505050505050505050506040516020818303038152906040526040518082805190602001908083835b60208310151561331257805182526020820191506020810190506020830392506132ed565b6001836020036101000a0380198251168184511680821785525050505050509050019150506040518091039020905061334b8185613917565b9250505095945050505050565b60008460020160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090508060040154831115156133af57600080fd5b828160040181905550818160030181600019169055505050505050565b6000606060006040805190810160405280600381526020017f323737000000000000000000000000000000000000000000000000000000000081525091506040805190810160405280601a81526020017f19457468657265756d205369676e6564204d6573736167653a0a00000000000081525082306002546002600481111561345257fe5b8d8d8d8d8d604051602001808b805190602001908083835b60208310151561348f578051825260208201915060208101905060208303925061346a565b6001836020036101000a0380198251168184511680821785525050505050509050018a805190602001908083835b6020831015156134e257805182526020820191506020810190506020830392506134bd565b6001836020036101000a0380198251168184511680821785525050505050509050018973ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166c010000000000000000000000000281526014018881526020018781526020018681526020018560001916600019168152602001848152602001836000191660001916815260200182805190602001908083835b6020831015156135aa5780518252602082019150602081019050602083039250613585565b6001836020036101000a0380198251168184511680821785525050505050509050019a50505050505050505050506040516020818303038152906040526040518082805190602001908083835b60208310151561361c57805182526020820191506020810190506020830392506135f7565b6001836020036101000a038019825116818451168082178552505050505050905001915050604051809103902090506136558185613917565b925050509695505050505050565b60008060008060008060008789511115156136875780600080905096509650613831565b87890151945060208801890151935060408801890151915084848360405160200180848152602001838152602001826000191660001916815260200193505050506040516020818303038152906040526040518082805190602001908083835b60208310151561370c57805182526020820191506020810190506020830392506136e7565b6001836020036101000a03801982511681845116808217855250505050505090500191505060405180910390209050600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663c1f62946836040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808260001916600019168152602001915050602060405180830381600087803b1580156137d457600080fd5b505af11580156137e8573d6000803e3d6000fd5b505050506040513d60208110156137fe57600080fd5b8101908080519060200190929190505050925060008314806138205750828511155b1561382a57600093505b8084965096505b50505050509250929050565b60008160010154836001015483600001548560000154010303905092915050565b600080600080600061387887604001518860600151613a43565b935061388c86604001518760600151613a43565b925083831015151561389d57600080fd5b866040015184101515156138ad57fe5b856040015183101515156138bd57fe5b83830391506138d0828860000151613a43565b90506138e08188602001516138f2565b50809150508094505050505092915050565b6000808284116139075760008481915061390c565b828403835b915091509250929050565b6000806000806041855114151561392d57600080fd5b6020850151925060408501519150606085015160001a9050601b8160ff16101561395857601b810190505b601b8160ff16148061396d5750601c8160ff16145b151561397857600080fd5b600186828585604051600081526020016040526040518085600019166000191681526020018460ff1660ff1681526020018360001916600019168152602001826000191660001916815260200194505050505060206040516020810390808403906000865af11580156139ef573d6000803e3d6000fd5b505050602060405103519350600073ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff1614151515613a3757600080fd5b83935050505092915050565b600080828401905083811015613a79577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff613a7b565b805b91505092915050565b6080604051908101604052806000815260200160008152602001600081526020016000815250905600a165627a7a7230582031e6ac55398c2f815444a8e98e33222f5641cc4acbed9b812770679645b193810029000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000002d07731e878e4c59bda93ea3fe93e34fb0172bd0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000001f400000000000000000000000000000000000000000000000000000000000879a40000000000000000000000004acc8495159749c6a0f1580167bbf262cb462215",
  "constructorArguments": "000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000002d07731e878e4c59bda93ea3fe93e34fb0172bd0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000001f400000000000000000000000000000000000000000000000000000000000879a40000000000000000000000004acc8495159749c6a0f1580167bbf262cb462215"
}