{
  "address": "0xd138deade3c2f087e6d9b8fdc90a69a2ca34a513",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "DeconetPaymentsSplittingFactory",
  "compilerVersion": "v0.4.25+commit.59dbf8f1",
  "optimization": false,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2018-12-07\n*/\n\npragma solidity 0.4.25;\n// produced by the Solididy File Flattener (c) David Appleton 2018\n// contact : [emailÂ protected]\n// released under Apache 2.0 licence\ncontract CloneFactory {\n\n  event CloneCreated(address indexed target, address clone);\n\n  function createClone(address target) internal returns (address result) {\n    bytes memory clone = hex\"3d602d80600a3d3981f3363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe5af43d82803e903d91602b57fd5bf3\";\n    bytes20 targetBytes = bytes20(target);\n    for (uint i = 0; i < 20; i++) {\n      clone[20 + i] = targetBytes[i];\n    }\n    assembly {\n      let len := mload(clone)\n      let data := add(clone, 0x20)\n      result := create(0, data, len)\n    }\n  }\n}\n\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (_a == 0) {\n      return 0;\n    }\n\n    c = _a * _b;\n    assert(c / _a == _b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = _a / _b;\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n    return _a / _b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    assert(_b <= _a);\n    return _a - _b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    c = _a + _b;\n    assert(c >= _a);\n    return c;\n  }\n}\n\ncontract DeconetPaymentsSplitting {\n    using SafeMath for uint;\n\n    // Logged on this distribution set up completion.\n    event DistributionCreated (\n        address[] destinations,\n        uint[] sharesMantissa,\n        uint sharesExponent\n    );\n\n    // Logged when funds landed to or been sent out from this contract balance.\n    event FundsOperation (\n        address indexed senderOrAddressee,\n        uint amount,\n        FundsOperationType indexed operationType\n    );\n\n    // Enumeration of possible funds operations.\n    enum FundsOperationType { Incoming, Outgoing }\n\n    // Describes Distribution destination and its share of all incoming funds.\n    struct Distribution {\n        // Destination address of the distribution.\n        address destination;\n\n        // Floating-point number mantissa of a share allotted for a destination address.\n        uint mantissa;\n    }\n\n    // Stores exponent of a power term of a floating-point number.\n    uint public sharesExponent;\n\n    // Stores list of distributions.\n    Distribution[] public distributions;\n\n    /**\n     * @dev Payable fallback that tries to send over incoming funds to the distribution destinations splitted\n     * by pre-configured shares. In case when there is not enough gas sent for the transaction to complete\n     * distribution, all funds will be kept in contract untill somebody calls `withdrawFullContractBalance` to\n     * run postponed distribution and withdraw contract's balance funds.\n     */\n    function () public payable {\n        emit FundsOperation(msg.sender, msg.value, FundsOperationType.Incoming);\n        distributeFunds();\n    }\n\n    /**\n     * @dev Set up distribution for the current clone, can be called only once.\n     * @param _destinations Destination addresses of the current payments splitting contract clone.\n     * @param _sharesMantissa Mantissa values for destinations shares ordered respectively with `_destinations`.\n     * @param _sharesExponent Exponent of a power term that forms shares floating-point numbers, expected to\n     * be the same for all values in `_sharesMantissa`.\n     */\n    function setUpDistribution(\n        address[] _destinations,\n        uint[] _sharesMantissa,\n        uint _sharesExponent\n    )\n        external\n    {\n        require(distributions.length == 0, \"Contract can only be initialized once\"); // Make sure the clone isn't initialized yet.\n        require(_destinations.length <= 8 && _destinations.length > 0, \"There is a maximum of 8 destinations allowed\");  // max of 8 destinations\n        // prevent integer overflow when math with _sharesExponent happens\n        // also ensures that low balances can be distributed because balance must always be >= 10**(sharesExponent + 2)\n        require(_sharesExponent <= 4, \"The maximum allowed sharesExponent is 4\");\n        // ensure that lengths of arrays match so array out of bounds can't happen\n        require(_destinations.length == _sharesMantissa.length, \"Length of destinations does not match length of sharesMantissa\");\n\n        uint sum = 0;\n        for (uint i = 0; i < _destinations.length; i++) {\n            // Forbid contract as destination so that transfer can never fail\n            require(!isContract(_destinations[i]), \"A contract may not be a destination address\");\n            sum = sum.add(_sharesMantissa[i]);\n            distributions.push(Distribution(_destinations[i], _sharesMantissa[i]));\n        }\n         // taking into account 100% by adding 2 to the exponent.\n        require(sum == 10**(_sharesExponent.add(2)), \"The sum of all sharesMantissa should equal 10 ** ( _sharesExponent + 2 ) but it does not.\");\n        sharesExponent = _sharesExponent;\n        emit DistributionCreated(_destinations, _sharesMantissa, _sharesExponent);\n    }\n\n    /**\n     * @dev Process the available balance through the distribution and send money over to destination addresses.\n     */\n    function distributeFunds() public {\n        uint balance = address(this).balance;\n        require(balance >= 10**(sharesExponent.add(2)), \"You can not split up less wei than sum of all shares\");\n        for (uint i = 0; i < distributions.length; i++) {\n            Distribution memory distribution = distributions[i];\n            uint amount = calculatePayout(balance, distribution.mantissa, sharesExponent);\n            distribution.destination.transfer(amount);\n            emit FundsOperation(distribution.destination, amount, FundsOperationType.Outgoing);\n        }\n    }\n\n    /**\n     * @dev Returns length of distributions array\n     * @return Length of distributions array\n    */\n    function distributionsLength() public view returns (uint256) {\n        return distributions.length;\n    }\n\n\n    /**\n     * @dev Calculates a share of the full amount.\n     * @param _fullAmount Full amount.\n     * @param _shareMantissa Mantissa of the percentage floating-point number.\n     * @param _shareExponent Exponent of the percentage floating-point number.\n     * @return An uint of the payout.\n     */\n    function calculatePayout(uint _fullAmount, uint _shareMantissa, uint _shareExponent) private pure returns(uint) {\n        return (_fullAmount.div(10 ** (_shareExponent.add(2)))).mul(_shareMantissa);\n    }\n\n    /**\n     * @dev Checks whether or not a given address contains a contract\n     * @param _addr The address to check\n     * @return A boolean indicating whether or not the address is a contract\n     */\n    function isContract(address _addr) private view returns (bool) {\n        uint32 size;\n        assembly {\n            size := extcodesize(_addr)\n        }\n        return (size > 0);\n    }\n}\n\ncontract DeconetPaymentsSplittingFactory is CloneFactory {\n\n    // PaymentsSplitting master-contract address.\n    address public libraryAddress;\n\n    // Logged when a new PaymentsSplitting clone is deployed to the chain.\n    event PaymentsSplittingCreated(address newCloneAddress);\n\n    /**\n     * @dev Constructor for the contract.\n     * @param _libraryAddress PaymentsSplitting master-contract address.\n     */\n    constructor(address _libraryAddress) public {\n        libraryAddress = _libraryAddress;\n    }\n\n    /**\n     * @dev Create PaymentsSplitting clone.\n     * @param _destinations Destination addresses of the new PaymentsSplitting contract clone.\n     * @param _sharesMantissa Mantissa values for destinations shares ordered respectively with `_destinations`.\n     * @param _sharesExponent Exponent of a power term that forms shares floating-point numbers, expected to\n     * be the same for all values in `_sharesMantissa`.\n     */\n    function createPaymentsSplitting(\n        address[] _destinations,\n        uint[] _sharesMantissa,\n        uint _sharesExponent\n    )\n        external\n        returns(address)\n    {\n        address clone = createClone(libraryAddress);\n        DeconetPaymentsSplitting(clone).setUpDistribution(_destinations, _sharesMantissa, _sharesExponent);\n        emit PaymentsSplittingCreated(clone);\n        return clone;\n    }\n}",
  "bytecode": "608060405234801561001057600080fd5b506040516020806104a583398101806040528101908080519060200190929190505050806000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050610422806100836000396000f30060806040526004361061004c576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063b324816a14610051578063b816f513146100ee575b600080fd5b34801561005d57600080fd5b506100ac60048036038101908080359060200190820180359060200191909192939192939080359060200190820180359060200191909192939192939080359060200190929190505050610145565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b3480156100fa57600080fd5b506101036102b5565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b6000806101726000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff166102da565b90508073ffffffffffffffffffffffffffffffffffffffff1663e8211eeb88888888886040518663ffffffff167c01000000000000000000000000000000000000000000000000000000000281526004018080602001806020018481526020018381038352888882818152602001925060200280828437820191505083810382528686828181526020019250602002808284378201915050975050505050505050600060405180830381600087803b15801561022d57600080fd5b505af1158015610241573d6000803e3d6000fd5b505050507f5cbb16c37e699341e78c777ebf08af28de2b4dc91fccf65f6ba0f749fbcdb3f981604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390a18091505095945050505050565b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b60006060600080606060405190810160405280603781526020017f3d602d80600a3d3981f3363d3d373d3d3d363d73bebebebebebebebebebebebe81526020017fbebebebebebebebe5af43d82803e903d91602b57fd5bf30000000000000000008152509250846c01000000000000000000000000029150600090505b60148110156103df57818160148110151561036e57fe5b1a7f01000000000000000000000000000000000000000000000000000000000000000283826014018151811015156103a257fe5b9060200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053508080600101915050610357565b82516020840181816000f0955050505050509190505600a165627a7a72305820ee01b5edf5da977257ce2939ae666ca9a17c02c49d5b338af8c57d587df043570029000000000000000000000000a485a4bbbd026cf0c49844ef617bd4a913b2bc89",
  "constructorArguments": "000000000000000000000000a485a4bbbd026cf0c49844ef617bd4a913b2bc89"
}