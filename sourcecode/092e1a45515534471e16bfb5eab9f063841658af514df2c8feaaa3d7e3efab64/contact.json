{
  "address": "0xaf038b0290c35a3210d5cfda9f39ffceea1c1ea5",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "GigToken",
  "compilerVersion": "v0.4.19+commit.c4cbbb05",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2018-04-16\n*/\n\npragma solidity 0.4.19;\n\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}\n\n\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n\ncontract Multivest is Ownable {\n\n    using SafeMath for uint256;\n\n    /* public variables */\n    mapping (address => bool) public allowedMultivests;\n\n    /* events */\n    event MultivestSet(address multivest);\n\n    event MultivestUnset(address multivest);\n\n    event Contribution(address holder, uint256 value, uint256 tokens);\n\n    modifier onlyAllowedMultivests(address _addresss) {\n        require(allowedMultivests[_addresss] == true);\n        _;\n    }\n\n    /* constructor */\n    function Multivest() public {}\n\n    function setAllowedMultivest(address _address) public onlyOwner {\n        allowedMultivests[_address] = true;\n        MultivestSet(_address);\n    }\n\n    function unsetAllowedMultivest(address _address) public onlyOwner {\n        allowedMultivests[_address] = false;\n        MultivestUnset(_address);\n    }\n\n    function multivestBuy(address _address, uint256 _value) public onlyAllowedMultivests(msg.sender) {\n        require(buy(_address, _value) == true);\n    }\n\n    function multivestBuy(\n        address _address,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) public payable onlyAllowedMultivests(verify(keccak256(msg.sender), _v, _r, _s)) {\n        require(_address == msg.sender && buy(msg.sender, msg.value) == true);\n    }\n\n    function verify(bytes32 _hash, uint8 _v, bytes32 _r, bytes32 _s) internal pure returns (address) {\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n\n        return ecrecover(keccak256(prefix, _hash), _v, _r, _s);\n    }\n\n    function buy(address _address, uint256 _value) internal returns (bool);\n\n}\n\n\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n\ncontract GigERC20 is StandardToken, Ownable {\n    /* Public variables of the token */\n    uint256 public creationBlock;\n\n    uint8 public decimals;\n\n    string public name;\n\n    string public symbol;\n\n    string public standard;\n\n    bool public locked;\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    function GigERC20(\n        uint256 _totalSupply,\n        string _tokenName,\n        uint8 _decimalUnits,\n        string _tokenSymbol,\n        bool _transferAllSupplyToOwner,\n        bool _locked\n    ) public {\n        standard = \"ERC20 0.1\";\n        locked = _locked;\n        totalSupply_ = _totalSupply;\n\n        if (_transferAllSupplyToOwner) {\n            balances[msg.sender] = totalSupply_;\n        } else {\n            balances[this] = totalSupply_;\n        }\n        name = _tokenName;\n        // Set the name for display purposes\n        symbol = _tokenSymbol;\n        // Set the symbol for display purposes\n        decimals = _decimalUnits;\n        // Amount of decimals for display purposes\n        creationBlock = block.number;\n    }\n\n    function setLocked(bool _locked) public onlyOwner {\n        locked = _locked;\n    }\n\n    /* public methods */\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(locked == false);\n        return super.transfer(_to, _value);\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        if (locked) {\n            return false;\n        }\n        return super.approve(_spender, _value);\n    }\n\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool success) {\n        if (locked) {\n            return false;\n        }\n        return super.increaseApproval(_spender, _addedValue);\n    }\n\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool success) {\n        if (locked) {\n            return false;\n        }\n        return super.decreaseApproval(_spender, _subtractedValue);\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        if (locked) {\n            return false;\n        }\n\n        return super.transferFrom(_from, _to, _value);\n    }\n\n}\n\n\n/*\nThis contract manages the minters and the modifier to allow mint to happen only if called by minters\nThis contract contains basic minting functionality though\n*/\ncontract MintingERC20 is GigERC20 {\n\n    using SafeMath for uint256;\n\n    //Variables\n    mapping (address => bool) public minters;\n\n    uint256 public maxSupply;\n\n    //Modifiers\n    modifier onlyMinters () {\n        require(true == minters[msg.sender]);\n        _;\n    }\n\n    function MintingERC20(\n        uint256 _initialSupply,\n        uint256 _maxSupply,\n        string _tokenName,\n        uint8 _decimals,\n        string _symbol,\n        bool _transferAllSupplyToOwner,\n        bool _locked\n    )\n        public GigERC20(_initialSupply, _tokenName, _decimals, _symbol, _transferAllSupplyToOwner, _locked)\n    {\n        standard = \"MintingERC20 0.1\";\n        minters[msg.sender] = true;\n        maxSupply = _maxSupply;\n    }\n\n    function addMinter(address _newMinter) public onlyOwner {\n        minters[_newMinter] = true;\n    }\n\n    function removeMinter(address _minter) public onlyOwner {\n        minters[_minter] = false;\n    }\n\n    function mint(address _addr, uint256 _amount) public onlyMinters returns (uint256) {\n        if (true == locked) {\n            return uint256(0);\n        }\n\n        if (_amount == uint256(0)) {\n            return uint256(0);\n        }\n\n        if (totalSupply_.add(_amount) > maxSupply) {\n            return uint256(0);\n        }\n\n        totalSupply_ = totalSupply_.add(_amount);\n        balances[_addr] = balances[_addr].add(_amount);\n        Transfer(address(0), _addr, _amount);\n\n        return _amount;\n    }\n\n}\n\n\ncontract GigToken is MintingERC20 {\n    SellableToken public crowdSale; // Pre ICO & ICO\n    SellableToken public privateSale;\n\n    bool public transferFrozen = false;\n\n    uint256 public crowdSaleEndTime;\n\n    mapping(address => uint256) public lockedBalancesReleasedAfterOneYear;\n\n    modifier onlyCrowdSale() {\n        require(crowdSale != address(0) && msg.sender == address(crowdSale));\n\n        _;\n    }\n\n    modifier onlySales() {\n        require((privateSale != address(0) && msg.sender == address(privateSale)) ||\n            (crowdSale != address(0) && msg.sender == address(crowdSale)));\n\n        _;\n    }\n\n    event MaxSupplyBurned(uint256 burnedTokens);\n\n    function GigToken(bool _locked) public\n        MintingERC20(0, maxSupply, \"GigBit\", 18, \"GBTC\", false, _locked)\n    {\n        standard = \"GBTC 0.1\";\n\n        maxSupply = uint256(1000000000).mul(uint256(10) ** decimals);\n    }\n\n    function setCrowdSale(address _crowdSale) public onlyOwner {\n        require(_crowdSale != address(0));\n\n        crowdSale = SellableToken(_crowdSale);\n\n        crowdSaleEndTime = crowdSale.endTime();\n    }\n\n    function setPrivateSale(address _privateSale) public onlyOwner {\n        require(_privateSale != address(0));\n\n        privateSale = SellableToken(_privateSale);\n    }\n\n    function freezing(bool _transferFrozen) public onlyOwner {\n        transferFrozen = _transferFrozen;\n    }\n\n    function isTransferAllowed(address _from, uint256 _value) public view returns (bool status) {\n        uint256 senderBalance = balanceOf(_from);\n        if (transferFrozen == true || senderBalance < _value) {\n            return false;\n        }\n\n        uint256 lockedBalance = lockedBalancesReleasedAfterOneYear[_from];\n\n        // check if holder tries to transfer more than locked tokens\n    if (lockedBalance > 0 && senderBalance.sub(_value) < lockedBalance) {\n            uint256 unlockTime = crowdSaleEndTime + 1 years;\n\n            // fail if unlock time is not come\n            if (crowdSaleEndTime == 0 || block.timestamp < unlockTime) {\n                return false;\n            }\n\n            uint256 secsFromUnlock = block.timestamp.sub(unlockTime);\n\n            // number of months over from unlock\n            uint256 months = secsFromUnlock / 30 days;\n\n            if (months > 12) {\n                months = 12;\n            }\n\n            uint256 tokensPerMonth = lockedBalance / 12;\n\n            uint256 unlockedBalance = tokensPerMonth.mul(months);\n\n            uint256 actualLockedBalance = lockedBalance.sub(unlockedBalance);\n\n            if (senderBalance.sub(_value) < actualLockedBalance) {\n                return false;\n            }\n        }\n\n        if (block.timestamp < crowdSaleEndTime &&\n            crowdSale != address(0) &&\n            crowdSale.isTransferAllowed(_from, _value) == false\n        ) {\n            return false;\n        }\n\n\n        return true;\n    }\n\n    function transfer(address _to, uint _value) public returns (bool) {\n        require(isTransferAllowed(msg.sender, _value));\n\n        return super.transfer(_to, _value);\n    }\n\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\n        // transferFrom & approve are disabled before end of ICO\n        require((crowdSaleEndTime <= block.timestamp) && isTransferAllowed(_from, _value));\n\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        // transferFrom & approve are disabled before end of ICO\n\n        require(crowdSaleEndTime <= block.timestamp);\n\n        return super.approve(_spender, _value);\n    }\n\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool success) {\n        // transferFrom & approve are disabled before end of ICO\n\n        require(crowdSaleEndTime <= block.timestamp);\n\n        return super.increaseApproval(_spender, _addedValue);\n    }\n\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool success) {\n        // transferFrom & approve are disabled before end of ICO\n\n        require(crowdSaleEndTime <= block.timestamp);\n\n        return super.decreaseApproval(_spender, _subtractedValue);\n    }\n\n    function increaseLockedBalance(address _address, uint256 _tokens) public onlySales {\n        lockedBalancesReleasedAfterOneYear[_address] =\n            lockedBalancesReleasedAfterOneYear[_address].add(_tokens);\n    }\n\n    // burn tokens if soft cap is not reached\n    function burnInvestorTokens(\n        address _address,\n        uint256 _amount\n    ) public onlyCrowdSale returns (uint256) {\n        require(block.timestamp > crowdSaleEndTime);\n\n        require(_amount <= balances[_address]);\n\n        balances[_address] = balances[_address].sub(_amount);\n\n        totalSupply_ = totalSupply_.sub(_amount);\n\n        Transfer(_address, address(0), _amount);\n\n        return _amount;\n    }\n\n    // decrease max supply of tokens that are not sold\n    function burnUnsoldTokens(uint256 _amount) public onlyCrowdSale {\n        require(block.timestamp > crowdSaleEndTime);\n\n        maxSupply = maxSupply.sub(_amount);\n\n        MaxSupplyBurned(_amount);\n    }\n}\n\ncontract SellableToken is Multivest {\n    uint256 public constant MONTH_IN_SEC = 2629743;\n    GigToken public token;\n\n    uint256 public minPurchase = 100 * 10 ** 5;\n    uint256 public maxPurchase;\n\n    uint256 public softCap;\n    uint256 public hardCap;\n\n    uint256 public startTime;\n    uint256 public endTime;\n\n    uint256 public maxTokenSupply;\n\n    uint256 public soldTokens;\n\n    uint256 public collectedEthers;\n\n    address public etherHolder;\n\n    uint256 public collectedUSD;\n\n    uint256 public etherPriceInUSD;\n    uint256 public priceUpdateAt;\n\n    mapping(address => uint256) public etherBalances;\n\n    Tier[] public tiers;\n\n    struct Tier {\n        uint256 discount;\n        uint256 startTime;\n        uint256 endTime;\n    }\n\n    event Refund(address _holder, uint256 _ethers, uint256 _tokens);\n    event NewPriceTicker(string _price);\n\n    function SellableToken(\n        address _token,\n        address _etherHolder,\n        uint256 _startTime,\n        uint256 _endTime,\n        uint256 _maxTokenSupply,\n        uint256 _etherPriceInUSD\n    )\n    public Multivest()\n    {\n        require(_token != address(0) && _etherHolder != address(0));\n        token = GigToken(_token);\n\n        require(_startTime < _endTime);\n        etherHolder = _etherHolder;\n        require((_maxTokenSupply == uint256(0)) || (_maxTokenSupply <= token.maxSupply()));\n\n        startTime = _startTime;\n        endTime = _endTime;\n        maxTokenSupply = _maxTokenSupply;\n        etherPriceInUSD = _etherPriceInUSD;\n\n        priceUpdateAt = block.timestamp;\n    }\n\n    function setTokenContract(address _token) public onlyOwner {\n        require(_token != address(0));\n        token = GigToken(_token);\n    }\n\n    function setEtherHolder(address _etherHolder) public onlyOwner {\n        if (_etherHolder != address(0)) {\n            etherHolder = _etherHolder;\n        }\n    }\n\n    function setPurchaseLimits(uint256 _min, uint256 _max) public onlyOwner {\n        if (_min < _max) {\n            minPurchase = _min;\n            maxPurchase = _max;\n        }\n    }\n\n    function mint(address _address, uint256 _tokenAmount) public onlyOwner returns (uint256) {\n        return mintInternal(_address, _tokenAmount);\n    }\n\n    function isActive() public view returns (bool);\n\n    function isTransferAllowed(address _from, uint256 _value) public view returns (bool);\n\n    function withinPeriod() public view returns (bool);\n\n    function getMinEthersInvestment() public view returns (uint256) {\n        return uint256(1 ether).mul(minPurchase).div(etherPriceInUSD);\n    }\n\n    function calculateTokensAmount(uint256 _value) public view returns (uint256 tokenAmount, uint256 usdAmount);\n\n    function calculateEthersAmount(uint256 _tokens) public view returns (uint256 ethers, uint256 bonus);\n\n    function updatePreICOMaxTokenSupply(uint256 _amount) public;\n\n    // set ether price in USD with 5 digits after the decimal point\n    //ex. 308.75000\n    //for updating the price through  multivest\n    function setEtherInUSD(string _price) public onlyAllowedMultivests(msg.sender) {\n        bytes memory bytePrice = bytes(_price);\n        uint256 dot = bytePrice.length.sub(uint256(6));\n\n        // check if dot is in 6 position  from  the last\n        require(0x2e == uint(bytePrice[dot]));\n\n        uint256 newPrice = uint256(10 ** 23).div(parseInt(_price, 5));\n\n        require(newPrice > 0);\n\n        etherPriceInUSD = parseInt(_price, 5);\n\n        priceUpdateAt = block.timestamp;\n\n        NewPriceTicker(_price);\n    }\n\n    function mintInternal(address _address, uint256 _tokenAmount) internal returns (uint256) {\n        uint256 mintedAmount = token.mint(_address, _tokenAmount);\n\n        require(mintedAmount == _tokenAmount);\n\n        soldTokens = soldTokens.add(_tokenAmount);\n        if (maxTokenSupply > 0) {\n            require(maxTokenSupply >= soldTokens);\n        }\n\n        return _tokenAmount;\n    }\n\n    function transferEthers() internal;\n\n    function parseInt(string _a, uint _b) internal pure returns (uint) {\n        bytes memory bresult = bytes(_a);\n        uint res = 0;\n        bool decimals = false;\n        for (uint i = 0; i < bresult.length; i++) {\n            if ((bresult[i] >= 48) && (bresult[i] <= 57)) {\n                if (decimals) {\n                    if (_b == 0) break;\n                    else _b--;\n                }\n                res *= 10;\n                res += uint(bresult[i]) - 48;\n            } else if (bresult[i] == 46) decimals = true;\n        }\n        if (_b > 0) res *= 10 ** _b;\n        return res;\n    }\n}\n\n\ncontract TokenAllocation is Ownable {\n    using SafeERC20 for ERC20Basic;\n    using SafeMath for uint256;\n\n    address public ecosystemIncentive = 0xd339D9aeDFFa244E09874D65290c09d64b2356E0;\n    address public marketingAndBounty = 0x26d6EF95A51BF0A2048Def4Fb7c548c3BDE37410;\n    address public liquidityFund = 0x3D458b6f9024CDD9A2a7528c2E6451DD3b29e4cc;\n    address public treasure = 0x00dEaFC5959Dd0E164bB00D06B08d972A276bf8E;\n    address public amirShaikh = 0x31b17e7a2F86d878429C03f3916d17555C0d4884;\n    address public sadiqHameed = 0x27B5cb71ff083Bd6a34764fBf82700b3669137f3;\n    address public omairLatif = 0x92Db818bF10Bf3BfB73942bbB1f184274aA63833;\n\n    uint256 public icoEndTime;\n\n    address public vestingApplicature;\n    address public vestingSimonCocking;\n    address public vestingNathanChristian;\n    address public vestingEdwinVanBerg;\n\n    mapping(address => bool) public tokenInited;\n    address[] public vestings;\n\n    event VestingCreated(\n        address _vesting,\n        address _beneficiary,\n        uint256 _start,\n        uint256 _cliff,\n        uint256 _duration,\n        uint256 _periods,\n        bool _revocable\n    );\n\n    event VestingRevoked(address _vesting);\n\n    function setICOEndTime(uint256 _icoEndTime) public onlyOwner {\n        icoEndTime = _icoEndTime;\n    }\n\n    function initVesting() public onlyOwner() {\n        require(vestingApplicature == address(0) &&\n        vestingSimonCocking == address(0) &&\n        vestingNathanChristian == address(0) &&\n        vestingEdwinVanBerg == address(0) &&\n        icoEndTime != 0\n        );\n\n        uint256 oneYearAfterIcoEnd = icoEndTime.add(1 years);\n\n        vestingApplicature = createVesting(\n            0x760864dcdC58FDA80dB6883ce442B6ce44921Cf9, oneYearAfterIcoEnd, 0, 1 years, 2, false\n        );\n\n        vestingSimonCocking = createVesting(\n            0x7f438d78a51886B24752941ba98Cc00aBA217495, oneYearAfterIcoEnd, 0, 1 years, 2, true\n        );\n\n        vestingNathanChristian = createVesting(\n            0xfD86B8B016de558Fe39B1697cBf525592A233B2c, oneYearAfterIcoEnd, 0, 1 years, 2, true\n        );\n\n        vestingEdwinVanBerg = createVesting(\n            0x2451A73F35874028217bC833462CCd90c72dbE6D, oneYearAfterIcoEnd, 0, 1 years, 2, true\n        );\n    }\n\n    function allocate(MintingERC20 token) public onlyOwner() {\n        require(tokenInited[token] == false);\n\n        tokenInited[token] = true;\n\n        require(vestingApplicature != address(0));\n        require(vestingSimonCocking != address(0));\n        require(vestingNathanChristian != address(0));\n        require(vestingEdwinVanBerg != address(0));\n\n        uint256 tokenPrecision = uint256(10) ** uint256(token.decimals());\n\n        // allocate funds\n        token.mint(ecosystemIncentive, 200000000 * tokenPrecision);\n        token.mint(marketingAndBounty, 50000000 * tokenPrecision);\n        token.mint(liquidityFund, 50000000 * tokenPrecision);\n        token.mint(treasure, 200000000 * tokenPrecision);\n\n        // allocate funds to founders\n        token.mint(amirShaikh, 73350000 * tokenPrecision);\n        token.mint(sadiqHameed, 36675000 * tokenPrecision);\n        token.mint(omairLatif, 36675000 * tokenPrecision);\n\n        // allocate funds to advisors\n        token.mint(vestingApplicature, 1500000 * tokenPrecision);\n        token.mint(vestingSimonCocking, 750000 * tokenPrecision);\n        token.mint(vestingNathanChristian, 750000 * tokenPrecision);\n        token.mint(vestingEdwinVanBerg, 300000 * tokenPrecision);\n    }\n\n    function createVesting(\n        address _beneficiary, uint256 _start, uint256 _cliff, uint256 _duration, uint256 _periods, bool _revocable\n    ) public onlyOwner() returns (PeriodicTokenVesting) {\n        PeriodicTokenVesting vesting = new PeriodicTokenVesting(\n            _beneficiary, _start, _cliff, _duration, _periods, _revocable\n        );\n\n        vestings.push(vesting);\n\n        VestingCreated(vesting, _beneficiary, _start, _cliff, _duration, _periods, _revocable);\n\n        return vesting;\n    }\n\n    function revokeVesting(PeriodicTokenVesting _vesting, MintingERC20 token) public onlyOwner() {\n        _vesting.revoke(token);\n\n        VestingRevoked(_vesting);\n    }\n}\n\n\nlibrary SafeERC20 {\n  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n    assert(token.transfer(to, value));\n  }\n\n  function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\n    assert(token.transferFrom(from, to, value));\n  }\n\n  function safeApprove(ERC20 token, address spender, uint256 value) internal {\n    assert(token.approve(spender, value));\n  }\n}\n\n\ncontract TokenVesting is Ownable {\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20Basic;\n\n  event Released(uint256 amount);\n  event Revoked();\n\n  // beneficiary of tokens after they are released\n  address public beneficiary;\n\n  uint256 public cliff;\n  uint256 public start;\n  uint256 public duration;\n\n  bool public revocable;\n\n  mapping (address => uint256) public released;\n  mapping (address => bool) public revoked;\n\n  /**\n   * @dev Creates a vesting contract that vests its balance of any ERC20 token to the\n   * _beneficiary, gradually in a linear fashion until _start + _duration. By then all\n   * of the balance will have vested.\n   * @param _beneficiary address of the beneficiary to whom vested tokens are transferred\n   * @param _cliff duration in seconds of the cliff in which tokens will begin to vest\n   * @param _duration duration in seconds of the period in which the tokens will vest\n   * @param _revocable whether the vesting is revocable or not\n   */\n  function TokenVesting(address _beneficiary, uint256 _start, uint256 _cliff, uint256 _duration, bool _revocable) public {\n    require(_beneficiary != address(0));\n    require(_cliff <= _duration);\n\n    beneficiary = _beneficiary;\n    revocable = _revocable;\n    duration = _duration;\n    cliff = _start.add(_cliff);\n    start = _start;\n  }\n\n  /**\n   * @notice Transfers vested tokens to beneficiary.\n   * @param token ERC20 token which is being vested\n   */\n  function release(ERC20Basic token) public {\n    uint256 unreleased = releasableAmount(token);\n\n    require(unreleased > 0);\n\n    released[token] = released[token].add(unreleased);\n\n    token.safeTransfer(beneficiary, unreleased);\n\n    Released(unreleased);\n  }\n\n  /**\n   * @notice Allows the owner to revoke the vesting. Tokens already vested\n   * remain in the contract, the rest are returned to the owner.\n   * @param token ERC20 token which is being vested\n   */\n  function revoke(ERC20Basic token) public onlyOwner {\n    require(revocable);\n    require(!revoked[token]);\n\n    uint256 balance = token.balanceOf(this);\n\n    uint256 unreleased = releasableAmount(token);\n    uint256 refund = balance.sub(unreleased);\n\n    revoked[token] = true;\n\n    token.safeTransfer(owner, refund);\n\n    Revoked();\n  }\n\n  /**\n   * @dev Calculates the amount that has already vested but hasn't been released yet.\n   * @param token ERC20 token which is being vested\n   */\n  function releasableAmount(ERC20Basic token) public view returns (uint256) {\n    return vestedAmount(token).sub(released[token]);\n  }\n\n  /**\n   * @dev Calculates the amount that has already vested.\n   * @param token ERC20 token which is being vested\n   */\n  function vestedAmount(ERC20Basic token) public view returns (uint256) {\n    uint256 currentBalance = token.balanceOf(this);\n    uint256 totalBalance = currentBalance.add(released[token]);\n\n    if (now < cliff) {\n      return 0;\n    } else if (now >= start.add(duration) || revoked[token]) {\n      return totalBalance;\n    } else {\n      return totalBalance.mul(now.sub(start)).div(duration);\n    }\n  }\n}\n\n\ncontract PeriodicTokenVesting is TokenVesting {\n    uint256 public periods;\n\n    function PeriodicTokenVesting(\n        address _beneficiary, uint256 _start, uint256 _cliff, uint256 _duration, uint256 _periods, bool _revocable\n    )\n        public TokenVesting(_beneficiary, _start, _cliff, _duration, _revocable)\n    {\n        periods = _periods;\n    }\n\n    /**\n    * @dev Calculates the amount that has already vested.\n    * @param token ERC20 token which is being vested\n    */\n    function vestedAmount(ERC20Basic token) public view returns (uint256) {\n        uint256 currentBalance = token.balanceOf(this);\n        uint256 totalBalance = currentBalance.add(released[token]);\n\n        if (now < cliff) {\n            return 0;\n        } else if (now >= start.add(duration * periods) || revoked[token]) {\n            return totalBalance;\n        } else {\n\n            uint256 periodTokens = totalBalance.div(periods);\n\n            uint256 periodsOver = now.sub(start).div(duration) + 1;\n\n            if (periodsOver >= periods) {\n                return totalBalance;\n            }\n\n            return periodTokens.mul(periodsOver);\n        }\n    }\n}\n\n\ncontract PrivateSale is SellableToken {\n\n    uint256 public price;\n    uint256 public discount;\n    SellableToken public crowdSale;\n\n    function PrivateSale(\n        address _token,\n        address _etherHolder,\n        uint256 _startTime,\n        uint256 _endTime,\n        uint256 _maxTokenSupply, //14000000000000000000000000\n        uint256 _etherPriceInUSD\n    ) public SellableToken(\n        _token,\n        _etherHolder,\n        _startTime,\n        _endTime,\n        _maxTokenSupply,\n        _etherPriceInUSD\n    ) {\n        price = 24800;// $0.2480 * 10 ^ 5\n        discount = 75;// $75%\n    }\n\n    function changeSalePeriod(uint256 _start, uint256 _end) public onlyOwner {\n        if (_start != 0 && _start < _end) {\n            startTime = _start;\n            endTime = _end;\n        }\n    }\n\n    function isActive() public view returns (bool) {\n        if (soldTokens == maxTokenSupply) {\n            return false;\n        }\n\n        return withinPeriod();\n    }\n\n    function withinPeriod() public view returns (bool) {\n        return block.timestamp >= startTime && block.timestamp <= endTime;\n    }\n\n    function calculateTokensAmount(uint256 _value) public view returns (uint256 tokenAmount, uint256 usdAmount) {\n        if (_value == 0) {\n            return (0, 0);\n        }\n\n        usdAmount = _value.mul(etherPriceInUSD);\n\n        tokenAmount = usdAmount.div(price * (100 - discount) / 100);\n\n        usdAmount = usdAmount.div(uint256(10) ** 18);\n\n        if (usdAmount < minPurchase) {\n            return (0, 0);\n        }\n    }\n\n    function calculateEthersAmount(uint256 _tokens) public view returns (uint256 ethers, uint256 usdAmount) {\n        if (_tokens == 0) {\n            return (0, 0);\n        }\n\n        usdAmount = _tokens.mul((price * (100 - discount) / 100));\n        ethers = usdAmount.div(etherPriceInUSD);\n\n        if (ethers < getMinEthersInvestment()) {\n            return (0, 0);\n        }\n\n        usdAmount = usdAmount.div(uint256(10) ** 18);\n    }\n\n    function getStats(uint256 _ethPerBtc) public view returns (\n        uint256 start,\n        uint256 end,\n        uint256 sold,\n        uint256 maxSupply,\n        uint256 min,\n        uint256 tokensPerEth,\n        uint256 tokensPerBtc\n    ) {\n        start = startTime;\n        end = endTime;\n        sold = soldTokens;\n        maxSupply = maxTokenSupply;\n        min = minPurchase;\n        uint256 usd;\n        (tokensPerEth, usd) = calculateTokensAmount(1 ether);\n        (tokensPerBtc, usd) = calculateTokensAmount(_ethPerBtc);\n    }\n\n    function setCrowdSale(address _crowdSale) public onlyOwner {\n        require(_crowdSale != address(0));\n\n        crowdSale = SellableToken(_crowdSale);\n    }\n\n    function moveUnsoldTokens() public onlyOwner {\n        require(address(crowdSale) != address(0) && now >= endTime && !isActive() && maxTokenSupply > soldTokens);\n\n        crowdSale.updatePreICOMaxTokenSupply(maxTokenSupply.sub(soldTokens));\n        maxTokenSupply = soldTokens;\n    }\n\n    function updatePreICOMaxTokenSupply(uint256) public {\n        require(false);\n    }\n\n    function isTransferAllowed(address, uint256) public view returns (bool) {\n        return false;\n    }\n\n    function buy(address _address, uint256 _value) internal returns (bool) {\n        if (_value == 0 || _address == address(0)) {\n            return false;\n        }\n\n        uint256 tokenAmount;\n        uint256 usdAmount;\n\n        (tokenAmount, usdAmount) = calculateTokensAmount(_value);\n\n        uint256 mintedAmount = mintInternal(_address, tokenAmount);\n        collectedUSD = collectedUSD.add(usdAmount);\n        require(usdAmount > 0 && mintedAmount > 0);\n\n        collectedEthers = collectedEthers.add(_value);\n        etherBalances[_address] = etherBalances[_address].add(_value);\n\n        token.increaseLockedBalance(_address, mintedAmount);\n\n        transferEthers();\n\n        Contribution(_address, _value, tokenAmount);\n        return true;\n    }\n\n    function transferEthers() internal {\n        etherHolder.transfer(this.balance);\n    }\n}",
  "bytecode": "6060604052600d805460a060020a60ff021916905534156200002057600080fd5b60405160208062001a3583398101604052808051600b54909250600091506040805190810160405280600681526020017f47696742697400000000000000000000000000000000000000000000000000008152506012604080519081016040908152600482527f4742544300000000000000000000000000000000000000000000000000000000602083015260038054600160a060020a03191633600160a060020a031617905560009087908790869086908690869086908051908101604052600981527f455243323020302e310000000000000000000000000000000000000000000000602082015260089080516200011f929160200190620002f5565b506009805460ff1916821515179055600186905581156200015c57600154600160a060020a03331660009081526020819052604090205562000179565b600154600160a060020a0330166000908152602081905260409020555b60068580516200018e929160200190620002f5565b506007838051620001a4929160200190620002f5565b50506005805460ff191660ff949094169390931790925550504360045550604090508051908101604052601081527f4d696e74696e67455243323020302e3100000000000000000000000000000000602082015260089080516200020d929160200190620002f5565b505050600160a060020a0333166000908152600a602052604090819020805460ff19166001179055600b9490945550919250829150505190810160405260088082527f4742544320302e31000000000000000000000000000000000000000000000000602083015290805162000288929160200190620002f5565b50600554620002b190633b9aca009060ff16600a0a6401000000006200113f620002bb82021704565b600b55506200039a565b600080831515620002d05760009150620002ee565b50828202828482811515620002e157fe5b0414620002ea57fe5b8091505b5092915050565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f106200033857805160ff191683800117855562000368565b8280016001018555821562000368579182015b82811115620003685782518255916020019190600101906200034b565b50620003769291506200037a565b5090565b6200039791905b8082111562000376576000815560010162000381565b90565b61168b80620003aa6000396000f3006060604052600436106101925763ffffffff60e060020a60003504166306fdde038114610197578063095ea7b31461022157806309f68e9614610257578063176345141461027857806318160ddd1461029d57806318e3d998146102b05780631d1fe108146102c3578063211e28b6146102e557806323b872dd146102fd5780632a6adcec146103255780633092afd514610347578063313ce5671461036657806336a23dbf1461038f57806340c10f19146103a75780635a3b7e42146103c95780635eae177c146103dc57806366188463146103fe57806370a08231146104205780637770bd151461043f5780638da5cb5b1461046e57806395d89b4114610481578063983b2d5614610494578063a9059cbb146104b3578063ade4637a146104d5578063ba1f879f146104e8578063bace5bdb146104fb578063cf3090121461051a578063d0479abc1461052d578063d5abeb0114610543578063d73dd62314610556578063dd62ed3e14610578578063f2fde38b1461059d578063f46eccc4146105bc578063f4b5cbc4146105db575b600080fd5b34156101a257600080fd5b6101aa6105fa565b60405160208082528190810183818151815260200191508051906020019080838360005b838110156101e65780820151838201526020016101ce565b50505050905090810190601f1680156102135780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b341561022c57600080fd5b610243600160a060020a0360043516602435610698565b604051901515815260200160405180910390f35b341561026257600080fd5b610276600160a060020a03600435166106be565b005b341561028357600080fd5b61028b61071d565b60405190815260200160405180910390f35b34156102a857600080fd5b61028b610723565b34156102bb57600080fd5b61028b610729565b34156102ce57600080fd5b61028b600160a060020a036004351660243561072f565b34156102f057600080fd5b6102766004351515610823565b341561030857600080fd5b610243600160a060020a0360043581169060243516604435610851565b341561033057600080fd5b610276600160a060020a036004351660243561088a565b341561035257600080fd5b610276600160a060020a0360043516610934565b341561037157600080fd5b610379610970565b60405160ff909116815260200160405180910390f35b341561039a57600080fd5b6102766004351515610979565b34156103b257600080fd5b61028b600160a060020a03600435166024356109d4565b34156103d457600080fd5b6101aa610ace565b34156103e757600080fd5b610243600160a060020a0360043516602435610b39565b341561040957600080fd5b610243600160a060020a0360043516602435610d20565b341561042b57600080fd5b61028b600160a060020a0360043516610d3d565b341561044a57600080fd5b610452610d58565b604051600160a060020a03909116815260200160405180910390f35b341561047957600080fd5b610452610d67565b341561048c57600080fd5b6101aa610d76565b341561049f57600080fd5b610276600160a060020a0360043516610de1565b34156104be57600080fd5b610243600160a060020a0360043516602435610e20565b34156104e057600080fd5b610243610e41565b34156104f357600080fd5b610452610e62565b341561050657600080fd5b61028b600160a060020a0360043516610e71565b341561052557600080fd5b610243610e83565b341561053857600080fd5b610276600435610e8c565b341561054e57600080fd5b61028b610f19565b341561056157600080fd5b610243600160a060020a0360043516602435610f1f565b341561058357600080fd5b61028b600160a060020a0360043581169060243516610f3c565b34156105a857600080fd5b610276600160a060020a0360043516610f67565b34156105c757600080fd5b610243600160a060020a0360043516611002565b34156105e657600080fd5b610276600160a060020a0360043516611017565b60068054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156106905780601f1061066557610100808354040283529160200191610690565b820191906000526020600020905b81548152906001019060200180831161067357829003601f168201915b505050505081565b600042600e54111515156106ab57600080fd5b6106b583836110d2565b90505b92915050565b60035433600160a060020a039081169116146106d957600080fd5b600160a060020a03811615156106ee57600080fd5b600d805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b60045481565b60015490565b600e5481565b600c54600090600160a060020a03161580159061075a5750600c5433600160a060020a039081169116145b151561076557600080fd5b600e54421161077357600080fd5b600160a060020a03831660009081526020819052604090205482111561079857600080fd5b600160a060020a0383166000908152602081905260409020546107c1908363ffffffff6110f216565b600160a060020a0384166000908152602081905260409020556001546107ed908363ffffffff6110f216565b6001556000600160a060020a0384166000805160206116408339815191528460405190815260200160405180910390a350919050565b60035433600160a060020a0390811691161461083e57600080fd5b6009805460ff1916911515919091179055565b600042600e541115801561086a575061086a8483610b39565b151561087557600080fd5b610880848484611104565b90505b9392505050565b600d54600160a060020a0316158015906108b25750600d5433600160a060020a039081169116145b806108e05750600c54600160a060020a0316158015906108e05750600c5433600160a060020a039081169116145b15156108eb57600080fd5b600160a060020a0382166000908152600f6020526040902054610914908263ffffffff61112516565b600160a060020a039092166000908152600f602052604090209190915550565b60035433600160a060020a0390811691161461094f57600080fd5b600160a060020a03166000908152600a60205260409020805460ff19169055565b60055460ff1681565b60035433600160a060020a0390811691161461099457600080fd5b600d8054911515740100000000000000000000000000000000000000000274ff000000000000000000000000000000000000000019909216919091179055565b600160a060020a0333166000908152600a602052604081205460ff1615156001146109fe57600080fd5b60095460ff16151560011415610a16575060006106b8565b811515610a25575060006106b8565b600b54600154610a3b908463ffffffff61112516565b1115610a49575060006106b8565b600154610a5c908363ffffffff61112516565b600155600160a060020a038316600090815260208190526040902054610a88908363ffffffff61112516565b600160a060020a0384166000818152602081905260408082209390935590916000805160206116408339815191529085905190815260200160405180910390a350919050565b60088054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156106905780601f1061066557610100808354040283529160200191610690565b6000806000806000806000806000610b508b610d3d565b600d5490985074010000000000000000000000000000000000000000900460ff16151560011480610b8057508988105b15610b8e5760009850610d12565b600160a060020a038b166000908152600f6020526040812054975087118015610bc5575086610bc3898c63ffffffff6110f216565b105b15610c6157600e546301e13380810196501580610be157508542105b15610bef5760009850610d12565b610bff428763ffffffff6110f216565b945062278d0085049350600c841115610c1757600c93505b600c87049250610c2d838563ffffffff61113f16565b9150610c3f878363ffffffff6110f216565b905080610c52898c63ffffffff6110f216565b1015610c615760009850610d12565b600e5442108015610c7c5750600c54600160a060020a031615155b8015610cff5750600c54600160a060020a0316635eae177c8c8c60006040516020015260405160e060020a63ffffffff8516028152600160a060020a0390921660048301526024820152604401602060405180830381600087803b1515610ce257600080fd5b6102c65a03f11515610cf357600080fd5b50505060405180511590505b15610d0d5760009850610d12565b600198505b505050505050505092915050565b600042600e5411151515610d3357600080fd5b6106b5838361116a565b600160a060020a031660009081526020819052604090205490565b600c54600160a060020a031681565b600354600160a060020a031681565b60078054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156106905780601f1061066557610100808354040283529160200191610690565b60035433600160a060020a03908116911614610dfc57600080fd5b600160a060020a03166000908152600a60205260409020805460ff19166001179055565b6000610e2c3383610b39565b1515610e3757600080fd5b6106b5838361118a565b600d5474010000000000000000000000000000000000000000900460ff1681565b600d54600160a060020a031681565b600f6020526000908152604090205481565b60095460ff1681565b600c54600160a060020a031615801590610eb45750600c5433600160a060020a039081169116145b1515610ebf57600080fd5b600e544211610ecd57600080fd5b600b54610ee0908263ffffffff6110f216565b600b557f7174e2dc81bf5de8f9bf1dd00b511763f2ffb109c06de0f447be45348cc75af58160405190815260200160405180910390a150565b600b5481565b600042600e5411151515610f3257600080fd5b6106b583836111a7565b600160a060020a03918216600090815260026020908152604080832093909416825291909152205490565b60035433600160a060020a03908116911614610f8257600080fd5b600160a060020a0381161515610f9757600080fd5b600354600160a060020a0380831691167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a36003805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b600a6020526000908152604090205460ff1681565b60035433600160a060020a0390811691161461103257600080fd5b600160a060020a038116151561104757600080fd5b600c805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a03838116919091179182905516633197cbb66000604051602001526040518163ffffffff1660e060020a028152600401602060405180830381600087803b15156110b257600080fd5b6102c65a03f115156110c357600080fd5b5050506040518051600e555050565b60095460009060ff16156110e8575060006106b8565b6106b583836111c7565b6000828211156110fe57fe5b50900390565b60095460009060ff161561111a57506000610883565b610880848484611233565b60008282018381101561113457fe5b8091505b5092915050565b6000808315156111525760009150611138565b5082820282848281151561116257fe5b041461113457fe5b60095460009060ff1615611180575060006106b8565b6106b583836113a1565b60095460009060ff161561119d57600080fd5b6106b5838361149b565b60095460009060ff16156111bd575060006106b8565b6106b5838361159b565b600160a060020a03338116600081815260026020908152604080832094871680845294909152808220859055909291907f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b9259085905190815260200160405180910390a350600192915050565b6000600160a060020a038316151561124a57600080fd5b600160a060020a03841660009081526020819052604090205482111561126f57600080fd5b600160a060020a03808516600090815260026020908152604080832033909416835292905220548211156112a257600080fd5b600160a060020a0384166000908152602081905260409020546112cb908363ffffffff6110f216565b600160a060020a038086166000908152602081905260408082209390935590851681522054611300908363ffffffff61112516565b600160a060020a0380851660009081526020818152604080832094909455878316825260028152838220339093168252919091522054611346908363ffffffff6110f216565b600160a060020a03808616600081815260026020908152604080832033861684529091529081902093909355908516916000805160206116408339815191529085905190815260200160405180910390a35060019392505050565b600160a060020a033381166000908152600260209081526040808320938616835292905290812054808311156113fe57600160a060020a033381166000908152600260209081526040808320938816835292905290812055611435565b61140e818463ffffffff6110f216565b600160a060020a033381166000908152600260209081526040808320938916835292905220555b600160a060020a0333811660008181526002602090815260408083209489168084529490915290819020547f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925915190815260200160405180910390a35060019392505050565b6000600160a060020a03831615156114b257600080fd5b600160a060020a0333166000908152602081905260409020548211156114d757600080fd5b600160a060020a033316600090815260208190526040902054611500908363ffffffff6110f216565b600160a060020a033381166000908152602081905260408082209390935590851681522054611535908363ffffffff61112516565b60008085600160a060020a0316600160a060020a031681526020019081526020016000208190555082600160a060020a031633600160a060020a03166000805160206116408339815191528460405190815260200160405180910390a350600192915050565b600160a060020a0333811660009081526002602090815260408083209386168352929052908120546115d3908363ffffffff61112516565b600160a060020a0333811660008181526002602090815260408083209489168084529490915290819020849055919290917f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92591905190815260200160405180910390a3506001929150505600ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa165627a7a72305820952cb2b31753a4a8295f98061add2ace92fba423d54132081121701fca0dfcb600290000000000000000000000000000000000000000000000000000000000000000",
  "constructorArguments": "0000000000000000000000000000000000000000000000000000000000000000"
}