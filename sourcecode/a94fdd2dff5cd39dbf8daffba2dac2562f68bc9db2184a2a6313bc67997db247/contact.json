{
  "address": "0x69726ae4d92f48b97405d4e2785e4006c208a28a",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "KeyRewardPool",
  "compilerVersion": "v0.4.18+commit.9cf6e910",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2018-03-09\n*/\n\npragma solidity 0.4.18;\n\n//import \"ds-token/token.sol\";\n    //import \"ds-stop/stop.sol\";\n        //import \"ds-auth/auth.sol\";\n        //import \"ds-note/note.sol\";\n    //import \"./base.sol\";\n        //import \"erc20/erc20.sol\";\n        //import \"ds-math/math.sol\";\n\n//import \"ds-math/math.sol\";\ncontract DSMath {\n    \n    /*\n    standard uint256 functions\n     */\n\n    function add(uint256 x, uint256 y) constant internal returns (uint256 z) {\n        assert((z = x + y) >= x);\n    }\n\n    function sub(uint256 x, uint256 y) constant internal returns (uint256 z) {\n        assert((z = x - y) <= x);\n    }\n\n    function mul(uint256 x, uint256 y) constant internal returns (uint256 z) {\n        z = x * y;\n        assert(x == 0 || z / x == y);\n    }\n\n    function div(uint256 x, uint256 y) constant internal returns (uint256 z) {\n        z = x / y;\n    }\n\n    function min(uint256 x, uint256 y) constant internal returns (uint256 z) {\n        return x <= y ? x : y;\n    }\n    function max(uint256 x, uint256 y) constant internal returns (uint256 z) {\n        return x >= y ? x : y;\n    }\n\n    /*\n    uint128 functions (h is for half)\n     */\n\n\n    function hadd(uint128 x, uint128 y) constant internal returns (uint128 z) {\n        assert((z = x + y) >= x);\n    }\n\n    function hsub(uint128 x, uint128 y) constant internal returns (uint128 z) {\n        assert((z = x - y) <= x);\n    }\n\n    function hmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n        z = x * y;\n        assert(x == 0 || z / x == y);\n    }\n\n    function hdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n        z = x / y;\n    }\n\n    function hmin(uint128 x, uint128 y) constant internal returns (uint128 z) {\n        return x <= y ? x : y;\n    }\n    function hmax(uint128 x, uint128 y) constant internal returns (uint128 z) {\n        return x >= y ? x : y;\n    }\n\n\n    /*\n    int256 functions\n     */\n\n    function imin(int256 x, int256 y) constant internal returns (int256 z) {\n        return x <= y ? x : y;\n    }\n    function imax(int256 x, int256 y) constant internal returns (int256 z) {\n        return x >= y ? x : y;\n    }\n\n    /*\n    WAD math\n     */\n\n    uint128 constant WAD = 10 ** 18;\n\n    function wadd(uint128 x, uint128 y) constant internal returns (uint128) {\n        return hadd(x, y);\n    }\n\n    function wsub(uint128 x, uint128 y) constant internal returns (uint128) {\n        return hsub(x, y);\n    }\n\n    function wmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n        z = cast((uint256(x) * y + WAD / 2) / WAD);\n    }\n\n    function wdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n        z = cast((uint256(x) * WAD + y / 2) / y);\n    }\n\n    function wmin(uint128 x, uint128 y) constant internal returns (uint128) {\n        return hmin(x, y);\n    }\n    function wmax(uint128 x, uint128 y) constant internal returns (uint128) {\n        return hmax(x, y);\n    }\n\n    /*\n    RAY math\n     */\n\n    uint128 constant RAY = 10 ** 27;\n\n    function radd(uint128 x, uint128 y) constant internal returns (uint128) {\n        return hadd(x, y);\n    }\n\n    function rsub(uint128 x, uint128 y) constant internal returns (uint128) {\n        return hsub(x, y);\n    }\n\n    function rmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n        z = cast((uint256(x) * y + RAY / 2) / RAY);\n    }\n\n    function rdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n        z = cast((uint256(x) * RAY + y / 2) / y);\n    }\n\n    function rpow(uint128 x, uint64 n) constant internal returns (uint128 z) {\n        // This famous algorithm is called \"exponentiation by squaring\"\n        // and calculates x^n with x as fixed-point and n as regular unsigned.\n        //\n        // It's O(log n), instead of O(n) for naive repeated multiplication.\n        //\n        // These facts are why it works:\n        //\n        //  If n is even, then x^n = (x^2)^(n/2).\n        //  If n is odd,  then x^n = x * x^(n-1),\n        //   and applying the equation for even x gives\n        //    x^n = x * (x^2)^((n-1) / 2).\n        //\n        //  Also, EVM division is flooring and\n        //    floor[(n-1) / 2] = floor[n / 2].\n\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n\n    function rmin(uint128 x, uint128 y) constant internal returns (uint128) {\n        return hmin(x, y);\n    }\n    function rmax(uint128 x, uint128 y) constant internal returns (uint128) {\n        return hmax(x, y);\n    }\n\n    function cast(uint256 x) constant internal returns (uint128 z) {\n        assert((z = uint128(x)) == x);\n    }\n\n}\n\n//import \"erc20/erc20.sol\";\ncontract ERC20 {\n    function totalSupply() constant returns (uint supply);\n    function balanceOf( address who ) constant returns (uint value);\n    function allowance( address owner, address spender ) constant returns (uint _allowance);\n\n    function transfer( address to, uint value) returns (bool ok);\n    function transferFrom( address from, address to, uint value) returns (bool ok);\n    function approve( address spender, uint value ) returns (bool ok);\n\n    event Transfer( address indexed from, address indexed to, uint value);\n    event Approval( address indexed owner, address indexed spender, uint value);\n}\n\n//import \"./base.sol\";\ncontract DSTokenBase is ERC20, DSMath {\n    uint256                                            _supply;\n    mapping (address => uint256)                       _balances;\n    mapping (address => mapping (address => uint256))  _approvals;\n    \n    function DSTokenBase(uint256 supply) {\n        _balances[msg.sender] = supply;\n        _supply = supply;\n    }\n    \n    function totalSupply() constant returns (uint256) {\n        return _supply;\n    }\n    function balanceOf(address src) constant returns (uint256) {\n        return _balances[src];\n    }\n    function allowance(address src, address guy) constant returns (uint256) {\n        return _approvals[src][guy];\n    }\n    \n    function transfer(address dst, uint wad) returns (bool) {\n        assert(_balances[msg.sender] >= wad);\n        \n        _balances[msg.sender] = sub(_balances[msg.sender], wad);\n        _balances[dst] = add(_balances[dst], wad);\n        \n        Transfer(msg.sender, dst, wad);\n        \n        return true;\n    }\n    \n    function transferFrom(address src, address dst, uint wad) returns (bool) {\n        assert(_balances[src] >= wad);\n        assert(_approvals[src][msg.sender] >= wad);\n        \n        _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);\n        _balances[src] = sub(_balances[src], wad);\n        _balances[dst] = add(_balances[dst], wad);\n        \n        Transfer(src, dst, wad);\n        \n        return true;\n    }\n    \n    function approve(address guy, uint256 wad) returns (bool) {\n        _approvals[msg.sender][guy] = wad;\n        \n        Approval(msg.sender, guy, wad);\n        \n        return true;\n    }\n\n}\n\n//import \"ds-auth/auth.sol\";\ncontract DSAuthority {\n    function canCall(\n        address src, address dst, bytes4 sig\n    ) constant returns (bool);\n}\n\ncontract DSAuthEvents {\n    event LogSetAuthority (address indexed authority);\n    event LogSetOwner     (address indexed owner);\n}\n\ncontract DSAuth is DSAuthEvents {\n    DSAuthority  public  authority;\n    address      public  owner;\n\n    function DSAuth() {\n        owner = msg.sender;\n        LogSetOwner(msg.sender);\n    }\n\n    function setOwner(address owner_)\n        auth\n    {\n        owner = owner_;\n        LogSetOwner(owner);\n    }\n\n    function setAuthority(DSAuthority authority_)\n        auth\n    {\n        authority = authority_;\n        LogSetAuthority(authority);\n    }\n\n    modifier auth {\n        assert(isAuthorized(msg.sender, msg.sig));\n        _;\n    }\n\n    function isAuthorized(address src, bytes4 sig) internal returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else if (authority == DSAuthority(0)) {\n            return false;\n        } else {\n            return authority.canCall(src, this, sig);\n        }\n    }\n}\n\n//import \"ds-note/note.sol\";\ncontract DSNote {\n    event LogNote(\n        bytes4   indexed  sig,\n        address  indexed  guy,\n        bytes32  indexed  foo,\n        bytes32  indexed  bar,\n        uint              wad,\n        bytes             fax\n    ) anonymous;\n\n    modifier note {\n        bytes32 foo;\n        bytes32 bar;\n\n        assembly {\n            foo := calldataload(4)\n            bar := calldataload(36)\n        }\n\n        LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\n\n        _;\n    }\n}\n\n//import \"ds-stop/stop.sol\";\ncontract DSStop is DSNote, DSAuth {\n\n    bool public stopped;\n\n    modifier stoppable {\n        assert (!stopped);\n        _;\n    }\n    function stop() auth note {\n        stopped = true;\n    }\n    function start() auth note {\n        stopped = false;\n    }\n\n}\n\n\n\n//import \"ds-token/token.sol\";\ncontract DSToken is DSTokenBase(0), DSStop {\n\n    bytes32  public  symbol;\n    uint256  public  decimals = 18; // standard token precision. override to customize\n\n    function DSToken(bytes32 symbol_) {\n        symbol = symbol_;\n    }\n\n    function transfer(address dst, uint wad) stoppable note returns (bool) {\n        return super.transfer(dst, wad);\n    }\n    function transferFrom(\n        address src, address dst, uint wad\n    ) stoppable note returns (bool) {\n        return super.transferFrom(src, dst, wad);\n    }\n    function approve(address guy, uint wad) stoppable note returns (bool) {\n        return super.approve(guy, wad);\n    }\n\n    function push(address dst, uint128 wad) returns (bool) {\n        return transfer(dst, wad);\n    }\n    function pull(address src, uint128 wad) returns (bool) {\n        return transferFrom(src, msg.sender, wad);\n    }\n\n    function mint(uint128 wad) auth stoppable note {\n        _balances[msg.sender] = add(_balances[msg.sender], wad);\n        _supply = add(_supply, wad);\n    }\n    function burn(uint128 wad) auth stoppable note {\n        _balances[msg.sender] = sub(_balances[msg.sender], wad);\n        _supply = sub(_supply, wad);\n    }\n\n    // Optional token name\n\n    bytes32   public  name = \"\";\n    \n    function setName(bytes32 name_) auth {\n        name = name_;\n    }\n\n}\n\n\n\n\ncontract KeyRewardPool is DSMath, DSNote{\n\n    DSToken public key;\n    uint public rewardStartTime;\n\n    uint constant public yearlyRewardPercentage = 10; // 10% of remaining tokens\n    uint public totalRewardThisYear;\n    uint public collectedTokens;\n    address public withdrawer;\n    address public owner;\n    bool public paused;\n\n    event TokensWithdrawn(address indexed _holder, uint _amount);\n    event LogSetWithdrawer(address indexed _withdrawer);\n    event LogSetOwner(address indexed _owner);\n\n    modifier onlyWithdrawer {\n        require(msg.sender == withdrawer);\n        _;\n    }\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    modifier notPaused {\n        require(!paused);\n        _;\n    }\n\n    function KeyRewardPool(uint _rewardStartTime, address _key, address _withdrawer) public{\n        require(_rewardStartTime != 0 );\n        require(_key != address(0) );\n        require(_withdrawer != address(0) );\n        uint _time = time();\n        require(_rewardStartTime > _time - 364 days);\n\n        rewardStartTime = _rewardStartTime;\n        key = DSToken(_key);\n        withdrawer = _withdrawer;\n        owner = msg.sender;\n        paused = false;\n    }\n\n    // @notice call this method to extract the tokens\n    function collectToken() public notPaused onlyWithdrawer{\n        uint _time = time();\n        require(_time > rewardStartTime);\n\n        var _key = key;  // create a in memory variable for storage variable will save gas usage.\n\n\n        uint balance = _key.balanceOf(address(this));\n        uint total = add(collectedTokens, balance);\n\n        uint remainingTokens = total;\n\n        uint yearCount = yearFor(_time);\n\n        for(uint i = 0; i < yearCount; i++) {\n            remainingTokens =  div( mul(remainingTokens, 100 - yearlyRewardPercentage), 100);\n        }\n        //\n        totalRewardThisYear =  div( mul(remainingTokens, yearlyRewardPercentage), 100);\n\n        // the reward will be increasing linearly in one year.\n        uint canExtractThisYear = div( mul(totalRewardThisYear, (_time - rewardStartTime)  % 365 days), 365 days);\n\n        uint canExtract = canExtractThisYear + (total - remainingTokens);\n\n        canExtract = sub(canExtract, collectedTokens);\n\n        if(canExtract > balance) {\n            canExtract = balance;\n        }\n\n        \n        collectedTokens = add(collectedTokens, canExtract);\n\n        assert(_key.transfer(withdrawer, canExtract)); // Fix potential re-entry bug.\n        TokensWithdrawn(withdrawer, canExtract);\n    }\n\n\n    function yearFor(uint timestamp) public constant returns(uint) {\n        return timestamp < rewardStartTime\n            ? 0\n            : sub(timestamp, rewardStartTime) / (365 days);\n    }\n\n    // overrideable for easy testing\n    function time() public constant returns (uint) {\n        return now;\n    }\n\n    function setWithdrawer(address _withdrawer) public onlyOwner {\n        withdrawer = _withdrawer;\n        LogSetWithdrawer(_withdrawer);\n    }\n\n    function setOwner(address _owner) public onlyOwner {\n        owner = _owner;\n        LogSetOwner(_owner);\n    }\n\n\n    function pauseCollectToken() public onlyOwner {\n        paused = true;\n    }\n\n    function resumeCollectToken() public onlyOwner {\n        paused = false;\n    }\n\n    // @notice This method can be used by the controller to extract mistakenly\n    //  sent tokens to this contract.\n    // @param dst The address that will be receiving the tokens\n    // @param wad The amount of tokens to transfer\n    // @param _token The address of the token contract that you want to recover\n    function transferTokens(address dst, uint wad, address _token) public onlyWithdrawer {\n        require( _token != address(key));\n        if (wad > 0) {\n            ERC20 token = ERC20(_token);\n            token.transfer(dst, wad);\n        }\n    }\n\n    \n}",
  "bytecode": "6060604052341561000f57600080fd5b60405160608061092183398101604052808051919060200180519190602001805191506000905083151561004257600080fd5b600160a060020a038316151561005757600080fd5b600160a060020a038216151561006c57600080fd5b6100816401000000006103656100e982021704565b90506301dfe1ff198101841161009657600080fd5b5060019290925560008054600160a060020a0319908116600160a060020a03938416179091556004805482169383169390931790925560058054909216339091161760a060020a60ff02191690556100ed565b4290565b610825806100fc6000396000f3006060604052600436106100cc5763ffffffff60e060020a6000350416630d174c2481146100d15780630e4aed3f146100f257806313af40351461011757806316ada547146101365780632cc138be146101495780633943380c1461015c5780634af350eb1461018b5780634c610ba4146101b45780635c975abb146101c75780636f8c9575146101ee578063748b659d14610204578063787e9137146102175780638da5cb5b1461022a578063cc4cc05f1461023d578063cdc1842414610250578063cf7b38a214610263575b600080fd5b34156100dc57600080fd5b6100f0600160a060020a0360043516610276565b005b34156100fd57600080fd5b6101056102eb565b60405190815260200160405180910390f35b341561012257600080fd5b6100f0600160a060020a03600435166102f0565b341561014157600080fd5b610105610365565b341561015457600080fd5b610105610369565b341561016757600080fd5b61016f61036f565b604051600160a060020a03909116815260200160405180910390f35b341561019657600080fd5b6100f0600160a060020a03600435811690602435906044351661037e565b34156101bf57600080fd5b610105610441565b34156101d257600080fd5b6101da610447565b604051901515815260200160405180910390f35b34156101f957600080fd5b610105600435610468565b341561020f57600080fd5b6100f061049c565b341561022257600080fd5b6101056104ee565b341561023557600080fd5b61016f6104f4565b341561024857600080fd5b6100f0610503565b341561025b57600080fd5b61016f61075e565b341561026e57600080fd5b6100f061076d565b60055433600160a060020a0390811691161461029157600080fd5b6004805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0383169081179091557f91ea294e4187e15075dc6da5e9abb3161ca1a608c538e1a1c6528fc644b1b6f560405160405180910390a250565b600a81565b60055433600160a060020a0390811691161461030b57600080fd5b6005805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0383169081179091557fce241d7ca1f669fee44b6fc00b8eba2df3bb514eed0f6f668f8f89096e81ed9460405160405180910390a250565b4290565b60015481565b600054600160a060020a031681565b60045460009033600160a060020a0390811691161461039c57600080fd5b600054600160a060020a03838116911614156103b757600080fd5b600083111561043b575080600160a060020a03811663a9059cbb858560006040516020015260405160e060020a63ffffffff8516028152600160a060020a0390921660048301526024820152604401602060405180830381600087803b151561041f57600080fd5b6102c65a03f1151561043057600080fd5b505050604051805150505b50505050565b60025481565b60055474010000000000000000000000000000000000000000900460ff1681565b60006001548210610493576301e13380610484836001546107a8565b81151561048d57fe5b04610496565b60005b92915050565b60055433600160a060020a039081169116146104b757600080fd5b6005805474ff0000000000000000000000000000000000000000191674010000000000000000000000000000000000000000179055565b60035481565b600554600160a060020a031681565b6000806000806000806000806000600560149054906101000a900460ff1615151561052d57600080fd5b60045433600160a060020a0390811691161461054857600080fd5b610550610365565b600154909950891161056157600080fd5b60008054600160a060020a0316985088906370a082319030906040516020015260405160e060020a63ffffffff8416028152600160a060020a039091166004820152602401602060405180830381600087803b15156105bf57600080fd5b6102c65a03f115156105d057600080fd5b5050506040518051905096506105e8600354886107b5565b95508594506105f689610468565b9350600092505b838310156106275761061a61061386605a6107c2565b60646107e4565b94506001909201916105fd565b61063561061386600a6107c2565b600281905560015461065d91610653916301e13380908d03066107c2565b6301e133806107e4565b915084860382019050610672816003546107a8565b90508681111561067f5750855b61068b600354826107b5565b600355600454600160a060020a03808a169163a9059cbb91168360006040516020015260405160e060020a63ffffffff8516028152600160a060020a0390921660048301526024820152604401602060405180830381600087803b15156106f157600080fd5b6102c65a03f1151561070257600080fd5b50505060405180519050151561071457fe5b600454600160a060020a03167f6352c5382c4a4578e712449ca65e83cdb392d045dfcf1cad9615189db2da244b8260405190815260200160405180910390a2505050505050505050565b600454600160a060020a031681565b60055433600160a060020a0390811691161461078857600080fd5b6005805474ff000000000000000000000000000000000000000019169055565b8082038281111561049657fe5b8082018281101561049657fe5b8181028215806107dc57508183828115156107d957fe5b04145b151561049657fe5b600081838115156107f157fe5b0493925050505600a165627a7a72305820193c3d04ae865d1275958b81bdf39b228a8c5c737ec047ad08424ba721688d240029000000000000000000000000000000000000000000000000000000005a9699c00000000000000000000000004cd988afbad37289baaf53c13e98e2bd46aaea8c0000000000000000000000002ffaf50adbff4c4eb382b0407ac4f9ceb118eaca",
  "constructorArguments": "000000000000000000000000000000000000000000000000000000005a9699c00000000000000000000000004cd988afbad37289baaf53c13e98e2bd46aaea8c0000000000000000000000002ffaf50adbff4c4eb382b0407ac4f9ceb118eaca"
}