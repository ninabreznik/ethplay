{
  "address": "0x3D32f1404deacE2A43B08211E4662275045b495b",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "FeePool",
  "compilerVersion": "v0.4.25+commit.59dbf8f1",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2019-05-28\n*/\n\n/* ===============================================\n* Flattened with Solidifier by Coinage\n* \n* https://solidifier.coina.ge\n* ===============================================\n*/\n\n\n/*\n-----------------------------------------------------------------\nFILE INFORMATION\n-----------------------------------------------------------------\n\nfile:       Owned.sol\nversion:    1.1\nauthor:     Anton Jurisevic\n            Dominic Romanowski\n\ndate:       2018-2-26\n\n-----------------------------------------------------------------\nMODULE DESCRIPTION\n-----------------------------------------------------------------\n\nAn Owned contract, to be inherited by other contracts.\nRequires its owner to be explicitly set in the constructor.\nProvides an onlyOwner access modifier.\n\nTo change owner, the current owner must nominate the next owner,\nwho then has to accept the nomination. The nomination can be\ncancelled before it is accepted by the new owner by having the\nprevious owner change the nomination (setting it to 0).\n\n-----------------------------------------------------------------\n*/\n\npragma solidity 0.4.25;\n\n/**\n * @title A contract with an owner.\n * @notice Contract ownership can be transferred by first nominating the new owner,\n * who must then accept the ownership, which prevents accidental incorrect ownership transfers.\n */\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    /**\n     * @dev Owned Constructor\n     */\n    constructor(address _owner)\n        public\n    {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    /**\n     * @notice Nominate a new owner of this contract.\n     * @dev Only the current owner may nominate a new owner.\n     */\n    function nominateNewOwner(address _owner)\n        external\n        onlyOwner\n    {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    /**\n     * @notice Accept the nomination to be owner.\n     */\n    function acceptOwnership()\n        external\n    {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner\n    {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n        _;\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n\n\n/*\n-----------------------------------------------------------------\nFILE INFORMATION\n-----------------------------------------------------------------\n\nfile:       Proxy.sol\nversion:    1.3\nauthor:     Anton Jurisevic\n\ndate:       2018-05-29\n\n-----------------------------------------------------------------\nMODULE DESCRIPTION\n-----------------------------------------------------------------\n\nA proxy contract that, if it does not recognise the function\nbeing called on it, passes all value and call data to an\nunderlying target contract.\n\nThis proxy has the capacity to toggle between DELEGATECALL\nand CALL style proxy functionality.\n\nThe former executes in the proxy's context, and so will preserve \nmsg.sender and store data at the proxy address. The latter will not.\nTherefore, any contract the proxy wraps in the CALL style must\nimplement the Proxyable interface, in order that it can pass msg.sender\ninto the underlying contract as the state parameter, messageSender.\n\n-----------------------------------------------------------------\n*/\n\n\ncontract Proxy is Owned {\n\n    Proxyable public target;\n    bool public useDELEGATECALL;\n\n    constructor(address _owner)\n        Owned(_owner)\n        public\n    {}\n\n    function setTarget(Proxyable _target)\n        external\n        onlyOwner\n    {\n        target = _target;\n        emit TargetUpdated(_target);\n    }\n\n    function setUseDELEGATECALL(bool value) \n        external\n        onlyOwner\n    {\n        useDELEGATECALL = value;\n    }\n\n    function _emit(bytes callData, uint numTopics, bytes32 topic1, bytes32 topic2, bytes32 topic3, bytes32 topic4)\n        external\n        onlyTarget\n    {\n        uint size = callData.length;\n        bytes memory _callData = callData;\n\n        assembly {\n            /* The first 32 bytes of callData contain its length (as specified by the abi). \n             * Length is assumed to be a uint256 and therefore maximum of 32 bytes\n             * in length. It is also leftpadded to be a multiple of 32 bytes.\n             * This means moving call_data across 32 bytes guarantees we correctly access\n             * the data itself. */\n            switch numTopics\n            case 0 {\n                log0(add(_callData, 32), size)\n            } \n            case 1 {\n                log1(add(_callData, 32), size, topic1)\n            }\n            case 2 {\n                log2(add(_callData, 32), size, topic1, topic2)\n            }\n            case 3 {\n                log3(add(_callData, 32), size, topic1, topic2, topic3)\n            }\n            case 4 {\n                log4(add(_callData, 32), size, topic1, topic2, topic3, topic4)\n            }\n        }\n    }\n\n    function()\n        external\n        payable\n    {\n        if (useDELEGATECALL) {\n            assembly {\n                /* Copy call data into free memory region. */\n                let free_ptr := mload(0x40)\n                calldatacopy(free_ptr, 0, calldatasize)\n\n                /* Forward all gas and call data to the target contract. */\n                let result := delegatecall(gas, sload(target_slot), free_ptr, calldatasize, 0, 0)\n                returndatacopy(free_ptr, 0, returndatasize)\n\n                /* Revert if the call failed, otherwise return the result. */\n                if iszero(result) { revert(free_ptr, returndatasize) }\n                return(free_ptr, returndatasize)\n            }\n        } else {\n            /* Here we are as above, but must send the messageSender explicitly \n             * since we are using CALL rather than DELEGATECALL. */\n            target.setMessageSender(msg.sender);\n            assembly {\n                let free_ptr := mload(0x40)\n                calldatacopy(free_ptr, 0, calldatasize)\n\n                /* We must explicitly forward ether to the underlying contract as well. */\n                let result := call(gas, sload(target_slot), callvalue, free_ptr, calldatasize, 0, 0)\n                returndatacopy(free_ptr, 0, returndatasize)\n\n                if iszero(result) { revert(free_ptr, returndatasize) }\n                return(free_ptr, returndatasize)\n            }\n        }\n    }\n\n    modifier onlyTarget {\n        require(Proxyable(msg.sender) == target, \"Must be proxy target\");\n        _;\n    }\n\n    event TargetUpdated(Proxyable newTarget);\n}\n\n\n/*\n-----------------------------------------------------------------\nFILE INFORMATION\n-----------------------------------------------------------------\n\nfile:       Proxyable.sol\nversion:    1.1\nauthor:     Anton Jurisevic\n\ndate:       2018-05-15\n\nchecked:    Mike Spain\napproved:   Samuel Brooks\n\n-----------------------------------------------------------------\nMODULE DESCRIPTION\n-----------------------------------------------------------------\n\nA proxyable contract that works hand in hand with the Proxy contract\nto allow for anyone to interact with the underlying contract both\ndirectly and through the proxy.\n\n-----------------------------------------------------------------\n*/\n\n\n// This contract should be treated like an abstract contract\ncontract Proxyable is Owned {\n    /* The proxy this contract exists behind. */\n    Proxy public proxy;\n\n    /* The caller of the proxy, passed through to this contract.\n     * Note that every function using this member must apply the onlyProxy or\n     * optionalProxy modifiers, otherwise their invocations can use stale values. */ \n    address messageSender; \n\n    constructor(address _proxy, address _owner)\n        Owned(_owner)\n        public\n    {\n        proxy = Proxy(_proxy);\n        emit ProxyUpdated(_proxy);\n    }\n\n    function setProxy(address _proxy)\n        external\n        onlyOwner\n    {\n        proxy = Proxy(_proxy);\n        emit ProxyUpdated(_proxy);\n    }\n\n    function setMessageSender(address sender)\n        external\n        onlyProxy\n    {\n        messageSender = sender;\n    }\n\n    modifier onlyProxy {\n        require(Proxy(msg.sender) == proxy, \"Only the proxy can call this function\");\n        _;\n    }\n\n    modifier optionalProxy\n    {\n        if (Proxy(msg.sender) != proxy) {\n            messageSender = msg.sender;\n        }\n        _;\n    }\n\n    modifier optionalProxy_onlyOwner\n    {\n        if (Proxy(msg.sender) != proxy) {\n            messageSender = msg.sender;\n        }\n        require(messageSender == owner, \"This action can only be performed by the owner\");\n        _;\n    }\n\n    event ProxyUpdated(address proxyAddress);\n}\n\n\n/*\n-----------------------------------------------------------------\nFILE INFORMATION\n-----------------------------------------------------------------\n\nfile:       SelfDestructible.sol\nversion:    1.2\nauthor:     Anton Jurisevic\n\ndate:       2018-05-29\n\n-----------------------------------------------------------------\nMODULE DESCRIPTION\n-----------------------------------------------------------------\n\nThis contract allows an inheriting contract to be destroyed after\nits owner indicates an intention and then waits for a period\nwithout changing their mind. All ether contained in the contract\nis forwarded to a nominated beneficiary upon destruction.\n\n-----------------------------------------------------------------\n*/\n\n\n/**\n * @title A contract that can be destroyed by its owner after a delay elapses.\n */\ncontract SelfDestructible is Owned {\n    \n    uint public initiationTime;\n    bool public selfDestructInitiated;\n    address public selfDestructBeneficiary;\n    uint public constant SELFDESTRUCT_DELAY = 4 weeks;\n\n    /**\n     * @dev Constructor\n     * @param _owner The account which controls this contract.\n     */\n    constructor(address _owner)\n        Owned(_owner)\n        public\n    {\n        require(_owner != address(0), \"Owner must not be the zero address\");\n        selfDestructBeneficiary = _owner;\n        emit SelfDestructBeneficiaryUpdated(_owner);\n    }\n\n    /**\n     * @notice Set the beneficiary address of this contract.\n     * @dev Only the contract owner may call this. The provided beneficiary must be non-null.\n     * @param _beneficiary The address to pay any eth contained in this contract to upon self-destruction.\n     */\n    function setSelfDestructBeneficiary(address _beneficiary)\n        external\n        onlyOwner\n    {\n        require(_beneficiary != address(0), \"Beneficiary must not be the zero address\");\n        selfDestructBeneficiary = _beneficiary;\n        emit SelfDestructBeneficiaryUpdated(_beneficiary);\n    }\n\n    /**\n     * @notice Begin the self-destruction counter of this contract.\n     * Once the delay has elapsed, the contract may be self-destructed.\n     * @dev Only the contract owner may call this.\n     */\n    function initiateSelfDestruct()\n        external\n        onlyOwner\n    {\n        initiationTime = now;\n        selfDestructInitiated = true;\n        emit SelfDestructInitiated(SELFDESTRUCT_DELAY);\n    }\n\n    /**\n     * @notice Terminate and reset the self-destruction timer.\n     * @dev Only the contract owner may call this.\n     */\n    function terminateSelfDestruct()\n        external\n        onlyOwner\n    {\n        initiationTime = 0;\n        selfDestructInitiated = false;\n        emit SelfDestructTerminated();\n    }\n\n    /**\n     * @notice If the self-destruction delay has elapsed, destroy this contract and\n     * remit any ether it owns to the beneficiary address.\n     * @dev Only the contract owner may call this.\n     */\n    function selfDestruct()\n        external\n        onlyOwner\n    {\n        require(selfDestructInitiated, \"Self destruct has not yet been initiated\");\n        require(initiationTime + SELFDESTRUCT_DELAY < now, \"Self destruct delay has not yet elapsed\");\n        address beneficiary = selfDestructBeneficiary;\n        emit SelfDestructed(beneficiary);\n        selfdestruct(beneficiary);\n    }\n\n    event SelfDestructTerminated();\n    event SelfDestructed(address beneficiary);\n    event SelfDestructInitiated(uint selfDestructDelay);\n    event SelfDestructBeneficiaryUpdated(address newBeneficiary);\n}\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, reverts on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b);\n\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n  /**\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  /**\n  * @dev Adds two numbers, reverts on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a);\n\n    return c;\n  }\n\n  /**\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n  * reverts when dividing by zero.\n  */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0);\n    return a % b;\n  }\n}\n\n\n/*\n\n-----------------------------------------------------------------\nFILE INFORMATION\n-----------------------------------------------------------------\n\nfile:       SafeDecimalMath.sol\nversion:    2.0\nauthor:     Kevin Brown\n            Gavin Conway\ndate:       2018-10-18\n\n-----------------------------------------------------------------\nMODULE DESCRIPTION\n-----------------------------------------------------------------\n\nA library providing safe mathematical operations for division and\nmultiplication with the capability to round or truncate the results\nto the nearest increment. Operations can return a standard precision\nor high precision decimal. High precision decimals are useful for\nexample when attempting to calculate percentages or fractions\naccurately.\n\n-----------------------------------------------------------------\n*/\n\n\n/**\n * @title Safely manipulate unsigned fixed-point decimals at a given precision level.\n * @dev Functions accepting uints in this contract and derived contracts\n * are taken to be such fixed point decimals of a specified precision (either standard\n * or high).\n */\nlibrary SafeDecimalMath {\n\n    using SafeMath for uint;\n\n    /* Number of decimal places in the representations. */\n    uint8 public constant decimals = 18;\n    uint8 public constant highPrecisionDecimals = 27;\n\n    /* The number representing 1.0. */\n    uint public constant UNIT = 10 ** uint(decimals);\n\n    /* The number representing 1.0 for higher fidelity numbers. */\n    uint public constant PRECISE_UNIT = 10 ** uint(highPrecisionDecimals);\n    uint private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = 10 ** uint(highPrecisionDecimals - decimals);\n\n    /** \n     * @return Provides an interface to UNIT.\n     */\n    function unit()\n        external\n        pure\n        returns (uint)\n    {\n        return UNIT;\n    }\n\n    /** \n     * @return Provides an interface to PRECISE_UNIT.\n     */\n    function preciseUnit()\n        external\n        pure \n        returns (uint)\n    {\n        return PRECISE_UNIT;\n    }\n\n    /**\n     * @return The result of multiplying x and y, interpreting the operands as fixed-point\n     * decimals.\n     * \n     * @dev A unit factor is divided out after the product of x and y is evaluated,\n     * so that product must be less than 2**256. As this is an integer division,\n     * the internal division always rounds down. This helps save on gas. Rounding\n     * is more expensive on gas.\n     */\n    function multiplyDecimal(uint x, uint y)\n        internal\n        pure\n        returns (uint)\n    {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        return x.mul(y) / UNIT;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of the specified precision unit.\n     *\n     * @dev The operands should be in the form of a the specified unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function _multiplyDecimalRound(uint x, uint y, uint precisionUnit)\n        private\n        pure\n        returns (uint)\n    {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        uint quotientTimesTen = x.mul(y) / (precisionUnit / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a precise unit.\n     *\n     * @dev The operands should be in the precise unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRoundPrecise(uint x, uint y)\n        internal\n        pure\n        returns (uint)\n    {\n        return _multiplyDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a standard unit.\n     *\n     * @dev The operands should be in the standard unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRound(uint x, uint y)\n        internal\n        pure\n        returns (uint)\n    {\n        return _multiplyDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is a high\n     * precision decimal.\n     * \n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and UNIT must be less than 2**256. As\n     * this is an integer division, the result is always rounded down.\n     * This helps save on gas. Rounding is more expensive on gas.\n     */\n    function divideDecimal(uint x, uint y)\n        internal\n        pure\n        returns (uint)\n    {\n        /* Reintroduce the UNIT factor that will be divided out by y. */\n        return x.mul(UNIT).div(y);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * decimal in the precision unit specified in the parameter.\n     *\n     * @dev y is divided after the product of x and the specified precision unit\n     * is evaluated, so the product of x and the specified precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function _divideDecimalRound(uint x, uint y, uint precisionUnit)\n        private\n        pure\n        returns (uint)\n    {\n        uint resultTimesTen = x.mul(precisionUnit * 10).div(y);\n\n        if (resultTimesTen % 10 >= 5) {\n            resultTimesTen += 10;\n        }\n\n        return resultTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * standard precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and the standard precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRound(uint x, uint y)\n        internal\n        pure\n        returns (uint)\n    {\n        return _divideDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * high precision decimal.\n     *\n     * @dev y is divided after the product of x and the high precision unit\n     * is evaluated, so the product of x and the high precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRoundPrecise(uint x, uint y)\n        internal\n        pure\n        returns (uint)\n    {\n        return _divideDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @dev Convert a standard decimal representation to a high precision one.\n     */\n    function decimalToPreciseDecimal(uint i)\n        internal\n        pure\n        returns (uint)\n    {\n        return i.mul(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);\n    }\n\n    /**\n     * @dev Convert a high precision decimal to a standard decimal representation.\n     */\n    function preciseDecimalToDecimal(uint i)\n        internal\n        pure\n        returns (uint)\n    {\n        uint quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n\n}\n\n\n/*\n-----------------------------------------------------------------\nFILE INFORMATION\n-----------------------------------------------------------------\n\nfile:       State.sol\nversion:    1.1\nauthor:     Dominic Romanowski\n            Anton Jurisevic\n\ndate:       2018-05-15\n\n-----------------------------------------------------------------\nMODULE DESCRIPTION\n-----------------------------------------------------------------\n\nThis contract is used side by side with external state token\ncontracts, such as Synthetix and Synth.\nIt provides an easy way to upgrade contract logic while\nmaintaining all user balances and allowances. This is designed\nto make the changeover as easy as possible, since mappings\nare not so cheap or straightforward to migrate.\n\nThe first deployed contract would create this state contract,\nusing it as its store of balances.\nWhen a new contract is deployed, it links to the existing\nstate contract, whose owner would then change its associated\ncontract to the new one.\n\n-----------------------------------------------------------------\n*/\n\n\ncontract State is Owned {\n    // the address of the contract that can modify variables\n    // this can only be changed by the owner of this contract\n    address public associatedContract;\n\n\n    constructor(address _owner, address _associatedContract)\n        Owned(_owner)\n        public\n    {\n        associatedContract = _associatedContract;\n        emit AssociatedContractUpdated(_associatedContract);\n    }\n\n    /* ========== SETTERS ========== */\n\n    // Change the associated contract to a new address\n    function setAssociatedContract(address _associatedContract)\n        external\n        onlyOwner\n    {\n        associatedContract = _associatedContract;\n        emit AssociatedContractUpdated(_associatedContract);\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyAssociatedContract\n    {\n        require(msg.sender == associatedContract, \"Only the associated contract can perform this action\");\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event AssociatedContractUpdated(address associatedContract);\n}\n\n\n/*\n-----------------------------------------------------------------\nFILE INFORMATION\n-----------------------------------------------------------------\n\nfile:       TokenState.sol\nversion:    1.1\nauthor:     Dominic Romanowski\n            Anton Jurisevic\n\ndate:       2018-05-15\n\n-----------------------------------------------------------------\nMODULE DESCRIPTION\n-----------------------------------------------------------------\n\nA contract that holds the state of an ERC20 compliant token.\n\nThis contract is used side by side with external state token\ncontracts, such as Synthetix and Synth.\nIt provides an easy way to upgrade contract logic while\nmaintaining all user balances and allowances. This is designed\nto make the changeover as easy as possible, since mappings\nare not so cheap or straightforward to migrate.\n\nThe first deployed contract would create this state contract,\nusing it as its store of balances.\nWhen a new contract is deployed, it links to the existing\nstate contract, whose owner would then change its associated\ncontract to the new one.\n\n-----------------------------------------------------------------\n*/\n\n\n/**\n * @title ERC20 Token State\n * @notice Stores balance information of an ERC20 token contract.\n */\ncontract TokenState is State {\n\n    /* ERC20 fields. */\n    mapping(address => uint) public balanceOf;\n    mapping(address => mapping(address => uint)) public allowance;\n\n    /**\n     * @dev Constructor\n     * @param _owner The address which controls this contract.\n     * @param _associatedContract The ERC20 contract whose state this composes.\n     */\n    constructor(address _owner, address _associatedContract)\n        State(_owner, _associatedContract)\n        public\n    {}\n\n    /* ========== SETTERS ========== */\n\n    /**\n     * @notice Set ERC20 allowance.\n     * @dev Only the associated contract may call this.\n     * @param tokenOwner The authorising party.\n     * @param spender The authorised party.\n     * @param value The total value the authorised party may spend on the\n     * authorising party's behalf.\n     */\n    function setAllowance(address tokenOwner, address spender, uint value)\n        external\n        onlyAssociatedContract\n    {\n        allowance[tokenOwner][spender] = value;\n    }\n\n    /**\n     * @notice Set the balance in a given account\n     * @dev Only the associated contract may call this.\n     * @param account The account whose value to set.\n     * @param value The new balance of the given account.\n     */\n    function setBalanceOf(address account, uint value)\n        external\n        onlyAssociatedContract\n    {\n        balanceOf[account] = value;\n    }\n}\n\n\n/*\n-----------------------------------------------------------------\nFILE INFORMATION\n-----------------------------------------------------------------\n\nfile:       ExternStateToken.sol\nversion:    1.0\nauthor:     Kevin Brown\ndate:       2018-08-06\n\n-----------------------------------------------------------------\nMODULE DESCRIPTION\n-----------------------------------------------------------------\n\nThis contract offers a modifer that can prevent reentrancy on\nparticular actions. It will not work if you put it on multiple\nfunctions that can be called from each other. Specifically guard\nexternal entry points to the contract with the modifier only.\n\n-----------------------------------------------------------------\n*/\n\n\ncontract ReentrancyPreventer {\n    /* ========== MODIFIERS ========== */\n    bool isInFunctionBody = false;\n\n    modifier preventReentrancy {\n        require(!isInFunctionBody, \"Reverted to prevent reentrancy\");\n        isInFunctionBody = true;\n        _;\n        isInFunctionBody = false;\n    }\n}\n\n/*\n-----------------------------------------------------------------\nFILE INFORMATION\n-----------------------------------------------------------------\n\nfile:       TokenFallback.sol\nversion:    1.0\nauthor:     Kevin Brown\ndate:       2018-08-10\n\n-----------------------------------------------------------------\nMODULE DESCRIPTION\n-----------------------------------------------------------------\n\nThis contract provides the logic that's used to call tokenFallback()\nwhen transfers happen.\n\nIt's pulled out into its own module because it's needed in two\nplaces, so instead of copy/pasting this logic and maininting it\nboth in Fee Token and Extern State Token, it's here and depended\non by both contracts.\n\n-----------------------------------------------------------------\n*/\n\n\ncontract TokenFallbackCaller is ReentrancyPreventer {\n    function callTokenFallbackIfNeeded(address sender, address recipient, uint amount, bytes data)\n        internal\n        preventReentrancy\n    {\n        /*\n            If we're transferring to a contract and it implements the tokenFallback function, call it.\n            This isn't ERC223 compliant because we don't revert if the contract doesn't implement tokenFallback.\n            This is because many DEXes and other contracts that expect to work with the standard\n            approve / transferFrom workflow don't implement tokenFallback but can still process our tokens as\n            usual, so it feels very harsh and likely to cause trouble if we add this restriction after having\n            previously gone live with a vanilla ERC20.\n        */\n\n        // Is the to address a contract? We can check the code size on that address and know.\n        uint length;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            // Retrieve the size of the code on the recipient address\n            length := extcodesize(recipient)\n        }\n\n        // If there's code there, it's a contract\n        if (length > 0) {\n            // Now we need to optionally call tokenFallback(address from, uint value).\n            // We can't call it the normal way because that reverts when the recipient doesn't implement the function.\n\n            // solium-disable-next-line security/no-low-level-calls\n            recipient.call(abi.encodeWithSignature(\"tokenFallback(address,uint256,bytes)\", sender, amount, data));\n\n            // And yes, we specifically don't care if this call fails, so we're not checking the return value.\n        }\n    }\n}\n\n\n/*\n-----------------------------------------------------------------\nFILE INFORMATION\n-----------------------------------------------------------------\n\nfile:       ExternStateToken.sol\nversion:    1.3\nauthor:     Anton Jurisevic\n            Dominic Romanowski\n            Kevin Brown\n\ndate:       2018-05-29\n\n-----------------------------------------------------------------\nMODULE DESCRIPTION\n-----------------------------------------------------------------\n\nA partial ERC20 token contract, designed to operate with a proxy.\nTo produce a complete ERC20 token, transfer and transferFrom\ntokens must be implemented, using the provided _byProxy internal\nfunctions.\nThis contract utilises an external state for upgradeability.\n\n-----------------------------------------------------------------\n*/\n\n\n/**\n * @title ERC20 Token contract, with detached state and designed to operate behind a proxy.\n */\ncontract ExternStateToken is SelfDestructible, Proxyable, TokenFallbackCaller {\n\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    /* ========== STATE VARIABLES ========== */\n\n    /* Stores balances and allowances. */\n    TokenState public tokenState;\n\n    /* Other ERC20 fields. */\n    string public name;\n    string public symbol;\n    uint public totalSupply;\n    uint8 public decimals;\n\n    /**\n     * @dev Constructor.\n     * @param _proxy The proxy associated with this contract.\n     * @param _name Token's ERC20 name.\n     * @param _symbol Token's ERC20 symbol.\n     * @param _totalSupply The total supply of the token.\n     * @param _tokenState The TokenState contract address.\n     * @param _owner The owner of this contract.\n     */\n    constructor(address _proxy, TokenState _tokenState,\n                string _name, string _symbol, uint _totalSupply,\n                uint8 _decimals, address _owner)\n        SelfDestructible(_owner)\n        Proxyable(_proxy, _owner)\n        public\n    {\n        tokenState = _tokenState;\n\n        name = _name;\n        symbol = _symbol;\n        totalSupply = _totalSupply;\n        decimals = _decimals;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /**\n     * @notice Returns the ERC20 allowance of one party to spend on behalf of another.\n     * @param owner The party authorising spending of their funds.\n     * @param spender The party spending tokenOwner's funds.\n     */\n    function allowance(address owner, address spender)\n        public\n        view\n        returns (uint)\n    {\n        return tokenState.allowance(owner, spender);\n    }\n\n    /**\n     * @notice Returns the ERC20 token balance of a given account.\n     */\n    function balanceOf(address account)\n        public\n        view\n        returns (uint)\n    {\n        return tokenState.balanceOf(account);\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /**\n     * @notice Set the address of the TokenState contract.\n     * @dev This can be used to \"pause\" transfer functionality, by pointing the tokenState at 0x000..\n     * as balances would be unreachable.\n     */ \n    function setTokenState(TokenState _tokenState)\n        external\n        optionalProxy_onlyOwner\n    {\n        tokenState = _tokenState;\n        emitTokenStateUpdated(_tokenState);\n    }\n\n    function _internalTransfer(address from, address to, uint value, bytes data) \n        internal\n        returns (bool)\n    { \n        /* Disallow transfers to irretrievable-addresses. */\n        require(to != address(0), \"Cannot transfer to the 0 address\");\n        require(to != address(this), \"Cannot transfer to the underlying contract\");\n        require(to != address(proxy), \"Cannot transfer to the proxy contract\");\n\n        // Insufficient balance will be handled by the safe subtraction.\n        tokenState.setBalanceOf(from, tokenState.balanceOf(from).sub(value));\n        tokenState.setBalanceOf(to, tokenState.balanceOf(to).add(value));\n\n        // If the recipient is a contract, we need to call tokenFallback on it so they can do ERC223\n        // actions when receiving our tokens. Unlike the standard, however, we don't revert if the\n        // recipient contract doesn't implement tokenFallback.\n        callTokenFallbackIfNeeded(from, to, value, data);\n        \n        // Emit a standard ERC20 transfer event\n        emitTransfer(from, to, value);\n\n        return true;\n    }\n\n    /**\n     * @dev Perform an ERC20 token transfer. Designed to be called by transfer functions possessing\n     * the onlyProxy or optionalProxy modifiers.\n     */\n    function _transfer_byProxy(address from, address to, uint value, bytes data)\n        internal\n        returns (bool)\n    {\n        return _internalTransfer(from, to, value, data);\n    }\n\n    /**\n     * @dev Perform an ERC20 token transferFrom. Designed to be called by transferFrom functions\n     * possessing the optionalProxy or optionalProxy modifiers.\n     */\n    function _transferFrom_byProxy(address sender, address from, address to, uint value, bytes data)\n        internal\n        returns (bool)\n    {\n        /* Insufficient allowance will be handled by the safe subtraction. */\n        tokenState.setAllowance(from, sender, tokenState.allowance(from, sender).sub(value));\n        return _internalTransfer(from, to, value, data);\n    }\n\n    /**\n     * @notice Approves spender to transfer on the message sender's behalf.\n     */\n    function approve(address spender, uint value)\n        public\n        optionalProxy\n        returns (bool)\n    {\n        address sender = messageSender;\n\n        tokenState.setAllowance(sender, spender, value);\n        emitApproval(sender, spender, value);\n        return true;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event Transfer(address indexed from, address indexed to, uint value);\n    bytes32 constant TRANSFER_SIG = keccak256(\"Transfer(address,address,uint256)\");\n    function emitTransfer(address from, address to, uint value) internal {\n        proxy._emit(abi.encode(value), 3, TRANSFER_SIG, bytes32(from), bytes32(to), 0);\n    }\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n    bytes32 constant APPROVAL_SIG = keccak256(\"Approval(address,address,uint256)\");\n    function emitApproval(address owner, address spender, uint value) internal {\n        proxy._emit(abi.encode(value), 3, APPROVAL_SIG, bytes32(owner), bytes32(spender), 0);\n    }\n\n    event TokenStateUpdated(address newTokenState);\n    bytes32 constant TOKENSTATEUPDATED_SIG = keccak256(\"TokenStateUpdated(address)\");\n    function emitTokenStateUpdated(address newTokenState) internal {\n        proxy._emit(abi.encode(newTokenState), 1, TOKENSTATEUPDATED_SIG, 0, 0, 0);\n    }\n}\n\n\n/*\n-----------------------------------------------------------------\nFILE INFORMATION\n-----------------------------------------------------------------\n\nfile:       SupplySchedule.sol\nversion:    1.0\nauthor:     Jackson Chan\n            Clinton Ennis\ndate:       2019-03-01\n\n-----------------------------------------------------------------\nMODULE DESCRIPTION\n-----------------------------------------------------------------\n\nSupply Schedule contract. SNX is a transferable ERC20 token.\n\nUser's get staking rewards as part of the incentives of\n+------+-------------+--------------+----------+\n| Year |  Increase   | Total Supply | Increase |\n+------+-------------+--------------+----------+\n|    1 |           0 |  100,000,000 |          |\n|    2 |  75,000,000 |  175,000,000 | 75%      |\n|    3 |  37,500,000 |  212,500,000 | 21%      |\n|    4 |  18,750,000 |  231,250,000 | 9%       |\n|    5 |   9,375,000 |  240,625,000 | 4%       |\n|    6 |   4,687,500 |  245,312,500 | 2%       |\n+------+-------------+--------------+----------+\n\n\n-----------------------------------------------------------------\n*/\n\n\n/**\n * @title SupplySchedule contract\n */\ncontract SupplySchedule is Owned {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    /* Storage */\n    struct ScheduleData {\n        // Total supply issuable during period\n        uint totalSupply;\n\n        // UTC Time - Start of the schedule\n        uint startPeriod;\n\n        // UTC Time - End of the schedule\n        uint endPeriod;\n\n        // UTC Time - Total of supply minted\n        uint totalSupplyMinted;\n    }\n\n    // How long each mint period is\n    uint public mintPeriodDuration = 1 weeks;\n\n    // time supply last minted\n    uint public lastMintEvent;\n\n    Synthetix public synthetix;\n\n    uint constant SECONDS_IN_YEAR = 60 * 60 * 24 * 365;\n\n    uint public constant START_DATE = 1520294400; // 2018-03-06T00:00:00+00:00\n    uint public constant YEAR_ONE = START_DATE + SECONDS_IN_YEAR.mul(1);\n    uint public constant YEAR_TWO = START_DATE + SECONDS_IN_YEAR.mul(2);\n    uint public constant YEAR_THREE = START_DATE + SECONDS_IN_YEAR.mul(3);\n    uint public constant YEAR_FOUR = START_DATE + SECONDS_IN_YEAR.mul(4);\n    uint public constant YEAR_FIVE = START_DATE + SECONDS_IN_YEAR.mul(5);\n    uint public constant YEAR_SIX = START_DATE + SECONDS_IN_YEAR.mul(6);\n    uint public constant YEAR_SEVEN = START_DATE + SECONDS_IN_YEAR.mul(7);\n\n    uint8 constant public INFLATION_SCHEDULES_LENGTH = 7;\n    ScheduleData[INFLATION_SCHEDULES_LENGTH] public schedules;\n\n    uint public minterReward = 200 * SafeDecimalMath.unit();\n\n    constructor(address _owner)\n        Owned(_owner)\n        public\n    {\n        // ScheduleData(totalSupply, startPeriod, endPeriod, totalSupplyMinted)\n        // Year 1 - Total supply 100,000,000\n        schedules[0] = ScheduleData(1e8 * SafeDecimalMath.unit(), START_DATE, YEAR_ONE - 1, 1e8 * SafeDecimalMath.unit());\n        schedules[1] = ScheduleData(75e6 * SafeDecimalMath.unit(), YEAR_ONE, YEAR_TWO - 1, 0); // Year 2 - Total supply 175,000,000\n        schedules[2] = ScheduleData(37.5e6 * SafeDecimalMath.unit(), YEAR_TWO, YEAR_THREE - 1, 0); // Year 3 - Total supply 212,500,000\n        schedules[3] = ScheduleData(18.75e6 * SafeDecimalMath.unit(), YEAR_THREE, YEAR_FOUR - 1, 0); // Year 4 - Total supply 231,250,000\n        schedules[4] = ScheduleData(9.375e6 * SafeDecimalMath.unit(), YEAR_FOUR, YEAR_FIVE - 1, 0); // Year 5 - Total supply 240,625,000\n        schedules[5] = ScheduleData(4.6875e6 * SafeDecimalMath.unit(), YEAR_FIVE, YEAR_SIX - 1, 0); // Year 6 - Total supply 245,312,500\n        schedules[6] = ScheduleData(0, YEAR_SIX, YEAR_SEVEN - 1, 0); // Year 7 - Total supply 245,312,500\n    }\n\n    // ========== SETTERS ========== */\n    function setSynthetix(Synthetix _synthetix)\n        external\n        onlyOwner\n    {\n        synthetix = _synthetix;\n        // emit event\n    }\n\n    // ========== VIEWS ==========\n    function mintableSupply()\n        public\n        view\n        returns (uint)\n    {\n        if (!isMintable()) {\n            return 0;\n        }\n\n        uint index = getCurrentSchedule();\n\n        // Calculate previous year's mintable supply\n        uint amountPreviousPeriod = _remainingSupplyFromPreviousYear(index);\n\n        /* solium-disable */\n\n        // Last mint event within current period will use difference in (now - lastMintEvent)\n        // Last mint event not set (0) / outside of current Period will use current Period\n        // start time resolved in (now - schedule.startPeriod)\n        ScheduleData memory schedule = schedules[index];\n\n        uint weeksInPeriod = (schedule.endPeriod - schedule.startPeriod).div(mintPeriodDuration);\n\n        uint supplyPerWeek = schedule.totalSupply.divideDecimal(weeksInPeriod);\n\n        uint weeksToMint = lastMintEvent >= schedule.startPeriod ? _numWeeksRoundedDown(now.sub(lastMintEvent)) : _numWeeksRoundedDown(now.sub(schedule.startPeriod));\n        // /* solium-enable */\n\n        uint amountInPeriod = supplyPerWeek.multiplyDecimal(weeksToMint);\n        return amountInPeriod.add(amountPreviousPeriod);\n    }\n\n    function _numWeeksRoundedDown(uint _timeDiff)\n        public\n        view\n        returns (uint)\n    {\n        // Take timeDiff in seconds (Dividend) and mintPeriodDuration as (Divisor)\n        // Calculate the numberOfWeeks since last mint rounded down to 1 week\n        // Fraction of a week will return 0\n        return _timeDiff.div(mintPeriodDuration);\n    }\n\n    function isMintable()\n        public\n        view\n        returns (bool)\n    {\n        bool mintable = false;\n        if (now - lastMintEvent > mintPeriodDuration && now <= schedules[6].endPeriod) // Ensure time is not after end of Year 7\n        {\n            mintable = true;\n        }\n        return mintable;\n    }\n\n    // Return the current schedule based on the timestamp\n    // applicable based on startPeriod and endPeriod\n    function getCurrentSchedule()\n        public\n        view\n        returns (uint)\n    {\n        require(now <= schedules[6].endPeriod, \"Mintable periods have ended\");\n\n        for (uint i = 0; i < INFLATION_SCHEDULES_LENGTH; i++) {\n            if (schedules[i].startPeriod <= now && schedules[i].endPeriod >= now) {\n                return i;\n            }\n        }\n    }\n\n    function _remainingSupplyFromPreviousYear(uint currentSchedule)\n        internal\n        view\n        returns (uint)\n    {\n        // All supply has been minted for previous period if last minting event is after\n        // the endPeriod for last year\n        if (currentSchedule == 0 || lastMintEvent > schedules[currentSchedule - 1].endPeriod) {\n            return 0;\n        }\n\n        // return the remaining supply to be minted for previous period missed\n        uint amountInPeriod = schedules[currentSchedule - 1].totalSupply.sub(schedules[currentSchedule - 1].totalSupplyMinted);\n\n        // Ensure previous period remaining amount is not less than 0\n        if (amountInPeriod < 0) {\n            return 0;\n        }\n\n        return amountInPeriod;\n    }\n\n    // ========== MUTATIVE FUNCTIONS ==========\n    function updateMintValues()\n        external\n        onlySynthetix\n        returns (bool)\n    {\n        // Will fail if the time is outside of schedules\n        uint currentIndex = getCurrentSchedule();\n        uint lastPeriodAmount = _remainingSupplyFromPreviousYear(currentIndex);\n        uint currentPeriodAmount = mintableSupply().sub(lastPeriodAmount);\n\n        // Update schedule[n - 1].totalSupplyMinted\n        if (lastPeriodAmount > 0) {\n            schedules[currentIndex - 1].totalSupplyMinted = schedules[currentIndex - 1].totalSupplyMinted.add(lastPeriodAmount);\n        }\n\n        // Update schedule.totalSupplyMinted for currentSchedule\n        schedules[currentIndex].totalSupplyMinted = schedules[currentIndex].totalSupplyMinted.add(currentPeriodAmount);\n        // Update mint event to now\n        lastMintEvent = now;\n\n        emit SupplyMinted(lastPeriodAmount, currentPeriodAmount, currentIndex, now);\n        return true;\n    }\n\n    function setMinterReward(uint _amount)\n        external\n        onlyOwner\n    {\n        minterReward = _amount;\n        emit MinterRewardUpdated(_amount);\n    }\n\n    // ========== MODIFIERS ==========\n\n    modifier onlySynthetix() {\n        require(msg.sender == address(synthetix), \"Only the synthetix contract can perform this action\");\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event SupplyMinted(uint previousPeriodAmount, uint currentAmount, uint indexed schedule, uint timestamp);\n    event MinterRewardUpdated(uint newRewardAmount);\n}\n\n\n/*\n-----------------------------------------------------------------\nFILE INFORMATION\n-----------------------------------------------------------------\n\nfile:       ExchangeRates.sol\nversion:    1.0\nauthor:     Kevin Brown\ndate:       2018-09-12\n\n-----------------------------------------------------------------\nMODULE DESCRIPTION\n-----------------------------------------------------------------\n\nA contract that any other contract in the Synthetix system can query\nfor the current market value of various assets, including\ncrypto assets as well as various fiat assets.\n\nThis contract assumes that rate updates will completely update\nall rates to their current values. If a rate shock happens\non a single asset, the oracle will still push updated rates\nfor all other assets.\n\n-----------------------------------------------------------------\n*/\n\n\n/**\n * @title The repository for exchange rates\n */\n\ncontract ExchangeRates is SelfDestructible {\n\n\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    // Exchange rates stored by currency code, e.g. 'SNX', or 'sUSD'\n    mapping(bytes4 => uint) public rates;\n\n    // Update times stored by currency code, e.g. 'SNX', or 'sUSD'\n    mapping(bytes4 => uint) public lastRateUpdateTimes;\n\n    // The address of the oracle which pushes rate updates to this contract\n    address public oracle;\n\n    // Do not allow the oracle to submit times any further forward into the future than this constant.\n    uint constant ORACLE_FUTURE_LIMIT = 10 minutes;\n\n    // How long will the contract assume the rate of any asset is correct\n    uint public rateStalePeriod = 3 hours;\n\n    // Each participating currency in the XDR basket is represented as a currency key with\n    // equal weighting.\n    // There are 5 participating currencies, so we'll declare that clearly.\n    bytes4[5] public xdrParticipants;\n\n    // For inverted prices, keep a mapping of their entry, limits and frozen status\n    struct InversePricing {\n        uint entryPoint;\n        uint upperLimit;\n        uint lowerLimit;\n        bool frozen;\n    }\n    mapping(bytes4 => InversePricing) public inversePricing;\n    bytes4[] public invertedKeys;\n\n    //\n    // ========== CONSTRUCTOR ==========\n\n    /**\n     * @dev Constructor\n     * @param _owner The owner of this contract.\n     * @param _oracle The address which is able to update rate information.\n     * @param _currencyKeys The initial currency keys to store (in order).\n     * @param _newRates The initial currency amounts for each currency (in order).\n     */\n    constructor(\n        // SelfDestructible (Ownable)\n        address _owner,\n\n        // Oracle values - Allows for rate updates\n        address _oracle,\n        bytes4[] _currencyKeys,\n        uint[] _newRates\n    )\n        /* Owned is initialised in SelfDestructible */\n        SelfDestructible(_owner)\n        public\n    {\n        require(_currencyKeys.length == _newRates.length, \"Currency key length and rate length must match.\");\n\n        oracle = _oracle;\n\n        // The sUSD rate is always 1 and is never stale.\n        rates[\"sUSD\"] = SafeDecimalMath.unit();\n        lastRateUpdateTimes[\"sUSD\"] = now;\n\n        // These are the currencies that make up the XDR basket.\n        // These are hard coded because:\n        //  - This way users can depend on the calculation and know it won't change for this deployment of the contract.\n        //  - Adding new currencies would likely introduce some kind of weighting factor, which\n        //    isn't worth preemptively adding when all of the currencies in the current basket are weighted at 1.\n        //  - The expectation is if this logic needs to be updated, we'll simply deploy a new version of this contract\n        //    then point the system at the new version.\n        xdrParticipants = [\n            bytes4(\"sUSD\"),\n            bytes4(\"sAUD\"),\n            bytes4(\"sCHF\"),\n            bytes4(\"sEUR\"),\n            bytes4(\"sGBP\")\n        ];\n\n        internalUpdateRates(_currencyKeys, _newRates, now);\n    }\n\n    /* ========== SETTERS ========== */\n\n    /**\n     * @notice Set the rates stored in this contract\n     * @param currencyKeys The currency keys you wish to update the rates for (in order)\n     * @param newRates The rates for each currency (in order)\n     * @param timeSent The timestamp of when the update was sent, specified in seconds since epoch (e.g. the same as the now keyword in solidity).contract\n     *                 This is useful because transactions can take a while to confirm, so this way we know how old the oracle's datapoint was exactly even\n     *                 if it takes a long time for the transaction to confirm.\n     */\n    function updateRates(bytes4[] currencyKeys, uint[] newRates, uint timeSent)\n        external\n        onlyOracle\n        returns(bool)\n    {\n        return internalUpdateRates(currencyKeys, newRates, timeSent);\n    }\n\n    /**\n     * @notice Internal function which sets the rates stored in this contract\n     * @param currencyKeys The currency keys you wish to update the rates for (in order)\n     * @param newRates The rates for each currency (in order)\n     * @param timeSent The timestamp of when the update was sent, specified in seconds since epoch (e.g. the same as the now keyword in solidity).contract\n     *                 This is useful because transactions can take a while to confirm, so this way we know how old the oracle's datapoint was exactly even\n     *                 if it takes a long time for the transaction to confirm.\n     */\n    function internalUpdateRates(bytes4[] currencyKeys, uint[] newRates, uint timeSent)\n        internal\n        returns(bool)\n    {\n        require(currencyKeys.length == newRates.length, \"Currency key array length must match rates array length.\");\n        require(timeSent < (now + ORACLE_FUTURE_LIMIT), \"Time is too far into the future\");\n\n        // Loop through each key and perform update.\n        for (uint i = 0; i < currencyKeys.length; i++) {\n            // Should not set any rate to zero ever, as no asset will ever be\n            // truely worthless and still valid. In this scenario, we should\n            // delete the rate and remove it from the system.\n            require(newRates[i] != 0, \"Zero is not a valid rate, please call deleteRate instead.\");\n            require(currencyKeys[i] != \"sUSD\", \"Rate of sUSD cannot be updated, it's always UNIT.\");\n\n            // We should only update the rate if it's at least the same age as the last rate we've got.\n            if (timeSent < lastRateUpdateTimes[currencyKeys[i]]) {\n                continue;\n            }\n\n            newRates[i] = rateOrInverted(currencyKeys[i], newRates[i]);\n\n            // Ok, go ahead with the update.\n            rates[currencyKeys[i]] = newRates[i];\n            lastRateUpdateTimes[currencyKeys[i]] = timeSent;\n        }\n\n        emit RatesUpdated(currencyKeys, newRates);\n\n        // Now update our XDR rate.\n        updateXDRRate(timeSent);\n\n        return true;\n    }\n\n    /**\n     * @notice Internal function to get the inverted rate, if any, and mark an inverted\n     *  key as frozen if either limits are reached.\n     * @param currencyKey The price key to lookup\n     * @param rate The rate for the given price key\n     */\n    function rateOrInverted(bytes4 currencyKey, uint rate) internal returns (uint) {\n        // if an inverse mapping exists, adjust the price accordingly\n        InversePricing storage inverse = inversePricing[currencyKey];\n        if (inverse.entryPoint <= 0) {\n            return rate;\n        }\n\n        // set the rate to the current rate initially (if it's frozen, this is what will be returned)\n        uint newInverseRate = rates[currencyKey];\n\n        // get the new inverted rate if not frozen\n        if (!inverse.frozen) {\n            uint doubleEntryPoint = inverse.entryPoint.mul(2);\n            if (doubleEntryPoint <= rate) {\n                // avoid negative numbers for unsigned ints, so set this to 0\n                // which by the requirement that lowerLimit be > 0 will\n                // cause this to freeze the price to the lowerLimit\n                newInverseRate = 0;\n            } else {\n                newInverseRate = doubleEntryPoint.sub(rate);\n            }\n\n            // now if new rate hits our limits, set it to the limit and freeze\n            if (newInverseRate >= inverse.upperLimit) {\n                newInverseRate = inverse.upperLimit;\n            } else if (newInverseRate <= inverse.lowerLimit) {\n                newInverseRate = inverse.lowerLimit;\n            }\n\n            if (newInverseRate == inverse.upperLimit || newInverseRate == inverse.lowerLimit) {\n                inverse.frozen = true;\n                emit InversePriceFrozen(currencyKey);\n            }\n        }\n\n        return newInverseRate;\n    }\n\n    /**\n     * @notice Update the Synthetix Drawing Rights exchange rate based on other rates already updated.\n     */\n    function updateXDRRate(uint timeSent)\n        internal\n    {\n        uint total = 0;\n\n        for (uint i = 0; i < xdrParticipants.length; i++) {\n            total = rates[xdrParticipants[i]].add(total);\n        }\n\n        // Set the rate\n        rates[\"XDR\"] = total;\n\n        // Record that we updated the XDR rate.\n        lastRateUpdateTimes[\"XDR\"] = timeSent;\n\n        // Emit our updated event separate to the others to save\n        // moving data around between arrays.\n        bytes4[] memory eventCurrencyCode = new bytes4[](1);\n        eventCurrencyCode[0] = \"XDR\";\n\n        uint[] memory eventRate = new uint[](1);\n        eventRate[0] = rates[\"XDR\"];\n\n        emit RatesUpdated(eventCurrencyCode, eventRate);\n    }\n\n    /**\n     * @notice Delete a rate stored in the contract\n     * @param currencyKey The currency key you wish to delete the rate for\n     */\n    function deleteRate(bytes4 currencyKey)\n        external\n        onlyOracle\n    {\n        require(rates[currencyKey] > 0, \"Rate is zero\");\n\n        delete rates[currencyKey];\n        delete lastRateUpdateTimes[currencyKey];\n\n        emit RateDeleted(currencyKey);\n    }\n\n    /**\n     * @notice Set the Oracle that pushes the rate information to this contract\n     * @param _oracle The new oracle address\n     */\n    function setOracle(address _oracle)\n        external\n        onlyOwner\n    {\n        oracle = _oracle;\n        emit OracleUpdated(oracle);\n    }\n\n    /**\n     * @notice Set the stale period on the updated rate variables\n     * @param _time The new rateStalePeriod\n     */\n    function setRateStalePeriod(uint _time)\n        external\n        onlyOwner\n    {\n        rateStalePeriod = _time;\n        emit RateStalePeriodUpdated(rateStalePeriod);\n    }\n\n    /**\n     * @notice Set an inverse price up for the currency key\n     * @param currencyKey The currency to update\n     * @param entryPoint The entry price point of the inverted price\n     * @param upperLimit The upper limit, at or above which the price will be frozen\n     * @param lowerLimit The lower limit, at or below which the price will be frozen\n     */\n    function setInversePricing(bytes4 currencyKey, uint entryPoint, uint upperLimit, uint lowerLimit)\n        external onlyOwner\n    {\n        require(entryPoint > 0, \"entryPoint must be above 0\");\n        require(lowerLimit > 0, \"lowerLimit must be above 0\");\n        require(upperLimit > entryPoint, \"upperLimit must be above the entryPoint\");\n        require(upperLimit < entryPoint.mul(2), \"upperLimit must be less than double entryPoint\");\n        require(lowerLimit < entryPoint, \"lowerLimit must be below the entryPoint\");\n\n        if (inversePricing[currencyKey].entryPoint <= 0) {\n            // then we are adding a new inverse pricing, so add this\n            invertedKeys.push(currencyKey);\n        }\n        inversePricing[currencyKey].entryPoint = entryPoint;\n        inversePricing[currencyKey].upperLimit = upperLimit;\n        inversePricing[currencyKey].lowerLimit = lowerLimit;\n        inversePricing[currencyKey].frozen = false;\n\n        emit InversePriceConfigured(currencyKey, entryPoint, upperLimit, lowerLimit);\n    }\n\n    /**\n     * @notice Remove an inverse price for the currency key\n     * @param currencyKey The currency to remove inverse pricing for\n     */\n    function removeInversePricing(bytes4 currencyKey) external onlyOwner {\n        inversePricing[currencyKey].entryPoint = 0;\n        inversePricing[currencyKey].upperLimit = 0;\n        inversePricing[currencyKey].lowerLimit = 0;\n        inversePricing[currencyKey].frozen = false;\n\n        // now remove inverted key from array\n        for (uint8 i = 0; i < invertedKeys.length; i++) {\n            if (invertedKeys[i] == currencyKey) {\n                delete invertedKeys[i];\n\n                // Copy the last key into the place of the one we just deleted\n                // If there's only one key, this is array[0] = array[0].\n                // If we're deleting the last one, it's also a NOOP in the same way.\n                invertedKeys[i] = invertedKeys[invertedKeys.length - 1];\n\n                // Decrease the size of the array by one.\n                invertedKeys.length--;\n\n                break;\n            }\n        }\n\n        emit InversePriceConfigured(currencyKey, 0, 0, 0);\n    }\n    /* ========== VIEWS ========== */\n\n    /**\n     * @notice A function that lets you easily convert an amount in a source currency to an amount in the destination currency\n     * @param sourceCurrencyKey The currency the amount is specified in\n     * @param sourceAmount The source amount, specified in UNIT base\n     * @param destinationCurrencyKey The destination currency\n     */\n    function effectiveValue(bytes4 sourceCurrencyKey, uint sourceAmount, bytes4 destinationCurrencyKey)\n        public\n        view\n        rateNotStale(sourceCurrencyKey)\n        rateNotStale(destinationCurrencyKey)\n        returns (uint)\n    {\n        // If there's no change in the currency, then just return the amount they gave us\n        if (sourceCurrencyKey == destinationCurrencyKey) return sourceAmount;\n\n        // Calculate the effective value by going from source -> USD -> destination\n        return sourceAmount.multiplyDecimalRound(rateForCurrency(sourceCurrencyKey))\n            .divideDecimalRound(rateForCurrency(destinationCurrencyKey));\n    }\n\n    /**\n     * @notice Retrieve the rate for a specific currency\n     */\n    function rateForCurrency(bytes4 currencyKey)\n        public\n        view\n        returns (uint)\n    {\n        return rates[currencyKey];\n    }\n\n    /**\n     * @notice Retrieve the rates for a list of currencies\n     */\n    function ratesForCurrencies(bytes4[] currencyKeys)\n        public\n        view\n        returns (uint[])\n    {\n        uint[] memory _rates = new uint[](currencyKeys.length);\n\n        for (uint8 i = 0; i < currencyKeys.length; i++) {\n            _rates[i] = rates[currencyKeys[i]];\n        }\n\n        return _rates;\n    }\n\n    /**\n     * @notice Retrieve a list of last update times for specific currencies\n     */\n    function lastRateUpdateTimeForCurrency(bytes4 currencyKey)\n        public\n        view\n        returns (uint)\n    {\n        return lastRateUpdateTimes[currencyKey];\n    }\n\n    /**\n     * @notice Retrieve the last update time for a specific currency\n     */\n    function lastRateUpdateTimesForCurrencies(bytes4[] currencyKeys)\n        public\n        view\n        returns (uint[])\n    {\n        uint[] memory lastUpdateTimes = new uint[](currencyKeys.length);\n\n        for (uint8 i = 0; i < currencyKeys.length; i++) {\n            lastUpdateTimes[i] = lastRateUpdateTimes[currencyKeys[i]];\n        }\n\n        return lastUpdateTimes;\n    }\n\n    /**\n     * @notice Check if a specific currency's rate hasn't been updated for longer than the stale period.\n     */\n    function rateIsStale(bytes4 currencyKey)\n        public\n        view\n        returns (bool)\n    {\n        // sUSD is a special case and is never stale.\n        if (currencyKey == \"sUSD\") return false;\n\n        return lastRateUpdateTimes[currencyKey].add(rateStalePeriod) < now;\n    }\n\n    /**\n     * @notice Check if any rate is frozen (cannot be exchanged into)\n     */\n    function rateIsFrozen(bytes4 currencyKey)\n        external\n        view\n        returns (bool)\n    {\n        return inversePricing[currencyKey].frozen;\n    }\n\n\n    /**\n     * @notice Check if any of the currency rates passed in haven't been updated for longer than the stale period.\n     */\n    function anyRateIsStale(bytes4[] currencyKeys)\n        external\n        view\n        returns (bool)\n    {\n        // Loop through each key and check whether the data point is stale.\n        uint256 i = 0;\n\n        while (i < currencyKeys.length) {\n            // sUSD is a special case and is never false\n            if (currencyKeys[i] != \"sUSD\" && lastRateUpdateTimes[currencyKeys[i]].add(rateStalePeriod) < now) {\n                return true;\n            }\n            i += 1;\n        }\n\n        return false;\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier rateNotStale(bytes4 currencyKey) {\n        require(!rateIsStale(currencyKey), \"Rate stale or nonexistant currency\");\n        _;\n    }\n\n    modifier onlyOracle\n    {\n        require(msg.sender == oracle, \"Only the oracle can perform this action\");\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event OracleUpdated(address newOracle);\n    event RateStalePeriodUpdated(uint rateStalePeriod);\n    event RatesUpdated(bytes4[] currencyKeys, uint[] newRates);\n    event RateDeleted(bytes4 currencyKey);\n    event InversePriceConfigured(bytes4 currencyKey, uint entryPoint, uint upperLimit, uint lowerLimit);\n    event InversePriceFrozen(bytes4 currencyKey);\n}\n\n\n/*\n-----------------------------------------------------------------\nFILE INFORMATION\n-----------------------------------------------------------------\n\nfile:       LimitedSetup.sol\nversion:    1.1\nauthor:     Anton Jurisevic\n\ndate:       2018-05-15\n\n-----------------------------------------------------------------\nMODULE DESCRIPTION\n-----------------------------------------------------------------\n\nA contract with a limited setup period. Any function modified\nwith the setup modifier will cease to work after the\nconclusion of the configurable-length post-construction setup period.\n\n-----------------------------------------------------------------\n*/\n\n\n/**\n * @title Any function decorated with the modifier this contract provides\n * deactivates after a specified setup period.\n */\ncontract LimitedSetup {\n\n    uint setupExpiryTime;\n\n    /**\n     * @dev LimitedSetup Constructor.\n     * @param setupDuration The time the setup period will last for.\n     */\n    constructor(uint setupDuration)\n        public\n    {\n        setupExpiryTime = now + setupDuration;\n    }\n\n    modifier onlyDuringSetup\n    {\n        require(now < setupExpiryTime, \"Can only perform this action during setup\");\n        _;\n    }\n}\n\n\ncontract ISynthetixState {\n    // A struct for handing values associated with an individual user's debt position\n    struct IssuanceData {\n        // Percentage of the total debt owned at the time\n        // of issuance. This number is modified by the global debt\n        // delta array. You can figure out a user's exit price and\n        // collateralisation ratio using a combination of their initial\n        // debt and the slice of global debt delta which applies to them.\n        uint initialDebtOwnership;\n        // This lets us know when (in relative terms) the user entered\n        // the debt pool so we can calculate their exit price and\n        // collateralistion ratio\n        uint debtEntryIndex;\n    }\n\n    uint[] public debtLedger;\n    uint public issuanceRatio;\n    mapping(address => IssuanceData) public issuanceData;\n\n    function debtLedgerLength() external view returns (uint);\n    function hasIssued(address account) external view returns (bool);\n    function incrementTotalIssuerCount() external;\n    function decrementTotalIssuerCount() external;\n    function setCurrentIssuanceData(address account, uint initialDebtOwnership) external;\n    function lastDebtLedgerEntry() external view returns (uint);\n    function appendDebtLedgerValue(uint value) external;\n    function clearIssuanceData(address account) external;\n}\n\n\n/*\n-----------------------------------------------------------------\nFILE INFORMATION\n-----------------------------------------------------------------\n\nfile:       SynthetixState.sol\nversion:    1.0\nauthor:     Kevin Brown\ndate:       2018-10-19\n\n-----------------------------------------------------------------\nMODULE DESCRIPTION\n-----------------------------------------------------------------\n\nA contract that holds issuance state and preferred currency of\nusers in the Synthetix system.\n\nThis contract is used side by side with the Synthetix contract\nto make it easier to upgrade the contract logic while maintaining\nissuance state.\n\nThe Synthetix contract is also quite large and on the edge of\nbeing beyond the contract size limit without moving this information\nout to another contract.\n\nThe first deployed contract would create this state contract,\nusing it as its store of issuance data.\n\nWhen a new contract is deployed, it links to the existing\nstate contract, whose owner would then change its associated\ncontract to the new one.\n\n-----------------------------------------------------------------\n*/\n\n\n/**\\\n * @title Synthetix State\n * @notice Stores issuance information and preferred currency information of the Synthetix contract.\n */\ncontract SynthetixState is ISynthetixState, State, LimitedSetup {\n\n\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    // Issued synth balances for individual fee entitlements and exit price calculations\n    mapping(address => IssuanceData) public issuanceData;\n\n    // The total count of people that have outstanding issued synths in any flavour\n    uint public totalIssuerCount;\n\n    // Global debt pool tracking\n    uint[] public debtLedger;\n\n    // Import state\n    uint public importedXDRAmount;\n\n    // A quantity of synths greater than this ratio\n    // may not be issued against a given value of SNX.\n    uint public issuanceRatio = SafeDecimalMath.unit() / 5;\n    // No more synths may be issued than the value of SNX backing them.\n    uint constant MAX_ISSUANCE_RATIO = SafeDecimalMath.unit();\n\n    // Users can specify their preferred currency, in which case all synths they receive\n    // will automatically exchange to that preferred currency upon receipt in their wallet\n    mapping(address => bytes4) public preferredCurrency;\n\n    /**\n     * @dev Constructor\n     * @param _owner The address which controls this contract.\n     * @param _associatedContract The ERC20 contract whose state this composes.\n     */\n    constructor(address _owner, address _associatedContract)\n        State(_owner, _associatedContract)\n        LimitedSetup(1 weeks)\n        public\n    {}\n\n    /* ========== SETTERS ========== */\n\n    /**\n     * @notice Set issuance data for an address\n     * @dev Only the associated contract may call this.\n     * @param account The address to set the data for.\n     * @param initialDebtOwnership The initial debt ownership for this address.\n     */\n    function setCurrentIssuanceData(address account, uint initialDebtOwnership)\n        external\n        onlyAssociatedContract\n    {\n        issuanceData[account].initialDebtOwnership = initialDebtOwnership;\n        issuanceData[account].debtEntryIndex = debtLedger.length;\n    }\n\n    /**\n     * @notice Clear issuance data for an address\n     * @dev Only the associated contract may call this.\n     * @param account The address to clear the data for.\n     */\n    function clearIssuanceData(address account)\n        external\n        onlyAssociatedContract\n    {\n        delete issuanceData[account];\n    }\n\n    /**\n     * @notice Increment the total issuer count\n     * @dev Only the associated contract may call this.\n     */\n    function incrementTotalIssuerCount()\n        external\n        onlyAssociatedContract\n    {\n        totalIssuerCount = totalIssuerCount.add(1);\n    }\n\n    /**\n     * @notice Decrement the total issuer count\n     * @dev Only the associated contract may call this.\n     */\n    function decrementTotalIssuerCount()\n        external\n        onlyAssociatedContract\n    {\n        totalIssuerCount = totalIssuerCount.sub(1);\n    }\n\n    /**\n     * @notice Append a value to the debt ledger\n     * @dev Only the associated contract may call this.\n     * @param value The new value to be added to the debt ledger.\n     */\n    function appendDebtLedgerValue(uint value)\n        external\n        onlyAssociatedContract\n    {\n        debtLedger.push(value);\n    }\n\n    /**\n     * @notice Set preferred currency for a user\n     * @dev Only the associated contract may call this.\n     * @param account The account to set the preferred currency for\n     * @param currencyKey The new preferred currency\n     */\n    function setPreferredCurrency(address account, bytes4 currencyKey)\n        external\n        onlyAssociatedContract\n    {\n        preferredCurrency[account] = currencyKey;\n    }\n\n    /**\n     * @notice Set the issuanceRatio for issuance calculations.\n     * @dev Only callable by the contract owner.\n     */\n    function setIssuanceRatio(uint _issuanceRatio)\n        external\n        onlyOwner\n    {\n        require(_issuanceRatio <= MAX_ISSUANCE_RATIO, \"New issuance ratio cannot exceed MAX_ISSUANCE_RATIO\");\n        issuanceRatio = _issuanceRatio;\n        emit IssuanceRatioUpdated(_issuanceRatio);\n    }\n\n    /**\n     * @notice Import issuer data from the old Synthetix contract before multicurrency\n     * @dev Only callable by the contract owner, and only for 1 week after deployment.\n     */\n    function importIssuerData(address[] accounts, uint[] sUSDAmounts)\n        external\n        onlyOwner\n        onlyDuringSetup\n    {\n        require(accounts.length == sUSDAmounts.length, \"Length mismatch\");\n\n        for (uint8 i = 0; i < accounts.length; i++) {\n            _addToDebtRegister(accounts[i], sUSDAmounts[i]);\n        }\n    }\n\n    /**\n     * @notice Import issuer data from the old Synthetix contract before multicurrency\n     * @dev Only used from importIssuerData above, meant to be disposable\n     */\n    function _addToDebtRegister(address account, uint amount)\n        internal\n    {\n        // This code is duplicated from Synthetix so that we can call it directly here\n        // during setup only.\n        Synthetix synthetix = Synthetix(associatedContract);\n\n        // What is the value of the requested debt in XDRs?\n        uint xdrValue = synthetix.effectiveValue(\"sUSD\", amount, \"XDR\");\n\n        // What is the value that we've previously imported?\n        uint totalDebtIssued = importedXDRAmount;\n\n        // What will the new total be including the new value?\n        uint newTotalDebtIssued = xdrValue.add(totalDebtIssued);\n\n        // Save that for the next import.\n        importedXDRAmount = newTotalDebtIssued;\n\n        // What is their percentage (as a high precision int) of the total debt?\n        uint debtPercentage = xdrValue.divideDecimalRoundPrecise(newTotalDebtIssued);\n\n        // And what effect does this percentage have on the global debt holding of other issuers?\n        // The delta specifically needs to not take into account any existing debt as it's already\n        // accounted for in the delta from when they issued previously.\n        // The delta is a high precision integer.\n        uint delta = SafeDecimalMath.preciseUnit().sub(debtPercentage);\n\n        uint existingDebt = synthetix.debtBalanceOf(account, \"XDR\");\n\n        // And what does their debt ownership look like including this previous stake?\n        if (existingDebt > 0) {\n            debtPercentage = xdrValue.add(existingDebt).divideDecimalRoundPrecise(newTotalDebtIssued);\n        }\n\n        // Are they a new issuer? If so, record them.\n        if (issuanceData[account].initialDebtOwnership == 0) {\n            totalIssuerCount = totalIssuerCount.add(1);\n        }\n\n        // Save the debt entry parameters\n        issuanceData[account].initialDebtOwnership = debtPercentage;\n        issuanceData[account].debtEntryIndex = debtLedger.length;\n\n        // And if we're the first, push 1 as there was no effect to any other holders, otherwise push\n        // the change for the rest of the debt holders. The debt ledger holds high precision integers.\n        if (debtLedger.length > 0) {\n            debtLedger.push(\n                debtLedger[debtLedger.length - 1].multiplyDecimalRoundPrecise(delta)\n            );\n        } else {\n            debtLedger.push(SafeDecimalMath.preciseUnit());\n        }\n    }\n\n    /* ========== VIEWS ========== */\n\n    /**\n     * @notice Retrieve the length of the debt ledger array\n     */\n    function debtLedgerLength()\n        external\n        view\n        returns (uint)\n    {\n        return debtLedger.length;\n    }\n\n    /**\n     * @notice Retrieve the most recent entry from the debt ledger\n     */\n    function lastDebtLedgerEntry()\n        external\n        view\n        returns (uint)\n    {\n        return debtLedger[debtLedger.length - 1];\n    }\n\n    /**\n     * @notice Query whether an account has issued and has an outstanding debt balance\n     * @param account The address to query for\n     */\n    function hasIssued(address account)\n        external\n        view\n        returns (bool)\n    {\n        return issuanceData[account].initialDebtOwnership > 0;\n    }\n\n    event IssuanceRatioUpdated(uint newRatio);\n}\n\n\ncontract IFeePool {\n    address public FEE_ADDRESS;\n    function amountReceivedFromExchange(uint value) external view returns (uint);\n    function amountReceivedFromTransfer(uint value) external view returns (uint);\n    function feePaid(bytes4 currencyKey, uint amount) external;\n    function appendAccountIssuanceRecord(address account, uint lockedAmount, uint debtEntryIndex) external;\n    function rewardsMinted(uint amount) external;\n    function transferFeeIncurred(uint value) public view returns (uint);\n}\n\n\n/*\n-----------------------------------------------------------------\nFILE INFORMATION\n-----------------------------------------------------------------\n\nfile:       Synth.sol\nversion:    2.0\nauthor:     Kevin Brown\ndate:       2018-09-13\n\n-----------------------------------------------------------------\nMODULE DESCRIPTION\n-----------------------------------------------------------------\n\nSynthetix-backed stablecoin contract.\n\nThis contract issues synths, which are tokens that mirror various\nflavours of fiat currency.\n\nSynths are issuable by Synthetix Network Token (SNX) holders who\nhave to lock up some value of their SNX to issue S * Cmax synths.\nWhere Cmax issome value less than 1.\n\nA configurable fee is charged on synth transfers and deposited\ninto a common pot, which Synthetix holders may withdraw from once\nper fee period.\n\n-----------------------------------------------------------------\n*/\n\n\ncontract Synth is ExternStateToken {\n\n    /* ========== STATE VARIABLES ========== */\n\n    IFeePool public feePool;\n    Synthetix public synthetix;\n\n    // Currency key which identifies this Synth to the Synthetix system\n    bytes4 public currencyKey;\n\n    uint8 constant DECIMALS = 18;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(address _proxy, TokenState _tokenState, Synthetix _synthetix, IFeePool _feePool,\n        string _tokenName, string _tokenSymbol, address _owner, bytes4 _currencyKey\n    )\n        ExternStateToken(_proxy, _tokenState, _tokenName, _tokenSymbol, 0, DECIMALS, _owner)\n        public\n    {\n        require(_proxy != 0, \"_proxy cannot be 0\");\n        require(address(_synthetix) != 0, \"_synthetix cannot be 0\");\n        require(address(_feePool) != 0, \"_feePool cannot be 0\");\n        require(_owner != 0, \"_owner cannot be 0\");\n        require(_synthetix.synths(_currencyKey) == Synth(0), \"Currency key is already in use\");\n\n        feePool = _feePool;\n        synthetix = _synthetix;\n        currencyKey = _currencyKey;\n    }\n\n    /* ========== SETTERS ========== */\n\n    function setSynthetix(Synthetix _synthetix)\n        external\n        optionalProxy_onlyOwner\n    {\n        synthetix = _synthetix;\n        emitSynthetixUpdated(_synthetix);\n    }\n\n    function setFeePool(IFeePool _feePool)\n        external\n        optionalProxy_onlyOwner\n    {\n        feePool = _feePool;\n        emitFeePoolUpdated(_feePool);\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /**\n     * @notice Override ERC20 transfer function in order to\n     * subtract the transaction fee and send it to the fee pool\n     * for SNX holders to claim. */\n    function transfer(address to, uint value)\n        public\n        optionalProxy\n        notFeeAddress(messageSender)\n        returns (bool)\n    {\n        uint amountReceived = feePool.amountReceivedFromTransfer(value);\n        uint fee = value.sub(amountReceived);\n\n        // Send the fee off to the fee pool.\n        synthetix.synthInitiatedFeePayment(messageSender, currencyKey, fee);\n\n        // And send their result off to the destination address\n        bytes memory empty;\n        return _internalTransfer(messageSender, to, amountReceived, empty);\n    }\n\n    /**\n     * @notice Override ERC223 transfer function in order to\n     * subtract the transaction fee and send it to the fee pool\n     * for SNX holders to claim. */\n    function transfer(address to, uint value, bytes data)\n        public\n        optionalProxy\n        notFeeAddress(messageSender)\n        returns (bool)\n    {\n        uint amountReceived = feePool.amountReceivedFromTransfer(value);\n        uint fee = value.sub(amountReceived);\n\n        // Send the fee off to the fee pool, which we don't want to charge an additional fee on\n        synthetix.synthInitiatedFeePayment(messageSender, currencyKey, fee);\n\n        // And send their result off to the destination address\n        return _internalTransfer(messageSender, to, amountReceived, data);\n    }\n\n    /**\n     * @notice Override ERC20 transferFrom function in order to\n     * subtract the transaction fee and send it to the fee pool\n     * for SNX holders to claim. */\n    function transferFrom(address from, address to, uint value)\n        public\n        optionalProxy\n        notFeeAddress(from)\n        returns (bool)\n    {\n        // The fee is deducted from the amount sent.\n        uint amountReceived = feePool.amountReceivedFromTransfer(value);\n        uint fee = value.sub(amountReceived);\n\n        // Reduce the allowance by the amount we're transferring.\n        // The safeSub call will handle an insufficient allowance.\n        tokenState.setAllowance(from, messageSender, tokenState.allowance(from, messageSender).sub(value));\n\n        // Send the fee off to the fee pool.\n        synthetix.synthInitiatedFeePayment(from, currencyKey, fee);\n\n        bytes memory empty;\n        return _internalTransfer(from, to, amountReceived, empty);\n    }\n\n    /**\n     * @notice Override ERC223 transferFrom function in order to\n     * subtract the transaction fee and send it to the fee pool\n     * for SNX holders to claim. */\n    function transferFrom(address from, address to, uint value, bytes data)\n        public\n        optionalProxy\n        notFeeAddress(from)\n        returns (bool)\n    {\n        // The fee is deducted from the amount sent.\n        uint amountReceived = feePool.amountReceivedFromTransfer(value);\n        uint fee = value.sub(amountReceived);\n\n        // Reduce the allowance by the amount we're transferring.\n        // The safeSub call will handle an insufficient allowance.\n        tokenState.setAllowance(from, messageSender, tokenState.allowance(from, messageSender).sub(value));\n\n        // Send the fee off to the fee pool, which we don't want to charge an additional fee on\n        synthetix.synthInitiatedFeePayment(from, currencyKey, fee);\n\n        return _internalTransfer(from, to, amountReceived, data);\n    }\n\n    /* Subtract the transfer fee from the senders account so the\n     * receiver gets the exact amount specified to send. */\n    function transferSenderPaysFee(address to, uint value)\n        public\n        optionalProxy\n        notFeeAddress(messageSender)\n        returns (bool)\n    {\n        uint fee = feePool.transferFeeIncurred(value);\n\n        // Send the fee off to the fee pool, which we don't want to charge an additional fee on\n        synthetix.synthInitiatedFeePayment(messageSender, currencyKey, fee);\n\n        // And send their transfer amount off to the destination address\n        bytes memory empty;\n        return _internalTransfer(messageSender, to, value, empty);\n    }\n\n    /* Subtract the transfer fee from the senders account so the\n     * receiver gets the exact amount specified to send. */\n    function transferSenderPaysFee(address to, uint value, bytes data)\n        public\n        optionalProxy\n        notFeeAddress(messageSender)\n        returns (bool)\n    {\n        uint fee = feePool.transferFeeIncurred(value);\n\n        // Send the fee off to the fee pool, which we don't want to charge an additional fee on\n        synthetix.synthInitiatedFeePayment(messageSender, currencyKey, fee);\n\n        // And send their transfer amount off to the destination address\n        return _internalTransfer(messageSender, to, value, data);\n    }\n\n    /* Subtract the transfer fee from the senders account so the\n     * to address receives the exact amount specified to send. */\n    function transferFromSenderPaysFee(address from, address to, uint value)\n        public\n        optionalProxy\n        notFeeAddress(from)\n        returns (bool)\n    {\n        uint fee = feePool.transferFeeIncurred(value);\n\n        // Reduce the allowance by the amount we're transferring.\n        // The safeSub call will handle an insufficient allowance.\n        tokenState.setAllowance(from, messageSender, tokenState.allowance(from, messageSender).sub(value.add(fee)));\n\n        // Send the fee off to the fee pool, which we don't want to charge an additional fee on\n        synthetix.synthInitiatedFeePayment(from, currencyKey, fee);\n\n        bytes memory empty;\n        return _internalTransfer(from, to, value, empty);\n    }\n\n    /* Subtract the transfer fee from the senders account so the\n     * to address receives the exact amount specified to send. */\n    function transferFromSenderPaysFee(address from, address to, uint value, bytes data)\n        public\n        optionalProxy\n        notFeeAddress(from)\n        returns (bool)\n    {\n        uint fee = feePool.transferFeeIncurred(value);\n\n        // Reduce the allowance by the amount we're transferring.\n        // The safeSub call will handle an insufficient allowance.\n        tokenState.setAllowance(from, messageSender, tokenState.allowance(from, messageSender).sub(value.add(fee)));\n\n        // Send the fee off to the fee pool, which we don't want to charge an additional fee on\n        synthetix.synthInitiatedFeePayment(from, currencyKey, fee);\n\n        return _internalTransfer(from, to, value, data);\n    }\n\n    // Override our internal transfer to inject preferred currency support\n    function _internalTransfer(address from, address to, uint value, bytes data)\n        internal\n        returns (bool)\n    {\n        bytes4 preferredCurrencyKey = synthetix.synthetixState().preferredCurrency(to);\n\n        // Do they have a preferred currency that's not us? If so we need to exchange\n        if (preferredCurrencyKey != 0 && preferredCurrencyKey != currencyKey) {\n            return synthetix.synthInitiatedExchange(from, currencyKey, value, preferredCurrencyKey, to);\n        } else {\n            // Otherwise we just transfer\n            return super._internalTransfer(from, to, value, data);\n        }\n    }\n\n    // Allow synthetix to issue a certain number of synths from an account.\n    function issue(address account, uint amount)\n        external\n        onlySynthetixOrFeePool\n    {\n        tokenState.setBalanceOf(account, tokenState.balanceOf(account).add(amount));\n        totalSupply = totalSupply.add(amount);\n        emitTransfer(address(0), account, amount);\n        emitIssued(account, amount);\n    }\n\n    // Allow synthetix or another synth contract to burn a certain number of synths from an account.\n    function burn(address account, uint amount)\n        external\n        onlySynthetixOrFeePool\n    {\n        tokenState.setBalanceOf(account, tokenState.balanceOf(account).sub(amount));\n        totalSupply = totalSupply.sub(amount);\n        emitTransfer(account, address(0), amount);\n        emitBurned(account, amount);\n    }\n\n    // Allow owner to set the total supply on import.\n    function setTotalSupply(uint amount)\n        external\n        optionalProxy_onlyOwner\n    {\n        totalSupply = amount;\n    }\n\n    // Allow synthetix to trigger a token fallback call from our synths so users get notified on\n    // exchange as well as transfer\n    function triggerTokenFallbackIfNeeded(address sender, address recipient, uint amount)\n        external\n        onlySynthetixOrFeePool\n    {\n        bytes memory empty;\n        callTokenFallbackIfNeeded(sender, recipient, amount, empty);\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlySynthetixOrFeePool() {\n        bool isSynthetix = msg.sender == address(synthetix);\n        bool isFeePool = msg.sender == address(feePool);\n\n        require(isSynthetix || isFeePool, \"Only the Synthetix or FeePool contracts can perform this action\");\n        _;\n    }\n\n    modifier notFeeAddress(address account) {\n        require(account != feePool.FEE_ADDRESS(), \"Cannot perform this action with the fee address\");\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event SynthetixUpdated(address newSynthetix);\n    bytes32 constant SYNTHETIXUPDATED_SIG = keccak256(\"SynthetixUpdated(address)\");\n    function emitSynthetixUpdated(address newSynthetix) internal {\n        proxy._emit(abi.encode(newSynthetix), 1, SYNTHETIXUPDATED_SIG, 0, 0, 0);\n    }\n\n    event FeePoolUpdated(address newFeePool);\n    bytes32 constant FEEPOOLUPDATED_SIG = keccak256(\"FeePoolUpdated(address)\");\n    function emitFeePoolUpdated(address newFeePool) internal {\n        proxy._emit(abi.encode(newFeePool), 1, FEEPOOLUPDATED_SIG, 0, 0, 0);\n    }\n\n    event Issued(address indexed account, uint value);\n    bytes32 constant ISSUED_SIG = keccak256(\"Issued(address,uint256)\");\n    function emitIssued(address account, uint value) internal {\n        proxy._emit(abi.encode(value), 2, ISSUED_SIG, bytes32(account), 0, 0);\n    }\n\n    event Burned(address indexed account, uint value);\n    bytes32 constant BURNED_SIG = keccak256(\"Burned(address,uint256)\");\n    function emitBurned(address account, uint value) internal {\n        proxy._emit(abi.encode(value), 2, BURNED_SIG, bytes32(account), 0, 0);\n    }\n}\n\n\n/**\n * @title SynthetixEscrow interface\n */\ninterface ISynthetixEscrow {\n    function balanceOf(address account) public view returns (uint);\n    function appendVestingEntry(address account, uint quantity) public;\n}\n\n\n/*\n-----------------------------------------------------------------\nFILE INFORMATION\n-----------------------------------------------------------------\n\nfile:       Synthetix.sol\nversion:    2.0\nauthor:     Kevin Brown\n            Gavin Conway\ndate:       2018-09-14\n\n-----------------------------------------------------------------\nMODULE DESCRIPTION\n-----------------------------------------------------------------\n\nSynthetix token contract. SNX is a transferable ERC20 token,\nand also give its holders the following privileges.\nAn owner of SNX has the right to issue synths in all synth flavours.\n\nAfter a fee period terminates, the duration and fees collected for that\nperiod are computed, and the next period begins. Thus an account may only\nwithdraw the fees owed to them for the previous period, and may only do\nso once per period. Any unclaimed fees roll over into the common pot for\nthe next period.\n\n== Average Balance Calculations ==\n\nThe fee entitlement of a synthetix holder is proportional to their average\nissued synth balance over the last fee period. This is computed by\nmeasuring the area under the graph of a user's issued synth balance over\ntime, and then when a new fee period begins, dividing through by the\nduration of the fee period.\n\nWe need only update values when the balances of an account is modified.\nThis occurs when issuing or burning for issued synth balances,\nand when transferring for synthetix balances. This is for efficiency,\nand adds an implicit friction to interacting with SNX.\nA synthetix holder pays for his own recomputation whenever he wants to change\nhis position, which saves the foundation having to maintain a pot dedicated\nto resourcing this.\n\nA hypothetical user's balance history over one fee period, pictorially:\n\n      s ____\n       |    |\n       |    |___ p\n       |____|___|___ __ _  _\n       f    t   n\n\nHere, the balance was s between times f and t, at which time a transfer\noccurred, updating the balance to p, until n, when the present transfer occurs.\nWhen a new transfer occurs at time n, the balance being p,\nwe must:\n\n  - Add the area p * (n - t) to the total area recorded so far\n  - Update the last transfer time to n\n\nSo if this graph represents the entire current fee period,\nthe average SNX held so far is ((t-f)*s + (n-t)*p) / (n-f).\nThe complementary computations must be performed for both sender and\nrecipient.\n\nNote that a transfer keeps global supply of SNX invariant.\nThe sum of all balances is constant, and unmodified by any transfer.\nSo the sum of all balances multiplied by the duration of a fee period is also\nconstant, and this is equivalent to the sum of the area of every user's\ntime/balance graph. Dividing through by that duration yields back the total\nsynthetix supply. So, at the end of a fee period, we really do yield a user's\naverage share in the synthetix supply over that period.\n\nA slight wrinkle is introduced if we consider the time r when the fee period\nrolls over. Then the previous fee period k-1 is before r, and the current fee\nperiod k is afterwards. If the last transfer took place before r,\nbut the latest transfer occurred afterwards:\n\nk-1       |        k\n      s __|_\n       |  | |\n       |  | |____ p\n       |__|_|____|___ __ _  _\n          |\n       f  | t    n\n          r\n\nIn this situation the area (r-f)*s contributes to fee period k-1, while\nthe area (t-r)*s contributes to fee period k. We will implicitly consider a\nzero-value transfer to have occurred at time r. Their fee entitlement for the\nprevious period will be finalised at the time of their first transfer during the\ncurrent fee period, or when they query or withdraw their fee entitlement.\n\nIn the implementation, the duration of different fee periods may be slightly irregular,\nas the check that they have rolled over occurs only when state-changing synthetix\noperations are performed.\n\n== Issuance and Burning ==\n\nIn this version of the synthetix contract, synths can only be issued by\nthose that have been nominated by the synthetix foundation. Synths are assumed\nto be valued at $1, as they are a stable unit of account.\n\nAll synths issued require a proportional value of SNX to be locked,\nwhere the proportion is governed by the current issuance ratio. This\nmeans for every $1 of SNX locked up, $(issuanceRatio) synths can be issued.\ni.e. to issue 100 synths, 100/issuanceRatio dollars of SNX need to be locked up.\n\nTo determine the value of some amount of SNX(S), an oracle is used to push\nthe price of SNX (P_S) in dollars to the contract. The value of S\nwould then be: S * P_S.\n\nAny SNX that are locked up by this issuance process cannot be transferred.\nThe amount that is locked floats based on the price of SNX. If the price\nof SNX moves up, less SNX are locked, so they can be issued against,\nor transferred freely. If the price of SNX moves down, more SNX are locked,\neven going above the initial wallet balance.\n\n-----------------------------------------------------------------\n*/\n\n\n/**\n * @title Synthetix ERC20 contract.\n * @notice The Synthetix contracts not only facilitates transfers, exchanges, and tracks balances,\n * but it also computes the quantity of fees each synthetix holder is entitled to.\n */\ncontract Synthetix is ExternStateToken {\n\n    // ========== STATE VARIABLES ==========\n\n    // Available Synths which can be used with the system\n    Synth[] public availableSynths;\n    mapping(bytes4 => Synth) public synths;\n\n    IFeePool public feePool;\n    ISynthetixEscrow public escrow;\n    ISynthetixEscrow public rewardEscrow;\n    ExchangeRates public exchangeRates;\n    SynthetixState public synthetixState;\n    SupplySchedule public supplySchedule;\n\n    uint constant SYNTHETIX_SUPPLY = 1e8 * SafeDecimalMath.unit();\n    string constant TOKEN_NAME = \"Synthetix Network Token\";\n    string constant TOKEN_SYMBOL = \"SNX\";\n    uint8 constant DECIMALS = 18;\n    // ========== CONSTRUCTOR ==========\n\n    /**\n     * @dev Constructor\n     * @param _tokenState A pre-populated contract containing token balances.\n     * If the provided address is 0x0, then a fresh one will be constructed with the contract owning all tokens.\n     * @param _owner The owner of this contract.\n     */\n    constructor(address _proxy, TokenState _tokenState, SynthetixState _synthetixState,\n        address _owner, ExchangeRates _exchangeRates, IFeePool _feePool, SupplySchedule _supplySchedule,\n        ISynthetixEscrow _rewardEscrow, ISynthetixEscrow _escrow\n    )\n        ExternStateToken(_proxy, _tokenState, TOKEN_NAME, TOKEN_SYMBOL, SYNTHETIX_SUPPLY, DECIMALS, _owner)\n        public\n    {\n        synthetixState = _synthetixState;\n        exchangeRates = _exchangeRates;\n        feePool = _feePool;\n        supplySchedule = _supplySchedule;\n        rewardEscrow = _rewardEscrow;\n        escrow = _escrow;\n    }\n    // ========== SETTERS ========== */\n\n    function setFeePool(IFeePool _feePool)\n        external\n        optionalProxy_onlyOwner\n    {\n        feePool = _feePool;\n    }\n\n    function setExchangeRates(ExchangeRates _exchangeRates)\n        external\n        optionalProxy_onlyOwner\n    {\n        exchangeRates = _exchangeRates;\n    }\n\n    /**\n     * @notice Add an associated Synth contract to the Synthetix system\n     * @dev Only the contract owner may call this.\n     */\n    function addSynth(Synth synth)\n        external\n        optionalProxy_onlyOwner\n    {\n        bytes4 currencyKey = synth.currencyKey();\n\n        require(synths[currencyKey] == Synth(0), \"Synth already exists\");\n\n        availableSynths.push(synth);\n        synths[currencyKey] = synth;\n    }\n\n    /**\n     * @notice Remove an associated Synth contract from the Synthetix system\n     * @dev Only the contract owner may call this.\n     */\n    function removeSynth(bytes4 currencyKey)\n        external\n        optionalProxy_onlyOwner\n    {\n        require(synths[currencyKey] != address(0), \"Synth does not exist\");\n        require(synths[currencyKey].totalSupply() == 0, \"Synth supply exists\");\n        require(currencyKey != \"XDR\", \"Cannot remove XDR synth\");\n\n        // Save the address we're removing for emitting the event at the end.\n        address synthToRemove = synths[currencyKey];\n\n        // Remove the synth from the availableSynths array.\n        for (uint8 i = 0; i < availableSynths.length; i++) {\n            if (availableSynths[i] == synthToRemove) {\n                delete availableSynths[i];\n\n                // Copy the last synth into the place of the one we just deleted\n                // If there's only one synth, this is synths[0] = synths[0].\n                // If we're deleting the last one, it's also a NOOP in the same way.\n                availableSynths[i] = availableSynths[availableSynths.length - 1];\n\n                // Decrease the size of the array by one.\n                availableSynths.length--;\n\n                break;\n            }\n        }\n\n        // And remove it from the synths mapping\n        delete synths[currencyKey];\n\n        // Note: No event here as our contract exceeds max contract size\n        // with these events, and it's unlikely people will need to\n        // track these events specifically.\n    }\n\n    // ========== VIEWS ==========\n\n    /**\n     * @notice A function that lets you easily convert an amount in a source currency to an amount in the destination currency\n     * @param sourceCurrencyKey The currency the amount is specified in\n     * @param sourceAmount The source amount, specified in UNIT base\n     * @param destinationCurrencyKey The destination currency\n     */\n    function effectiveValue(bytes4 sourceCurrencyKey, uint sourceAmount, bytes4 destinationCurrencyKey)\n        public\n        view\n        rateNotStale(sourceCurrencyKey)\n        rateNotStale(destinationCurrencyKey)\n        returns (uint)\n    {\n        // If there's no change in the currency, then just return the amount they gave us\n        if (sourceCurrencyKey == destinationCurrencyKey) return sourceAmount;\n\n        // Calculate the effective value by going from source -> USD -> destination\n        return sourceAmount.multiplyDecimalRound(exchangeRates.rateForCurrency(sourceCurrencyKey))\n            .divideDecimalRound(exchangeRates.rateForCurrency(destinationCurrencyKey));\n    }\n\n    /**\n     * @notice Total amount of synths issued by the system, priced in currencyKey\n     * @param currencyKey The currency to value the synths in\n     */\n    function totalIssuedSynths(bytes4 currencyKey)\n        public\n        view\n        rateNotStale(currencyKey)\n        returns (uint)\n    {\n        uint total = 0;\n        uint currencyRate = exchangeRates.rateForCurrency(currencyKey);\n\n        require(!exchangeRates.anyRateIsStale(availableCurrencyKeys()), \"Rates are stale\");\n\n        for (uint8 i = 0; i < availableSynths.length; i++) {\n            // What's the total issued value of that synth in the destination currency?\n            // Note: We're not using our effectiveValue function because we don't want to go get the\n            //       rate for the destination currency and check if it's stale repeatedly on every\n            //       iteration of the loop\n            uint synthValue = availableSynths[i].totalSupply()\n                .multiplyDecimalRound(exchangeRates.rateForCurrency(availableSynths[i].currencyKey()))\n                .divideDecimalRound(currencyRate);\n            total = total.add(synthValue);\n        }\n\n        return total;\n    }\n\n    /**\n     * @notice Returns the currencyKeys of availableSynths for rate checking\n     */\n    function availableCurrencyKeys()\n        internal\n        view\n        returns (bytes4[])\n    {\n        bytes4[] memory availableCurrencyKeys = new bytes4[](availableSynths.length);\n\n        for (uint8 i = 0; i < availableSynths.length; i++) {\n            availableCurrencyKeys[i] = availableSynths[i].currencyKey();\n        }\n\n        return availableCurrencyKeys;\n    }\n\n    /**\n     * @notice Returns the count of available synths in the system, which you can use to iterate availableSynths\n     */\n    function availableSynthCount()\n        public\n        view\n        returns (uint)\n    {\n        return availableSynths.length;\n    }\n\n    // ========== MUTATIVE FUNCTIONS ==========\n\n    /**\n     * @notice ERC20 transfer function.\n     */\n    function transfer(address to, uint value)\n        public\n        returns (bool)\n    {\n        bytes memory empty;\n        return transfer(to, value, empty);\n    }\n\n    /**\n     * @notice ERC223 transfer function. Does not conform with the ERC223 spec, as:\n     *         - Transaction doesn't revert if the recipient doesn't implement tokenFallback()\n     *         - Emits a standard ERC20 event without the bytes data parameter so as not to confuse\n     *           tooling such as Etherscan.\n     */\n    function transfer(address to, uint value, bytes data)\n        public\n        optionalProxy\n        returns (bool)\n    {\n        // Ensure they're not trying to exceed their locked amount\n        require(value <= transferableSynthetix(messageSender), \"Insufficient balance\");\n\n        // Perform the transfer: if there is a problem an exception will be thrown in this call.\n        _transfer_byProxy(messageSender, to, value, data);\n\n        return true;\n    }\n\n    /**\n     * @notice ERC20 transferFrom function.\n     */\n    function transferFrom(address from, address to, uint value)\n        public\n        returns (bool)\n    {\n        bytes memory empty;\n        return transferFrom(from, to, value, empty);\n    }\n\n    /**\n     * @notice ERC223 transferFrom function. Does not conform with the ERC223 spec, as:\n     *         - Transaction doesn't revert if the recipient doesn't implement tokenFallback()\n     *         - Emits a standard ERC20 event without the bytes data parameter so as not to confuse\n     *           tooling such as Etherscan.\n     */\n    function transferFrom(address from, address to, uint value, bytes data)\n        public\n        optionalProxy\n        returns (bool)\n    {\n        // Ensure they're not trying to exceed their locked amount\n        require(value <= transferableSynthetix(from), \"Insufficient balance\");\n\n        // Perform the transfer: if there is a problem,\n        // an exception will be thrown in this call.\n        _transferFrom_byProxy(messageSender, from, to, value, data);\n\n        return true;\n    }\n\n    /**\n     * @notice Function that allows you to exchange synths you hold in one flavour for another.\n     * @param sourceCurrencyKey The source currency you wish to exchange from\n     * @param sourceAmount The amount, specified in UNIT of source currency you wish to exchange\n     * @param destinationCurrencyKey The destination currency you wish to obtain.\n     * @param destinationAddress Where the result should go. If this is address(0) then it sends back to the message sender.\n     * @return Boolean that indicates whether the transfer succeeded or failed.\n     */\n    function exchange(bytes4 sourceCurrencyKey, uint sourceAmount, bytes4 destinationCurrencyKey, address destinationAddress)\n        external\n        optionalProxy\n        // Note: We don't need to insist on non-stale rates because effectiveValue will do it for us.\n        returns (bool)\n    {\n        require(sourceCurrencyKey != destinationCurrencyKey, \"Exchange must use different synths\");\n        require(sourceAmount > 0, \"Zero amount\");\n\n        // Pass it along, defaulting to the sender as the recipient.\n        return _internalExchange(\n            messageSender,\n            sourceCurrencyKey,\n            sourceAmount,\n            destinationCurrencyKey,\n            destinationAddress == address(0) ? messageSender : destinationAddress,\n            true // Charge fee on the exchange\n        );\n    }\n\n    /**\n     * @notice Function that allows synth contract to delegate exchanging of a synth that is not the same sourceCurrency\n     * @dev Only the synth contract can call this function\n     * @param from The address to exchange / burn synth from\n     * @param sourceCurrencyKey The source currency you wish to exchange from\n     * @param sourceAmount The amount, specified in UNIT of source currency you wish to exchange\n     * @param destinationCurrencyKey The destination currency you wish to obtain.\n     * @param destinationAddress Where the result should go.\n     * @return Boolean that indicates whether the transfer succeeded or failed.\n     */\n    function synthInitiatedExchange(\n        address from,\n        bytes4 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes4 destinationCurrencyKey,\n        address destinationAddress\n    )\n        external\n        onlySynth\n        returns (bool)\n    {\n        require(sourceCurrencyKey != destinationCurrencyKey, \"Can't be same synth\");\n        require(sourceAmount > 0, \"Zero amount\");\n\n        // Pass it along\n        return _internalExchange(\n            from,\n            sourceCurrencyKey,\n            sourceAmount,\n            destinationCurrencyKey,\n            destinationAddress,\n            false // Don't charge fee on the exchange, as they've already been charged a transfer fee in the synth contract\n        );\n    }\n\n    /**\n     * @notice Function that allows synth contract to delegate sending fee to the fee Pool.\n     * @dev Only the synth contract can call this function.\n     * @param from The address fee is coming from.\n     * @param sourceCurrencyKey source currency fee from.\n     * @param sourceAmount The amount, specified in UNIT of source currency.\n     * @return Boolean that indicates whether the transfer succeeded or failed.\n     */\n    function synthInitiatedFeePayment(\n        address from,\n        bytes4 sourceCurrencyKey,\n        uint sourceAmount\n    )\n        external\n        onlySynth\n        returns (bool)\n    {\n        // Allow fee to be 0 and skip minting XDRs to feePool\n        if (sourceAmount == 0) {\n            return true;\n        }\n\n        require(sourceAmount > 0, \"Source can't be 0\");\n\n        // Pass it along, defaulting to the sender as the recipient.\n        bool result = _internalExchange(\n            from,\n            sourceCurrencyKey,\n            sourceAmount,\n            \"XDR\",\n            feePool.FEE_ADDRESS(),\n            false // Don't charge a fee on the exchange because this is already a fee\n        );\n\n        // Tell the fee pool about this.\n        feePool.feePaid(sourceCurrencyKey, sourceAmount);\n\n        return result;\n    }\n\n    /**\n     * @notice Function that allows synth contract to delegate sending fee to the fee Pool.\n     * @dev fee pool contract address is not allowed to call function\n     * @param from The address to move synth from\n     * @param sourceCurrencyKey source currency from.\n     * @param sourceAmount The amount, specified in UNIT of source currency.\n     * @param destinationCurrencyKey The destination currency to obtain.\n     * @param destinationAddress Where the result should go.\n     * @param chargeFee Boolean to charge a fee for transaction.\n     * @return Boolean that indicates whether the transfer succeeded or failed.\n     */\n    function _internalExchange(\n        address from,\n        bytes4 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes4 destinationCurrencyKey,\n        address destinationAddress,\n        bool chargeFee\n    )\n        internal\n        notFeeAddress(from)\n        returns (bool)\n    {\n        require(destinationAddress != address(0), \"Zero destination\");\n        require(destinationAddress != address(this), \"Synthetix is invalid destination\");\n        require(destinationAddress != address(proxy), \"Proxy is invalid destination\");\n\n        // Note: We don't need to check their balance as the burn() below will do a safe subtraction which requires\n        // the subtraction to not overflow, which would happen if their balance is not sufficient.\n\n        // Burn the source amount\n        synths[sourceCurrencyKey].burn(from, sourceAmount);\n\n        // How much should they get in the destination currency?\n        uint destinationAmount = effectiveValue(sourceCurrencyKey, sourceAmount, destinationCurrencyKey);\n\n        // What's the fee on that currency that we should deduct?\n        uint amountReceived = destinationAmount;\n        uint fee = 0;\n\n        if (chargeFee) {\n            amountReceived = feePool.amountReceivedFromExchange(destinationAmount);\n            fee = destinationAmount.sub(amountReceived);\n        }\n\n        // Issue their new synths\n        synths[destinationCurrencyKey].issue(destinationAddress, amountReceived);\n\n        // Remit the fee in XDRs\n        if (fee > 0) {\n            uint xdrFeeAmount = effectiveValue(destinationCurrencyKey, fee, \"XDR\");\n            synths[\"XDR\"].issue(feePool.FEE_ADDRESS(), xdrFeeAmount);\n            // Tell the fee pool about this.\n            feePool.feePaid(\"XDR\", xdrFeeAmount);\n        }\n\n        // Nothing changes as far as issuance data goes because the total value in the system hasn't changed.\n\n        // Call the ERC223 transfer callback if needed\n        synths[destinationCurrencyKey].triggerTokenFallbackIfNeeded(from, destinationAddress, amountReceived);\n\n        //Let the DApps know there was a Synth exchange\n        emitSynthExchange(from, sourceCurrencyKey, sourceAmount, destinationCurrencyKey, amountReceived, destinationAddress);\n\n        return true;\n    }\n\n    /**\n     * @notice Function that registers new synth as they are isseud. Calculate delta to append to synthetixState.\n     * @dev Only internal calls from synthetix address.\n     * @param currencyKey The currency to register synths in, for example sUSD or sAUD\n     * @param amount The amount of synths to register with a base of UNIT\n     */\n    function _addToDebtRegister(bytes4 currencyKey, uint amount)\n        internal\n        optionalProxy\n    {\n        // What is the value of the requested debt in XDRs?\n        uint xdrValue = effectiveValue(currencyKey, amount, \"XDR\");\n\n        // What is the value of all issued synths of the system (priced in XDRs)?\n        uint totalDebtIssued = totalIssuedSynths(\"XDR\");\n\n        // What will the new total be including the new value?\n        uint newTotalDebtIssued = xdrValue.add(totalDebtIssued);\n\n        // What is their percentage (as a high precision int) of the total debt?\n        uint debtPercentage = xdrValue.divideDecimalRoundPrecise(newTotalDebtIssued);\n\n        // And what effect does this percentage change have on the global debt holding of other issuers?\n        // The delta specifically needs to not take into account any existing debt as it's already\n        // accounted for in the delta from when they issued previously.\n        // The delta is a high precision integer.\n        uint delta = SafeDecimalMath.preciseUnit().sub(debtPercentage);\n\n        // How much existing debt do they have?\n        uint existingDebt = debtBalanceOf(messageSender, \"XDR\");\n\n        // And what does their debt ownership look like including this previous stake?\n        if (existingDebt > 0) {\n            debtPercentage = xdrValue.add(existingDebt).divideDecimalRoundPrecise(newTotalDebtIssued);\n        }\n\n        // Are they a new issuer? If so, record them.\n        if (!synthetixState.hasIssued(messageSender)) {\n            synthetixState.incrementTotalIssuerCount();\n        }\n\n        // Save the debt entry parameters\n        synthetixState.setCurrentIssuanceData(messageSender, debtPercentage);\n\n        // And if we're the first, push 1 as there was no effect to any other holders, otherwise push\n        // the change for the rest of the debt holders. The debt ledger holds high precision integers.\n        if (synthetixState.debtLedgerLength() > 0) {\n            synthetixState.appendDebtLedgerValue(\n                synthetixState.lastDebtLedgerEntry().multiplyDecimalRoundPrecise(delta)\n            );\n        } else {\n            synthetixState.appendDebtLedgerValue(SafeDecimalMath.preciseUnit());\n        }\n    }\n\n    /**\n     * @notice Issue synths against the sender's SNX.\n     * @dev Issuance is only allowed if the synthetix price isn't stale. Amount should be larger than 0.\n     * @param currencyKey The currency you wish to issue synths in, for example sUSD or sAUD\n     * @param amount The amount of synths you wish to issue with a base of UNIT\n     */\n    function issueSynths(bytes4 currencyKey, uint amount)\n        public\n        optionalProxy\n        // No need to check if price is stale, as it is checked in issuableSynths.\n    {\n        require(amount <= remainingIssuableSynths(messageSender, currencyKey), \"Amount too large\");\n\n        // Keep track of the debt they're about to create\n        _addToDebtRegister(currencyKey, amount);\n\n        // Create their synths\n        synths[currencyKey].issue(messageSender, amount);\n\n        // Store their locked SNX amount to determine their fee % for the period\n        _appendAccountIssuanceRecord();\n    }\n\n    /**\n     * @notice Issue the maximum amount of Synths possible against the sender's SNX.\n     * @dev Issuance is only allowed if the synthetix price isn't stale.\n     * @param currencyKey The currency you wish to issue synths in, for example sUSD or sAUD\n     */\n    function issueMaxSynths(bytes4 currencyKey)\n        external\n        optionalProxy\n    {\n        // Figure out the maximum we can issue in that currency\n        uint maxIssuable = remainingIssuableSynths(messageSender, currencyKey);\n\n        // And issue them\n        issueSynths(currencyKey, maxIssuable);\n    }\n\n    /**\n     * @notice Burn synths to clear issued synths/free SNX.\n     * @param currencyKey The currency you're specifying to burn\n     * @param amount The amount (in UNIT base) you wish to burn\n     * @dev The amount to burn is debased to XDR's\n     */\n    function burnSynths(bytes4 currencyKey, uint amount)\n        external\n        optionalProxy\n        // No need to check for stale rates as effectiveValue checks rates\n    {\n        // How much debt do they have?\n        uint debtToRemove = effectiveValue(currencyKey, amount, \"XDR\");\n        uint debt = debtBalanceOf(messageSender, \"XDR\");\n        uint debtInCurrencyKey = debtBalanceOf(messageSender, currencyKey);\n\n        require(debt > 0, \"No debt to forgive\");\n\n        // If they're trying to burn more debt than they actually owe, rather than fail the transaction, let's just\n        // clear their debt and leave them be.\n        uint amountToRemove = debt < debtToRemove ? debt : debtToRemove;\n\n        // Remove their debt from the ledger\n        _removeFromDebtRegister(amountToRemove);\n\n        uint amountToBurn = debtInCurrencyKey < amount ? debtInCurrencyKey : amount;\n\n        // synth.burn does a safe subtraction on balance (so it will revert if there are not enough synths).\n        synths[currencyKey].burn(messageSender, amountToBurn);\n\n        // Store their debtRatio against a feeperiod to determine their fee/rewards % for the period\n        _appendAccountIssuanceRecord();\n    }\n\n    /**\n     * @notice Store in the FeePool the users current debt value in the system in XDRs.\n     * @dev debtBalanceOf(messageSender, \"XDR\") to be used with totalIssuedSynths(\"XDR\") to get\n     *  users % of the system within a feePeriod.\n     */\n    function _appendAccountIssuanceRecord()\n        internal\n    {\n        uint initialDebtOwnership;\n        uint debtEntryIndex;\n        (initialDebtOwnership, debtEntryIndex) = synthetixState.issuanceData(messageSender);\n\n        feePool.appendAccountIssuanceRecord(\n            messageSender,\n            initialDebtOwnership,\n            debtEntryIndex\n        );\n    }\n\n    /**\n     * @notice Remove a debt position from the register\n     * @param amount The amount (in UNIT base) being presented in XDRs\n     */\n    function _removeFromDebtRegister(uint amount)\n        internal\n    {\n        uint debtToRemove = amount;\n\n        // How much debt do they have?\n        uint existingDebt = debtBalanceOf(messageSender, \"XDR\");\n\n        // What is the value of all issued synths of the system (priced in XDRs)?\n        uint totalDebtIssued = totalIssuedSynths(\"XDR\");\n\n        // What will the new total after taking out the withdrawn amount\n        uint newTotalDebtIssued = totalDebtIssued.sub(debtToRemove);\n\n        uint delta;\n\n        // What will the debt delta be if there is any debt left?\n        // Set delta to 0 if no more debt left in system after user\n        if (newTotalDebtIssued > 0) {\n\n            // What is the percentage of the withdrawn debt (as a high precision int) of the total debt after?\n            uint debtPercentage = debtToRemove.divideDecimalRoundPrecise(newTotalDebtIssued);\n\n            // And what effect does this percentage change have on the global debt holding of other issuers?\n            // The delta specifically needs to not take into account any existing debt as it's already\n            // accounted for in the delta from when they issued previously.\n            delta = SafeDecimalMath.preciseUnit().add(debtPercentage);\n        } else {\n            delta = 0;\n        }\n\n        // Are they exiting the system, or are they just decreasing their debt position?\n        if (debtToRemove == existingDebt) {\n            synthetixState.setCurrentIssuanceData(messageSender, 0);\n            synthetixState.decrementTotalIssuerCount();\n        } else {\n            // What percentage of the debt will they be left with?\n            uint newDebt = existingDebt.sub(debtToRemove);\n            uint newDebtPercentage = newDebt.divideDecimalRoundPrecise(newTotalDebtIssued);\n\n            // Store the debt percentage and debt ledger as high precision integers\n            synthetixState.setCurrentIssuanceData(messageSender, newDebtPercentage);\n        }\n\n        // Update our cumulative ledger. This is also a high precision integer.\n        synthetixState.appendDebtLedgerValue(\n            synthetixState.lastDebtLedgerEntry().multiplyDecimalRoundPrecise(delta)\n        );\n    }\n\n    // ========== Issuance/Burning ==========\n\n    /**\n     * @notice The maximum synths an issuer can issue against their total synthetix quantity, priced in XDRs.\n     * This ignores any already issued synths, and is purely giving you the maximimum amount the user can issue.\n     */\n    function maxIssuableSynths(address issuer, bytes4 currencyKey)\n        public\n        view\n        // We don't need to check stale rates here as effectiveValue will do it for us.\n        returns (uint)\n    {\n        // What is the value of their SNX balance in the destination currency?\n        uint destinationValue = effectiveValue(\"SNX\", collateral(issuer), currencyKey);\n\n        // They're allowed to issue up to issuanceRatio of that value\n        return destinationValue.multiplyDecimal(synthetixState.issuanceRatio());\n    }\n\n    /**\n     * @notice The current collateralisation ratio for a user. Collateralisation ratio varies over time\n     * as the value of the underlying Synthetix asset changes, e.g. if a user issues their maximum available\n     * synths when they hold $10 worth of Synthetix, they will have issued $2 worth of synths. If the value\n     * of Synthetix changes, the ratio returned by this function will adjust accordlingly. Users are\n     * incentivised to maintain a collateralisation ratio as close to the issuance ratio as possible by\n     * altering the amount of fees they're able to claim from the system.\n     */\n    function collateralisationRatio(address issuer)\n        public\n        view\n        returns (uint)\n    {\n        uint totalOwnedSynthetix = collateral(issuer);\n        if (totalOwnedSynthetix == 0) return 0;\n\n        uint debtBalance = debtBalanceOf(issuer, \"SNX\");\n        return debtBalance.divideDecimalRound(totalOwnedSynthetix);\n    }\n\n    /**\n     * @notice If a user issues synths backed by SNX in their wallet, the SNX become locked. This function\n     * will tell you how many synths a user has to give back to the system in order to unlock their original\n     * debt position. This is priced in whichever synth is passed in as a currency key, e.g. you can price\n     * the debt in sUSD, XDR, or any other synth you wish.\n     */\n    function debtBalanceOf(address issuer, bytes4 currencyKey)\n        public\n        view\n        // Don't need to check for stale rates here because totalIssuedSynths will do it for us\n        returns (uint)\n    {\n        // What was their initial debt ownership?\n        uint initialDebtOwnership;\n        uint debtEntryIndex;\n        (initialDebtOwnership, debtEntryIndex) = synthetixState.issuanceData(issuer);\n\n        // If it's zero, they haven't issued, and they have no debt.\n        if (initialDebtOwnership == 0) return 0;\n\n        // Figure out the global debt percentage delta from when they entered the system.\n        // This is a high precision integer.\n        uint currentDebtOwnership = synthetixState.lastDebtLedgerEntry()\n            .divideDecimalRoundPrecise(synthetixState.debtLedger(debtEntryIndex))\n            .multiplyDecimalRoundPrecise(initialDebtOwnership);\n\n        // What's the total value of the system in their requested currency?\n        uint totalSystemValue = totalIssuedSynths(currencyKey);\n\n        // Their debt balance is their portion of the total system value.\n        uint highPrecisionBalance = totalSystemValue.decimalToPreciseDecimal()\n            .multiplyDecimalRoundPrecise(currentDebtOwnership);\n\n        return highPrecisionBalance.preciseDecimalToDecimal();\n    }\n\n    /**\n     * @notice The remaining synths an issuer can issue against their total synthetix balance.\n     * @param issuer The account that intends to issue\n     * @param currencyKey The currency to price issuable value in\n     */\n    function remainingIssuableSynths(address issuer, bytes4 currencyKey)\n        public\n        view\n        // Don't need to check for synth existing or stale rates because maxIssuableSynths will do it for us.\n        returns (uint)\n    {\n        uint alreadyIssued = debtBalanceOf(issuer, currencyKey);\n        uint max = maxIssuableSynths(issuer, currencyKey);\n\n        if (alreadyIssued >= max) {\n            return 0;\n        } else {\n            return max.sub(alreadyIssued);\n        }\n    }\n\n    /**\n     * @notice The total SNX owned by this account, both escrowed and unescrowed,\n     * against which synths can be issued.\n     * This includes those already being used as collateral (locked), and those\n     * available for further issuance (unlocked).\n     */\n    function collateral(address account)\n        public\n        view\n        returns (uint)\n    {\n        uint balance = tokenState.balanceOf(account);\n\n        if (escrow != address(0)) {\n            balance = balance.add(escrow.balanceOf(account));\n        }\n\n        if (rewardEscrow != address(0)) {\n            balance = balance.add(rewardEscrow.balanceOf(account));\n        }\n\n        return balance;\n    }\n\n    /**\n     * @notice The number of SNX that are free to be transferred by an account.\n     * @dev When issuing, escrowed SNX are locked first, then non-escrowed\n     * SNX are locked last, but escrowed SNX are not transferable, so they are not included\n     * in this calculation.\n     */\n    function transferableSynthetix(address account)\n        public\n        view\n        rateNotStale(\"SNX\")\n        returns (uint)\n    {\n        // How many SNX do they have, excluding escrow?\n        // Note: We're excluding escrow here because we're interested in their transferable amount\n        // and escrowed SNX are not transferable.\n        uint balance = tokenState.balanceOf(account);\n\n        // How many of those will be locked by the amount they've issued?\n        // Assuming issuance ratio is 20%, then issuing 20 SNX of value would require\n        // 100 SNX to be locked in their wallet to maintain their collateralisation ratio\n        // The locked synthetix value can exceed their balance.\n        uint lockedSynthetixValue = debtBalanceOf(account, \"SNX\").divideDecimalRound(synthetixState.issuanceRatio());\n\n        // If we exceed the balance, no SNX are transferable, otherwise the difference is.\n        if (lockedSynthetixValue >= balance) {\n            return 0;\n        } else {\n            return balance.sub(lockedSynthetixValue);\n        }\n    }\n\n    function mint()\n        external\n        returns (bool)\n    {\n        require(rewardEscrow != address(0), \"Reward Escrow destination missing\");\n\n        uint supplyToMint = supplySchedule.mintableSupply();\n        require(supplyToMint > 0, \"No supply is mintable\");\n\n        supplySchedule.updateMintValues();\n\n        // Set minted SNX balance to RewardEscrow's balance\n        // Minus the minterReward and set balance of minter to add reward\n        uint minterReward = supplySchedule.minterReward();\n\n        tokenState.setBalanceOf(rewardEscrow, tokenState.balanceOf(rewardEscrow).add(supplyToMint.sub(minterReward)));\n        emitTransfer(this, rewardEscrow, supplyToMint.sub(minterReward));\n\n        // Tell the FeePool how much it has to distribute\n        feePool.rewardsMinted(supplyToMint.sub(minterReward));\n\n        // Assign the minters reward.\n        tokenState.setBalanceOf(msg.sender, tokenState.balanceOf(msg.sender).add(minterReward));\n        emitTransfer(this, msg.sender, minterReward);\n\n        totalSupply = totalSupply.add(supplyToMint);\n    }\n\n    // ========== MODIFIERS ==========\n\n    modifier rateNotStale(bytes4 currencyKey) {\n        require(!exchangeRates.rateIsStale(currencyKey), \"Rate stale or nonexistant currency\");\n        _;\n    }\n\n    modifier notFeeAddress(address account) {\n        require(account != feePool.FEE_ADDRESS(), \"Fee address not allowed\");\n        _;\n    }\n\n    modifier onlySynth() {\n        bool isSynth = false;\n\n        // No need to repeatedly call this function either\n        for (uint8 i = 0; i < availableSynths.length; i++) {\n            if (availableSynths[i] == msg.sender) {\n                isSynth = true;\n                break;\n            }\n        }\n\n        require(isSynth, \"Only synth allowed\");\n        _;\n    }\n\n    modifier nonZeroAmount(uint _amount) {\n        require(_amount > 0, \"Amount needs to be larger than 0\");\n        _;\n    }\n\n    // ========== EVENTS ==========\n    /* solium-disable */\n    event SynthExchange(address indexed account, bytes4 fromCurrencyKey, uint256 fromAmount, bytes4 toCurrencyKey,  uint256 toAmount, address toAddress);\n    bytes32 constant SYNTHEXCHANGE_SIG = keccak256(\"SynthExchange(address,bytes4,uint256,bytes4,uint256,address)\");\n    function emitSynthExchange(address account, bytes4 fromCurrencyKey, uint256 fromAmount, bytes4 toCurrencyKey, uint256 toAmount, address toAddress) internal {\n        proxy._emit(abi.encode(fromCurrencyKey, fromAmount, toCurrencyKey, toAmount, toAddress), 2, SYNTHEXCHANGE_SIG, bytes32(account), 0, 0);\n    }\n    /* solium-enable */\n}\n\n\n/*\n-----------------------------------------------------------------\nFILE INFORMATION\n-----------------------------------------------------------------\n\nfile:       FeePoolState.sol\nversion:    1.0\nauthor:     Clinton Ennis\n            Jackson Chan\ndate:       2019-04-05\n\n-----------------------------------------------------------------\nMODULE DESCRIPTION\n-----------------------------------------------------------------\n\nThe FeePoolState simply stores the accounts issuance ratio for\neach fee period in the FeePool.\n\nThis is use to caclulate the correct allocation of fees/rewards\nowed to minters of the stablecoin total supply\n\n-----------------------------------------------------------------\n*/\n\n\ncontract FeePoolState is SelfDestructible, LimitedSetup {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    /* ========== STATE VARIABLES ========== */\n\n    uint8 constant public FEE_PERIOD_LENGTH = 6;\n\n    address public feePool;\n\n    // The IssuanceData activity that's happened in a fee period.\n    struct IssuanceData {\n        uint debtPercentage;\n        uint debtEntryIndex;\n    }\n\n    // The IssuanceData activity that's happened in a fee period.\n    mapping(address => IssuanceData[FEE_PERIOD_LENGTH]) public accountIssuanceLedger;\n\n    /**\n     * @dev Constructor.\n     * @param _owner The owner of this contract.\n     */\n    constructor(address _owner, IFeePool _feePool)\n        SelfDestructible(_owner)\n        LimitedSetup(6 weeks)\n        public\n    {\n        feePool = _feePool;\n    }\n\n    /* ========== SETTERS ========== */\n\n    /**\n     * @notice set the FeePool contract as it is the only authority to be able to call\n     * appendAccountIssuanceRecord with the onlyFeePool modifer\n     * @dev Must be set by owner when FeePool logic is upgraded\n     */\n    function setFeePool(IFeePool _feePool)\n        external\n        onlyOwner\n    {\n        feePool = _feePool;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /**\n     * @notice Get an accounts issuanceData for\n     * @param account users account\n     * @param index Index in the array to retrieve. Upto FEE_PERIOD_LENGTH\n     */\n    function getAccountsDebtEntry(address account, uint index)\n        public\n        view\n        returns (uint debtPercentage, uint debtEntryIndex)\n    {\n        require(index < FEE_PERIOD_LENGTH, \"index exceeds the FEE_PERIOD_LENGTH\");\n\n        debtPercentage = accountIssuanceLedger[account][index].debtPercentage;\n        debtEntryIndex = accountIssuanceLedger[account][index].debtEntryIndex;\n    }\n\n    /**\n     * @notice Find the oldest debtEntryIndex for the corresponding closingDebtIndex\n     * @param account users account\n     * @param closingDebtIndex the last periods debt index on close\n     */\n    function applicableIssuanceData(address account, uint closingDebtIndex)\n        external\n        view\n        returns (uint, uint)\n    {\n        IssuanceData[FEE_PERIOD_LENGTH] memory issuanceData = accountIssuanceLedger[account];\n        \n        // We want to use the user's debtEntryIndex at when the period closed\n        // Find the oldest debtEntryIndex for the corresponding closingDebtIndex\n        for (uint i = 0; i < FEE_PERIOD_LENGTH; i++) {\n            if (closingDebtIndex >= issuanceData[i].debtEntryIndex) {\n                return (issuanceData[i].debtPercentage, issuanceData[i].debtEntryIndex);\n            }\n        }\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /**\n     * @notice Logs an accounts issuance data in the current fee period which is then stored historically\n     * @param account Message.Senders account address\n     * @param debtRatio Debt percentage this account has locked after minting or burning their synth\n     * @param debtEntryIndex The index in the global debt ledger. synthetix.synthetixState().issuanceData(account)\n     * @param currentPeriodStartDebtIndex The startingDebtIndex of the current fee period\n     * @dev onlyFeePool to call me on synthetix.issue() & synthetix.burn() calls to store the locked SNX\n     * per fee period so we know to allocate the correct proportions of fees and rewards per period\n      accountIssuanceLedger[account][0] has the latest locked amount for the current period. This can be update as many time\n      accountIssuanceLedger[account][1-3] has the last locked amount for a previous period they minted or burned\n     */\n    function appendAccountIssuanceRecord(address account, uint debtRatio, uint debtEntryIndex, uint currentPeriodStartDebtIndex)\n        external\n        onlyFeePool\n    {\n        // Is the current debtEntryIndex within this fee period\n        if (accountIssuanceLedger[account][0].debtEntryIndex < currentPeriodStartDebtIndex) {\n             // If its older then shift the previous IssuanceData entries periods down to make room for the new one.\n            issuanceDataIndexOrder(account);\n        }\n        \n        // Always store the latest IssuanceData entry at [0]\n        accountIssuanceLedger[account][0].debtPercentage = debtRatio;\n        accountIssuanceLedger[account][0].debtEntryIndex = debtEntryIndex;\n    }\n\n    /**\n     * @notice Pushes down the entire array of debt ratios per fee period\n     */\n    function issuanceDataIndexOrder(address account)\n        private\n    {\n        for (uint i = FEE_PERIOD_LENGTH - 2; i < FEE_PERIOD_LENGTH; i--) {\n            uint next = i + 1;\n            accountIssuanceLedger[account][next].debtPercentage = accountIssuanceLedger[account][i].debtPercentage;\n            accountIssuanceLedger[account][next].debtEntryIndex = accountIssuanceLedger[account][i].debtEntryIndex;\n        }\n    }\n\n    /**\n     * @notice Import issuer data from synthetixState.issuerData on FeePeriodClose() block #\n     * @dev Only callable by the contract owner, and only for 6 weeks after deployment.\n     * @param accounts Array of issuing addresses\n     * @param ratios Array of debt ratios\n     * @param periodToInsert The Fee Period to insert the historical records into\n     * @param feePeriodCloseIndex An accounts debtEntryIndex is valid when within the fee peroid,\n     * since the input ratio will be an average of the pervious periods it just needs to be\n     * > recentFeePeriods[periodToInsert].startingDebtIndex\n     * < recentFeePeriods[periodToInsert - 1].startingDebtIndex\n     */\n    function importIssuerData(address[] accounts, uint[] ratios, uint periodToInsert, uint feePeriodCloseIndex)\n        external\n        onlyOwner\n        onlyDuringSetup\n    {\n        require(accounts.length == ratios.length, \"Length mismatch\");\n\n        for (uint8 i = 0; i < accounts.length; i++) {\n            accountIssuanceLedger[accounts[i]][periodToInsert].debtPercentage = ratios[i];\n            accountIssuanceLedger[accounts[i]][periodToInsert].debtEntryIndex = feePeriodCloseIndex;\n            emit IssuanceDebtRatioEntry(accounts[i], ratios[i], feePeriodCloseIndex);\n        }\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyFeePool\n    {\n        require(msg.sender == address(feePool), \"Only the FeePool contract can perform this action\");\n        _;\n    }\n\n    /* ========== Events ========== */\n    event IssuanceDebtRatioEntry(address indexed account, uint debtRatio, uint feePeriodCloseIndex);\n}\n\n\n/*\n-----------------------------------------------------------------\nFILE INFORMATION\n-----------------------------------------------------------------\n\nfile:       EternalStorage.sol\nversion:    1.0\nauthor:     Clinton Ennise\n            Jackson Chan\n\ndate:       2019-02-01\n\n-----------------------------------------------------------------\nMODULE DESCRIPTION\n-----------------------------------------------------------------\n\nThis contract is used with external state storage contracts for\ndecoupled data storage.\n\nImplements support for storing a keccak256 key and value pairs. It is\nthe more flexible and extensible option. This ensures data schema\nchanges can be implemented without requiring upgrades to the\nstorage contract\n\nThe first deployed storage contract would create this eternal storage.\nFavour use of keccak256 key over sha3 as future version of solidity\n> 0.5.0 will be deprecated.\n\n-----------------------------------------------------------------\n*/\n\n\n/**\n * @notice  This contract is based on the code available from this blog\n * https://blog.colony.io/writing-upgradeable-contracts-in-solidity-6743f0eecc88/\n * Implements support for storing a keccak256 key and value pairs. It is the more flexible\n * and extensible option. This ensures data schema changes can be implemented without\n * requiring upgrades to the storage contract.\n */\ncontract EternalStorage is State {\n\n    constructor(address _owner, address _associatedContract)\n        State(_owner, _associatedContract)\n        public\n    {\n    }\n\n    /* ========== DATA TYPES ========== */\n    mapping(bytes32 => uint) UIntStorage;\n    mapping(bytes32 => string) StringStorage;\n    mapping(bytes32 => address) AddressStorage;\n    mapping(bytes32 => bytes) BytesStorage;\n    mapping(bytes32 => bytes32) Bytes32Storage;\n    mapping(bytes32 => bool) BooleanStorage;\n    mapping(bytes32 => int) IntStorage;\n\n    // UIntStorage;\n    function getUIntValue(bytes32 record) external view returns (uint){\n        return UIntStorage[record];\n    }\n\n    function setUIntValue(bytes32 record, uint value) external\n        onlyAssociatedContract\n    {\n        UIntStorage[record] = value;\n    }\n\n    function deleteUIntValue(bytes32 record) external\n        onlyAssociatedContract\n    {\n        delete UIntStorage[record];\n    }\n\n    // StringStorage\n    function getStringValue(bytes32 record) external view returns (string memory){\n        return StringStorage[record];\n    }\n\n    function setStringValue(bytes32 record, string value) external\n        onlyAssociatedContract\n    {\n        StringStorage[record] = value;\n    }\n\n    function deleteStringValue(bytes32 record) external\n        onlyAssociatedContract\n    {\n        delete StringStorage[record];\n    }\n\n    // AddressStorage\n    function getAddressValue(bytes32 record) external view returns (address){\n        return AddressStorage[record];\n    }\n\n    function setAddressValue(bytes32 record, address value) external\n        onlyAssociatedContract\n    {\n        AddressStorage[record] = value;\n    }\n\n    function deleteAddressValue(bytes32 record) external\n        onlyAssociatedContract\n    {\n        delete AddressStorage[record];\n    }\n\n\n    // BytesStorage\n    function getBytesValue(bytes32 record) external view returns\n    (bytes memory){\n        return BytesStorage[record];\n    }\n\n    function setBytesValue(bytes32 record, bytes value) external\n        onlyAssociatedContract\n    {\n        BytesStorage[record] = value;\n    }\n\n    function deleteBytesValue(bytes32 record) external\n        onlyAssociatedContract\n    {\n        delete BytesStorage[record];\n    }\n\n    // Bytes32Storage\n    function getBytes32Value(bytes32 record) external view returns (bytes32)\n    {\n        return Bytes32Storage[record];\n    }\n\n    function setBytes32Value(bytes32 record, bytes32 value) external\n        onlyAssociatedContract\n    {\n        Bytes32Storage[record] = value;\n    }\n\n    function deleteBytes32Value(bytes32 record) external\n        onlyAssociatedContract\n    {\n        delete Bytes32Storage[record];\n    }\n\n    // BooleanStorage\n    function getBooleanValue(bytes32 record) external view returns (bool)\n    {\n        return BooleanStorage[record];\n    }\n\n    function setBooleanValue(bytes32 record, bool value) external\n        onlyAssociatedContract\n    {\n        BooleanStorage[record] = value;\n    }\n\n    function deleteBooleanValue(bytes32 record) external\n        onlyAssociatedContract\n    {\n        delete BooleanStorage[record];\n    }\n\n    // IntStorage\n    function getIntValue(bytes32 record) external view returns (int){\n        return IntStorage[record];\n    }\n\n    function setIntValue(bytes32 record, int value) external\n        onlyAssociatedContract\n    {\n        IntStorage[record] = value;\n    }\n\n    function deleteIntValue(bytes32 record) external\n        onlyAssociatedContract\n    {\n        delete IntStorage[record];\n    }\n}\n\n/*\n-----------------------------------------------------------------\nFILE INFORMATION\n-----------------------------------------------------------------\n\nfile:       FeePoolEternalStorage.sol\nversion:    1.0\nauthor:     Clinton Ennis\n            Jackson Chan\ndate:       2019-04-05\n\n-----------------------------------------------------------------\nMODULE DESCRIPTION\n-----------------------------------------------------------------\n\nThe FeePoolEternalStorage is for any state the FeePool contract\nneeds to persist between upgrades to the FeePool logic.\n\nPlease see EternalStorage.sol\n\n-----------------------------------------------------------------\n*/\n\n\ncontract FeePoolEternalStorage is EternalStorage, LimitedSetup {\n\n    bytes32 constant LAST_FEE_WITHDRAWAL = \"last_fee_withdrawal\";\n\n    /**\n     * @dev Constructor.\n     * @param _owner The owner of this contract.\n     */\n    constructor(address _owner, address _feePool)\n        EternalStorage(_owner, _feePool)\n        LimitedSetup(6 weeks)\n        public\n    {\n    }\n\n    /**\n     * @notice Import data from FeePool.lastFeeWithdrawal\n     * @dev Only callable by the contract owner, and only for 6 weeks after deployment.\n     * @param accounts Array of addresses that have claimed\n     * @param feePeriodIDs Array feePeriodIDs with the accounts last claim\n     */\n    function importFeeWithdrawalData(address[] accounts, uint[] feePeriodIDs)\n        external\n        onlyOwner\n        onlyDuringSetup\n    {\n        require(accounts.length == feePeriodIDs.length, \"Length mismatch\");\n\n        for (uint8 i = 0; i < accounts.length; i++) {\n            this.setUIntValue(keccak256(abi.encodePacked(LAST_FEE_WITHDRAWAL, accounts[i])), feePeriodIDs[i]);\n        }\n    }\n}\n\n\n/*\n-----------------------------------------------------------------\nFILE INFORMATION\n-----------------------------------------------------------------\n\nfile:       DelegateApprovals.sol\nversion:    1.0\nauthor:     Jackson Chan\nchecked:    Clinton Ennis\ndate:       2019-05-01\n\n-----------------------------------------------------------------\nMODULE DESCRIPTION\n-----------------------------------------------------------------\n\nThe approval state contract is designed to allow a wallet to\nauthorise another address to perform actions, on a contract,\non their behalf. This could be an automated service\nthat would help a wallet claim fees / rewards on their behalf.\n\nThe concept is similar to the ERC20 interface where a wallet can\napprove an authorised party to spend on the authorising party's\nbehalf in the allowance interface.\n\nWithdrawing approval sets the delegate as false instead of\nremoving from the approvals list for auditability.\n\nThis contract inherits state for upgradeability / associated\ncontract.\n\n-----------------------------------------------------------------\n*/\n\n\ncontract DelegateApprovals is State {\n\n    // Approvals - [authoriser][delegate]\n    // Each authoriser can have multiple delegates\n    mapping(address => mapping(address => bool)) public approval;\n\n    /**\n     * @dev Constructor\n     * @param _owner The address which controls this contract.\n     * @param _associatedContract The contract whose approval state this composes.\n     */\n    constructor(address _owner, address _associatedContract)\n        State(_owner, _associatedContract)\n        public\n    {}\n\n    function setApproval(address authoriser, address delegate)\n        external\n        onlyAssociatedContract\n    {\n        approval[authoriser][delegate] = true;\n        emit Approval(authoriser, delegate);\n    }\n\n    function withdrawApproval(address authoriser, address delegate)\n        external\n        onlyAssociatedContract\n    {\n        delete approval[authoriser][delegate];\n        emit WithdrawApproval(authoriser, delegate);\n    }\n\n     /* ========== EVENTS ========== */\n\n    event Approval(address indexed authoriser, address delegate);\n    event WithdrawApproval(address indexed authoriser, address delegate);\n}\n\n\n/*\n-----------------------------------------------------------------\nFILE INFORMATION\n-----------------------------------------------------------------\n\nfile:       FeePool.sol\nversion:    1.0\nauthor:     Kevin Brown\ndate:       2018-10-15\n\n-----------------------------------------------------------------\nMODULE DESCRIPTION\n-----------------------------------------------------------------\n\nThe FeePool is a place for users to interact with the fees that\nhave been generated from the Synthetix system if they've helped\nto create the economy.\n\nUsers stake Synthetix to create Synths. As Synth users transact,\na small fee is deducted from exchange transactions, which collects\nin the fee pool. Fees are immediately converted to XDRs, a type\nof reserve currency similar to SDRs used by the IMF:\nhttps://www.imf.org/en/About/Factsheets/Sheets/2016/08/01/14/51/Special-Drawing-Right-SDR\n\nUsers are entitled to withdraw fees from periods that they participated\nin fully, e.g. they have to stake before the period starts. They\ncan withdraw fees for the last 6 periods as a single lump sum.\nCurrently fee periods are 7 days long, meaning it's assumed\nusers will withdraw their fees approximately once a month. Fees\nwhich are not withdrawn are redistributed to the whole pool,\nenabling these non-claimed fees to go back to the rest of the commmunity.\n\nFees can be withdrawn in any synth currency.\n\n-----------------------------------------------------------------\n*/\n\n\ncontract FeePool is Proxyable, SelfDestructible, LimitedSetup {\n\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    Synthetix public synthetix;\n    ISynthetixState public synthetixState;\n    ISynthetixEscrow public rewardEscrow;\n    FeePoolEternalStorage public feePoolEternalStorage;\n\n    // A percentage fee charged on each transfer.\n    uint public transferFeeRate;\n\n    // Transfer fee may not exceed 10%.\n    uint constant public MAX_TRANSFER_FEE_RATE = SafeDecimalMath.unit() / 10;\n\n    // A percentage fee charged on each exchange between currencies.\n    uint public exchangeFeeRate;\n\n    // Exchange fee may not exceed 10%.\n    uint constant public MAX_EXCHANGE_FEE_RATE = SafeDecimalMath.unit() / 10;\n\n    // The address with the authority to distribute fees.\n    address public feeAuthority;\n\n    // The address to the FeePoolState Contract.\n    FeePoolState public feePoolState;\n\n    // The address to the DelegateApproval contract.\n    DelegateApprovals public delegates;\n\n    // Where fees are pooled in XDRs.\n    address public constant FEE_ADDRESS = 0xfeEFEEfeefEeFeefEEFEEfEeFeefEEFeeFEEFEeF;\n\n    // This struct represents the issuance activity that's happened in a fee period.\n    struct FeePeriod {\n        uint feePeriodId;\n        uint startingDebtIndex;\n        uint startTime;\n        uint feesToDistribute;\n        uint feesClaimed;\n        uint rewardsToDistribute;\n        uint rewardsClaimed;\n    }\n\n    // The last 6 fee periods are all that you can claim from.\n    // These are stored and managed from [0], such that [0] is always\n    // the most recent fee period, and [5] is always the oldest fee\n    // period that users can claim for.\n    uint8 constant public FEE_PERIOD_LENGTH = 6;\n\n    FeePeriod[FEE_PERIOD_LENGTH] public recentFeePeriods;\n\n    // How long a fee period lasts at a minimum. It is required for the\n    // fee authority to roll over the periods, so they are not guaranteed\n    // to roll over at exactly this duration, but the contract enforces\n    // that they cannot roll over any quicker than this duration.\n    uint public feePeriodDuration = 1 weeks;\n    // The fee period must be between 1 day and 60 days.\n    uint public constant MIN_FEE_PERIOD_DURATION = 1 days;\n    uint public constant MAX_FEE_PERIOD_DURATION = 60 days;\n\n    // Users receive penalties if their collateralisation ratio drifts out of our desired brackets\n    // We precompute the brackets and penalties to save gas.\n    uint constant TWENTY_PERCENT = (20 * SafeDecimalMath.unit()) / 100;\n    uint constant TWENTY_TWO_PERCENT = (22 * SafeDecimalMath.unit()) / 100;\n    uint constant TWENTY_FIVE_PERCENT = (25 * SafeDecimalMath.unit()) / 100;\n    uint constant THIRTY_PERCENT = (30 * SafeDecimalMath.unit()) / 100;\n    uint constant FOURTY_PERCENT = (40 * SafeDecimalMath.unit()) / 100;\n    uint constant FIFTY_PERCENT = (50 * SafeDecimalMath.unit()) / 100;\n    uint constant SEVENTY_FIVE_PERCENT = (75 * SafeDecimalMath.unit()) / 100;\n    uint constant NINETY_PERCENT = (90 * SafeDecimalMath.unit()) / 100;\n    uint constant ONE_HUNDRED_PERCENT = (100 * SafeDecimalMath.unit()) / 100;\n\n    /* ========== ETERNAL STORAGE CONSTANTS ========== */\n\n    bytes32 constant LAST_FEE_WITHDRAWAL = \"last_fee_withdrawal\";\n\n    constructor(\n        address _proxy,\n        address _owner,\n        Synthetix _synthetix,\n        FeePoolState _feePoolState,\n        FeePoolEternalStorage _feePoolEternalStorage,\n        ISynthetixState _synthetixState,\n        ISynthetixEscrow _rewardEscrow,\n        address _feeAuthority,\n        uint _transferFeeRate,\n        uint _exchangeFeeRate)\n        SelfDestructible(_owner)\n        Proxyable(_proxy, _owner)\n        LimitedSetup(3 weeks)\n        public\n    {\n        // Constructed fee rates should respect the maximum fee rates.\n        require(_transferFeeRate <= MAX_TRANSFER_FEE_RATE, \"Constructed transfer fee rate should respect the maximum fee rate\");\n        require(_exchangeFeeRate <= MAX_EXCHANGE_FEE_RATE, \"Constructed exchange fee rate should respect the maximum fee rate\");\n\n        synthetix = _synthetix;\n        feePoolState = _feePoolState;\n        feePoolEternalStorage = _feePoolEternalStorage;\n        rewardEscrow = _rewardEscrow;\n        synthetixState = _synthetixState;\n        feeAuthority = _feeAuthority;\n        transferFeeRate = _transferFeeRate;\n        exchangeFeeRate = _exchangeFeeRate;\n\n        // Set our initial fee period\n        recentFeePeriods[0].feePeriodId = 1;\n        recentFeePeriods[0].startTime = now;\n    }\n\n    /**\n     * @notice Logs an accounts issuance data per fee period\n     * @param account Message.Senders account address\n     * @param debtRatio Debt percentage this account has locked after minting or burning their synth\n     * @param debtEntryIndex The index in the global debt ledger. synthetix.synthetixState().issuanceData(account)\n     * @dev onlySynthetix to call me on synthetix.issue() & synthetix.burn() calls to store the locked SNX\n     * per fee period so we know to allocate the correct proportions of fees and rewards per period\n     */\n    function appendAccountIssuanceRecord(address account, uint debtRatio, uint debtEntryIndex)\n        external\n        onlySynthetix\n    {\n        feePoolState.appendAccountIssuanceRecord(account, debtRatio, debtEntryIndex, recentFeePeriods[0].startingDebtIndex);\n\n        emitIssuanceDebtRatioEntry(account, debtRatio, debtEntryIndex, recentFeePeriods[0].startingDebtIndex);\n    }\n\n    /**\n     * @notice Set the exchange fee, anywhere within the range 0-10%.\n     * @dev The fee rate is in decimal format, with UNIT being the value of 100%.\n     */\n    function setExchangeFeeRate(uint _exchangeFeeRate)\n        external\n        optionalProxy_onlyOwner\n    {\n        require(_exchangeFeeRate <= MAX_EXCHANGE_FEE_RATE, \"Exchange fee rate must be below MAX_EXCHANGE_FEE_RATE\");\n\n        exchangeFeeRate = _exchangeFeeRate;\n\n        emitExchangeFeeUpdated(_exchangeFeeRate);\n    }\n\n    /**\n     * @notice Set the transfer fee, anywhere within the range 0-10%.\n     * @dev The fee rate is in decimal format, with UNIT being the value of 100%.\n     */\n    function setTransferFeeRate(uint _transferFeeRate)\n        external\n        optionalProxy_onlyOwner\n    {\n        require(_transferFeeRate <= MAX_TRANSFER_FEE_RATE, \"Transfer fee rate must be below MAX_TRANSFER_FEE_RATE\");\n\n        transferFeeRate = _transferFeeRate;\n\n        emitTransferFeeUpdated(_transferFeeRate);\n    }\n\n    /**\n     * @notice Set the address of the user/contract responsible for collecting or\n     * distributing fees.\n     */\n    function setFeeAuthority(address _feeAuthority)\n        external\n        optionalProxy_onlyOwner\n    {\n        feeAuthority = _feeAuthority;\n\n        emitFeeAuthorityUpdated(_feeAuthority);\n    }\n\n    /**\n     * @notice Set the address of the contract for feePool state\n     */\n    function setFeePoolState(FeePoolState _feePoolState)\n        external\n        optionalProxy_onlyOwner\n    {\n        feePoolState = _feePoolState;\n\n        emitFeePoolStateUpdated(_feePoolState);\n    }\n\n    /**\n     * @notice Set the address of the contract for delegate approvals\n     */\n    function setDelegateApprovals(DelegateApprovals _delegates)\n        external\n        optionalProxy_onlyOwner\n    {\n        delegates = _delegates;\n\n        emitDelegateApprovalsUpdated(_delegates);\n    }\n\n    /**\n     * @notice Set the fee period duration\n     */\n    function setFeePeriodDuration(uint _feePeriodDuration)\n        external\n        optionalProxy_onlyOwner\n    {\n        require(_feePeriodDuration >= MIN_FEE_PERIOD_DURATION, \"New fee period cannot be less than minimum fee period duration\");\n        require(_feePeriodDuration <= MAX_FEE_PERIOD_DURATION, \"New fee period cannot be greater than maximum fee period duration\");\n\n        feePeriodDuration = _feePeriodDuration;\n\n        emitFeePeriodDurationUpdated(_feePeriodDuration);\n    }\n\n    /**\n     * @notice Set the synthetix contract\n     */\n    function setSynthetix(Synthetix _synthetix)\n        external\n        optionalProxy_onlyOwner\n    {\n        require(address(_synthetix) != address(0), \"New Synthetix must be non-zero\");\n\n        synthetix = _synthetix;\n\n        emitSynthetixUpdated(_synthetix);\n    }\n\n    /**\n     * @notice The Synthetix contract informs us when fees are paid.\n     */\n    function feePaid(bytes4 currencyKey, uint amount)\n        external\n        onlySynthetix\n    {\n        uint xdrAmount;\n\n        if (currencyKey != \"XDR\") {\n            xdrAmount = synthetix.effectiveValue(currencyKey, amount, \"XDR\");\n        } else {\n            xdrAmount = amount;\n        }\n\n        // Keep track of in XDRs in our fee pool.\n        recentFeePeriods[0].feesToDistribute = recentFeePeriods[0].feesToDistribute.add(xdrAmount);\n    }\n\n    /**\n     * @notice The Synthetix contract informs us when SNX Rewards are minted to RewardEscrow to be claimed.\n     */\n    function rewardsMinted(uint amount)\n        external\n        onlySynthetix\n    {\n        // Add the newly minted SNX rewards on top of the rolling unclaimed amount\n        recentFeePeriods[0].rewardsToDistribute = recentFeePeriods[0].rewardsToDistribute.add(amount);\n    }\n\n    /**\n     * @notice Close the current fee period and start a new one. Only callable by the fee authority.\n     */\n    function closeCurrentFeePeriod()\n        external\n        optionalProxy_onlyFeeAuthority\n    {\n        require(recentFeePeriods[0].startTime <= (now - feePeriodDuration), \"It is too early to close the current fee period\");\n\n        FeePeriod memory secondLastFeePeriod = recentFeePeriods[FEE_PERIOD_LENGTH - 2];\n        FeePeriod memory lastFeePeriod = recentFeePeriods[FEE_PERIOD_LENGTH - 1];\n\n        // Any unclaimed fees from the last period in the array roll back one period.\n        // Because of the subtraction here, they're effectively proportionally redistributed to those who\n        // have already claimed from the old period, available in the new period.\n        // The subtraction is important so we don't create a ticking time bomb of an ever growing\n        // number of fees that can never decrease and will eventually overflow at the end of the fee pool.\n        recentFeePeriods[FEE_PERIOD_LENGTH - 2].feesToDistribute = lastFeePeriod.feesToDistribute\n            .sub(lastFeePeriod.feesClaimed)\n            .add(secondLastFeePeriod.feesToDistribute);\n        recentFeePeriods[FEE_PERIOD_LENGTH - 2].rewardsToDistribute = lastFeePeriod.rewardsToDistribute\n            .sub(lastFeePeriod.rewardsClaimed)\n            .add(secondLastFeePeriod.rewardsToDistribute);\n\n        // Shift the previous fee periods across to make room for the new one.\n        // Condition checks for overflow when uint subtracts one from zero\n        // Could be written with int instead of uint, but then we have to convert everywhere\n        // so it felt better from a gas perspective to just change the condition to check\n        // for overflow after subtracting one from zero.\n        for (uint i = FEE_PERIOD_LENGTH - 2; i < FEE_PERIOD_LENGTH; i--) {\n            uint next = i + 1;\n            recentFeePeriods[next].feePeriodId = recentFeePeriods[i].feePeriodId;\n            recentFeePeriods[next].startingDebtIndex = recentFeePeriods[i].startingDebtIndex;\n            recentFeePeriods[next].startTime = recentFeePeriods[i].startTime;\n            recentFeePeriods[next].feesToDistribute = recentFeePeriods[i].feesToDistribute;\n            recentFeePeriods[next].feesClaimed = recentFeePeriods[i].feesClaimed;\n            recentFeePeriods[next].rewardsToDistribute = recentFeePeriods[i].rewardsToDistribute;\n            recentFeePeriods[next].rewardsClaimed = recentFeePeriods[i].rewardsClaimed;\n        }\n\n        // Clear the first element of the array to make sure we don't have any stale values.\n        delete recentFeePeriods[0];\n\n        // Open up the new fee period. Take a snapshot of the total value of the system.\n        // Increment periodId from the recent closed period feePeriodId\n        recentFeePeriods[0].feePeriodId = recentFeePeriods[1].feePeriodId.add(1);\n        recentFeePeriods[0].startingDebtIndex = synthetixState.debtLedgerLength();\n        recentFeePeriods[0].startTime = now;\n\n        emitFeePeriodClosed(recentFeePeriods[1].feePeriodId);\n    }\n\n    /**\n    * @notice Claim fees for last period when available or not already withdrawn.\n    * @param currencyKey Synth currency you wish to receive the fees in.\n    */\n    function claimFees(bytes4 currencyKey)\n        external\n        optionalProxy\n        returns (bool)\n    {\n        return _claimFees(messageSender, currencyKey);\n    }\n\n    function claimOnBehalf(address claimingForAddress, bytes4 currencyKey)\n        external\n        optionalProxy\n        returns (bool)\n    {\n        require(delegates.approval(claimingForAddress, messageSender), \"Not approved to claim on behalf this address\");\n\n        return _claimFees(claimingForAddress, currencyKey);\n    }\n\n    function _claimFees(address claimingAddress, bytes4 currencyKey)\n        internal\n        returns (bool)\n    {\n        uint availableFees;\n        uint availableRewards;\n        (availableFees, availableRewards) = feesAvailable(claimingAddress, \"XDR\");\n\n        require(availableFees > 0 || availableRewards > 0, \"No fees or rewards available for period, or fees already claimed\");\n\n        _setLastFeeWithdrawal(claimingAddress, recentFeePeriods[1].feePeriodId);\n\n        if (availableFees > 0) {\n            // Record the fee payment in our recentFeePeriods\n            uint feesPaid = _recordFeePayment(availableFees);\n\n            // Send them their fees\n            _payFees(claimingAddress, feesPaid, currencyKey);\n\n            emitFeesClaimed(claimingAddress, feesPaid);\n        }\n\n        if (availableRewards > 0) {\n            // Record the reward payment in our recentFeePeriods\n            uint rewardPaid = _recordRewardPayment(availableRewards);\n\n            // Send them their rewards\n            _payRewards(claimingAddress, rewardPaid);\n\n            emitRewardsClaimed(claimingAddress, rewardPaid);\n        }\n\n        return true;\n    }\n\n    function importFeePeriod(\n        uint feePeriodIndex, uint feePeriodId, uint startingDebtIndex, uint startTime,\n        uint feesToDistribute, uint feesClaimed, uint rewardsToDistribute, uint rewardsClaimed)\n        public\n        optionalProxy_onlyOwner\n        onlyDuringSetup\n    {\n        recentFeePeriods[feePeriodIndex].feePeriodId = feePeriodId;\n        recentFeePeriods[feePeriodIndex].startingDebtIndex = startingDebtIndex;\n        recentFeePeriods[feePeriodIndex].startTime = startTime;\n        recentFeePeriods[feePeriodIndex].feesToDistribute = feesToDistribute;\n        recentFeePeriods[feePeriodIndex].feesClaimed = feesClaimed;\n        recentFeePeriods[feePeriodIndex].rewardsToDistribute = rewardsToDistribute;\n        recentFeePeriods[feePeriodIndex].rewardsClaimed = rewardsClaimed;\n    }\n\n    function approveClaimOnBehalf(address account)\n        public\n        optionalProxy\n    {\n        require(delegates != address(0), \"Delegates Approval destination missing\");\n        require(account != address(0), \"Can't delegate to address(0)\");\n        delegates.setApproval(messageSender, account);\n    }\n\n    function removeClaimOnBehalf(address account)\n        public\n        optionalProxy\n    {\n        require(delegates != address(0), \"Delegates Approval destination missing\");\n        delegates.withdrawApproval(messageSender, account);\n    }\n\n    /**\n     * @notice Record the fee payment in our recentFeePeriods.\n     * @param xdrAmount The amount of fees priced in XDRs.\n     */\n    function _recordFeePayment(uint xdrAmount)\n        internal\n        returns (uint)\n    {\n        // Don't assign to the parameter\n        uint remainingToAllocate = xdrAmount;\n\n        uint feesPaid;\n        // Start at the oldest period and record the amount, moving to newer periods\n        // until we've exhausted the amount.\n        // The condition checks for overflow because we're going to 0 with an unsigned int.\n        for (uint i = FEE_PERIOD_LENGTH - 1; i < FEE_PERIOD_LENGTH; i--) {\n            uint delta = recentFeePeriods[i].feesToDistribute.sub(recentFeePeriods[i].feesClaimed);\n\n            if (delta > 0) {\n                // Take the smaller of the amount left to claim in the period and the amount we need to allocate\n                uint amountInPeriod = delta < remainingToAllocate ? delta : remainingToAllocate;\n\n                recentFeePeriods[i].feesClaimed = recentFeePeriods[i].feesClaimed.add(amountInPeriod);\n                remainingToAllocate = remainingToAllocate.sub(amountInPeriod);\n                feesPaid = feesPaid.add(amountInPeriod);\n\n                // No need to continue iterating if we've recorded the whole amount;\n                if (remainingToAllocate == 0) return feesPaid;\n\n                // We've exhausted feePeriods to distribute and no fees remain in last period\n                // User last to claim would in this scenario have their remainder slashed\n                if (i == 0 && remainingToAllocate > 0) {\n                    remainingToAllocate = 0;\n                }\n            }\n        }\n\n        return feesPaid;\n    }\n\n    /**\n     * @notice Record the reward payment in our recentFeePeriods.\n     * @param snxAmount The amount of SNX tokens.\n     */\n    function _recordRewardPayment(uint snxAmount)\n        internal\n        returns (uint)\n    {\n        // Don't assign to the parameter\n        uint remainingToAllocate = snxAmount;\n\n        uint rewardPaid;\n\n        // Start at the oldest period and record the amount, moving to newer periods\n        // until we've exhausted the amount.\n        // The condition checks for overflow because we're going to 0 with an unsigned int.\n        for (uint i = FEE_PERIOD_LENGTH - 1; i < FEE_PERIOD_LENGTH; i--) {\n            uint toDistribute = recentFeePeriods[i].rewardsToDistribute.sub(recentFeePeriods[i].rewardsClaimed);\n\n            if (toDistribute > 0) {\n                // Take the smaller of the amount left to claim in the period and the amount we need to allocate\n                uint amountInPeriod = toDistribute < remainingToAllocate ? toDistribute : remainingToAllocate;\n\n                recentFeePeriods[i].rewardsClaimed = recentFeePeriods[i].rewardsClaimed.add(amountInPeriod);\n                remainingToAllocate = remainingToAllocate.sub(amountInPeriod);\n                rewardPaid = rewardPaid.add(amountInPeriod);\n\n                // No need to continue iterating if we've recorded the whole amount;\n                if (remainingToAllocate == 0) return rewardPaid;\n\n                // We've exhausted feePeriods to distribute and no rewards remain in last period\n                // User last to claim would in this scenario have their remainder slashed\n                // due to rounding up of PreciseDecimal\n                if (i == 0 && remainingToAllocate > 0) {\n                    remainingToAllocate = 0;\n                }\n            }\n        }\n        return rewardPaid;\n    }\n\n    /**\n    * @notice Send the fees to claiming address.\n    * @param account The address to send the fees to.\n    * @param xdrAmount The amount of fees priced in XDRs.\n    * @param destinationCurrencyKey The synth currency the user wishes to receive their fees in (convert to this currency).\n    */\n    function _payFees(address account, uint xdrAmount, bytes4 destinationCurrencyKey)\n        internal\n        notFeeAddress(account)\n    {\n        require(account != address(0), \"Account can't be 0\");\n        require(account != address(this), \"Can't send fees to fee pool\");\n        require(account != address(proxy), \"Can't send fees to proxy\");\n        require(account != address(synthetix), \"Can't send fees to synthetix\");\n\n        Synth xdrSynth = synthetix.synths(\"XDR\");\n        Synth destinationSynth = synthetix.synths(destinationCurrencyKey);\n\n        // Note: We don't need to check the fee pool balance as the burn() below will do a safe subtraction which requires\n        // the subtraction to not overflow, which would happen if the balance is not sufficient.\n\n        // Burn the source amount\n        xdrSynth.burn(FEE_ADDRESS, xdrAmount);\n\n        // How much should they get in the destination currency?\n        uint destinationAmount = synthetix.effectiveValue(\"XDR\", xdrAmount, destinationCurrencyKey);\n\n        // There's no fee on withdrawing fees, as that'd be way too meta.\n\n        // Mint their new synths\n        destinationSynth.issue(account, destinationAmount);\n\n        // Nothing changes as far as issuance data goes because the total value in the system hasn't changed.\n\n        // Call the ERC223 transfer callback if needed\n        destinationSynth.triggerTokenFallbackIfNeeded(FEE_ADDRESS, account, destinationAmount);\n    }\n\n    /**\n    * @notice Send the rewards to claiming address - will be locked in rewardEscrow.\n    * @param account The address to send the fees to.\n    * @param snxAmount The amount of SNX.\n    */\n    function _payRewards(address account, uint snxAmount)\n        internal\n        notFeeAddress(account)\n    {\n        require(account != address(0), \"Account can't be 0\");\n        require(account != address(this), \"Can't send rewards to fee pool\");\n        require(account != address(proxy), \"Can't send rewards to proxy\");\n        require(account != address(synthetix), \"Can't send rewards to synthetix\");\n\n        // Record vesting entry for claiming address and amount\n        // SNX already minted to rewardEscrow balance\n        rewardEscrow.appendVestingEntry(account, snxAmount);\n    }\n\n    /**\n     * @notice Calculate the Fee charged on top of a value being sent\n     * @return Return the fee charged\n     */\n    function transferFeeIncurred(uint value)\n        public\n        view\n        returns (uint)\n    {\n        return value.multiplyDecimal(transferFeeRate);\n\n        // Transfers less than the reciprocal of transferFeeRate should be completely eaten up by fees.\n        // This is on the basis that transfers less than this value will result in a nil fee.\n        // Probably too insignificant to worry about, but the following code will achieve it.\n        //      if (fee == 0 && transferFeeRate != 0) {\n        //          return _value;\n        //      }\n        //      return fee;\n    }\n\n    /**\n     * @notice The value that you would need to send so that the recipient receives\n     * a specified value.\n     * @param value The value you want the recipient to receive\n     */\n    function transferredAmountToReceive(uint value)\n        external\n        view\n        returns (uint)\n    {\n        return value.add(transferFeeIncurred(value));\n    }\n\n    /**\n     * @notice The amount the recipient will receive if you send a certain number of tokens.\n     * @param value The amount of tokens you intend to send.\n     */\n    function amountReceivedFromTransfer(uint value)\n        external\n        view\n        returns (uint)\n    {\n        return value.divideDecimal(transferFeeRate.add(SafeDecimalMath.unit()));\n    }\n\n    /**\n     * @notice Calculate the fee charged on top of a value being sent via an exchange\n     * @return Return the fee charged\n     */\n    function exchangeFeeIncurred(uint value)\n        public\n        view\n        returns (uint)\n    {\n        return value.multiplyDecimal(exchangeFeeRate);\n\n        // Exchanges less than the reciprocal of exchangeFeeRate should be completely eaten up by fees.\n        // This is on the basis that exchanges less than this value will result in a nil fee.\n        // Probably too insignificant to worry about, but the following code will achieve it.\n        //      if (fee == 0 && exchangeFeeRate != 0) {\n        //          return _value;\n        //      }\n        //      return fee;\n    }\n\n    /**\n     * @notice The value that you would need to get after currency exchange so that the recipient receives\n     * a specified value.\n     * @param value The value you want the recipient to receive\n     */\n    function exchangedAmountToReceive(uint value)\n        external\n        view\n        returns (uint)\n    {\n        return value.add(exchangeFeeIncurred(value));\n    }\n\n    /**\n     * @notice The amount the recipient will receive if you are performing an exchange and the\n     * destination currency will be worth a certain number of tokens.\n     * @param value The amount of destination currency tokens they received after the exchange.\n     */\n    function amountReceivedFromExchange(uint value)\n        external\n        view\n        returns (uint)\n    {\n        return value.multiplyDecimal(SafeDecimalMath.unit().sub(exchangeFeeRate));\n    }\n\n    /**\n     * @notice The total fees available in the system to be withdrawn, priced in currencyKey currency\n     * @param currencyKey The currency you want to price the fees in\n     */\n    function totalFeesAvailable(bytes4 currencyKey)\n        external\n        view\n        returns (uint)\n    {\n        uint totalFees = 0;\n\n        // Fees in fee period [0] are not yet available for withdrawal\n        for (uint i = 1; i < FEE_PERIOD_LENGTH; i++) {\n            totalFees = totalFees.add(recentFeePeriods[i].feesToDistribute);\n            totalFees = totalFees.sub(recentFeePeriods[i].feesClaimed);\n        }\n\n        return synthetix.effectiveValue(\"XDR\", totalFees, currencyKey);\n    }\n\n    /**\n     * @notice The total SNX rewards available in the system to be withdrawn\n     */\n    function totalRewardsAvailable()\n        external\n        view\n        returns (uint)\n    {\n        uint totalRewards = 0;\n\n        // Rewards in fee period [0] are not yet available for withdrawal\n        for (uint i = 1; i < FEE_PERIOD_LENGTH; i++) {\n            totalRewards = totalRewards.add(recentFeePeriods[i].rewardsToDistribute);\n            totalRewards = totalRewards.sub(recentFeePeriods[i].rewardsClaimed);\n        }\n\n        return totalRewards;\n    }\n\n    /**\n     * @notice The fees available to be withdrawn by a specific account, priced in currencyKey currency\n     * @dev Returns two amounts, one for fees and one for SNX rewards\n     * @param currencyKey The currency you want to price the fees in\n     */\n    function feesAvailable(address account, bytes4 currencyKey)\n        public\n        view\n        returns (uint, uint)\n    {\n        // Add up the fees\n        uint[2][FEE_PERIOD_LENGTH] memory userFees = feesByPeriod(account);\n\n        uint totalFees = 0;\n        uint totalRewards = 0;\n\n        // Fees & Rewards in fee period [0] are not yet available for withdrawal\n        for (uint i = 1; i < FEE_PERIOD_LENGTH; i++) {\n            totalFees = totalFees.add(userFees[i][0]);\n            totalRewards = totalRewards.add(userFees[i][1]);\n        }\n\n        // And convert totalFees to their desired currency\n        // Return totalRewards as is in SNX amount\n        return (\n            synthetix.effectiveValue(\"XDR\", totalFees, currencyKey),\n            totalRewards\n        );\n    }\n\n    /**\n     * @notice The penalty a particular address would incur if its fees were withdrawn right now\n     * @param account The address you want to query the penalty for\n     */\n    function currentPenalty(address account)\n        public\n        view\n        returns (uint)\n    {\n        uint ratio = synthetix.collateralisationRatio(account);\n\n        // Users receive a different amount of fees depending on how their collateralisation ratio looks right now.\n        //  0% < 20% ( - 500%):    Fee is calculated based on percentage of economy issued.\n        // 20% - 22% (500% - 454%):  0% reduction in fees\n        // 22% - 30% (454% - 333%): 25% reduction in fees\n        // 30% - 40% (333% - 250%): 50% reduction in fees\n        // 40% - 50% (250% - 200%): 75% reduction in fees\n        //     > 50% (200% - 100%): 90% reduction in fees\n        //     > 100%(100% -   0%):100% reduction in fees\n        if (ratio <= TWENTY_PERCENT) {\n            return 0;\n        } else if (ratio > TWENTY_PERCENT && ratio <= TWENTY_TWO_PERCENT) {\n            return 0;\n        } else if (ratio > TWENTY_TWO_PERCENT && ratio <= THIRTY_PERCENT) {\n            return TWENTY_FIVE_PERCENT;\n        } else if (ratio > THIRTY_PERCENT && ratio <= FOURTY_PERCENT) {\n            return FIFTY_PERCENT;\n        } else if (ratio > FOURTY_PERCENT && ratio <= FIFTY_PERCENT) {\n            return SEVENTY_FIVE_PERCENT;\n        } else if (ratio > FIFTY_PERCENT && ratio <= ONE_HUNDRED_PERCENT) {\n            return NINETY_PERCENT;\n        }\n        return ONE_HUNDRED_PERCENT;\n    }\n\n    /**\n     * @notice Calculates fees by period for an account, priced in XDRs\n     * @param account The address you want to query the fees by penalty for\n     */\n    function feesByPeriod(address account)\n        public\n        view\n        returns (uint[2][FEE_PERIOD_LENGTH] memory results)\n    {\n        // What's the user's debt entry index and the debt they owe to the system at current feePeriod\n        uint userOwnershipPercentage;\n        uint debtEntryIndex;\n        (userOwnershipPercentage, debtEntryIndex) = feePoolState.getAccountsDebtEntry(account, 0);\n\n        // If they don't have any debt ownership and they haven't minted, they don't have any fees\n        if (debtEntryIndex == 0 && userOwnershipPercentage == 0) return;\n\n        // If there are no XDR synths, then they don't have any fees\n        if (synthetix.totalIssuedSynths(\"XDR\") == 0) return;\n\n        uint penalty = currentPenalty(account);\n\n        // The [0] fee period is not yet ready to claim, but it is a fee period that they can have\n        // fees owing for, so we need to report on it anyway.\n        uint feesFromPeriod;\n        uint rewardsFromPeriod;\n        (feesFromPeriod, rewardsFromPeriod) = _feesAndRewardsFromPeriod(0, userOwnershipPercentage, debtEntryIndex, penalty);\n\n        results[0][0] = feesFromPeriod;\n        results[0][1] = rewardsFromPeriod;\n\n        // Go through our fee periods from the oldest feePeriod[FEE_PERIOD_LENGTH - 1] and figure out what we owe them.\n        // Condition checks for periods > 0\n        for (uint i = FEE_PERIOD_LENGTH - 1; i > 0; i--) {\n            uint next = i - 1;\n            FeePeriod memory nextPeriod = recentFeePeriods[next];\n\n            // We can skip period if no debt minted during period\n            if (nextPeriod.startingDebtIndex > 0 &&\n            getLastFeeWithdrawal(account) < recentFeePeriods[i].feePeriodId) {\n\n                // We calculate a feePeriod's closingDebtIndex by looking at the next feePeriod's startingDebtIndex\n                // we can use the most recent issuanceData[0] for the current feePeriod\n                // else find the applicableIssuanceData for the feePeriod based on the StartingDebtIndex of the period\n                uint closingDebtIndex = nextPeriod.startingDebtIndex.sub(1);\n\n                // Gas optimisation - to reuse debtEntryIndex if found new applicable one\n                // if applicable is 0,0 (none found) we keep most recent one from issuanceData[0]\n                // return if userOwnershipPercentage = 0)\n                (userOwnershipPercentage, debtEntryIndex) = feePoolState.applicableIssuanceData(account, closingDebtIndex);\n\n                (feesFromPeriod, rewardsFromPeriod) = _feesAndRewardsFromPeriod(i, userOwnershipPercentage, debtEntryIndex, penalty);\n\n                results[i][0] = feesFromPeriod;\n                results[i][1] = rewardsFromPeriod;\n            }\n        }\n    }\n\n    /**\n     * @notice ownershipPercentage is a high precision decimals uint based on\n     * wallet's debtPercentage. Gives a precise amount of the feesToDistribute\n     * for fees in the period. Precision factor is removed before results are\n     * returned.\n     */\n    function _feesAndRewardsFromPeriod(uint period, uint ownershipPercentage, uint debtEntryIndex, uint penalty)\n        internal\n        returns (uint, uint)\n    {\n        // If it's zero, they haven't issued, and they have no fees OR rewards.\n        if (ownershipPercentage == 0) return (0, 0);\n\n        uint debtOwnershipForPeriod = ownershipPercentage;\n\n        // If period has closed we want to calculate debtPercentage for the period\n        if (period > 0) {\n            uint closingDebtIndex = recentFeePeriods[period - 1].startingDebtIndex.sub(1);\n            debtOwnershipForPeriod = _effectiveDebtRatioForPeriod(closingDebtIndex, ownershipPercentage, debtEntryIndex);\n        }\n\n        // Calculate their percentage of the fees / rewards in this period\n        // This is a high precision integer.\n        uint feesFromPeriodWithoutPenalty = recentFeePeriods[period].feesToDistribute\n            .multiplyDecimal(debtOwnershipForPeriod);\n\n        uint rewardsFromPeriodWithoutPenalty = recentFeePeriods[period].rewardsToDistribute\n            .multiplyDecimal(debtOwnershipForPeriod);\n\n        // Less their penalty if they have one.\n        uint feesFromPeriod = feesFromPeriodWithoutPenalty.sub(feesFromPeriodWithoutPenalty.multiplyDecimal(penalty));\n\n        uint rewardsFromPeriod = rewardsFromPeriodWithoutPenalty.sub(rewardsFromPeriodWithoutPenalty.multiplyDecimal(penalty));\n\n        return (\n            feesFromPeriod.preciseDecimalToDecimal(),\n            rewardsFromPeriod.preciseDecimalToDecimal()\n        );\n    }\n\n    function _effectiveDebtRatioForPeriod(uint closingDebtIndex, uint ownershipPercentage, uint debtEntryIndex)\n        internal\n        view\n        returns (uint)\n    {\n        // Condition to check if debtLedger[] has value otherwise return 0\n        if (closingDebtIndex > synthetixState.debtLedgerLength()) return 0;\n\n        // Figure out their global debt percentage delta at end of fee Period.\n        // This is a high precision integer.\n        uint feePeriodDebtOwnership = synthetixState.debtLedger(closingDebtIndex)\n            .divideDecimalRoundPrecise(synthetixState.debtLedger(debtEntryIndex))\n            .multiplyDecimalRoundPrecise(ownershipPercentage);\n\n        return feePeriodDebtOwnership;\n    }\n\n    function effectiveDebtRatioForPeriod(address account, uint period)\n        external\n        view\n        returns (uint)\n    {\n        require(period != 0, \"Current period has not closed yet\");\n        require(period < FEE_PERIOD_LENGTH, \"Period exceeds the FEE_PERIOD_LENGTH\");\n\n        // No debt minted during period as next period starts at 0\n        if (recentFeePeriods[period - 1].startingDebtIndex == 0) return;\n\n        uint closingDebtIndex = recentFeePeriods[period - 1].startingDebtIndex.sub(1);\n\n        uint ownershipPercentage;\n        uint debtEntryIndex;\n        (ownershipPercentage, debtEntryIndex) = feePoolState.applicableIssuanceData(account, closingDebtIndex);\n\n        // internal function will check closingDebtIndex has corresponding debtLedger entry\n        return _effectiveDebtRatioForPeriod(closingDebtIndex, ownershipPercentage, debtEntryIndex);\n    }\n\n    /**\n     * @notice Get the feePeriodID of the last claim this account made\n     * @param _claimingAddress account to check the last fee period ID claim for\n     * @return uint of the feePeriodID this account last claimed\n     */\n    function getLastFeeWithdrawal(address _claimingAddress)\n        public\n        view\n        returns (uint)\n    {\n        return feePoolEternalStorage.getUIntValue(keccak256(abi.encodePacked(LAST_FEE_WITHDRAWAL, _claimingAddress)));\n    }\n\n    /**\n     * @notice Set the feePeriodID of the last claim this account made\n     * @param _claimingAddress account to set the last feePeriodID claim for\n     * @param _feePeriodID the feePeriodID this account claimed fees for\n     */\n    function _setLastFeeWithdrawal(address _claimingAddress, uint _feePeriodID)\n        internal\n    {\n        feePoolEternalStorage.setUIntValue(keccak256(abi.encodePacked(LAST_FEE_WITHDRAWAL, _claimingAddress)), _feePeriodID);\n    }\n\n    /* ========== Modifiers ========== */\n\n    modifier optionalProxy_onlyFeeAuthority\n    {\n        if (Proxy(msg.sender) != proxy) {\n            messageSender = msg.sender;\n        }\n        require(msg.sender == feeAuthority, \"Only the fee authority can perform this action\");\n        _;\n    }\n\n    modifier onlySynthetix\n    {\n        require(msg.sender == address(synthetix), \"Only the synthetix contract can perform this action\");\n        _;\n    }\n\n    modifier notFeeAddress(address account) {\n        require(account != FEE_ADDRESS, \"Fee address not allowed\");\n        _;\n    }\n\n    /* ========== Events ========== */\n\n    event IssuanceDebtRatioEntry(address indexed account, uint debtRatio, uint debtEntryIndex, uint feePeriodStartingDebtIndex);\n    bytes32 constant ISSUANCEDEBTRATIOENTRY_SIG = keccak256(\"IssuanceDebtRatioEntry(address,uint256,uint256,uint256)\");\n    function emitIssuanceDebtRatioEntry(address account, uint debtRatio, uint debtEntryIndex, uint feePeriodStartingDebtIndex) internal {\n        proxy._emit(abi.encode(debtRatio, debtEntryIndex, feePeriodStartingDebtIndex), 2, ISSUANCEDEBTRATIOENTRY_SIG, bytes32(account), 0, 0);\n    }\n\n    event TransferFeeUpdated(uint newFeeRate);\n    bytes32 constant TRANSFERFEEUPDATED_SIG = keccak256(\"TransferFeeUpdated(uint256)\");\n    function emitTransferFeeUpdated(uint newFeeRate) internal {\n        proxy._emit(abi.encode(newFeeRate), 1, TRANSFERFEEUPDATED_SIG, 0, 0, 0);\n    }\n\n    event ExchangeFeeUpdated(uint newFeeRate);\n    bytes32 constant EXCHANGEFEEUPDATED_SIG = keccak256(\"ExchangeFeeUpdated(uint256)\");\n    function emitExchangeFeeUpdated(uint newFeeRate) internal {\n        proxy._emit(abi.encode(newFeeRate), 1, EXCHANGEFEEUPDATED_SIG, 0, 0, 0);\n    }\n\n    event FeePeriodDurationUpdated(uint newFeePeriodDuration);\n    bytes32 constant FEEPERIODDURATIONUPDATED_SIG = keccak256(\"FeePeriodDurationUpdated(uint256)\");\n    function emitFeePeriodDurationUpdated(uint newFeePeriodDuration) internal {\n        proxy._emit(abi.encode(newFeePeriodDuration), 1, FEEPERIODDURATIONUPDATED_SIG, 0, 0, 0);\n    }\n\n    event FeeAuthorityUpdated(address newFeeAuthority);\n    bytes32 constant FEEAUTHORITYUPDATED_SIG = keccak256(\"FeeAuthorityUpdated(address)\");\n    function emitFeeAuthorityUpdated(address newFeeAuthority) internal {\n        proxy._emit(abi.encode(newFeeAuthority), 1, FEEAUTHORITYUPDATED_SIG, 0, 0, 0);\n    }\n\n    event FeePoolStateUpdated(address newFeePoolState);\n    bytes32 constant FEEPOOLSTATEUPDATED_SIG = keccak256(\"FeePoolStateUpdated(address)\");\n    function emitFeePoolStateUpdated(address newFeePoolState) internal {\n        proxy._emit(abi.encode(newFeePoolState), 1, FEEPOOLSTATEUPDATED_SIG, 0, 0, 0);\n    }\n\n    event DelegateApprovalsUpdated(address newDelegateApprovals);\n    bytes32 constant DELEGATEAPPROVALSUPDATED_SIG = keccak256(\"DelegateApprovalsUpdated(address)\");\n    function emitDelegateApprovalsUpdated(address newDelegateApprovals) internal {\n        proxy._emit(abi.encode(newDelegateApprovals), 1, DELEGATEAPPROVALSUPDATED_SIG, 0, 0, 0);\n    }\n\n    event FeePeriodClosed(uint feePeriodId);\n    bytes32 constant FEEPERIODCLOSED_SIG = keccak256(\"FeePeriodClosed(uint256)\");\n    function emitFeePeriodClosed(uint feePeriodId) internal {\n        proxy._emit(abi.encode(feePeriodId), 1, FEEPERIODCLOSED_SIG, 0, 0, 0);\n    }\n\n    event FeesClaimed(address account, uint xdrAmount);\n    bytes32 constant FEESCLAIMED_SIG = keccak256(\"FeesClaimed(address,uint256)\");\n    function emitFeesClaimed(address account, uint xdrAmount) internal {\n        proxy._emit(abi.encode(account, xdrAmount), 1, FEESCLAIMED_SIG, 0, 0, 0);\n    }\n\n    event RewardsClaimed(address account, uint snxAmount);\n    bytes32 constant REWARDSCLAIMED_SIG = keccak256(\"RewardsClaimed(address,uint256)\");\n    function emitRewardsClaimed(address account, uint snxAmount) internal {\n        proxy._emit(abi.encode(account, snxAmount), 1, REWARDSCLAIMED_SIG, 0, 0, 0);\n    }\n\n    event SynthetixUpdated(address newSynthetix);\n    bytes32 constant SYNTHETIXUPDATED_SIG = keccak256(\"SynthetixUpdated(address)\");\n    function emitSynthetixUpdated(address newSynthetix) internal {\n        proxy._emit(abi.encode(newSynthetix), 1, SYNTHETIXUPDATED_SIG, 0, 0, 0);\n    }\n}",
  "bytecode": "608060405262093a80603a553480156200001857600080fd5b50604051610140806200603e83398101604090815281516020830151918301516060840151608085015160a086015160c087015160e088015161010089015161012090990151969895969495939492939192909190621baf80898b8180600160a060020a0381161515620000ed57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601960248201527f4f776e657220616464726573732063616e6e6f74206265203000000000000000604482015290519081900360640190fd5b60008054600160a060020a031916600160a060020a038316908117825560408051928352602083019190915280517fb532073b38c83145e3e5135377a08bf9aab55bc0fd7c1179cd4fb995d2a5159c9281900390910190a15060028054600160a060020a038416600160a060020a0319909116811790915560408051918252517ffc80377ca9c49cc11ae6982f390a42db976d5530af7c43889264b13fbbd7c57e9181900360200190a15050600160a060020a03811615156200023757604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602260248201527f4f776e6572206d757374206e6f7420626520746865207a65726f20616464726560448201527f7373000000000000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b60058054600160a060020a038316610100810261010060a860020a03199092169190911790915560408051918252517fd5da63a0b864b315bc04128dedbc93888c8529ee6cf47ce664dc204339228c539181900360200190a15080420160068190555050600a7384d626b2bb4d0f064067e4bf80fce7055d8f3e7b63907af6c06040518163ffffffff167c010000000000000000000000000000000000000000000000000000000002815260040160206040518083038186803b158015620002fe57600080fd5b505af415801562000313573d6000803e3d6000fd5b505050506040513d60208110156200032a57600080fd5b50518115156200033657fe5b04821115620003e157604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152604160248201527f436f6e7374727563746564207472616e7366657220666565207261746520736860448201526000805160206200601e83398151915260648201527f6500000000000000000000000000000000000000000000000000000000000000608482015290519081900360a40190fd5b600a7384d626b2bb4d0f064067e4bf80fce7055d8f3e7b63907af6c06040518163ffffffff167c010000000000000000000000000000000000000000000000000000000002815260040160206040518083038186803b1580156200044457600080fd5b505af415801562000459573d6000803e3d6000fd5b505050506040513d60208110156200047057600080fd5b50518115156200047c57fe5b048111156200052757604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152604160248201527f436f6e73747275637465642065786368616e676520666565207261746520736860448201526000805160206200601e83398151915260648201527f6500000000000000000000000000000000000000000000000000000000000000608482015290519081900360a40190fd5b60078054600160a060020a0319908116600160a060020a039a8b1617909155600e80548216988a1698909817909755600a80548816968916969096179095556009805487169388169390931790925560088054861693871693909317909255600d80549094169190941617909155600b91909155600c555050600160105542601255615a6580620005b96000396000f3006080604052600436106102bb5763ffffffff60e060020a60003504166304c49f2c81146102c0578063075d2c41146102da57806307ea50cd146102fb5780630813071c1461032e5780630f5024a7146103525780630f9b49551461039457806310adda0e146103a95780631627540c146103f057806317c70de41461041157806320714f881461042657806322425fa41461044757806331dbd8a51461045c5780633278c9601461048d57806333140016146104a2578063351bf5181461051d5780633ebc457a146105325780633fcd2240146105475780634180e5b51461059757806352b9f8a2146105b857806353a47bb7146105cd578063578a791d146105e25780635b292e94146105fa5780636138b19e1461061b578063639cd59c146106305780636c8bc9fe146106525780636de813f114610673578063759b52251461068857806376d752a11461069d57806379ba5097146106b257806386645274146106c75780638a957929146106ee5780638da5cb5b1461070f57806397107d6d146107245780639cb8a26a14610745578063a3fd6d0e1461075a578063a430be6c1461077f578063a461fc8214610794578063b10090b8146107a9578063b6dc8e25146107d6578063b7fcfa69146107ee578063b8225dec14610806578063bc67f8321461081b578063bd32aa441461083c578063c58aaae614610851578063c894e1e514610866578063cc9b31c91461087e578063cd503c0b14610896578063cf427d1b146108b8578063cff2ddad146108d9578063d62ae39914610904578063da46e6c414610919578063dbd4a42214610931578063e05bac8214610946578063e3082f6a1461095e578063e3f060ae14610973578063e9d36c561461098b578063eb1edd61146109a3578063ec556889146109b8578063f344da67146109cd578063fb1b4c7e1461069d578063fec9f9da146109e2575b600080fd5b3480156102cc57600080fd5b506102d8600435610a03565b005b3480156102e657600080fd5b506102d8600160a060020a0360043516610bcb565b34801561030757600080fd5b5061031c600160a060020a0360043516610c7e565b60408051918252519081900360200190f35b34801561033a57600080fd5b5061031c600160a060020a0360043516602435610dae565b34801561035e57600080fd5b50610380600160a060020a0360043516600160e060020a031960243516610fbc565b604080519115158252519081900360200190f35b3480156103a057600080fd5b5061031c611110565b3480156103b557600080fd5b506103d7600160a060020a0360043516600160e060020a031960243516611116565b6040805192835260208301919091528051918290030190f35b3480156103fc57600080fd5b506102d8600160a060020a0360043516611240565b34801561041d57600080fd5b5061031c6112f8565b34801561043257600080fd5b506102d8600160a060020a03600435166112fe565b34801561045357600080fd5b5061031c611451565b34801561046857600080fd5b50610471611457565b60408051600160a060020a039092168252519081900360200190f35b34801561049957600080fd5b506102d8611466565b3480156104ae57600080fd5b506104c3600160a060020a0360043516611504565b6040516000826006835b8184101561050d5760208402830151604080838360005b838110156104fc5781810151838201526020016104e4565b5050505090500192600101926104cd565b9250505091505060405180910390f35b34801561052957600080fd5b5061031c61186a565b34801561053e57600080fd5b506102d8611870565b34801561055357600080fd5b5061055f600435611ce3565b604080519788526020880196909652868601949094526060860192909252608085015260a084015260c0830152519081900360e00190f35b3480156105a357600080fd5b506102d8600160a060020a0360043516611d23565b3480156105c457600080fd5b50610471611ebd565b3480156105d957600080fd5b50610471611ecc565b3480156105ee57600080fd5b506102d8600435611edb565b34801561060657600080fd5b506102d8600160a060020a0360043516612074565b34801561062757600080fd5b50610471612127565b34801561063c57600080fd5b5061031c600160e060020a031960043516612136565b34801561065e57600080fd5b506102d8600160a060020a0360043516612242565b34801561067f57600080fd5b5061031c612361565b34801561069457600080fd5b506104716123d0565b3480156106a957600080fd5b5061031c6123df565b3480156106be57600080fd5b506102d8612461565b3480156106d357600080fd5b506102d8600160a060020a036004351660243560443561255c565b3480156106fa57600080fd5b506102d8600160a060020a0360043516612693565b34801561071b57600080fd5b50610471612746565b34801561073057600080fd5b506102d8600160a060020a0360043516612755565b34801561075157600080fd5b506102d861280d565b34801561076657600080fd5b506102d8600160e060020a0319600435166024356129d2565b34801561078b57600080fd5b50610471612b37565b3480156107a057600080fd5b5061031c612b46565b3480156107b557600080fd5b506102d860043560243560443560643560843560a43560c43560e435612b4d565b3480156107e257600080fd5b5061031c600435612d18565b3480156107fa57600080fd5b5061031c600435612d39565b34801561081257600080fd5b50610380612dd0565b34801561082757600080fd5b506102d8600160a060020a0360043516612dd9565b34801561084857600080fd5b506102d8612e83565b34801561085d57600080fd5b50610471612f30565b34801561087257600080fd5b506102d8600435612f44565b34801561088a57600080fd5b5061031c6004356130dd565b3480156108a257600080fd5b50610380600160e060020a0319600435166130f4565b3480156108c457600080fd5b5061031c600160a060020a0360043516613132565b3480156108e557600080fd5b506108ee613a85565b6040805160ff9092168252519081900360200190f35b34801561091057600080fd5b5061031c613a8a565b34801561092557600080fd5b5061031c600435613a91565b34801561093d57600080fd5b50610471613aa8565b34801561095257600080fd5b5061031c600435613ab7565b34801561096a57600080fd5b50610471613b4e565b34801561097f57600080fd5b506102d8600435613b5d565b34801561099757600080fd5b5061031c600435613bfe565b3480156109af57600080fd5b50610471613c0c565b3480156109c457600080fd5b50610471613c24565b3480156109d957600080fd5b5061031c613c33565b3480156109ee57600080fd5b506102d8600160a060020a0360043516613c3a565b600254600160a060020a03163314610a285760038054600160a060020a031916331790555b600054600354600160a060020a03908116911614610a92576040805160e560020a62461bcd02815260206004820152602e60248201526000805160206159da8339815191526044820152600080516020615a1a833981519152606482015290519081900360840190fd5b62015180811015610b13576040805160e560020a62461bcd02815260206004820152603e60248201527f4e65772066656520706572696f642063616e6e6f74206265206c65737320746860448201527f616e206d696e696d756d2066656520706572696f64206475726174696f6e0000606482015290519081900360840190fd5b624f1a00811115610bba576040805160e560020a62461bcd02815260206004820152604160248201527f4e65772066656520706572696f642063616e6e6f74206265206772656174657260448201527f207468616e206d6178696d756d2066656520706572696f64206475726174696f60648201527f6e00000000000000000000000000000000000000000000000000000000000000608482015290519081900360a40190fd5b603a819055610bc881613d4d565b50565b600254600160a060020a03163314610bf05760038054600160a060020a031916331790555b600054600354600160a060020a03908116911614610c5a576040805160e560020a62461bcd02815260206004820152602e60248201526000805160206159da8339815191526044820152600080516020615a1a833981519152606482015290519081900360840190fd5b600e8054600160a060020a031916600160a060020a038316179055610bc881613e98565b600a54604080517f6c6173745f6665655f7769746864726177616c00000000000000000000000000602080830191909152600160a060020a038581166c010000000000000000000000000283850152835180840360340181526054909301938490528251600095919091169363bdc963d89392909182918401908083835b60208310610d1b5780518252601f199092019160209182019101610cfc565b51815160209384036101000a60001901801990921691161790526040805192909401829003822063ffffffff881660e060020a0283526004830152925160248083019650939450929083900301905081600087803b158015610d7c57600080fd5b505af1158015610d90573d6000803e3d6000fd5b505050506040513d6020811015610da657600080fd5b505192915050565b6000808080841515610e30576040805160e560020a62461bcd02815260206004820152602160248201527f43757272656e7420706572696f6420686173206e6f7420636c6f73656420796560448201527f7400000000000000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b60068510610ead576040805160e560020a62461bcd028152602060048201526024808201527f506572696f64206578636565647320746865204645455f504552494f445f4c4560448201527f4e47544800000000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b6010600019860160068110610ebe57fe5b600702016001015460001415610ed357610fb3565b610eff60016010600019880160068110610ee957fe5b6007020160010154613f7490919063ffffffff16565b600e54604080517fd29c000a000000000000000000000000000000000000000000000000000000008152600160a060020a038a811660048301526024820185905282519497509092169263d29c000a9260448082019392918290030181600087803b158015610f6d57600080fd5b505af1158015610f81573d6000803e3d6000fd5b505050506040513d6040811015610f9757600080fd5b5080516020909101519092509050610fb0838383613f92565b93505b50505092915050565b600254600090600160a060020a03163314610fe45760038054600160a060020a031916331790555b600f54600354604080517fe1270b6e000000000000000000000000000000000000000000000000000000008152600160a060020a03878116600483015292831660248201529051919092169163e1270b6e9160448083019260209291908290030181600087803b15801561105757600080fd5b505af115801561106b573d6000803e3d6000fd5b505050506040513d602081101561108157600080fd5b505115156110ff576040805160e560020a62461bcd02815260206004820152602c60248201527f4e6f7420617070726f76656420746f20636c61696d206f6e20626568616c662060448201527f7468697320616464726573730000000000000000000000000000000000000000606482015290519081900360840190fd5b611109838361417a565b9392505050565b600c5481565b600080611121615931565b600080600061112f88611504565b93506000925060009150600190505b60068110156111975761116384826006811061115657fe5b6020020151518490614291565b925061118d84826006811061117457fe5b602002015160016020020151839063ffffffff61429116565b915060010161113e565b6007546040805160e660020a62e759bf02815260e960020a622c222902600482015260248101869052600160e060020a03198a1660448201529051600160a060020a03909216916339d66fc0916064808201926020929091908290030181600087803b15801561120657600080fd5b505af115801561121a573d6000803e3d6000fd5b505050506040513d602081101561123057600080fd5b5051989197509095505050505050565b600054600160a060020a031633146112a4576040805160e560020a62461bcd02815260206004820152602f60248201526000805160206159ba83398151915260448201526000805160206159fa833981519152606482015290519081900360840190fd5b60018054600160a060020a038316600160a060020a0319909116811790915560408051918252517f906a1c6bd7e3091ea86693dd029a831c19049ce77f1dce2ce0bab1cacbabce229181900360200190a150565b60045481565b600054600160a060020a03163314611362576040805160e560020a62461bcd02815260206004820152602f60248201526000805160206159ba83398151915260448201526000805160206159fa833981519152606482015290519081900360840190fd5b600160a060020a03811615156113e8576040805160e560020a62461bcd02815260206004820152602860248201527f42656e6566696369617279206d757374206e6f7420626520746865207a65726f60448201527f2061646472657373000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b60058054600160a060020a038316610100810274ffffffffffffffffffffffffffffffffffffffff00199092169190911790915560408051918252517fd5da63a0b864b315bc04128dedbc93888c8529ee6cf47ce664dc204339228c539181900360200190a150565b603a5481565b600d54600160a060020a031681565b600054600160a060020a031633146114ca576040805160e560020a62461bcd02815260206004820152602f60248201526000805160206159ba83398151915260448201526000805160206159fa833981519152606482015290519081900360840190fd5b600060048190556005805460ff191690556040517f6adcc7125002935e0aa31697538ebbd65cfddf20431eb6ecdcfc3e238bfd082c9190a1565b61150c615931565b600080600080600080600061151f615960565b600e54604080517fb326f84e000000000000000000000000000000000000000000000000000000008152600160a060020a038d8116600483015260006024830181905283519094919091169263b326f84e926044808201939182900301818787803b15801561158d57600080fd5b505af11580156115a1573d6000803e3d6000fd5b505050506040513d60408110156115b757600080fd5b5080516020909101519099509750871580156115d1575088155b156115db5761185c565b600754604080517f403dca5500000000000000000000000000000000000000000000000000000000815260e960020a622c22290260048201529051600160a060020a039092169163403dca55916024808201926020929091908290030181600087803b15801561164a57600080fd5b505af115801561165e573d6000803e3d6000fd5b505050506040513d602081101561167457600080fd5b505115156116815761185c565b61168a8b613132565b965061169960008a8a8a6142a3565b8b518290528b516020018190529096509450600593505b600084111561185c5760001984019250601083600681106116cd57fe5b6007020160e0604051908101604052908160008201548152602001600182015481526020016002820154815260200160038201548152602001600482015481526020016005820154815260200160068201548152505091506000826020015111801561175157506010846006811061174157fe5b600702015461174f8c610c7e565b105b1561185057602082015161176c90600163ffffffff613f7416565b600e54604080517fd29c000a000000000000000000000000000000000000000000000000000000008152600160a060020a038f811660048301526024820185905282519495509092169263d29c000a9260448082019392918290030181600087803b1580156117da57600080fd5b505af11580156117ee573d6000803e3d6000fd5b505050506040513d604081101561180457600080fd5b508051602090910151909950975061181e848a8a8a6142a3565b9096509450858a856006811061183057fe5b602002015152848a856006811061184357fe5b6020020151600160200201525b600019909301926116b0565b505050505050505050919050565b600b5481565b611878615960565b611880615960565b6002546000908190600160a060020a031633146118aa5760038054600160a060020a031916331790555b600d54600160a060020a03163314611932576040805160e560020a62461bcd02815260206004820152602e60248201527f4f6e6c79207468652066656520617574686f726974792063616e20706572666f60448201527f726d207468697320616374696f6e000000000000000000000000000000000000606482015290519081900360840190fd5b603a54601254429190910310156119b9576040805160e560020a62461bcd02815260206004820152602f60248201527f497420697320746f6f206561726c7920746f20636c6f7365207468652063757260448201527f72656e742066656520706572696f640000000000000000000000000000000000606482015290519081900360840190fd5b6040805160e08082018352602c548252602d54602080840191909152602e5483850152602f54606080850191825260305460808087019190915260315460a08088019190915260325460c0808901919091528851968701895260335487526034549587019590955260355497860197909752603654918501829052603754908501819052603854968501969096526039549284019290925251929750909550611a7892611a6c919063ffffffff613f7416565b9063ffffffff61429116565b602f5560a08085015160c085015191850151611a9e92611a6c919063ffffffff613f7416565b603155600491505b6006821015611c0a57506001810160108260068110611ac157fe5b600702015460108260068110611ad357fe5b600702015560108260068110611ae557fe5b6007020160010154601082600681101515611afc57fe5b6007020160010181905550601082600681101515611b1657fe5b6007020160020154601082600681101515611b2d57fe5b6007020160020181905550601082600681101515611b4757fe5b6007020160030154601082600681101515611b5e57fe5b6007020160030181905550601082600681101515611b7857fe5b6007020160040154601082600681101515611b8f57fe5b6007020160040181905550601082600681101515611ba957fe5b6007020160050154601082600681101515611bc057fe5b6007020160050181905550601082600681101515611bda57fe5b6007020160060154601082600681101515611bf157fe5b6007020160060181905550818060019003925050611aa6565b6000601081905560118190556012819055601381905560148190556015819055601655601754611c3b906001614291565b601055600854604080517fcd92eba90000000000000000000000000000000000000000000000000000000081529051600160a060020a039092169163cd92eba9916004808201926020929091908290030181600087803b158015611c9e57600080fd5b505af1158015611cb2573d6000803e3d6000fd5b505050506040513d6020811015611cc857600080fd5b505160115542601255601754611cdd906143ad565b50505050565b60108160068110611cf057fe5b60070201805460018201546002830154600384015460048501546005860154600690960154949650929491939092919087565b600254600160a060020a03163314611d485760038054600160a060020a031916331790555b600f54600160a060020a03161515611dd0576040805160e560020a62461bcd02815260206004820152602660248201527f44656c65676174657320417070726f76616c2064657374696e6174696f6e206d60448201527f697373696e670000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b600160a060020a0381161515611e30576040805160e560020a62461bcd02815260206004820152601c60248201527f43616e27742064656c656761746520746f206164647265737328302900000000604482015290519081900360640190fd5b600f54600354604080517fb3c12354000000000000000000000000000000000000000000000000000000008152600160a060020a03928316600482015284831660248201529051919092169163b3c1235491604480830192600092919082900301818387803b158015611ea257600080fd5b505af1158015611eb6573d6000803e3d6000fd5b5050505050565b600a54600160a060020a031681565b600154600160a060020a031681565b600254600160a060020a03163314611f005760038054600160a060020a031916331790555b600054600354600160a060020a03908116911614611f6a576040805160e560020a62461bcd02815260206004820152602e60248201526000805160206159da8339815191526044820152600080516020615a1a833981519152606482015290519081900360840190fd5b600a7384d626b2bb4d0f064067e4bf80fce7055d8f3e7b63907af6c06040518163ffffffff1660e060020a02815260040160206040518083038186803b158015611fb357600080fd5b505af4158015611fc7573d6000803e3d6000fd5b505050506040513d6020811015611fdd57600080fd5b5051811515611fe857fe5b04811115612066576040805160e560020a62461bcd02815260206004820152603560248201527f45786368616e6765206665652072617465206d7573742062652062656c6f772060448201527f4d41585f45584348414e47455f4645455f524154450000000000000000000000606482015290519081900360840190fd5b600c819055610bc881614480565b600254600160a060020a031633146120995760038054600160a060020a031916331790555b600054600354600160a060020a03908116911614612103576040805160e560020a62461bcd02815260206004820152602e60248201526000805160206159da8339815191526044820152600080516020615a1a833981519152606482015290519081900360840190fd5b600f8054600160a060020a031916600160a060020a038316179055610bc881614553565b600f54600160a060020a031681565b60008060015b600681101561219f5761216c6010826006811061215557fe5b60070201600301548361429190919063ffffffff16565b91506121956010826006811061217e57fe5b600702016004015483613f7490919063ffffffff16565b915060010161213c565b6007546040805160e660020a62e759bf02815260e960020a622c222902600482015260248101859052600160e060020a0319871660448201529051600160a060020a03909216916339d66fc0916064808201926020929091908290030181600087803b15801561220e57600080fd5b505af1158015612222573d6000803e3d6000fd5b505050506040513d602081101561223857600080fd5b5051949350505050565b600254600160a060020a031633146122675760038054600160a060020a031916331790555b600f54600160a060020a031615156122ef576040805160e560020a62461bcd02815260206004820152602660248201527f44656c65676174657320417070726f76616c2064657374696e6174696f6e206d60448201527f697373696e670000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b600f54600354604080517f5f0736a1000000000000000000000000000000000000000000000000000000008152600160a060020a039283166004820152848316602482015290519190921691635f0736a191604480830192600092919082900301818387803b158015611ea257600080fd5b60008060015b60068110156123ca576123976010826006811061238057fe5b60070201600501548361429190919063ffffffff16565b91506123c0601082600681106123a957fe5b600702016006015483613f7490919063ffffffff16565b9150600101612367565b50919050565b600754600160a060020a031681565b600a7384d626b2bb4d0f064067e4bf80fce7055d8f3e7b63907af6c06040518163ffffffff1660e060020a02815260040160206040518083038186803b15801561242857600080fd5b505af415801561243c573d6000803e3d6000fd5b505050506040513d602081101561245257600080fd5b505181151561245d57fe5b0481565b600154600160a060020a031633146124e9576040805160e560020a62461bcd02815260206004820152603560248201527f596f75206d757374206265206e6f6d696e61746564206265666f726520796f7560448201527f2063616e20616363657074206f776e6572736869700000000000000000000000606482015290519081900360840190fd5b60005460015460408051600160a060020a03938416815292909116602083015280517fb532073b38c83145e3e5135377a08bf9aab55bc0fd7c1179cd4fb995d2a5159c9281900390910190a16001805460008054600160a060020a0319908116600160a060020a03841617909155169055565b600754600160a060020a031633146125e4576040805160e560020a62461bcd02815260206004820152603360248201527f4f6e6c79207468652073796e74686574697820636f6e74726163742063616e2060448201527f706572666f726d207468697320616374696f6e00000000000000000000000000606482015290519081900360840190fd5b600e54601154604080517f94e1a448000000000000000000000000000000000000000000000000000000008152600160a060020a03878116600483015260248201879052604482018690526064820193909352905191909216916394e1a44891608480830192600092919082900301818387803b15801561266457600080fd5b505af1158015612678573d6000803e3d6000fd5b505060115461268e925085915084908490614655565b505050565b600254600160a060020a031633146126b85760038054600160a060020a031916331790555b600054600354600160a060020a03908116911614612722576040805160e560020a62461bcd02815260206004820152602e60248201526000805160206159da8339815191526044820152600080516020615a1a833981519152606482015290519081900360840190fd5b600d8054600160a060020a031916600160a060020a038316179055610bc8816147d6565b600054600160a060020a031681565b600054600160a060020a031633146127b9576040805160e560020a62461bcd02815260206004820152602f60248201526000805160206159ba83398151915260448201526000805160206159fa833981519152606482015290519081900360840190fd5b60028054600160a060020a038316600160a060020a0319909116811790915560408051918252517ffc80377ca9c49cc11ae6982f390a42db976d5530af7c43889264b13fbbd7c57e9181900360200190a150565b60008054600160a060020a03163314612872576040805160e560020a62461bcd02815260206004820152602f60248201526000805160206159ba83398151915260448201526000805160206159fa833981519152606482015290519081900360840190fd5b60055460ff1615156128f4576040805160e560020a62461bcd02815260206004820152602860248201527f53656c6620646573747275637420686173206e6f7420796574206265656e206960448201527f6e69746961746564000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b426224ea006004540110151561297a576040805160e560020a62461bcd02815260206004820152602760248201527f53656c662064657374727563742064656c617920686173206e6f74207965742060448201527f656c617073656400000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b5060055460408051600160a060020a0361010090930492909216808352905190917f8a09e1677ced846cb537dc2b172043bd05a1a81ad7e0033a7ef8ba762df990b7919081900360200190a180600160a060020a0316ff5b600754600090600160a060020a03163314612a5d576040805160e560020a62461bcd02815260206004820152603360248201527f4f6e6c79207468652073796e74686574697820636f6e74726163742063616e2060448201527f706572666f726d207468697320616374696f6e00000000000000000000000000606482015290519081900360840190fd5b60e960020a622c222902600160e060020a0319841614612b19576007546040805160e660020a62e759bf028152600160e060020a0319861660048201526024810185905260e960020a622c22290260448201529051600160a060020a03909216916339d66fc0916064808201926020929091908290030181600087803b158015612ae657600080fd5b505af1158015612afa573d6000803e3d6000fd5b505050506040513d6020811015612b1057600080fd5b50519050612b1c565b50805b601354612b2f908263ffffffff61429116565b601355505050565b600954600160a060020a031681565b6224ea0081565b600254600160a060020a03163314612b725760038054600160a060020a031916331790555b600054600354600160a060020a03908116911614612bdc576040805160e560020a62461bcd02815260206004820152602e60248201526000805160206159da8339815191526044820152600080516020615a1a833981519152606482015290519081900360840190fd5b6006544210612c5b576040805160e560020a62461bcd02815260206004820152602960248201527f43616e206f6e6c7920706572666f726d207468697320616374696f6e2064757260448201527f696e672073657475700000000000000000000000000000000000000000000000606482015290519081900360840190fd5b8660108960068110612c6957fe5b60070201558560108960068110612c7c57fe5b600702016001018190555084601089600681101515612c9757fe5b600702016002018190555083601089600681101515612cb257fe5b600702016003018190555082601089600681101515612ccd57fe5b600702016004018190555081601089600681101515612ce857fe5b600702016005018190555080601089600681101515612d0357fe5b60070201600601819055505050505050505050565b6000612d33612d26836130dd565b839063ffffffff61429116565b92915050565b6000612d33612dc37384d626b2bb4d0f064067e4bf80fce7055d8f3e7b63907af6c06040518163ffffffff1660e060020a02815260040160206040518083038186803b158015612d8857600080fd5b505af4158015612d9c573d6000803e3d6000fd5b505050506040513d6020811015612db257600080fd5b5051600b549063ffffffff61429116565b839063ffffffff6148b216565b60055460ff1681565b600254600160a060020a03163314612e61576040805160e560020a62461bcd02815260206004820152602560248201527f4f6e6c79207468652070726f78792063616e2063616c6c20746869732066756e60448201527f6374696f6e000000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b60038054600160a060020a031916600160a060020a0392909216919091179055565b600054600160a060020a03163314612ee7576040805160e560020a62461bcd02815260206004820152602f60248201526000805160206159ba83398151915260448201526000805160206159fa833981519152606482015290519081900360840190fd5b426004556005805460ff19166001179055604080516224ea00815290517fcbd94ca75b8dc45c9d80c77e851670e78843c0d75180cb81db3e2158228fa9a69181900360200190a1565b6005546101009004600160a060020a031681565b600254600160a060020a03163314612f695760038054600160a060020a031916331790555b600054600354600160a060020a03908116911614612fd3576040805160e560020a62461bcd02815260206004820152602e60248201526000805160206159da8339815191526044820152600080516020615a1a833981519152606482015290519081900360840190fd5b600a7384d626b2bb4d0f064067e4bf80fce7055d8f3e7b63907af6c06040518163ffffffff1660e060020a02815260040160206040518083038186803b15801561301c57600080fd5b505af4158015613030573d6000803e3d6000fd5b505050506040513d602081101561304657600080fd5b505181151561305157fe5b048111156130cf576040805160e560020a62461bcd02815260206004820152603560248201527f5472616e73666572206665652072617465206d7573742062652062656c6f772060448201527f4d41585f5452414e534645525f4645455f524154450000000000000000000000606482015290519081900360840190fd5b600b819055610bc8816148dc565b6000612d33600c54836149af90919063ffffffff16565b600254600090600160a060020a0316331461311c5760038054600160a060020a031916331790555b600354612d3390600160a060020a03168361417a565b600754604080517fa311c7c2000000000000000000000000000000000000000000000000000000008152600160a060020a03848116600483015291516000938493169163a311c7c291602480830192602092919082900301818787803b15801561319b57600080fd5b505af11580156131af573d6000803e3d6000fd5b505050506040513d60208110156131c557600080fd5b5051604080517f907af6c000000000000000000000000000000000000000000000000000000000815290519192506064917384d626b2bb4d0f064067e4bf80fce7055d8f3e7b9163907af6c0916004808301926020929190829003018186803b15801561323157600080fd5b505af4158015613245573d6000803e3d6000fd5b505050506040513d602081101561325b57600080fd5b505160140281151561326957fe5b04811161327957600091506123ca565b60647384d626b2bb4d0f064067e4bf80fce7055d8f3e7b63907af6c06040518163ffffffff1660e060020a02815260040160206040518083038186803b1580156132c257600080fd5b505af41580156132d6573d6000803e3d6000fd5b505050506040513d60208110156132ec57600080fd5b50516014028115156132fa57fe5b048111801561338a575060647384d626b2bb4d0f064067e4bf80fce7055d8f3e7b63907af6c06040518163ffffffff1660e060020a02815260040160206040518083038186803b15801561334d57600080fd5b505af4158015613361573d6000803e3d6000fd5b505050506040513d602081101561337757600080fd5b505160160281151561338557fe5b048111155b1561339857600091506123ca565b60647384d626b2bb4d0f064067e4bf80fce7055d8f3e7b63907af6c06040518163ffffffff1660e060020a02815260040160206040518083038186803b1580156133e157600080fd5b505af41580156133f5573d6000803e3d6000fd5b505050506040513d602081101561340b57600080fd5b505160160281151561341957fe5b04811180156134a9575060647384d626b2bb4d0f064067e4bf80fce7055d8f3e7b63907af6c06040518163ffffffff1660e060020a02815260040160206040518083038186803b15801561346c57600080fd5b505af4158015613480573d6000803e3d6000fd5b505050506040513d602081101561349657600080fd5b5051601e028115156134a457fe5b048111155b156135375760647384d626b2bb4d0f064067e4bf80fce7055d8f3e7b63907af6c06040518163ffffffff1660e060020a02815260040160206040518083038186803b1580156134f757600080fd5b505af415801561350b573d6000803e3d6000fd5b505050506040513d602081101561352157600080fd5b505160190281151561352f57fe5b0491506123ca565b60647384d626b2bb4d0f064067e4bf80fce7055d8f3e7b63907af6c06040518163ffffffff1660e060020a02815260040160206040518083038186803b15801561358057600080fd5b505af4158015613594573d6000803e3d6000fd5b505050506040513d60208110156135aa57600080fd5b5051601e028115156135b857fe5b0481118015613648575060647384d626b2bb4d0f064067e4bf80fce7055d8f3e7b63907af6c06040518163ffffffff1660e060020a02815260040160206040518083038186803b15801561360b57600080fd5b505af415801561361f573d6000803e3d6000fd5b505050506040513d602081101561363557600080fd5b505160280281151561364357fe5b048111155b156136ce5760647384d626b2bb4d0f064067e4bf80fce7055d8f3e7b63907af6c06040518163ffffffff1660e060020a02815260040160206040518083038186803b15801561369657600080fd5b505af41580156136aa573d6000803e3d6000fd5b505050506040513d60208110156136c057600080fd5b505160320281151561352f57fe5b60647384d626b2bb4d0f064067e4bf80fce7055d8f3e7b63907af6c06040518163ffffffff1660e060020a02815260040160206040518083038186803b15801561371757600080fd5b505af415801561372b573d6000803e3d6000fd5b505050506040513d602081101561374157600080fd5b505160280281151561374f57fe5b04811180156137df575060647384d626b2bb4d0f064067e4bf80fce7055d8f3e7b63907af6c06040518163ffffffff1660e060020a02815260040160206040518083038186803b1580156137a257600080fd5b505af41580156137b6573d6000803e3d6000fd5b505050506040513d60208110156137cc57600080fd5b50516032028115156137da57fe5b048111155b156138655760647384d626b2bb4d0f064067e4bf80fce7055d8f3e7b63907af6c06040518163ffffffff1660e060020a02815260040160206040518083038186803b15801561382d57600080fd5b505af4158015613841573d6000803e3d6000fd5b505050506040513d602081101561385757600080fd5b5051604b0281151561352f57fe5b60647384d626b2bb4d0f064067e4bf80fce7055d8f3e7b63907af6c06040518163ffffffff1660e060020a02815260040160206040518083038186803b1580156138ae57600080fd5b505af41580156138c2573d6000803e3d6000fd5b505050506040513d60208110156138d857600080fd5b50516032028115156138e657fe5b0481118015613976575060647384d626b2bb4d0f064067e4bf80fce7055d8f3e7b63907af6c06040518163ffffffff1660e060020a02815260040160206040518083038186803b15801561393957600080fd5b505af415801561394d573d6000803e3d6000fd5b505050506040513d602081101561396357600080fd5b505160640281151561397157fe5b048111155b156139fc5760647384d626b2bb4d0f064067e4bf80fce7055d8f3e7b63907af6c06040518163ffffffff1660e060020a02815260040160206040518083038186803b1580156139c457600080fd5b505af41580156139d8573d6000803e3d6000fd5b505050506040513d60208110156139ee57600080fd5b5051605a0281151561352f57fe5b60647384d626b2bb4d0f064067e4bf80fce7055d8f3e7b63907af6c06040518163ffffffff1660e060020a02815260040160206040518083038186803b158015613a4557600080fd5b505af4158015613a59573d6000803e3d6000fd5b505050506040513d6020811015613a6f57600080fd5b5051606402811515613a7d57fe5b049392505050565b600681565b6201518081565b6000612d33600b54836149af90919063ffffffff16565b600854600160a060020a031681565b6000612d33613b41600c547384d626b2bb4d0f064067e4bf80fce7055d8f3e7b63907af6c06040518163ffffffff1660e060020a02815260040160206040518083038186803b158015613b0957600080fd5b505af4158015613b1d573d6000803e3d6000fd5b505050506040513d6020811015613b3357600080fd5b50519063ffffffff613f7416565b839063ffffffff6149af16565b600e54600160a060020a031681565b600754600160a060020a03163314613be5576040805160e560020a62461bcd02815260206004820152603360248201527f4f6e6c79207468652073796e74686574697820636f6e74726163742063616e2060448201527f706572666f726d207468697320616374696f6e00000000000000000000000000606482015290519081900360840190fd5b601554613bf8908263ffffffff61429116565b60155550565b6000612d33612d2683613a91565b73feefeefeefeefeefeefeefeefeefeefeefeefeef81565b600254600160a060020a031681565b624f1a0081565b600254600160a060020a03163314613c5f5760038054600160a060020a031916331790555b600054600354600160a060020a03908116911614613cc9576040805160e560020a62461bcd02815260206004820152602e60248201526000805160206159da8339815191526044820152600080516020615a1a833981519152606482015290519081900360840190fd5b600160a060020a0381161515613d29576040805160e560020a62461bcd02815260206004820152601e60248201527f4e65772053796e746865746978206d757374206265206e6f6e2d7a65726f0000604482015290519081900360640190fd5b60078054600160a060020a031916600160a060020a038316179055610bc8816149d3565b6002546040805160208082018590528251808303820181528284018085527f466565506572696f644475726174696f6e557064617465642875696e7432353690527f29000000000000000000000000000000000000000000000000000000000000006060840152925191829003606101822060e060020a63907dff97028352600160248401819052604484018290526000606485018190526084850181905260a4850181905260c060048601908152865160c48701528651600160a060020a039098169763907dff979796939592938493849392839260e401918a0190808383885b83811015613e47578181015183820152602001613e2f565b50505050905090810190601f168015613e745780820380516001836020036101000a031916815260200191505b50975050505050505050600060405180830381600087803b158015611ea257600080fd5b60025460408051600160a060020a038481166020808401919091528351808403820181528385018086527f466565506f6f6c537461746555706461746564286164647265737329000000009052935192839003605c01832060e060020a63907dff97028452600160248501819052604485018290526000606486018190526084860181905260a4860181905260c060048701908152875160c48801528751959098169763907dff97979692959394919384938493839260e490920191908a01908083838883811015613e47578181015183820152602001613e2f565b60008083831115613f8457600080fd5b5050808203805b5092915050565b600080600860009054906101000a9004600160a060020a0316600160a060020a031663cd92eba96040518163ffffffff1660e060020a028152600401602060405180830381600087803b158015613fe857600080fd5b505af1158015613ffc573d6000803e3d6000fd5b505050506040513d602081101561401257600080fd5b50518511156140245760009150614172565b600854604080517f08d95cd500000000000000000000000000000000000000000000000000000000815260048101869052905161416c92879261416092600160a060020a03909216916308d95cd5916024808201926020929091908290030181600087803b15801561409557600080fd5b505af11580156140a9573d6000803e3d6000fd5b505050506040513d60208110156140bf57600080fd5b5051600854604080517f08d95cd5000000000000000000000000000000000000000000000000000000008152600481018c90529051600160a060020a03909216916308d95cd5916024808201926020929091908290030181600087803b15801561412857600080fd5b505af115801561413c573d6000803e3d6000fd5b505050506040513d602081101561415257600080fd5b50519063ffffffff614aaf16565b9063ffffffff614ac816565b90508091505b509392505050565b60008060008060006141958760e960020a622c222902611116565b909450925060008411806141a95750600083115b1515614225576040805160e560020a62461bcd02815260206004820152602481018290527f4e6f2066656573206f72207265776172647320617661696c61626c6520666f7260448201527f20706572696f642c206f72206665657320616c726561647920636c61696d6564606482015290519081900360840190fd5b601754614233908890614ae1565b600084111561425c5761424584614c00565b9150614252878388614d12565b61425c87836152b1565b60008311156142845761426e836153e6565b905061427a87826154ea565b6142848782615778565b5060019695505050505050565b60008282018381101561110957600080fd5b6000808080808080808a15156142bf576000975087965061439e565b8a955060008c11156142f1576142e1600160106000198f0160068110610ee957fe5b94506142ee858c8c613f92565b95505b6143188660108e6006811061430257fe5b60070201600301546149af90919063ffffffff16565b93506143418660108e6006811061432b57fe5b60070201600501546149af90919063ffffffff16565b9250614363614356858b63ffffffff6149af16565b859063ffffffff613f7416565b9150614385614378848b63ffffffff6149af16565b849063ffffffff613f7416565b90506143908261585b565b6143998261585b565b975097505b50505050505094509492505050565b6002546040805160208082018590528251808303820181528284018085527f466565506572696f64436c6f7365642875696e743235362900000000000000009052925191829003605801822060e060020a63907dff97028352600160248401819052604484018290526000606485018190526084850181905260a4850181905260c060048601908152865160c48701528651600160a060020a039098169763907dff979796939592938493849392839260e401918a01908083838883811015613e47578181015183820152602001613e2f565b6002546040805160208082018590528251808303820181528284018085527f45786368616e6765466565557064617465642875696e743235362900000000009052925191829003605b01822060e060020a63907dff97028352600160248401819052604484018290526000606485018190526084850181905260a4850181905260c060048601908152865160c48701528651600160a060020a039098169763907dff979796939592938493849392839260e401918a01908083838883811015613e47578181015183820152602001613e2f565b60025460408051600160a060020a038481166020808401919091528351808403820181528385018086527f44656c6567617465417070726f76616c7355706461746564286164647265737390527f29000000000000000000000000000000000000000000000000000000000000006060850152935192839003606101832060e060020a63907dff97028452600160248501819052604485018290526000606486018190526084860181905260a4860181905260c060048701908152875160c48801528751959098169763907dff97979692959394919384938493839260e490920191908a01908083838883811015613e47578181015183820152602001613e2f565b60028054604080516020808201889052818301879052606080830187905283518084039091018152608083018085527f49737375616e636544656274526174696f456e74727928616464726573732c7590527f696e743235362c75696e743235362c75696e743235362900000000000000000060a084015292519182900360b701822060e060020a63907dff970283526024830186905260448301819052600160a060020a038a81166064850181905260006084860181905260a4860181905260c060048701908152875160c48801528751939098169863907dff9798909694959294919384939192839260e490910191908a0190808383885b8381101561476757818101518382015260200161474f565b50505050905090810190601f1680156147945780820380516001836020036101000a031916815260200191505b50975050505050505050600060405180830381600087803b1580156147b857600080fd5b505af11580156147cc573d6000803e3d6000fd5b5050505050505050565b60025460408051600160a060020a038481166020808401919091528351808403820181528385018086527f466565417574686f7269747955706461746564286164647265737329000000009052935192839003605c01832060e060020a63907dff97028452600160248501819052604485018290526000606486018190526084860181905260a4860181905260c060048701908152875160c48801528751959098169763907dff97979692959394919384938493839260e490920191908a01908083838883811015613e47578181015183820152602001613e2f565b6000611109826148d085670de0b6b3a764000063ffffffff61587b16565b9063ffffffff6158a916565b6002546040805160208082018590528251808303820181528284018085527f5472616e73666572466565557064617465642875696e743235362900000000009052925191829003605b01822060e060020a63907dff97028352600160248401819052604484018290526000606485018190526084850181905260a4850181905260c060048601908152865160c48701528651600160a060020a039098169763907dff979796939592938493849392839260e401918a01908083838883811015613e47578181015183820152602001613e2f565b6000670de0b6b3a76400006149ca848463ffffffff61587b16565b811515613a7d57fe5b60025460408051600160a060020a038481166020808401919091528351808403820181528385018086527f53796e74686574697855706461746564286164647265737329000000000000009052935192839003605901832060e060020a63907dff97028452600160248501819052604485018290526000606486018190526084860181905260a4860181905260c060048701908152875160c48801528751959098169763907dff97979692959394919384938493839260e490920191908a01908083838883811015613e47578181015183820152602001613e2f565b600061110983836b033b2e3c9fd0803ce80000006158cc565b600061110983836b033b2e3c9fd0803ce8000000615904565b600a54604080517f6c6173745f6665655f7769746864726177616c00000000000000000000000000602080830191909152600160a060020a038681166c010000000000000000000000000283850152835180840360340181526054909301938490528251941693633562fd2093918291908401908083835b60208310614b785780518252601f199092019160209182019101614b59565b5181516020939093036101000a60001901801990911692169190911790526040805191909301819003812063ffffffff871660e060020a028252600482015260248101889052915160448084019550600094509092839003019050818387803b158015614be457600080fd5b505af1158015614bf8573d6000803e3d6000fd5b505050505050565b60008181600581805b6006831015614d0457614c4f60108460068110614c2257fe5b6007020160040154601085600681101515614c3957fe5b6007020160030154613f7490919063ffffffff16565b91506000821115614cf857848210614c675784614c69565b815b9050614c928160108560068110614c7c57fe5b600702016004015461429190919063ffffffff16565b60108460068110614c9f57fe5b6007020160040181905550614cbd8186613f7490919063ffffffff16565b9450614ccf848263ffffffff61429116565b9350841515614ce057839550614d08565b82158015614cee5750600085115b15614cf857600094505b60001990920191614c09565b8395505b5050505050919050565b6000808085600160a060020a03811673feefeefeefeefeefeefeefeefeefeefeefeefeef1415614d8c576040805160e560020a62461bcd02815260206004820152601760248201527f4665652061646472657373206e6f7420616c6c6f776564000000000000000000604482015290519081900360640190fd5b600160a060020a0387161515614dec576040805160e560020a62461bcd02815260206004820152601260248201527f4163636f756e742063616e277420626520300000000000000000000000000000604482015290519081900360640190fd5b600160a060020a038716301415614e4d576040805160e560020a62461bcd02815260206004820152601b60248201527f43616e27742073656e64206665657320746f2066656520706f6f6c0000000000604482015290519081900360640190fd5b600254600160a060020a0388811691161415614eb3576040805160e560020a62461bcd02815260206004820152601860248201527f43616e27742073656e64206665657320746f2070726f78790000000000000000604482015290519081900360640190fd5b600754600160a060020a0388811691161415614f19576040805160e560020a62461bcd02815260206004820152601c60248201527f43616e27742073656e64206665657320746f2073796e74686574697800000000604482015290519081900360640190fd5b600754604080517f502b8bda00000000000000000000000000000000000000000000000000000000815260e960020a622c22290260048201529051600160a060020a039092169163502b8bda916024808201926020929091908290030181600087803b158015614f8857600080fd5b505af1158015614f9c573d6000803e3d6000fd5b505050506040513d6020811015614fb257600080fd5b5051600754604080517f502b8bda000000000000000000000000000000000000000000000000000000008152600160e060020a0319891660048201529051929650600160a060020a039091169163502b8bda916024808201926020929091908290030181600087803b15801561502757600080fd5b505af115801561503b573d6000803e3d6000fd5b505050506040513d602081101561505157600080fd5b5051604080517f9dc29fac00000000000000000000000000000000000000000000000000000000815273feefeefeefeefeefeefeefeefeefeefeefeefeef6004820152602481018990529051919450600160a060020a03861691639dc29fac9160448082019260009290919082900301818387803b1580156150d257600080fd5b505af11580156150e6573d6000803e3d6000fd5b50506007546040805160e660020a62e759bf02815260e960020a622c2229026004820152602481018b9052600160e060020a03198a1660448201529051600160a060020a0390921693506339d66fc092506064808201926020929091908290030181600087803b15801561515957600080fd5b505af115801561516d573d6000803e3d6000fd5b505050506040513d602081101561518357600080fd5b5051604080517f867904b4000000000000000000000000000000000000000000000000000000008152600160a060020a038a811660048301526024820184905291519294509085169163867904b49160448082019260009290919082900301818387803b1580156151f357600080fd5b505af1158015615207573d6000803e3d6000fd5b5050604080517feb6ecc0300000000000000000000000000000000000000000000000000000000815273feefeefeefeefeefeefeefeefeefeefeefeefeef6004820152600160a060020a038b81166024830152604482018790529151918716935063eb6ecc03925060648082019260009290919082900301818387803b15801561529057600080fd5b505af11580156152a4573d6000803e3d6000fd5b5050505050505050505050565b60025460408051600160a060020a03858116602080840191909152828401869052835180840385018152606084018086527f46656573436c61696d656428616464726573732c75696e7432353629000000009052935192839003607c01832060e060020a63907dff97028452600160248501819052604485018290526000606486018190526084860181905260a4860181905260c060048701908152875160c48801528751959098169763907dff97979692959394919384938493839260e490920191908a0190808383885b8381101561539557818101518382015260200161537d565b50505050905090810190601f1680156153c25780820380516001836020036101000a031916815260200191505b50975050505050505050600060405180830381600087803b158015614be457600080fd5b60008181600581805b6006831015614d04576154356010846006811061540857fe5b600702016006015460108560068110151561541f57fe5b6007020160050154613f7490919063ffffffff16565b915060008211156154de5784821061544d578461544f565b815b9050615478816010856006811061546257fe5b600702016006015461429190919063ffffffff16565b6010846006811061548557fe5b60070201600601819055506154a38186613f7490919063ffffffff16565b94506154b5848263ffffffff61429116565b93508415156154c657839550614d08565b821580156154d45750600085115b156154de57600094505b600019909201916153ef565b81600160a060020a03811673feefeefeefeefeefeefeefeefeefeefeefeefeef1415615560576040805160e560020a62461bcd02815260206004820152601760248201527f4665652061646472657373206e6f7420616c6c6f776564000000000000000000604482015290519081900360640190fd5b600160a060020a03831615156155c0576040805160e560020a62461bcd02815260206004820152601260248201527f4163636f756e742063616e277420626520300000000000000000000000000000604482015290519081900360640190fd5b600160a060020a038316301415615621576040805160e560020a62461bcd02815260206004820152601e60248201527f43616e27742073656e64207265776172647320746f2066656520706f6f6c0000604482015290519081900360640190fd5b600254600160a060020a0384811691161415615687576040805160e560020a62461bcd02815260206004820152601b60248201527f43616e27742073656e64207265776172647320746f2070726f78790000000000604482015290519081900360640190fd5b600754600160a060020a03848116911614156156ed576040805160e560020a62461bcd02815260206004820152601f60248201527f43616e27742073656e64207265776172647320746f2073796e74686574697800604482015290519081900360640190fd5b600954604080517fb5ddb9c7000000000000000000000000000000000000000000000000000000008152600160a060020a038681166004830152602482018690529151919092169163b5ddb9c791604480830192600092919082900301818387803b15801561575b57600080fd5b505af115801561576f573d6000803e3d6000fd5b50505050505050565b60025460408051600160a060020a03858116602080840191909152828401869052835180840385018152606084018086527f52657761726473436c61696d656428616464726573732c75696e7432353629009052935192839003607f01832060e060020a63907dff97028452600160248501819052604485018290526000606486018190526084860181905260a4860181905260c060048701908152875160c48801528751959098169763907dff97979692959394919384938493839260e490920191908a0190808383888381101561539557818101518382015260200161537d565b60006305f5e10082046005600a82061061587357600a015b600a81613a7d565b60008083151561588e5760009150613f8b565b5082820282848281151561589e57fe5b041461110957600080fd5b6000808083116158b857600080fd5b82848115156158c357fe5b04949350505050565b6000806158e6846148d087600a870263ffffffff61587b16565b90506005600a825b06106158f857600a015b600a9004949350505050565b600080600a830461591b868663ffffffff61587b16565b81151561592457fe5b0490506005600a826158ee565b610180604051908101604052806006905b61594a61599e565b8152602001906001900390816159425790505090565b60e060405190810160405280600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b6040805180820182529060029082908038833950919291505056004f6e6c792074686520636f6e7472616374206f776e6572206d617920706572665468697320616374696f6e2063616e206f6e6c7920626520706572666f726d656f726d207468697320616374696f6e00000000000000000000000000000000006420627920746865206f776e6572000000000000000000000000000000000000a165627a7a72305820119fb381378ac0205235d0b1a577efa42ce42f1460da22c6cb8a78ffc7a6f3df00296f756c64207265737065637420746865206d6178696d756d2066656520726174000000000000000000000000b440dd674e1243644791a4adfe3a2abb0a92d309000000000000000000000000b64ff7a4a33acdf48d97dab0d764afd0f617688200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c9dfff5fa5605fd94f8b7927b892f2b57391e8bb0000000000000000000000004b9ca5607f1ff8019c1c6a3c2f0cc8de622d5b82000000000000000000000000b671f2210b1f6621a2607ea63e6b2dc3e2464d1f000000000000000000000000fee056f4d9d63a63d6cf16707d49ffae7ff3ff010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000aa87bee538000",
  "constructorArguments": "000000000000000000000000b440dd674e1243644791a4adfe3a2abb0a92d309000000000000000000000000b64ff7a4a33acdf48d97dab0d764afd0f617688200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c9dfff5fa5605fd94f8b7927b892f2b57391e8bb0000000000000000000000004b9ca5607f1ff8019c1c6a3c2f0cc8de622d5b82000000000000000000000000b671f2210b1f6621a2607ea63e6b2dc3e2464d1f000000000000000000000000fee056f4d9d63a63d6cf16707d49ffae7ff3ff010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000aa87bee538000",
  "libraries": [
    {
      "name": "SafeDecimalMath",
      "address": "0x84D626B2BB4D0F064067e4BF80FCe7055d8F3E7B"
    }
  ]
}