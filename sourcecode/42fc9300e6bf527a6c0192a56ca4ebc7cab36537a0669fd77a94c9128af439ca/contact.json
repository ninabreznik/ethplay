{
  "address": "0xbadac68d3d59b3156de50ce7e2b7c756cbe52fee",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "stakethemall",
  "compilerVersion": "v0.4.25+commit.59dbf8f1",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2019-02-25\n*/\n\n/*\n\nIntroducing \"STAKE THEM ALL\" Version 1.0\n\"STAKE THEM ALL\" is playable @ https://stakethemall.io (Ethereum Edition) and https://trx.stakethemall.io (TRON Edition)\n\nAbout the game :\n\n\"STAKE THEM ALL\" IS A FUN AND REWARDING PHYSICS GAME RUNNING ON THE BLOCKCHAIN\nHAVE FUN WHILE PARTICIPATING TO THE HDX20 TOKEN PRICE APPRECIATION @ https://hdx20.io\n\nHow to play \"STAKE THEM ALL\":\n\nChallenge MODE\n--------------\nSet the difficulty of your CHALLENGE by choosing how many cube you want\nto stack on top of each other and get rewarded on success.\n\nBuilder MODE\n------------\nStack 15 cubes in order to reach the maximum height. \nThe best score, if not beaten within a 24H countdown, wins the whole POT.   \n   \n\nThis product is copyrighted. Any unauthorized copy, modification, or use without express written consent from HyperDevbox is prohibited.\n\nCopyright 2019 HyperDevbox\n\n*/\n\n\n\n\npragma solidity ^0.4.25;\n\n\ninterface HDX20Interface\n{\n    function() payable external;\n    \n    \n    function buyTokenFromGame( address _customerAddress , address _referrer_address ) payable external returns(uint256);\n  \n    function payWithToken( uint256 _eth , address _player_address ) external returns(uint256);\n  \n    function appreciateTokenPrice() payable external;\n   \n    function totalSupply() external view returns(uint256); \n    \n    function ethBalanceOf(address _customerAddress) external view returns(uint256);\n  \n    function balanceOf(address _playerAddress) external view returns(uint256);\n    \n    function sellingPrice( bool includeFees) external view returns(uint256);\n  \n}\n\n\n\ncontract stakethemall\n{\n     HDX20Interface private HDXcontract = HDX20Interface(0x8942a5995bd168f347f7ec58f25a54a9a064f882);\n     \n     using SafeMath for uint256;\n     using SafeMath128 for uint128;\n     \n     /*==============================\n    =            EVENTS            =\n    ==============================*/\n    event OwnershipTransferred(\n        \n         address previousOwner,\n         address nextOwner,\n          uint256 timeStamp\n         );\n         \n    event HDXcontractChanged(\n        \n         address previous,\n         address next,\n         uint256 timeStamp\n         );\n \n  \n    \n\t    \n     event onWithdrawGains(\n        address customerAddress,\n        uint256 ethereumWithdrawn,\n        uint256 timeStamp\n    );\n    \n     event onBuyMode1(\n        address     customerAddress,\n        uint256     BatchID,\n        uint256     BatchBlockTimeout,  \n        uint32      Challenge\n        );  \n        \n    event onBuyMode2(\n        address     customerAddress,\n        uint256     BatchID,\n        uint256     BatchBlockTimeout,  \n        uint256     nb_token\n        );   \n        \n    event onNewScoreMode1(\n        uint256 score,\n        address customerAddress,\n        uint256 winning,\n        uint256 nb_token\n    ); \n    \n    event onNewScoreMode2(\n        uint256 score,\n        address       customerAddress,\n        bool    newHighscore\n      \n    ); \n        \n  \n        \n    event onChangeMinimumPrice(\n        \n         uint256 minimum,\n         uint256 timeStamp\n         );\n         \n  \n      event onChangeBlockTimeout(\n        \n         uint32 b1,\n         uint32 b2\n         );\n         \n        event onChangeTreasurePercentage(\n        \n         uint32 percentage\n         );\n         \n       \n         \n    /*==============================\n    =            MODIFIERS         =\n    ==============================*/\n    modifier onlyOwner\n    {\n        require (msg.sender == owner );\n        _;\n    }\n    \n    modifier onlyFromHDXToken\n    {\n        require (msg.sender == address( HDXcontract ));\n        _;\n    }\n   \n     modifier onlyDirectTransaction\n    {\n        require (msg.sender == tx.origin);\n        _;\n    }\n\n  \n    address public owner;\n  \n   \n    address public signerAuthority = 0xf77444cE64f3F46ba6b63F6b9411dF9c589E3319;\n   \n    \n\n    constructor () public\n    {\n        owner = msg.sender;\n       \n        GameRoundData.extraData[0] = 20; //mode1 20%\n        GameRoundData.extraData[1] = 0; //mode2 current highscore\n\t    GameRoundData.extraData[2] = uint32((3600*1) / 15);     //1 hour\n\t    GameRoundData.extraData[3] = uint32((3600*24) / 15);     //24 hour\n        \n        \n        if ( address(this).balance > 0)\n        {\n            owner.transfer( address(this).balance );\n        }\n    }\n    \n    function changeOwner(address _nextOwner) public\n    onlyOwner\n    {\n        require (_nextOwner != owner);\n        require(_nextOwner != address(0));\n         \n        emit OwnershipTransferred(owner, _nextOwner , now);\n         \n        owner = _nextOwner;\n    }\n    \n    function changeSigner(address _nextSigner) public\n    onlyOwner\n    {\n        require (_nextSigner != signerAuthority);\n        require(_nextSigner != address(0));\n      \n        signerAuthority = _nextSigner;\n    }\n    \n    function changeHDXcontract(address _next) public\n    onlyOwner\n    {\n        require (_next != address( HDXcontract ));\n        require( _next != address(0));\n         \n        emit HDXcontractChanged(address(HDXcontract), _next , now);\n         \n        HDXcontract  = HDX20Interface( _next);\n    }\n  \n  \n    function changeMinimumPrice( uint256 newmini) public\n    onlyOwner\n    {\n      \n      if (newmini>0)\n      {\n          minimumSharePrice = newmini;\n      }\n       \n      emit onChangeMinimumPrice( newmini , now ); \n    }\n    \n    \n    function changeBlockTimeout( uint32 b1 , uint32 b2) public\n    onlyOwner\n    {\n        require( b1>0 && b2>0 );\n        \n       \n        GameRoundData.extraData[2] = b1;\n        GameRoundData.extraData[3] = b2;\n            \n        emit onChangeBlockTimeout( b1,b2 ); \n        \n       \n       \n    }\n    \n    function changeTreasurePercentage( uint32 percentage) public\n    onlyOwner\n    {\n        require( percentage>0 && percentage<=100);\n        \n        GameRoundData.extraData[0] = percentage;\n          \n        emit onChangeTreasurePercentage( percentage ); \n       \n       \n       \n    }\n    \n     /*================================\n    =       GAMES VARIABLES         =\n    ================================*/\n    \n    struct PlayerData_s\n    {\n   \n        uint256 chest;  \n        uint256 payoutsTo;\n       \n\t\t//credit locked until we validate the score mode1\n\t\tuint256         mode1LockedCredit;\t\n\t\tuint256         mode1BatchID;         \n        uint256         mode1BlockTimeout;   \n        \n        uint256         mode2BatchID;         \n        uint256         mode2BlockTimeout;   \n\n\t\tuint32[2]\t\tpackedData;\t\t//[0] = mode1 challenge how ,any cube to stack;\n\t\t                                //[1] = mode1 multiplier\n\t\t\t\t\t\t\n    }\n    \n    \n    struct GameRoundData_s\n    {\n\t   \n\t   //mode1 \n\t   uint256\t\t\t\ttreasureAmount;\n\t   \n\t   //mode2\n\t   uint256              potAmount;\n\t   address\t\t\t\tcurrentPotWinner;\n\t   uint256              potBlockCountdown;\n\t          \n       uint256              hdx20AppreciationPayout;\n       uint256              devAppreciationPayout;\n\t   \n       //********************************************************************************************\n\t   \n\t   uint32[4]\t\t\textraData;\t\t//[0] = mode1 percentage    treasure\n\t\t\t\t\t\t\t\t\t        //[1] =\tmode2 current       highscore\n                                            //[2] = mode1 and mode2 blocktimeout  how manyblock to submit a valid score\n                                            //[3] = mode2 countdown how many block\n                                           \n                                            \n    }\n      \n   \n    mapping (address => PlayerData_s)   private PlayerData;\n       \n    GameRoundData_s   private GameRoundData;\n   \n    uint8 constant private HDX20BuyFees = 5;\n     \n    uint8 constant private DevFees = 5;\n\tuint8 constant private AppreciationFees = 15;\t\t\n\n\tuint8 constant private TreasureAppreciation = 80;\n   \tuint8 constant private PotAppreciation = 80;\n   \t\n   \n    uint256 constant internal magnitude = 1e18;\n     \n    uint256 private minimumSharePrice = 0.1 ether;\n    \n\n    uint256 constant thresholdForAppreciation = 0.05 ether;\n      \n    /*================================\n    =       PUBLIC FUNCTIONS         =\n    ================================*/\n    \n    //fallback will be called only from the HDX token contract to fund the game from customers's HDX20\n    \n     function()\n     payable\n     public\n     onlyFromHDXToken \n    {\n       \n      \n      \n          \n    }\n    \n    function ChargePot() public payable\n    {\n\t\tuint256 _val = msg.value;\n\t\t\n\t\tGameRoundData.potAmount = GameRoundData.potAmount.add( _val );\n\t\n    }\n    \n    function ChargeTreasure() public payable\n    {\n\t\tuint256 _val = msg.value;\n\t\n\t\t\n\t\tGameRoundData.treasureAmount = GameRoundData.treasureAmount.add( _val );\n\t\t\t\t   \n    }\n\t\n\t//mode1\n\tfunction AddTreasure( uint256 _val ) private\n\t{\n\t\n\t\tGameRoundData.treasureAmount = GameRoundData.treasureAmount.add( _val.mul( TreasureAppreciation ) / 100 );\n\t\t\n\t\t//now HDX20 appreciation and dev account\n\t\t\n\t\tuint256 _appreciation = SafeMath.mul( _val , AppreciationFees) / 100; \n          \n        uint256 _dev = SafeMath.mul( _val , DevFees) / 100;  \n\t\t\n\t\t_dev = _dev.add( GameRoundData.devAppreciationPayout );\n\t\t\n\t\tif (_dev>= thresholdForAppreciation )\n\t\t{\n\t\t\tGameRoundData.devAppreciationPayout = 0;\n\t\t\t\n\t\t\tHDXcontract.buyTokenFromGame.value( _dev )( owner , address(0));\t\n\t\t}\n\t\telse\n\t\t{\n\t\t\t GameRoundData.devAppreciationPayout = _dev;\n\t\t}\n\t\n\t\t_appreciation = _appreciation.add( GameRoundData.hdx20AppreciationPayout );\n\t\t\n\t\tif (_appreciation>= thresholdForAppreciation)\n\t\t{\n\t\t\tGameRoundData.hdx20AppreciationPayout = 0;\n\t\t\t\n\t\t\tHDXcontract.appreciateTokenPrice.value( _appreciation )();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tGameRoundData.hdx20AppreciationPayout = _appreciation;\n\t\t}\n\t\t\n\t}\n\t\n    //mode2\n\tfunction AddPot( uint256 _val ) private\n\t{\n\t    \n        \n\t\tGameRoundData.potAmount = GameRoundData.potAmount.add( _val.mul( PotAppreciation ) / 100 );\n\t\t\n\t\t//now HDX20 appreciation and dev account\n\t\t\n\t\tuint256 _appreciation = SafeMath.mul( _val , AppreciationFees) / 100; \n          \n        uint256 _dev = SafeMath.mul( _val , DevFees) / 100;  \n\t\t\n\t\t_dev = _dev.add( GameRoundData.devAppreciationPayout );\n\t\t\n\t\tif (_dev>= thresholdForAppreciation )\n\t\t{\n\t\t\tGameRoundData.devAppreciationPayout = 0;\n\t\t\t\n\t\t\tHDXcontract.buyTokenFromGame.value( _dev )( owner , address(0));\t\n\t\t}\n\t\telse\n\t\t{\n\t\t\t GameRoundData.devAppreciationPayout = _dev;\n\t\t}\n\t\n\t\t_appreciation = _appreciation.add( GameRoundData.hdx20AppreciationPayout );\n\t\t\n\t\tif (_appreciation>= thresholdForAppreciation)\n\t\t{\n\t\t\tGameRoundData.hdx20AppreciationPayout = 0;\n\t\t\t\n\t\t\tHDXcontract.appreciateTokenPrice.value( _appreciation )();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tGameRoundData.hdx20AppreciationPayout = _appreciation;\n\t\t}\n\t\t\n\t}\n    \n    \n    function ValidMode1Score( uint256 score, uint256 mode1BatchID , bytes32 r , bytes32 s , uint8 v) public\n    onlyDirectTransaction\n    {\n        address _customer_address = msg.sender;\n      \n        GameVar_s memory gamevar;\n        gamevar.score = score;\n        gamevar.BatchID = mode1BatchID;\n        gamevar.r = r;\n        gamevar.s = s;\n        gamevar.v = v;\n   \n        checkPayPot();\n   \n        coreValidMode1Score( _customer_address , gamevar  );\n    }\n    \n    function ValidMode2Score( uint256 score, uint256 mode2BatchID , bytes32 r , bytes32 s , uint8 v) public\n    onlyDirectTransaction\n    {\n        address _customer_address = msg.sender;\n      \n        GameVar_s memory gamevar;\n        gamevar.score = score;\n        gamevar.BatchID = mode2BatchID;\n        gamevar.r = r;\n        gamevar.s = s;\n        gamevar.v = v;\n        \n        checkPayPot();\n   \n        coreValidMode2Score( _customer_address , gamevar  );\n    }\n    \n    struct GameVar_s\n    {\n        uint256  BatchID;\n       \n \t    uint256   score;\n\t\n        bytes32  r;\n        bytes32  s;\n        uint8    v;\n        uint32   multiplier;\n    }\n    \n\tfunction checkPayPot() private\n\t{\n\t    uint256 b1 =  GameRoundData.potBlockCountdown;\n\t    \n\t    if (b1>0)\n\t    {\n\t        if (block.number>=b1)\n\t        {\n    \t\t    address _winner = GameRoundData.currentPotWinner;\n    \t\t    uint256 _j = GameRoundData.potAmount/2;\n    \t\t\n    \t\t   \n    \t\t\n    \t\t    if (_winner != address(0))\n    \t\t    {\n    \t\t\t    PlayerData[ _winner ].chest = PlayerData[ _winner ].chest.add( _j ); \n    \t\t    }\n    \t\t    \n        \t\tGameRoundData.currentPotWinner = address(0);\n        \t\tGameRoundData.potAmount = GameRoundData.potAmount.sub( _j );\n        \t\t\n        \t    //highscore to 0\n        \t\tGameRoundData.extraData[1] = 0;\n        \t\t//block at 0\n        \t\tGameRoundData.potBlockCountdown = 0;\n        \t\t\n    \t\t}\n\t    }\n\t\t\n\t}\n  \n    \n    function coreValidMode1Score( address _player_address , GameVar_s gamevar) private\n    {\n    \n        PlayerData_s storage  _PlayerData = PlayerData[ _player_address];\n                \n        require((gamevar.BatchID != 0) && (gamevar.BatchID == _PlayerData.mode1BatchID) && ( _PlayerData.mode1LockedCredit>0 ));\n        \n        if (block.number>=_PlayerData.mode1BlockTimeout || (ecrecover(keccak256(abi.encodePacked( gamevar.score,gamevar.BatchID )) , gamevar.v, gamevar.r, gamevar.s) != signerAuthority))\n        {\n            gamevar.score = 0;\n        }\n\t\t\n\t\n\t    if (gamevar.score> _PlayerData.packedData[0]) \tgamevar.score =  _PlayerData.packedData[0];\n\t    \n\t    uint256 _winning =0;\n\t    uint256 _hdx20 = 0;\n\t    uint256 _nb_token = 0;\n\t    uint256 _minimum =  _PlayerData.mode1LockedCredit.mul(5) / 100;\n\t   \n\t    \n\t   \n\t    if (gamevar.score>0)\n\t    {\n\t        uint256 _gain;\n\t    \n\t        //percentage of treasure      \n\t        _gain = GameRoundData.treasureAmount.mul( GameRoundData.extraData[0]) / 100;\n\t        \n\t        //scale the gain based the credit size\n\t        _gain = _gain.mul( _PlayerData.packedData[1]) / 10;\n\t   \n\t        //triple cube curve     \n\t        _gain = _gain.mul( _PlayerData.packedData[0] * _PlayerData.packedData[0] * _PlayerData.packedData[0] );\n\t        _gain /= (10*10*10);\n\t        \n\t          //maximum x2\n\t        if (_gain>_PlayerData.mode1LockedCredit) _gain = _PlayerData.mode1LockedCredit;\n\t        \n\t        //succed challenge ?\n\t        if (gamevar.score==_PlayerData.packedData[0])\n\t        {\n\t            _winning = _PlayerData.mode1LockedCredit.add( _gain);\n\t        }\n\t        else\n\t        {\n\t            _winning = _PlayerData.mode1LockedCredit.sub( _gain );\n\t            _gain = (_gain).mul( gamevar.score-1 );\n\t            _gain /= uint256( _PlayerData.packedData[0] );\n\t            _winning = _winning.add( _gain );\n\t        }\n\t    }\n\t    \n\t    if (_winning<_minimum) _winning = _minimum;\n\t    \n\t   //winning cannot be zero \n\t   \n\t   //HDX20BuyFees\n        _hdx20 = (_winning.mul(HDX20BuyFees)) / 100;\n\t\n\t    _nb_token =   HDXcontract.buyTokenFromGame.value( _hdx20 )( _player_address , address(0)); \n\t     \n\t\t//credit the player for what is won minus the HDX20\n\t\t_PlayerData.chest = _PlayerData.chest.add( _winning - _hdx20 );\n\t\t\n\t\t//loosing some ?\n\t\t\n\t\tif (_PlayerData.mode1LockedCredit> _winning)\n\t\t{\n\t\t\t\n\t\t\tAddTreasure( _PlayerData.mode1LockedCredit - _winning );\n\t\t}\n\t\t\n\t\t//we need to pay the difference from the treasure\n\t\tif (_winning>_PlayerData.mode1LockedCredit)\n\t\t{\n\t\t    GameRoundData.treasureAmount = GameRoundData.treasureAmount.sub( _winning - _PlayerData.mode1LockedCredit);\n\t\t}\n\t\n        //ok reset it so we can get a new one\n        _PlayerData.mode1BatchID = 0;\n        _PlayerData.mode1LockedCredit = 0;\n\t\t\n        emit onNewScoreMode1( gamevar.score , _player_address , _winning , _nb_token );\n\n    }\n    \n    function coreValidMode2Score( address _player_address , GameVar_s gamevar) private\n    {\n    \n        PlayerData_s storage  _PlayerData = PlayerData[ _player_address];\n        \n                \n        if ((gamevar.BatchID != 0) && (gamevar.BatchID == _PlayerData.mode2BatchID))\n        {\n                \n            if (block.number>=_PlayerData.mode2BlockTimeout || (ecrecover(keccak256(abi.encodePacked( gamevar.score,gamevar.BatchID )) , gamevar.v, gamevar.r, gamevar.s) != signerAuthority))\n            {\n                gamevar.score = 0;\n            }\n    \t\t\n    \t\n    \t    if (gamevar.score>80*2*15) \tgamevar.score = 80*2*15;\n    \t    \n    \t    bool _newHighscore = false;\n    \t    \n    \t    //new highscore\n    \t    if (gamevar.score > GameRoundData.extraData[1])\n    \t    {\n    \t        GameRoundData.extraData[1] = uint32(gamevar.score);\n    \t        GameRoundData.currentPotWinner = _player_address;\n    \t        GameRoundData.potBlockCountdown = block.number + uint256( GameRoundData.extraData[3] ); //24 hours countdown start\n    \t        \n    \t        _newHighscore = true;\n    \t        \n    \t    }\n    \t    \n    \t    emit onNewScoreMode2( gamevar.score , _player_address , _newHighscore);\n        }\n\t \n        //ok reset it so we can get a new one\n        _PlayerData.mode2BatchID = 0;\n     \n\t\t\n\n    }\n    \n    \n    function BuyMode1WithDividends( uint256 eth , uint32 challenge, uint256 score, uint256 BatchID,  address _referrer_address , bytes32 r , bytes32 s , uint8 v) public\n    onlyDirectTransaction\n    {\n        \n        require( (eth==minimumSharePrice || eth==minimumSharePrice*5 || eth==minimumSharePrice*10) && (challenge>=4 && challenge<=10) );\n  \n        address _customer_address = msg.sender;\n        \n        checkPayPot();\n        \n        GameVar_s memory gamevar;\n        gamevar.score = score;\n        gamevar.BatchID = BatchID;\n        gamevar.r = r;\n        gamevar.s = s;\n        gamevar.v = v;\n        gamevar.multiplier = uint32(eth / minimumSharePrice);\n      \n        \n        eth = HDXcontract.payWithToken( eth , _customer_address );\n       \n        require( eth>0 );\n       \n         \n        CoreBuyMode1( _customer_address , eth , challenge, _referrer_address , gamevar );\n        \n       \n    }\n    \n \n    \n    function BuyMode1( uint32 challenge, uint256 score, uint256 BatchID, address _referrer_address , bytes32 r , bytes32 s , uint8 v ) public payable\n    onlyDirectTransaction\n    {\n     \n        address _customer_address = msg.sender;\n        uint256 eth = msg.value;\n        \n        require( (eth==minimumSharePrice || eth==minimumSharePrice*5 || eth==minimumSharePrice*10) && (challenge>=4 && challenge<=10));\n        \n        checkPayPot();\n   \n        GameVar_s memory gamevar;\n        gamevar.score = score;\n        gamevar.BatchID = BatchID;\n        gamevar.r = r;\n        gamevar.s = s;\n        gamevar.v = v;\n        gamevar.multiplier = uint32(eth / minimumSharePrice);\n     \n        CoreBuyMode1( _customer_address , eth , challenge, _referrer_address, gamevar);\n     \n    }\n    \n    \n    function BuyMode2WithDividends( uint256 eth , uint256 score, uint256 BatchID,  address _referrer_address , bytes32 r , bytes32 s , uint8 v) public\n    onlyDirectTransaction\n    {\n        \n        require( (eth==minimumSharePrice) );\n  \n        address _customer_address = msg.sender;\n        \n        checkPayPot();\n        \n        GameVar_s memory gamevar;\n        gamevar.score = score;\n        gamevar.BatchID = BatchID;\n        gamevar.r = r;\n        gamevar.s = s;\n        gamevar.v = v;\n      \n        \n        eth = HDXcontract.payWithToken( eth , _customer_address );\n       \n        require( eth>0 );\n       \n         \n        CoreBuyMode2( _customer_address , eth , _referrer_address , gamevar );\n        \n       \n    }\n    \n    \n    function BuyMode2( uint256 score, uint256 BatchID, address _referrer_address , bytes32 r , bytes32 s , uint8 v ) public payable\n    onlyDirectTransaction\n    {\n     \n        address _customer_address = msg.sender;\n        uint256 eth = msg.value;\n        \n        require( (eth==minimumSharePrice));\n        \n        checkPayPot();\n   \n        GameVar_s memory gamevar;\n        gamevar.score = score;\n        gamevar.BatchID = BatchID;\n        gamevar.r = r;\n        gamevar.s = s;\n        gamevar.v = v;\n     \n   \n        CoreBuyMode2( _customer_address , eth , _referrer_address, gamevar);\n     \n    }\n    \n    /*================================\n    =       CORE BUY FUNCTIONS       =\n    ================================*/\n    \n    function CoreBuyMode1( address _player_address , uint256 eth , uint32 challenge,  address _referrer_address , GameVar_s gamevar) private\n    {\n    \n        PlayerData_s storage  _PlayerData = PlayerData[ _player_address];\n         \n        //we need to validate the score before buying a torpedo batch\n        if (gamevar.BatchID !=0 || _PlayerData.mode1BatchID !=0)\n        {\n             coreValidMode1Score( _player_address , gamevar);\n        }\n        \n        //if we can continue then everything is fine let's create the new batch\n        \n        _PlayerData.packedData[0] = challenge;\n        _PlayerData.packedData[1] = gamevar.multiplier;\n        \n        _PlayerData.mode1BlockTimeout = block.number + (uint256(GameRoundData.extraData[2]));\n        _PlayerData.mode1BatchID = uint256((keccak256(abi.encodePacked( block.number,1,challenge, _player_address , address(this)))));\n      \n\t\t_PlayerData.mode1LockedCredit =  eth;\n\t\n        \n        emit onBuyMode1( _player_address, _PlayerData.mode1BatchID , _PlayerData.mode1BlockTimeout,  _PlayerData.packedData[0]);\n            \n        \n    }\n    \n    \n    function CoreBuyMode2( address _player_address , uint256 eth ,  address _referrer_address , GameVar_s gamevar) private\n    {\n    \n        PlayerData_s storage  _PlayerData = PlayerData[ _player_address];\n         \n        //we need to validate the score before buying a torpedo batch\n        if (gamevar.BatchID !=0 || _PlayerData.mode2BatchID !=0)\n        {\n             coreValidMode2Score( _player_address , gamevar);\n        }\n        \n        //if we can continue then everything is fine let's create the new batch\n        \n       \n        _PlayerData.mode2BlockTimeout = block.number + (uint256(GameRoundData.extraData[2]));\n        _PlayerData.mode2BatchID = uint256((keccak256(abi.encodePacked( block.number,2, _player_address , address(this)))));\n      \n         //HDX20BuyFees\n        uint256 _tempo = (eth.mul(HDX20BuyFees)) / 100;\n\t\n\t    eth = eth.sub( _tempo );\t\n\t\n        uint256 _nb_token =   HDXcontract.buyTokenFromGame.value( _tempo )( _player_address , _referrer_address);\n        \n        AddPot( eth );\n        \n        emit onBuyMode2( _player_address, _PlayerData.mode2BatchID , _PlayerData.mode2BlockTimeout, _nb_token );\n            \n        \n    }\n    \n    function getPotGain( address _player_address) private view\n    returns( uint256)\n\t{\n\t    uint256 b1 =  GameRoundData.potBlockCountdown;\n\t    \n\t    if (b1>0)\n\t    {\n\t        if (block.number>=b1 && _player_address==GameRoundData.currentPotWinner)\n\t        {\n\t            return( GameRoundData.potAmount/2);\n\t          \n    \t\t}\n\t    }\n\t    \n\t    return( 0 );\n\t\t\n\t}\n   \n    \n    function get_Gains(address _player_address) private view\n    returns( uint256)\n    {\n       \n        uint256 _gains = PlayerData[ _player_address ].chest;\n        \n        //we may have to temporary add the current pot gain to reflect the correct position\n        \n        _gains = _gains.add( getPotGain(_player_address ) );\n        \n        if (_gains > PlayerData[ _player_address].payoutsTo)\n        {\n            _gains -= PlayerData[ _player_address].payoutsTo;\n        }\n        else _gains = 0;\n     \n    \n        return( _gains );\n        \n    }\n    \n    \n    function WithdrawGains() public \n   \n    {\n        address _customer_address = msg.sender;\n        \n        checkPayPot();\n        \n        uint256 _gains = get_Gains( _customer_address );\n        \n        require( _gains>0);\n        \n        PlayerData[ _customer_address ].payoutsTo = PlayerData[ _customer_address ].payoutsTo.add( _gains );\n        \n      \n        emit onWithdrawGains( _customer_address , _gains , now);\n        \n        _customer_address.transfer( _gains );\n        \n        \n    }\n    \n   \n  \n    \n     /*================================\n    =  VIEW AND HELPERS FUNCTIONS    =\n    ================================*/\n  \n    \n    function view_get_Treasure() public\n    view\n    returns(uint256)\n    {\n      \n      return( GameRoundData.treasureAmount );  \n    }\n\t\n\tfunction view_get_Pot() public\n    view\n    returns(uint256)\n    {\n      \n      return( GameRoundData.potAmount );  \n    }\n \n    function view_get_gameData() public\n    view\n    returns( \n             uint256 treasure,\n\t\t\t uint256 pot,\n\t\t\t uint32  highscore ,\n\t\t\t address highscore_address ,\n\t\t\n\t\t\t uint256 mode1BatchID,\n\t\t     uint256 mode1BlockTimeout,\n\t\t     uint32  mode1Challenge,\n\t\t     uint256 mode1Multiplier,\n\t\t     \n\t\t\t uint256 mode2BatchID,\n\t\t\t uint256 mode2BlockTimeout,\n\t\t\t \n\t\t\t uint256 potBlockCountdown,\n\t\t\t \n\t\t\t uint32  percentage)\n    {\n        address _player_address = msg.sender;\n\t\t\n\t\ttreasure = GameRoundData.treasureAmount;\n\t\tpot = GameRoundData.potAmount;\n\t\thighscore = GameRoundData.extraData[1];\n\t\thighscore_address = GameRoundData.currentPotWinner;\n\t\tpercentage = GameRoundData.extraData[0];\n\t\t      \n        mode1BatchID = PlayerData[_player_address].mode1BatchID;\n        mode1BlockTimeout = PlayerData[_player_address].mode1BlockTimeout;\n        mode1Challenge = PlayerData[_player_address].packedData[0];\n        mode1Multiplier =  PlayerData[_player_address].packedData[1];\n        \n        mode2BatchID =  PlayerData[_player_address].mode2BatchID;\n        mode2BlockTimeout = PlayerData[ _player_address].mode2BlockTimeout;\n        \n        potBlockCountdown = GameRoundData.potBlockCountdown;\n        \n      \n       \n    }\n  \n       \n  \n    \n    function view_get_Gains()\n    public\n    view\n    returns( uint256 gains)\n    {\n        \n        address _player_address = msg.sender;\n   \n        uint256 _gains = PlayerData[ _player_address ].chest;\n        \n        _gains = _gains.add( getPotGain( _player_address ) );\n        \n        if (_gains > PlayerData[ _player_address].payoutsTo)\n        {\n            _gains -= PlayerData[ _player_address].payoutsTo;\n        }\n        else _gains = 0;\n     \n    \n        return( _gains );\n        \n    }\n  \n  \n    \n    function view_get_gameStates() public \n    view\n    returns( uint256 minimumshare ,\n\t\t     uint256 blockNumberCurrent,\n\t\t     uint32  blockScoreTimeout,\n\t\t     uint32  blockPotTimout\n\t\t   \n\t\t    )\n    {\n       \n        \n        return( minimumSharePrice ,  block.number   , GameRoundData.extraData[2] , GameRoundData.extraData[3] );\n    }\n    \n    function view_get_pendingHDX20Appreciation()\n    public\n    view\n    returns(uint256)\n    {\n        return GameRoundData.hdx20AppreciationPayout;\n    }\n    \n    function view_get_pendingDevAppreciation()\n    public\n    view\n    returns(uint256)\n    {\n        return GameRoundData.devAppreciationPayout;\n    }\n  \n \n \n    function totalEthereumBalance()\n    public\n    view\n    returns(uint256)\n    {\n        return address(this).balance;\n    }\n    \n  \n    \n    function view_get_blockNumbers()\n    public\n    view\n    returns( uint256 b1 )\n    {\n        return( block.number);\n        \n    }\n    \n  \n    \n   \n}\n\n\nlibrary SafeMath {\n    \n   \n    function mul(uint256 a, uint256 b) \n        internal \n        pure \n        returns (uint256 c) \n    {\n        if (a == 0) {\n            return 0;\n        }\n        c = a * b;\n        require(c / a == b);\n        return c;\n    }\n\n   \n    function sub(uint256 a, uint256 b)\n        internal\n        pure\n        returns (uint256) \n    {\n        require(b <= a);\n        return a - b;\n    }\n\n   \n    function add(uint256 a, uint256 b)\n        internal\n        pure\n        returns (uint256 c) \n    {\n        c = a + b;\n        require(c >= a);\n        return c;\n    }\n    \n   \n    \n  \n    \n   \n}\n\n\nlibrary SafeMath128 {\n    \n   \n    function mul(uint128 a, uint128 b) \n        internal \n        pure \n        returns (uint128 c) \n    {\n        if (a == 0) {\n            return 0;\n        }\n        c = a * b;\n        require(c / a == b);\n        return c;\n    }\n\n   \n    function sub(uint128 a, uint128 b)\n        internal\n        pure\n        returns (uint128) \n    {\n        require(b <= a);\n        return a - b;\n    }\n\n   \n    function add(uint128 a, uint128 b)\n        internal\n        pure\n        returns (uint128 c) \n    {\n        c = a + b;\n        require(c >= a);\n        return c;\n    }\n    \n   \n    \n  \n    \n   \n}",
  "bytecode": "608060405260008054600160a060020a0319908116738942a5995bd168f347f7ec58f25a54a9a064f882179091556002805490911673f77444ce64f3f46ba6b63f6b9411df9c589e331917905567016345785d8a0000600b5534801561006457600080fd5b506001805433600160a060020a0319909116179055600a805463ffffffff19166014176bffffffffffffffff00000000191668f0000000000000000017606060020a63ffffffff0219166d168000000000000000000000000017905560003031111561010657600154604051600160a060020a0390911690303180156108fc02916000818181858888f19350505050158015610104573d6000803e3d6000fd5b505b611f77806101156000396000f3006080604052600436106101535763ffffffff7c01000000000000000000000000000000000000000000000000000000006000350416630149eea0811461016c578063024abf33146101935780630f666426146101b957806311757911146101d15780631449c321146101e65780631c13aa0c146102275780631dec054d1461022f57806334b46d80146102565780635b3660961461028c57806361c95926146102ad5780636b2f4632146102de5780636ff0a3a9146102f357806373def3c9146103115780637b41ceef14610340578063844d38ee1461037f57806388037e1c146103945780638da5cb5b146104165780639b8fa9a71461042b578063a6f9dae114610440578063aad2b72314610461578063b395f27814610482578063bbf3553114610497578063bd679ab2146104ac578063f431a706146104c1578063fee13823146104e8578063ffe0531a146104f0575b600054600160a060020a0316331461016a57600080fd5b005b34801561017857600080fd5b50610181610514565b60408051918252519081900360200190f35b61016a600435602435600160a060020a036044351660643560843560ff60a4351661051a565b3480156101c557600080fd5b5061016a600435610585565b3480156101dd57600080fd5b506101816105e8565b3480156101f257600080fd5b506101fb6105ee565b60408051948552602085019390935263ffffffff91821684840152166060830152519081900360800190f35b61016a610621565b34801561023b57600080fd5b5061016a60043560243560443560643560ff6084351661063c565b34801561026257600080fd5b5061016a600435602435604435600160a060020a036064351660843560a43560ff60c43516610691565b34801561029857600080fd5b5061016a600160a060020a0360043516610798565b3480156102b957600080fd5b506102c261085a565b60408051600160a060020a039092168252519081900360200190f35b3480156102ea57600080fd5b50610181610869565b3480156102ff57600080fd5b5061016a63ffffffff6004351661086e565b61016a63ffffffff60043516602435604435600160a060020a036064351660843560a43560ff60c435166108fb565b34801561034c57600080fd5b5061016a60043563ffffffff60243516604435606435600160a060020a036084351660a43560c43560ff60e435166109c6565b34801561038b57600080fd5b50610181610b2e565b3480156103a057600080fd5b506103a9610bad565b604080519c8d5260208d019b909b5263ffffffff998a168c8c0152600160a060020a0390981660608c015260808b019690965260a08a019490945291861660c089015260e08801526101008701526101208601526101408501521661016083015251908190036101800190f35b34801561042257600080fd5b506102c2610c20565b34801561043757600080fd5b50610181610c2f565b34801561044c57600080fd5b5061016a600160a060020a0360043516610c35565b34801561046d57600080fd5b5061016a600160a060020a0360043516610cf7565b34801561048e57600080fd5b50610181610d6d565b3480156104a357600080fd5b50610181610d71565b3480156104b857600080fd5b5061016a610d77565b3480156104cd57600080fd5b5061016a60043560243560443560643560ff60843516610e60565b61016a610eac565b3480156104fc57600080fd5b5061016a63ffffffff60043581169060243516610ec7565b60045490565b600080610525611f16565b33321461053157600080fd5b600b54339350349250821461054557600080fd5b61054d610f9b565b60208101899052878152604081018690526060810185905260ff8416608082015261057a8383898461105f565b505050505050505050565b600154600160a060020a0316331461059c57600080fd5b60008111156105ab57600b8190555b6040805182815242602082015281517f96aff3d0ee4748c300128c53ba5612b8363232b00ab841ce27937cd52c8e0f28929181900390910190a150565b60055490565b600b54600a549091439163ffffffff6801000000000000000082048116926c010000000000000000000000009092041690565b6005543490610636908263ffffffff6112c116565b60055550565b6000610646611f16565b33321461065257600080fd5b60208101879052858152604081018590526060810184905260ff8316608082015233915061067e610f9b565b61068882826112d1565b50505050505050565b600061069b611f16565b3332146106a757600080fd5b600b5489146106b557600080fd5b3391506106c0610f9b565b602080820189905287825260408083018790526060830186905260ff851660808401526000805482517f52dde1c3000000000000000000000000000000000000000000000000000000008152600481018e9052600160a060020a038781166024830152935193909116936352dde1c39360448084019492939192918390030190829087803b15801561075157600080fd5b505af1158015610765573d6000803e3d6000fd5b505050506040513d602081101561077b57600080fd5b505198506000891161078c57600080fd5b61057a828a888461105f565b600154600160a060020a031633146107af57600080fd5b600054600160a060020a03828116911614156107ca57600080fd5b600160a060020a03811615156107df57600080fd5b60005460408051600160a060020a03928316815291831660208301524282820152517f87ab77b91a9a6a5a04a748607e0ee38d580963c4e21fe45d2e79ffeef26bc55e9181900360600190a16000805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b600254600160a060020a031681565b303190565b600154600160a060020a0316331461088557600080fd5b60008163ffffffff161180156108a2575060648163ffffffff1611155b15156108ad57600080fd5b600a805463ffffffff831663ffffffff19909116811790915560408051918252517f2ac8e2ffa440a5380440a919fbf3ffca1f2019bf4eb2083a56a7183e7f467e699181900360200190a150565b600080610906611f16565b33321461091257600080fd5b339250349150600b5482148061092c5750600b5460050282145b8061093b5750600b54600a0282145b8015610960575060048a63ffffffff16101580156109605750600a8a63ffffffff1611155b151561096b57600080fd5b610973610f9b565b60208101899052878152604081018690526060810185905260ff84166080820152600b54828115156109a157fe5b0463ffffffff1660a08201526109ba83838c8a8561154c565b50505050505050505050565b60006109d0611f16565b3332146109dc57600080fd5b600b548a14806109f05750600b546005028a145b806109ff5750600b54600a028a145b8015610a24575060048963ffffffff1610158015610a245750600a8963ffffffff1611155b1515610a2f57600080fd5b339150610a3a610f9b565b60208101889052868152604081018590526060810184905260ff83166080820152600b548a811515610a6857fe5b0463ffffffff1660a082015260008054604080517f52dde1c3000000000000000000000000000000000000000000000000000000008152600481018e9052600160a060020a038681166024830152915191909216926352dde1c392604480820193602093909283900390910190829087803b158015610ae657600080fd5b505af1158015610afa573d6000803e3d6000fd5b505050506040513d6020811015610b1057600080fd5b5051995060008a11610b2157600080fd5b6109ba828b8b898561154c565b33600081815260036020526040812054909190610b5a610b4d83611730565b829063ffffffff6112c116565b600160a060020a038316600090815260036020526040902060010154909150811115610ba357600160a060020a0382166000908152600360205260409020600101549003610ba7565b5060005b92915050565b6004805460058054600a5460068054336000908152600360208190526040909120908101549781015460078083015497830154929094015493549799959864010000000080870463ffffffff9081169a600160a060020a0390961699929893978184169792909304811695919391921690565b600154600160a060020a031681565b60095490565b600154600160a060020a03163314610c4c57600080fd5b600154600160a060020a0382811691161415610c6757600080fd5b600160a060020a0381161515610c7c57600080fd5b60015460408051600160a060020a03928316815291831660208301524282820152517fc13a1166d81cd3b0b352a367aebab95f3a6f6bc695fdab8e9a9d335239c3861b9181900360600190a16001805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b600154600160a060020a03163314610d0e57600080fd5b600254600160a060020a0382811691161415610d2957600080fd5b600160a060020a0381161515610d3e57600080fd5b6002805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b4390565b60085490565b336000610d82610f9b565b610d8b82611779565b905060008111610d9a57600080fd5b600160a060020a038216600090815260036020526040902060010154610dc6908263ffffffff6112c116565b600160a060020a038316600081815260036020908152604091829020600101939093558051918252918101839052428183015290517f8ea11b70a47e5aaa4024df0985799a384faaaf34e6da0aadbadcae0fbfca45ac9181900360600190a1604051600160a060020a0383169082156108fc029083906000818181858888f19350505050158015610e5b573d6000803e3d6000fd5b505050565b6000610e6a611f16565b333214610e7657600080fd5b60208101879052858152604081018590526060810184905260ff83166080820152339150610ea2610f9b565b61068882826117e7565b6004543490610ec1908263ffffffff6112c116565b60045550565b600154600160a060020a03163314610ede57600080fd5b60008263ffffffff16118015610efa575060008163ffffffff16115b1515610f0557600080fd5b600a80546bffffffff000000000000000019166801000000000000000063ffffffff858116918202929092176fffffffff00000000000000000000000019166c010000000000000000000000009285169283021790925560408051928352602083019190915280517ff4ab9cef590dc0ec17e353c8e7952b4d69b4fa4ebd439d2b6873c663d55f30e99281900390910190a15050565b60075460008080831115610e5b57438311610e5b575050600654600554600160a060020a039091169060029004811561101157600160a060020a038216600090815260036020526040902054610ff7908263ffffffff6112c116565b600160a060020a0383166000908152600360205260409020555b6006805473ffffffffffffffffffffffffffffffffffffffff19169055600554611041908263ffffffff611ca716565b6005555050600a805467ffffffff0000000019169055506000600755565b600160a060020a03841660009081526003602052604081208251909190819015158061108e5750600583015415155b1561109d5761109d87856112d1565b600a5468010000000000000000900463ffffffff16439081016006850155604080516020808201939093527f020000000000000000000000000000000000000000000000000000000000000081830152600160a060020a038a166c0100000000000000000000000090810260418301523002605582015281518082036049018152606990910191829052805190928291908401908083835b602083106111545780518252601f199092019160209182019101611135565b5181516020939093036101000a60001901801990911692169190911790526040519201829003909120600587810191909155606493506111979250899150611cbc565b8115156111a057fe5b0491506111b3868363ffffffff611ca716565b600054604080517fc671b934000000000000000000000000000000000000000000000000000000008152600160a060020a038b811660048301528981166024830152915193995091169163c671b934918591604480830192602092919082900301818588803b15801561122557600080fd5b505af1158015611239573d6000803e3d6000fd5b50505050506040513d602081101561125057600080fd5b5051905061125d86611ce8565b6005830154600684015460408051600160a060020a038b16815260208101939093528281019190915260608201839052517f7c3638bb8501e29b667f04c5c7cdee077a3e02667cf398fabe17d2f7cc6ae1fd9181900360800190a150505050505050565b81810182811015610ba757600080fd5b600160a060020a0382166000908152600360205260408120825190919015801590611300575060058201548351145b1561153f5781600601544310158061143f575060025460208085015185516040805180850193909352828101919091528051808303820181526060909201908190528151600160a060020a03909416936001938291908401908083835b6020831061137c5780518252601f19909201916020918201910161135d565b6001836020036101000a0380198251168184511680821785525050505050509050019150506040518091039020856080015186604001518760600151604051600081526020016040526040518085600019166000191681526020018460ff1660ff1681526020018360001916600019168152602001826000191660001916815260200194505050505060206040516020810390808403906000865af1158015611429573d6000803e3d6000fd5b50505060206040510351600160a060020a031614155b1561144c57600060208401525b610960836020015111156114635761096060208401525b50600a546020830151600091640100000000900463ffffffff1610156114ed57506020820151600a805467ffffffff00000000191664010000000063ffffffff9384160217908190556006805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0387161790556c01000000000000000000000000900416430160075560015b60208084015160408051918252600160a060020a038716928201929092528215158183015290517fee02551c85dd2b4c8ea56a7181c5a67f093aa10d55fa6be5b137cb34e9e945349181900360600190a15b5060006005909101555050565b600160a060020a038516600090815260036020526040902081511515806115765750600381015415155b156115855761158586836117e7565b60078101805460a084015163ffffffff9081166401000000000267ffffffff000000001988831663ffffffff1990941684171617909255600a54436801000000000000000090910490921682016004840155604080516020808201949094527f0100000000000000000000000000000000000000000000000000000000000000818301527c010000000000000000000000000000000000000000000000000000000090920260418301526c01000000000000000000000000600160a060020a038a1681026045840152300260598301528051604d818403018152606d9092019081905281519192909182918401908083835b602083106116965780518252601f199092019160209182019101611677565b51815160001960209485036101000a0190811690199091161790526040805192909401829003822060038801819055600288018c905560048801546007890154600160a060020a038f168552928401919091528285015263ffffffff16606082015291517f4b0d1523a5409334be982872b5c5a7bcf88df79471bcaf0882526843a9100119945091829003608001925050a1505050505050565b6007546000908181111561176e5780431015801561175b5750600654600160a060020a038481169116145b1561176e57600554600290049150611773565b600091505b50919050565b600160a060020a03811660009081526003602052604081205461179e610b4d84611730565b600160a060020a038416600090815260036020526040902060010154909150811115610ba357600160a060020a0383166000908152600360205260409020600101549003610ba7565b600160a060020a0382166000908152600360205260408120825190919081908190819081901580159061181e575060038601548751145b801561182e575060008660020154115b151561183957600080fd5b856004015443101580611973575060025460208089015189516040805180850193909352828101919091528051808303820181526060909201908190528151600160a060020a03909416936001938291908401908083835b602083106118b05780518252601f199092019160209182019101611891565b6001836020036101000a038019825116818451168082178552505050505050905001915050604051809103902089608001518a604001518b60600151604051600081526020016040526040518085600019166000191681526020018460ff1660ff1681526020018360001916600019168152602001826000191660001916815260200194505050505060206040516020810390808403906000865af115801561195d573d6000803e3d6000fd5b50505060206040510351600160a060020a031614155b1561198057600060208801525b6007860154602088015163ffffffff90911610156119a957600786015463ffffffff1660208801525b6002860154600095508594508493506064906119cc90600563ffffffff611cbc16565b8115156119d557fe5b049150600087602001511115611b1157600a54600454606491611a02919063ffffffff90811690611cbc16565b811515611a0b57fe5b60078801549190049150600a90611a3590839063ffffffff640100000000909104811690611cbc16565b811515611a3e57fe5b60078801549190049150611a6390829063ffffffff90811680800202811690611cbc16565b60028701546103e89091049150811115611a7e575060028501545b6007860154602088015163ffffffff9091161415611ab2576002860154611aab908263ffffffff6112c116565b9450611b11565b6002860154611ac7908263ffffffff611ca716565b9450611ae3600188602001510382611cbc90919063ffffffff16565b600787015490915063ffffffff1681811515611afb57fe5b049050611b0e858263ffffffff6112c116565b94505b81851015611b1d578194505b6064611b3086600563ffffffff611cbc16565b811515611b3957fe5b60008054604080517fc671b934000000000000000000000000000000000000000000000000000000008152600160a060020a038e8116600483015260248201949094529051949093049750169163c671b934918791604480830192602092919082900301818588803b158015611bae57600080fd5b505af1158015611bc2573d6000803e3d6000fd5b50505050506040513d6020811015611bd957600080fd5b50518654909350611bf29085870363ffffffff6112c116565b86556002860154851015611c0f57611c0f85876002015403611ed3565b8560020154851115611c38576002860154600454611c3491870363ffffffff611ca716565b6004555b600060038701819055600287015560208088015160408051918252600160a060020a038b16928201929092528082018790526060810185905290517f2e2a7a95332061057c7e55ae51231969840ed796dd6d5b4d21dad5c5751c184e9181900360800190a15050505050505050565b600082821115611cb657600080fd5b50900390565b6000821515611ccd57506000610ba7565b50818102818382811515611cdd57fe5b0414610ba757600080fd5b600080611d1b6064611d0185605063ffffffff611cbc16565b811515611d0a57fe5b60055491900463ffffffff6112c116565b6005556064611d2b84600f611cbc565b811515611d3457fe5b0491506064611d44846005611cbc565b811515611d4d57fe5b6009549190049150611d6690829063ffffffff6112c116565b905066b1a2bc2ec500008110611e2157600060098190558054600154604080517fc671b934000000000000000000000000000000000000000000000000000000008152600160a060020a03928316600482015260248101949094525191169163c671b93491849160448082019260209290919082900301818588803b158015611dee57600080fd5b505af1158015611e02573d6000803e3d6000fd5b50505050506040513d6020811015611e1957600080fd5b50611e279050565b60098190555b600854611e3b90839063ffffffff6112c116565b915066b1a2bc2ec500008210611ecc57600060088190558054604080517f16ff1c760000000000000000000000000000000000000000000000000000000081529051600160a060020a03909216926316ff1c76928692600481810193929182900301818588803b158015611eae57600080fd5b505af1158015611ec2573d6000803e3d6000fd5b5050505050610e5b565b5060085550565b600080611f066064611eec85605063ffffffff611cbc16565b811515611ef557fe5b60045491900463ffffffff6112c116565b6004556064611d2b84600f611cbc565b6040805160c081018252600080825260208201819052918101829052606081018290526080810182905260a0810191909152905600a165627a7a723058202842e49c25a34c6c9091cdfddc28a9e56e9d1d7f9f37c9e5080422565e02b2520029"
}