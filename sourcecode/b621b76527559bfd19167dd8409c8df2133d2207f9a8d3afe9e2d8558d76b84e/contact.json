{
  "address": "0x47a2714ebcc0826b482572caffceb74e8e3eb311",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "EmissionProvider",
  "compilerVersion": "v0.4.19+commit.c4cbbb05",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2018-12-03\n*/\n\npragma solidity ^0.4.11;\n\n/**\n * @title Owned contract with safe ownership pass.\n *\n * Note: all the non constant functions return false instead of throwing in case if state change\n * didn't happen yet.\n */\ncontract Owned {\n    /**\n     * Contract owner address\n     */\n    address public contractOwner;\n\n    /**\n     * Contract owner address\n     */\n    address public pendingContractOwner;\n\n    function Owned() {\n        contractOwner = msg.sender;\n    }\n\n    /**\n    * @dev Owner check modifier\n    */\n    modifier onlyContractOwner() {\n        if (contractOwner == msg.sender) {\n            _;\n        }\n    }\n\n    /**\n     * @dev Destroy contract and scrub a data\n     * @notice Only owner can call it\n     */\n    function destroy() onlyContractOwner {\n        suicide(msg.sender);\n    }\n\n    /**\n     * Prepares ownership pass.\n     *\n     * Can only be called by current owner.\n     *\n     * @param _to address of the next owner. 0x0 is not allowed.\n     *\n     * @return success.\n     */\n    function changeContractOwnership(address _to) onlyContractOwner() returns(bool) {\n        if (_to  == 0x0) {\n            return false;\n        }\n\n        pendingContractOwner = _to;\n        return true;\n    }\n\n    /**\n     * Finalize ownership pass.\n     *\n     * Can only be called by pending owner.\n     *\n     * @return success.\n     */\n    function claimContractOwnership() returns(bool) {\n        if (pendingContractOwner != msg.sender) {\n            return false;\n        }\n\n        contractOwner = pendingContractOwner;\n        delete pendingContractOwner;\n\n        return true;\n    }\n}\n\ncontract ERC20Interface {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed from, address indexed spender, uint256 value);\n    string public symbol;\n\n    function totalSupply() constant returns (uint256 supply);\n    function balanceOf(address _owner) constant returns (uint256 balance);\n    function transfer(address _to, uint256 _value) returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n    function approve(address _spender, uint256 _value) returns (bool success);\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n}\n\n/**\n * @title Generic owned destroyable contract\n */\ncontract Object is Owned {\n    /**\n    *  Common result code. Means everything is fine.\n    */\n    uint constant OK = 1;\n    uint constant OWNED_ACCESS_DENIED_ONLY_CONTRACT_OWNER = 8;\n\n    function withdrawnTokens(address[] tokens, address _to) onlyContractOwner returns(uint) {\n        for(uint i=0;i<tokens.length;i++) {\n            address token = tokens[i];\n            uint balance = ERC20Interface(token).balanceOf(this);\n            if(balance != 0)\n                ERC20Interface(token).transfer(_to,balance);\n        }\n        return OK;\n    }\n\n    function checkOnlyContractOwner() internal constant returns(uint) {\n        if (contractOwner == msg.sender) {\n            return OK;\n        }\n\n        return OWNED_ACCESS_DENIED_ONLY_CONTRACT_OWNER;\n    }\n}\n\n/**\n* @title SafeMath\n* @dev Math operations with safety checks that throw on error\n*/\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a * b;\n        assert(a == 0 || c / a == b);\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\ncontract OracleContractAdapter is Object {\n\n    event OracleAdded(address _oracle);\n    event OracleRemoved(address _oracle);\n\n    mapping(address => bool) public oracles;\n\n    /// @dev Allow access only for oracle\n    modifier onlyOracle {\n        if (oracles[msg.sender]) {\n            _;\n        }\n    }\n\n    modifier onlyOracleOrOwner {\n        if (oracles[msg.sender] || msg.sender == contractOwner) {\n            _;\n        }\n    }\n\n    /// @notice Add oracles to whitelist.\n    ///\n    /// @param _whitelist user list.\n    function addOracles(address[] _whitelist) \n    onlyContractOwner \n    external \n    returns (uint) \n    {\n        for (uint _idx = 0; _idx < _whitelist.length; ++_idx) {\n            address _oracle = _whitelist[_idx];\n            if (_oracle != 0x0 && !oracles[_oracle]) {\n                oracles[_oracle] = true;\n                _emitOracleAdded(_oracle);\n            }\n        }\n        return OK;\n    }\n\n    /// @notice Removes oracles from whitelist.\n    ///\n    /// @param _blacklist user in whitelist.\n    function removeOracles(address[] _blacklist) \n    onlyContractOwner \n    external \n    returns (uint) \n    {\n        for (uint _idx = 0; _idx < _blacklist.length; ++_idx) {\n            address _oracle = _blacklist[_idx];\n            if (_oracle != 0x0 && oracles[_oracle]) {\n                delete oracles[_oracle];\n                _emitOracleRemoved(_oracle);\n            }\n        }\n        return OK;\n    }\n\n    function _emitOracleAdded(address _oracle) internal {\n        OracleAdded(_oracle);\n    }\n\n    function _emitOracleRemoved(address _oracle) internal {\n        OracleRemoved(_oracle);\n    }\n}\n\n/// @title ServiceAllowance.\n///\n/// Provides a way to delegate operation allowance decision to a service contract\ncontract ServiceAllowance {\n    function isTransferAllowed(address _from, address _to, address _sender, address _token, uint _value) public view returns (bool);\n}\n\n/// @title DepositWalletInterface\n///\n/// Defines an interface for a wallet that can be deposited/withdrawn by 3rd contract\ncontract DepositWalletInterface {\n    function deposit(address _asset, address _from, uint256 amount) public returns (uint);\n    function withdraw(address _asset, address _to, uint256 amount) public returns (uint);\n}\n\ncontract ProfiteroleEmitter {\n\n    event DepositPendingAdded(uint amount, address from, uint timestamp);\n    event BonusesWithdrawn(bytes32 userKey, uint amount, uint timestamp);\n\n    event Error(uint errorCode);\n\n    function _emitError(uint _errorCode) internal returns (uint) {\n        Error(_errorCode);\n        return _errorCode;\n    }\n}\n\ncontract TreasuryEmitter {\n    event TreasuryDeposited(bytes32 userKey, uint value, uint lockupDate);\n    event TreasuryWithdrawn(bytes32 userKey, uint value);\n}\n\ncontract ERC20 {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed from, address indexed spender, uint256 value);\n    string public symbol;\n\n    function totalSupply() constant returns (uint256 supply);\n    function balanceOf(address _owner) constant returns (uint256 balance);\n    function transfer(address _to, uint256 _value) returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n    function approve(address _spender, uint256 _value) returns (bool success);\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n}\n\n\n\n\n/// @title Treasury contract.\n///\n/// Treasury for CCs deposits for particular fund with bmc-days calculations.\n/// Accept BMC deposits from Continuous Contributors via oracle and\n/// calculates bmc-days metric for each CC's role.\ncontract Treasury is OracleContractAdapter, ServiceAllowance, TreasuryEmitter {\n\n    /* ERROR CODES */\n\n    uint constant PERCENT_PRECISION = 10000;\n\n    uint constant TREASURY_ERROR_SCOPE = 108000;\n    uint constant TREASURY_ERROR_TOKEN_NOT_SET_ALLOWANCE = TREASURY_ERROR_SCOPE + 1;\n\n    using SafeMath for uint;\n\n    struct LockedDeposits {\n        uint counter;\n        mapping(uint => uint) index2Date;\n        mapping(uint => uint) date2deposit;\n    }\n\n    struct Period {\n        uint transfersCount;\n        uint totalBmcDays;\n        uint bmcDaysPerDay;\n        uint startDate;\n        mapping(bytes32 => uint) user2bmcDays;\n        mapping(bytes32 => uint) user2lastTransferIdx;\n        mapping(bytes32 => uint) user2balance;\n        mapping(uint => uint) transfer2date;\n    }\n\n    /* FIELDS */\n\n    address token;\n    address profiterole;\n    uint periodsCount;\n\n    mapping(uint => Period) periods;\n    mapping(uint => uint) periodDate2periodIdx;\n    mapping(bytes32 => uint) user2lastPeriodParticipated;\n    mapping(bytes32 => LockedDeposits) user2lockedDeposits;\n\n    /* MODIFIERS */\n\n    /// @dev Only profiterole contract allowed to invoke guarded functions\n    modifier onlyProfiterole {\n        require(profiterole == msg.sender);\n        _;\n    }\n\n    /* PUBLIC */\n    \n    function Treasury(address _token) public {\n        require(address(_token) != 0x0);\n        token = _token;\n        periodsCount = 1;\n    }\n\n    function init(address _profiterole) public onlyContractOwner returns (uint) {\n        require(_profiterole != 0x0);\n        profiterole = _profiterole;\n        return OK;\n    }\n\n    /// @notice Do not accept Ether transfers\n    function() payable public {\n        revert();\n    }\n\n    /* EXTERNAL */\n\n    /// @notice Deposits tokens on behalf of users\n    /// Allowed only for oracle.\n    ///\n    /// @param _userKey aggregated user key (user ID + role ID)\n    /// @param _value amount of tokens to deposit\n    /// @param _feeAmount amount of tokens that will be taken from _value as fee\n    /// @param _feeAddress destination address for fee transfer\n    /// @param _lockupDate lock up date for deposit. Until that date the deposited value couldn't be withdrawn\n    ///\n    /// @return result code of an operation\n    function deposit(bytes32 _userKey, uint _value, uint _feeAmount, address _feeAddress, uint _lockupDate) external onlyOracle returns (uint) {\n        require(_userKey != bytes32(0));\n        require(_value != 0);\n        require(_feeAmount < _value);\n\n        ERC20 _token = ERC20(token);\n        if (_token.allowance(msg.sender, address(this)) < _value) {\n            return TREASURY_ERROR_TOKEN_NOT_SET_ALLOWANCE;\n        }\n\n        uint _depositedAmount = _value - _feeAmount;\n        _makeDepositForPeriod(_userKey, _depositedAmount, _lockupDate);\n\n        uint _periodsCount = periodsCount;\n        user2lastPeriodParticipated[_userKey] = _periodsCount;\n        delete periods[_periodsCount].startDate;\n\n        if (!_token.transferFrom(msg.sender, address(this), _value)) {\n            revert();\n        }\n\n        if (!(_feeAddress == 0x0 || _feeAmount == 0 || _token.transfer(_feeAddress, _feeAmount))) {\n            revert();\n        }\n\n        TreasuryDeposited(_userKey, _depositedAmount, _lockupDate);\n        return OK;\n    }\n\n    /// @notice Withdraws deposited tokens on behalf of users\n    /// Allowed only for oracle\n    ///\n    /// @param _userKey aggregated user key (user ID + role ID)\n    /// @param _value an amount of tokens that is requrested to withdraw\n    /// @param _withdrawAddress address to withdraw; should not be 0x0\n    /// @param _feeAmount amount of tokens that will be taken from _value as fee\n    /// @param _feeAddress destination address for fee transfer\n    ///\n    /// @return result of an operation\n    function withdraw(bytes32 _userKey, uint _value, address _withdrawAddress, uint _feeAmount, address _feeAddress) external onlyOracle returns (uint) {\n        require(_userKey != bytes32(0));\n        require(_value != 0);\n        require(_feeAmount < _value);\n\n        _makeWithdrawForPeriod(_userKey, _value);\n        uint _periodsCount = periodsCount;\n        user2lastPeriodParticipated[_userKey] = periodsCount;\n        delete periods[_periodsCount].startDate;\n\n        ERC20 _token = ERC20(token);\n        if (!(_feeAddress == 0x0 || _feeAmount == 0 || _token.transfer(_feeAddress, _feeAmount))) {\n            revert();\n        }\n\n        uint _withdrawnAmount = _value - _feeAmount;\n        if (!_token.transfer(_withdrawAddress, _withdrawnAmount)) {\n            revert();\n        }\n\n        TreasuryWithdrawn(_userKey, _withdrawnAmount);\n        return OK;\n    }\n\n    /// @notice Gets shares (in percents) the user has on provided date\n    ///\n    /// @param _userKey aggregated user key (user ID + role ID)\n    /// @param _date date where period ends\n    ///\n    /// @return percent from total amount of bmc-days the treasury has on this date.\n    /// Use PERCENT_PRECISION to get right precision\n    function getSharesPercentForPeriod(bytes32 _userKey, uint _date) public view returns (uint) {\n        uint _periodIdx = periodDate2periodIdx[_date];\n        if (_date != 0 && _periodIdx == 0) {\n            return 0;\n        }\n\n        if (_date == 0) {\n            _date = now;\n            _periodIdx = periodsCount;\n        }\n\n        uint _bmcDays = _getBmcDaysAmountForUser(_userKey, _date, _periodIdx);\n        uint _totalBmcDeposit = _getTotalBmcDaysAmount(_date, _periodIdx);\n        return _totalBmcDeposit != 0 ? _bmcDays * PERCENT_PRECISION / _totalBmcDeposit : 0;\n    }\n\n    /// @notice Gets user balance that is deposited\n    /// @param _userKey aggregated user key (user ID + role ID)\n    /// @return an amount of tokens deposited on behalf of user\n    function getUserBalance(bytes32 _userKey) public view returns (uint) {\n        uint _lastPeriodForUser = user2lastPeriodParticipated[_userKey];\n        if (_lastPeriodForUser == 0) {\n            return 0;\n        }\n\n        if (_lastPeriodForUser <= periodsCount.sub(1)) {\n            return periods[_lastPeriodForUser].user2balance[_userKey];\n        }\n\n        return periods[periodsCount].user2balance[_userKey];\n    }\n\n    /// @notice Gets amount of locked deposits for user\n    /// @param _userKey aggregated user key (user ID + role ID)\n    /// @return an amount of tokens locked\n    function getLockedUserBalance(bytes32 _userKey) public returns (uint) {\n        return _syncLockedDepositsAmount(_userKey);\n    }\n\n    /// @notice Gets list of locked up deposits with dates when they will be available to withdraw\n    /// @param _userKey aggregated user key (user ID + role ID)\n    /// @return {\n    ///     \"_lockupDates\": \"list of lockup dates of deposits\",\n    ///     \"_deposits\": \"list of deposits\"\n    /// }\n    function getLockedUserDeposits(bytes32 _userKey) public view returns (uint[] _lockupDates, uint[] _deposits) {\n        LockedDeposits storage _lockedDeposits = user2lockedDeposits[_userKey];\n        uint _lockedDepositsCounter = _lockedDeposits.counter;\n        _lockupDates = new uint[](_lockedDepositsCounter);\n        _deposits = new uint[](_lockedDepositsCounter);\n\n        uint _pointer = 0;\n        for (uint _idx = 1; _idx < _lockedDepositsCounter; ++_idx) {\n            uint _lockDate = _lockedDeposits.index2Date[_idx];\n\n            if (_lockDate > now) {\n                _lockupDates[_pointer] = _lockDate;\n                _deposits[_pointer] = _lockedDeposits.date2deposit[_lockDate];\n                ++_pointer;\n            }\n        }\n    }\n\n    /// @notice Gets total amount of bmc-day accumulated due provided date\n    /// @param _date date where period ends\n    /// @return an amount of bmc-days\n    function getTotalBmcDaysAmount(uint _date) public view returns (uint) {\n        return _getTotalBmcDaysAmount(_date, periodsCount);\n    }\n\n    /// @notice Makes a checkpoint to start counting a new period\n    /// @dev Should be used only by Profiterole contract\n    function addDistributionPeriod() public onlyProfiterole returns (uint) {\n        uint _periodsCount = periodsCount;\n        uint _nextPeriod = _periodsCount.add(1);\n        periodDate2periodIdx[now] = _periodsCount;\n\n        Period storage _previousPeriod = periods[_periodsCount];\n        uint _totalBmcDeposit = _getTotalBmcDaysAmount(now, _periodsCount);\n        periods[_nextPeriod].startDate = now;\n        periods[_nextPeriod].bmcDaysPerDay = _previousPeriod.bmcDaysPerDay;\n        periods[_nextPeriod].totalBmcDays = _totalBmcDeposit;\n        periodsCount = _nextPeriod;\n\n        return OK;\n    }\n\n    function isTransferAllowed(address, address, address, address, uint) public view returns (bool) {\n        return true;\n    }\n\n    /* INTERNAL */\n\n    function _makeDepositForPeriod(bytes32 _userKey, uint _value, uint _lockupDate) internal {\n        Period storage _transferPeriod = periods[periodsCount];\n\n        _transferPeriod.user2bmcDays[_userKey] = _getBmcDaysAmountForUser(_userKey, now, periodsCount);\n        _transferPeriod.totalBmcDays = _getTotalBmcDaysAmount(now, periodsCount);\n        _transferPeriod.bmcDaysPerDay = _transferPeriod.bmcDaysPerDay.add(_value);\n\n        uint _userBalance = getUserBalance(_userKey);\n        uint _updatedTransfersCount = _transferPeriod.transfersCount.add(1);\n        _transferPeriod.transfersCount = _updatedTransfersCount;\n        _transferPeriod.transfer2date[_transferPeriod.transfersCount] = now;\n        _transferPeriod.user2balance[_userKey] = _userBalance.add(_value);\n        _transferPeriod.user2lastTransferIdx[_userKey] = _updatedTransfersCount;\n\n        _registerLockedDeposits(_userKey, _value, _lockupDate);\n    }\n\n    function _makeWithdrawForPeriod(bytes32 _userKey, uint _value) internal {\n        uint _userBalance = getUserBalance(_userKey);\n        uint _lockedBalance = _syncLockedDepositsAmount(_userKey);\n        require(_userBalance.sub(_lockedBalance) >= _value);\n\n        uint _periodsCount = periodsCount;\n        Period storage _transferPeriod = periods[_periodsCount];\n\n        _transferPeriod.user2bmcDays[_userKey] = _getBmcDaysAmountForUser(_userKey, now, _periodsCount);\n        uint _totalBmcDeposit = _getTotalBmcDaysAmount(now, _periodsCount);\n        _transferPeriod.totalBmcDays = _totalBmcDeposit;\n        _transferPeriod.bmcDaysPerDay = _transferPeriod.bmcDaysPerDay.sub(_value);\n\n        uint _updatedTransferCount = _transferPeriod.transfersCount.add(1);\n        _transferPeriod.transfer2date[_updatedTransferCount] = now;\n        _transferPeriod.user2lastTransferIdx[_userKey] = _updatedTransferCount;\n        _transferPeriod.user2balance[_userKey] = _userBalance.sub(_value);\n        _transferPeriod.transfersCount = _updatedTransferCount;\n    }\n\n    function _registerLockedDeposits(bytes32 _userKey, uint _amount, uint _lockupDate) internal {\n        if (_lockupDate <= now) {\n            return;\n        }\n\n        LockedDeposits storage _lockedDeposits = user2lockedDeposits[_userKey];\n        uint _lockedBalance = _lockedDeposits.date2deposit[_lockupDate];\n\n        if (_lockedBalance == 0) {\n            uint _lockedDepositsCounter = _lockedDeposits.counter.add(1);\n            _lockedDeposits.counter = _lockedDepositsCounter;\n            _lockedDeposits.index2Date[_lockedDepositsCounter] = _lockupDate;\n        }\n        _lockedDeposits.date2deposit[_lockupDate] = _lockedBalance.add(_amount);\n    }\n\n    function _syncLockedDepositsAmount(bytes32 _userKey) internal returns (uint _lockedSum) {\n        LockedDeposits storage _lockedDeposits = user2lockedDeposits[_userKey];\n        uint _lockedDepositsCounter = _lockedDeposits.counter;\n\n        for (uint _idx = 1; _idx <= _lockedDepositsCounter; ++_idx) {\n            uint _lockDate = _lockedDeposits.index2Date[_idx];\n\n            if (_lockDate <= now) {\n                _lockedDeposits.index2Date[_idx] = _lockedDeposits.index2Date[_lockedDepositsCounter];\n\n                delete _lockedDeposits.index2Date[_lockedDepositsCounter];\n                delete _lockedDeposits.date2deposit[_lockDate];\n\n                _lockedDepositsCounter = _lockedDepositsCounter.sub(1);\n                continue;\n            }\n\n            _lockedSum = _lockedSum.add(_lockedDeposits.date2deposit[_lockDate]);\n        }\n\n        _lockedDeposits.counter = _lockedDepositsCounter;\n    }\n\n    function _getBmcDaysAmountForUser(bytes32 _userKey, uint _date, uint _periodIdx) internal view returns (uint) {\n        uint _lastPeriodForUserIdx = user2lastPeriodParticipated[_userKey];\n        if (_lastPeriodForUserIdx == 0) {\n            return 0;\n        }\n\n        Period storage _transferPeriod = _lastPeriodForUserIdx <= _periodIdx ? periods[_lastPeriodForUserIdx] : periods[_periodIdx];\n        uint _lastTransferDate = _transferPeriod.transfer2date[_transferPeriod.user2lastTransferIdx[_userKey]];\n        // NOTE: It is an intended substraction separation to correctly round dates\n        uint _daysLong = (_date / 1 days) - (_lastTransferDate / 1 days);\n        uint _bmcDays = _transferPeriod.user2bmcDays[_userKey];\n        return _bmcDays.add(_transferPeriod.user2balance[_userKey] * _daysLong);\n    }\n\n    /* PRIVATE */\n\n    function _getTotalBmcDaysAmount(uint _date, uint _periodIdx) private view returns (uint) {\n        Period storage _depositPeriod = periods[_periodIdx];\n        uint _transfersCount = _depositPeriod.transfersCount;\n        uint _lastRecordedDate = _transfersCount != 0 ? _depositPeriod.transfer2date[_transfersCount] : _depositPeriod.startDate;\n\n        if (_lastRecordedDate == 0) {\n            return 0;\n        }\n\n        // NOTE: It is an intended substraction separation to correctly round dates\n        uint _daysLong = (_date / 1 days).sub((_lastRecordedDate / 1 days));\n        uint _totalBmcDeposit = _depositPeriod.totalBmcDays.add(_depositPeriod.bmcDaysPerDay.mul(_daysLong));\n        return _totalBmcDeposit;\n    }\n}\n\n/// @title Profiterole contract\n/// Collector and distributor for creation and redemption fees.\n/// Accepts bonus tokens from EmissionProvider, BurningMan or other distribution source.\n/// Calculates CCs shares in bonuses. Uses Treasury Contract as source of shares in bmc-days.\n/// Allows to withdraw bonuses on request.\ncontract Profiterole is OracleContractAdapter, ServiceAllowance, ProfiteroleEmitter {\n\n    uint constant PERCENT_PRECISION = 10000;\n\n    uint constant PROFITEROLE_ERROR_SCOPE = 102000;\n    uint constant PROFITEROLE_ERROR_INSUFFICIENT_DISTRIBUTION_BALANCE = PROFITEROLE_ERROR_SCOPE + 1;\n    uint constant PROFITEROLE_ERROR_INSUFFICIENT_BONUS_BALANCE = PROFITEROLE_ERROR_SCOPE + 2;\n    uint constant PROFITEROLE_ERROR_TRANSFER_ERROR = PROFITEROLE_ERROR_SCOPE + 3;\n\n    using SafeMath for uint;\n\n    struct Balance {\n        uint left;\n        bool initialized;\n    }\n\n    struct Deposit {\n        uint balance;\n        uint left;\n        uint nextDepositDate;\n        mapping(bytes32 => Balance) leftToWithdraw;\n    }\n\n    struct UserBalance {\n        uint lastWithdrawDate;\n    }\n\n    mapping(address => bool) distributionSourcesList;\n    mapping(bytes32 => UserBalance) bonusBalances;\n    mapping(uint => Deposit) public distributionDeposits;\n\n    uint public firstDepositDate;\n    uint public lastDepositDate;\n\n    address public bonusToken;\n    address public treasury;\n    address public wallet;\n\n    /// @dev Guards functions only for distributionSource invocations\n    modifier onlyDistributionSource {\n        if (!distributionSourcesList[msg.sender]) {\n            revert();\n        }\n        _;\n    }\n\n    function Profiterole(address _bonusToken, address _treasury, address _wallet) public {\n        require(_bonusToken != 0x0);\n        require(_treasury != 0x0);\n        require(_wallet != 0x0);\n\n        bonusToken = _bonusToken;\n        treasury = _treasury;\n        wallet = _wallet;\n    }\n\n    function() payable public {\n        revert();\n    }\n\n    /* EXTERNAL */\n\n    /// @notice Sets new treasury address\n    /// Only for contract owner.\n    function updateTreasury(address _treasury) external onlyContractOwner returns (uint) {\n        require(_treasury != 0x0);\n        treasury = _treasury;\n        return OK;\n    }\n\n    /// @notice Sets new wallet address for profiterole\n    /// Only for contract owner.\n    function updateWallet(address _wallet) external onlyContractOwner returns (uint) {\n        require(_wallet != 0x0);\n        wallet = _wallet;\n        return OK;\n    }\n\n    /// @notice Add distribution sources to whitelist.\n    ///\n    /// @param _whitelist addresses list.\n    function addDistributionSources(address[] _whitelist) external onlyContractOwner returns (uint) {\n        for (uint _idx = 0; _idx < _whitelist.length; ++_idx) {\n            distributionSourcesList[_whitelist[_idx]] = true;\n        }\n        return OK;\n    }\n\n    /// @notice Removes distribution sources from whitelist.\n    /// Only for contract owner.\n    ///\n    /// @param _blacklist addresses in whitelist.\n    function removeDistributionSources(address[] _blacklist) external onlyContractOwner returns (uint) {\n        for (uint _idx = 0; _idx < _blacklist.length; ++_idx) {\n            delete distributionSourcesList[_blacklist[_idx]];\n        }\n        return OK;\n    }\n\n    /// @notice Allows to withdraw user's bonuses that he deserves due to Treasury shares for\n    /// every distribution period.\n    /// Only oracles allowed to invoke this function.\n    ///\n    /// @param _userKey aggregated user key (user ID + role ID) on behalf of whom bonuses will be withdrawn\n    /// @param _value an amount of tokens to withdraw\n    /// @param _withdrawAddress destination address of withdrawal (usually user's address)\n    /// @param _feeAmount an amount of fee that will be taken from resulted _value\n    /// @param _feeAddress destination address of fee transfer\n    ///\n    /// @return result code of an operation\n    function withdrawBonuses(bytes32 _userKey, uint _value, address _withdrawAddress, uint _feeAmount, address _feeAddress) external onlyOracle returns (uint) {\n        require(_userKey != bytes32(0));\n        require(_value != 0);\n        require(_feeAmount < _value);\n        require(_withdrawAddress != 0x0);\n\n        DepositWalletInterface _wallet = DepositWalletInterface(wallet);\n        ERC20Interface _bonusToken = ERC20Interface(bonusToken);\n        if (_bonusToken.balanceOf(_wallet) < _value) {\n            return _emitError(PROFITEROLE_ERROR_INSUFFICIENT_BONUS_BALANCE);\n        }\n\n        if (OK != _withdrawBonuses(_userKey, _value)) {\n            revert();\n        }\n\n        if (!(_feeAddress == 0x0 || _feeAmount == 0 || OK == _wallet.withdraw(_bonusToken, _feeAddress, _feeAmount))) {\n            revert();\n        }\n\n        if (OK != _wallet.withdraw(_bonusToken, _withdrawAddress, _value - _feeAmount)) {\n            revert();\n        }\n\n        BonusesWithdrawn(_userKey, _value, now);\n        return OK;\n    }\n\n    /* PUBLIC */\n\n    /// @notice Gets total amount of bonuses user has during all distribution periods\n    /// @param _userKey aggregated user key (user ID + role ID)\n    /// @return _sum available amount of bonuses to withdraw\n    function getTotalBonusesAmountAvailable(bytes32 _userKey) public view returns (uint _sum) {\n        uint _startDate = _getCalculationStartDate(_userKey);\n        Treasury _treasury = Treasury(treasury);\n\n        for (\n            uint _endDate = lastDepositDate;\n            _startDate <= _endDate && _startDate != 0;\n            _startDate = distributionDeposits[_startDate].nextDepositDate\n        ) {\n            Deposit storage _pendingDeposit = distributionDeposits[_startDate];\n            Balance storage _userBalance = _pendingDeposit.leftToWithdraw[_userKey];\n\n            if (_userBalance.initialized) {\n                _sum = _sum.add(_userBalance.left);\n            } else {\n                uint _sharesPercent = _treasury.getSharesPercentForPeriod(_userKey, _startDate);\n                _sum = _sum.add(_pendingDeposit.balance.mul(_sharesPercent).div(PERCENT_PRECISION));\n            }\n        }\n    }\n\n    /// @notice Gets an amount of bonuses user has for concrete distribution date\n    /// @param _userKey aggregated user key (user ID + role ID)\n    /// @param _distributionDate date of distribution operation\n    /// @return available amount of bonuses to withdraw for selected distribution date\n    function getBonusesAmountAvailable(bytes32 _userKey, uint _distributionDate) public view returns (uint) {\n        Deposit storage _deposit = distributionDeposits[_distributionDate];\n        if (_deposit.leftToWithdraw[_userKey].initialized) {\n            return _deposit.leftToWithdraw[_userKey].left;\n        }\n\n        uint _sharesPercent = Treasury(treasury).getSharesPercentForPeriod(_userKey, _distributionDate);\n        return _deposit.balance.mul(_sharesPercent).div(PERCENT_PRECISION);\n    }\n\n    /// @notice Gets total amount of deposits that has left after users' bonus withdrawals\n    /// @return amount of deposits available for bonus payments\n    function getTotalDepositsAmountLeft() public view returns (uint _amount) {\n        uint _lastDepositDate = lastDepositDate;\n        for (\n            uint _startDate = firstDepositDate;\n            _startDate <= _lastDepositDate || _startDate != 0;\n            _startDate = distributionDeposits[_startDate].nextDepositDate\n        ) {\n            _amount = _amount.add(distributionDeposits[_startDate].left);\n        }\n    }\n\n    /// @notice Gets an amount of deposits that has left after users' bonus withdrawals for selected date\n    /// @param _distributionDate date of distribution operation\n    /// @return amount of deposits available for bonus payments for concrete distribution date\n    function getDepositsAmountLeft(uint _distributionDate) public view returns (uint _amount) {\n        return distributionDeposits[_distributionDate].left;\n    }\n\n    /// @notice Makes checkmark and deposits tokens on profiterole account\n    /// to pay them later as bonuses for Treasury shares holders. Timestamp of transaction\n    /// counts as the distribution period date.\n    /// Only addresses that were added as a distributionSource are allowed to call this function.\n    ///\n    /// @param _amount an amount of tokens to distribute\n    ///\n    /// @return result code of an operation.\n    /// PROFITEROLE_ERROR_INSUFFICIENT_DISTRIBUTION_BALANCE, PROFITEROLE_ERROR_TRANSFER_ERROR errors\n    /// are possible\n    function distributeBonuses(uint _amount) public onlyDistributionSource returns (uint) {\n\n        ERC20Interface _bonusToken = ERC20Interface(bonusToken);\n\n        if (_bonusToken.allowance(msg.sender, address(this)) < _amount) {\n            return _emitError(PROFITEROLE_ERROR_INSUFFICIENT_DISTRIBUTION_BALANCE);\n        }\n\n        if (!_bonusToken.transferFrom(msg.sender, wallet, _amount)) {\n            return _emitError(PROFITEROLE_ERROR_TRANSFER_ERROR);\n        }\n\n        if (firstDepositDate == 0) {\n            firstDepositDate = now;\n        }\n\n        uint _lastDepositDate = lastDepositDate;\n        if (_lastDepositDate != 0) {\n            distributionDeposits[_lastDepositDate].nextDepositDate = now;\n        }\n\n        lastDepositDate = now;\n        distributionDeposits[now] = Deposit(_amount, _amount, 0);\n\n        Treasury(treasury).addDistributionPeriod();\n\n        DepositPendingAdded(_amount, msg.sender, now);\n        return OK;\n    }\n\n    function isTransferAllowed(address, address, address, address, uint) public view returns (bool) {\n        return false;\n    }\n\n    /* PRIVATE */\n\n    function _getCalculationStartDate(bytes32 _userKey) private view returns (uint _startDate) {\n        _startDate = bonusBalances[_userKey].lastWithdrawDate;\n        return _startDate != 0 ? _startDate : firstDepositDate;\n    }\n\n    function _withdrawBonuses(bytes32 _userKey, uint _value) private returns (uint) {\n        uint _startDate = _getCalculationStartDate(_userKey);\n        uint _lastWithdrawDate = _startDate;\n        Treasury _treasury = Treasury(treasury);\n\n        for (\n            uint _endDate = lastDepositDate;\n            _startDate <= _endDate && _startDate != 0 && _value > 0;\n            _startDate = distributionDeposits[_startDate].nextDepositDate\n        ) {\n            uint _balanceToWithdraw = _withdrawBonusesFromDeposit(_userKey, _startDate, _value, _treasury);\n            _value = _value.sub(_balanceToWithdraw);\n        }\n\n        if (_lastWithdrawDate != _startDate) {\n            bonusBalances[_userKey].lastWithdrawDate = _lastWithdrawDate;\n        }\n\n        if (_value > 0) {\n            revert();\n        }\n\n        return OK;\n    }\n\n    function _withdrawBonusesFromDeposit(bytes32 _userKey, uint _periodDate, uint _value, Treasury _treasury) private returns (uint) {\n        Deposit storage _pendingDeposit = distributionDeposits[_periodDate];\n        Balance storage _userBalance = _pendingDeposit.leftToWithdraw[_userKey];\n\n        uint _balanceToWithdraw;\n        if (_userBalance.initialized) {\n            _balanceToWithdraw = _userBalance.left;\n        } else {\n            uint _sharesPercent = _treasury.getSharesPercentForPeriod(_userKey, _periodDate);\n            _balanceToWithdraw = _pendingDeposit.balance.mul(_sharesPercent).div(PERCENT_PRECISION);\n            _userBalance.initialized = true;\n        }\n\n        if (_balanceToWithdraw > _value) {\n            _userBalance.left = _balanceToWithdraw - _value;\n            _balanceToWithdraw = _value;\n        } else {\n            delete _userBalance.left;\n        }\n\n        _pendingDeposit.left = _pendingDeposit.left.sub(_balanceToWithdraw);\n        return _balanceToWithdraw;\n    }\n}\n\n/// @title EmissionProviderEmitter\n///\n/// Organizes and provides a set of events specific for EmissionProvider's role\ncontract EmissionProviderEmitter {\n\n    event Error(uint errorCode);\n    event Emission(bytes32 smbl, address to, uint value);\n    event HardcapFinishedManually();\n    event Destruction();\n\n    function _emitError(uint _errorCode) internal returns (uint) {\n        Error(_errorCode);\n        return _errorCode;\n    }\n\n    function _emitEmission(bytes32 _smbl, address _to, uint _value) internal {\n        Emission(_smbl, _to, _value);\n    }\n\n    function _emitHardcapFinishedManually() internal {\n        HardcapFinishedManually();\n    }\n\n    function _emitDestruction() internal {\n        Destruction();\n    }\n}\n\ncontract Token is ERC20 {\n    \n    bytes32 public smbl;\n    address public platform;\n\n    function __transferWithReference(address _to, uint _value, string _reference, address _sender) public returns (bool);\n    function __transferFromWithReference(address _from, address _to, uint _value, string _reference, address _sender) public returns (bool);\n    function __approve(address _spender, uint _value, address _sender) public returns (bool);\n    function getLatestVersion() public returns (address);\n    function init(address _bmcPlatform, string _symbol, string _name) public;\n    function proposeUpgrade(address _newVersion) public;\n}\n\ncontract Platform {\n    mapping(bytes32 => address) public proxies;\n    function name(bytes32 _symbol) public view returns (string);\n    function setProxy(address _address, bytes32 _symbol) public returns (uint errorCode);\n    function isOwner(address _owner, bytes32 _symbol) public view returns (bool);\n    function totalSupply(bytes32 _symbol) public view returns (uint);\n    function balanceOf(address _holder, bytes32 _symbol) public view returns (uint);\n    function allowance(address _from, address _spender, bytes32 _symbol) public view returns (uint);\n    function baseUnit(bytes32 _symbol) public view returns (uint8);\n    function proxyTransferWithReference(address _to, uint _value, bytes32 _symbol, string _reference, address _sender) public returns (uint errorCode);\n    function proxyTransferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference, address _sender) public returns (uint errorCode);\n    function proxyApprove(address _spender, uint _value, bytes32 _symbol, address _sender) public returns (uint errorCode);\n    function issueAsset(bytes32 _symbol, uint _value, string _name, string _description, uint8 _baseUnit, bool _isReissuable) public returns (uint errorCode);\n    function reissueAsset(bytes32 _symbol, uint _value) public returns (uint errorCode);\n    function revokeAsset(bytes32 _symbol, uint _value) public returns (uint errorCode);\n    function isReissuable(bytes32 _symbol) public view returns (bool);\n    function changeOwnership(bytes32 _symbol, address _newOwner) public returns (uint errorCode);\n}\n\n\n/// @title EmissionProvider.\n///\n/// Provides participation registration and token volume issuance called Emission Event.\n/// Full functionality of EmissionProvider issuance will be available after adding a smart contract\n/// as part-owner of an ATx asset in asset's platform\ncontract EmissionProvider is OracleContractAdapter, ServiceAllowance, EmissionProviderEmitter {\n\n    uint constant EMISSION_PROVIDER_ERROR_SCOPE = 107000;\n    uint constant EMISSION_PROVIDER_ERROR_WRONG_STATE = EMISSION_PROVIDER_ERROR_SCOPE + 1;\n    uint constant EMISSION_PROVIDER_ERROR_INSUFFICIENT_BMC = EMISSION_PROVIDER_ERROR_SCOPE + 2;\n    uint constant EMISSION_PROVIDER_ERROR_INTERNAL = EMISSION_PROVIDER_ERROR_SCOPE + 3;\n\n    using SafeMath for uint;\n\n    enum State {\n        Init, Waiting, Sale, Reached, Destructed\n    }\n\n    uint public startDate;\n    uint public endDate;\n\n    uint public tokenSoftcapIssued;\n    uint public tokenSoftcap;\n\n    uint tokenHardcapIssuedValue;\n    uint tokenHardcapValue;\n\n    address public token;\n    address public bonusToken;\n    address public profiterole;\n\n    mapping(address => bool) public whitelist;\n\n    bool public destructed;\n    bool finishedHardcap;\n    bool needInitialization;\n\n    /// @dev Deny any access except during sale period (it's time for sale && hardcap haven't reached yet)\n    modifier onlySale {\n        var (hardcapState, softcapState) = getState();\n        if (!(State.Sale == hardcapState || State.Sale == softcapState)) {\n            _emitError(EMISSION_PROVIDER_ERROR_WRONG_STATE);\n            assembly {\n                mstore(0, 107001) // EMISSION_PROVIDER_ERROR_WRONG_STATE\n                return (0, 32)\n            }\n        }\n        _;\n    }\n\n    /// @dev Deny any access before all sales will be finished\n    modifier onlySaleFinished {\n        var (hardcapState, softcapState) = getState();\n        if (hardcapState < State.Reached || softcapState < State.Reached) {\n            _emitError(EMISSION_PROVIDER_ERROR_WRONG_STATE);\n            assembly {\n                mstore(0, 107001) // EMISSION_PROVIDER_ERROR_WRONG_STATE\n                return (0, 32)\n            }\n        }\n        _;\n    }\n    /// @dev Deny any access before hardcap will be reached\n    modifier notHardcapReached {\n        var (state,) = getState();\n        if (state >= State.Reached) {\n            _emitError(EMISSION_PROVIDER_ERROR_WRONG_STATE);\n            assembly {\n                mstore(0, 107001) // EMISSION_PROVIDER_ERROR_WRONG_STATE\n                return (0, 32)\n            }\n        }\n        _;\n    }\n\n    /// @dev Deny any access before softcap will be reached\n    modifier notSoftcapReached {\n        var (, state) = getState();\n        if (state >= State.Reached) {\n            _emitError(EMISSION_PROVIDER_ERROR_WRONG_STATE);\n            assembly {\n                mstore(0, 107001) // EMISSION_PROVIDER_ERROR_WRONG_STATE\n                return (0, 32)\n            }\n        }\n        _;\n    }\n\n    /// @dev Guards from calls to the contract in destructed state\n    modifier notDestructed {\n        if (destructed) {\n            _emitError(EMISSION_PROVIDER_ERROR_WRONG_STATE);\n            assembly {\n                mstore(0, 107001) // EMISSION_PROVIDER_ERROR_WRONG_STATE\n                return (0, 32)\n            }\n        }\n        _;\n    }\n\n    /// @dev Deny any access except the contract is not in init state\n    modifier onlyInit {\n        var (state,) = getState();\n        if (state != State.Init) {\n            _emitError(EMISSION_PROVIDER_ERROR_WRONG_STATE);\n            assembly {\n                mstore(0, 107001) // EMISSION_PROVIDER_ERROR_WRONG_STATE\n                return (0, 32)\n            }\n        }\n        _;\n    }\n\n    /// @dev Allow access only for whitelisted users\n    modifier onlyAllowed(address _account) {\n        if (whitelist[_account]) {\n            _;\n        }\n    }\n\n    /// @notice Constructor for EmissionProvider.\n    ///\n    /// @param _token token that will be served by EmissionProvider\n    /// @param _bonusToken shares token used for fee distribution\n    /// @param _profiterole address of fee destination\n    /// @param _startDate start date of emission event\n    /// @param _endDate end date of emission event\n    /// @param _tokenHardcap max amount of tokens that are allowed to issue. After reaching this number emission will be stopped.\n    function EmissionProvider(\n        address _token,\n        address _bonusToken,\n        address _profiterole,\n        uint _startDate,\n        uint _endDate,\n        uint _tokenSoftcap,\n        uint _tokenHardcap\n    )\n    public\n    {\n        require(_token != 0x0);\n        require(_bonusToken != 0x0);\n\n        require(_profiterole != 0x0);\n\n        require(_startDate != 0);\n        require(_endDate > _startDate);\n\n        require(_tokenSoftcap != 0);\n        require(_tokenHardcap >= _tokenSoftcap);\n\n        require(Profiterole(_profiterole).bonusToken() == _bonusToken);\n\n        token = _token;\n        bonusToken = _bonusToken;\n        profiterole = _profiterole;\n        startDate = _startDate;\n        endDate = _endDate;\n        tokenSoftcap = _tokenSoftcap;\n        tokenHardcapValue = _tokenHardcap - _tokenSoftcap;\n        needInitialization = true;\n    }\n\n    /// @dev Payable function. Don't accept any Ether\n    function() public payable {\n        revert();\n    }\n\n    /// @notice Initialization\n    /// Issue new ATx tokens for Softcap. After contract goes in Sale state\n    function init() public onlyContractOwner onlyInit returns (uint) {\n        needInitialization = false;\n        bytes32 _symbol = Token(token).smbl();\n        if (OK != Platform(Token(token).platform()).reissueAsset(_symbol, tokenSoftcap)) {\n            revert();\n        }\n        return OK;\n    }\n\n    /// @notice Gets absolute hardcap value which means it will be greater than softcap value.\n    /// Actual value will be equal to `tokenSoftcap - tokenHardcap`\n    function tokenHardcap() public view returns (uint) {\n        return tokenSoftcap + tokenHardcapValue;\n    }\n\n    /// @notice Gets absolute issued hardcap volume which means it will be greater than softcap value.\n    /// Actual value will be equal to `tokenSoftcap - tokenHardcapIssued`\n    function tokenHardcapIssued() public view returns (uint) {\n        return tokenSoftcap + tokenHardcapIssuedValue;\n    }\n\n    /// @notice Gets current state of Emission Provider. State changes over time or reaching buyback goals.\n    /// @return state of a Emission Provider. 'Init', 'Waiting', 'Sale', 'HardcapReached', 'Destructed` values are possible\n    function getState() public view returns (State, State) {\n        if (needInitialization) {\n            return (State.Init, State.Init);\n        }\n\n        if (destructed) {\n            return (State.Destructed, State.Destructed);\n        }\n\n        if (now < startDate) {\n            return (State.Waiting, State.Waiting);\n        }\n\n        State _hardcapState = (finishedHardcap || (tokenHardcapIssuedValue == tokenHardcapValue) || (now > endDate))\n        ? State.Reached\n        : State.Sale;\n\n        State _softcapState = (tokenSoftcapIssued == tokenSoftcap)\n        ? State.Reached\n        : State.Sale;\n\n        return (_hardcapState, _softcapState);\n    }\n\n    /// @notice Add users to whitelist.\n    /// @param _whitelist user list.\n    function addUsers(address[] _whitelist) public onlyOracleOrOwner onlySale returns (uint) {\n        for (uint _idx = 0; _idx < _whitelist.length; ++_idx) {\n            whitelist[_whitelist[_idx]] = true;\n        }\n        return OK;\n    }\n\n    /// @notice Removes users from whitelist.\n    /// @param _blacklist user in whitelist.\n    function removeUsers(address[] _blacklist) public onlyOracleOrOwner onlySale returns (uint) {\n        for (uint _idx = 0; _idx < _blacklist.length; ++_idx) {\n            delete whitelist[_blacklist[_idx]];\n        }\n        return OK;\n    }\n\n    /// @notice Issue tokens for user.\n    /// Access allowed only for oracle while the sale period is active.\n    ///\n    /// @param _token address for token.\n    /// @param _for user address.\n    /// @param _value token amount,\n    function issueHardcapToken(\n        address _token, \n        address _for, \n        uint _value\n    ) \n    onlyOracle \n    onlyAllowed(_for) \n    onlySale \n    notHardcapReached \n    public\n    returns (uint) \n    {\n        require(_token == token);\n        require(_value != 0);\n\n        uint _tokenHardcap = tokenHardcapValue;\n        uint _issued = tokenHardcapIssuedValue;\n        if (_issued.add(_value) > _tokenHardcap) {\n            _value = _tokenHardcap.sub(_issued);\n        }\n\n        tokenHardcapIssuedValue = _issued.add(_value);\n\n        bytes32 _symbol = Token(_token).smbl();\n        if (OK != Platform(Token(_token).platform()).reissueAsset(_symbol, _value)) {\n            revert();\n        }\n\n        if (!Token(_token).transfer(_for, _value)) {\n            revert();\n        }\n\n        _emitEmission(_symbol, _for, _value);\n        return OK;\n    }\n\n    /// @notice Issue tokens for user.\n    /// Access allowed only for oracle while the sale period is active.\n    ///\n    /// @param _token address for token.\n    /// @param _for user address.\n    /// @param _value token amount,\n    function issueSoftcapToken(\n        address _token, \n        address _for, \n        uint _value\n    ) \n    onlyOracle\n    onlyAllowed(_for)\n    onlySale\n    notSoftcapReached\n    public\n    returns (uint)\n    {\n        require(_token == token);\n        require(_value != 0);\n\n        uint _tokenSoftcap = tokenSoftcap;\n        uint _issued = tokenSoftcapIssued;\n        if (_issued.add(_value) > _tokenSoftcap) {\n            _value = _tokenSoftcap.sub(_issued);\n        }\n\n        tokenSoftcapIssued = _issued.add(_value);\n\n        if (!Token(_token).transfer(_for, _value)) {\n            revert();\n        }\n\n        _emitEmission(Token(_token).smbl(), _for, _value);\n        return OK;\n    }\n\n    /// @notice Performs finish hardcap manually\n    /// Only by contract owner and in sale period\n    function finishHardcap() public onlyContractOwner onlySale notHardcapReached returns (uint) {\n        finishedHardcap = true;\n        _emitHardcapFinishedManually();\n        return OK;\n    }\n\n    /// @notice Performs distribution of sent BMC tokens and send them to Profiterole address\n    /// Only by oracle address and after reaching hardcap conditions\n    function distributeBonuses() public onlyOracleOrOwner onlySaleFinished notDestructed returns (uint) {\n        ERC20Interface _token = ERC20Interface(bonusToken);\n        uint _balance = _token.balanceOf(address(this));\n\n        if (_balance == 0) {\n            return _emitError(EMISSION_PROVIDER_ERROR_INSUFFICIENT_BMC);\n        }\n\n        Profiterole _profiterole = Profiterole(profiterole);\n        if (!_token.approve(address(_profiterole), _balance)) {\n            return _emitError(EMISSION_PROVIDER_ERROR_INTERNAL);\n        }\n\n        if (OK != _profiterole.distributeBonuses(_balance)) {\n            revert();\n        }\n\n        return OK;\n    }\n\n    /// @notice Activates distruction.\n    /// Access allowed only by contract owner after distruction\n    function activateDestruction() public onlyContractOwner onlySaleFinished notDestructed returns (uint) {\n        destructed = true;\n        _emitDestruction();\n        return OK;\n    }\n\n    /* ServiceAllowance */\n\n    /// @notice Restricts transfers only for:\n    /// 1) oracle and only ATx tokens;\n    /// 2) from itself to holder\n    function isTransferAllowed(address _from, address _to, address, address _token, uint) public view returns (bool) {\n        if (_token == token &&\n            ((oracles[_from] && _to == address(this)) ||\n            (_from == address(this) && whitelist[_to]))\n        ) {\n            return true;\n        }\n    }\n\n    function tokenFallback(address _sender, uint, bytes) external {\n        require(msg.sender == Token(token).getLatestVersion());\n        require(oracles[_sender]);\n    }\n}",
  "bytecode": "606060405234156200001057600080fd5b60405160e08062001bc08339810160405280805191906020018051919060200180519190602001805191906020018051919060200180519190602001805160008054600160a060020a03191633600160a060020a03908116919091179091559092508816151590506200008257600080fd5b600160a060020a03861615156200009857600080fd5b600160a060020a0385161515620000ae57600080fd5b831515620000bb57600080fd5b838311620000c857600080fd5b811515620000d557600080fd5b81811015620000e357600080fd5b85600160a060020a031685600160a060020a03166341d4a1ab6000604051602001526040518163ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401602060405180830381600087803b15156200014d57600080fd5b6102c65a03f115156200015f57600080fd5b50505060405180519050600160a060020a03161415156200017f57600080fd5b60098054600160a060020a03988916600160a060020a031991821617909155600a805497891697821697909717909655600b8054959097169490951693909317909455600355600492909255600682905503600855600d805462ff00001916620100001790556119cb80620001f56000396000f3006060604052600436106101715763ffffffff60e060020a600035041663067906b181146101765780630b97bc86146101a55780630bf1c747146101ca5780630c3c92a3146101f15780631865c57d14610204578063205b931e146102505780632be4a9031461026e5780633f242990146102bd57806341d4a1ab146102d057806345644fd6146102e35780634592cd1d14610301578063557f4bc9146103145780635aa77d3c14610333578063700c94741461034657806383197ef01461039557806392c9a9e2146103aa5780639b19251a146103bd578063addd5099146103dc578063bca19900146103fb578063c0ee0b8a1461040e578063c24a0f8b1461043d578063c32ee59114610450578063c661deb414610484578063c875b1fb146104ac578063cb9bdf45146104bf578063ce606ee0146104d2578063d8f9659b146104e5578063d8fed39e1461053f578063e1c7392a14610552578063fbf22dea14610565578063fc0c546a1461058d575b600080fd5b341561018157600080fd5b6101896105a0565b604051600160a060020a03909116815260200160405180910390f35b34156101b057600080fd5b6101b86105af565b60405190815260200160405180910390f35b34156101d557600080fd5b6101dd6105b5565b604051901515815260200160405180910390f35b34156101fc57600080fd5b6101b86105be565b341561020f57600080fd5b610217610679565b6040518083600481111561022757fe5b60ff16815260200182600481111561023b57fe5b60ff1681526020019250505060405180910390f35b341561025b57600080fd5b6101b86004803560248101910135610726565b341561027957600080fd5b6101b860046024813581810190830135806020818102016040519081016040528093929190818152602001838360200280828437509496506107e995505050505050565b34156102c857600080fd5b6101b86108cd565b34156102db57600080fd5b6101896108d7565b34156102ee57600080fd5b6101b860048035602481019101356108e6565b341561030c57600080fd5b6101dd610998565b341561031f57600080fd5b6101dd600160a060020a03600435166109ef565b341561033e57600080fd5b610189610a4e565b341561035157600080fd5b6101b86004602481358181019083013580602081810201604051908101604052809392919081815260200183836020028082843750949650610a5d95505050505050565b34156103a057600080fd5b6103a8610b3d565b005b34156103b557600080fd5b6101b8610b62565b34156103c857600080fd5b6101dd600160a060020a0360043516610bf5565b34156103e757600080fd5b6101dd600160a060020a0360043516610c0a565b341561040657600080fd5b6101b8610c1f565b341561041957600080fd5b6103a860048035600160a060020a0316906024803591604435918201910135610c29565b341561044857600080fd5b6101b8610cd8565b341561045b57600080fd5b6101dd600160a060020a0360043581169060243581169060443581169060643516608435610cde565b341561048f57600080fd5b6101b8600160a060020a0360043581169060243516604435610d83565b34156104b757600080fd5b6101b861108d565b34156104ca57600080fd5b6101b86112d1565b34156104dd57600080fd5b6101896112d7565b34156104f057600080fd5b6101b8600460248135818101908301358060208181020160405190810160405280939291908181526020018383602002808284375094965050509235600160a060020a031692506112e6915050565b341561054a57600080fd5b6101b8611435565b341561055d57600080fd5b6101b861143b565b341561057057600080fd5b6101b8600160a060020a03600435811690602435166044356115d7565b341561059857600080fd5b610189611800565b600b54600160a060020a031681565b60035481565b600d5460ff1681565b6000805433600160a060020a0390811691161415610676576000806105e1610679565b915091508160048111156105f157fe5b6002148061060a575080600481111561060657fe5b6002145b151561062a5761061c6201a1f961180f565b506201a1f960005260206000f35b6000610634610679565b509050600381600481111561064557fe5b106106565761061c6201a1f961180f565b600d805461ff00191661010017905561066d611848565b600193505b5050505b90565b600080600080600d60029054906101000a900460ff16156106a05760008093509350610720565b600d5460ff16156106b75760048093509350610720565b6003544210156106cd5760018093509350610720565b600d54610100900460ff16806106e65750600854600754145b806106f2575060045442115b6106fd576002610700565b60035b915060065460055414610714576002610717565b60035b90508181935093505b50509091565b600080548190819033600160a060020a03908116911614156107e157600091505b838210156107dc5784848381811061075b57fe5b90506020020135600160a060020a0316905080600160a060020a03166000141580156107a05750600160a060020a03811660009081526002602052604090205460ff16155b156107d157600160a060020a0381166000908152600260205260409020805460ff191660011790556107d181611876565b816001019150610747565b600192505b505092915050565b600160a060020a033316600090815260026020526040812054819060ff1680610820575060005433600160a060020a039081169116145b156108c757600080610830610679565b9150915081600481111561084057fe5b60021480610859575080600481111561085557fe5b6002145b151561086b5761061c6201a1f961180f565b600092505b84518310156108c057600c600086858151811061088957fe5b90602001906020020151600160a060020a031681526020810191909152604001600020805460ff1916905560019290920191610870565b6001935050505b50919050565b6008546006540190565b600a54600160a060020a031681565b600080548190819033600160a060020a03908116911614156107e157600091505b838210156107dc5784848381811061091b57fe5b90506020020135600160a060020a0316905080600160a060020a031660001415801561095f5750600160a060020a03811660009081526002602052604090205460ff165b1561098d57600160a060020a0381166000908152600260205260409020805460ff1916905561098d816118b5565b816001019150610907565b60015460009033600160a060020a039081169116146109b957506000610676565b50600180546000805473ffffffffffffffffffffffffffffffffffffffff19908116600160a060020a0384161790915516815590565b6000805433600160a060020a0390811691161415610a4957600160a060020a0382161515610a1f57506000610a49565b506001805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0383161781555b919050565b600154600160a060020a031681565b600160a060020a033316600090815260026020526040812054819060ff1680610a94575060005433600160a060020a039081169116145b156108c757600080610aa4610679565b91509150816004811115610ab457fe5b60021480610acd5750806004811115610ac957fe5b6002145b1515610adf5761061c6201a1f961180f565b600092505b84518310156108c0576001600c6000878681518110610aff57fe5b90602001906020020151600160a060020a031681526020810191909152604001600020805460ff191691151591909117905560019290920191610ae4565b60005433600160a060020a0390811691161415610b605733600160a060020a0316ff5b565b6000805433600160a060020a039081169116141561067657600080610b85610679565b90925090506003826004811115610b9857fe5b1080610baf57506003816004811115610bad57fe5b105b15610bc05761061c6201a1f961180f565b600d5460ff1615610bd75761061c6201a1f961180f565b600d805460ff19166001179055610bec6118f5565b60019250505090565b600c6020526000908152604090205460ff1681565b60026020526000908152604090205460ff1681565b6007546006540190565b600954600160a060020a0316630e6d1de96000604051602001526040518163ffffffff1660e060020a028152600401602060405180830381600087803b1515610c7157600080fd5b6102c65a03f11515610c8257600080fd5b50505060405180519050600160a060020a031633600160a060020a0316141515610cab57600080fd5b600160a060020a03841660009081526002602052604090205460ff161515610cd257600080fd5b50505050565b60045481565b600954600090600160a060020a038481169116148015610d715750600160a060020a03861660009081526002602052604090205460ff168015610d32575030600160a060020a031685600160a060020a0316145b80610d71575030600160a060020a031686600160a060020a0316148015610d715750600160a060020a0385166000908152600c602052604090205460ff165b15610d7a575060015b95945050505050565b600160a060020a03331660009081526002602052604081205481908190819060ff161561108357600160a060020a0386166000908152600c6020526040902054869060ff161561108157600080610dd8610679565b91509150816004811115610de857fe5b60021480610e015750806004811115610dfd57fe5b6002145b1515610e135761061c6201a1f961180f565b6000610e1d610679565b5090506003816004811115610e2e57fe5b10610e3f5761061c6201a1f961180f565b600954600160a060020a038c8116911614610e5957600080fd5b881515610e6557600080fd5b600854600754909750955086610e81878b63ffffffff61192316565b1115610e9a57610e97878763ffffffff61193916565b98505b610eaa868a63ffffffff61192316565b600755600160a060020a038b1663cb4e75bb6000604051602001526040518163ffffffff1660e060020a028152600401602060405180830381600087803b1515610ef357600080fd5b6102c65a03f11515610f0457600080fd5b5050506040518051955050600160a060020a038b16634bde38c86000604051602001526040518163ffffffff1660e060020a028152600401602060405180830381600087803b1515610f5557600080fd5b6102c65a03f11515610f6657600080fd5b50505060405180519050600160a060020a031663e0873c06868b60006040516020015260405160e060020a63ffffffff851602815260048101929092526024820152604401602060405180830381600087803b1515610fc457600080fd5b6102c65a03f11515610fd557600080fd5b50505060405180516001149050610feb57600080fd5b8a600160a060020a031663a9059cbb8b8b60006040516020015260405160e060020a63ffffffff8516028152600160a060020a0390921660048301526024820152604401602060405180830381600087803b151561104857600080fd5b6102c65a03f1151561105957600080fd5b50505060405180519050151561106e57600080fd5b611079858b8b61194b565b600197505050505b505b5050509392505050565b600160a060020a03331660009081526002602052604081205481908190819060ff16806110c8575060005433600160a060020a039081169116145b15610672576000806110d8610679565b909250905060038260048111156110eb57fe5b10806111025750600381600481111561110057fe5b105b156111135761061c6201a1f961180f565b600d5460ff161561112a5761061c6201a1f961180f565b600a54600160a060020a03169450846370a082313060006040516020015260405160e060020a63ffffffff8416028152600160a060020a039091166004820152602401602060405180830381600087803b151561118657600080fd5b6102c65a03f1151561119757600080fd5b50505060405180519450508315156111bc576111b56201a1fa61180f565b95506112c9565b600b54600160a060020a039081169350851663095ea7b3848660006040516020015260405160e060020a63ffffffff8516028152600160a060020a0390921660048301526024820152604401602060405180830381600087803b151561122157600080fd5b6102c65a03f1151561123257600080fd5b50505060405180519050151561124e576111b56201a1fb61180f565b82600160a060020a0316630d80fcdb8560006040516020015260405160e060020a63ffffffff84160281526004810191909152602401602060405180830381600087803b151561129d57600080fd5b6102c65a03f115156112ae57600080fd5b505050604051805160011490506112c457600080fd5b600195505b505050505090565b60055481565b600054600160a060020a031681565b6000805481908190819033600160a060020a039081169116141561142c57600092505b85518310156114275785838151811061131e57fe5b90602001906020020151915081600160a060020a03166370a082313060006040516020015260405160e060020a63ffffffff8416028152600160a060020a039091166004820152602401602060405180830381600087803b151561138157600080fd5b6102c65a03f1151561139257600080fd5b5050506040518051915050801561141c5781600160a060020a031663a9059cbb868360006040516020015260405160e060020a63ffffffff8516028152600160a060020a0390921660048301526024820152604401602060405180830381600087803b151561140057600080fd5b6102c65a03f1151561141157600080fd5b505050604051805150505b600190920191611309565b600193505b50505092915050565b60065481565b60008054819033600160a060020a03908116911614156115d357600061145f610679565b509050600081600481111561147057fe5b146114815761061c6201a1f961180f565b600d805462ff000019169055600954600160a060020a031663cb4e75bb6000604051602001526040518163ffffffff1660e060020a028152600401602060405180830381600087803b15156114d557600080fd5b6102c65a03f115156114e657600080fd5b5050506040518051600954909350600160a060020a03169050634bde38c86000604051602001526040518163ffffffff1660e060020a028152600401602060405180830381600087803b151561153b57600080fd5b6102c65a03f1151561154c57600080fd5b50505060405180519050600160a060020a031663e0873c068360065460006040516020015260405160e060020a63ffffffff851602815260048101929092526024820152604401602060405180830381600087803b15156115ac57600080fd5b6102c65a03f115156115bd57600080fd5b50505060405180516001149050610bec57600080fd5b5090565b600160a060020a0333166000908152600260205260408120548190819060ff16156117f757600160a060020a0385166000908152600c6020526040902054859060ff16156110835760008061162a610679565b9150915081600481111561163a57fe5b60021480611653575080600481111561164f57fe5b6002145b15156116655761061c6201a1f961180f565b600061166f610679565b91506003905081600481111561168157fe5b106116925761061c6201a1f961180f565b600954600160a060020a038b81169116146116ac57600080fd5b8715156116b857600080fd5b6006546005549096509450856116d4868a63ffffffff61192316565b11156116ed576116ea868663ffffffff61193916565b97505b6116fd858963ffffffff61192316565b600555600160a060020a038a1663a9059cbb8a8a60006040516020015260405160e060020a63ffffffff8516028152600160a060020a0390921660048301526024820152604401602060405180830381600087803b151561175d57600080fd5b6102c65a03f1151561176e57600080fd5b50505060405180519050151561178357600080fd5b6117ee8a600160a060020a031663cb4e75bb6000604051602001526040518163ffffffff1660e060020a028152600401602060405180830381600087803b15156117cc57600080fd5b6102c65a03f115156117dd57600080fd5b505050604051805190508a8a61194b565b60019650505050505b50509392505050565b600954600160a060020a031681565b60007f2e36a7093f25f22bd4cbdeb6040174c3ba4c5fe8f1abc04e7c3c48f26c7413e08260405190815260200160405180910390a15090565b7fcd2525d5f744a73d0628d3559e6307b563577eef6e90395c5345d56251e6811560405160405180910390a1565b7e47706786c922d17b39285dc59d696bafea72c0b003d3841ae1202076f4c2e481604051600160a060020a03909116815260200160405180910390a150565b7f9c8e7d83025bef8a04c664b2f753f64b8814bdb7e27291d7e50935f18cc3c71281604051600160a060020a03909116815260200160405180910390a150565b7f32fc160bbed8ee6cd2b58d0c9e99c310c62dd70084e16ef451ba3deef6cb079d60405160405180910390a1565b60008282018381101561193257fe5b9392505050565b60008282111561194557fe5b50900390565b7f3e501db90d29a8b80c5dbafec3fbc8a0256516a56ef879411a72d8057ca39f59838383604051928352600160a060020a0390911660208301526040808301919091526060909101905180910390a15050505600a165627a7a7230582064d2fdec856d11cbaae0d755f990ba43f6c7f2d8c4cfe287508258be8c3bf2b80029000000000000000000000000e9b149d1d7025abbc2ff664e9d4e2e61950226c9000000000000000000000000df6ef343350780bf8c3410bf062e0c015b1dd67100000000000000000000000027ef687f2883c8506400dc1289afea3cce97b1ba000000000000000000000000000000000000000000000000000000005bfe9150000000000000000000000000000000000000000000000000000000005ddfc4d000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000de0b6b3a7640001",
  "constructorArguments": "000000000000000000000000e9b149d1d7025abbc2ff664e9d4e2e61950226c9000000000000000000000000df6ef343350780bf8c3410bf062e0c015b1dd67100000000000000000000000027ef687f2883c8506400dc1289afea3cce97b1ba000000000000000000000000000000000000000000000000000000005bfe9150000000000000000000000000000000000000000000000000000000005ddfc4d000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000de0b6b3a7640001"
}