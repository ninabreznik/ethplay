{
  "address": "0x325f68d32bdee6ed86e7235ff2480e2a433d6189",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "Censures",
  "compilerVersion": "v0.4.24+commit.e67f0147",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2019-01-14\n*/\n\n//  simple reputations store\n//  https://azimuth.network\n\npragma solidity 0.4.24;\n\n////////////////////////////////////////////////////////////////////////////////\n//  Imports\n////////////////////////////////////////////////////////////////////////////////\n\n// OpenZeppelin's Owneable.sol\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipRenounced(address indexed previousOwner);\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to relinquish control of the contract.\n   * @notice Renouncing to ownership will leave the contract without an owner.\n   * It will not be possible to call the functions with the `onlyOwner`\n   * modifier anymore.\n   */\n  function renounceOwnership() public onlyOwner {\n    emit OwnershipRenounced(owner);\n    owner = address(0);\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address _newOwner) public onlyOwner {\n    _transferOwnership(_newOwner);\n  }\n\n  /**\n   * @dev Transfers control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function _transferOwnership(address _newOwner) internal {\n    require(_newOwner != address(0));\n    emit OwnershipTransferred(owner, _newOwner);\n    owner = _newOwner;\n  }\n}\n\n// Azimuth's Azimuth.sol\n\n//  Azimuth: point state data contract\n//\n//    This contract is used for storing all data related to Azimuth points\n//    and their ownership. Consider this contract the Azimuth ledger.\n//\n//    It also contains permissions data, which ties in to ERC721\n//    functionality. Operators of an address are allowed to transfer\n//    ownership of all points owned by their associated address\n//    (ERC721's approveAll()). A transfer proxy is allowed to transfer\n//    ownership of a single point (ERC721's approve()).\n//    Separate from ERC721 are managers, assigned per point. They are\n//    allowed to perform \"low-impact\" operations on the owner's points,\n//    like configuring public keys and making escape requests.\n//\n//    Since data stores are difficult to upgrade, this contract contains\n//    as little actual business logic as possible. Instead, the data stored\n//    herein can only be modified by this contract's owner, which can be\n//    changed and is thus upgradable/replaceable.\n//\n//    This contract will be owned by the Ecliptic contract.\n//\ncontract Azimuth is Ownable\n{\n//\n//  Events\n//\n\n  //  OwnerChanged: :point is now owned by :owner\n  //\n  event OwnerChanged(uint32 indexed point, address indexed owner);\n\n  //  Activated: :point is now active\n  //\n  event Activated(uint32 indexed point);\n\n  //  Spawned: :prefix has spawned :child\n  //\n  event Spawned(uint32 indexed prefix, uint32 indexed child);\n\n  //  EscapeRequested: :point has requested a new :sponsor\n  //\n  event EscapeRequested(uint32 indexed point, uint32 indexed sponsor);\n\n  //  EscapeCanceled: :point's :sponsor request was canceled or rejected\n  //\n  event EscapeCanceled(uint32 indexed point, uint32 indexed sponsor);\n\n  //  EscapeAccepted: :point confirmed with a new :sponsor\n  //\n  event EscapeAccepted(uint32 indexed point, uint32 indexed sponsor);\n\n  //  LostSponsor: :point's :sponsor is now refusing it service\n  //\n  event LostSponsor(uint32 indexed point, uint32 indexed sponsor);\n\n  //  ChangedKeys: :point has new network public keys\n  //\n  event ChangedKeys( uint32 indexed point,\n                     bytes32 encryptionKey,\n                     bytes32 authenticationKey,\n                     uint32 cryptoSuiteVersion,\n                     uint32 keyRevisionNumber );\n\n  //  BrokeContinuity: :point has a new continuity number, :number\n  //\n  event BrokeContinuity(uint32 indexed point, uint32 number);\n\n  //  ChangedSpawnProxy: :spawnProxy can now spawn using :point\n  //\n  event ChangedSpawnProxy(uint32 indexed point, address indexed spawnProxy);\n\n  //  ChangedTransferProxy: :transferProxy can now transfer ownership of :point\n  //\n  event ChangedTransferProxy( uint32 indexed point,\n                              address indexed transferProxy );\n\n  //  ChangedManagementProxy: :managementProxy can now manage :point\n  //\n  event ChangedManagementProxy( uint32 indexed point,\n                                address indexed managementProxy );\n\n  //  ChangedVotingProxy: :votingProxy can now vote using :point\n  //\n  event ChangedVotingProxy(uint32 indexed point, address indexed votingProxy);\n\n  //  ChangedDns: dnsDomains have been updated\n  //\n  event ChangedDns(string primary, string secondary, string tertiary);\n\n//\n//  Structures\n//\n\n  //  Size: kinds of points registered on-chain\n  //\n  //    NOTE: the order matters, because of Solidity enum numbering\n  //\n  enum Size\n  {\n    Galaxy, // = 0\n    Star,   // = 1\n    Planet  // = 2\n  }\n\n  //  Point: state of a point\n  //\n  //    While the ordering of the struct members is semantically chaotic,\n  //    they are ordered to tightly pack them into Ethereum's 32-byte storage\n  //    slots, which reduces gas costs for some function calls.\n  //    The comment ticks indicate assumed slot boundaries.\n  //\n  struct Point\n  {\n    //  encryptionKey: (curve25519) encryption public key, or 0 for none\n    //\n    bytes32 encryptionKey;\n  //\n    //  authenticationKey: (ed25519) authentication public key, or 0 for none\n    //\n    bytes32 authenticationKey;\n  //\n    //  spawned: for stars and galaxies, all :active children\n    //\n    uint32[] spawned;\n  //\n    //  hasSponsor: true if the sponsor still supports the point\n    //\n    bool hasSponsor;\n\n    //  active: whether point can be linked\n    //\n    //    false: point belongs to prefix, cannot be configured or linked\n    //    true: point no longer belongs to prefix, can be configured and linked\n    //\n    bool active;\n\n    //  escapeRequested: true if the point has requested to change sponsors\n    //\n    bool escapeRequested;\n\n    //  sponsor: the point that supports this one on the network, or,\n    //           if :hasSponsor is false, the last point that supported it.\n    //           (by default, the point's half-width prefix)\n    //\n    uint32 sponsor;\n\n    //  escapeRequestedTo: if :escapeRequested is true, new sponsor requested\n    //\n    uint32 escapeRequestedTo;\n\n    //  cryptoSuiteVersion: version of the crypto suite used for the pubkeys\n    //\n    uint32 cryptoSuiteVersion;\n\n    //  keyRevisionNumber: incremented every time the public keys change\n    //\n    uint32 keyRevisionNumber;\n\n    //  continuityNumber: incremented to indicate network-side state loss\n    //\n    uint32 continuityNumber;\n  }\n\n  //  Deed: permissions for a point\n  //\n  struct Deed\n  {\n    //  owner: address that owns this point\n    //\n    address owner;\n\n    //  managementProxy: 0, or another address with the right to perform\n    //                   low-impact, managerial operations on this point\n    //\n    address managementProxy;\n\n    //  spawnProxy: 0, or another address with the right to spawn children\n    //              of this point\n    //\n    address spawnProxy;\n\n    //  votingProxy: 0, or another address with the right to vote as this point\n    //\n    address votingProxy;\n\n    //  transferProxy: 0, or another address with the right to transfer\n    //                 ownership of this point\n    //\n    address transferProxy;\n  }\n\n//\n//  General state\n//\n\n  //  points: per point, general network-relevant point state\n  //\n  mapping(uint32 => Point) public points;\n\n  //  rights: per point, on-chain ownership and permissions\n  //\n  mapping(uint32 => Deed) public rights;\n\n  //  operators: per owner, per address, has the right to transfer ownership\n  //             of all the owner's points (ERC721)\n  //\n  mapping(address => mapping(address => bool)) public operators;\n\n  //  dnsDomains: base domains for contacting galaxies\n  //\n  //    dnsDomains[0] is primary, the others are used as fallbacks\n  //\n  string[3] public dnsDomains;\n\n//\n//  Lookups\n//\n\n  //  sponsoring: per point, the points they are sponsoring\n  //\n  mapping(uint32 => uint32[]) public sponsoring;\n\n  //  sponsoringIndexes: per point, per point, (index + 1) in\n  //                     the sponsoring array\n  //\n  mapping(uint32 => mapping(uint32 => uint256)) public sponsoringIndexes;\n\n  //  escapeRequests: per point, the points they have open escape requests from\n  //\n  mapping(uint32 => uint32[]) public escapeRequests;\n\n  //  escapeRequestsIndexes: per point, per point, (index + 1) in\n  //                         the escapeRequests array\n  //\n  mapping(uint32 => mapping(uint32 => uint256)) public escapeRequestsIndexes;\n\n  //  pointsOwnedBy: per address, the points they own\n  //\n  mapping(address => uint32[]) public pointsOwnedBy;\n\n  //  pointOwnerIndexes: per owner, per point, (index + 1) in\n  //                     the pointsOwnedBy array\n  //\n  //    We delete owners by moving the last entry in the array to the\n  //    newly emptied slot, which is (n - 1) where n is the value of\n  //    pointOwnerIndexes[owner][point].\n  //\n  mapping(address => mapping(uint32 => uint256)) public pointOwnerIndexes;\n\n  //  managerFor: per address, the points they are the management proxy for\n  //\n  mapping(address => uint32[]) public managerFor;\n\n  //  managerForIndexes: per address, per point, (index + 1) in\n  //                     the managerFor array\n  //\n  mapping(address => mapping(uint32 => uint256)) public managerForIndexes;\n\n  //  spawningFor: per address, the points they can spawn with\n  //\n  mapping(address => uint32[]) public spawningFor;\n\n  //  spawningForIndexes: per address, per point, (index + 1) in\n  //                      the spawningFor array\n  //\n  mapping(address => mapping(uint32 => uint256)) public spawningForIndexes;\n\n  //  votingFor: per address, the points they can vote with\n  //\n  mapping(address => uint32[]) public votingFor;\n\n  //  votingForIndexes: per address, per point, (index + 1) in\n  //                    the votingFor array\n  //\n  mapping(address => mapping(uint32 => uint256)) public votingForIndexes;\n\n  //  transferringFor: per address, the points they can transfer\n  //\n  mapping(address => uint32[]) public transferringFor;\n\n  //  transferringForIndexes: per address, per point, (index + 1) in\n  //                          the transferringFor array\n  //\n  mapping(address => mapping(uint32 => uint256)) public transferringForIndexes;\n\n//\n//  Logic\n//\n\n  //  constructor(): configure default dns domains\n  //\n  constructor()\n    public\n  {\n    setDnsDomains(\"example.com\", \"example.com\", \"example.com\");\n  }\n\n  //  setDnsDomains(): set the base domains used for contacting galaxies\n  //\n  //    Note: since a string is really just a byte[], and Solidity can't\n  //    work with two-dimensional arrays yet, we pass in the three\n  //    domains as individual strings.\n  //\n  function setDnsDomains(string _primary, string _secondary, string _tertiary)\n    onlyOwner\n    public\n  {\n    dnsDomains[0] = _primary;\n    dnsDomains[1] = _secondary;\n    dnsDomains[2] = _tertiary;\n    emit ChangedDns(_primary, _secondary, _tertiary);\n  }\n\n  //\n  //  Point reading\n  //\n\n    //  isActive(): return true if _point is active\n    //\n    function isActive(uint32 _point)\n      view\n      external\n      returns (bool equals)\n    {\n      return points[_point].active;\n    }\n\n    //  getKeys(): returns the public keys and their details, as currently\n    //             registered for _point\n    //\n    function getKeys(uint32 _point)\n      view\n      external\n      returns (bytes32 crypt, bytes32 auth, uint32 suite, uint32 revision)\n    {\n      Point storage point = points[_point];\n      return (point.encryptionKey,\n              point.authenticationKey,\n              point.cryptoSuiteVersion,\n              point.keyRevisionNumber);\n    }\n\n    //  getKeyRevisionNumber(): gets the revision number of _point's current\n    //                          public keys\n    //\n    function getKeyRevisionNumber(uint32 _point)\n      view\n      external\n      returns (uint32 revision)\n    {\n      return points[_point].keyRevisionNumber;\n    }\n\n    //  hasBeenLinked(): returns true if the point has ever been assigned keys\n    //\n    function hasBeenLinked(uint32 _point)\n      view\n      external\n      returns (bool result)\n    {\n      return ( points[_point].keyRevisionNumber > 0 );\n    }\n\n    //  isLive(): returns true if _point currently has keys properly configured\n    //\n    function isLive(uint32 _point)\n      view\n      external\n      returns (bool result)\n    {\n      Point storage point = points[_point];\n      return ( point.encryptionKey != 0 &&\n               point.authenticationKey != 0 &&\n               point.cryptoSuiteVersion != 0 );\n    }\n\n    //  getContinuityNumber(): returns _point's current continuity number\n    //\n    function getContinuityNumber(uint32 _point)\n      view\n      external\n      returns (uint32 continuityNumber)\n    {\n      return points[_point].continuityNumber;\n    }\n\n    //  getSpawnCount(): return the number of children spawned by _point\n    //\n    function getSpawnCount(uint32 _point)\n      view\n      external\n      returns (uint32 spawnCount)\n    {\n      uint256 len = points[_point].spawned.length;\n      assert(len < 2**32);\n      return uint32(len);\n    }\n\n    //  getSpawned(): return array of points created under _point\n    //\n    //    Note: only useful for clients, as Solidity does not currently\n    //    support returning dynamic arrays.\n    //\n    function getSpawned(uint32 _point)\n      view\n      external\n      returns (uint32[] spawned)\n    {\n      return points[_point].spawned;\n    }\n\n    //  hasSponsor(): returns true if _point's sponsor is providing it service\n    //\n    function hasSponsor(uint32 _point)\n      view\n      external\n      returns (bool has)\n    {\n      return points[_point].hasSponsor;\n    }\n\n    //  getSponsor(): returns _point's current (or most recent) sponsor\n    //\n    function getSponsor(uint32 _point)\n      view\n      external\n      returns (uint32 sponsor)\n    {\n      return points[_point].sponsor;\n    }\n\n    //  isSponsor(): returns true if _sponsor is currently providing service\n    //               to _point\n    //\n    function isSponsor(uint32 _point, uint32 _sponsor)\n      view\n      external\n      returns (bool result)\n    {\n      Point storage point = points[_point];\n      return ( point.hasSponsor &&\n               (point.sponsor == _sponsor) );\n    }\n\n    //  getSponsoringCount(): returns the number of points _sponsor is\n    //                        providing service to\n    //\n    function getSponsoringCount(uint32 _sponsor)\n      view\n      external\n      returns (uint256 count)\n    {\n      return sponsoring[_sponsor].length;\n    }\n\n    //  getSponsoring(): returns a list of points _sponsor is providing\n    //                   service to\n    //\n    //    Note: only useful for clients, as Solidity does not currently\n    //    support returning dynamic arrays.\n    //\n    function getSponsoring(uint32 _sponsor)\n      view\n      external\n      returns (uint32[] sponsees)\n    {\n      return sponsoring[_sponsor];\n    }\n\n    //  escaping\n\n    //  isEscaping(): returns true if _point has an outstanding escape request\n    //\n    function isEscaping(uint32 _point)\n      view\n      external\n      returns (bool escaping)\n    {\n      return points[_point].escapeRequested;\n    }\n\n    //  getEscapeRequest(): returns _point's current escape request\n    //\n    //    the returned escape request is only valid as long as isEscaping()\n    //    returns true\n    //\n    function getEscapeRequest(uint32 _point)\n      view\n      external\n      returns (uint32 escape)\n    {\n      return points[_point].escapeRequestedTo;\n    }\n\n    //  isRequestingEscapeTo(): returns true if _point has an outstanding\n    //                          escape request targetting _sponsor\n    //\n    function isRequestingEscapeTo(uint32 _point, uint32 _sponsor)\n      view\n      public\n      returns (bool equals)\n    {\n      Point storage point = points[_point];\n      return (point.escapeRequested && (point.escapeRequestedTo == _sponsor));\n    }\n\n    //  getEscapeRequestsCount(): returns the number of points _sponsor\n    //                            is providing service to\n    //\n    function getEscapeRequestsCount(uint32 _sponsor)\n      view\n      external\n      returns (uint256 count)\n    {\n      return escapeRequests[_sponsor].length;\n    }\n\n    //  getEscapeRequests(): get the points _sponsor has received escape\n    //                       requests from\n    //\n    //    Note: only useful for clients, as Solidity does not currently\n    //    support returning dynamic arrays.\n    //\n    function getEscapeRequests(uint32 _sponsor)\n      view\n      external\n      returns (uint32[] requests)\n    {\n      return escapeRequests[_sponsor];\n    }\n\n  //\n  //  Point writing\n  //\n\n    //  activatePoint(): activate a point, register it as spawned by its prefix\n    //\n    function activatePoint(uint32 _point)\n      onlyOwner\n      external\n    {\n      //  make a point active, setting its sponsor to its prefix\n      //\n      Point storage point = points[_point];\n      require(!point.active);\n      point.active = true;\n      registerSponsor(_point, true, getPrefix(_point));\n      emit Activated(_point);\n    }\n\n    //  setKeys(): set network public keys of _point to _encryptionKey and\n    //            _authenticationKey, with the specified _cryptoSuiteVersion\n    //\n    function setKeys(uint32 _point,\n                     bytes32 _encryptionKey,\n                     bytes32 _authenticationKey,\n                     uint32 _cryptoSuiteVersion)\n      onlyOwner\n      external\n    {\n      Point storage point = points[_point];\n      if ( point.encryptionKey == _encryptionKey &&\n           point.authenticationKey == _authenticationKey &&\n           point.cryptoSuiteVersion == _cryptoSuiteVersion )\n      {\n        return;\n      }\n\n      point.encryptionKey = _encryptionKey;\n      point.authenticationKey = _authenticationKey;\n      point.cryptoSuiteVersion = _cryptoSuiteVersion;\n      point.keyRevisionNumber++;\n\n      emit ChangedKeys(_point,\n                       _encryptionKey,\n                       _authenticationKey,\n                       _cryptoSuiteVersion,\n                       point.keyRevisionNumber);\n    }\n\n    //  incrementContinuityNumber(): break continuity for _point\n    //\n    function incrementContinuityNumber(uint32 _point)\n      onlyOwner\n      external\n    {\n      Point storage point = points[_point];\n      point.continuityNumber++;\n      emit BrokeContinuity(_point, point.continuityNumber);\n    }\n\n    //  registerSpawn(): add a point to its prefix's list of spawned points\n    //\n    function registerSpawned(uint32 _point)\n      onlyOwner\n      external\n    {\n      //  if a point is its own prefix (a galaxy) then don't register it\n      //\n      uint32 prefix = getPrefix(_point);\n      if (prefix == _point)\n      {\n        return;\n      }\n\n      //  register a new spawned point for the prefix\n      //\n      points[prefix].spawned.push(_point);\n      emit Spawned(prefix, _point);\n    }\n\n    //  loseSponsor(): indicates that _point's sponsor is no longer providing\n    //                 it service\n    //\n    function loseSponsor(uint32 _point)\n      onlyOwner\n      external\n    {\n      Point storage point = points[_point];\n      if (!point.hasSponsor)\n      {\n        return;\n      }\n      registerSponsor(_point, false, point.sponsor);\n      emit LostSponsor(_point, point.sponsor);\n    }\n\n    //  setEscapeRequest(): for _point, start an escape request to _sponsor\n    //\n    function setEscapeRequest(uint32 _point, uint32 _sponsor)\n      onlyOwner\n      external\n    {\n      if (isRequestingEscapeTo(_point, _sponsor))\n      {\n        return;\n      }\n      registerEscapeRequest(_point, true, _sponsor);\n      emit EscapeRequested(_point, _sponsor);\n    }\n\n    //  cancelEscape(): for _point, stop the current escape request, if any\n    //\n    function cancelEscape(uint32 _point)\n      onlyOwner\n      external\n    {\n      Point storage point = points[_point];\n      if (!point.escapeRequested)\n      {\n        return;\n      }\n      uint32 request = point.escapeRequestedTo;\n      registerEscapeRequest(_point, false, 0);\n      emit EscapeCanceled(_point, request);\n    }\n\n    //  doEscape(): perform the requested escape\n    //\n    function doEscape(uint32 _point)\n      onlyOwner\n      external\n    {\n      Point storage point = points[_point];\n      require(point.escapeRequested);\n      registerSponsor(_point, true, point.escapeRequestedTo);\n      registerEscapeRequest(_point, false, 0);\n      emit EscapeAccepted(_point, point.sponsor);\n    }\n\n  //\n  //  Point utils\n  //\n\n    //  getPrefix(): compute prefix (\"parent\") of _point\n    //\n    function getPrefix(uint32 _point)\n      pure\n      public\n      returns (uint16 prefix)\n    {\n      if (_point < 0x10000)\n      {\n        return uint16(_point % 0x100);\n      }\n      return uint16(_point % 0x10000);\n    }\n\n    //  getPointSize(): return the size of _point\n    //\n    function getPointSize(uint32 _point)\n      external\n      pure\n      returns (Size _size)\n    {\n      if (_point < 0x100) return Size.Galaxy;\n      if (_point < 0x10000) return Size.Star;\n      return Size.Planet;\n    }\n\n    //  internal use\n\n    //  registerSponsor(): set the sponsorship state of _point and update the\n    //                     reverse lookup for sponsors\n    //\n    function registerSponsor(uint32 _point, bool _hasSponsor, uint32 _sponsor)\n      internal\n    {\n      Point storage point = points[_point];\n      bool had = point.hasSponsor;\n      uint32 prev = point.sponsor;\n\n      //  if we didn't have a sponsor, and won't get one,\n      //  or if we get the sponsor we already have,\n      //  nothing will change, so jump out early.\n      //\n      if ( (!had && !_hasSponsor) ||\n           (had && _hasSponsor && prev == _sponsor) )\n      {\n        return;\n      }\n\n      //  if the point used to have a different sponsor, do some gymnastics\n      //  to keep the reverse lookup gapless.  delete the point from the old\n      //  sponsor's list, then fill that gap with the list tail.\n      //\n      if (had)\n      {\n        //  i: current index in previous sponsor's list of sponsored points\n        //\n        uint256 i = sponsoringIndexes[prev][_point];\n\n        //  we store index + 1, because 0 is the solidity default value\n        //\n        assert(i > 0);\n        i--;\n\n        //  copy the last item in the list into the now-unused slot,\n        //  making sure to update its :sponsoringIndexes reference\n        //\n        uint32[] storage prevSponsoring = sponsoring[prev];\n        uint256 last = prevSponsoring.length - 1;\n        uint32 moved = prevSponsoring[last];\n        prevSponsoring[i] = moved;\n        sponsoringIndexes[prev][moved] = i + 1;\n\n        //  delete the last item\n        //\n        delete(prevSponsoring[last]);\n        prevSponsoring.length = last;\n        sponsoringIndexes[prev][_point] = 0;\n      }\n\n      if (_hasSponsor)\n      {\n        uint32[] storage newSponsoring = sponsoring[_sponsor];\n        newSponsoring.push(_point);\n        sponsoringIndexes[_sponsor][_point] = newSponsoring.length;\n      }\n\n      point.sponsor = _sponsor;\n      point.hasSponsor = _hasSponsor;\n    }\n\n    //  registerEscapeRequest(): set the escape state of _point and update the\n    //                           reverse lookup for sponsors\n    //\n    function registerEscapeRequest( uint32 _point,\n                                    bool _isEscaping, uint32 _sponsor )\n      internal\n    {\n      Point storage point = points[_point];\n      bool was = point.escapeRequested;\n      uint32 prev = point.escapeRequestedTo;\n\n      //  if we weren't escaping, and won't be,\n      //  or if we were escaping, and the new target is the same,\n      //  nothing will change, so jump out early.\n      //\n      if ( (!was && !_isEscaping) ||\n           (was && _isEscaping && prev == _sponsor) )\n      {\n        return;\n      }\n\n      //  if the point used to have a different request, do some gymnastics\n      //  to keep the reverse lookup gapless.  delete the point from the old\n      //  sponsor's list, then fill that gap with the list tail.\n      //\n      if (was)\n      {\n        //  i: current index in previous sponsor's list of sponsored points\n        //\n        uint256 i = escapeRequestsIndexes[prev][_point];\n\n        //  we store index + 1, because 0 is the solidity default value\n        //\n        assert(i > 0);\n        i--;\n\n        //  copy the last item in the list into the now-unused slot,\n        //  making sure to update its :escapeRequestsIndexes reference\n        //\n        uint32[] storage prevRequests = escapeRequests[prev];\n        uint256 last = prevRequests.length - 1;\n        uint32 moved = prevRequests[last];\n        prevRequests[i] = moved;\n        escapeRequestsIndexes[prev][moved] = i + 1;\n\n        //  delete the last item\n        //\n        delete(prevRequests[last]);\n        prevRequests.length = last;\n        escapeRequestsIndexes[prev][_point] = 0;\n      }\n\n      if (_isEscaping)\n      {\n        uint32[] storage newRequests = escapeRequests[_sponsor];\n        newRequests.push(_point);\n        escapeRequestsIndexes[_sponsor][_point] = newRequests.length;\n      }\n\n      point.escapeRequestedTo = _sponsor;\n      point.escapeRequested = _isEscaping;\n    }\n\n  //\n  //  Deed reading\n  //\n\n    //  owner\n\n    //  getOwner(): return owner of _point\n    //\n    function getOwner(uint32 _point)\n      view\n      external\n      returns (address owner)\n    {\n      return rights[_point].owner;\n    }\n\n    //  isOwner(): true if _point is owned by _address\n    //\n    function isOwner(uint32 _point, address _address)\n      view\n      external\n      returns (bool result)\n    {\n      return (rights[_point].owner == _address);\n    }\n\n    //  getOwnedPointCount(): return length of array of points that _whose owns\n    //\n    function getOwnedPointCount(address _whose)\n      view\n      external\n      returns (uint256 count)\n    {\n      return pointsOwnedBy[_whose].length;\n    }\n\n    //  getOwnedPoints(): return array of points that _whose owns\n    //\n    //    Note: only useful for clients, as Solidity does not currently\n    //    support returning dynamic arrays.\n    //\n    function getOwnedPoints(address _whose)\n      view\n      external\n      returns (uint32[] ownedPoints)\n    {\n      return pointsOwnedBy[_whose];\n    }\n\n    //  getOwnedPointAtIndex(): get point at _index from array of points that\n    //                         _whose owns\n    //\n    function getOwnedPointAtIndex(address _whose, uint256 _index)\n      view\n      external\n      returns (uint32 point)\n    {\n      uint32[] storage owned = pointsOwnedBy[_whose];\n      require(_index < owned.length);\n      return owned[_index];\n    }\n\n    //  management proxy\n\n    //  getManagementProxy(): returns _point's current management proxy\n    //\n    function getManagementProxy(uint32 _point)\n      view\n      external\n      returns (address manager)\n    {\n      return rights[_point].managementProxy;\n    }\n\n    //  isManagementProxy(): returns true if _proxy is _point's management proxy\n    //\n    function isManagementProxy(uint32 _point, address _proxy)\n      view\n      external\n      returns (bool result)\n    {\n      return (rights[_point].managementProxy == _proxy);\n    }\n\n    //  canManage(): true if _who is the owner or manager of _point\n    //\n    function canManage(uint32 _point, address _who)\n      view\n      external\n      returns (bool result)\n    {\n      Deed storage deed = rights[_point];\n      return ( (0x0 != _who) &&\n               ( (_who == deed.owner) ||\n                 (_who == deed.managementProxy) ) );\n    }\n\n    //  getManagerForCount(): returns the amount of points _proxy can manage\n    //\n    function getManagerForCount(address _proxy)\n      view\n      external\n      returns (uint256 count)\n    {\n      return managerFor[_proxy].length;\n    }\n\n    //  getManagerFor(): returns the points _proxy can manage\n    //\n    //    Note: only useful for clients, as Solidity does not currently\n    //    support returning dynamic arrays.\n    //\n    function getManagerFor(address _proxy)\n      view\n      external\n      returns (uint32[] mfor)\n    {\n      return managerFor[_proxy];\n    }\n\n    //  spawn proxy\n\n    //  getSpawnProxy(): returns _point's current spawn proxy\n    //\n    function getSpawnProxy(uint32 _point)\n      view\n      external\n      returns (address spawnProxy)\n    {\n      return rights[_point].spawnProxy;\n    }\n\n    //  isSpawnProxy(): returns true if _proxy is _point's spawn proxy\n    //\n    function isSpawnProxy(uint32 _point, address _proxy)\n      view\n      external\n      returns (bool result)\n    {\n      return (rights[_point].spawnProxy == _proxy);\n    }\n\n    //  canSpawnAs(): true if _who is the owner or spawn proxy of _point\n    //\n    function canSpawnAs(uint32 _point, address _who)\n      view\n      external\n      returns (bool result)\n    {\n      Deed storage deed = rights[_point];\n      return ( (0x0 != _who) &&\n               ( (_who == deed.owner) ||\n                 (_who == deed.spawnProxy) ) );\n    }\n\n    //  getSpawningForCount(): returns the amount of points _proxy\n    //                         can spawn with\n    //\n    function getSpawningForCount(address _proxy)\n      view\n      external\n      returns (uint256 count)\n    {\n      return spawningFor[_proxy].length;\n    }\n\n    //  getSpawningFor(): get the points _proxy can spawn with\n    //\n    //    Note: only useful for clients, as Solidity does not currently\n    //    support returning dynamic arrays.\n    //\n    function getSpawningFor(address _proxy)\n      view\n      external\n      returns (uint32[] sfor)\n    {\n      return spawningFor[_proxy];\n    }\n\n    //  voting proxy\n\n    //  getVotingProxy(): returns _point's current voting proxy\n    //\n    function getVotingProxy(uint32 _point)\n      view\n      external\n      returns (address voter)\n    {\n      return rights[_point].votingProxy;\n    }\n\n    //  isVotingProxy(): returns true if _proxy is _point's voting proxy\n    //\n    function isVotingProxy(uint32 _point, address _proxy)\n      view\n      external\n      returns (bool result)\n    {\n      return (rights[_point].votingProxy == _proxy);\n    }\n\n    //  canVoteAs(): true if _who is the owner of _point,\n    //               or the voting proxy of _point's owner\n    //\n    function canVoteAs(uint32 _point, address _who)\n      view\n      external\n      returns (bool result)\n    {\n      Deed storage deed = rights[_point];\n      return ( (0x0 != _who) &&\n               ( (_who == deed.owner) ||\n                 (_who == deed.votingProxy) ) );\n    }\n\n    //  getVotingForCount(): returns the amount of points _proxy can vote as\n    //\n    function getVotingForCount(address _proxy)\n      view\n      external\n      returns (uint256 count)\n    {\n      return votingFor[_proxy].length;\n    }\n\n    //  getVotingFor(): returns the points _proxy can vote as\n    //\n    //    Note: only useful for clients, as Solidity does not currently\n    //    support returning dynamic arrays.\n    //\n    function getVotingFor(address _proxy)\n      view\n      external\n      returns (uint32[] vfor)\n    {\n      return votingFor[_proxy];\n    }\n\n    //  transfer proxy\n\n    //  getTransferProxy(): returns _point's current transfer proxy\n    //\n    function getTransferProxy(uint32 _point)\n      view\n      external\n      returns (address transferProxy)\n    {\n      return rights[_point].transferProxy;\n    }\n\n    //  isTransferProxy(): returns true if _proxy is _point's transfer proxy\n    //\n    function isTransferProxy(uint32 _point, address _proxy)\n      view\n      external\n      returns (bool result)\n    {\n      return (rights[_point].transferProxy == _proxy);\n    }\n\n    //  canTransfer(): true if _who is the owner or transfer proxy of _point,\n    //                 or is an operator for _point's current owner\n    //\n    function canTransfer(uint32 _point, address _who)\n      view\n      external\n      returns (bool result)\n    {\n      Deed storage deed = rights[_point];\n      return ( (0x0 != _who) &&\n               ( (_who == deed.owner) ||\n                 (_who == deed.transferProxy) ||\n                 operators[deed.owner][_who] ) );\n    }\n\n    //  getTransferringForCount(): returns the amount of points _proxy\n    //                             can transfer\n    //\n    function getTransferringForCount(address _proxy)\n      view\n      external\n      returns (uint256 count)\n    {\n      return transferringFor[_proxy].length;\n    }\n\n    //  getTransferringFor(): get the points _proxy can transfer\n    //\n    //    Note: only useful for clients, as Solidity does not currently\n    //    support returning dynamic arrays.\n    //\n    function getTransferringFor(address _proxy)\n      view\n      external\n      returns (uint32[] tfor)\n    {\n      return transferringFor[_proxy];\n    }\n\n    //  isOperator(): returns true if _operator is allowed to transfer\n    //                ownership of _owner's points\n    //\n    function isOperator(address _owner, address _operator)\n      view\n      external\n      returns (bool result)\n    {\n      return operators[_owner][_operator];\n    }\n\n  //\n  //  Deed writing\n  //\n\n    //  setOwner(): set owner of _point to _owner\n    //\n    //    Note: setOwner() only implements the minimal data storage\n    //    logic for a transfer; the full transfer is implemented in\n    //    Ecliptic.\n    //\n    //    Note: _owner must not be the zero address.\n    //\n    function setOwner(uint32 _point, address _owner)\n      onlyOwner\n      external\n    {\n      //  prevent burning of points by making zero the owner\n      //\n      require(0x0 != _owner);\n\n      //  prev: previous owner, if any\n      //\n      address prev = rights[_point].owner;\n\n      if (prev == _owner)\n      {\n        return;\n      }\n\n      //  if the point used to have a different owner, do some gymnastics to\n      //  keep the list of owned points gapless.  delete this point from the\n      //  list, then fill that gap with the list tail.\n      //\n      if (0x0 != prev)\n      {\n        //  i: current index in previous owner's list of owned points\n        //\n        uint256 i = pointOwnerIndexes[prev][_point];\n\n        //  we store index + 1, because 0 is the solidity default value\n        //\n        assert(i > 0);\n        i--;\n\n        //  copy the last item in the list into the now-unused slot,\n        //  making sure to update its :pointOwnerIndexes reference\n        //\n        uint32[] storage owner = pointsOwnedBy[prev];\n        uint256 last = owner.length - 1;\n        uint32 moved = owner[last];\n        owner[i] = moved;\n        pointOwnerIndexes[prev][moved] = i + 1;\n\n        //  delete the last item\n        //\n        delete(owner[last]);\n        owner.length = last;\n        pointOwnerIndexes[prev][_point] = 0;\n      }\n\n      //  update the owner list and the owner's index list\n      //\n      rights[_point].owner = _owner;\n      pointsOwnedBy[_owner].push(_point);\n      pointOwnerIndexes[_owner][_point] = pointsOwnedBy[_owner].length;\n      emit OwnerChanged(_point, _owner);\n    }\n\n    //  setManagementProxy(): makes _proxy _point's management proxy\n    //\n    function setManagementProxy(uint32 _point, address _proxy)\n      onlyOwner\n      external\n    {\n      Deed storage deed = rights[_point];\n      address prev = deed.managementProxy;\n      if (prev == _proxy)\n      {\n        return;\n      }\n\n      //  if the point used to have a different manager, do some gymnastics\n      //  to keep the reverse lookup gapless.  delete the point from the\n      //  old manager's list, then fill that gap with the list tail.\n      //\n      if (0x0 != prev)\n      {\n        //  i: current index in previous manager's list of managed points\n        //\n        uint256 i = managerForIndexes[prev][_point];\n\n        //  we store index + 1, because 0 is the solidity default value\n        //\n        assert(i > 0);\n        i--;\n\n        //  copy the last item in the list into the now-unused slot,\n        //  making sure to update its :managerForIndexes reference\n        //\n        uint32[] storage prevMfor = managerFor[prev];\n        uint256 last = prevMfor.length - 1;\n        uint32 moved = prevMfor[last];\n        prevMfor[i] = moved;\n        managerForIndexes[prev][moved] = i + 1;\n\n        //  delete the last item\n        //\n        delete(prevMfor[last]);\n        prevMfor.length = last;\n        managerForIndexes[prev][_point] = 0;\n      }\n\n      if (0x0 != _proxy)\n      {\n        uint32[] storage mfor = managerFor[_proxy];\n        mfor.push(_point);\n        managerForIndexes[_proxy][_point] = mfor.length;\n      }\n\n      deed.managementProxy = _proxy;\n      emit ChangedManagementProxy(_point, _proxy);\n    }\n\n    //  setSpawnProxy(): makes _proxy _point's spawn proxy\n    //\n    function setSpawnProxy(uint32 _point, address _proxy)\n      onlyOwner\n      external\n    {\n      Deed storage deed = rights[_point];\n      address prev = deed.spawnProxy;\n      if (prev == _proxy)\n      {\n        return;\n      }\n\n      //  if the point used to have a different spawn proxy, do some\n      //  gymnastics to keep the reverse lookup gapless.  delete the point\n      //  from the old proxy's list, then fill that gap with the list tail.\n      //\n      if (0x0 != prev)\n      {\n        //  i: current index in previous proxy's list of spawning points\n        //\n        uint256 i = spawningForIndexes[prev][_point];\n\n        //  we store index + 1, because 0 is the solidity default value\n        //\n        assert(i > 0);\n        i--;\n\n        //  copy the last item in the list into the now-unused slot,\n        //  making sure to update its :spawningForIndexes reference\n        //\n        uint32[] storage prevSfor = spawningFor[prev];\n        uint256 last = prevSfor.length - 1;\n        uint32 moved = prevSfor[last];\n        prevSfor[i] = moved;\n        spawningForIndexes[prev][moved] = i + 1;\n\n        //  delete the last item\n        //\n        delete(prevSfor[last]);\n        prevSfor.length = last;\n        spawningForIndexes[prev][_point] = 0;\n      }\n\n      if (0x0 != _proxy)\n      {\n        uint32[] storage sfor = spawningFor[_proxy];\n        sfor.push(_point);\n        spawningForIndexes[_proxy][_point] = sfor.length;\n      }\n\n      deed.spawnProxy = _proxy;\n      emit ChangedSpawnProxy(_point, _proxy);\n    }\n\n    //  setVotingProxy(): makes _proxy _point's voting proxy\n    //\n    function setVotingProxy(uint32 _point, address _proxy)\n      onlyOwner\n      external\n    {\n      Deed storage deed = rights[_point];\n      address prev = deed.votingProxy;\n      if (prev == _proxy)\n      {\n        return;\n      }\n\n      //  if the point used to have a different voter, do some gymnastics\n      //  to keep the reverse lookup gapless.  delete the point from the\n      //  old voter's list, then fill that gap with the list tail.\n      //\n      if (0x0 != prev)\n      {\n        //  i: current index in previous voter's list of points it was\n        //     voting for\n        //\n        uint256 i = votingForIndexes[prev][_point];\n\n        //  we store index + 1, because 0 is the solidity default value\n        //\n        assert(i > 0);\n        i--;\n\n        //  copy the last item in the list into the now-unused slot,\n        //  making sure to update its :votingForIndexes reference\n        //\n        uint32[] storage prevVfor = votingFor[prev];\n        uint256 last = prevVfor.length - 1;\n        uint32 moved = prevVfor[last];\n        prevVfor[i] = moved;\n        votingForIndexes[prev][moved] = i + 1;\n\n        //  delete the last item\n        //\n        delete(prevVfor[last]);\n        prevVfor.length = last;\n        votingForIndexes[prev][_point] = 0;\n      }\n\n      if (0x0 != _proxy)\n      {\n        uint32[] storage vfor = votingFor[_proxy];\n        vfor.push(_point);\n        votingForIndexes[_proxy][_point] = vfor.length;\n      }\n\n      deed.votingProxy = _proxy;\n      emit ChangedVotingProxy(_point, _proxy);\n    }\n\n    //  setManagementProxy(): makes _proxy _point's transfer proxy\n    //\n    function setTransferProxy(uint32 _point, address _proxy)\n      onlyOwner\n      external\n    {\n      Deed storage deed = rights[_point];\n      address prev = deed.transferProxy;\n      if (prev == _proxy)\n      {\n        return;\n      }\n\n      //  if the point used to have a different transfer proxy, do some\n      //  gymnastics to keep the reverse lookup gapless.  delete the point\n      //  from the old proxy's list, then fill that gap with the list tail.\n      //\n      if (0x0 != prev)\n      {\n        //  i: current index in previous proxy's list of transferable points\n        //\n        uint256 i = transferringForIndexes[prev][_point];\n\n        //  we store index + 1, because 0 is the solidity default value\n        //\n        assert(i > 0);\n        i--;\n\n        //  copy the last item in the list into the now-unused slot,\n        //  making sure to update its :transferringForIndexes reference\n        //\n        uint32[] storage prevTfor = transferringFor[prev];\n        uint256 last = prevTfor.length - 1;\n        uint32 moved = prevTfor[last];\n        prevTfor[i] = moved;\n        transferringForIndexes[prev][moved] = i + 1;\n\n        //  delete the last item\n        //\n        delete(prevTfor[last]);\n        prevTfor.length = last;\n        transferringForIndexes[prev][_point] = 0;\n      }\n\n      if (0x0 != _proxy)\n      {\n        uint32[] storage tfor = transferringFor[_proxy];\n        tfor.push(_point);\n        transferringForIndexes[_proxy][_point] = tfor.length;\n      }\n\n      deed.transferProxy = _proxy;\n      emit ChangedTransferProxy(_point, _proxy);\n    }\n\n    //  setOperator(): dis/allow _operator to transfer ownership of all points\n    //                 owned by _owner\n    //\n    //    operators are part of the ERC721 standard\n    //\n    function setOperator(address _owner, address _operator, bool _approved)\n      onlyOwner\n      external\n    {\n      operators[_owner][_operator] = _approved;\n    }\n}\n\n// Azimuth's ReadsAzimuth.sol\n\n//  ReadsAzimuth: referring to and testing against the Azimuth\n//                data contract\n//\n//    To avoid needless repetition, this contract provides common\n//    checks and operations using the Azimuth contract.\n//\ncontract ReadsAzimuth\n{\n  //  azimuth: points data storage contract.\n  //\n  Azimuth public azimuth;\n\n  //  constructor(): set the Azimuth data contract's address\n  //\n  constructor(Azimuth _azimuth)\n    public\n  {\n    azimuth = _azimuth;\n  }\n\n  //  activePointOwner(): require that :msg.sender is the owner of _point,\n  //                      and that _point is active\n  //\n  modifier activePointOwner(uint32 _point)\n  {\n    require( azimuth.isOwner(_point, msg.sender) &&\n             azimuth.isActive(_point) );\n    _;\n  }\n\n  //  activePointManager(): require that :msg.sender can manage _point,\n  //                        and that _point is active\n  //\n  modifier activePointManager(uint32 _point)\n  {\n    require( azimuth.canManage(_point, msg.sender) &&\n             azimuth.isActive(_point) );\n    _;\n  }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n//  Censures\n////////////////////////////////////////////////////////////////////////////////\n\n//  Censures: simple reputation management\n//\n//    This contract allows stars and galaxies to assign a negative\n//    reputation (censure) to other points of the same or lower rank.\n//    These censures are not permanent, they can be forgiven.\n//\n//    Since Azimuth-based networks provide incentives for good behavior,\n//    making bad behavior the exception rather than the rule, this\n//    contract only provides registration of negative reputation.\n//\ncontract Censures is ReadsAzimuth\n{\n  //  Censured: :who got censured by :by\n  //\n  event Censured(uint16 indexed by, uint32 indexed who);\n\n  //  Forgiven: :who is no longer censured by :by\n  //\n  event Forgiven(uint16 indexed by, uint32 indexed who);\n\n  //  censuring: per point, the points they're censuring\n  //\n  mapping(uint16 => uint32[]) public censuring;\n\n  //  censuredBy: per point, those who have censured them\n  //\n  mapping(uint32 => uint16[]) public censuredBy;\n\n  //  censuringIndexes: per point per censure, (index + 1) in censures array\n  //\n  //    We delete censures by moving the last entry in the array to the\n  //    newly emptied slot, which is (n - 1) where n is the value of\n  //    indexes[point][censure].\n  //\n  mapping(uint16 => mapping(uint32 => uint256)) public censuringIndexes;\n\n  //  censuredByIndexes: per censure per point, (index + 1) in censured array\n  //\n  //    see also explanation for indexes_censures above\n  //\n  mapping(uint32 => mapping(uint16 => uint256)) public censuredByIndexes;\n\n  //  constructor(): register the azimuth contract\n  //\n  constructor(Azimuth _azimuth)\n    ReadsAzimuth(_azimuth)\n    public\n  {\n    //\n  }\n\n  //  getCensuringCount(): return length of array of censures made by _whose\n  //\n  function getCensuringCount(uint16 _whose)\n    view\n    public\n    returns (uint256 count)\n  {\n    return censuring[_whose].length;\n  }\n\n  //  getCensuring(): return array of censures made by _whose\n  //\n  //    Note: only useful for clients, as Solidity does not currently\n  //    support returning dynamic arrays.\n  //\n  function getCensuring(uint16 _whose)\n    view\n    public\n    returns (uint32[] cens)\n  {\n    return censuring[_whose];\n  }\n\n  //  getCensuredByCount(): return length of array of censures made against _who\n  //\n  function getCensuredByCount(uint16 _who)\n    view\n    public\n    returns (uint256 count)\n  {\n    return censuredBy[_who].length;\n  }\n\n  //  getCensuredBy(): return array of censures made against _who\n  //\n  //    Note: only useful for clients, as Solidity does not currently\n  //    support returning dynamic arrays.\n  //\n  function getCensuredBy(uint16 _who)\n    view\n    public\n    returns (uint16[] cens)\n  {\n    return censuredBy[_who];\n  }\n\n  //  censure(): register a censure of _who as _as\n  //\n  function censure(uint16 _as, uint32 _who)\n    external\n    activePointManager(_as)\n  {\n    require( //  can't censure self\n             //\n             (_as != _who) &&\n             //\n             //  must not haven censured _who already\n             //\n             (censuringIndexes[_as][_who] == 0) );\n\n    //  only stars and galaxies may censure, and only galaxies may censure\n    //  other galaxies. (enum gets smaller for higher point sizes)\n    //  this function's signature makes sure planets cannot censure.\n    //\n    Azimuth.Size asSize = azimuth.getPointSize(_as);\n    Azimuth.Size whoSize = azimuth.getPointSize(_who);\n    require( whoSize >= asSize );\n\n    //  update contract state with the new censure\n    //\n    censuring[_as].push(_who);\n    censuringIndexes[_as][_who] = censuring[_as].length;\n\n    //  and update the reverse lookup\n    //\n    censuredBy[_who].push(_as);\n    censuredByIndexes[_who][_as] = censuredBy[_who].length;\n\n    emit Censured(_as, _who);\n  }\n\n  //  forgive(): unregister a censure of _who as _as\n  //\n  function forgive(uint16 _as, uint32 _who)\n    external\n    activePointManager(_as)\n  {\n    //  below, we perform the same logic twice: once on the canonical data,\n    //  and once on the reverse lookup\n    //\n    //  i: current index in _as's list of censures\n    //  j: current index in _who's list of points that have censured it\n    //\n    uint256 i = censuringIndexes[_as][_who];\n    uint256 j = censuredByIndexes[_who][_as];\n\n    //  we store index + 1, because 0 is the eth default value\n    //  can only delete an existing censure\n    //\n    require( (i > 0) && (j > 0) );\n    i--;\n    j--;\n\n    //  copy last item in the list into the now-unused slot,\n    //  making sure to update the :indexes_ references\n    //\n    uint32[] storage cens = censuring[_as];\n    uint16[] storage cend = censuredBy[_who];\n    uint256 lastCens = cens.length - 1;\n    uint256 lastCend = cend.length - 1;\n    uint32 movedCens = cens[lastCens];\n    uint16 movedCend = cend[lastCend];\n    cens[i] = movedCens;\n    cend[j] = movedCend;\n    censuringIndexes[_as][movedCens] = i + 1;\n    censuredByIndexes[_who][movedCend] = j + 1;\n\n    //  delete the last item\n    //\n    cens.length = lastCens;\n    cend.length = lastCend;\n    censuringIndexes[_as][_who] = 0;\n    censuredByIndexes[_who][_as] = 0;\n\n    emit Forgiven(_as, _who);\n  }\n}",
  "bytecode": "608060405234801561001057600080fd5b50604051602080610d5b833981016040525160008054600160a060020a03909216600160a060020a0319909216919091179055610d09806100526000396000f3006080604052600436106100ae5763ffffffff7c01000000000000000000000000000000000000000000000000000000006000350416630fb7a5e681146100b357806320c2637e1461011f578063658cc376146101575780638618da88146101855780638f7a4738146101aa578063b6bcf354146101d1578063d40ffacb146101ed578063d487758a1461021e578063e83113a814610243578063e8a7dc0514610268578063f98139be146102a0575b600080fd5b3480156100bf57600080fd5b506100cf61ffff600435166102bc565b60408051602080825283518183015283519192839290830191858101910280838360005b8381101561010b5781810151838201526020016100f3565b505050509050019250505060405180910390f35b34801561012b57600080fd5b5061013e61ffff6004351660243561034b565b6040805163ffffffff9092168252519081900360200190f35b34801561016357600080fd5b5061017361ffff60043516610393565b60408051918252519081900360200190f35b34801561019157600080fd5b5061017363ffffffff6004351661ffff602435166103a9565b3480156101b657600080fd5b506101cf61ffff6004351663ffffffff602435166103c6565b005b3480156101dd57600080fd5b506100cf61ffff60043516610790565b3480156101f957600080fd5b50610202610821565b60408051600160a060020a039092168252519081900360200190f35b34801561022a57600080fd5b506101cf61ffff6004351663ffffffff60243516610830565b34801561024f57600080fd5b5061017361ffff6004351663ffffffff60243516610bda565b34801561027457600080fd5b5061028963ffffffff60043516602435610bf7565b6040805161ffff9092168252519081900360200190f35b3480156102ac57600080fd5b5061017361ffff60043516610c3d565b61ffff811660009081526002602090815260409182902080548351818402810184019094528084526060939283018282801561033f57602002820191906000526020600020906000905b82829054906101000a900461ffff1661ffff16815260200190600201906020826001010492830192600103820291508084116103065790505b50505050509050919050565b60016020528160005260406000208181548110151561036657fe5b9060005260206000209060089182820401919006600402915091509054906101000a900463ffffffff1681565b61ffff1660009081526001602052604090205490565b600460209081526000928352604080842090915290825290205481565b60008054604080517f9137fe0a00000000000000000000000000000000000000000000000000000000815261ffff86166004820181905233602483015291518493600160a060020a031691639137fe0a91604480830192602092919082900301818887803b15801561043757600080fd5b505af115801561044b573d6000803e3d6000fd5b505050506040513d602081101561046157600080fd5b50518015610504575060008054604080517f5e19b30500000000000000000000000000000000000000000000000000000000815263ffffffff851660048201529051600160a060020a0390921692635e19b305926024808401936020939083900390910190829087803b1580156104d757600080fd5b505af11580156104eb573d6000803e3d6000fd5b505050506040513d602081101561050157600080fd5b50515b151561050f57600080fd5b8363ffffffff168561ffff161415801561054b575061ffff8516600090815260036020908152604080832063ffffffff88168452909152902054155b151561055657600080fd5b60008054604080517f9397640500000000000000000000000000000000000000000000000000000000815261ffff891660048201529051600160a060020a03909216926393976405926024808401936020939083900390910190829087803b1580156105c157600080fd5b505af11580156105d5573d6000803e3d6000fd5b505050506040513d60208110156105eb57600080fd5b505160008054604080517f9397640500000000000000000000000000000000000000000000000000000000815263ffffffff891660048201529051939650600160a060020a0390911692639397640592602480840193602093929083900390910190829087803b15801561065e57600080fd5b505af1158015610672573d6000803e3d6000fd5b505050506040513d602081101561068857600080fd5b5051915082600281111561069857fe5b8260028111156106a457fe5b10156106af57600080fd5b61ffff8086166000818152600160208181526040808420805480850182558186528386206008820401805463ffffffff808f1660046007909516850261010090810a8281029302199093169190911790925588885292546003865284882082895286528488205560028086528488208054978801815580895286892060108904018054600f90991690920290940a808a029a0219909616989098179094558685525492825280842085855290915280832091909155517f672de430319eb045be436e23c1e2dde54bab11643b876afbcf00c6b8f290238a9190a35050505050565b61ffff811660009081526001602090815260409182902080548351818402810184019094528084526060939283018282801561033f57602002820191906000526020600020906000905b82829054906101000a900463ffffffff1663ffffffff16815260200190600401906020826003010492830192600103820291508084116107da575094979650505050505050565b600054600160a060020a031681565b60008054604080517f9137fe0a00000000000000000000000000000000000000000000000000000000815261ffff861660048201819052336024830152915184938493849384938493849384939092600160a060020a0390921691639137fe0a9160448082019260209290919082900301818887803b1580156108b257600080fd5b505af11580156108c6573d6000803e3d6000fd5b505050506040513d60208110156108dc57600080fd5b5051801561097f575060008054604080517f5e19b30500000000000000000000000000000000000000000000000000000000815263ffffffff851660048201529051600160a060020a0390921692635e19b305926024808401936020939083900390910190829087803b15801561095257600080fd5b505af1158015610966573d6000803e3d6000fd5b505050506040513d602081101561097c57600080fd5b50515b151561098a57600080fd5b61ffff8b16600081815260036020908152604080832063ffffffff8f1684528252808320546004835281842094845293909152812054919a50909850891180156109d45750600088115b15156109df57600080fd5b61ffff8b16600090815260016020908152604080832063ffffffff8e1684526002909252909120815481546000199c8d019c9b8c019b939a50919850808301975091019450879086908110610a3057fe5b90600052602060002090600891828204019190066004029054906101000a900463ffffffff1692508584815481101515610a6657fe5b90600052602060002090601091828204019190066002029054906101000a900461ffff16915082878a815481101515610a9b57fe5b90600052602060002090600891828204019190066004026101000a81548163ffffffff021916908363ffffffff160217905550818689815481101515610add57fe5b6000918252602080832060108304018054600f9093166002026101000a61ffff8181021990941695841602949094179093558d8116825260038352604080832063ffffffff888116855290855281842060018f8101909155908f16845260048552818420928716845291909352919020908901905584610b5d8882610c53565b5083610b698782610c8c565b5061ffff8b16600081815260036020908152604080832063ffffffff8f1680855290835281842084905560048352818420858552909252808320839055519092917f3117bd64ae3afde1b1fbaf78e7e84647e30969d8804ce132b4278e96d71446ce91a35050505050505050505050565b600360209081526000928352604080842090915290825290205481565b600260205281600052604060002081815481101515610c1257fe5b9060005260206000209060109182820401919006600202915091509054906101000a900461ffff1681565b61ffff1660009081526002602052604090205490565b815481835581811115610c87576007016008900481600701600890048360005260206000209182019101610c879190610cbc565b505050565b815481835581811115610c8757600f016010900481600f01601090048360005260206000209182019101610c8791905b610cda91905b80821115610cd65760008155600101610cc2565b5090565b905600a165627a7a72305820926f826b9b6bba7cd8a2e38d3476912561510f19de893417d907e48248ff37df0029000000000000000000000000223c067f8cf28ae173ee5cafea60ca44c335fecb",
  "constructorArguments": "000000000000000000000000223c067f8cf28ae173ee5cafea60ca44c335fecb"
}