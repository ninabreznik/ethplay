{
  "address": "0x2371c3764abf450c60a9985a74f8ce08a8fc7449",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "InsightsNetworkMigrationToEOS",
  "compilerVersion": "v0.4.24+commit.e67f0147",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2019-03-07\n*/\n\n// File: zeppelin-solidity/contracts/ownership/Ownable.sol\n\npragma solidity ^0.4.24;\n\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipRenounced(address indexed previousOwner);\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to relinquish control of the contract.\n   * @notice Renouncing to ownership will leave the contract without an owner.\n   * It will not be possible to call the functions with the `onlyOwner`\n   * modifier anymore.\n   */\n  function renounceOwnership() public onlyOwner {\n    emit OwnershipRenounced(owner);\n    owner = address(0);\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address _newOwner) public onlyOwner {\n    _transferOwnership(_newOwner);\n  }\n\n  /**\n   * @dev Transfers control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function _transferOwnership(address _newOwner) internal {\n    require(_newOwner != address(0));\n    emit OwnershipTransferred(owner, _newOwner);\n    owner = _newOwner;\n  }\n}\n\n// File: zeppelin-solidity/contracts/lifecycle/Destructible.sol\n\npragma solidity ^0.4.24;\n\n\n\n/**\n * @title Destructible\n * @dev Base contract that can be destroyed by owner. All funds in contract will be sent to the owner.\n */\ncontract Destructible is Ownable {\n  /**\n   * @dev Transfers the current balance to the owner and terminates the contract.\n   */\n  function destroy() public onlyOwner {\n    selfdestruct(owner);\n  }\n\n  function destroyAndSend(address _recipient) public onlyOwner {\n    selfdestruct(_recipient);\n  }\n}\n\n// File: zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n\npragma solidity ^0.4.24;\n\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * See https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address _who) public view returns (uint256);\n  function transfer(address _to, uint256 _value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// File: zeppelin-solidity/contracts/math/SafeMath.sol\n\npragma solidity ^0.4.24;\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (_a == 0) {\n      return 0;\n    }\n\n    c = _a * _b;\n    assert(c / _a == _b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = _a / _b;\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n    return _a / _b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    assert(_b <= _a);\n    return _a - _b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    c = _a + _b;\n    assert(c >= _a);\n    return c;\n  }\n}\n\n// File: zeppelin-solidity/contracts/token/ERC20/BasicToken.sol\n\npragma solidity ^0.4.24;\n\n\n\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) internal balances;\n\n  uint256 internal totalSupply_;\n\n  /**\n  * @dev Total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev Transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_value <= balances[msg.sender]);\n    require(_to != address(0));\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    emit Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256) {\n    return balances[_owner];\n  }\n\n}\n\n// File: zeppelin-solidity/contracts/token/ERC20/ERC20.sol\n\npragma solidity ^0.4.24;\n\n\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address _owner, address _spender)\n    public view returns (uint256);\n\n  function transferFrom(address _from, address _to, uint256 _value)\n    public returns (bool);\n\n  function approve(address _spender, uint256 _value) public returns (bool);\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}\n\n// File: zeppelin-solidity/contracts/token/ERC20/StandardToken.sol\n\npragma solidity ^0.4.24;\n\n\n\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * https://github.com/ethereum/EIPs/issues/20\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  )\n    public\n    returns (bool)\n  {\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n    require(_to != address(0));\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    emit Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    emit Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(\n    address _owner,\n    address _spender\n   )\n    public\n    view\n    returns (uint256)\n  {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(\n    address _spender,\n    uint256 _addedValue\n  )\n    public\n    returns (bool)\n  {\n    allowed[msg.sender][_spender] = (\n      allowed[msg.sender][_spender].add(_addedValue));\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(\n    address _spender,\n    uint256 _subtractedValue\n  )\n    public\n    returns (bool)\n  {\n    uint256 oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue >= oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n// File: zeppelin-solidity/contracts/lifecycle/Pausable.sol\n\npragma solidity ^0.4.24;\n\n\n\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() public onlyOwner whenNotPaused {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() public onlyOwner whenPaused {\n    paused = false;\n    emit Unpause();\n  }\n}\n\n// File: zeppelin-solidity/contracts/token/ERC20/PausableToken.sol\n\npragma solidity ^0.4.24;\n\n\n\n\n/**\n * @title Pausable token\n * @dev StandardToken modified with pausable transfers.\n **/\ncontract PausableToken is StandardToken, Pausable {\n\n  function transfer(\n    address _to,\n    uint256 _value\n  )\n    public\n    whenNotPaused\n    returns (bool)\n  {\n    return super.transfer(_to, _value);\n  }\n\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  )\n    public\n    whenNotPaused\n    returns (bool)\n  {\n    return super.transferFrom(_from, _to, _value);\n  }\n\n  function approve(\n    address _spender,\n    uint256 _value\n  )\n    public\n    whenNotPaused\n    returns (bool)\n  {\n    return super.approve(_spender, _value);\n  }\n\n  function increaseApproval(\n    address _spender,\n    uint _addedValue\n  )\n    public\n    whenNotPaused\n    returns (bool success)\n  {\n    return super.increaseApproval(_spender, _addedValue);\n  }\n\n  function decreaseApproval(\n    address _spender,\n    uint _subtractedValue\n  )\n    public\n    whenNotPaused\n    returns (bool success)\n  {\n    return super.decreaseApproval(_spender, _subtractedValue);\n  }\n}\n\n// File: zeppelin-solidity/contracts/token/ERC20/DetailedERC20.sol\n\npragma solidity ^0.4.24;\n\n\n\n/**\n * @title DetailedERC20 token\n * @dev The decimals are only for visualization purposes.\n * All the operations are done using the smallest and indivisible token unit,\n * just as on Ethereum all the operations are done in wei.\n */\ncontract DetailedERC20 is ERC20 {\n  string public name;\n  string public symbol;\n  uint8 public decimals;\n\n  constructor(string _name, string _symbol, uint8 _decimals) public {\n    name = _name;\n    symbol = _symbol;\n    decimals = _decimals;\n  }\n}\n\n// File: zeppelin-solidity/contracts/token/ERC20/MintableToken.sol\n\npragma solidity ^0.4.24;\n\n\n\n\n/**\n * @title Mintable token\n * @dev Simple ERC20 Token example, with mintable token creation\n * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\n */\ncontract MintableToken is StandardToken, Ownable {\n  event Mint(address indexed to, uint256 amount);\n  event MintFinished();\n\n  bool public mintingFinished = false;\n\n\n  modifier canMint() {\n    require(!mintingFinished);\n    _;\n  }\n\n  modifier hasMintPermission() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Function to mint tokens\n   * @param _to The address that will receive the minted tokens.\n   * @param _amount The amount of tokens to mint.\n   * @return A boolean that indicates if the operation was successful.\n   */\n  function mint(\n    address _to,\n    uint256 _amount\n  )\n    public\n    hasMintPermission\n    canMint\n    returns (bool)\n  {\n    totalSupply_ = totalSupply_.add(_amount);\n    balances[_to] = balances[_to].add(_amount);\n    emit Mint(_to, _amount);\n    emit Transfer(address(0), _to, _amount);\n    return true;\n  }\n\n  /**\n   * @dev Function to stop minting new tokens.\n   * @return True if the operation was successful.\n   */\n  function finishMinting() public onlyOwner canMint returns (bool) {\n    mintingFinished = true;\n    emit MintFinished();\n    return true;\n  }\n}\n\n// File: zeppelin-solidity/contracts/token/ERC20/CappedToken.sol\n\npragma solidity ^0.4.24;\n\n\n\n/**\n * @title Capped token\n * @dev Mintable token with a token cap.\n */\ncontract CappedToken is MintableToken {\n\n  uint256 public cap;\n\n  constructor(uint256 _cap) public {\n    require(_cap > 0);\n    cap = _cap;\n  }\n\n  /**\n   * @dev Function to mint tokens\n   * @param _to The address that will receive the minted tokens.\n   * @param _amount The amount of tokens to mint.\n   * @return A boolean that indicates if the operation was successful.\n   */\n  function mint(\n    address _to,\n    uint256 _amount\n  )\n    public\n    returns (bool)\n  {\n    require(totalSupply_.add(_amount) <= cap);\n\n    return super.mint(_to, _amount);\n  }\n\n}\n\n// File: contracts/InsightsNetwork1.sol\n\npragma solidity ^0.4.4;\n\ncontract InsightsNetwork1 {\n  address public owner; // Creator\n  address public successor; // May deactivate contract\n  mapping (address => uint) public balances;    // Who has what\n  mapping (address => uint) public unlockTimes; // When balances unlock\n  bool public active;\n  uint256 _totalSupply; // Sum of minted tokens\n\n  string public constant name = \"INS\";\n  string public constant symbol = \"INS\";\n  uint8 public constant decimals = 0;\n\n  function InsightsNetwork1() {\n    owner = msg.sender;\n    active = true;\n  }\n\n  function register(address newTokenHolder, uint issueAmount) { // Mint tokens and assign to new owner\n    require(active);\n    require(msg.sender == owner);   // Only creator can register\n    require(balances[newTokenHolder] == 0); // Accounts can only be registered once\n\n    _totalSupply += issueAmount;\n    Mint(newTokenHolder, issueAmount);  // Trigger event\n\n    require(balances[newTokenHolder] < (balances[newTokenHolder] + issueAmount));   // Overflow check\n    balances[newTokenHolder] += issueAmount;\n    Transfer(address(0), newTokenHolder, issueAmount);  // Trigger event\n\n    uint currentTime = block.timestamp; // seconds since the Unix epoch\n    uint unlockTime = currentTime + 365*24*60*60; // one year out from the current time\n    assert(unlockTime > currentTime); // check for overflow\n    unlockTimes[newTokenHolder] = unlockTime;\n  }\n\n  function totalSupply() constant returns (uint256) {   // ERC20 compliance\n    return _totalSupply;\n  }\n\n  function transfer(address _to, uint256 _value) returns (bool success) {   // ERC20 compliance\n    return false;\n  }\n\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {    // ERC20 compliance\n    return false;\n  }\n\n  function approve(address _spender, uint256 _value) returns (bool success) {   // ERC20 compliance\n    return false;\n  }\n\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {   // ERC20 compliance\n    return 0;   // No transfer allowance\n  }\n\n  function balanceOf(address _owner) constant returns (uint256 balance) {   // ERC20 compliance\n    return balances[_owner];\n  }\n\n  function getUnlockTime(address _accountHolder) constant returns (uint256) {\n    return unlockTimes[_accountHolder];\n  }\n\n  event Mint(address indexed _to, uint256 _amount);\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n  function makeSuccessor(address successorAddr) {\n    require(active);\n    require(msg.sender == owner);\n    //require(successorAddr == address(0));\n    successor = successorAddr;\n  }\n\n  function deactivate() {\n    require(active);\n    require(msg.sender == owner || (successor != address(0) && msg.sender == successor));   // Called by creator or successor\n    active = false;\n  }\n}\n\n// File: contracts/InsightsNetwork2Base.sol\n\npragma solidity ^0.4.18;\n\n\n\n\n\n\ncontract InsightsNetwork2Base is DetailedERC20(\"Insights Network\", \"INSTAR\", 18), PausableToken, CappedToken{\n\n    uint256 constant ATTOTOKEN_FACTOR = 10**18;\n\n    address public predecessor;\n    address public successor;\n\n    uint constant MAX_LENGTH = 1024;\n    uint constant MAX_PURCHASES = 64;\n    \n    mapping (address => uint256[]) public lockedBalances;\n    mapping (address => uint256[]) public unlockTimes;\n    mapping (address => bool) public imported;\n\n    event Import(address indexed account, uint256 amount, uint256 unlockTime);    \n\n    function InsightsNetwork2Base() public CappedToken(300*1000000*ATTOTOKEN_FACTOR) {\n        paused = true;\n        mintingFinished = true;\n    }\n\n    function activate(address _predecessor) public onlyOwner {\n        require(predecessor == 0);\n        require(_predecessor != 0);\n        require(predecessorDeactivated(_predecessor));\n        predecessor = _predecessor;\n        unpause();\n        mintingFinished = false;\n    }\n\n    function lockedBalanceOf(address account) public view returns (uint256 balance) {\n        uint256 amount;\n        for (uint256 index = 0; index < lockedBalances[account].length; index++)\n            if (unlockTimes[account][index] > now)\n                amount += lockedBalances[account][index];\n        return amount;\n    }\n\n    function mintBatch(address[] accounts, uint256[] amounts) public onlyOwner canMint returns (bool) {\n        require(accounts.length == amounts.length);\n        require(accounts.length <= MAX_LENGTH);\n        for (uint index = 0; index < accounts.length; index++)\n            require(mint(accounts[index], amounts[index]));\n        return true;\n    }\n\n    function mintUnlockTime(address account, uint256 amount, uint256 unlockTime) public onlyOwner canMint returns (bool) {\n        require(unlockTime > now);\n        require(lockedBalances[account].length < MAX_PURCHASES);\n        lockedBalances[account].push(amount);\n        unlockTimes[account].push(unlockTime);\n        return super.mint(account, amount);\n    }\n\n    function mintUnlockTimeBatch(address[] accounts, uint256[] amounts, uint256 unlockTime) public onlyOwner canMint returns (bool) {\n        require(accounts.length == amounts.length);\n        require(accounts.length <= MAX_LENGTH);\n        for (uint index = 0; index < accounts.length; index++)\n            require(mintUnlockTime(accounts[index], amounts[index], unlockTime));\n        return true;\n    }\n\n    function mintLockPeriod(address account, uint256 amount, uint256 lockPeriod) public onlyOwner canMint returns (bool) {\n        return mintUnlockTime(account, amount, now + lockPeriod);\n    }\n\n    function mintLockPeriodBatch(address[] accounts, uint256[] amounts, uint256 lockPeriod) public onlyOwner canMint returns (bool) {\n        return mintUnlockTimeBatch(accounts, amounts, now + lockPeriod);\n    }\n\n    function importBalance(address account) public onlyOwner canMint returns (bool);\n\n    function importBalanceBatch(address[] accounts) public onlyOwner canMint returns (bool) {\n        require(accounts.length <= MAX_LENGTH);\n        for (uint index = 0; index < accounts.length; index++)\n            require(importBalance(accounts[index]));\n        return true;\n    }\n\n    function transfer(address to, uint256 value) public returns (bool) {\n        require(value <= balances[msg.sender] - lockedBalanceOf(msg.sender));\n        return super.transfer(to, value);\n    }\n\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        require(value <= balances[from] - lockedBalanceOf(from));\n        return super.transferFrom(from, to, value);\n    }\n\n    function selfDestruct(address _successor) public onlyOwner whenPaused {\n        require(mintingFinished);\n        successor = _successor;\n        selfdestruct(owner);\n    }\n\n    function predecessorDeactivated(address _predecessor) internal view onlyOwner returns (bool);\n\n}\n\n// File: contracts/InsightsNetwork3.sol\n\npragma solidity ^0.4.18;\n\n\n\ncontract InsightsNetwork3 is InsightsNetwork2Base {\n\n    function importBalance(address account) public onlyOwner canMint returns (bool) {\n        require(!imported[account]);\n        InsightsNetwork2Base source = InsightsNetwork2Base(predecessor);\n        uint256 amount = source.balanceOf(account);\n        require(amount > 0);\n        imported[account] = true;\n        uint256 mintAmount = amount - source.lockedBalanceOf(account);\n        if (mintAmount > 0) {\n            Import(account, mintAmount, now);\n            assert(mint(account, mintAmount));\n            amount -= mintAmount;\n        }\n        for (uint index = 0; amount > 0; index++) {\n            uint256 unlockTime = source.unlockTimes(account, index);\n            if ( unlockTime > now ) {\n                mintAmount = source.lockedBalances(account, index);\n                Import(account, mintAmount, unlockTime);\n                assert(mintUnlockTime(account, mintAmount, unlockTime));\n                amount -= mintAmount;\n            }\n        }\n        return true;\n    }\n\n    function predecessorDeactivated(address _predecessor) internal view onlyOwner returns (bool) {\n        return InsightsNetwork2Base(_predecessor).paused() && InsightsNetwork2Base(_predecessor).mintingFinished();\n    }\n\n}\n\n// File: contracts/InsightsNetworkMigrationToEOS.sol\n\npragma solidity ^0.4.24;\n\n\n\n\ncontract InsightsNetworkMigrationToEOS is Destructible, Pausable {\n\n    InsightsNetwork3 public tokenContract;\n\n    mapping(address => string) public eosPublicKeys;\n    mapping(address => uint256) public changeTime;\n\n    uint256 public constant gracePeriod = 24 * 60 * 60;\n\n    event Register(address indexed account);\n    event Reject(address indexed account);\n\n    constructor(address _tokenContractAddr) public {\n        tokenContract = InsightsNetwork3(_tokenContractAddr);\n        paused = true;\n    }\n\n    function register(string eosPublicKey) public whenNotPaused {\n        require(tokenContract.balanceOf(msg.sender) > 0);\n\n        require(bytes(eosPublicKey).length == 53 && bytes(eosPublicKey)[0] == \"E\" && bytes(eosPublicKey)[1] == \"O\" && bytes(eosPublicKey)[2] == \"S\");\n        require(bytes(eosPublicKeys[msg.sender]).length == 0);\n\n        eosPublicKeys[msg.sender] = eosPublicKey;\n        changeTime[msg.sender] = block.timestamp;\n\n        emit Register(msg.sender);\n    }\n\n    function reject() public whenNotPaused {\n        require(bytes(eosPublicKeys[msg.sender]).length > 0);\n        require((changeTime[msg.sender] + gracePeriod) > block.timestamp);\n\n        delete eosPublicKeys[msg.sender];\n        delete changeTime[msg.sender];\n\n        emit Reject(msg.sender);\n    }\n}",
  "bytecode": "60806040526000805460a060020a60ff021916905534801561002057600080fd5b50604051602080610b2e83398101604052516000805460018054600160a060020a03909416600160a060020a031994851617905560a060020a60ff0219921633179190911674010000000000000000000000000000000000000000179055610aa18061008d6000396000f3006080604052600436106100cf5763ffffffff7c0100000000000000000000000000000000000000000000000000000000600035041663331c7de381146100d45780633f4ba83a1461016a5780634dc415de1461018157806355a373d6146101965780635c975abb146101c7578063715018a6146101f057806383197ef0146102055780638456cb591461021a5780638da5cb5b1461022f578063a06db7dc14610244578063c79ce19a1461026b578063f2c298be1461028c578063f2fde38b146102e5578063f5074f4114610306575b600080fd5b3480156100e057600080fd5b506100f5600160a060020a0360043516610327565b6040805160208082528351818301528351919283929083019185019080838360005b8381101561012f578181015183820152602001610117565b50505050905090810190601f16801561015c5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b34801561017657600080fd5b5061017f6103c0565b005b34801561018d57600080fd5b5061017f610436565b3480156101a257600080fd5b506101ab6104ec565b60408051600160a060020a039092168252519081900360200190f35b3480156101d357600080fd5b506101dc6104fb565b604080519115158252519081900360200190f35b3480156101fc57600080fd5b5061017f61050b565b34801561021157600080fd5b5061017f610577565b34801561022657600080fd5b5061017f61059c565b34801561023b57600080fd5b506101ab610617565b34801561025057600080fd5b50610259610626565b60408051918252519081900360200190f35b34801561027757600080fd5b50610259600160a060020a036004351661062d565b34801561029857600080fd5b506040805160206004803580820135601f810184900484028501840190955284845261017f94369492936024939284019190819084018382808284375094975061063f9650505050505050565b3480156102f157600080fd5b5061017f600160a060020a03600435166108d3565b34801561031257600080fd5b5061017f600160a060020a03600435166108f6565b600260208181526000928352604092839020805484516001821615610100026000190190911693909304601f81018390048302840183019094528383529192908301828280156103b85780601f1061038d576101008083540402835291602001916103b8565b820191906000526020600020905b81548152906001019060200180831161039b57829003601f168201915b505050505081565b600054600160a060020a031633146103d757600080fd5b60005460a060020a900460ff1615156103ef57600080fd5b6000805474ff0000000000000000000000000000000000000000191681556040517f7805862f689e2f13df9f062ff482ad3ad112aca9e0847911ed832e158c525b339190a1565b60005460a060020a900460ff161561044d57600080fd5b3360009081526002602081905260408220546000196101006001831615020116041161047857600080fd5b3360009081526003602052604090205442620151809091011161049a57600080fd5b3360009081526002602052604081206104b291610996565b33600081815260036020526040808220829055517fe87a127e630432a36e6ce7e0bcd8342ad7957812ec5c3220489f036e5e84c2769190a2565b600154600160a060020a031681565b60005460a060020a900460ff1681565b600054600160a060020a0316331461052257600080fd5b60008054604051600160a060020a03909116917ff8df31144d9c2f0f6b59d69b8b98abd5459d07f2742c4df920b25aae33c6482091a26000805473ffffffffffffffffffffffffffffffffffffffff19169055565b600054600160a060020a0316331461058e57600080fd5b600054600160a060020a0316ff5b600054600160a060020a031633146105b357600080fd5b60005460a060020a900460ff16156105ca57600080fd5b6000805474ff0000000000000000000000000000000000000000191660a060020a1781556040517f6985a02210a168e66602d3235cb6db0e70f92b3ba4d376a33c0f3d9434bff6259190a1565b600054600160a060020a031681565b6201518081565b60036020526000908152604090205481565b60005460a060020a900460ff161561065657600080fd5b600154604080517f70a082310000000000000000000000000000000000000000000000000000000081523360048201529051600092600160a060020a0316916370a0823191602480830192602092919082900301818787803b1580156106bb57600080fd5b505af11580156106cf573d6000803e3d6000fd5b505050506040513d60208110156106e557600080fd5b5051116106f157600080fd5b80516035148015610764575080600081518110151561070c57fe5b90602001015160f860020a900460f860020a027effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167f4500000000000000000000000000000000000000000000000000000000000000145b80156107d2575080600181518110151561077a57fe5b90602001015160f860020a900460f860020a027effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167f4f00000000000000000000000000000000000000000000000000000000000000145b801561084057508060028151811015156107e857fe5b90602001015160f860020a900460f860020a027effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167f5300000000000000000000000000000000000000000000000000000000000000145b151561084b57600080fd5b336000908152600260208190526040909120546000196101006001831615020116041561087757600080fd5b3360009081526002602090815260409091208251610897928401906109da565b5033600081815260036020526040808220429055517feeda149c76076b34d4b9d8896c2f7efc0d33d1c7b53ea3c5db490d64613f603a9190a250565b600054600160a060020a031633146108ea57600080fd5b6108f381610919565b50565b600054600160a060020a0316331461090d57600080fd5b80600160a060020a0316ff5b600160a060020a038116151561092e57600080fd5b60008054604051600160a060020a03808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a36000805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b50805460018160011615610100020316600290046000825580601f106109bc57506108f3565b601f0160209004906000526020600020908101906108f39190610a58565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f10610a1b57805160ff1916838001178555610a48565b82800160010185558215610a48579182015b82811115610a48578251825591602001919060010190610a2d565b50610a54929150610a58565b5090565b610a7291905b80821115610a545760008155600101610a5e565b905600a165627a7a72305820166295508bc56dd0a224031d87d9e2db61e166d04e4a739c83a65a7f2fc48ad50029000000000000000000000000c72fe8e3dd5bef0f9f31f259399f301272ef2a2d",
  "constructorArguments": "000000000000000000000000c72fe8e3dd5bef0f9f31f259399f301272ef2a2d"
}