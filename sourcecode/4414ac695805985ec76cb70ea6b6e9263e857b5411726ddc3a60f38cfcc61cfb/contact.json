{
  "address": "0x4c251de85ad3498c5b89388d8efc696ddd0b0fe7",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "FiCoin",
  "compilerVersion": "v0.4.18+commit.9cf6e910",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2018-01-23\n*/\n\npragma solidity ^0.4.18;\n\ncontract OraclizeI {\n    address public cbAddress;\n    function query(uint _timestamp, string _datasource, string _arg) external payable returns (bytes32 _id);\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) external payable returns (bytes32 _id);\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) public payable returns (bytes32 _id);\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) external payable returns (bytes32 _id);\n    function queryN(uint _timestamp, string _datasource, bytes _argN) public payable returns (bytes32 _id);\n    function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) external payable returns (bytes32 _id);\n    function getPrice(string _datasource) public returns (uint _dsprice);\n    function getPrice(string _datasource, uint gaslimit) public returns (uint _dsprice);\n    function setProofType(byte _proofType) external;\n    function setCustomGasPrice(uint _gasPrice) external;\n    function randomDS_getSessionPubKeyHash() external constant returns(bytes32);\n}\ncontract OraclizeAddrResolverI {\n    function getAddress() public returns (address _addr);\n}\ncontract usingOraclize {\n    uint constant day = 60*60*24;\n    uint constant week = 60*60*24*7;\n    uint constant month = 60*60*24*30;\n    byte constant proofType_NONE = 0x00;\n    byte constant proofType_TLSNotary = 0x10;\n    byte constant proofType_Android = 0x20;\n    byte constant proofType_Ledger = 0x30;\n    byte constant proofType_Native = 0xF0;\n    byte constant proofStorage_IPFS = 0x01;\n    uint8 constant networkID_auto = 0;\n    uint8 constant networkID_mainnet = 1;\n    uint8 constant networkID_testnet = 2;\n    uint8 constant networkID_morden = 2;\n    uint8 constant networkID_consensys = 161;\n\n    OraclizeAddrResolverI OAR;\n\n    OraclizeI oraclize;\n    modifier oraclizeAPI {\n        if((address(OAR)==0)||(getCodeSize(address(OAR))==0))\n            oraclize_setNetwork(networkID_auto);\n\n        if(address(oraclize) != OAR.getAddress())\n            oraclize = OraclizeI(OAR.getAddress());\n\n        _;\n    }\n    modifier coupon(string code){\n        oraclize = OraclizeI(OAR.getAddress());\n        _;\n    }\n\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n      return oraclize_setNetwork();\n      networkID; // silence the warning and remain backwards compatible\n    }\n    function oraclize_setNetwork() internal returns(bool){\n        if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){ //mainnet\n            OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\n            oraclize_setNetworkName(\"eth_mainnet\");\n            return true;\n        }\n        if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){ //ropsten testnet\n            OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\n            oraclize_setNetworkName(\"eth_ropsten3\");\n            return true;\n        }\n        if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){ //kovan testnet\n            OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\n            oraclize_setNetworkName(\"eth_kovan\");\n            return true;\n        }\n        if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){ //rinkeby testnet\n            OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\n            oraclize_setNetworkName(\"eth_rinkeby\");\n            return true;\n        }\n        if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){ //ethereum-bridge\n            OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\n            return true;\n        }\n        if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){ //ether.camp ide\n            OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\n            return true;\n        }\n        if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){ //browser-solidity\n            OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\n            return true;\n        }\n        return false;\n    }\n\n    function __callback(bytes32 myid, string result) public {\n        __callback(myid, result, new bytes(0));\n    }\n    function __callback(bytes32 myid, string result, bytes proof) public {\n      return;\n      myid; result; proof; // Silence compiler warnings\n    }\n\n    function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\n        return oraclize.getPrice(datasource);\n    }\n\n    function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\n        return oraclize.getPrice(datasource, gaslimit);\n    }\n\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(0, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(timestamp, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        bytes memory args = stra2cbor(argN);\n        return oraclize.queryN.value(price)(0, datasource, args);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        bytes memory args = stra2cbor(argN);\n        return oraclize.queryN.value(price)(timestamp, datasource, args);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        bytes memory args = stra2cbor(argN);\n        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n    }\n    function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        bytes memory args = stra2cbor(argN);\n        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n    }\n    function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](1);\n        dynargs[0] = args[0];\n        return oraclize_query(datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](1);\n        dynargs[0] = args[0];\n        return oraclize_query(timestamp, datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](1);\n        dynargs[0] = args[0];\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](1);\n        dynargs[0] = args[0];\n        return oraclize_query(datasource, dynargs, gaslimit);\n    }\n\n    function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](2);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        return oraclize_query(datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](2);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        return oraclize_query(timestamp, datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](2);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](2);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        return oraclize_query(datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](3);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        return oraclize_query(datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](3);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        return oraclize_query(timestamp, datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](3);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](3);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        return oraclize_query(datasource, dynargs, gaslimit);\n    }\n\n    function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](4);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        return oraclize_query(datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](4);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        return oraclize_query(timestamp, datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](4);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](4);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        return oraclize_query(datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](5);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        dynargs[4] = args[4];\n        return oraclize_query(datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](5);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        dynargs[4] = args[4];\n        return oraclize_query(timestamp, datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](5);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        dynargs[4] = args[4];\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](5);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        dynargs[4] = args[4];\n        return oraclize_query(datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        bytes memory args = ba2cbor(argN);\n        return oraclize.queryN.value(price)(0, datasource, args);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        bytes memory args = ba2cbor(argN);\n        return oraclize.queryN.value(price)(timestamp, datasource, args);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        bytes memory args = ba2cbor(argN);\n        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n    }\n    function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        bytes memory args = ba2cbor(argN);\n        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n    }\n    function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](1);\n        dynargs[0] = args[0];\n        return oraclize_query(datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](1);\n        dynargs[0] = args[0];\n        return oraclize_query(timestamp, datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](1);\n        dynargs[0] = args[0];\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](1);\n        dynargs[0] = args[0];\n        return oraclize_query(datasource, dynargs, gaslimit);\n    }\n\n    function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](2);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        return oraclize_query(datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](2);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        return oraclize_query(timestamp, datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](2);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](2);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        return oraclize_query(datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](3);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        return oraclize_query(datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](3);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        return oraclize_query(timestamp, datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](3);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](3);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        return oraclize_query(datasource, dynargs, gaslimit);\n    }\n\n    function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](4);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        return oraclize_query(datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](4);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        return oraclize_query(timestamp, datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](4);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](4);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        return oraclize_query(datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](5);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        dynargs[4] = args[4];\n        return oraclize_query(datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](5);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        dynargs[4] = args[4];\n        return oraclize_query(timestamp, datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](5);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        dynargs[4] = args[4];\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](5);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        dynargs[4] = args[4];\n        return oraclize_query(datasource, dynargs, gaslimit);\n    }\n\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\n        return oraclize.cbAddress();\n    }\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\n        return oraclize.setProofType(proofP);\n    }\n    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\n        return oraclize.setCustomGasPrice(gasPrice);\n    }\n\n    function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){\n        return oraclize.randomDS_getSessionPubKeyHash();\n    }\n\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\n        assembly {\n            _size := extcodesize(_addr)\n        }\n    }\n\n    function parseAddr(string _a) internal pure returns (address){\n        bytes memory tmp = bytes(_a);\n        uint160 iaddr = 0;\n        uint160 b1;\n        uint160 b2;\n        for (uint i=2; i<2+2*20; i+=2){\n            iaddr *= 256;\n            b1 = uint160(tmp[i]);\n            b2 = uint160(tmp[i+1]);\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n            else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n            else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n            iaddr += (b1*16+b2);\n        }\n        return address(iaddr);\n    }\n\n    function strCompare(string _a, string _b) internal pure returns (int) {\n        bytes memory a = bytes(_a);\n        bytes memory b = bytes(_b);\n        uint minLength = a.length;\n        if (b.length < minLength) minLength = b.length;\n        for (uint i = 0; i < minLength; i ++)\n            if (a[i] < b[i])\n                return -1;\n            else if (a[i] > b[i])\n                return 1;\n        if (a.length < b.length)\n            return -1;\n        else if (a.length > b.length)\n            return 1;\n        else\n            return 0;\n    }\n\n    function indexOf(string _haystack, string _needle) internal pure returns (int) {\n        bytes memory h = bytes(_haystack);\n        bytes memory n = bytes(_needle);\n        if(h.length < 1 || n.length < 1 || (n.length > h.length))\n            return -1;\n        else if(h.length > (2**128 -1))\n            return -1;\n        else\n        {\n            uint subindex = 0;\n            for (uint i = 0; i < h.length; i ++)\n            {\n                if (h[i] == n[0])\n                {\n                    subindex = 1;\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n                    {\n                        subindex++;\n                    }\n                    if(subindex == n.length)\n                        return int(i);\n                }\n            }\n            return -1;\n        }\n    }\n\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n        bytes memory _ba = bytes(_a);\n        bytes memory _bb = bytes(_b);\n        bytes memory _bc = bytes(_c);\n        bytes memory _bd = bytes(_d);\n        bytes memory _be = bytes(_e);\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n        bytes memory babcde = bytes(abcde);\n        uint k = 0;\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n        return string(babcde);\n    }\n\n    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n        return strConcat(_a, _b, _c, _d, \"\");\n    }\n\n    function strConcat(string _a, string _b, string _c) internal pure returns (string) {\n        return strConcat(_a, _b, _c, \"\", \"\");\n    }\n\n    function strConcat(string _a, string _b) internal pure returns (string) {\n        return strConcat(_a, _b, \"\", \"\", \"\");\n    }\n\n    // parseInt\n    function parseInt(string _a) internal pure returns (uint) {\n        return parseInt(_a, 0);\n    }\n\n    // parseInt(parseFloat*10^_b)\n    function parseInt(string _a, uint _b) internal pure returns (uint) {\n        bytes memory bresult = bytes(_a);\n        uint mint = 0;\n        bool decimals = false;\n        for (uint i=0; i<bresult.length; i++){\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n                if (decimals){\n                   if (_b == 0) break;\n                    else _b--;\n                }\n                mint *= 10;\n                mint += uint(bresult[i]) - 48;\n            } else if (bresult[i] == 46) decimals = true;\n        }\n        if (_b > 0) mint *= 10**_b;\n        return mint;\n    }\n\n    function uint2str(uint i) internal pure returns (string){\n        if (i == 0) return \"0\";\n        uint j = i;\n        uint len;\n        while (j != 0){\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint k = len - 1;\n        while (i != 0){\n            bstr[k--] = byte(48 + i % 10);\n            i /= 10;\n        }\n        return string(bstr);\n    }\n\n    function stra2cbor(string[] arr) internal pure returns (bytes) {\n            uint arrlen = arr.length;\n\n            // get correct cbor output length\n            uint outputlen = 0;\n            bytes[] memory elemArray = new bytes[](arrlen);\n            for (uint i = 0; i < arrlen; i++) {\n                elemArray[i] = (bytes(arr[i]));\n                outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3; //+3 accounts for paired identifier types\n            }\n            uint ctr = 0;\n            uint cborlen = arrlen + 0x80;\n            outputlen += byte(cborlen).length;\n            bytes memory res = new bytes(outputlen);\n\n            while (byte(cborlen).length > ctr) {\n                res[ctr] = byte(cborlen)[ctr];\n                ctr++;\n            }\n            for (i = 0; i < arrlen; i++) {\n                res[ctr] = 0x5F;\n                ctr++;\n                for (uint x = 0; x < elemArray[i].length; x++) {\n                    // if there's a bug with larger strings, this may be the culprit\n                    if (x % 23 == 0) {\n                        uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\n                        elemcborlen += 0x40;\n                        uint lctr = ctr;\n                        while (byte(elemcborlen).length > ctr - lctr) {\n                            res[ctr] = byte(elemcborlen)[ctr - lctr];\n                            ctr++;\n                        }\n                    }\n                    res[ctr] = elemArray[i][x];\n                    ctr++;\n                }\n                res[ctr] = 0xFF;\n                ctr++;\n            }\n            return res;\n        }\n\n    function ba2cbor(bytes[] arr) internal pure returns (bytes) {\n            uint arrlen = arr.length;\n\n            // get correct cbor output length\n            uint outputlen = 0;\n            bytes[] memory elemArray = new bytes[](arrlen);\n            for (uint i = 0; i < arrlen; i++) {\n                elemArray[i] = (bytes(arr[i]));\n                outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3; //+3 accounts for paired identifier types\n            }\n            uint ctr = 0;\n            uint cborlen = arrlen + 0x80;\n            outputlen += byte(cborlen).length;\n            bytes memory res = new bytes(outputlen);\n\n            while (byte(cborlen).length > ctr) {\n                res[ctr] = byte(cborlen)[ctr];\n                ctr++;\n            }\n            for (i = 0; i < arrlen; i++) {\n                res[ctr] = 0x5F;\n                ctr++;\n                for (uint x = 0; x < elemArray[i].length; x++) {\n                    // if there's a bug with larger strings, this may be the culprit\n                    if (x % 23 == 0) {\n                        uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\n                        elemcborlen += 0x40;\n                        uint lctr = ctr;\n                        while (byte(elemcborlen).length > ctr - lctr) {\n                            res[ctr] = byte(elemcborlen)[ctr - lctr];\n                            ctr++;\n                        }\n                    }\n                    res[ctr] = elemArray[i][x];\n                    ctr++;\n                }\n                res[ctr] = 0xFF;\n                ctr++;\n            }\n            return res;\n        }\n\n\n    string oraclize_network_name;\n    function oraclize_setNetworkName(string _network_name) internal {\n        oraclize_network_name = _network_name;\n    }\n\n    function oraclize_getNetworkName() internal view returns (string) {\n        return oraclize_network_name;\n    }\n\n    function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\n        require((_nbytes > 0) && (_nbytes <= 32));\n        bytes memory nbytes = new bytes(1);\n        nbytes[0] = byte(_nbytes);\n        bytes memory unonce = new bytes(32);\n        bytes memory sessionKeyHash = new bytes(32);\n        bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();\n        assembly {\n            mstore(unonce, 0x20)\n            mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\n            mstore(sessionKeyHash, 0x20)\n            mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\n        }\n        bytes[3] memory args = [unonce, nbytes, sessionKeyHash];\n        bytes32 queryId = oraclize_query(_delay, \"random\", args, _customGasLimit);\n        oraclize_randomDS_setCommitment(queryId, keccak256(bytes8(_delay), args[1], sha256(args[0]), args[2]));\n        return queryId;\n    }\n\n    function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {\n        oraclize_randomDS_args[queryId] = commitment;\n    }\n\n    mapping(bytes32=>bytes32) oraclize_randomDS_args;\n    mapping(bytes32=>bool) oraclize_randomDS_sessionKeysHashVerified;\n\n    function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){\n        bool sigok;\n        address signer;\n\n        bytes32 sigr;\n        bytes32 sigs;\n\n        bytes memory sigr_ = new bytes(32);\n        uint offset = 4+(uint(dersig[3]) - 0x20);\n        sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);\n        bytes memory sigs_ = new bytes(32);\n        offset += 32 + 2;\n        sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);\n\n        assembly {\n            sigr := mload(add(sigr_, 32))\n            sigs := mload(add(sigs_, 32))\n        }\n\n\n        (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);\n        if (address(keccak256(pubkey)) == signer) return true;\n        else {\n            (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);\n            return (address(keccak256(pubkey)) == signer);\n        }\n    }\n\n    function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {\n        bool sigok;\n\n        // Step 6: verify the attestation signature, APPKEY1 must sign the sessionKey from the correct ledger app (CODEHASH)\n        bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);\n        copyBytes(proof, sig2offset, sig2.length, sig2, 0);\n\n        bytes memory appkey1_pubkey = new bytes(64);\n        copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);\n\n        bytes memory tosign2 = new bytes(1+65+32);\n        tosign2[0] = byte(1); //role\n        copyBytes(proof, sig2offset-65, 65, tosign2, 1);\n        bytes memory CODEHASH = hex\"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c\";\n        copyBytes(CODEHASH, 0, 32, tosign2, 1+65);\n        sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);\n\n        if (sigok == false) return false;\n\n\n        // Step 7: verify the APPKEY1 provenance (must be signed by Ledger)\n        bytes memory LEDGERKEY = hex\"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4\";\n\n        bytes memory tosign3 = new bytes(1+65);\n        tosign3[0] = 0xFE;\n        copyBytes(proof, 3, 65, tosign3, 1);\n\n        bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);\n        copyBytes(proof, 3+65, sig3.length, sig3, 0);\n\n        sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);\n\n        return sigok;\n    }\n\n    modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {\n        // Step 1: the prefix has to match 'LP\\x01' (Ledger Proof version 1)\n        require((_proof[0] == \"L\") && (_proof[1] == \"P\") && (_proof[2] == 1));\n\n        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n        require(proofVerified);\n\n        _;\n    }\n\n    function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){\n        // Step 1: the prefix has to match 'LP\\x01' (Ledger Proof version 1)\n        if ((_proof[0] != \"L\")||(_proof[1] != \"P\")||(_proof[2] != 1)) return 1;\n\n        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n        if (proofVerified == false) return 2;\n\n        return 0;\n    }\n\n    function matchBytes32Prefix(bytes32 content, bytes prefix, uint n_random_bytes) internal pure returns (bool){\n        bool match_ = true;\n        \n\n        for (uint256 i=0; i< n_random_bytes; i++) {\n            if (content[i] != prefix[i]) match_ = false;\n        }\n\n        return match_;\n    }\n\n    function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\n\n        // Step 2: the unique keyhash has to match with the sha256 of (context name + queryId)\n        uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32;\n        bytes memory keyhash = new bytes(32);\n        copyBytes(proof, ledgerProofLength, 32, keyhash, 0);\n        if (!(keccak256(keyhash) == keccak256(sha256(context_name, queryId)))) return false;\n\n        bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2);\n        copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0);\n\n        // Step 3: we assume sig1 is valid (it will be verified during step 5) and we verify if 'result' is the prefix of sha256(sig1)\n        if (!matchBytes32Prefix(sha256(sig1), result, uint(proof[ledgerProofLength+32+8]))) return false;\n\n        // Step 4: commitment match verification, keccak256(delay, nbytes, unonce, sessionKeyHash) == commitment in storage.\n        // This is to verify that the computed args match with the ones specified in the query.\n        bytes memory commitmentSlice1 = new bytes(8+1+32);\n        copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0);\n\n        bytes memory sessionPubkey = new bytes(64);\n        uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65;\n        copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0);\n\n        bytes32 sessionPubkeyHash = sha256(sessionPubkey);\n        if (oraclize_randomDS_args[queryId] == keccak256(commitmentSlice1, sessionPubkeyHash)){ //unonce, nbytes and sessionKeyHash match\n            delete oraclize_randomDS_args[queryId];\n        } else return false;\n\n\n        // Step 5: validity verification for sig1 (keyhash and args signed with the sessionKey)\n        bytes memory tosign1 = new bytes(32+8+1+32);\n        copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0);\n        if (!verifySig(sha256(tosign1), sig1, sessionPubkey)) return false;\n\n        // verify if sessionPubkeyHash was verified already, if not.. let's do it!\n        if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){\n            oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);\n        }\n\n        return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];\n    }\n\n    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\n    function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal pure returns (bytes) {\n        uint minLength = length + toOffset;\n\n        // Buffer too small\n        require(to.length >= minLength); // Should be a better way?\n\n        // NOTE: the offset 32 is added to skip the `size` field of both bytes variables\n        uint i = 32 + fromOffset;\n        uint j = 32 + toOffset;\n\n        while (i < (32 + fromOffset + length)) {\n            assembly {\n                let tmp := mload(add(from, i))\n                mstore(add(to, j), tmp)\n            }\n            i += 32;\n            j += 32;\n        }\n\n        return to;\n    }\n\n    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\n    // Duplicate Solidity's ecrecover, but catching the CALL return value\n    function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\n        // We do our own memory management here. Solidity uses memory offset\n        // 0x40 to store the current end of memory. We write past it (as\n        // writes are memory extensions), but don't update the offset so\n        // Solidity will reuse it. The memory used here is only needed for\n        // this context.\n\n        // FIXME: inline assembly can't access return values\n        bool ret;\n        address addr;\n\n        assembly {\n            let size := mload(0x40)\n            mstore(size, hash)\n            mstore(add(size, 32), v)\n            mstore(add(size, 64), r)\n            mstore(add(size, 96), s)\n\n            // NOTE: we can reuse the request memory because we deal with\n            //       the return code\n            ret := call(3000, 1, 0, size, 128, size, 32)\n            addr := mload(size)\n        }\n\n        return (ret, addr);\n    }\n\n    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\n    function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        if (sig.length != 65)\n          return (false, 0);\n\n        // The signature format is a compact form of:\n        //   {bytes32 r}{bytes32 s}{uint8 v}\n        // Compact means, uint8 is not padded to 32 bytes.\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n\n            // Here we are loading the last 32 bytes. We exploit the fact that\n            // 'mload' will pad with zeroes if we overread.\n            // There is no 'mload8' to do this, but that would be nicer.\n            v := byte(0, mload(add(sig, 96)))\n\n            // Alternative solution:\n            // 'byte' is not working due to the Solidity parser, so lets\n            // use the second best option, 'and'\n            // v := and(mload(add(sig, 65)), 255)\n        }\n\n        // albeit non-transactional signatures are not specified by the YP, one would expect it\n        // to match the YP range of [27, 28]\n        //\n        // geth uses [0, 1] and some clients have followed. This might change, see:\n        //  https://github.com/ethereum/go-ethereum/issues/2053\n        if (v < 27)\n          v += 27;\n\n        if (v != 27 && v != 28)\n            return (false, 0);\n\n        return safer_ecrecover(hash, v, r, s);\n    }\n\n}\n// </ORACLIZE_API>\n\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\ncontract ERC20 {\n    uint256 public totalSupply;\n    function balanceOf(address who) public view returns (uint256);\n    function transfer(address to, uint256 value) public returns (bool);\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\n    function allowance(address owner, address spender) public view returns (uint256);\n    function approve(address spender, uint256 value) public returns (bool);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\ncontract StandardToken is ERC20 {\n    using SafeMath for uint256;\n\n    mapping(address => uint256) balances;\n    mapping (address => mapping (address => uint256)) internal allowed;\n\n    /**\n    * @dev Gets the balance of the specified address.\n    * @param _owner The address to query the the balance of.\n    * @return An uint256 representing the amount owned by the passed address.\n    */\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    /**\n    * @dev transfer token for a specified address\n    * @param _to The address to transfer to.\n    * @param _value The amount to be transferred.\n    */\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(_value <= balances[msg.sender]);\n\n        // SafeMath.sub will throw if there is not enough balance.\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    /**\n    * @dev Transfer tokens from one address to another\n    * @param _from address The address which you want to send tokens from\n    * @param _to address The address which you want to transfer to\n    * @param _value uint256 the amount of tokens to be transferred\n    */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(_value <= balances[_from]);\n        require(_value <= allowed[_from][msg.sender]);\n\n        balances[_from] = balances[_from].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n    * @dev Function to check the amount of tokens that an owner allowed to a spender.\n    * @param _owner address The address which owns the funds.\n    * @param _spender address The address which will spend the funds.\n    * @return A uint256 specifying the amount of tokens still available for the spender.\n    */\n    function allowance(address _owner, address _spender) public view returns (uint256) {\n        return allowed[_owner][_spender];\n    }\n\n    /**\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n    *\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    * @param _spender The address which will spend the funds.\n    * @param _value The amount of tokens to be spent.\n    */\n    function approve(address _spender, uint256 _value) public returns (bool) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n\n    /**\n    * approve should be called when allowed[_spender] == 0. To increment\n    * allowed value is better to use this function to avoid 2 calls (and wait until\n    * the first transaction is mined)\n    * From MonolithDAO Token.sol\n    */\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n        uint oldValue = allowed[msg.sender][_spender];\n        if (_subtractedValue > oldValue) {\n        allowed[msg.sender][_spender] = 0;\n        } else {\n        allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n        }\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n}\n\ncontract FiCoin is StandardToken, usingOraclize {\n\n    using SafeMath for uint256;\n\n    struct Contributor {\n        address addr;\n        uint256 amount;\n    }\n\n    mapping (bytes32 => Contributor) internal contributors;\n\n    //==========================================================\n    // TOKEN PROPERTIES\n    //==========================================================\n    string public constant name = \"FiCoin\";\n    string public constant symbol = \"FiC\";\n    uint256 public constant decimals = 18;\n    string public version = \"1.0\";\n\n    //==========================================================\n    // STAGE LIMITS PROPERTIES\n    //==========================================================\n    uint256 public saleCap;\n\n    //==========================================================\n    // WALLETS\n    //==========================================================\n    address public FiCoinFundDeposit;\n    address public CoinStorage;\n    address public OwnerAddress;\n\n    //==========================================================\n    // CROWDSALE STAGES\n    //==========================================================\n    bool internal isPreSale = false;\n    bool internal isFirstRound  = false;\n    bool internal isSecondRound = false;\n\n    uint256 public burnedTokens;\n\n    //==========================================================\n    // INTERNAL VARIABLES\n    //==========================================================\n    uint256 internal tokenPriceInCents;\n    uint256 internal buyLimit;\n    uint256 internal totalLocked;\n    uint256 internal startDate;\n    uint256 internal endDate;\n    mapping(address => uint256) internal lockedTokens;\n    mapping(address => uint256) internal buyLimitPerAddress;\n\n    //==========================================================\n    // EVENTS\n    //==========================================================\n    event OraclizeQuery(string description);\n    event Burn(address indexed burner, uint256 value);\n    event TokenPurchase(address indexed purchaser, uint256 value, uint256 amount);\n    event Lock(address indexed purchaser, uint256 value);\n\n    //==========================================================\n    // MODIFIERS\n    //==========================================================\n    modifier onlyOwner() {\n        require(msg.sender == OwnerAddress);\n        _;\n    }\n\n    //==========================================================\n    // CONSTRUCTOR\n    //==========================================================\n    function FiCoin() public {\n\n        FiCoinFundDeposit = 0x00aa6ddfa8ADD5B1E6bCfFcbaB83c3FDBd10DA91;\n        CoinStorage = 0x00aD59ec96C12dA4C4546383fac422fEF45a21bB;\n        OwnerAddress = 0x00aD59ec96C12dA4C4546383fac422fEF45a21bB;\n        \n        totalSupply = 14930352 * 10 ** decimals;\n\n        // crowdsale statistics\n        tokenPriceInCents = 34;\n        buyLimit = 0;\n        saleCap = 0;\n\n        // burned tokens\n        burnedTokens = 0;\n\n        // move the supply the storage\n        balances[CoinStorage] = totalSupply;\n\n        startDate = 0;\n        endDate = 0;\n    }\n\n    //==========================================================\n    // ONLY OWNER FUNCTIONS\n    //==========================================================\n    function forwardFunds() onlyOwner public {\n        FiCoinFundDeposit.transfer(this.balance);\n    }\n\n    //==========================================================\n    // PUBLIC FUNCTIONS\n    //==========================================================\n    function () public payable {\n        buyTokens(msg.sender);\n    }\n\n    // low level token purchase function\n    function buyTokens(address beneficiary) public payable {\n        require(beneficiary != address(0));\n        require(msg.value >= 1 * 10 ** 17); // minimum ETH contribution is 0.1 ETH\n        require(startDate < now && endDate > now);\n        \n        // this functionallity is kept in the same function with purpose.\n        if (oraclize_getPrice(\"URL\") > this.balance) {\n            OraclizeQuery(\"Oraclize query was NOT sent, please add some ETH to cover for the query fee\");\n        } else {\n            OraclizeQuery(\"Oraclize query was sent, standing by for the answer.\");\n            bytes32 queryId = oraclize_query(\"URL\", \"json(https://api.coinmarketcap.com/v1/ticker/ethereum).0.price_usd\");\n            contributors[queryId] = Contributor(beneficiary, msg.value);\n        }\n    }\n    \n    function lockedOf(address _owner) public view returns (uint256 locked) {\n        return lockedTokens[_owner];\n    }\n    \n    function __callback(bytes32 myid, string result, bytes proof) public {\n        require (msg.sender == oraclize_cbAddress());\n\n        uint256 etherPrice = parseInt(result, 2);\n        uint256 purchasedTokens = getPurchasedTokens(contributors[myid].amount, etherPrice);\n    \n        privateTransfer(contributors[myid].addr, purchasedTokens);\n        TokenPurchase(contributors[myid].addr, contributors[myid].amount, purchasedTokens);\n\n        delete contributors[myid];\n    }\n\n\n    //==========================================================\n    // INTERNAL FUNCTIONS\n    //==========================================================\n    function getPurchasedTokens(uint256 _weiAmount, uint256 _etherPrice) internal constant returns (uint256) { \n        require(_etherPrice > 0);\n\n        //Formula:\n        //( weiAmount * etherPrice (cents) ) / ( tokenPrice (cents) )\n        uint256 purchasedTokens = _weiAmount.mul(_etherPrice);\n        purchasedTokens = purchasedTokens.div(tokenPriceInCents);\n\n        return purchasedTokens;\n    }\n\n    function privateTransfer(address _to, uint256 _value) internal returns (bool) {\n        require(_to != address(0));\n        require(_value <= balances[CoinStorage]);\n        // check that sold tokens + purchase value + totalLocked is less than the saleCap\n        require(totalSupply - balances[CoinStorage] + _value + totalLocked <= saleCap);\n        // check that user's locked tokens + purchase value is less than the purchase limit\n        require(buyLimitPerAddress[_to] + lockedTokens[_to] + _value <= buyLimit); \n\n        // SafeMath.sub will throw if there is not enough balance.\n        balances[CoinStorage] = balances[CoinStorage].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        //===================================================================\n        buyLimitPerAddress[_to] = buyLimitPerAddress[_to].add(_value);\n        //===================================================================\n        Transfer(CoinStorage, _to, _value);\n        return true;\n    }\n\n    // Add to totalLocked\n    // Substract from owner's balance\n    // Init mapping.\n    function lock(address _to, uint256 _value) onlyOwner public {\n        require(_to != address(0));\n        require(_value <= balances[CoinStorage]);\n        // check that sold tokens + purchase value + totalLocked is less than the saleCap\n        require(totalSupply - balances[CoinStorage] + _value + totalLocked <= saleCap);\n        // check that user's locked tokens + purchase value is less than the purchase limit\n        require(buyLimitPerAddress[_to] + lockedTokens[_to] + _value <= buyLimit);\n        \n        totalLocked = totalLocked + _value;\n        balances[CoinStorage] = balances[CoinStorage].sub(_value);\n        lockedTokens[_to] = _value;\n    }\n\n    // Unlock tokens\n    // Transfer tokens\n    function pay(address _to, uint256 _value) onlyOwner public {\n        unlock(_to);\n        privateTransfer(_to, _value);\n    }\n\n    // Substract from totalLocked\n    // Add the locked tokens to the owner's balance\n    // Delete mapping element\n    function unlock(address _to) onlyOwner public {\n        require(_to != address(0));\n        require(lockedTokens[_to] > 0);\n\n        totalLocked = totalLocked.sub(lockedTokens[_to]);\n        balances[CoinStorage] = balances[CoinStorage].add(lockedTokens[_to]);\n        delete lockedTokens[_to];\n    }\n\n\n    //==========================================================\n    // EXTERNAL FUNCTIONS\n    //==========================================================\n    function switchSaleStage() onlyOwner public {\n        require(!isSecondRound);\n\n        if (!isPreSale) {\n            isPreSale = true;\n            tokenPriceInCents = 34;\n            buyLimit = 5000 * 10 ** decimals;\n            saleCap = 2178309 * 10 ** decimals;\n        } else if (!isFirstRound) {\n            isFirstRound = true;\n            tokenPriceInCents = 55;\n            buyLimit = buyLimit + 10000 * 10 ** decimals;\n            saleCap = totalSupply - balances[CoinStorage] + 3524578 * 10 ** decimals;\n        } else if (!isSecondRound) {\n            isSecondRound = true;\n            tokenPriceInCents = 89;\n            buyLimit = buyLimit + 15000 * 10**decimals;\n            saleCap = totalSupply - balances[CoinStorage] + 5702887 * 10 ** decimals;\n        } \n\n        startDate = now + 1 minutes;\n        endDate = startDate + 120 hours;\n    }\n    \n    /**\n     * @dev Burns a specific amount of tokens.\n     * @param _value The amount of token to be burned.\n     */\n    function burn(uint256 _value) public {\n        require(_value > 0);\n        require(_value <= balances[msg.sender]);\n        // no need to require value <= totalSupply, since that would imply the\n        // sender's balance is greater than the totalSupply, which *should* be an assertion failure\n\n        address burner = msg.sender;\n        balances[burner] = balances[burner].sub(_value);\n        totalSupply = totalSupply.sub(_value);\n        burnedTokens = burnedTokens.add(_value);\n        Burn(burner, _value);\n    }\n}",
  "bytecode": "606060405260408051908101604052600381527f312e300000000000000000000000000000000000000000000000000000000000602082015260099080516200004d9291602001906200010a565b50600d805460a060020a62ffffff021916905534156200006c57600080fd5b600b805472aa6ddfa8add5b1e6bcffcbab83c3fdbd10da91600160a060020a031991821617909155600c805472ad59ec96c12da4c4546383fac422fef45a21bb908316811791829055600d8054909316179091556a0c59a000f3b4d7b8c0000060008181556022600f556010819055600a819055600e819055600160a060020a039092168252600160205260408220556012819055601355620001af565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f106200014d57805160ff19168380011785556200017d565b828001600101855582156200017d579182015b828111156200017d57825182559160200191906001019062000160565b506200018b9291506200018f565b5090565b620001ac91905b808211156200018b576000815560010162000196565b90565b61246e80620001bf6000396000f3006060604052600436106101445763ffffffff60e060020a600035041662a051ca811461014f57806306fdde031461017e578063078fd9ea14610208578063095ea7b31461022d57806318160ddd1461026357806323b872dd14610276578063279a34f11461029e57806327dc297e146102b1578063282d3fdf146103075780632f6c493c14610329578063313ce5671461034857806338bbfa501461035b57806342966c68146103f357806347b5dd541461040957806354fd4d501461041c578063661884631461042f57806370a08231146104515780637f17b05d1461047057806395d89b41146104835780639d73528614610496578063a5f1e282146104a9578063a9059cbb146104c8578063c4076876146104ea578063d73dd6231461050c578063dd62ed3e1461052e578063e4a6e85a14610553578063ec8ac4d814610566575b61014d33610576565b005b341561015a57600080fd5b61016261086b565b604051600160a060020a03909116815260200160405180910390f35b341561018957600080fd5b61019161087a565b60405160208082528190810183818151815260200191508051906020019080838360005b838110156101cd5780820151838201526020016101b5565b50505050905090810190601f1680156101fa5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b341561021357600080fd5b61021b6108b1565b60405190815260200160405180910390f35b341561023857600080fd5b61024f600160a060020a03600435166024356108b7565b604051901515815260200160405180910390f35b341561026e57600080fd5b61021b610923565b341561028157600080fd5b61024f600160a060020a0360043581169060243516604435610929565b34156102a957600080fd5b61014d610aab565b34156102bc57600080fd5b61014d600480359060446024803590810190830135806020601f82018190048102016040519081016040528181529291906020840183838082843750949650610ccd95505050505050565b341561031257600080fd5b61014d600160a060020a0360043516602435610cfb565b341561033457600080fd5b61014d600160a060020a0360043516610e21565b341561035357600080fd5b61021b610f11565b341561036657600080fd5b61014d600480359060446024803590810190830135806020601f8201819004810201604051908101604052818152929190602084018383808284378201915050505050509190803590602001908201803590602001908080601f016020809104026020016040519081016040528181529291906020840183838082843750949650610f1695505050505050565b34156103fe57600080fd5b61014d600435611014565b341561041457600080fd5b61021b6110f3565b341561042757600080fd5b6101916110f9565b341561043a57600080fd5b61024f600160a060020a0360043516602435611197565b341561045c57600080fd5b61021b600160a060020a0360043516611293565b341561047b57600080fd5b6101626112ae565b341561048e57600080fd5b6101916112bd565b34156104a157600080fd5b61014d6112f4565b34156104b457600080fd5b61021b600160a060020a036004351661134a565b34156104d357600080fd5b61024f600160a060020a0360043516602435611365565b34156104f557600080fd5b61014d600160a060020a0360043516602435611460565b341561051757600080fd5b61024f600160a060020a0360043516602435611493565b341561053957600080fd5b61021b600160a060020a0360043581169060243516611537565b341561055e57600080fd5b610162611562565b61014d600160a060020a03600435165b6000600160a060020a038216151561058d57600080fd5b67016345785d8a00003410156105a257600080fd5b426012541080156105b4575042601354115b15156105bf57600080fd5b30600160a060020a03163161060660408051908101604052600381527f55524c00000000000000000000000000000000000000000000000000000000006020820152611571565b11156106c2577fd7789a3deb1d0944b7966c5d18037fc5b3a0a17236de9e7c20fe3a63451672956040516020808252604b908201527f4f7261636c697a6520717565727920776173204e4f542073656e742c20706c656040808301919091527f6173652061646420736f6d652045544820746f20636f76657220666f7220746860608301527f6520717565727920666565000000000000000000000000000000000000000000608083015260a0909101905180910390a1610867565b7fd7789a3deb1d0944b7966c5d18037fc5b3a0a17236de9e7c20fe3a634516729560405160208082526034908201527f4f7261636c697a65207175657279207761732073656e742c207374616e64696e6040808301919091527f6720627920666f722074686520616e737765722e00000000000000000000000060608301526080909101905180910390a161080e6040805190810160405280600381526020017f55524c0000000000000000000000000000000000000000000000000000000000815250608060405190810160405280604281526020017f6a736f6e2868747470733a2f2f6170692e636f696e6d61726b65746361702e6381526020017f6f6d2f76312f7469636b65722f657468657265756d292e302e70726963655f7581526020017f736400000000000000000000000000000000000000000000000000000000000081525061177f565b9050604080519081016040908152600160a060020a038416825234602080840191909152600084815260089091522081518154600160a060020a031916600160a060020a03919091161781556020820151600190910155505b5050565b600b54600160a060020a031681565b60408051908101604052600681527f4669436f696e0000000000000000000000000000000000000000000000000000602082015281565b600a5481565b600160a060020a03338116600081815260026020908152604080832094871680845294909152808220859055909291907f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b9259085905190815260200160405180910390a350600192915050565b60005481565b6000600160a060020a038316151561094057600080fd5b600160a060020a03841660009081526001602052604090205482111561096557600080fd5b600160a060020a038085166000908152600260209081526040808320339094168352929052205482111561099857600080fd5b600160a060020a0384166000908152600160205260409020546109c1908363ffffffff611af516565b600160a060020a0380861660009081526001602052604080822093909355908516815220546109f6908363ffffffff611b0716565b600160a060020a03808516600090815260016020908152604080832094909455878316825260028152838220339093168252919091522054610a3e908363ffffffff611af516565b600160a060020a03808616600081815260026020908152604080832033861684529091529081902093909355908516917fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef9085905190815260200160405180910390a35060019392505050565b600d5433600160a060020a03908116911614610ac657600080fd5b600d54760100000000000000000000000000000000000000000000900460ff1615610af057600080fd5b600d5474010000000000000000000000000000000000000000900460ff161515610b7057600d805474ff00000000000000000000000000000000000000001916740100000000000000000000000000000000000000001790556022600f5569010f0cf064dd592000006010556a01cd465e14f44918f40000600a55610cbb565b600d547501000000000000000000000000000000000000000000900460ff161515610c1657600d805475ff000000000000000000000000000000000000000000191675010000000000000000000000000000000000000000001790556037600f556010805469021e19e0c9bab2400000019055600c54600160a060020a03166000908152600160205260408120549054036a02ea5bc198996c8248000001600a55610cbb565b600d54760100000000000000000000000000000000000000000000900460ff161515610cbb57600d805476ff0000000000000000000000000000000000000000000019167601000000000000000000000000000000000000000000001790556059600f556010805469032d26d12e980b600000019055600c54600160a060020a03166000908152600160205260408120549054036a04b7a21fad8db59b3c000001600a555b42603c8101601255620697bc01601355565b61086782826000604051805910610ce15750595b818152601f19601f83011681016020016040529050610f16565b600d5433600160a060020a03908116911614610d1657600080fd5b600160a060020a0382161515610d2b57600080fd5b600c54600160a060020a0316600090815260016020526040902054811115610d5257600080fd5b600a54601154600c54600160a060020a03166000908152600160205260408120549054038301011115610d8457600080fd5b601054600160a060020a0383166000908152601460209081526040808320546015909252909120540182011115610dba57600080fd5b6011805482019055600c54600160a060020a0316600090815260016020526040902054610ded908263ffffffff611af516565b600c54600160a060020a03908116600090815260016020908152604080832094909455949091168152601490935290912055565b600d5433600160a060020a03908116911614610e3c57600080fd5b600160a060020a0381161515610e5157600080fd5b600160a060020a03811660009081526014602052604081205411610e7457600080fd5b600160a060020a038116600090815260146020526040902054601154610e9f9163ffffffff611af516565b601155600160a060020a03808216600090815260146020908152604080832054600c5490941683526001909152902054610ede9163ffffffff611b0716565b600c54600160a060020a039081166000908152600160209081526040808320949094559390911681526014909252812055565b601281565b600080610f21611b1d565b600160a060020a031633600160a060020a0316141515610f4057600080fd5b610f4b846002611cbe565b600086815260086020526040902060010154909250610f6a9083611e2c565b600086815260086020526040902054909150610f8f90600160a060020a031682611e6a565b50600085815260086020526040908190208054600190910154600160a060020a03909116917fcd60aa75dea3072fbc07ae6d7d856b5dc5f4eee88854f5b4abf7b680ef8bc50f919084905191825260208201526040908101905180910390a25050506000918252506008602052604081208054600160a060020a031916815560010155565b600080821161102257600080fd5b600160a060020a03331660009081526001602052604090205482111561104757600080fd5b5033600160a060020a03811660009081526001602052604090205461106c9083611af5565b600160a060020a03821660009081526001602052604081209190915554611099908363ffffffff611af516565b600055600e546110af908363ffffffff611b0716565b600e55600160a060020a0381167fcc16f5dbb4873280815c1ee09dbd06736cffcc184412cf7a71a0fdb75d397ca58360405190815260200160405180910390a25050565b600e5481565b60098054600181600116156101000203166002900480601f01602080910402602001604051908101604052809291908181526020018280546001816001161561010002031660029004801561118f5780601f106111645761010080835404028352916020019161118f565b820191906000526020600020905b81548152906001019060200180831161117257829003601f168201915b505050505081565b600160a060020a033381166000908152600260209081526040808320938616835292905290812054808311156111f457600160a060020a03338116600090815260026020908152604080832093881683529290529081205561122b565b611204818463ffffffff611af516565b600160a060020a033381166000908152600260209081526040808320938916835292905220555b600160a060020a0333811660008181526002602090815260408083209489168084529490915290819020547f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925915190815260200160405180910390a3600191505b5092915050565b600160a060020a031660009081526001602052604090205490565b600d54600160a060020a031681565b60408051908101604052600381527f4669430000000000000000000000000000000000000000000000000000000000602082015281565b600d5433600160a060020a0390811691161461130f57600080fd5b600b54600160a060020a039081169030163180156108fc0290604051600060405180830381858888f19350505050151561134857600080fd5b565b600160a060020a031660009081526014602052604090205490565b6000600160a060020a038316151561137c57600080fd5b600160a060020a0333166000908152600160205260409020548211156113a157600080fd5b600160a060020a0333166000908152600160205260409020546113ca908363ffffffff611af516565b600160a060020a0333811660009081526001602052604080822093909355908516815220546113ff908363ffffffff611b0716565b600160a060020a0380851660008181526001602052604090819020939093559133909116907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef9085905190815260200160405180910390a350600192915050565b600d5433600160a060020a0390811691161461147b57600080fd5b61148482610e21565b61148e8282611e6a565b505050565b600160a060020a0333811660009081526002602090815260408083209386168352929052908120546114cb908363ffffffff611b0716565b600160a060020a0333811660008181526002602090815260408083209489168084529490915290819020849055919290917f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92591905190815260200160405180910390a350600192915050565b600160a060020a03918216600090815260026020908152604080832093909416825291909152205490565b600c54600160a060020a031681565b600354600090600160a060020a0316158061159e575060035461159c90600160a060020a031661200b565b155b156115af576115ad600061200f565b505b600354600160a060020a03166338cc48316000604051602001526040518163ffffffff1660e060020a028152600401602060405180830381600087803b15156115f757600080fd5b6102c65a03f1151561160857600080fd5b5050506040518051600454600160a060020a0390811691161490506116aa57600354600160a060020a03166338cc48316000604051602001526040518163ffffffff1660e060020a028152600401602060405180830381600087803b151561166f57600080fd5b6102c65a03f1151561168057600080fd5b505050604051805160048054600160a060020a031916600160a060020a0392909216919091179055505b600454600160a060020a031663524f3889836000604051602001526040518263ffffffff1660e060020a0281526004018080602001828103825283818151815260200191508051906020019080838360005b838110156117145780820151838201526020016116fc565b50505050905090810190601f1680156117415780820380516001836020036101000a031916815260200191505b5092505050602060405180830381600087803b151561175f57600080fd5b6102c65a03f1151561177057600080fd5b50505060405180519392505050565b6003546000908190600160a060020a031615806117ae57506003546117ac90600160a060020a031661200b565b155b156117bf576117bd600061200f565b505b600354600160a060020a03166338cc48316000604051602001526040518163ffffffff1660e060020a028152600401602060405180830381600087803b151561180757600080fd5b6102c65a03f1151561181857600080fd5b5050506040518051600454600160a060020a0390811691161490506118ba57600354600160a060020a03166338cc48316000604051602001526040518163ffffffff1660e060020a028152600401602060405180830381600087803b151561187f57600080fd5b6102c65a03f1151561189057600080fd5b505050604051805160048054600160a060020a031916600160a060020a0392909216919091179055505b600454600160a060020a031663524f3889856000604051602001526040518263ffffffff1660e060020a0281526004018080602001828103825283818151815260200191508051906020019080838360005b8381101561192457808201518382015260200161190c565b50505050905090810190601f1680156119515780820380516001836020036101000a031916815260200191505b5092505050602060405180830381600087803b151561196f57600080fd5b6102c65a03f1151561198057600080fd5b5050506040518051915050670de0b6b3a764000062030d403a02018111156119ab576000915061128c565b600454600160a060020a031663adf59f99826000878782604051602001526040518563ffffffff1660e060020a028152600401808481526020018060200180602001838103835285818151815260200191508051906020019080838360005b83811015611a22578082015183820152602001611a0a565b50505050905090810190601f168015611a4f5780820380516001836020036101000a031916815260200191505b50838103825284818151815260200191508051906020019080838360005b83811015611a85578082015183820152602001611a6d565b50505050905090810190601f168015611ab25780820380516001836020036101000a031916815260200191505b50955050505050506020604051808303818588803b1515611ad257600080fd5b6125ee5a03f11515611ae357600080fd5b50505050604051805195945050505050565b600082821115611b0157fe5b50900390565b600082820183811015611b1657fe5b9392505050565b600354600090600160a060020a03161580611b4a5750600354611b4890600160a060020a031661200b565b155b15611b5b57611b59600061200f565b505b600354600160a060020a03166338cc48316000604051602001526040518163ffffffff1660e060020a028152600401602060405180830381600087803b1515611ba357600080fd5b6102c65a03f11515611bb457600080fd5b5050506040518051600454600160a060020a039081169116149050611c5657600354600160a060020a03166338cc48316000604051602001526040518163ffffffff1660e060020a028152600401602060405180830381600087803b1515611c1b57600080fd5b6102c65a03f11515611c2c57600080fd5b505050604051805160048054600160a060020a031916600160a060020a0392909216919091179055505b600454600160a060020a031663c281d19e6000604051602001526040518163ffffffff1660e060020a028152600401602060405180830381600087803b1515611c9e57600080fd5b6102c65a03f11515611caf57600080fd5b50505060405180519150505b90565b6000611cc8612398565b5082600080805b8351811015611e0f577f3000000000000000000000000000000000000000000000000000000000000000848281518110611d0557fe5b016020015160f860020a900460f860020a02600160f860020a03191610158015611d7657507f3900000000000000000000000000000000000000000000000000000000000000848281518110611d5757fe5b016020015160f860020a900460f860020a02600160f860020a03191611155b15611dcc578115611d9557851515611d8d57611e0f565b600019909501945b600a830292506030848281518110611da957fe5b016020015160f860020a900460f860020a0260f860020a90040383019250611e07565b838181518110611dd857fe5b016020015160f860020a900460f860020a02600160f860020a031916602e60f860020a021415611e0757600191505b600101611ccf565b6000861115611e215785600a0a830292505b509095945050505050565b600080808311611e3b57600080fd5b611e4b848463ffffffff61201f16565b9050611e62600f548261204a90919063ffffffff16565b949350505050565b6000600160a060020a0383161515611e8157600080fd5b600c54600160a060020a0316600090815260016020526040902054821115611ea857600080fd5b600a54601154600c54600160a060020a03166000908152600160205260408120549054038401011115611eda57600080fd5b601054600160a060020a0384166000908152601460209081526040808320546015909252909120540183011115611f1057600080fd5b600c54600160a060020a0316600090815260016020526040902054611f3b908363ffffffff611af516565b600c54600160a060020a039081166000908152600160205260408082209390935590851681522054611f73908363ffffffff611b0716565b600160a060020a038416600090815260016020908152604080832093909355601590522054611fa8908363ffffffff611b0716565b600160a060020a038085166000818152601560205260409081902093909355600c5490929116907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef9085905190815260200160405180910390a350600192915050565b3b90565b6000612019612061565b92915050565b600080831515612032576000915061128c565b5082820282848281151561204257fe5b0414611b1657fe5b600080828481151561205857fe5b04949350505050565b600080612081731d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed61200b565b11156120f15760038054600160a060020a031916731d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed1790556120e960408051908101604052600b81527f6574685f6d61696e6e65740000000000000000000000000000000000000000006020820152612385565b506001611cbb565b600061211073c03a2615d5efaf5f49f60b7bb6583eaec212fdf161200b565b11156121785760038054600160a060020a03191673c03a2615d5efaf5f49f60b7bb6583eaec212fdf11790556120e960408051908101604052600c81527f6574685f726f707374656e3300000000000000000000000000000000000000006020820152612385565b600061219773b7a07bcf2ba2f2703b24c0691b5278999c59ac7e61200b565b11156121ff5760038054600160a060020a03191673b7a07bcf2ba2f2703b24c0691b5278999c59ac7e1790556120e960408051908101604052600981527f6574685f6b6f76616e00000000000000000000000000000000000000000000006020820152612385565b600061221e73146500cfd35b22e4a392fe0adc06de1a1368ed4861200b565b11156122865760038054600160a060020a03191673146500cfd35b22e4a392fe0adc06de1a1368ed481790556120e960408051908101604052600b81527f6574685f72696e6b6562790000000000000000000000000000000000000000006020820152612385565b60006122a5736f485c8bf6fc43ea212e93bbf8ce046c7f1cb47561200b565b11156122d9575060038054600160a060020a031916736f485c8bf6fc43ea212e93bbf8ce046c7f1cb4751790556001611cbb565b60006122f87320e12a1f859b3feae5fb2a0a32c18f5a65555bbf61200b565b111561232c575060038054600160a060020a0319167320e12a1f859b3feae5fb2a0a32c18f5a65555bbf1790556001611cbb565b600061234b7351efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa61200b565b111561237f575060038054600160a060020a0319167351efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa1790556001611cbb565b50600090565b60058180516108679291602001906123aa565b60206040519081016040526000815290565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f106123eb57805160ff1916838001178555612418565b82800160010185558215612418579182015b828111156124185782518255916020019190600101906123fd565b50612424929150612428565b5090565b611cbb91905b80821115612424576000815560010161242e5600a165627a7a72305820c34392be577502526747ca841dac8160664c48afd128c47b1eed3774f898b16b0029"
}