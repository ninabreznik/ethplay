{
  "address": "0x31cf75e0839a79c8914569465b6ce9e3d6fc9959",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "NewUserBonusDistributor",
  "compilerVersion": "v0.4.20+commit.3155dd80",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2018-03-06\n*/\n\n// EtherGen Contract: \n\n// Base Minting Contract\n\ncontract CardMintingFacilitator {\n    CardConfig schema = CardConfig(0x08584271df3d0249c2c06ac1bc1237a1dd30cb9a); \n    EtherGenCore storageContract = EtherGenCore(0x677aa1dc08b9429c595efd4425b2d218cc22fd6e);\n    address public owner = 0x08F4aE96b647B30177cc15B21195960625BA4163;\n    \n    function generateRandomCard(uint32 randomSeed) internal constant returns (uint8[14]) {\n        uint8[14] memory cardDetails;\n       \n        randomSeed = uint32(sha3(block.blockhash(block.number), randomSeed));\n        cardDetails[0] = schema.getType(randomSeed);\n\n        if (cardDetails[0] == uint8(CardConfig.Type.Monster)) {\n            generateRandomMonster(cardDetails, randomSeed);\n        } else {\n            generateRandomSpell(cardDetails, randomSeed);\n        }\n        \n        randomSeed = uint32(sha3(block.blockhash(block.number), randomSeed));\n        if (randomSeed % 200 == 13) { // Lucky number 13\n            cardDetails[12] = 1; // Secret golden attribute\n        }\n        \n        return cardDetails;\n    }\n    \n    function generateRandomMonster(uint8[14] cardDetails, uint32 randomSeed) internal constant {\n        uint24 totalCost;\n        \n        randomSeed = uint32(sha3(block.blockhash(block.number), randomSeed));\n        cardDetails[1] = schema.getRace(randomSeed);\n        totalCost += schema.getCostForRace(cardDetails[1]);\n\n        randomSeed = uint32(sha3(block.blockhash(block.number), randomSeed));\n        cardDetails[2] = schema.getTrait(randomSeed);\n        totalCost += schema.getCostForTrait(cardDetails[2]);\n\n        uint8 newMutation;\n        uint24 newMutationCost;\n        randomSeed = uint32(sha3(block.blockhash(block.number), randomSeed));\n        \n        uint8 numMutations = uint8(randomSeed % 12); // 0 = 0 mutations, 1 = 1 mutation, 2-5 = 2 mutations, 6-11 = 3 mutations \n        if (numMutations > 5) {\n            numMutations = 3;\n        } else if (numMutations > 2) {\n            numMutations = 2;\n        }\n        \n        for (uint8 i = 0; i < numMutations; i++) {\n            randomSeed = uint32(sha3(block.blockhash(block.number), randomSeed));\n            if (bool(randomSeed % 3 == 0)) { // 0: Race; 1-2: Neutral\n                randomSeed = uint32(sha3(block.blockhash(block.number), randomSeed));\n\n                // Horribly add new mutations (rather than looping for a fresh one) this is cheaper\n                (newMutationCost, newMutation) = schema.getMutationForRace(CardConfig.Race(cardDetails[1]), randomSeed);\n                if (totalCost + newMutationCost < 290000) {\n                    if (cardDetails[6] == 0) {\n                        cardDetails[6] = newMutation;\n                        totalCost += newMutationCost;\n                    } else if (cardDetails[6] > 0 && cardDetails[7] == 0 && cardDetails[6] != newMutation) {\n                        cardDetails[7] = newMutation;\n                        totalCost += newMutationCost;\n                    } else if  (cardDetails[6] > 0 && cardDetails[7] > 0 && cardDetails[8] == 0 && cardDetails[6] != newMutation && cardDetails[7] != newMutation) {\n                        cardDetails[8] = newMutation;\n                        totalCost += newMutationCost;\n                    }\n                }\n            } else {\n                randomSeed = uint32(sha3(block.blockhash(block.number), randomSeed));\n\n                // Horribly add new mutations (rather than looping for a fresh one) this is cheaper\n                (newMutationCost, newMutation) = schema.getNeutralMutation(randomSeed);\n                if (totalCost + newMutationCost < 290000) {\n                    if (cardDetails[9] == 0) {\n                        cardDetails[9] = newMutation;\n                        totalCost += newMutationCost;\n                    } else if (cardDetails[9] > 0 && cardDetails[10] == 0 && cardDetails[9] != newMutation) {\n                        cardDetails[10] = newMutation;\n                        totalCost += newMutationCost;\n                    } else if (cardDetails[9] > 0 && cardDetails[10] > 0 && cardDetails[11] == 0 && cardDetails[9] != newMutation && cardDetails[10] != newMutation) {\n                        cardDetails[11] = newMutation;\n                        totalCost += newMutationCost;\n                    }\n                }\n            }\n        }\n\n        // For attack & health distribution\n        randomSeed = uint32(sha3(block.blockhash(block.number), randomSeed));\n        uint24 powerCost = schema.getCostForHealth(1) + uint24(randomSeed % (301000 - (totalCost + schema.getCostForHealth(1)))); // % upto 300999 will allow 30 cost cards\n\n        if (totalCost + powerCost < 100000) { // Cards should cost at least 10 crystals (10*10000 exponant)\n            powerCost = 100000 - totalCost;\n        }\n        \n        randomSeed = uint32(sha3(block.blockhash(block.number), randomSeed));\n        cardDetails[5] = 1 + uint8(schema.getHealthForCost(randomSeed % powerCost)); // should be (1 + powerCost - schema.getCostForHealth(1))\n        totalCost += schema.getCostForHealth(cardDetails[5]);\n        \n        powerCost = powerCost - schema.getCostForHealth(cardDetails[5]); // Power left for attack\n        cardDetails[4] = uint8(schema.getAttackForCost(powerCost));\n        totalCost += schema.getCostForAttack(cardDetails[4]);\n       \n        // Remove exponent to get total card cost [10-30]\n        cardDetails[3] = uint8(totalCost / 10000);\n    }\n    \n    \n    function generateRandomSpell(uint8[14] cardDetails, uint32 randomSeed) internal constant {\n        uint24 totalCost;\n        \n        uint8 newAbility;\n        uint24 newAbilityCost;\n        randomSeed = uint32(sha3(block.blockhash(block.number), randomSeed));\n        \n        uint8 numAbilities = uint8(randomSeed % 16); // 0 = 1 ability, 1-8 = 2 abilities, 9-15 = 3 abilities \n        if (numAbilities > 8) {\n            numAbilities = 3;\n        } else if (numAbilities > 0) {\n            numAbilities = 2;\n        } else {\n            numAbilities = 1;\n        }\n        \n        for (uint8 i = 0; i < numAbilities; i++) {\n            randomSeed = uint32(sha3(block.blockhash(block.number), randomSeed));\n\n            // Horribly add new spell abilities (rather than looping for a fresh one) this is cheaper\n            (newAbilityCost, newAbility) = schema.getSpellAbility(randomSeed);\n            if (totalCost + newAbilityCost <= 300000) {\n                if (cardDetails[9] == 0) {\n                    cardDetails[9] = newAbility;\n                    totalCost += newAbilityCost;\n                } else if (cardDetails[9] > 0 && cardDetails[10] == 0 && cardDetails[9] != newAbility) {\n                    cardDetails[10] = newAbility;\n                    totalCost += newAbilityCost;\n                } else if (cardDetails[9] > 0 && cardDetails[10] > 0 && cardDetails[11] == 0 && cardDetails[9] != newAbility && cardDetails[10] != newAbility) {\n                    cardDetails[11] = newAbility;\n                    totalCost += newAbilityCost;\n                }\n            }\n        }\n        \n        // Remove exponent to get total card cost [10-30]\n        cardDetails[3] = uint8(totalCost / 10000);\n    }\n    \n    \n    function generateCostFromAttributes(uint8[14] cardDetails) internal constant returns (uint8 cost) {\n        uint24 exponentCost = 0;\n        if (cardDetails[0] == 1) { // Spell\n            exponentCost += schema.getSpellAbilityCost(cardDetails[9]);\n            exponentCost += schema.getSpellAbilityCost(cardDetails[10]);\n            exponentCost += schema.getSpellAbilityCost(cardDetails[11]);\n        } else {\n            exponentCost += schema.getCostForRace(cardDetails[1]);\n            exponentCost += schema.getCostForTrait(cardDetails[2]);\n            exponentCost += schema.getCostForAttack(cardDetails[4]);\n            exponentCost += schema.getCostForHealth(cardDetails[5]);\n            exponentCost += schema.getRaceMutationCost(CardConfig.Race(cardDetails[1]), cardDetails[6]);\n            exponentCost += schema.getRaceMutationCost(CardConfig.Race(cardDetails[1]), cardDetails[7]);\n            exponentCost += schema.getRaceMutationCost(CardConfig.Race(cardDetails[1]), cardDetails[8]);\n            exponentCost += schema.getNeutralMutationCost(cardDetails[9]);\n            exponentCost += schema.getNeutralMutationCost(cardDetails[10]);\n            exponentCost += schema.getNeutralMutationCost(cardDetails[11]);\n        }\n        return uint8(exponentCost / 10000); // Everything is factor 10000 for ease of autonomous Workshop cost-tuning\n    }\n    \n    // Allows future extensibility (New card mutations + Workshop updates)\n    function upgradeCardConfig(address newCardConfig) external {\n        require(msg.sender == owner);\n        schema = CardConfig(newCardConfig);\n    }\n    \n    function updateStorageContract(address newStorage) external {\n        require(msg.sender == owner);\n        storageContract = EtherGenCore(newStorage);\n    }\n    \n    function updateOwner(address newOwner) external {\n        require(msg.sender == owner);\n        owner = newOwner;\n    }\n}\n\n\n\n\n\n\n//// Card Promotion + Referrals\n\ncontract NewUserBonusDistributor is CardMintingFacilitator {\n    mapping(address => bool) private claimedAddresses; // You only get one free card for 'signing up'\n    bool public newUserBonusCardTradable = true; // If people abuse new user bonus they will be made untradable (but unlocked via battle)\n    \n    address[] public referals; // Array to store all unpaid referal cards\n    \n    function claimFreeFirstCard(address referer) external {\n        require(!claimedAddresses[msg.sender]);\n        \n        uint8[14] memory newCard = generateRandomCard(uint32(msg.sender));\n        if (!newUserBonusCardTradable) {\n            newCard[13] = 1;\n        }\n        claimedAddresses[msg.sender] = true;\n        storageContract.mintCard(msg.sender, newCard);\n        allocateReferalBonus(referer);\n    }\n    \n    function hasAlreadyClaimed() external constant returns (bool) {\n        return claimedAddresses[msg.sender];\n    }\n    \n    function allocateReferalBonus(address referer) internal {\n        // To save new players gas, referals will be async and payed out manually by our team\n        if (referer != address(0) && referer != msg.sender) {\n            referals.push(referer);\n            referals.push(msg.sender);\n        }\n    }\n    \n    function awardReferalBonus() external {\n        // To save new players gas, referals are payed out below manually (by our team + kind gas donors)\n        require(referals.length > 0);\n        address recipient = referals[referals.length - 1];\n        uint8[14] memory newCard = generateRandomCard(uint32(storageContract.totalSupply() * now));\n        newCard[13] = 1; // Referal cards untradable to prevent abuse (unlocked via battle)\n        \n        delete referals[referals.length - 1];\n        referals.length--;\n        storageContract.mintCard(recipient, newCard);\n    }\n    \n    function setNewUserBonusCardTradable(bool tradable) external {\n        require(msg.sender == owner);\n        newUserBonusCardTradable = tradable;\n    }\n    \n}\n\n\n\n\n\n\n\n\n\n\n// Interface for contracts conforming to ERC-721: Non-Fungible Tokens\ncontract ERC721 {\n\n    // Required methods\n    function totalSupply() public view returns (uint256 cards);\n    function balanceOf(address player) public view returns (uint256 balance);\n    function ownerOf(uint256 cardId) external view returns (address owner);\n    function approve(address to, uint256 cardId) external;\n    function transfer(address to, uint256 cardId) external;\n    function transferFrom(address from, address to, uint256 cardId) external;\n\n    // Events\n    event Transfer(address from, address to, uint256 cardId);\n    event Approval(address owner, address approved, uint256 cardId);\n\n    // Name and symbol of the non fungible token, as defined in ERC721.\n    string public constant name = \"EtherGen\";\n    string public constant symbol = \"ETG\";\n\n    // Optional methods\n    function tokensOfOwner(address player) external view returns (uint64[] cardIds);\n}\n\n\n// Base Storage for EtherGen\ncontract PlayersCollectionStorage {\n    \n    mapping(address => PlayersCollection) internal playersCollections;\n    mapping(uint64 => Card) internal cardIdMapping;\n\n    struct PlayersCollection {\n        uint64[] cardIds;\n        bool referalCardsUnlocked;\n    }\n\n    struct Card {\n        uint64 id;\n        uint64 collectionPointer; // Index in player's collection\n        address owner;\n        \n        uint8 cardType;\n        uint8 race;\n        uint8 trait;\n\n        uint8 cost; // [10-30]\n        uint8 attack; // [0-99]\n        uint8 health; // [1-99]\n\n        uint8 raceMutation0; // Super ugly but dynamic length arrays are currently a no-go across contracts\n        uint8 raceMutation1; // + very expensive gas since cards are in nested structs (collection of cards)\n        uint8 raceMutation2;\n\n        uint8 neutralMutation0;\n        uint8 neutralMutation1;\n        uint8 neutralMutation2;\n\n        /**\n         * Initally referal (free) cards will be untradable (to stop abuse) however EtherGenCore has\n         * unlockUntradeableCards() to make them tradeable -triggered once player hits certain battle/game milestone\n         */\n        bool isReferalReward;\n        bool isGolden; // Top secret Q2 animated art\n    }\n    \n    function getPlayersCollection(address player) public constant returns (uint64[], uint8[14][]) {\n        uint8[14][] memory cardDetails = new uint8[14][](playersCollections[player].cardIds.length);\n        uint64[] memory cardIds = new uint64[](playersCollections[player].cardIds.length);\n\n        for (uint32 i = 0; i < playersCollections[player].cardIds.length; i++) {\n            Card memory card = cardIdMapping[playersCollections[player].cardIds[i]];\n            cardDetails[i][0] = card.cardType;\n            cardDetails[i][1] = card.race;\n            cardDetails[i][2] = card.trait;\n            cardDetails[i][3] = card.cost;\n            cardDetails[i][4] = card.attack;\n            cardDetails[i][5] = card.health;\n            cardDetails[i][6] = card.raceMutation0;\n            cardDetails[i][7] = card.raceMutation1;\n            cardDetails[i][8] = card.raceMutation2;\n            cardDetails[i][9] = card.neutralMutation0;\n            cardDetails[i][10] = card.neutralMutation1;\n            cardDetails[i][11] = card.neutralMutation2;\n\n            cardDetails[i][12] = card.isGolden ? 1 : 0; // Not ideal but web3.js didn't like returning multiple 2d arrays\n            cardDetails[i][13] = isCardTradeable(card) ? 1 : 0;\n            \n            cardIds[i] = card.id;\n        }\n        return (cardIds, cardDetails);\n    }\n    \n    function getCard(uint64 cardId) public constant returns (uint8[14]) {\n        Card memory card = cardIdMapping[cardId];\n        return ([card.cardType, card.race, card.trait, card.cost, card.attack, card.health,\n                 card.raceMutation0, card.raceMutation1, card.raceMutation2,\n                 card.neutralMutation0, card.neutralMutation1, card.neutralMutation2,\n                 card.isGolden ? 1 : 0, \n                 isCardTradeable(card) ? 1 : 0]);\n    }\n    \n    function isCardTradeable(Card card) internal constant returns(bool) {\n        return (playersCollections[card.owner].referalCardsUnlocked || !card.isReferalReward);\n    }\n    \n    function isCardTradeable(uint64 cardId) external constant returns(bool) {\n        return isCardTradeable(cardIdMapping[cardId]);\n    }\n}\n\n\n\n// Extensibility of storage + ERCness\ncontract EtherGenCore is PlayersCollectionStorage, ERC721 {\n    \n    mapping(address => bool) private privilegedTransferModules; // Marketplace ( + future features)\n    mapping(address => bool) private privilegedMintingModules; // Referals, Fusing, Workshop etc. ( + future features)\n    \n    mapping(uint64 => address) private cardIdApproveds; // Approval list (ERC721 transfers)\n    uint64 private totalCardSupply; // Also used for cardId incrementation\n    \n    TransferRestrictionVerifier transferRestrictionVerifier = TransferRestrictionVerifier(0xd9861d9a6111bfbb9235a71151f654d0fe7ed954); \n    address public owner = 0x08F4aE96b647B30177cc15B21195960625BA4163;\n    bool public paused = false;\n    \n    function totalSupply() public view returns (uint256 cards) {\n        return totalCardSupply;\n    }\n    \n    function ownerOf(uint256 cardId) external view returns (address cardOwner) {\n        return cardIdMapping[uint64(cardId)].owner;\n    }\n    \n    function balanceOf(address player) public view returns (uint256 balance) {\n        return playersCollections[player].cardIds.length;\n    }\n    \n    function tokensOfOwner(address player) external view returns (uint64[] cardIds) {\n        return playersCollections[player].cardIds;\n    }\n    \n    function transfer(address newOwner, uint256 cardId) external {\n        uint64 castCardId = uint64(cardId);\n        require(cardIdMapping[castCardId].owner == msg.sender);\n        require(isCardTradeable(cardIdMapping[castCardId]));\n        require(transferRestrictionVerifier.isAvailableForTransfer(castCardId));\n        require(!paused);\n        \n        removeCardOwner(castCardId);\n        assignCardOwner(newOwner, castCardId);\n        Transfer(msg.sender, newOwner, castCardId); // Emit Event\n    }\n    \n    function transferFrom(address currentOwner, address newOwner, uint256 cardId) external {\n        uint64 castCardId = uint64(cardId);\n        require(cardIdMapping[castCardId].owner == currentOwner);\n        require(isApprovedTransferer(msg.sender, castCardId));\n        require(isCardTradeable(cardIdMapping[castCardId]));\n        require(transferRestrictionVerifier.isAvailableForTransfer(castCardId));\n        require(!paused);\n        \n        removeCardOwner(castCardId);\n        assignCardOwner(newOwner, castCardId);\n        Transfer(currentOwner, newOwner, castCardId); // Emit Event\n    }\n    \n    function approve(address approved, uint256 cardId) external {\n        uint64 castCardId = uint64(cardId);\n        require(cardIdMapping[castCardId].owner == msg.sender);\n        \n        cardIdApproveds[castCardId] = approved; // Register approval (replacing previous)\n        Approval(msg.sender, approved, castCardId); // Emit Event\n    }\n    \n    function isApprovedTransferer(address approvee, uint64 cardId) internal constant returns (bool) {\n        // Will only return true if approvee (msg.sender) is a privileged transfer address (Marketplace) or santioned by card's owner using ERC721's approve()\n        return privilegedTransferModules[approvee] || cardIdApproveds[cardId] == approvee;\n    }\n    \n    function removeCardOwner(uint64 cardId) internal {\n        address cardOwner = cardIdMapping[cardId].owner;\n\n        if (playersCollections[cardOwner].cardIds.length > 1) {\n            uint64 rowToDelete = cardIdMapping[cardId].collectionPointer;\n            uint64 cardIdToMove = playersCollections[cardOwner].cardIds[playersCollections[cardOwner].cardIds.length - 1];\n            playersCollections[cardOwner].cardIds[rowToDelete] = cardIdToMove;\n            cardIdMapping[cardIdToMove].collectionPointer = rowToDelete;\n        }\n        \n        playersCollections[cardOwner].cardIds.length--;\n        cardIdMapping[cardId].owner = 0;\n    }\n    \n    function assignCardOwner(address newOwner, uint64 cardId) internal {\n        if (newOwner != address(0)) {\n            cardIdMapping[cardId].owner = newOwner;\n            cardIdMapping[cardId].collectionPointer = uint64(playersCollections[newOwner].cardIds.push(cardId) - 1);\n        }\n    }\n    \n    function mintCard(address recipient, uint8[14] cardDetails) external {\n        require(privilegedMintingModules[msg.sender]);\n        require(!paused);\n        \n        Card memory card;\n        card.owner = recipient;\n        \n        card.cardType = cardDetails[0];\n        card.race = cardDetails[1];\n        card.trait = cardDetails[2];\n        card.cost = cardDetails[3];\n        card.attack = cardDetails[4];\n        card.health = cardDetails[5];\n        card.raceMutation0 = cardDetails[6];\n        card.raceMutation1 = cardDetails[7];\n        card.raceMutation2 = cardDetails[8];\n        card.neutralMutation0 = cardDetails[9];\n        card.neutralMutation1 = cardDetails[10];\n        card.neutralMutation2 = cardDetails[11];\n        card.isGolden = cardDetails[12] == 1;\n        card.isReferalReward = cardDetails[13] == 1;\n        \n        card.id = totalCardSupply;\n        totalCardSupply++;\n\n        cardIdMapping[card.id] = card;\n        cardIdMapping[card.id].collectionPointer = uint64(playersCollections[recipient].cardIds.push(card.id) - 1);\n    }\n    \n    // Management functions to facilitate future contract extensibility, unlocking of (untradable) referal bonus cards and contract ownership\n    \n    function unlockUntradeableCards(address player) external {\n        require(privilegedTransferModules[msg.sender]);\n        playersCollections[player].referalCardsUnlocked = true;\n    }\n    \n    function manageApprovedTransferModule(address moduleAddress, bool isApproved) external {\n        require(msg.sender == owner);\n        privilegedTransferModules[moduleAddress] = isApproved; \n    }\n    \n     function manageApprovedMintingModule(address moduleAddress, bool isApproved) external {\n        require(msg.sender == owner);\n        privilegedMintingModules[moduleAddress] = isApproved; \n    }\n    \n    function updateTransferRestrictionVerifier(address newTransferRestrictionVerifier) external {\n        require(msg.sender == owner);\n        transferRestrictionVerifier = TransferRestrictionVerifier(newTransferRestrictionVerifier);\n    }\n    \n    function setPaused(bool shouldPause) external {\n        require(msg.sender == owner);\n        paused = shouldPause;\n    }\n    \n    function updateOwner(address newOwner) external {\n        require(msg.sender == owner);\n        owner = newOwner;\n    }\n    \n}\n\n\n\n\ncontract CardConfig {\n    enum Type {Monster, Spell} // More could come!\n\n    enum Race {Dragon, Spiderling, Demon, Humanoid, Beast, Undead, Elemental, Vampire, Serpent, Mech, Golem, Parasite}\n    uint16 constant numRaces = 12;\n\n    enum Trait {Normal, Fire, Poison, Lightning, Ice, Divine, Shadow, Arcane, Cursed, Void}\n    uint16 constant numTraits = 10;\n\n    function getType(uint32 randomSeed) public constant returns (uint8) {\n        if (randomSeed % 5 > 0) { // 80% chance for monster (spells are less fun so make up for it in rarity)\n            return uint8(Type.Monster);\n        } else {\n            return uint8(Type.Spell);\n        }\n    }\n    \n    function getRace(uint32 randomSeed) public constant returns (uint8) {\n        return uint8(Race(randomSeed % numRaces));\n    }\n\n    function getTrait(uint32 randomSeed) public constant returns (uint8) {\n        return uint8(Trait(randomSeed % numTraits));\n    }\n\n    SpellAbilities spellAbilities = new SpellAbilities();\n    SharedNeutralMutations neutralMutations = new SharedNeutralMutations();\n    DragonMutations dragonMutations = new DragonMutations();\n    SpiderlingMutations spiderlingMutations = new SpiderlingMutations();\n    DemonMutations demonMutations = new DemonMutations();\n    HumanoidMutations humanoidMutations = new HumanoidMutations();\n    BeastMutations beastMutations = new BeastMutations();\n    UndeadMutations undeadMutations = new UndeadMutations();\n    ElementalMutations elementalMutations = new ElementalMutations();\n    VampireMutations vampireMutations = new VampireMutations();\n    SerpentMutations serpentMutations = new SerpentMutations();\n    MechMutations mechMutations = new MechMutations();\n    GolemMutations golemMutations = new GolemMutations();\n    ParasiteMutations parasiteMutations = new ParasiteMutations();\n    \n\n    // The powerful schema that will allow the Workshop (crystal) prices to fluctuate based on performance, keeping the game fresh & evolve over time!\n    \n    function getCostForRace(uint8 race) public constant returns (uint8 cost) {\n        return 0; // born equal (under current config)\n    }\n    \n    function getCostForTrait(uint8 trait) public constant returns (uint24 cost) {\n        if (trait == uint8(CardConfig.Trait.Normal)) {\n            return 0;\n        }\n        return 40000;\n    }\n    \n    function getSpellAbility(uint32 randomSeed) public constant returns (uint24 cost, uint8 spell) {\n        spell = uint8(spellAbilities.getSpell(randomSeed)) + 1;\n        return (getSpellAbilityCost(spell), spell);\n    }\n    \n    function getSpellAbilityCost(uint8 spell) public constant returns (uint24 cost) {\n        return 100000;\n    }\n\n    function getNeutralMutation(uint32 randomSeed) public constant returns (uint24 cost, uint8 mutation) {\n        mutation = uint8(neutralMutations.getMutation(randomSeed)) + 1;\n        return (getNeutralMutationCost(mutation), mutation);\n    }\n    \n    function getNeutralMutationCost(uint8 mutation) public constant returns (uint24 cost) {\n        if (mutation == 0) {\n            return 0;   \n        }\n        return 40000;\n    }\n\n    function getMutationForRace(Race race, uint32 randomSeed) public constant returns (uint24 cost, uint8 mutation) {\n        if (race == Race.Dragon) {\n            mutation = uint8(dragonMutations.getRaceMutation(randomSeed)) + 1;\n        } else if (race == Race.Spiderling) {\n            mutation = uint8(spiderlingMutations.getRaceMutation(randomSeed)) + 1;\n        } else if (race == Race.Demon) {\n            mutation = uint8(demonMutations.getRaceMutation(randomSeed)) + 1;\n        } else if (race == Race.Humanoid) {\n            mutation = uint8(humanoidMutations.getRaceMutation(randomSeed)) + 1;\n        } else if (race == Race.Beast) {\n            mutation = uint8(beastMutations.getRaceMutation(randomSeed)) + 1;\n        } else if (race == Race.Undead) {\n            mutation = uint8(undeadMutations.getRaceMutation(randomSeed)) + 1;\n        } else if (race == Race.Elemental) {\n            mutation = uint8(elementalMutations.getRaceMutation(randomSeed)) + 1;\n        } else if (race == Race.Vampire) {\n            mutation = uint8(vampireMutations.getRaceMutation(randomSeed)) + 1;\n        } else if (race == Race.Serpent) {\n            mutation = uint8(serpentMutations.getRaceMutation(randomSeed)) + 1;\n        } else if (race == Race.Mech) {\n            mutation = uint8(mechMutations.getRaceMutation(randomSeed)) + 1;\n        } else if (race == Race.Golem) {\n            mutation = uint8(golemMutations.getRaceMutation(randomSeed)) + 1;\n        } else if (race == Race.Parasite) {\n            mutation = uint8(parasiteMutations.getRaceMutation(randomSeed)) + 1;\n        }\n        return (getRaceMutationCost(race, mutation), mutation);\n    }\n    \n    function getRaceMutationCost(Race race, uint8 mutation) public constant returns (uint24 cost) {\n        if (mutation == 0) {\n            return 0;   \n        }\n        return 40000;\n    }\n    \n    function getCostForHealth(uint8 health) public constant returns (uint24 cost) {\n        return health * uint24(2000);\n    }\n    \n    function getHealthForCost(uint32 cost) public constant returns (uint32 health) {\n        health = cost / 2000;\n        if (health > 98) { // 1+[0-98] (gotta have [1-99] health)\n            health = 98;\n        }\n        return health;\n    }\n    \n    function getCostForAttack(uint8 attack) public constant returns (uint24 cost) {\n        return attack * uint24(2000);\n    }\n    \n    function getAttackForCost(uint32 cost) public constant returns (uint32 attack) {\n       attack = cost / 2000;\n        if (attack > 99) {\n            attack = 99;\n        }\n        return attack;\n    }\n    \n}\n\ncontract SpellAbilities {\n    enum Spells {LavaBlast, FlameNova, Purify, IceBlast, FlashFrost, SnowStorm, FrostFlurry, ChargeFoward, DeepFreeze, ThawTarget,\n                 FlashOfLight, LightBeacon, BlackHole, Earthquake, EnchantArmor, EnchantWeapon, CallReinforcements, ParalysisPotion,\n                 InflictFear, ArcaneVision, KillShot, DragonsBreath, GlacialShard, BlackArrow, DivineKnowledge, LightningVortex,\n                 SolarFlare, PrimalBurst, RagingStorm, GiantCyclone, UnleashDarkness, ChargedOrb, UnholyMight, PowerShield, HallowedMist,\n                 EmbraceLight, AcidRain, BoneFlurry, Rejuvenation, DeathGrip, SummonSwarm, MagicalCharm, EnchantedSilence, SolemnStrike,\n                 ImpendingDoom, SpreadingFlames, ShadowLance, HauntedCurse, LightningShock, PowerSurge}\n    uint16 constant numSpells = 50;\n\n    function getSpell(uint32 randomSeed) public constant returns (Spells spell) {\n        return Spells(randomSeed % numSpells);\n    }\n}\n\n\ncontract SharedNeutralMutations {\n    enum Mutations {Frontline, CallReinforcements, ArmorPiercing, Battlecry, HealAlly, LevelUp, SecondWind, ChargingStrike, SpellShield, AugmentMagic, CrystalSiphon, \n                    ManipulateCrystals, DeadlyDemise, FlameResistance, IceResistance, LightningResistance, PoisonResistance, CurseResistance, DragonSlayer, SpiderlingSlayer,\n                    VampireSlayer, DemonSlayer, HumanoidSlayer, BeastSlayer, UndeadSlayer, SerpentSlayer, MechSlayer, GolemSlayer, ElementalSlayer, ParasiteSlayer}\n    uint16 constant numMutations = 30;\n\n    function getMutation(uint32 randomSeed) public constant returns (Mutations mutation) {\n        return Mutations(randomSeed % numMutations);\n    }\n}\n\n\ncontract DragonMutations {\n    enum RaceMutations {FireBreath, HornedTail, BloodMagic, BarbedScales, WingedFlight, EggSpawn, Chronoshift, PhoenixFeathers}\n    uint16 constant numMutations = 8;\n\n    function getRaceMutation(uint32 randomSeed) public constant returns (RaceMutations mutation) {\n        return RaceMutations(randomSeed % numMutations);\n    }\n}\n\ncontract SpiderlingMutations {\n    enum RaceMutations {CripplingBite, BurrowTrap, SkitteringFrenzy, EggSpawn, CritterRush, WebCocoon, SummonBroodmother, TremorSense}\n    uint16 constant numMutations = 8;\n\n    function getRaceMutation(uint32 randomSeed) public constant returns (RaceMutations mutation) {\n        return RaceMutations(randomSeed % numMutations);\n    }\n}\n\ncontract VampireMutations {\n    enum RaceMutations {Bloodlink, LifeLeech, Bloodlust, DiamondSkin, TwilightVision, Regeneration, PiercingFangs, Shadowstrike}\n    uint16 constant numMutations = 8;\n\n    function getRaceMutation(uint32 randomSeed) public constant returns (RaceMutations mutation) {\n        return RaceMutations(randomSeed % numMutations);\n    }\n}\n\ncontract DemonMutations {\n    enum RaceMutations {PyreScales, ShadowRealm, MenacingGaze, Hellfire, RaiseAsh, TailLash, ReapSouls, BladedTalons}\n    uint16 constant numMutations = 8;\n\n    function getRaceMutation(uint32 randomSeed) public constant returns (RaceMutations mutation) {\n        return RaceMutations(randomSeed % numMutations);\n    }\n}\n\ncontract HumanoidMutations {\n    enum RaceMutations {Garrison, Entrench, Flagbearer, LegionCommander, ScoutAhead, Vengeance, EnchantedBlade, HorseRider}\n    uint16 constant numMutations = 8;\n\n    function getRaceMutation(uint32 randomSeed) public constant returns (RaceMutations mutation) {\n        return RaceMutations(randomSeed % numMutations);\n    }\n}\n\ncontract BeastMutations {\n    enum RaceMutations {FeralRoar, FelineClaws, PrimitiveTusks, ArcticFur, PackHunter, FeignDeath, RavenousBite, NightProwl}\n    uint16 constant numMutations = 8;\n\n    function getRaceMutation(uint32 randomSeed) public constant returns (RaceMutations mutation) {\n        return RaceMutations(randomSeed % numMutations);\n    }\n}\n\ncontract UndeadMutations {\n    enum RaceMutations {Reconstruct, AnimateDead, Pestilence, CrystalSkull, PsychicScreech, RavageSwipe, SpiritForm, BoneSpikes}\n    uint16 constant numMutations = 8;\n\n    function getRaceMutation(uint32 randomSeed) public constant returns (RaceMutations mutation) {\n        return RaceMutations(randomSeed % numMutations);\n    }\n}\n\ncontract SerpentMutations {\n    enum RaceMutations {Constrict, BurrowingStrike, PetrifyingGaze, EggSpawn, ShedScales, StoneBasilisk, EngulfPrey, SprayVenom}\n    uint16 constant numMutations = 8;\n\n    function getRaceMutation(uint32 randomSeed) public constant returns (RaceMutations mutation) {\n        return RaceMutations(randomSeed % numMutations);\n    }\n}\n\ncontract MechMutations {\n    enum RaceMutations {WhirlingBlade, RocketBoosters, SelfDestruct, EMPScramble, SpareParts, Deconstruct, TwinCannons, PowerShield}\n    uint16 constant numMutations = 8;\n\n    function getRaceMutation(uint32 randomSeed) public constant returns (RaceMutations mutation) {\n        return RaceMutations(randomSeed % numMutations);\n    }\n}\n\ncontract GolemMutations {\n    enum RaceMutations {StoneSentinel, ShatteringSmash, AnimateMud, MoltenCore, TremorGround, VineSprouts, ElementalRoar, FossilArmy}\n    uint16 constant numMutations = 8;\n\n    function getRaceMutation(uint32 randomSeed) public constant returns (RaceMutations mutation) {\n        return RaceMutations(randomSeed % numMutations);\n    }\n}\n\ncontract ElementalMutations {\n    enum RaceMutations {Sandstorm, SolarFlare, ElectricSurge, AquaRush, SpiritChannel, PhaseShift, CosmicAura, NaturesWrath}\n    uint16 constant numMutations = 8;\n\n    function getRaceMutation(uint32 randomSeed) public constant returns (RaceMutations mutation) {\n        return RaceMutations(randomSeed % numMutations);\n    }\n}\n\ncontract ParasiteMutations {\n    enum RaceMutations {Infestation, BloodLeech, Corruption, ProtectiveShell, TailSwipe, ExposeWound, StingingTentacles, EruptiveGut}\n    uint16 constant numMutations = 8;\n\n    function getRaceMutation(uint32 randomSeed) public constant returns (RaceMutations mutation) {\n        return RaceMutations(randomSeed % numMutations);\n    }\n}\n\n// Pulling checks like this into secondary contract allows for more extensibility in future (LoanMarketplace and so forth.)\ncontract TransferRestrictionVerifier {\n    MappedMarketplace marketplaceContract = MappedMarketplace(0xc3d2736b3e4f0f78457d75b3b5f0191a14e8bd57);\n    \n    function isAvailableForTransfer(uint64 cardId) external constant returns(bool) {\n        return !marketplaceContract.isListed(cardId);\n    }\n}\n\n\n\n\ncontract MappedMarketplace {\n    EtherGenCore storageContract; // Main card storage and ERC721 transfer functionality\n    TransferRestrictionVerifier transferRestrictionVerifier; // Allows future stuff (loan marketplace etc.) to restrict listing same card twice\n    \n    uint24 private constant removalDuration = 14 days; // Listings can be pruned from market after 14 days\n    uint8 private constant marketCut = 100; // 1% (not 100% as it is divided)\n    address public owner = 0x08F4aE96b647B30177cc15B21195960625BA4163;\n    bool public paused = false;\n\n    mapping(uint64 => Listing) private listings;\n    mapping(address => bool) private whitelistedContracts;\n    uint64[] private listedCardIds;\n\n    struct Listing {\n        uint64 listingPointer; // Index in the Market's listings\n        \n        uint64 cardId;\n        uint64 listTime; // Seconds\n        uint128 startPrice;\n        uint128 endPrice;\n        uint24 priceChangeDuration; // Seconds\n    }\n    \n    function isListed(uint64 cardId) public constant returns(bool) {\n        if (listedCardIds.length == 0) return false;\n        return (listings[cardId].listTime > 0);\n    }\n    \n    function getMarketSize() external constant returns(uint) {\n        return listedCardIds.length;\n    }\n    \n    function listCard(uint64 cardId, uint128 startPrice, uint128 endPrice, uint24 priceChangeDuration) external {\n        require(storageContract.ownerOf(cardId) == msg.sender);\n        require(storageContract.isCardTradeable(cardId));\n        require(transferRestrictionVerifier.isAvailableForTransfer(cardId));\n        require(isWhitelisted(msg.sender));\n        require(!paused);\n        require(startPrice > 99 szabo && startPrice <= 10 ether);\n        require(endPrice > 99 szabo && endPrice <= 10 ether);\n        require(priceChangeDuration > 21599 && priceChangeDuration < 259201); // 6-72 Hours\n       \n        listings[cardId] = Listing(0, cardId, uint64(now), startPrice, endPrice, priceChangeDuration);\n        listings[cardId].listingPointer = uint64(listedCardIds.push(cardId) - 1);\n    }\n    \n    \n    function purchaseCard(uint64 cardId) payable external {\n        require(isListed(cardId));\n        require(!paused);\n\n        uint256 price = getCurrentPrice(listings[cardId].startPrice, listings[cardId].endPrice, listings[cardId].priceChangeDuration, (uint64(now) - listings[cardId].listTime));\n        require(msg.value >= price);\n        \n        address seller = storageContract.ownerOf(cardId);\n        uint256 sellerProceeds = price - (price / marketCut); // 1% cut\n        \n        removeListingInternal(cardId);\n        seller.transfer(sellerProceeds);\n        \n        uint256 bidExcess = msg.value - price;\n        if (bidExcess > 1 szabo) { // Little point otherwise they'll just pay more in gas\n            msg.sender.transfer(bidExcess);\n        }\n        \n        storageContract.transferFrom(seller, msg.sender, cardId);\n    }\n    \n    function getCurrentPrice(uint128 startPrice, uint128 endPrice, uint24 priceChangeDuration, uint64 secondsSinceListing) public constant returns (uint256) {\n        if (secondsSinceListing >= priceChangeDuration) {\n            return endPrice;\n        } else {\n            int256 totalPriceChange = int256(endPrice) - int256(startPrice); // Can be negative\n            int256 currentPriceChange = totalPriceChange * int256(secondsSinceListing) / int256(priceChangeDuration);\n            return uint256(int256(startPrice) + currentPriceChange);\n        }\n    }\n    \n    function removeListing(uint64 cardId) external {\n        require(isListed(cardId));\n        require(!paused);\n        require(storageContract.ownerOf(cardId) == msg.sender || (now - listings[cardId].listTime) > removalDuration);\n        removeListingInternal(cardId);\n    }\n    \n    function removeListingInternal(uint64 cardId) internal {\n        if (listedCardIds.length > 1) {\n            uint64 rowToDelete = listings[cardId].listingPointer;\n            uint64 keyToMove = listedCardIds[listedCardIds.length - 1];\n            \n            listedCardIds[rowToDelete] = keyToMove;\n            listings[keyToMove].listingPointer = rowToDelete;\n        }\n        \n        listedCardIds.length--;\n        delete listings[cardId];\n    }\n    \n    \n    function getListings() external constant returns (uint64[], address[], uint64[], uint128[], uint128[], uint24[], uint8[14][]) {\n        uint64[] memory cardIds = new uint64[](listedCardIds.length); // Not ideal but web3.js didn't like returning multiple 2d arrays\n        address[] memory cardOwners = new address[](listedCardIds.length);\n        uint64[] memory listTimes = new uint64[](listedCardIds.length);\n        uint128[] memory startPrices = new uint128[](listedCardIds.length);\n        uint128[] memory endPrices = new uint128[](listedCardIds.length);\n        uint24[] memory priceChangeDurations = new uint24[](listedCardIds.length);\n        uint8[14][] memory cardDetails = new uint8[14][](listedCardIds.length);\n        \n        for (uint64 i = 0; i < listedCardIds.length; i++) {\n            Listing memory listing = listings[listedCardIds[i]];\n            cardDetails[i] = storageContract.getCard(listing.cardId);\n            cardOwners[i] = storageContract.ownerOf(listing.cardId);\n            cardIds[i] = listing.cardId;\n            listTimes[i] = listing.listTime;\n            startPrices[i] = listing.startPrice;\n            endPrices[i] = listing.endPrice;\n            priceChangeDurations[i] = listing.priceChangeDuration;\n        }\n        return (cardIds, cardOwners, listTimes, startPrices, endPrices, priceChangeDurations, cardDetails);\n    }\n    \n    function getListingAtPosition(uint64 i) external constant returns (uint128[5]) {\n        Listing memory listing = listings[listedCardIds[i]];\n        return ([listing.cardId, listing.listTime, listing.startPrice, listing.endPrice, listing.priceChangeDuration]);\n    }\n    \n    function getListing(uint64 cardId) external constant returns (uint128[5]) {\n        Listing memory listing = listings[cardId];\n        return ([listing.cardId, listing.listTime, listing.startPrice, listing.endPrice, listing.priceChangeDuration]);\n    }\n    \n    // Contracts can't list cards without contacting us (wallet addresses are unaffected)\n    function isWhitelisted(address seller) internal constant returns (bool) {\n        uint size;\n        assembly { size := extcodesize(seller) }\n        return size == 0 || whitelistedContracts[seller];\n    }\n    \n    function whitelistContract(address seller, bool whitelisted) external {\n        require(msg.sender == owner);\n        whitelistedContracts[seller] = whitelisted;\n    }\n    \n    function updateStorageContract(address newStorage) external {\n        require(msg.sender == owner);\n        storageContract = EtherGenCore(newStorage);\n    }\n    \n    function updateTransferRestrictionVerifier(address newTransferRestrictionVerifier) external {\n        require(msg.sender == owner);\n        transferRestrictionVerifier = TransferRestrictionVerifier(newTransferRestrictionVerifier);\n    }\n    \n    function setPaused(bool shouldPause) external {\n        require(msg.sender == owner);\n        paused = shouldPause;\n    }\n    \n    function updateOwner(address newOwner) external {\n        require(msg.sender == owner);\n        owner = newOwner;\n    }\n    \n    function withdrawBalance() external {\n        require(msg.sender == owner);\n        owner.transfer(this.balance);\n    }\n\n}",
  "bytecode": "606060405260008054600160a060020a03199081167308584271df3d0249c2c06ac1bc1237a1dd30cb9a1790915560018054821673677aa1dc08b9429c595efd4425b2d218cc22fd6e178155600280549092167308f4ae96b647b30177cc15b21195960625ba4163179091556004805460ff19169091179055341561008357600080fd5b611471806100926000396000f30060606040526004361061008a5763ffffffff60e060020a6000350416631a006503811461008f5780631f03bc1b146100b657806354c15020146100d057806359f47523146100e357806371b80b8f146100f6578063880cdc31146101155780638da5cb5b146101345780638fb6d99714610163578063cb9674d314610182578063e0929b9514610198575b600080fd5b341561009a57600080fd5b6100a26101b7565b604051901515815260200160405180910390f35b34156100c157600080fd5b6100ce60043515156101d7565b005b34156100db57600080fd5b6100ce610205565b34156100ee57600080fd5b6100a2610395565b341561010157600080fd5b6100ce600160a060020a036004351661039e565b341561012057600080fd5b6100ce600160a060020a03600435166103db565b341561013f57600080fd5b610147610418565b604051600160a060020a03909116815260200160405180910390f35b341561016e57600080fd5b6100ce600160a060020a0360043516610427565b341561018d57600080fd5b610147600435610464565b34156101a357600080fd5b6100ce600160a060020a036004351661048c565b600160a060020a03331660009081526003602052604090205460ff165b90565b60025433600160a060020a039081169116146101f257600080fd5b6004805460ff1916911515919091179055565b600061020f6113d5565b6005546000901161021f57600080fd5b60058054600019810190811061023157fe5b6000918252602082200154600154600160a060020a0391821694506102b2924292909116906318160ddd90604051602001526040518163ffffffff1660e060020a028152600401602060405180830381600087803b151561029157600080fd5b6102c65a03f115156102a257600080fd5b505050604051805190500261059f565b60016101a0820152600580549192509060001981019081106102d057fe5b60009182526020909120018054600160a060020a031916905560058054906102fc9060001983016113fe565b50600154600160a060020a031663fd6ba459838360405160e060020a63ffffffff8516028152600160a060020a0383166004820190815290602401826101c080838360005b83811015610359578082015183820152602001610341565b5050505090500192505050600060405180830381600087803b151561037d57600080fd5b6102c65a03f1151561038e57600080fd5b5050505050565b60045460ff1681565b60025433600160a060020a039081169116146103b957600080fd5b60008054600160a060020a031916600160a060020a0392909216919091179055565b60025433600160a060020a039081169116146103f657600080fd5b60028054600160a060020a031916600160a060020a0392909216919091179055565b600254600160a060020a031681565b60025433600160a060020a0390811691161461044257600080fd5b60018054600160a060020a031916600160a060020a0392909216919091179055565b600580548290811061047257fe5b600091825260209091200154600160a060020a0316905081565b6104946113d5565b600160a060020a03331660009081526003602052604090205460ff16156104ba57600080fd5b6104c33361059f565b60045490915060ff1615156104db5760016101a08201525b600160a060020a033381811660009081526003602052604090819020805460ff19166001908117909155549092169163fd6ba459919084905160e060020a63ffffffff8516028152600160a060020a0383166004820190815290602401826101c080838360005b8381101561055a578082015183820152602001610542565b5050505090500192505050600060405180830381600087803b151561057e57600080fd5b6102c65a03f1151561058f57600080fd5b50505061059b826106c3565b5050565b6105a76113d5565b6105af6113d5565b43408360405191825263ffffffff1660e060020a02602082015260240160405190819003902060008054919450600160a060020a03909116906312cf8a109085906040516020015260405163ffffffff83811660e060020a028252919091166004820152602401602060405180830381600087803b151561062f57600080fd5b6102c65a03f1151561064057600080fd5b505050604051805160ff168252506000815160ff16141561066a576106658184610764565b610674565b61067481846111a0565b43408360405191825263ffffffff1660e060020a026020820152602401604051908190039020925060c863ffffffff84160663ffffffff16600d14156106bd5760016101808201525b92915050565b600160a060020a038116158015906106ed575033600160a060020a031681600160a060020a031614155b1561076157600580546001810161070483826113fe565b5060009182526020909120018054600160a060020a031916600160a060020a038316179055600580546001810161073b83826113fe565b5060009182526020909120018054600160a060020a03191633600160a060020a03161790555b50565b60008060008060008043408760405191825263ffffffff1660e060020a02602082015260240160405190819003902060008054919850600160a060020a0390911690633c3861b69089906040516020015260405163ffffffff83811660e060020a028252919091166004820152602401602060405180830381600087803b15156107ed57600080fd5b6102c65a03f115156107fe57600080fd5b505050604051805160ff1660208a01908152600054600160a060020a03169150632be2f085905160006040516020015260405160e060020a63ffffffff841602815260ff9091166004820152602401602060405180830381600087803b151561086657600080fd5b6102c65a03f1151561087757600080fd5b5050506040518051905060ff168601955043408760405191825263ffffffff1660e060020a02602082015260240160405190819003902060008054919850600160a060020a039091169063edaebc209089906040516020015260405163ffffffff83811660e060020a028252919091166004820152602401602060405180830381600087803b151561090857600080fd5b6102c65a03f1151561091957600080fd5b505050604051805160ff1660408a01908152600054600160a060020a03169150631c0019c4905160006040516020015260405160e060020a63ffffffff841602815260ff9091166004820152602401602060405180830381600087803b151561098157600080fd5b6102c65a03f1151561099257600080fd5b505050604051805190508601955043408760405191825263ffffffff1660e060020a0260208201526024016040519081900390209650600c63ffffffff881606925060058360ff1611156109e957600392506109fa565b60028360ff1611156109fa57600292505b600091505b8260ff168260ff161015610da35743408760405191825263ffffffff1660e060020a0260208201526024016040519081900390209650600363ffffffff88160663ffffffff1660001415610c135743408760405191825263ffffffff1660e060020a026020820152602401604051908190039020600054909750600160a060020a0316635acea28860208a015160ff16600b811115610a9a57fe5b896000604051604001526040518363ffffffff1660e060020a0281526004018083600b811115610ac657fe5b60ff16815263ffffffff90921660208301525060409081019150805180830381600087803b1515610af657600080fd5b6102c65a03f11515610b0757600080fd5b505050604051805190602001805196509094505062046cd062ffffff878601161015610c0e5760c088015160ff161515610b5657848860065b60ff909216602092909202015294830194610c0e565b600060c089015160ff16118015610b72575060e088015160ff16155b8015610b88575060ff851660c089015160ff1614155b15610b965784886007610b40565b600060c089015160ff16118015610bb45750600060e089015160ff16115b8015610bc6575061010088015160ff16155b8015610bdc575060ff851660c089015160ff1614155b8015610bf2575060ff851660e089015160ff1614155b15610c0e57848860085b60ff9092166020929092020152948301945b610d98565b43408760405191825263ffffffff1660e060020a02602082015260240160405190819003902060008054919850600160a060020a039091169063c50bb4469089906040516040015260405163ffffffff83811660e060020a0282529190911660048201526024016040805180830381600087803b1515610c9257600080fd5b6102c65a03f11515610ca357600080fd5b505050604051805190602001805196509094505062046cd062ffffff878601161015610d985761012088015160ff161515610ce15784886009610bfc565b600061012089015160ff16118015610cff575061014088015160ff16155b8015610d16575060ff851661012089015160ff1614155b15610d24578488600a610bfc565b600061012089015160ff16118015610d445750600061014089015160ff16115b8015610d56575061016088015160ff16155b8015610d6d575060ff851661012089015160ff1614155b8015610d84575060ff851661014089015160ff1614155b15610d985760ff8516610160890152948301945b6001909101906109ff565b43408760405191825263ffffffff1660e060020a02602082015260240160405190819003902060008054919850600160a060020a03909116906324417f39906001906040516020015260405160e060020a63ffffffff841602815260ff9091166004820152602401602060405180830381600087803b1515610e2457600080fd5b6102c65a03f11515610e3557600080fd5b505050604051805190508601620497c80362ffffff168763ffffffff16811515610e5b57fe5b600080549290910691600160a060020a0316906324417f39906001906040516020015260405160e060020a63ffffffff841602815260ff9091166004820152602401602060405180830381600087803b1515610eb657600080fd5b6102c65a03f11515610ec757600080fd5b50505060405180519050019050620186a081870162ffffff161015610eef5785620186a00390505b43408760405191825263ffffffff1660e060020a026020820152602401604051908190039020600054909750600160a060020a03166395dba6c962ffffff831663ffffffff8a16811515610f3f57fe5b0660006040516020015260405163ffffffff83811660e060020a028252919091166004820152602401602060405180830381600087803b1515610f8157600080fd5b6102c65a03f11515610f9257600080fd5b505050604051805160010160ff1660a08a01908152600054600160a060020a031691506324417f39905160006040516020015260405160e060020a63ffffffff841602815260ff9091166004820152602401602060405180830381600087803b1515610ffd57600080fd5b6102c65a03f1151561100e57600080fd5b5050506040518051600054970196600160a060020a031690506324417f3960a08a015160006040516020015260405160e060020a63ffffffff841602815260ff9091166004820152602401602060405180830381600087803b151561107257600080fd5b6102c65a03f1151561108357600080fd5b5050506040518051600080549190930392600160a060020a039091169150632a1747109083906040516020015260405160e060020a63ffffffff841602815262ffffff9091166004820152602401602060405180830381600087803b15156110ea57600080fd5b6102c65a03f115156110fb57600080fd5b505050604051805160ff1660808a01908152600054600160a060020a03169150633addedd3905160006040516020015260405160e060020a63ffffffff841602815260ff9091166004820152602401602060405180830381600087803b151561116357600080fd5b6102c65a03f1151561117457600080fd5b5050506040518051612710970162ffffff169690960460ff166060989098019790975250505050505050565b600080600080600043408660405191825263ffffffff1660e060020a0260208201526024016040519081900390209550600f8616915060088211156111e85760039150611202565b60008260ff1611156111fd5760029150611202565b600191505b5060005b8160ff168160ff1610156113b25743408660405191825263ffffffff1660e060020a02602082015260240160405190819003902060008054919750600160a060020a039091169063eccaa8b59088906040516040015260405163ffffffff83811660e060020a0282529190911660048201526024016040805180830381600087803b151561129357600080fd5b6102c65a03f115156112a457600080fd5b5050506040518051906020018051955090935050620493e062ffffff86850116116113aa5761012087015160ff1615156112f357838760095b60ff9092166020929092020152938201936113aa565b600061012088015160ff16118015611311575061014087015160ff16155b8015611328575060ff841661012088015160ff1614155b15611336578387600a6112dd565b600061012088015160ff161180156113565750600061014088015160ff16115b8015611368575061016087015160ff16155b801561137f575060ff841661012088015160ff1614155b8015611396575060ff841661014088015160ff1614155b156113aa5760ff8416610160880152938201935b600101611206565b61271062ffffff86160487600360ff909216602092909202015250505050505050565b6101c0604051908101604052600e815b6000815260001990910190602001816113e55790505090565b81548183558181151161142257600083815260209020611422918101908301611427565b505050565b6101d491905b80821115611441576000815560010161142d565b50905600a165627a7a723058204431adfa5a5a8e34afeb69f33c88d24d4989d943e76d88f8fdfcf20fb957a3b30029"
}