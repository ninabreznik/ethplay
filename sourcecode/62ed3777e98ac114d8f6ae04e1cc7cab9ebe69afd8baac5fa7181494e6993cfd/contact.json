{
  "address": "0xe7e7f69b34d7d9bd8d61fb22c33b22708947971a",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "Claims",
  "compilerVersion": "v0.4.24+commit.e67f0147",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2019-01-04\n*/\n\n//  simple claims store\n//  https://azimuth.network\n\npragma solidity 0.4.24;\n\n////////////////////////////////////////////////////////////////////////////////\n//  Imports\n////////////////////////////////////////////////////////////////////////////////\n\n// OpenZeppelin's Ownable.sol\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipRenounced(address indexed previousOwner);\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to relinquish control of the contract.\n   * @notice Renouncing to ownership will leave the contract without an owner.\n   * It will not be possible to call the functions with the `onlyOwner`\n   * modifier anymore.\n   */\n  function renounceOwnership() public onlyOwner {\n    emit OwnershipRenounced(owner);\n    owner = address(0);\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address _newOwner) public onlyOwner {\n    _transferOwnership(_newOwner);\n  }\n\n  /**\n   * @dev Transfers control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function _transferOwnership(address _newOwner) internal {\n    require(_newOwner != address(0));\n    emit OwnershipTransferred(owner, _newOwner);\n    owner = _newOwner;\n  }\n}\n\n// Azimuth's Azimuth.sol\n\n//  Azimuth: point state data contract\n//\n//    This contract is used for storing all data related to Azimuth points\n//    and their ownership. Consider this contract the Azimuth ledger.\n//\n//    It also contains permissions data, which ties in to ERC721\n//    functionality. Operators of an address are allowed to transfer\n//    ownership of all points owned by their associated address\n//    (ERC721's approveAll()). A transfer proxy is allowed to transfer\n//    ownership of a single point (ERC721's approve()).\n//    Separate from ERC721 are managers, assigned per point. They are\n//    allowed to perform \"low-impact\" operations on the owner's points,\n//    like configuring public keys and making escape requests.\n//\n//    Since data stores are difficult to upgrade, this contract contains\n//    as little actual business logic as possible. Instead, the data stored\n//    herein can only be modified by this contract's owner, which can be\n//    changed and is thus upgradable/replaceable.\n//\n//    This contract will be owned by the Ecliptic contract.\n//\ncontract Azimuth is Ownable\n{\n//\n//  Events\n//\n\n  //  OwnerChanged: :point is now owned by :owner\n  //\n  event OwnerChanged(uint32 indexed point, address indexed owner);\n\n  //  Activated: :point is now active\n  //\n  event Activated(uint32 indexed point);\n\n  //  Spawned: :prefix has spawned :child\n  //\n  event Spawned(uint32 indexed prefix, uint32 indexed child);\n\n  //  EscapeRequested: :point has requested a new :sponsor\n  //\n  event EscapeRequested(uint32 indexed point, uint32 indexed sponsor);\n\n  //  EscapeCanceled: :point's :sponsor request was canceled or rejected\n  //\n  event EscapeCanceled(uint32 indexed point, uint32 indexed sponsor);\n\n  //  EscapeAccepted: :point confirmed with a new :sponsor\n  //\n  event EscapeAccepted(uint32 indexed point, uint32 indexed sponsor);\n\n  //  LostSponsor: :point's :sponsor is now refusing it service\n  //\n  event LostSponsor(uint32 indexed point, uint32 indexed sponsor);\n\n  //  ChangedKeys: :point has new network public keys\n  //\n  event ChangedKeys( uint32 indexed point,\n                     bytes32 encryptionKey,\n                     bytes32 authenticationKey,\n                     uint32 cryptoSuiteVersion,\n                     uint32 keyRevisionNumber );\n\n  //  BrokeContinuity: :point has a new continuity number, :number\n  //\n  event BrokeContinuity(uint32 indexed point, uint32 number);\n\n  //  ChangedSpawnProxy: :spawnProxy can now spawn using :point\n  //\n  event ChangedSpawnProxy(uint32 indexed point, address indexed spawnProxy);\n\n  //  ChangedTransferProxy: :transferProxy can now transfer ownership of :point\n  //\n  event ChangedTransferProxy( uint32 indexed point,\n                              address indexed transferProxy );\n\n  //  ChangedManagementProxy: :managementProxy can now manage :point\n  //\n  event ChangedManagementProxy( uint32 indexed point,\n                                address indexed managementProxy );\n\n  //  ChangedVotingProxy: :votingProxy can now vote using :point\n  //\n  event ChangedVotingProxy(uint32 indexed point, address indexed votingProxy);\n\n  //  ChangedDns: dnsDomains have been updated\n  //\n  event ChangedDns(string primary, string secondary, string tertiary);\n\n//\n//  Structures\n//\n\n  //  Size: kinds of points registered on-chain\n  //\n  //    NOTE: the order matters, because of Solidity enum numbering\n  //\n  enum Size\n  {\n    Galaxy, // = 0\n    Star,   // = 1\n    Planet  // = 2\n  }\n\n  //  Point: state of a point\n  //\n  //    While the ordering of the struct members is semantically chaotic,\n  //    they are ordered to tightly pack them into Ethereum's 32-byte storage\n  //    slots, which reduces gas costs for some function calls.\n  //    The comment ticks indicate assumed slot boundaries.\n  //\n  struct Point\n  {\n    //  encryptionKey: (curve25519) encryption public key, or 0 for none\n    //\n    bytes32 encryptionKey;\n  //\n    //  authenticationKey: (ed25519) authentication public key, or 0 for none\n    //\n    bytes32 authenticationKey;\n  //\n    //  spawned: for stars and galaxies, all :active children\n    //\n    uint32[] spawned;\n  //\n    //  hasSponsor: true if the sponsor still supports the point\n    //\n    bool hasSponsor;\n\n    //  active: whether point can be linked\n    //\n    //    false: point belongs to prefix, cannot be configured or linked\n    //    true: point no longer belongs to prefix, can be configured and linked\n    //\n    bool active;\n\n    //  escapeRequested: true if the point has requested to change sponsors\n    //\n    bool escapeRequested;\n\n    //  sponsor: the point that supports this one on the network, or,\n    //           if :hasSponsor is false, the last point that supported it.\n    //           (by default, the point's half-width prefix)\n    //\n    uint32 sponsor;\n\n    //  escapeRequestedTo: if :escapeRequested is true, new sponsor requested\n    //\n    uint32 escapeRequestedTo;\n\n    //  cryptoSuiteVersion: version of the crypto suite used for the pubkeys\n    //\n    uint32 cryptoSuiteVersion;\n\n    //  keyRevisionNumber: incremented every time the public keys change\n    //\n    uint32 keyRevisionNumber;\n\n    //  continuityNumber: incremented to indicate network-side state loss\n    //\n    uint32 continuityNumber;\n  }\n\n  //  Deed: permissions for a point\n  //\n  struct Deed\n  {\n    //  owner: address that owns this point\n    //\n    address owner;\n\n    //  managementProxy: 0, or another address with the right to perform\n    //                   low-impact, managerial operations on this point\n    //\n    address managementProxy;\n\n    //  spawnProxy: 0, or another address with the right to spawn children\n    //              of this point\n    //\n    address spawnProxy;\n\n    //  votingProxy: 0, or another address with the right to vote as this point\n    //\n    address votingProxy;\n\n    //  transferProxy: 0, or another address with the right to transfer\n    //                 ownership of this point\n    //\n    address transferProxy;\n  }\n\n//\n//  General state\n//\n\n  //  points: per point, general network-relevant point state\n  //\n  mapping(uint32 => Point) public points;\n\n  //  rights: per point, on-chain ownership and permissions\n  //\n  mapping(uint32 => Deed) public rights;\n\n  //  operators: per owner, per address, has the right to transfer ownership\n  //             of all the owner's points (ERC721)\n  //\n  mapping(address => mapping(address => bool)) public operators;\n\n  //  dnsDomains: base domains for contacting galaxies\n  //\n  //    dnsDomains[0] is primary, the others are used as fallbacks\n  //\n  string[3] public dnsDomains;\n\n//\n//  Lookups\n//\n\n  //  sponsoring: per point, the points they are sponsoring\n  //\n  mapping(uint32 => uint32[]) public sponsoring;\n\n  //  sponsoringIndexes: per point, per point, (index + 1) in\n  //                     the sponsoring array\n  //\n  mapping(uint32 => mapping(uint32 => uint256)) public sponsoringIndexes;\n\n  //  escapeRequests: per point, the points they have open escape requests from\n  //\n  mapping(uint32 => uint32[]) public escapeRequests;\n\n  //  escapeRequestsIndexes: per point, per point, (index + 1) in\n  //                         the escapeRequests array\n  //\n  mapping(uint32 => mapping(uint32 => uint256)) public escapeRequestsIndexes;\n\n  //  pointsOwnedBy: per address, the points they own\n  //\n  mapping(address => uint32[]) public pointsOwnedBy;\n\n  //  pointOwnerIndexes: per owner, per point, (index + 1) in\n  //                     the pointsOwnedBy array\n  //\n  //    We delete owners by moving the last entry in the array to the\n  //    newly emptied slot, which is (n - 1) where n is the value of\n  //    pointOwnerIndexes[owner][point].\n  //\n  mapping(address => mapping(uint32 => uint256)) public pointOwnerIndexes;\n\n  //  managerFor: per address, the points they are the management proxy for\n  //\n  mapping(address => uint32[]) public managerFor;\n\n  //  managerForIndexes: per address, per point, (index + 1) in\n  //                     the managerFor array\n  //\n  mapping(address => mapping(uint32 => uint256)) public managerForIndexes;\n\n  //  spawningFor: per address, the points they can spawn with\n  //\n  mapping(address => uint32[]) public spawningFor;\n\n  //  spawningForIndexes: per address, per point, (index + 1) in\n  //                      the spawningFor array\n  //\n  mapping(address => mapping(uint32 => uint256)) public spawningForIndexes;\n\n  //  votingFor: per address, the points they can vote with\n  //\n  mapping(address => uint32[]) public votingFor;\n\n  //  votingForIndexes: per address, per point, (index + 1) in\n  //                    the votingFor array\n  //\n  mapping(address => mapping(uint32 => uint256)) public votingForIndexes;\n\n  //  transferringFor: per address, the points they can transfer\n  //\n  mapping(address => uint32[]) public transferringFor;\n\n  //  transferringForIndexes: per address, per point, (index + 1) in\n  //                          the transferringFor array\n  //\n  mapping(address => mapping(uint32 => uint256)) public transferringForIndexes;\n\n//\n//  Logic\n//\n\n  //  constructor(): configure default dns domains\n  //\n  constructor()\n    public\n  {\n    setDnsDomains(\"example.com\", \"example.com\", \"example.com\");\n  }\n\n  //  setDnsDomains(): set the base domains used for contacting galaxies\n  //\n  //    Note: since a string is really just a byte[], and Solidity can't\n  //    work with two-dimensional arrays yet, we pass in the three\n  //    domains as individual strings.\n  //\n  function setDnsDomains(string _primary, string _secondary, string _tertiary)\n    onlyOwner\n    public\n  {\n    dnsDomains[0] = _primary;\n    dnsDomains[1] = _secondary;\n    dnsDomains[2] = _tertiary;\n    emit ChangedDns(_primary, _secondary, _tertiary);\n  }\n\n  //\n  //  Point reading\n  //\n\n    //  isActive(): return true if _point is active\n    //\n    function isActive(uint32 _point)\n      view\n      external\n      returns (bool equals)\n    {\n      return points[_point].active;\n    }\n\n    //  getKeys(): returns the public keys and their details, as currently\n    //             registered for _point\n    //\n    function getKeys(uint32 _point)\n      view\n      external\n      returns (bytes32 crypt, bytes32 auth, uint32 suite, uint32 revision)\n    {\n      Point storage point = points[_point];\n      return (point.encryptionKey,\n              point.authenticationKey,\n              point.cryptoSuiteVersion,\n              point.keyRevisionNumber);\n    }\n\n    //  getKeyRevisionNumber(): gets the revision number of _point's current\n    //                          public keys\n    //\n    function getKeyRevisionNumber(uint32 _point)\n      view\n      external\n      returns (uint32 revision)\n    {\n      return points[_point].keyRevisionNumber;\n    }\n\n    //  hasBeenLinked(): returns true if the point has ever been assigned keys\n    //\n    function hasBeenLinked(uint32 _point)\n      view\n      external\n      returns (bool result)\n    {\n      return ( points[_point].keyRevisionNumber > 0 );\n    }\n\n    //  isLive(): returns true if _point currently has keys properly configured\n    //\n    function isLive(uint32 _point)\n      view\n      external\n      returns (bool result)\n    {\n      Point storage point = points[_point];\n      return ( point.encryptionKey != 0 &&\n               point.authenticationKey != 0 &&\n               point.cryptoSuiteVersion != 0 );\n    }\n\n    //  getContinuityNumber(): returns _point's current continuity number\n    //\n    function getContinuityNumber(uint32 _point)\n      view\n      external\n      returns (uint32 continuityNumber)\n    {\n      return points[_point].continuityNumber;\n    }\n\n    //  getSpawnCount(): return the number of children spawned by _point\n    //\n    function getSpawnCount(uint32 _point)\n      view\n      external\n      returns (uint32 spawnCount)\n    {\n      uint256 len = points[_point].spawned.length;\n      assert(len < 2**32);\n      return uint32(len);\n    }\n\n    //  getSpawned(): return array of points created under _point\n    //\n    //    Note: only useful for clients, as Solidity does not currently\n    //    support returning dynamic arrays.\n    //\n    function getSpawned(uint32 _point)\n      view\n      external\n      returns (uint32[] spawned)\n    {\n      return points[_point].spawned;\n    }\n\n    //  hasSponsor(): returns true if _point's sponsor is providing it service\n    //\n    function hasSponsor(uint32 _point)\n      view\n      external\n      returns (bool has)\n    {\n      return points[_point].hasSponsor;\n    }\n\n    //  getSponsor(): returns _point's current (or most recent) sponsor\n    //\n    function getSponsor(uint32 _point)\n      view\n      external\n      returns (uint32 sponsor)\n    {\n      return points[_point].sponsor;\n    }\n\n    //  isSponsor(): returns true if _sponsor is currently providing service\n    //               to _point\n    //\n    function isSponsor(uint32 _point, uint32 _sponsor)\n      view\n      external\n      returns (bool result)\n    {\n      Point storage point = points[_point];\n      return ( point.hasSponsor &&\n               (point.sponsor == _sponsor) );\n    }\n\n    //  getSponsoringCount(): returns the number of points _sponsor is\n    //                        providing service to\n    //\n    function getSponsoringCount(uint32 _sponsor)\n      view\n      external\n      returns (uint256 count)\n    {\n      return sponsoring[_sponsor].length;\n    }\n\n    //  getSponsoring(): returns a list of points _sponsor is providing\n    //                   service to\n    //\n    //    Note: only useful for clients, as Solidity does not currently\n    //    support returning dynamic arrays.\n    //\n    function getSponsoring(uint32 _sponsor)\n      view\n      external\n      returns (uint32[] sponsees)\n    {\n      return sponsoring[_sponsor];\n    }\n\n    //  escaping\n\n    //  isEscaping(): returns true if _point has an outstanding escape request\n    //\n    function isEscaping(uint32 _point)\n      view\n      external\n      returns (bool escaping)\n    {\n      return points[_point].escapeRequested;\n    }\n\n    //  getEscapeRequest(): returns _point's current escape request\n    //\n    //    the returned escape request is only valid as long as isEscaping()\n    //    returns true\n    //\n    function getEscapeRequest(uint32 _point)\n      view\n      external\n      returns (uint32 escape)\n    {\n      return points[_point].escapeRequestedTo;\n    }\n\n    //  isRequestingEscapeTo(): returns true if _point has an outstanding\n    //                          escape request targetting _sponsor\n    //\n    function isRequestingEscapeTo(uint32 _point, uint32 _sponsor)\n      view\n      public\n      returns (bool equals)\n    {\n      Point storage point = points[_point];\n      return (point.escapeRequested && (point.escapeRequestedTo == _sponsor));\n    }\n\n    //  getEscapeRequestsCount(): returns the number of points _sponsor\n    //                            is providing service to\n    //\n    function getEscapeRequestsCount(uint32 _sponsor)\n      view\n      external\n      returns (uint256 count)\n    {\n      return escapeRequests[_sponsor].length;\n    }\n\n    //  getEscapeRequests(): get the points _sponsor has received escape\n    //                       requests from\n    //\n    //    Note: only useful for clients, as Solidity does not currently\n    //    support returning dynamic arrays.\n    //\n    function getEscapeRequests(uint32 _sponsor)\n      view\n      external\n      returns (uint32[] requests)\n    {\n      return escapeRequests[_sponsor];\n    }\n\n  //\n  //  Point writing\n  //\n\n    //  activatePoint(): activate a point, register it as spawned by its prefix\n    //\n    function activatePoint(uint32 _point)\n      onlyOwner\n      external\n    {\n      //  make a point active, setting its sponsor to its prefix\n      //\n      Point storage point = points[_point];\n      require(!point.active);\n      point.active = true;\n      registerSponsor(_point, true, getPrefix(_point));\n      emit Activated(_point);\n    }\n\n    //  setKeys(): set network public keys of _point to _encryptionKey and\n    //            _authenticationKey, with the specified _cryptoSuiteVersion\n    //\n    function setKeys(uint32 _point,\n                     bytes32 _encryptionKey,\n                     bytes32 _authenticationKey,\n                     uint32 _cryptoSuiteVersion)\n      onlyOwner\n      external\n    {\n      Point storage point = points[_point];\n      if ( point.encryptionKey == _encryptionKey &&\n           point.authenticationKey == _authenticationKey &&\n           point.cryptoSuiteVersion == _cryptoSuiteVersion )\n      {\n        return;\n      }\n\n      point.encryptionKey = _encryptionKey;\n      point.authenticationKey = _authenticationKey;\n      point.cryptoSuiteVersion = _cryptoSuiteVersion;\n      point.keyRevisionNumber++;\n\n      emit ChangedKeys(_point,\n                       _encryptionKey,\n                       _authenticationKey,\n                       _cryptoSuiteVersion,\n                       point.keyRevisionNumber);\n    }\n\n    //  incrementContinuityNumber(): break continuity for _point\n    //\n    function incrementContinuityNumber(uint32 _point)\n      onlyOwner\n      external\n    {\n      Point storage point = points[_point];\n      point.continuityNumber++;\n      emit BrokeContinuity(_point, point.continuityNumber);\n    }\n\n    //  registerSpawn(): add a point to its prefix's list of spawned points\n    //\n    function registerSpawned(uint32 _point)\n      onlyOwner\n      external\n    {\n      //  if a point is its own prefix (a galaxy) then don't register it\n      //\n      uint32 prefix = getPrefix(_point);\n      if (prefix == _point)\n      {\n        return;\n      }\n\n      //  register a new spawned point for the prefix\n      //\n      points[prefix].spawned.push(_point);\n      emit Spawned(prefix, _point);\n    }\n\n    //  loseSponsor(): indicates that _point's sponsor is no longer providing\n    //                 it service\n    //\n    function loseSponsor(uint32 _point)\n      onlyOwner\n      external\n    {\n      Point storage point = points[_point];\n      if (!point.hasSponsor)\n      {\n        return;\n      }\n      registerSponsor(_point, false, point.sponsor);\n      emit LostSponsor(_point, point.sponsor);\n    }\n\n    //  setEscapeRequest(): for _point, start an escape request to _sponsor\n    //\n    function setEscapeRequest(uint32 _point, uint32 _sponsor)\n      onlyOwner\n      external\n    {\n      if (isRequestingEscapeTo(_point, _sponsor))\n      {\n        return;\n      }\n      registerEscapeRequest(_point, true, _sponsor);\n      emit EscapeRequested(_point, _sponsor);\n    }\n\n    //  cancelEscape(): for _point, stop the current escape request, if any\n    //\n    function cancelEscape(uint32 _point)\n      onlyOwner\n      external\n    {\n      Point storage point = points[_point];\n      if (!point.escapeRequested)\n      {\n        return;\n      }\n      uint32 request = point.escapeRequestedTo;\n      registerEscapeRequest(_point, false, 0);\n      emit EscapeCanceled(_point, request);\n    }\n\n    //  doEscape(): perform the requested escape\n    //\n    function doEscape(uint32 _point)\n      onlyOwner\n      external\n    {\n      Point storage point = points[_point];\n      require(point.escapeRequested);\n      registerSponsor(_point, true, point.escapeRequestedTo);\n      registerEscapeRequest(_point, false, 0);\n      emit EscapeAccepted(_point, point.sponsor);\n    }\n\n  //\n  //  Point utils\n  //\n\n    //  getPrefix(): compute prefix (\"parent\") of _point\n    //\n    function getPrefix(uint32 _point)\n      pure\n      public\n      returns (uint16 prefix)\n    {\n      if (_point < 0x10000)\n      {\n        return uint16(_point % 0x100);\n      }\n      return uint16(_point % 0x10000);\n    }\n\n    //  getPointSize(): return the size of _point\n    //\n    function getPointSize(uint32 _point)\n      external\n      pure\n      returns (Size _size)\n    {\n      if (_point < 0x100) return Size.Galaxy;\n      if (_point < 0x10000) return Size.Star;\n      return Size.Planet;\n    }\n\n    //  internal use\n\n    //  registerSponsor(): set the sponsorship state of _point and update the\n    //                     reverse lookup for sponsors\n    //\n    function registerSponsor(uint32 _point, bool _hasSponsor, uint32 _sponsor)\n      internal\n    {\n      Point storage point = points[_point];\n      bool had = point.hasSponsor;\n      uint32 prev = point.sponsor;\n\n      //  if we didn't have a sponsor, and won't get one,\n      //  or if we get the sponsor we already have,\n      //  nothing will change, so jump out early.\n      //\n      if ( (!had && !_hasSponsor) ||\n           (had && _hasSponsor && prev == _sponsor) )\n      {\n        return;\n      }\n\n      //  if the point used to have a different sponsor, do some gymnastics\n      //  to keep the reverse lookup gapless.  delete the point from the old\n      //  sponsor's list, then fill that gap with the list tail.\n      //\n      if (had)\n      {\n        //  i: current index in previous sponsor's list of sponsored points\n        //\n        uint256 i = sponsoringIndexes[prev][_point];\n\n        //  we store index + 1, because 0 is the solidity default value\n        //\n        assert(i > 0);\n        i--;\n\n        //  copy the last item in the list into the now-unused slot,\n        //  making sure to update its :sponsoringIndexes reference\n        //\n        uint32[] storage prevSponsoring = sponsoring[prev];\n        uint256 last = prevSponsoring.length - 1;\n        uint32 moved = prevSponsoring[last];\n        prevSponsoring[i] = moved;\n        sponsoringIndexes[prev][moved] = i + 1;\n\n        //  delete the last item\n        //\n        delete(prevSponsoring[last]);\n        prevSponsoring.length = last;\n        sponsoringIndexes[prev][_point] = 0;\n      }\n\n      if (_hasSponsor)\n      {\n        uint32[] storage newSponsoring = sponsoring[_sponsor];\n        newSponsoring.push(_point);\n        sponsoringIndexes[_sponsor][_point] = newSponsoring.length;\n      }\n\n      point.sponsor = _sponsor;\n      point.hasSponsor = _hasSponsor;\n    }\n\n    //  registerEscapeRequest(): set the escape state of _point and update the\n    //                           reverse lookup for sponsors\n    //\n    function registerEscapeRequest( uint32 _point,\n                                    bool _isEscaping, uint32 _sponsor )\n      internal\n    {\n      Point storage point = points[_point];\n      bool was = point.escapeRequested;\n      uint32 prev = point.escapeRequestedTo;\n\n      //  if we weren't escaping, and won't be,\n      //  or if we were escaping, and the new target is the same,\n      //  nothing will change, so jump out early.\n      //\n      if ( (!was && !_isEscaping) ||\n           (was && _isEscaping && prev == _sponsor) )\n      {\n        return;\n      }\n\n      //  if the point used to have a different request, do some gymnastics\n      //  to keep the reverse lookup gapless.  delete the point from the old\n      //  sponsor's list, then fill that gap with the list tail.\n      //\n      if (was)\n      {\n        //  i: current index in previous sponsor's list of sponsored points\n        //\n        uint256 i = escapeRequestsIndexes[prev][_point];\n\n        //  we store index + 1, because 0 is the solidity default value\n        //\n        assert(i > 0);\n        i--;\n\n        //  copy the last item in the list into the now-unused slot,\n        //  making sure to update its :escapeRequestsIndexes reference\n        //\n        uint32[] storage prevRequests = escapeRequests[prev];\n        uint256 last = prevRequests.length - 1;\n        uint32 moved = prevRequests[last];\n        prevRequests[i] = moved;\n        escapeRequestsIndexes[prev][moved] = i + 1;\n\n        //  delete the last item\n        //\n        delete(prevRequests[last]);\n        prevRequests.length = last;\n        escapeRequestsIndexes[prev][_point] = 0;\n      }\n\n      if (_isEscaping)\n      {\n        uint32[] storage newRequests = escapeRequests[_sponsor];\n        newRequests.push(_point);\n        escapeRequestsIndexes[_sponsor][_point] = newRequests.length;\n      }\n\n      point.escapeRequestedTo = _sponsor;\n      point.escapeRequested = _isEscaping;\n    }\n\n  //\n  //  Deed reading\n  //\n\n    //  owner\n\n    //  getOwner(): return owner of _point\n    //\n    function getOwner(uint32 _point)\n      view\n      external\n      returns (address owner)\n    {\n      return rights[_point].owner;\n    }\n\n    //  isOwner(): true if _point is owned by _address\n    //\n    function isOwner(uint32 _point, address _address)\n      view\n      external\n      returns (bool result)\n    {\n      return (rights[_point].owner == _address);\n    }\n\n    //  getOwnedPointCount(): return length of array of points that _whose owns\n    //\n    function getOwnedPointCount(address _whose)\n      view\n      external\n      returns (uint256 count)\n    {\n      return pointsOwnedBy[_whose].length;\n    }\n\n    //  getOwnedPoints(): return array of points that _whose owns\n    //\n    //    Note: only useful for clients, as Solidity does not currently\n    //    support returning dynamic arrays.\n    //\n    function getOwnedPoints(address _whose)\n      view\n      external\n      returns (uint32[] ownedPoints)\n    {\n      return pointsOwnedBy[_whose];\n    }\n\n    //  getOwnedPointAtIndex(): get point at _index from array of points that\n    //                         _whose owns\n    //\n    function getOwnedPointAtIndex(address _whose, uint256 _index)\n      view\n      external\n      returns (uint32 point)\n    {\n      uint32[] storage owned = pointsOwnedBy[_whose];\n      require(_index < owned.length);\n      return owned[_index];\n    }\n\n    //  management proxy\n\n    //  getManagementProxy(): returns _point's current management proxy\n    //\n    function getManagementProxy(uint32 _point)\n      view\n      external\n      returns (address manager)\n    {\n      return rights[_point].managementProxy;\n    }\n\n    //  isManagementProxy(): returns true if _proxy is _point's management proxy\n    //\n    function isManagementProxy(uint32 _point, address _proxy)\n      view\n      external\n      returns (bool result)\n    {\n      return (rights[_point].managementProxy == _proxy);\n    }\n\n    //  canManage(): true if _who is the owner or manager of _point\n    //\n    function canManage(uint32 _point, address _who)\n      view\n      external\n      returns (bool result)\n    {\n      Deed storage deed = rights[_point];\n      return ( (0x0 != _who) &&\n               ( (_who == deed.owner) ||\n                 (_who == deed.managementProxy) ) );\n    }\n\n    //  getManagerForCount(): returns the amount of points _proxy can manage\n    //\n    function getManagerForCount(address _proxy)\n      view\n      external\n      returns (uint256 count)\n    {\n      return managerFor[_proxy].length;\n    }\n\n    //  getManagerFor(): returns the points _proxy can manage\n    //\n    //    Note: only useful for clients, as Solidity does not currently\n    //    support returning dynamic arrays.\n    //\n    function getManagerFor(address _proxy)\n      view\n      external\n      returns (uint32[] mfor)\n    {\n      return managerFor[_proxy];\n    }\n\n    //  spawn proxy\n\n    //  getSpawnProxy(): returns _point's current spawn proxy\n    //\n    function getSpawnProxy(uint32 _point)\n      view\n      external\n      returns (address spawnProxy)\n    {\n      return rights[_point].spawnProxy;\n    }\n\n    //  isSpawnProxy(): returns true if _proxy is _point's spawn proxy\n    //\n    function isSpawnProxy(uint32 _point, address _proxy)\n      view\n      external\n      returns (bool result)\n    {\n      return (rights[_point].spawnProxy == _proxy);\n    }\n\n    //  canSpawnAs(): true if _who is the owner or spawn proxy of _point\n    //\n    function canSpawnAs(uint32 _point, address _who)\n      view\n      external\n      returns (bool result)\n    {\n      Deed storage deed = rights[_point];\n      return ( (0x0 != _who) &&\n               ( (_who == deed.owner) ||\n                 (_who == deed.spawnProxy) ) );\n    }\n\n    //  getSpawningForCount(): returns the amount of points _proxy\n    //                         can spawn with\n    //\n    function getSpawningForCount(address _proxy)\n      view\n      external\n      returns (uint256 count)\n    {\n      return spawningFor[_proxy].length;\n    }\n\n    //  getSpawningFor(): get the points _proxy can spawn with\n    //\n    //    Note: only useful for clients, as Solidity does not currently\n    //    support returning dynamic arrays.\n    //\n    function getSpawningFor(address _proxy)\n      view\n      external\n      returns (uint32[] sfor)\n    {\n      return spawningFor[_proxy];\n    }\n\n    //  voting proxy\n\n    //  getVotingProxy(): returns _point's current voting proxy\n    //\n    function getVotingProxy(uint32 _point)\n      view\n      external\n      returns (address voter)\n    {\n      return rights[_point].votingProxy;\n    }\n\n    //  isVotingProxy(): returns true if _proxy is _point's voting proxy\n    //\n    function isVotingProxy(uint32 _point, address _proxy)\n      view\n      external\n      returns (bool result)\n    {\n      return (rights[_point].votingProxy == _proxy);\n    }\n\n    //  canVoteAs(): true if _who is the owner of _point,\n    //               or the voting proxy of _point's owner\n    //\n    function canVoteAs(uint32 _point, address _who)\n      view\n      external\n      returns (bool result)\n    {\n      Deed storage deed = rights[_point];\n      return ( (0x0 != _who) &&\n               ( (_who == deed.owner) ||\n                 (_who == deed.votingProxy) ) );\n    }\n\n    //  getVotingForCount(): returns the amount of points _proxy can vote as\n    //\n    function getVotingForCount(address _proxy)\n      view\n      external\n      returns (uint256 count)\n    {\n      return votingFor[_proxy].length;\n    }\n\n    //  getVotingFor(): returns the points _proxy can vote as\n    //\n    //    Note: only useful for clients, as Solidity does not currently\n    //    support returning dynamic arrays.\n    //\n    function getVotingFor(address _proxy)\n      view\n      external\n      returns (uint32[] vfor)\n    {\n      return votingFor[_proxy];\n    }\n\n    //  transfer proxy\n\n    //  getTransferProxy(): returns _point's current transfer proxy\n    //\n    function getTransferProxy(uint32 _point)\n      view\n      external\n      returns (address transferProxy)\n    {\n      return rights[_point].transferProxy;\n    }\n\n    //  isTransferProxy(): returns true if _proxy is _point's transfer proxy\n    //\n    function isTransferProxy(uint32 _point, address _proxy)\n      view\n      external\n      returns (bool result)\n    {\n      return (rights[_point].transferProxy == _proxy);\n    }\n\n    //  canTransfer(): true if _who is the owner or transfer proxy of _point,\n    //                 or is an operator for _point's current owner\n    //\n    function canTransfer(uint32 _point, address _who)\n      view\n      external\n      returns (bool result)\n    {\n      Deed storage deed = rights[_point];\n      return ( (0x0 != _who) &&\n               ( (_who == deed.owner) ||\n                 (_who == deed.transferProxy) ||\n                 operators[deed.owner][_who] ) );\n    }\n\n    //  getTransferringForCount(): returns the amount of points _proxy\n    //                             can transfer\n    //\n    function getTransferringForCount(address _proxy)\n      view\n      external\n      returns (uint256 count)\n    {\n      return transferringFor[_proxy].length;\n    }\n\n    //  getTransferringFor(): get the points _proxy can transfer\n    //\n    //    Note: only useful for clients, as Solidity does not currently\n    //    support returning dynamic arrays.\n    //\n    function getTransferringFor(address _proxy)\n      view\n      external\n      returns (uint32[] tfor)\n    {\n      return transferringFor[_proxy];\n    }\n\n    //  isOperator(): returns true if _operator is allowed to transfer\n    //                ownership of _owner's points\n    //\n    function isOperator(address _owner, address _operator)\n      view\n      external\n      returns (bool result)\n    {\n      return operators[_owner][_operator];\n    }\n\n  //\n  //  Deed writing\n  //\n\n    //  setOwner(): set owner of _point to _owner\n    //\n    //    Note: setOwner() only implements the minimal data storage\n    //    logic for a transfer; the full transfer is implemented in\n    //    Ecliptic.\n    //\n    //    Note: _owner must not be the zero address.\n    //\n    function setOwner(uint32 _point, address _owner)\n      onlyOwner\n      external\n    {\n      //  prevent burning of points by making zero the owner\n      //\n      require(0x0 != _owner);\n\n      //  prev: previous owner, if any\n      //\n      address prev = rights[_point].owner;\n\n      if (prev == _owner)\n      {\n        return;\n      }\n\n      //  if the point used to have a different owner, do some gymnastics to\n      //  keep the list of owned points gapless.  delete this point from the\n      //  list, then fill that gap with the list tail.\n      //\n      if (0x0 != prev)\n      {\n        //  i: current index in previous owner's list of owned points\n        //\n        uint256 i = pointOwnerIndexes[prev][_point];\n\n        //  we store index + 1, because 0 is the solidity default value\n        //\n        assert(i > 0);\n        i--;\n\n        //  copy the last item in the list into the now-unused slot,\n        //  making sure to update its :pointOwnerIndexes reference\n        //\n        uint32[] storage owner = pointsOwnedBy[prev];\n        uint256 last = owner.length - 1;\n        uint32 moved = owner[last];\n        owner[i] = moved;\n        pointOwnerIndexes[prev][moved] = i + 1;\n\n        //  delete the last item\n        //\n        delete(owner[last]);\n        owner.length = last;\n        pointOwnerIndexes[prev][_point] = 0;\n      }\n\n      //  update the owner list and the owner's index list\n      //\n      rights[_point].owner = _owner;\n      pointsOwnedBy[_owner].push(_point);\n      pointOwnerIndexes[_owner][_point] = pointsOwnedBy[_owner].length;\n      emit OwnerChanged(_point, _owner);\n    }\n\n    //  setManagementProxy(): makes _proxy _point's management proxy\n    //\n    function setManagementProxy(uint32 _point, address _proxy)\n      onlyOwner\n      external\n    {\n      Deed storage deed = rights[_point];\n      address prev = deed.managementProxy;\n      if (prev == _proxy)\n      {\n        return;\n      }\n\n      //  if the point used to have a different manager, do some gymnastics\n      //  to keep the reverse lookup gapless.  delete the point from the\n      //  old manager's list, then fill that gap with the list tail.\n      //\n      if (0x0 != prev)\n      {\n        //  i: current index in previous manager's list of managed points\n        //\n        uint256 i = managerForIndexes[prev][_point];\n\n        //  we store index + 1, because 0 is the solidity default value\n        //\n        assert(i > 0);\n        i--;\n\n        //  copy the last item in the list into the now-unused slot,\n        //  making sure to update its :managerForIndexes reference\n        //\n        uint32[] storage prevMfor = managerFor[prev];\n        uint256 last = prevMfor.length - 1;\n        uint32 moved = prevMfor[last];\n        prevMfor[i] = moved;\n        managerForIndexes[prev][moved] = i + 1;\n\n        //  delete the last item\n        //\n        delete(prevMfor[last]);\n        prevMfor.length = last;\n        managerForIndexes[prev][_point] = 0;\n      }\n\n      if (0x0 != _proxy)\n      {\n        uint32[] storage mfor = managerFor[_proxy];\n        mfor.push(_point);\n        managerForIndexes[_proxy][_point] = mfor.length;\n      }\n\n      deed.managementProxy = _proxy;\n      emit ChangedManagementProxy(_point, _proxy);\n    }\n\n    //  setSpawnProxy(): makes _proxy _point's spawn proxy\n    //\n    function setSpawnProxy(uint32 _point, address _proxy)\n      onlyOwner\n      external\n    {\n      Deed storage deed = rights[_point];\n      address prev = deed.spawnProxy;\n      if (prev == _proxy)\n      {\n        return;\n      }\n\n      //  if the point used to have a different spawn proxy, do some\n      //  gymnastics to keep the reverse lookup gapless.  delete the point\n      //  from the old proxy's list, then fill that gap with the list tail.\n      //\n      if (0x0 != prev)\n      {\n        //  i: current index in previous proxy's list of spawning points\n        //\n        uint256 i = spawningForIndexes[prev][_point];\n\n        //  we store index + 1, because 0 is the solidity default value\n        //\n        assert(i > 0);\n        i--;\n\n        //  copy the last item in the list into the now-unused slot,\n        //  making sure to update its :spawningForIndexes reference\n        //\n        uint32[] storage prevSfor = spawningFor[prev];\n        uint256 last = prevSfor.length - 1;\n        uint32 moved = prevSfor[last];\n        prevSfor[i] = moved;\n        spawningForIndexes[prev][moved] = i + 1;\n\n        //  delete the last item\n        //\n        delete(prevSfor[last]);\n        prevSfor.length = last;\n        spawningForIndexes[prev][_point] = 0;\n      }\n\n      if (0x0 != _proxy)\n      {\n        uint32[] storage sfor = spawningFor[_proxy];\n        sfor.push(_point);\n        spawningForIndexes[_proxy][_point] = sfor.length;\n      }\n\n      deed.spawnProxy = _proxy;\n      emit ChangedSpawnProxy(_point, _proxy);\n    }\n\n    //  setVotingProxy(): makes _proxy _point's voting proxy\n    //\n    function setVotingProxy(uint32 _point, address _proxy)\n      onlyOwner\n      external\n    {\n      Deed storage deed = rights[_point];\n      address prev = deed.votingProxy;\n      if (prev == _proxy)\n      {\n        return;\n      }\n\n      //  if the point used to have a different voter, do some gymnastics\n      //  to keep the reverse lookup gapless.  delete the point from the\n      //  old voter's list, then fill that gap with the list tail.\n      //\n      if (0x0 != prev)\n      {\n        //  i: current index in previous voter's list of points it was\n        //     voting for\n        //\n        uint256 i = votingForIndexes[prev][_point];\n\n        //  we store index + 1, because 0 is the solidity default value\n        //\n        assert(i > 0);\n        i--;\n\n        //  copy the last item in the list into the now-unused slot,\n        //  making sure to update its :votingForIndexes reference\n        //\n        uint32[] storage prevVfor = votingFor[prev];\n        uint256 last = prevVfor.length - 1;\n        uint32 moved = prevVfor[last];\n        prevVfor[i] = moved;\n        votingForIndexes[prev][moved] = i + 1;\n\n        //  delete the last item\n        //\n        delete(prevVfor[last]);\n        prevVfor.length = last;\n        votingForIndexes[prev][_point] = 0;\n      }\n\n      if (0x0 != _proxy)\n      {\n        uint32[] storage vfor = votingFor[_proxy];\n        vfor.push(_point);\n        votingForIndexes[_proxy][_point] = vfor.length;\n      }\n\n      deed.votingProxy = _proxy;\n      emit ChangedVotingProxy(_point, _proxy);\n    }\n\n    //  setManagementProxy(): makes _proxy _point's transfer proxy\n    //\n    function setTransferProxy(uint32 _point, address _proxy)\n      onlyOwner\n      external\n    {\n      Deed storage deed = rights[_point];\n      address prev = deed.transferProxy;\n      if (prev == _proxy)\n      {\n        return;\n      }\n\n      //  if the point used to have a different transfer proxy, do some\n      //  gymnastics to keep the reverse lookup gapless.  delete the point\n      //  from the old proxy's list, then fill that gap with the list tail.\n      //\n      if (0x0 != prev)\n      {\n        //  i: current index in previous proxy's list of transferable points\n        //\n        uint256 i = transferringForIndexes[prev][_point];\n\n        //  we store index + 1, because 0 is the solidity default value\n        //\n        assert(i > 0);\n        i--;\n\n        //  copy the last item in the list into the now-unused slot,\n        //  making sure to update its :transferringForIndexes reference\n        //\n        uint32[] storage prevTfor = transferringFor[prev];\n        uint256 last = prevTfor.length - 1;\n        uint32 moved = prevTfor[last];\n        prevTfor[i] = moved;\n        transferringForIndexes[prev][moved] = i + 1;\n\n        //  delete the last item\n        //\n        delete(prevTfor[last]);\n        prevTfor.length = last;\n        transferringForIndexes[prev][_point] = 0;\n      }\n\n      if (0x0 != _proxy)\n      {\n        uint32[] storage tfor = transferringFor[_proxy];\n        tfor.push(_point);\n        transferringForIndexes[_proxy][_point] = tfor.length;\n      }\n\n      deed.transferProxy = _proxy;\n      emit ChangedTransferProxy(_point, _proxy);\n    }\n\n    //  setOperator(): dis/allow _operator to transfer ownership of all points\n    //                 owned by _owner\n    //\n    //    operators are part of the ERC721 standard\n    //\n    function setOperator(address _owner, address _operator, bool _approved)\n      onlyOwner\n      external\n    {\n      operators[_owner][_operator] = _approved;\n    }\n}\n\n// Azimuth's ReadsAzimuth.sol\n\n//  ReadsAzimuth: referring to and testing against the Azimuth\n//                data contract\n//\n//    To avoid needless repetition, this contract provides common\n//    checks and operations using the Azimuth contract.\n//\ncontract ReadsAzimuth\n{\n  //  azimuth: points data storage contract.\n  //\n  Azimuth public azimuth;\n\n  //  constructor(): set the Azimuth data contract's address\n  //\n  constructor(Azimuth _azimuth)\n    public\n  {\n    azimuth = _azimuth;\n  }\n\n  //  activePointOwner(): require that :msg.sender is the owner of _point,\n  //                      and that _point is active\n  //\n  modifier activePointOwner(uint32 _point)\n  {\n    require( azimuth.isOwner(_point, msg.sender) &&\n             azimuth.isActive(_point) );\n    _;\n  }\n\n  //  activePointManager(): require that :msg.sender can manage _point,\n  //                        and that _point is active\n  //\n  modifier activePointManager(uint32 _point)\n  {\n    require( azimuth.canManage(_point, msg.sender) &&\n             azimuth.isActive(_point) );\n    _;\n  }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n//  Claims\n////////////////////////////////////////////////////////////////////////////////\n\n//  Claims: simple identity management\n//\n//    This contract allows points to document claims about their owner.\n//    Most commonly, these are about identity, with a claim's protocol\n//    defining the context or platform of the claim, and its dossier\n//    containing proof of its validity.\n//    Points are limited to a maximum of 16 claims.\n//\n//    For existing claims, the dossier can be updated, or the claim can\n//    be removed entirely. It is recommended to remove any claims associated\n//    with a point when it is about to be transferred to a new owner.\n//    For convenience, the owner of the Azimuth contract (the Ecliptic)\n//    is allowed to clear claims for any point, allowing it to do this for\n//    you on-transfer.\n//\ncontract Claims is ReadsAzimuth\n{\n  //  ClaimAdded: a claim was added by :by\n  //\n  event ClaimAdded( uint32 indexed by,\n                    string _protocol,\n                    string _claim,\n                    bytes _dossier );\n\n  //  ClaimRemoved: a claim was removed by :by\n  //\n  event ClaimRemoved(uint32 indexed by, string _protocol, string _claim);\n\n  //  maxClaims: the amount of claims that can be registered per point\n  //\n  uint8 constant maxClaims = 16;\n\n  //  Claim: claim details\n  //\n  struct Claim\n  {\n    //  protocol: context of the claim\n    //\n    string protocol;\n\n    //  claim: the claim itself\n    //\n    string claim;\n\n    //  dossier: data relating to the claim, as proof\n    //\n    bytes dossier;\n  }\n\n  //  per point, list of claims\n  //\n  mapping(uint32 => Claim[maxClaims]) public claims;\n\n  //  constructor(): register the azimuth contract.\n  //\n  constructor(Azimuth _azimuth)\n    ReadsAzimuth(_azimuth)\n    public\n  {\n    //\n  }\n\n  //  addClaim(): register a claim as _point\n  //\n  function addClaim(uint32 _point,\n                    string _protocol,\n                    string _claim,\n                    bytes _dossier)\n    external\n    activePointManager(_point)\n  {\n    //  cur: index + 1 of the claim if it already exists, 0 otherwise\n    //\n    uint8 cur = findClaim(_point, _protocol, _claim);\n\n    //  if the claim doesn't yet exist, store it in state\n    //\n    if (cur == 0)\n    {\n      //  if there are no empty slots left, this throws\n      //\n      uint8 empty = findEmptySlot(_point);\n      claims[_point][empty] = Claim(_protocol, _claim, _dossier);\n    }\n    //\n    //  if the claim has been made before, update the version in state\n    //\n    else\n    {\n      claims[_point][cur-1] = Claim(_protocol, _claim, _dossier);\n    }\n    emit ClaimAdded(_point, _protocol, _claim, _dossier);\n  }\n\n  //  removeClaim(): unregister a claim as _point\n  //\n  function removeClaim(uint32 _point, string _protocol, string _claim)\n    external\n    activePointManager(_point)\n  {\n    //  i: current index + 1 in _point's list of claims\n    //\n    uint256 i = findClaim(_point, _protocol, _claim);\n\n    //  we store index + 1, because 0 is the eth default value\n    //  can only delete an existing claim\n    //\n    require(i > 0);\n    i--;\n\n    //  clear out the claim\n    //\n    delete claims[_point][i];\n\n    emit ClaimRemoved(_point, _protocol, _claim);\n  }\n\n  //  clearClaims(): unregister all of _point's claims\n  //\n  //    can also be called by the ecliptic during point transfer\n  //\n  function clearClaims(uint32 _point)\n    external\n  {\n    //  both point owner and ecliptic may do this\n    //\n    //    We do not necessarily need to check for _point's active flag here,\n    //    since inactive points cannot have claims set. Doing the check\n    //    anyway would make this function slightly harder to think about due\n    //    to its relation to Ecliptic's transferPoint().\n    //\n    require( azimuth.canManage(_point, msg.sender) ||\n             ( msg.sender == azimuth.owner() ) );\n\n    Claim[maxClaims] storage currClaims = claims[_point];\n\n    //  clear out all claims\n    //\n    for (uint8 i = 0; i < maxClaims; i++)\n    {\n      delete currClaims[i];\n    }\n  }\n\n  //  findClaim(): find the index of the specified claim\n  //\n  //    returns 0 if not found, index + 1 otherwise\n  //\n  function findClaim(uint32 _whose, string _protocol, string _claim)\n    public\n    view\n    returns (uint8 index)\n  {\n    //  we use hashes of the string because solidity can't do string\n    //  comparison yet\n    //\n    bytes32 protocolHash = keccak256(bytes(_protocol));\n    bytes32 claimHash = keccak256(bytes(_claim));\n    Claim[maxClaims] storage theirClaims = claims[_whose];\n    for (uint8 i = 0; i < maxClaims; i++)\n    {\n      Claim storage thisClaim = theirClaims[i];\n      if ( ( protocolHash == keccak256(bytes(thisClaim.protocol)) ) &&\n           ( claimHash == keccak256(bytes(thisClaim.claim)) ) )\n      {\n        return i+1;\n      }\n    }\n    return 0;\n  }\n\n  //  findEmptySlot(): find the index of the first empty claim slot\n  //\n  //    returns the index of the slot, throws if there are no empty slots\n  //\n  function findEmptySlot(uint32 _whose)\n    internal\n    view\n    returns (uint8 index)\n  {\n    Claim[maxClaims] storage theirClaims = claims[_whose];\n    for (uint8 i = 0; i < maxClaims; i++)\n    {\n      Claim storage thisClaim = theirClaims[i];\n      if ( (0 == bytes(thisClaim.protocol).length) &&\n           (0 == bytes(thisClaim.claim).length) )\n      {\n        return i;\n      }\n    }\n    revert();\n  }\n}",
  "abi": "[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint32\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"claims\",\"outputs\":[{\"name\":\"protocol\",\"type\":\"string\"},{\"name\":\"claim\",\"type\":\"string\"},{\"name\":\"dossier\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_whose\",\"type\":\"uint32\"},{\"name\":\"_protocol\",\"type\":\"string\"},{\"name\":\"_claim\",\"type\":\"string\"}],\"name\":\"findClaim\",\"outputs\":[{\"name\":\"index\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_point\",\"type\":\"uint32\"},{\"name\":\"_protocol\",\"type\":\"string\"},{\"name\":\"_claim\",\"type\":\"string\"}],\"name\":\"removeClaim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"azimuth\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_point\",\"type\":\"uint32\"}],\"name\":\"clearClaims\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_point\",\"type\":\"uint32\"},{\"name\":\"_protocol\",\"type\":\"string\"},{\"name\":\"_claim\",\"type\":\"string\"},{\"name\":\"_dossier\",\"type\":\"bytes\"}],\"name\":\"addClaim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_azimuth\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"by\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"_protocol\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_claim\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_dossier\",\"type\":\"bytes\"}],\"name\":\"ClaimAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"by\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"_protocol\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_claim\",\"type\":\"string\"}],\"name\":\"ClaimRemoved\",\"type\":\"event\"}]",
  "bytecode": "608060405234801561001057600080fd5b50604051602080611276833981016040525160008054600160a060020a03909216600160a060020a0319909216919091179055611224806100526000396000f3006080604052600436106100775763ffffffff7c01000000000000000000000000000000000000000000000000000000006000350416632906247e811461007c5780632945a57d146101e1578063296e366114610299578063d40ffacb146102d1578063eaae46e514610302578063fb1d820114610320575b600080fd5b34801561008857600080fd5b5061009d63ffffffff60043516602435610362565b60405180806020018060200180602001848103845287818151815260200191508051906020019080838360005b838110156100e25781810151838201526020016100ca565b50505050905090810190601f16801561010f5780820380516001836020036101000a031916815260200191505b50848103835286518152865160209182019188019080838360005b8381101561014257818101518382015260200161012a565b50505050905090810190601f16801561016f5780820380516001836020036101000a031916815260200191505b50848103825285518152855160209182019187019080838360005b838110156101a257818101518382015260200161018a565b50505050905090810190601f1680156101cf5780820380516001836020036101000a031916815260200191505b50965050505050505060405180910390f35b3480156101ed57600080fd5b5060408051602060046024803582810135601f810185900485028601850190965285855261028395833563ffffffff1695369560449491939091019190819084018382808284375050604080516020601f89358b018035918201839004830284018301909452808352979a9998810197919650918201945092508291508401838280828437509497506105449650505050505050565b6040805160ff9092168252519081900360200190f35b3480156102a557600080fd5b506102cf6004803563ffffffff169060248035808201929081013591604435908101910135610753565b005b3480156102dd57600080fd5b506102e66109ea565b60408051600160a060020a039092168252519081900360200190f35b34801561030e57600080fd5b506102cf63ffffffff600435166109f9565b34801561032c57600080fd5b506102cf6004803563ffffffff169060248035808201929081013591604435808201929081013591606435908101910135610bb9565b6001602052600082815260409020816010811061037b57fe5b600302018054604080516020601f60026000196101006001881615020190951694909404938401819004810282018101909252828152929450919250839183018282801561040a5780601f106103df5761010080835404028352916020019161040a565b820191906000526020600020905b8154815290600101906020018083116103ed57829003601f168201915b505050505090806001018054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156104a85780601f1061047d576101008083540402835291602001916104a8565b820191906000526020600020905b81548152906001019060200180831161048b57829003601f168201915b50505060028085018054604080516020601f600019610100600187161502019094169590950492830185900485028101850190915281815295969594509092509083018282801561053a5780601f1061050f5761010080835404028352916020019161053a565b820191906000526020600020905b81548152906001019060200180831161051d57829003601f168201915b5050505050905083565b600080600080600080876040518082805190602001908083835b6020831061057d5780518252601f19909201916020918201910161055e565b51815160209384036101000a60001901801990921691161790526040519190930181900381208c51909a508c95509093508392850191508083835b602083106105d75780518252601f1990920191602091820191016105b8565b51815160209384036101000a6000190180199092169116179052604080519290940182900390912063ffffffff8f16600090815260019092529281209298509196509094505050505b601060ff83161015610742578260ff83166010811061063b57fe5b6003020190508060000160405180828054600181600116156101000203166002900480156106a05780601f1061067e5761010080835404028352918201916106a0565b820191906000526020600020905b81548152906001019060200180831161068c575b50506040519081900390208714915050801561072757508060010160405180828054600181600116156101000203166002900480156107165780601f106106f4576101008083540402835291820191610716565b820191906000526020600020905b815481529060010190602001808311610702575b505060405190819003902086149150505b1561073757816001019550610747565b600190910190610620565b600095505b50505050509392505050565b60008054604080517f9137fe0a00000000000000000000000000000000000000000000000000000000815263ffffffff8916600482015233602482015290518892600160a060020a031691639137fe0a91604480830192602092919082900301818887803b1580156107c457600080fd5b505af11580156107d8573d6000803e3d6000fd5b505050506040513d60208110156107ee57600080fd5b50518015610891575060008054604080517f5e19b30500000000000000000000000000000000000000000000000000000000815263ffffffff851660048201529051600160a060020a0390921692635e19b305926024808401936020939083900390910190829087803b15801561086457600080fd5b505af1158015610878573d6000803e3d6000fd5b505050506040513d602081101561088e57600080fd5b50515b151561089c57600080fd5b6109048787878080601f0160208091040260200160405190810160405280939291908181526020018383808284375050604080516020601f8d018190048102820181019092528b815294508b93508a9250829150840183828082843750610544945050505050565b60ff1691506000821161091657600080fd5b63ffffffff8716600090815260016020526040902060001990920191826010811061093d57fe5b60030201600061094d8282611116565b61095b600183016000611116565b610969600283016000611116565b50508663ffffffff167fdd924d662463d64f1eaae95a37d26f5bbbf9bbe2443adb897397e8b57c0b05138787878760405180806020018060200183810383528787828181526020019250808284379091018481038352858152602001905085858082843760405192018290039850909650505050505050a250505050505050565b600054600160a060020a031681565b60008054604080517f9137fe0a00000000000000000000000000000000000000000000000000000000815263ffffffff8516600482015233602482015290518392600160a060020a031691639137fe0a91604480830192602092919082900301818787803b158015610a6a57600080fd5b505af1158015610a7e573d6000803e3d6000fd5b505050506040513d6020811015610a9457600080fd5b505180610b3f57506000809054906101000a9004600160a060020a0316600160a060020a0316638da5cb5b6040518163ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401602060405180830381600087803b158015610b0757600080fd5b505af1158015610b1b573d6000803e3d6000fd5b505050506040513d6020811015610b3157600080fd5b5051600160a060020a031633145b1515610b4a57600080fd5b505063ffffffff81166000908152600160205260408120905b601060ff82161015610bb4578160ff821660108110610b7e57fe5b600302016000610b8e8282611116565b610b9c600183016000611116565b610baa600283016000611116565b5050600101610b63565b505050565b60008054604080517f9137fe0a00000000000000000000000000000000000000000000000000000000815263ffffffff8b166004820152336024820152905183928b92600160a060020a0390911691639137fe0a9160448082019260209290919082900301818887803b158015610c2f57600080fd5b505af1158015610c43573d6000803e3d6000fd5b505050506040513d6020811015610c5957600080fd5b50518015610cfc575060008054604080517f5e19b30500000000000000000000000000000000000000000000000000000000815263ffffffff851660048201529051600160a060020a0390921692635e19b305926024808401936020939083900390910190829087803b158015610ccf57600080fd5b505af1158015610ce3573d6000803e3d6000fd5b505050506040513d6020811015610cf957600080fd5b50515b1515610d0757600080fd5b610d748a8a8a8080601f01602080910402602001604051908101604052809392919081815260200183838082843782019150505050505089898080601f01602080910402602001604051908101604052809392919081815260200183838082843750610544945050505050565b925060ff83161515610eb657610d898a611082565b6040805160806020601f8d018190040282018101909252606081018b81529294509182918c908c9081908501838280828437820191505050505050815260200188888080601f016020809104026020016040519081016040528093929190818152602001838380828437820191505050505050815260200186868080601f0160208091040260200160405190810160405280939291908181526020018383808284375050509290935250505063ffffffff8b16600090815260016020526040902060ff841660108110610e5857fe5b600302016000820151816000019080519060200190610e7892919061115d565b506020828101518051610e91926001850192019061115d565b5060408201518051610ead91600284019160209091019061115d565b50905050610fe1565b6040805160806020601f8c018190040282018101909252606081018a815290918291908c908c9081908501838280828437820191505050505050815260200188888080601f016020809104026020016040519081016040528093929190818152602001838380828437820191505050505050815260200186868080601f0160208091040260200160405190810160405280939291908181526020018383808284375050509290935250505063ffffffff8b16600090815260016020526040902060ff60001986011660108110610f8857fe5b600302016000820151816000019080519060200190610fa892919061115d565b506020828101518051610fc1926001850192019061115d565b5060408201518051610fdd91600284019160209091019061115d565b5050505b8963ffffffff167fef768946812a98aaa648b07282fa428f69903e34f6a38d8a9b208bd8ee53bb538a8a8a8a8a8a6040518080602001806020018060200184810384528a8a82818152602001925080828437909101858103845288815260200190508888808284379091018581038352868152602001905086868082843760405192018290039b50909950505050505050505050a250505050505050505050565b63ffffffff8116600090815260016020526040812081805b601060ff83161015610077578260ff8316601081106110b557fe5b600302018054909150600260001961010060018416150201909116041580156110f65750806001018054600181600116156101000203166002900490506000145b156111035781935061110e565b60019091019061109a565b505050919050565b50805460018160011615610100020316600290046000825580601f1061113c575061115a565b601f01602090049060005260206000209081019061115a91906111db565b50565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061119e57805160ff19168380011785556111cb565b828001600101855582156111cb579182015b828111156111cb5782518255916020019190600101906111b0565b506111d79291506111db565b5090565b6111f591905b808211156111d757600081556001016111e1565b905600a165627a7a72305820a2dc6e5815d038136b28a8205b46a452020aefefdae7cdad8fe2da4208bb75b70029000000000000000000000000223c067f8cf28ae173ee5cafea60ca44c335fecb",
  "constructorArguments": "000000000000000000000000223c067f8cf28ae173ee5cafea60ca44c335fecb"
}