{
  "address": "0x1c8654c680c3f18a3b3a0ee943d40848a9fffd0d",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "SuperCrowdsale",
  "compilerVersion": "v0.4.24+commit.e67f0147",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2019-01-15\n*/\n\npragma solidity ^0.4.24;\n\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address _who) public view returns (uint256);\n  function transfer(address _to, uint256 _value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (_a == 0) {\n      return 0;\n    }\n\n    c = _a * _b;\n    assert(c / _a == _b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = _a / _b;\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n    return _a / _b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    assert(_b <= _a);\n    return _a - _b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    c = _a + _b;\n    assert(c >= _a);\n    return c;\n  }\n}\n\ncontract ERC20 is ERC20Basic {\n  function allowance(address _owner, address _spender)\n    public view returns (uint256);\n\n  function transferFrom(address _from, address _to, uint256 _value)\n    public returns (bool);\n\n  function approve(address _spender, uint256 _value) public returns (bool);\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}\n\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) internal balances;\n\n  uint256 internal totalSupply_;\n\n  /**\n  * @dev Total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev Transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_value <= balances[msg.sender]);\n    require(_to != address(0));\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    emit Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256) {\n    return balances[_owner];\n  }\n\n}\n\nlibrary SafeERC20 {\n  function safeTransfer(\n    ERC20Basic _token,\n    address _to,\n    uint256 _value\n  )\n    internal\n  {\n    require(_token.transfer(_to, _value));\n  }\n\n  function safeTransferFrom(\n    ERC20 _token,\n    address _from,\n    address _to,\n    uint256 _value\n  )\n    internal\n  {\n    require(_token.transferFrom(_from, _to, _value));\n  }\n\n  function safeApprove(\n    ERC20 _token,\n    address _spender,\n    uint256 _value\n  )\n    internal\n  {\n    require(_token.approve(_spender, _value));\n  }\n}\n\ncontract DetailedERC20 is ERC20 {\n  string public name;\n  string public symbol;\n  uint8 public decimals;\n\n  constructor(string _name, string _symbol, uint8 _decimals) public {\n    name = _name;\n    symbol = _symbol;\n    decimals = _decimals;\n  }\n}\n\ncontract Crowdsale {\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20;\n\n  // The token being sold\n  ERC20 public token;\n\n  // Address where funds are collected\n  address public wallet;\n\n  // How many token units a buyer gets per wei.\n  // The rate is the conversion between wei and the smallest and indivisible token unit.\n  // So, if you are using a rate of 1 with a DetailedERC20 token with 3 decimals called TOK\n  // 1 wei will give you 1 unit, or 0.001 TOK.\n  uint256 internal rate;\n\n  // Amount of wei raised\n  uint256 public weiRaised;\n\n  /**\n   * Event for token purchase logging\n   * @param purchaser who paid for the tokens\n   * @param beneficiary who got the tokens\n   * @param value weis paid for purchase\n   * @param amount amount of tokens purchased\n   */\n  event TokenPurchase(\n    address indexed purchaser,\n    address indexed beneficiary,\n    uint256 value,\n    uint256 amount\n  );\n\n  /**\n   * @param _wallet Address where collected funds will be forwarded to\n   * @param _token Address of the token being sold\n   */\n  constructor(address _wallet, ERC20 _token) public {\n    require(_wallet != address(0));\n    require(_token != address(0));\n    wallet = _wallet;\n    token = _token;\n  }\n\n  // -----------------------------------------\n  // Crowdsale external interface\n  // -----------------------------------------\n\n  /**\n   * @dev fallback function ***DO NOT OVERRIDE***\n   */\n  function () external payable {\n    buyTokens(msg.sender);\n  }\n\n  /**\n   * @dev low level token purchase ***DO NOT OVERRIDE***\n   * @param _beneficiary Address performing the token purchase\n   */\n  function buyTokens(address _beneficiary) public payable {\n\n    uint256 weiAmount = msg.value;\n    _preValidatePurchase(_beneficiary, weiAmount);\n\n    // calculate token amount to be created\n    uint256 tokens = _getTokenAmount(weiAmount);\n\n    // update state\n    weiRaised = weiRaised.add(weiAmount);\n\n    _processPurchase(_beneficiary, tokens);\n    emit TokenPurchase(\n      msg.sender,\n      _beneficiary,\n      weiAmount,\n      tokens\n    );\n\n    _updatePurchasingState(_beneficiary, weiAmount);\n\n    _forwardFunds();\n    _postValidatePurchase(_beneficiary, weiAmount);\n  }\n\n  // -----------------------------------------\n  // Internal interface (extensible)\n  // -----------------------------------------\n\n  /**\n   * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use `super` in contracts that inherit from Crowdsale to extend their validations.\n   * Example from CappedCrowdsale.sol's _preValidatePurchase method: \n   *   super._preValidatePurchase(_beneficiary, _weiAmount);\n   *   require(weiRaised.add(_weiAmount) <= cap);\n   * @param _beneficiary Address performing the token purchase\n   * @param _weiAmount Value in wei involved in the purchase\n   */\n  function _preValidatePurchase(\n    address _beneficiary,\n    uint256 _weiAmount\n  )\n    internal\n  {\n    require(_beneficiary != address(0));\n    require(_weiAmount != 0);\n  }\n\n  /**\n   * @dev Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid conditions are not met.\n   * @param _beneficiary Address performing the token purchase\n   * @param _weiAmount Value in wei involved in the purchase\n   */\n  function _postValidatePurchase(\n    address _beneficiary,\n    uint256 _weiAmount\n  )\n    internal\n  {\n    // optional override\n  }\n\n  /**\n   * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.\n   * @param _beneficiary Address performing the token purchase\n   * @param _tokenAmount Number of tokens to be emitted\n   */\n  function _deliverTokens(\n    address _beneficiary,\n    uint256 _tokenAmount\n  )\n    internal\n  {\n    token.safeTransfer(_beneficiary, _tokenAmount);\n  }\n\n  /**\n   * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.\n   * @param _beneficiary Address receiving the tokens\n   * @param _tokenAmount Number of tokens to be purchased\n   */\n  function _processPurchase(\n    address _beneficiary,\n    uint256 _tokenAmount\n  )\n    internal\n  {\n    _deliverTokens(_beneficiary, _tokenAmount);\n  }\n\n  /**\n   * @dev Override for extensions that require an internal state to check for validity (current user contributions, etc.)\n   * @param _beneficiary Address receiving the tokens\n   * @param _weiAmount Value in wei involved in the purchase\n   */\n  function _updatePurchasingState(\n    address _beneficiary,\n    uint256 _weiAmount\n  )\n    internal\n  {\n    // optional override\n  }\n\n  /**\n   * @dev Override to extend the way in which ether is converted to tokens.\n   * @param _weiAmount Value in wei to be converted into tokens\n   * @return Number of tokens that can be purchased with the specified _weiAmount\n   */\n  function _getTokenAmount(uint256 _weiAmount)\n    internal view returns (uint256)\n  {\n    return _weiAmount.mul(rate);\n  }\n\n  /**\n   * @dev Determines how ETH is stored/forwarded on purchases.\n   */\n  function _forwardFunds() internal {\n    wallet.transfer(msg.value);\n  }\n}\n\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  )\n    public\n    returns (bool)\n  {\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n    require(_to != address(0));\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    emit Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    emit Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(\n    address _owner,\n    address _spender\n   )\n    public\n    view\n    returns (uint256)\n  {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(\n    address _spender,\n    uint256 _addedValue\n  )\n    public\n    returns (bool)\n  {\n    allowed[msg.sender][_spender] = (\n      allowed[msg.sender][_spender].add(_addedValue));\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(\n    address _spender,\n    uint256 _subtractedValue\n  )\n    public\n    returns (bool)\n  {\n    uint256 oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue >= oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\ncontract CappedCrowdsale is Crowdsale {\n  using SafeMath for uint256;\n\n  uint256 public cap;\n\n  /**\n   * @dev Constructor, takes maximum amount of wei accepted in the crowdsale.\n   * @param _cap Max amount of wei to be contributed\n   */\n  constructor(uint256 _cap) public {\n    require(_cap > 0);\n    cap = _cap;\n  }\n\n  /**\n   * @dev Checks whether the cap has been reached.\n   * @return Whether the cap was reached\n   */\n  function capReached() public view returns (bool) {\n    return weiRaised >= cap;\n  }\n\n  /**\n   * @dev Extend parent behavior requiring purchase to respect the funding cap.\n   * @param _beneficiary Token purchaser\n   * @param _weiAmount Amount of wei contributed\n   */\n  function _preValidatePurchase(\n    address _beneficiary,\n    uint256 _weiAmount\n  )\n    internal\n  {\n    super._preValidatePurchase(_beneficiary, _weiAmount);\n    require(weiRaised.add(_weiAmount) <= cap);\n  }\n\n}\n\ncontract SANDER1 is StandardToken, DetailedERC20 {\n\n    /**\n    * 12 tokens equal 12 songs equal 1 album\n    * uint256 supply\n    */\n    uint256 internal supply = 12 * 1 ether;\n\n    constructor () \n        public \n        DetailedERC20 (\n            \"Super Ander Token 1\",\n            \"SANDER1\", \n            18\n        ) \n    {\n        totalSupply_ = supply;\n        balances[msg.sender] = supply;\n        emit Transfer(0x0, msg.sender, totalSupply_);\n    }\n}\ncontract SuperCrowdsale is CappedCrowdsale {\n    \n    using SafeERC20 for SANDER1;\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    address public owner;\n    SANDER1 public token;\n    uint256 internal weiAmount;\n\n    event ProcessedRemainder(uint256 remainder);\n\n    constructor (\n        SANDER1 _token, // sander1.superander.eth\n        address _wallet // wallet.superander.eth\n    ) public \n        Crowdsale(\n            _wallet,\n            _token\n        ) \n        CappedCrowdsale(\n            4145880000000000000000 // 4145.88 ETH\n        ) \n    {\n        owner = msg.sender;\n        token = _token;\n    }\n\n    /**\n   * @dev low level token purchase ***DO NOT OVERRIDE***\n   * @param _beneficiary Address performing the token purchase\n   */\n    function buyTokens(address _beneficiary) public payable {\n        weiAmount = msg.value;\n        // if wei raised equals total cap, stop the crowdsale.\n        _preValidatePurchase(_beneficiary, weiAmount);\n        uint256 tokens = getTokenAmount(weiAmount);\n        _processPurchase(_beneficiary, tokens);\n        emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);\n        _updatePurchasingState(_beneficiary, weiAmount);\n        _forwardFunds();\n        weiRaised = weiRaised.add(weiAmount);\n        _postValidatePurchase(_beneficiary, weiAmount);\n        weiAmount = 0;\n    }\n\n    /**\n    * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.\n    * @param _beneficiary Address performing the token purchase\n    * @param _tokenAmount Number of tokens to be emitted\n    */\n    function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {\n        token.safeTransferFrom(owner, _beneficiary, _tokenAmount);\n    }\n\n    /**\n       * @dev Override to extend the way in which ether is converted to tokens.\n       * @param _weiAmount Value in wei to be converted into tokens\n       * @return Number of tokens that can be purchased with the specified _weiAmount\n   */\n    function getTokenAmount(uint256 _weiAmount) public view returns (uint256) {\n        return _weiAmount.mul(token.allowance(owner, address(this))).div(cap);\n    }\n}",
  "bytecode": "608060405234801561001057600080fd5b5060405160408061060383398101604052805160209091015168e0bfa4962fb47c00008183600160a060020a038216151561004a57600080fd5b600160a060020a038116151561005f57600080fd5b60018054600160a060020a03938416600160a060020a03199182161790915560008054929093169116178155811161009657600080fd5b600455506005805433600160a060020a03199182161790915560068054909116600160a060020a039290921691909117905561052c806100d76000396000f30060806040526004361061008d5763ffffffff7c0100000000000000000000000000000000000000000000000000000000600035041663355274ea81146100985780634042b66f146100bf5780634f935945146100d4578063521eb273146100fd5780638da5cb5b1461012e578063c2507ac114610143578063ec8ac4d81461015b578063fc0c546a1461016f575b61009633610184565b005b3480156100a457600080fd5b506100ad61023c565b60408051918252519081900360200190f35b3480156100cb57600080fd5b506100ad610242565b3480156100e057600080fd5b506100e9610248565b604080519115158252519081900360200190f35b34801561010957600080fd5b50610112610253565b60408051600160a060020a039092168252519081900360200190f35b34801561013a57600080fd5b50610112610262565b34801561014f57600080fd5b506100ad600435610271565b610096600160a060020a0360043516610184565b34801561017b57600080fd5b5061011261033b565b6000346007819055506101998260075461034a565b6101a4600754610271565b90506101b08282610379565b60075460408051918252602082018390528051600160a060020a0385169233927f623b3804fa71d67900d064613da8f94b9617215ee90799290593e1745087ad1892918290030190a361020582600754610375565b61020d610383565b6007546003546102229163ffffffff6103bf16565b600355600754610233908390610375565b50506000600755565b60045481565b60035481565b600454600354101590565b600154600160a060020a031681565b600554600160a060020a031681565b60048054600654600554604080517fdd62ed3e000000000000000000000000000000000000000000000000000000008152600160a060020a039283169581019590955230602486015251600094610335949361032993169163dd62ed3e9160448082019260209290919082900301818a87803b1580156102f057600080fd5b505af1158015610304573d6000803e3d6000fd5b505050506040513d602081101561031a57600080fd5b5051859063ffffffff6103cc16565b9063ffffffff6103f516565b92915050565b600654600160a060020a031681565b610354828261040a565b60045460035461036a908363ffffffff6103bf16565b111561037557600080fd5b5050565b610375828261042b565b600154604051600160a060020a03909116903480156108fc02916000818181858888f193505050501580156103bc573d6000803e3d6000fd5b50565b8181018281101561033557fe5b60008215156103dd57506000610335565b508181028183828115156103ed57fe5b041461033557fe5b6000818381151561040257fe5b049392505050565b600160a060020a038216151561041f57600080fd5b80151561037557600080fd5b60055460065461037591600160a060020a039182169116848463ffffffff61044f16565b604080517f23b872dd000000000000000000000000000000000000000000000000000000008152600160a060020a0385811660048301528481166024830152604482018490529151918616916323b872dd916064808201926020929091908290030181600087803b1580156104c357600080fd5b505af11580156104d7573d6000803e3d6000fd5b505050506040513d60208110156104ed57600080fd5b505115156104fa57600080fd5b505050505600a165627a7a72305820d7722c8c1aa7fe083c4b72d15329e158b0886bd11fc6ab219d47b3676c61a0fa0029000000000000000000000000c9a593f0c87ffeaf9046aefe33a86c64cc98769d00000000000000000000000024b2e8c86cc5a378b184b64728db1a8484d844ec",
  "constructorArguments": "000000000000000000000000c9a593f0c87ffeaf9046aefe33a86c64cc98769d00000000000000000000000024b2e8c86cc5a378b184b64728db1a8484d844ec"
}