{
  "address": "0x1f5b7179a643570effb4da05a0ca0760b36ceed3",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "DaoStakeLocking",
  "compilerVersion": "v0.4.25+commit.59dbf8f1",
  "optimization": false,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2019-03-30\n*/\n\n// Full Contract Sources : https://github.com/DigixGlobal/dao-contracts\n// File: @digix/cacp-contracts-dao/contracts/ACOwned.sol\npragma solidity ^0.4.25;\n\n/// @title Owner based access control\n/// @author DigixGlobal\ncontract ACOwned {\n\n  address public owner;\n  address public new_owner;\n  bool is_ac_owned_init;\n\n  /// @dev Modifier to check if msg.sender is the contract owner\n  modifier if_owner() {\n    require(is_owner());\n    _;\n  }\n\n  function init_ac_owned()\n           internal\n           returns (bool _success)\n  {\n    if (is_ac_owned_init == false) {\n      owner = msg.sender;\n      is_ac_owned_init = true;\n    }\n    _success = true;\n  }\n\n  function is_owner()\n           private\n           constant\n           returns (bool _is_owner)\n  {\n    _is_owner = (msg.sender == owner);\n  }\n\n  function change_owner(address _new_owner)\n           if_owner()\n           public\n           returns (bool _success)\n  {\n    new_owner = _new_owner;\n    _success = true;\n  }\n\n  function claim_ownership()\n           public\n           returns (bool _success)\n  {\n    require(msg.sender == new_owner);\n    owner = new_owner;\n    _success = true;\n  }\n\n}\n\n// File: @digix/cacp-contracts-dao/contracts/Constants.sol\npragma solidity ^0.4.25;\n\n/// @title Some useful constants\n/// @author DigixGlobal\ncontract Constants {\n  address constant NULL_ADDRESS = address(0x0);\n  uint256 constant ZERO = uint256(0);\n  bytes32 constant EMPTY = bytes32(0x0);\n}\n\n// File: @digix/cacp-contracts-dao/contracts/ContractResolver.sol\npragma solidity ^0.4.25;\n\n/// @title Contract Name Registry\n/// @author DigixGlobal\ncontract ContractResolver is ACOwned, Constants {\n\n  mapping (bytes32 => address) contracts;\n  bool public locked_forever;\n\n  modifier unless_registered(bytes32 _key) {\n    require(contracts[_key] == NULL_ADDRESS);\n    _;\n  }\n\n  modifier if_owner_origin() {\n    require(tx.origin == owner);\n    _;\n  }\n\n  /// Function modifier to check if msg.sender corresponds to the resolved address of a given key\n  /// @param _contract The resolver key\n  modifier if_sender_is(bytes32 _contract) {\n    require(msg.sender == get_contract(_contract));\n    _;\n  }\n\n  modifier if_not_locked() {\n    require(locked_forever == false);\n    _;\n  }\n\n  /// @dev ContractResolver constructor will perform the following: 1. Set msg.sender as the contract owner.\n  constructor() public\n  {\n    require(init_ac_owned());\n    locked_forever = false;\n  }\n\n  /// @dev Called at contract initialization\n  /// @param _key bytestring for CACP name\n  /// @param _contract_address The address of the contract to be registered\n  /// @return _success if the operation is successful\n  function init_register_contract(bytes32 _key, address _contract_address)\n           if_owner_origin()\n           if_not_locked()\n           unless_registered(_key)\n           public\n           returns (bool _success)\n  {\n    require(_contract_address != NULL_ADDRESS);\n    contracts[_key] = _contract_address;\n    _success = true;\n  }\n\n  /// @dev Lock the resolver from any further modifications.  This can only be called from the owner\n  /// @return _success if the operation is successful\n  function lock_resolver_forever()\n           if_owner\n           public\n           returns (bool _success)\n  {\n    locked_forever = true;\n    _success = true;\n  }\n\n  /// @dev Get address of a contract\n  /// @param _key the bytestring name of the contract to look up\n  /// @return _contract the address of the contract\n  function get_contract(bytes32 _key)\n           public\n           view\n           returns (address _contract)\n  {\n    require(contracts[_key] != NULL_ADDRESS);\n    _contract = contracts[_key];\n  }\n\n}\n\n// File: @digix/cacp-contracts-dao/contracts/ResolverClient.sol\npragma solidity ^0.4.25;\n\n/// @title Contract Resolver Interface\n/// @author DigixGlobal\ncontract ResolverClient {\n\n  /// The address of the resolver contract for this project\n  address public resolver;\n  bytes32 public key;\n\n  /// Make our own address available to us as a constant\n  address public CONTRACT_ADDRESS;\n\n  /// Function modifier to check if msg.sender corresponds to the resolved address of a given key\n  /// @param _contract The resolver key\n  modifier if_sender_is(bytes32 _contract) {\n    require(sender_is(_contract));\n    _;\n  }\n\n  function sender_is(bytes32 _contract) internal view returns (bool _isFrom) {\n    _isFrom = msg.sender == ContractResolver(resolver).get_contract(_contract);\n  }\n\n  modifier if_sender_is_from(bytes32[3] _contracts) {\n    require(sender_is_from(_contracts));\n    _;\n  }\n\n  function sender_is_from(bytes32[3] _contracts) internal view returns (bool _isFrom) {\n    uint256 _n = _contracts.length;\n    for (uint256 i = 0; i < _n; i++) {\n      if (_contracts[i] == bytes32(0x0)) continue;\n      if (msg.sender == ContractResolver(resolver).get_contract(_contracts[i])) {\n        _isFrom = true;\n        break;\n      }\n    }\n  }\n\n  /// Function modifier to check resolver's locking status.\n  modifier unless_resolver_is_locked() {\n    require(is_locked() == false);\n    _;\n  }\n\n  /// @dev Initialize new contract\n  /// @param _key the resolver key for this contract\n  /// @return _success if the initialization is successful\n  function init(bytes32 _key, address _resolver)\n           internal\n           returns (bool _success)\n  {\n    bool _is_locked = ContractResolver(_resolver).locked_forever();\n    if (_is_locked == false) {\n      CONTRACT_ADDRESS = address(this);\n      resolver = _resolver;\n      key = _key;\n      require(ContractResolver(resolver).init_register_contract(key, CONTRACT_ADDRESS));\n      _success = true;\n    }  else {\n      _success = false;\n    }\n  }\n\n  /// @dev Check if resolver is locked\n  /// @return _locked if the resolver is currently locked\n  function is_locked()\n           private\n           view\n           returns (bool _locked)\n  {\n    _locked = ContractResolver(resolver).locked_forever();\n  }\n\n  /// @dev Get the address of a contract\n  /// @param _key the resolver key to look up\n  /// @return _contract the address of the contract\n  function get_contract(bytes32 _key)\n           public\n           view\n           returns (address _contract)\n  {\n    _contract = ContractResolver(resolver).get_contract(_key);\n  }\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\npragma solidity ^0.4.24;\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (_a == 0) {\n      return 0;\n    }\n\n    c = _a * _b;\n    assert(c / _a == _b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = _a / _b;\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n    return _a / _b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    assert(_b <= _a);\n    return _a - _b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    c = _a + _b;\n    assert(c >= _a);\n    return c;\n  }\n}\n\n// File: contracts/lib/MathHelper.sol\npragma solidity ^0.4.25;\n\nlibrary MathHelper {\n\n  using SafeMath for uint256;\n\n  function max(uint256 a, uint256 b) internal pure returns (uint256 _max){\n      _max = b;\n      if (a > b) {\n          _max = a;\n      }\n  }\n\n  function min(uint256 a, uint256 b) internal pure returns (uint256 _min){\n      _min = b;\n      if (a < b) {\n          _min = a;\n      }\n  }\n\n  function sumNumbers(uint256[] _numbers) internal pure returns (uint256 _sum) {\n      for (uint256 i=0;i<_numbers.length;i++) {\n          _sum = _sum.add(_numbers[i]);\n      }\n  }\n}\n\n// File: @digix/solidity-collections/contracts/abstract/AddressIteratorInteractive.sol\npragma solidity ^0.4.19;\n/**\n  @title Address Iterator Interactive\n  @author DigixGlobal Pte Ltd\n*/\ncontract AddressIteratorInteractive {\n\n  /**\n    @notice Lists a Address collection from start or end\n    @param _count Total number of Address items to return\n    @param _function_first Function that returns the First Address item in the list\n    @param _function_last Function that returns the last Address item in the list\n    @param _function_next Function that returns the Next Address item in the list\n    @param _function_previous Function that returns previous Address item in the list\n    @param _from_start whether to read from start (or end) of the list\n    @return {\"_address_items\" : \"Collection of reversed Address list\"}\n  */\n  function list_addresses(uint256 _count,\n                                 function () external constant returns (address) _function_first,\n                                 function () external constant returns (address) _function_last,\n                                 function (address) external constant returns (address) _function_next,\n                                 function (address) external constant returns (address) _function_previous,\n                                 bool _from_start)\n           internal\n           constant\n           returns (address[] _address_items)\n  {\n    if (_from_start) {\n      _address_items = private_list_addresses_from_address(_function_first(), _count, true, _function_last, _function_next);\n    } else {\n      _address_items = private_list_addresses_from_address(_function_last(), _count, true, _function_first, _function_previous);\n    }\n  }\n\n\n\n  /**\n    @notice Lists a Address collection from some `_current_item`, going forwards or backwards depending on `_from_start`\n    @param _current_item The current Item\n    @param _count Total number of Address items to return\n    @param _function_first Function that returns the First Address item in the list\n    @param _function_last Function that returns the last Address item in the list\n    @param _function_next Function that returns the Next Address item in the list\n    @param _function_previous Function that returns previous Address item in the list\n    @param _from_start whether to read in the forwards ( or backwards) direction\n    @return {\"_address_items\" :\"Collection/list of Address\"}\n  */\n  function list_addresses_from(address _current_item, uint256 _count,\n                                function () external constant returns (address) _function_first,\n                                function () external constant returns (address) _function_last,\n                                function (address) external constant returns (address) _function_next,\n                                function (address) external constant returns (address) _function_previous,\n                                bool _from_start)\n           internal\n           constant\n           returns (address[] _address_items)\n  {\n    if (_from_start) {\n      _address_items = private_list_addresses_from_address(_current_item, _count, false, _function_last, _function_next);\n    } else {\n      _address_items = private_list_addresses_from_address(_current_item, _count, false, _function_first, _function_previous);\n    }\n  }\n\n\n  /**\n    @notice a private function to lists a Address collection starting from some `_current_item` (which could be included or excluded), in the forwards or backwards direction\n    @param _current_item The current Item\n    @param _count Total number of Address items to return\n    @param _including_current Whether the `_current_item` should be included in the result\n    @param _function_last Function that returns the address where we stop reading more address\n    @param _function_next Function that returns the next address to read after some address (could be backwards or forwards in the physical collection)\n    @return {\"_address_items\" :\"Collection/list of Address\"}\n  */\n  function private_list_addresses_from_address(address _current_item, uint256 _count, bool _including_current,\n                                 function () external constant returns (address) _function_last,\n                                 function (address) external constant returns (address) _function_next)\n           private\n           constant\n           returns (address[] _address_items)\n  {\n    uint256 _i;\n    uint256 _real_count = 0;\n    address _last_item;\n\n    _last_item = _function_last();\n    if (_count == 0 || _last_item == address(0x0)) {\n      _address_items = new address[](0);\n    } else {\n      address[] memory _items_temp = new address[](_count);\n      address _this_item;\n      if (_including_current == true) {\n        _items_temp[0] = _current_item;\n        _real_count = 1;\n      }\n      _this_item = _current_item;\n      for (_i = _real_count; (_i < _count) && (_this_item != _last_item);_i++) {\n        _this_item = _function_next(_this_item);\n        if (_this_item != address(0x0)) {\n          _real_count++;\n          _items_temp[_i] = _this_item;\n        }\n      }\n\n      _address_items = new address[](_real_count);\n      for(_i = 0;_i < _real_count;_i++) {\n        _address_items[_i] = _items_temp[_i];\n      }\n    }\n  }\n\n\n  /** DEPRECATED\n    @notice private function to list a Address collection starting from the start or end of the list\n    @param _count Total number of Address item to return\n    @param _function_total Function that returns the Total number of Address item in the list\n    @param _function_first Function that returns the First Address item in the list\n    @param _function_next Function that returns the Next Address item in the list\n    @return {\"_address_items\" :\"Collection/list of Address\"}\n  */\n  /*function list_addresses_from_start_or_end(uint256 _count,\n                                 function () external constant returns (uint256) _function_total,\n                                 function () external constant returns (address) _function_first,\n                                 function (address) external constant returns (address) _function_next)\n\n           private\n           constant\n           returns (address[] _address_items)\n  {\n    uint256 _i;\n    address _current_item;\n    uint256 _real_count = _function_total();\n\n    if (_count > _real_count) {\n      _count = _real_count;\n    }\n\n    address[] memory _items_tmp = new address[](_count);\n\n    if (_count > 0) {\n      _current_item = _function_first();\n      _items_tmp[0] = _current_item;\n\n      for(_i = 1;_i <= (_count - 1);_i++) {\n        _current_item = _function_next(_current_item);\n        if (_current_item != address(0x0)) {\n          _items_tmp[_i] = _current_item;\n        }\n      }\n      _address_items = _items_tmp;\n    } else {\n      _address_items = new address[](0);\n    }\n  }*/\n\n  /** DEPRECATED\n    @notice a private function to lists a Address collection starting from some `_current_item`, could be forwards or backwards\n    @param _current_item The current Item\n    @param _count Total number of Address items to return\n    @param _function_last Function that returns the bytes where we stop reading more bytes\n    @param _function_next Function that returns the next bytes to read after some bytes (could be backwards or forwards in the physical collection)\n    @return {\"_address_items\" :\"Collection/list of Address\"}\n  */\n  /*function list_addresses_from_byte(address _current_item, uint256 _count,\n                                 function () external constant returns (address) _function_last,\n                                 function (address) external constant returns (address) _function_next)\n           private\n           constant\n           returns (address[] _address_items)\n  {\n    uint256 _i;\n    uint256 _real_count = 0;\n\n    if (_count == 0) {\n      _address_items = new address[](0);\n    } else {\n      address[] memory _items_temp = new address[](_count);\n\n      address _start_item;\n      address _last_item;\n\n      _last_item = _function_last();\n\n      if (_last_item != _current_item) {\n        _start_item = _function_next(_current_item);\n        if (_start_item != address(0x0)) {\n          _items_temp[0] = _start_item;\n          _real_count = 1;\n          for(_i = 1;(_i <= (_count - 1)) && (_start_item != _last_item);_i++) {\n            _start_item = _function_next(_start_item);\n            if (_start_item != address(0x0)) {\n              _real_count++;\n              _items_temp[_i] = _start_item;\n            }\n          }\n          _address_items = new address[](_real_count);\n          for(_i = 0;_i <= (_real_count - 1);_i++) {\n            _address_items[_i] = _items_temp[_i];\n          }\n        } else {\n          _address_items = new address[](0);\n        }\n      } else {\n        _address_items = new address[](0);\n      }\n    }\n  }*/\n\n}\n\n// File: @digix/solidity-collections/contracts/abstract/BytesIteratorInteractive.sol\npragma solidity ^0.4.19;\n/**\n  @title Bytes Iterator Interactive\n  @author DigixGlobal Pte Ltd\n*/\ncontract BytesIteratorInteractive {\n\n  /**\n    @notice Lists a Bytes collection from start or end\n    @param _count Total number of Bytes items to return\n    @param _function_first Function that returns the First Bytes item in the list\n    @param _function_last Function that returns the last Bytes item in the list\n    @param _function_next Function that returns the Next Bytes item in the list\n    @param _function_previous Function that returns previous Bytes item in the list\n    @param _from_start whether to read from start (or end) of the list\n    @return {\"_bytes_items\" : \"Collection of reversed Bytes list\"}\n  */\n  function list_bytesarray(uint256 _count,\n                                 function () external constant returns (bytes32) _function_first,\n                                 function () external constant returns (bytes32) _function_last,\n                                 function (bytes32) external constant returns (bytes32) _function_next,\n                                 function (bytes32) external constant returns (bytes32) _function_previous,\n                                 bool _from_start)\n           internal\n           constant\n           returns (bytes32[] _bytes_items)\n  {\n    if (_from_start) {\n      _bytes_items = private_list_bytes_from_bytes(_function_first(), _count, true, _function_last, _function_next);\n    } else {\n      _bytes_items = private_list_bytes_from_bytes(_function_last(), _count, true, _function_first, _function_previous);\n    }\n  }\n\n  /**\n    @notice Lists a Bytes collection from some `_current_item`, going forwards or backwards depending on `_from_start`\n    @param _current_item The current Item\n    @param _count Total number of Bytes items to return\n    @param _function_first Function that returns the First Bytes item in the list\n    @param _function_last Function that returns the last Bytes item in the list\n    @param _function_next Function that returns the Next Bytes item in the list\n    @param _function_previous Function that returns previous Bytes item in the list\n    @param _from_start whether to read in the forwards ( or backwards) direction\n    @return {\"_bytes_items\" :\"Collection/list of Bytes\"}\n  */\n  function list_bytesarray_from(bytes32 _current_item, uint256 _count,\n                                function () external constant returns (bytes32) _function_first,\n                                function () external constant returns (bytes32) _function_last,\n                                function (bytes32) external constant returns (bytes32) _function_next,\n                                function (bytes32) external constant returns (bytes32) _function_previous,\n                                bool _from_start)\n           internal\n           constant\n           returns (bytes32[] _bytes_items)\n  {\n    if (_from_start) {\n      _bytes_items = private_list_bytes_from_bytes(_current_item, _count, false, _function_last, _function_next);\n    } else {\n      _bytes_items = private_list_bytes_from_bytes(_current_item, _count, false, _function_first, _function_previous);\n    }\n  }\n\n  /**\n    @notice A private function to lists a Bytes collection starting from some `_current_item` (which could be included or excluded), in the forwards or backwards direction\n    @param _current_item The current Item\n    @param _count Total number of Bytes items to return\n    @param _including_current Whether the `_current_item` should be included in the result\n    @param _function_last Function that returns the bytes where we stop reading more bytes\n    @param _function_next Function that returns the next bytes to read after some bytes (could be backwards or forwards in the physical collection)\n    @return {\"_address_items\" :\"Collection/list of Bytes\"}\n  */\n  function private_list_bytes_from_bytes(bytes32 _current_item, uint256 _count, bool _including_current,\n                                 function () external constant returns (bytes32) _function_last,\n                                 function (bytes32) external constant returns (bytes32) _function_next)\n           private\n           constant\n           returns (bytes32[] _bytes32_items)\n  {\n    uint256 _i;\n    uint256 _real_count = 0;\n    bytes32 _last_item;\n\n    _last_item = _function_last();\n    if (_count == 0 || _last_item == bytes32(0x0)) {\n      _bytes32_items = new bytes32[](0);\n    } else {\n      bytes32[] memory _items_temp = new bytes32[](_count);\n      bytes32 _this_item;\n      if (_including_current == true) {\n        _items_temp[0] = _current_item;\n        _real_count = 1;\n      }\n      _this_item = _current_item;\n      for (_i = _real_count; (_i < _count) && (_this_item != _last_item);_i++) {\n        _this_item = _function_next(_this_item);\n        if (_this_item != bytes32(0x0)) {\n          _real_count++;\n          _items_temp[_i] = _this_item;\n        }\n      }\n\n      _bytes32_items = new bytes32[](_real_count);\n      for(_i = 0;_i < _real_count;_i++) {\n        _bytes32_items[_i] = _items_temp[_i];\n      }\n    }\n  }\n\n\n\n\n  ////// DEPRECATED FUNCTIONS (old versions)\n\n  /**\n    @notice a private function to lists a Bytes collection starting from some `_current_item`, could be forwards or backwards\n    @param _current_item The current Item\n    @param _count Total number of Bytes items to return\n    @param _function_last Function that returns the bytes where we stop reading more bytes\n    @param _function_next Function that returns the next bytes to read after some bytes (could be backwards or forwards in the physical collection)\n    @return {\"_bytes_items\" :\"Collection/list of Bytes\"}\n  */\n  /*function list_bytes_from_bytes(bytes32 _current_item, uint256 _count,\n                                 function () external constant returns (bytes32) _function_last,\n                                 function (bytes32) external constant returns (bytes32) _function_next)\n           private\n           constant\n           returns (bytes32[] _bytes_items)\n  {\n    uint256 _i;\n    uint256 _real_count = 0;\n\n    if (_count == 0) {\n      _bytes_items = new bytes32[](0);\n    } else {\n      bytes32[] memory _items_temp = new bytes32[](_count);\n\n      bytes32 _start_item;\n      bytes32 _last_item;\n\n      _last_item = _function_last();\n\n      if (_last_item != _current_item) {\n        _start_item = _function_next(_current_item);\n        if (_start_item != bytes32(0x0)) {\n          _items_temp[0] = _start_item;\n          _real_count = 1;\n          for(_i = 1;(_i <= (_count - 1)) && (_start_item != _last_item);_i++) {\n            _start_item = _function_next(_start_item);\n            if (_start_item != bytes32(0x0)) {\n              _real_count++;\n              _items_temp[_i] = _start_item;\n            }\n          }\n          _bytes_items = new bytes32[](_real_count);\n          for(_i = 0;_i <= (_real_count - 1);_i++) {\n            _bytes_items[_i] = _items_temp[_i];\n          }\n        } else {\n          _bytes_items = new bytes32[](0);\n        }\n      } else {\n        _bytes_items = new bytes32[](0);\n      }\n    }\n  }*/\n\n  /**\n    @notice private function to list a Bytes collection starting from the start or end of the list\n    @param _count Total number of Bytes item to return\n    @param _function_total Function that returns the Total number of Bytes item in the list\n    @param _function_first Function that returns the First Bytes item in the list\n    @param _function_next Function that returns the Next Bytes item in the list\n    @return {\"_bytes_items\" :\"Collection/list of Bytes\"}\n  */\n  /*function list_bytes_from_start_or_end(uint256 _count,\n                                 function () external constant returns (uint256) _function_total,\n                                 function () external constant returns (bytes32) _function_first,\n                                 function (bytes32) external constant returns (bytes32) _function_next)\n\n           private\n           constant\n           returns (bytes32[] _bytes_items)\n  {\n    uint256 _i;\n    bytes32 _current_item;\n    uint256 _real_count = _function_total();\n\n    if (_count > _real_count) {\n      _count = _real_count;\n    }\n\n    bytes32[] memory _items_tmp = new bytes32[](_count);\n\n    if (_count > 0) {\n      _current_item = _function_first();\n      _items_tmp[0] = _current_item;\n\n      for(_i = 1;_i <= (_count - 1);_i++) {\n        _current_item = _function_next(_current_item);\n        if (_current_item != bytes32(0x0)) {\n          _items_tmp[_i] = _current_item;\n        }\n      }\n      _bytes_items = _items_tmp;\n    } else {\n      _bytes_items = new bytes32[](0);\n    }\n  }*/\n}\n\n// File: @digix/solidity-collections/contracts/abstract/IndexedBytesIteratorInteractive.sol\npragma solidity ^0.4.19;\n\n/**\n  @title Indexed Bytes Iterator Interactive\n  @author DigixGlobal Pte Ltd\n*/\ncontract IndexedBytesIteratorInteractive {\n\n  /**\n    @notice Lists an indexed Bytes collection from start or end\n    @param _collection_index Index of the Collection to list\n    @param _count Total number of Bytes items to return\n    @param _function_first Function that returns the First Bytes item in the list\n    @param _function_last Function that returns the last Bytes item in the list\n    @param _function_next Function that returns the Next Bytes item in the list\n    @param _function_previous Function that returns previous Bytes item in the list\n    @param _from_start whether to read from start (or end) of the list\n    @return {\"_bytes_items\" : \"Collection of reversed Bytes list\"}\n  */\n  function list_indexed_bytesarray(bytes32 _collection_index, uint256 _count,\n                              function (bytes32) external constant returns (bytes32) _function_first,\n                              function (bytes32) external constant returns (bytes32) _function_last,\n                              function (bytes32, bytes32) external constant returns (bytes32) _function_next,\n                              function (bytes32, bytes32) external constant returns (bytes32) _function_previous,\n                              bool _from_start)\n           internal\n           constant\n           returns (bytes32[] _indexed_bytes_items)\n  {\n    if (_from_start) {\n      _indexed_bytes_items = private_list_indexed_bytes_from_bytes(_collection_index, _function_first(_collection_index), _count, true, _function_last, _function_next);\n    } else {\n      _indexed_bytes_items = private_list_indexed_bytes_from_bytes(_collection_index, _function_last(_collection_index), _count, true, _function_first, _function_previous);\n    }\n  }\n\n  /**\n    @notice Lists an indexed Bytes collection from some `_current_item`, going forwards or backwards depending on `_from_start`\n    @param _collection_index Index of the Collection to list\n    @param _current_item The current Item\n    @param _count Total number of Bytes items to return\n    @param _function_first Function that returns the First Bytes item in the list\n    @param _function_last Function that returns the last Bytes item in the list\n    @param _function_next Function that returns the Next Bytes item in the list\n    @param _function_previous Function that returns previous Bytes item in the list\n    @param _from_start whether to read in the forwards ( or backwards) direction\n    @return {\"_bytes_items\" :\"Collection/list of Bytes\"}\n  */\n  function list_indexed_bytesarray_from(bytes32 _collection_index, bytes32 _current_item, uint256 _count,\n                                function (bytes32) external constant returns (bytes32) _function_first,\n                                function (bytes32) external constant returns (bytes32) _function_last,\n                                function (bytes32, bytes32) external constant returns (bytes32) _function_next,\n                                function (bytes32, bytes32) external constant returns (bytes32) _function_previous,\n                                bool _from_start)\n           internal\n           constant\n           returns (bytes32[] _indexed_bytes_items)\n  {\n    if (_from_start) {\n      _indexed_bytes_items = private_list_indexed_bytes_from_bytes(_collection_index, _current_item, _count, false, _function_last, _function_next);\n    } else {\n      _indexed_bytes_items = private_list_indexed_bytes_from_bytes(_collection_index, _current_item, _count, false, _function_first, _function_previous);\n    }\n  }\n\n  /**\n    @notice a private function to lists an indexed Bytes collection starting from some `_current_item` (which could be included or excluded), in the forwards or backwards direction\n    @param _collection_index Index of the Collection to list\n    @param _current_item The item where we start reading from the list\n    @param _count Total number of Bytes items to return\n    @param _including_current Whether the `_current_item` should be included in the result\n    @param _function_last Function that returns the bytes where we stop reading more bytes\n    @param _function_next Function that returns the next bytes to read after another bytes (could be backwards or forwards in the physical collection)\n    @return {\"_bytes_items\" :\"Collection/list of Bytes\"}\n  */\n  function private_list_indexed_bytes_from_bytes(bytes32 _collection_index, bytes32 _current_item, uint256 _count, bool _including_current,\n                                         function (bytes32) external constant returns (bytes32) _function_last,\n                                         function (bytes32, bytes32) external constant returns (bytes32) _function_next)\n           private\n           constant\n           returns (bytes32[] _indexed_bytes_items)\n  {\n    uint256 _i;\n    uint256 _real_count = 0;\n    bytes32 _last_item;\n\n    _last_item = _function_last(_collection_index);\n    if (_count == 0 || _last_item == bytes32(0x0)) {  // if count is 0 or the collection is empty, returns empty array\n      _indexed_bytes_items = new bytes32[](0);\n    } else {\n      bytes32[] memory _items_temp = new bytes32[](_count);\n      bytes32 _this_item;\n      if (_including_current) {\n        _items_temp[0] = _current_item;\n        _real_count = 1;\n      }\n      _this_item = _current_item;\n      for (_i = _real_count; (_i < _count) && (_this_item != _last_item);_i++) {\n        _this_item = _function_next(_collection_index, _this_item);\n        if (_this_item != bytes32(0x0)) {\n          _real_count++;\n          _items_temp[_i] = _this_item;\n        }\n      }\n\n      _indexed_bytes_items = new bytes32[](_real_count);\n      for(_i = 0;_i < _real_count;_i++) {\n        _indexed_bytes_items[_i] = _items_temp[_i];\n      }\n    }\n  }\n\n\n  // old function, DEPRECATED\n  /*function list_indexed_bytes_from_bytes(bytes32 _collection_index, bytes32 _current_item, uint256 _count,\n                                         function (bytes32) external constant returns (bytes32) _function_last,\n                                         function (bytes32, bytes32) external constant returns (bytes32) _function_next)\n           private\n           constant\n           returns (bytes32[] _indexed_bytes_items)\n  {\n    uint256 _i;\n    uint256 _real_count = 0;\n    if (_count == 0) {\n      _indexed_bytes_items = new bytes32[](0);\n    } else {\n      bytes32[] memory _items_temp = new bytes32[](_count);\n\n      bytes32 _start_item;\n      bytes32 _last_item;\n\n      _last_item = _function_last(_collection_index);\n\n      if (_last_item != _current_item) {\n        _start_item = _function_next(_collection_index, _current_item);\n        if (_start_item != bytes32(0x0)) {\n          _items_temp[0] = _start_item;\n          _real_count = 1;\n          for(_i = 1;(_i <= (_count - 1)) && (_start_item != _last_item);_i++) {\n            _start_item = _function_next(_collection_index, _start_item);\n            if (_start_item != bytes32(0x0)) {\n              _real_count++;\n              _items_temp[_i] = _start_item;\n            }\n          }\n          _indexed_bytes_items = new bytes32[](_real_count);\n          for(_i = 0;_i <= (_real_count - 1);_i++) {\n            _indexed_bytes_items[_i] = _items_temp[_i];\n          }\n        } else {\n          _indexed_bytes_items = new bytes32[](0);\n        }\n      } else {\n        _indexed_bytes_items = new bytes32[](0);\n      }\n    }\n  }*/\n\n\n}\n\n// File: @digix/solidity-collections/contracts/lib/DoublyLinkedList.sol\npragma solidity ^0.4.19;\n\nlibrary DoublyLinkedList {\n\n  struct Item {\n    bytes32 item;\n    uint256 previous_index;\n    uint256 next_index;\n  }\n\n  struct Data {\n    uint256 first_index;\n    uint256 last_index;\n    uint256 count;\n    mapping(bytes32 => uint256) item_index;\n    mapping(uint256 => bool) valid_indexes;\n    Item[] collection;\n  }\n\n  struct IndexedUint {\n    mapping(bytes32 => Data) data;\n  }\n\n  struct IndexedAddress {\n    mapping(bytes32 => Data) data;\n  }\n\n  struct IndexedBytes {\n    mapping(bytes32 => Data) data;\n  }\n\n  struct Address {\n    Data data;\n  }\n\n  struct Bytes {\n    Data data;\n  }\n\n  struct Uint {\n    Data data;\n  }\n\n  uint256 constant NONE = uint256(0);\n  bytes32 constant EMPTY_BYTES = bytes32(0x0);\n  address constant NULL_ADDRESS = address(0x0);\n\n  function find(Data storage self, bytes32 _item)\n           public\n           constant\n           returns (uint256 _item_index)\n  {\n    if ((self.item_index[_item] == NONE) && (self.count == NONE)) {\n      _item_index = NONE;\n    } else {\n      _item_index = self.item_index[_item];\n    }\n  }\n\n  function get(Data storage self, uint256 _item_index)\n           public\n           constant\n           returns (bytes32 _item)\n  {\n    if (self.valid_indexes[_item_index] == true) {\n      _item = self.collection[_item_index - 1].item;\n    } else {\n      _item = EMPTY_BYTES;\n    }\n  }\n\n  function append(Data storage self, bytes32 _data)\n           internal\n           returns (bool _success)\n  {\n    if (find(self, _data) != NONE || _data == bytes32(\"\")) { // rejects addition of empty values\n      _success = false;\n    } else {\n      uint256 _index = uint256(self.collection.push(Item({item: _data, previous_index: self.last_index, next_index: NONE})));\n      if (self.last_index == NONE) {\n        if ((self.first_index != NONE) || (self.count != NONE)) {\n          revert();\n        } else {\n          self.first_index = self.last_index = _index;\n          self.count = 1;\n        }\n      } else {\n        self.collection[self.last_index - 1].next_index = _index;\n        self.last_index = _index;\n        self.count++;\n      }\n      self.valid_indexes[_index] = true;\n      self.item_index[_data] = _index;\n      _success = true;\n    }\n  }\n\n  function remove(Data storage self, uint256 _index)\n           internal\n           returns (bool _success)\n  {\n    if (self.valid_indexes[_index] == true) {\n      Item memory item = self.collection[_index - 1];\n      if (item.previous_index == NONE) {\n        self.first_index = item.next_index;\n      } else {\n        self.collection[item.previous_index - 1].next_index = item.next_index;\n      }\n\n      if (item.next_index == NONE) {\n        self.last_index = item.previous_index;\n      } else {\n        self.collection[item.next_index - 1].previous_index = item.previous_index;\n      }\n      delete self.collection[_index - 1];\n      self.valid_indexes[_index] = false;\n      delete self.item_index[item.item];\n      self.count--;\n      _success = true;\n    } else {\n      _success = false;\n    }\n  }\n\n  function remove_item(Data storage self, bytes32 _item)\n           internal\n           returns (bool _success)\n  {\n    uint256 _item_index = find(self, _item);\n    if (_item_index != NONE) {\n      require(remove(self, _item_index));\n      _success = true;\n    } else {\n      _success = false;\n    }\n    return _success;\n  }\n\n  function total(Data storage self)\n           public\n           constant\n           returns (uint256 _total_count)\n  {\n    _total_count = self.count;\n  }\n\n  function start(Data storage self)\n           public\n           constant\n           returns (uint256 _item_index)\n  {\n    _item_index = self.first_index;\n    return _item_index;\n  }\n\n  function start_item(Data storage self)\n           public\n           constant\n           returns (bytes32 _item)\n  {\n    uint256 _item_index = start(self);\n    if (_item_index != NONE) {\n      _item = get(self, _item_index);\n    } else {\n      _item = EMPTY_BYTES;\n    }\n  }\n\n  function end(Data storage self)\n           public\n           constant\n           returns (uint256 _item_index)\n  {\n    _item_index = self.last_index;\n    return _item_index;\n  }\n\n  function end_item(Data storage self)\n           public\n           constant\n           returns (bytes32 _item)\n  {\n    uint256 _item_index = end(self);\n    if (_item_index != NONE) {\n      _item = get(self, _item_index);\n    } else {\n      _item = EMPTY_BYTES;\n    }\n  }\n\n  function valid(Data storage self, uint256 _item_index)\n           public\n           constant\n           returns (bool _yes)\n  {\n    _yes = self.valid_indexes[_item_index];\n    //_yes = ((_item_index - 1) < self.collection.length);\n  }\n\n  function valid_item(Data storage self, bytes32 _item)\n           public\n           constant\n           returns (bool _yes)\n  {\n    uint256 _item_index = self.item_index[_item];\n    _yes = self.valid_indexes[_item_index];\n  }\n\n  function previous(Data storage self, uint256 _current_index)\n           public\n           constant\n           returns (uint256 _previous_index)\n  {\n    if (self.valid_indexes[_current_index] == true) {\n      _previous_index = self.collection[_current_index - 1].previous_index;\n    } else {\n      _previous_index = NONE;\n    }\n  }\n\n  function previous_item(Data storage self, bytes32 _current_item)\n           public\n           constant\n           returns (bytes32 _previous_item)\n  {\n    uint256 _current_index = find(self, _current_item);\n    if (_current_index != NONE) {\n      uint256 _previous_index = previous(self, _current_index);\n      _previous_item = get(self, _previous_index);\n    } else {\n      _previous_item = EMPTY_BYTES;\n    }\n  }\n\n  function next(Data storage self, uint256 _current_index)\n           public\n           constant\n           returns (uint256 _next_index)\n  {\n    if (self.valid_indexes[_current_index] == true) {\n      _next_index = self.collection[_current_index - 1].next_index;\n    } else {\n      _next_index = NONE;\n    }\n  }\n\n  function next_item(Data storage self, bytes32 _current_item)\n           public\n           constant\n           returns (bytes32 _next_item)\n  {\n    uint256 _current_index = find(self, _current_item);\n    if (_current_index != NONE) {\n      uint256 _next_index = next(self, _current_index);\n      _next_item = get(self, _next_index);\n    } else {\n      _next_item = EMPTY_BYTES;\n    }\n  }\n\n  function find(Uint storage self, uint256 _item)\n           public\n           constant\n           returns (uint256 _item_index)\n  {\n    _item_index = find(self.data, bytes32(_item));\n  }\n\n  function get(Uint storage self, uint256 _item_index)\n           public\n           constant\n           returns (uint256 _item)\n  {\n    _item = uint256(get(self.data, _item_index));\n  }\n\n\n  function append(Uint storage self, uint256 _data)\n           public\n           returns (bool _success)\n  {\n    _success = append(self.data, bytes32(_data));\n  }\n\n  function remove(Uint storage self, uint256 _index)\n           internal\n           returns (bool _success)\n  {\n    _success = remove(self.data, _index);\n  }\n\n  function remove_item(Uint storage self, uint256 _item)\n           public\n           returns (bool _success)\n  {\n    _success = remove_item(self.data, bytes32(_item));\n  }\n\n  function total(Uint storage self)\n           public\n           constant\n           returns (uint256 _total_count)\n  {\n    _total_count = total(self.data);\n  }\n\n  function start(Uint storage self)\n           public\n           constant\n           returns (uint256 _index)\n  {\n    _index = start(self.data);\n  }\n\n  function start_item(Uint storage self)\n           public\n           constant\n           returns (uint256 _start_item)\n  {\n    _start_item = uint256(start_item(self.data));\n  }\n\n\n  function end(Uint storage self)\n           public\n           constant\n           returns (uint256 _index)\n  {\n    _index = end(self.data);\n  }\n\n  function end_item(Uint storage self)\n           public\n           constant\n           returns (uint256 _end_item)\n  {\n    _end_item = uint256(end_item(self.data));\n  }\n\n  function valid(Uint storage self, uint256 _item_index)\n           public\n           constant\n           returns (bool _yes)\n  {\n    _yes = valid(self.data, _item_index);\n  }\n\n  function valid_item(Uint storage self, uint256 _item)\n           public\n           constant\n           returns (bool _yes)\n  {\n    _yes = valid_item(self.data, bytes32(_item));\n  }\n\n  function previous(Uint storage self, uint256 _current_index)\n           public\n           constant\n           returns (uint256 _previous_index)\n  {\n    _previous_index = previous(self.data, _current_index);\n  }\n\n  function previous_item(Uint storage self, uint256 _current_item)\n           public\n           constant\n           returns (uint256 _previous_item)\n  {\n    _previous_item = uint256(previous_item(self.data, bytes32(_current_item)));\n  }\n\n  function next(Uint storage self, uint256 _current_index)\n           public\n           constant\n           returns (uint256 _next_index)\n  {\n    _next_index = next(self.data, _current_index);\n  }\n\n  function next_item(Uint storage self, uint256 _current_item)\n           public\n           constant\n           returns (uint256 _next_item)\n  {\n    _next_item = uint256(next_item(self.data, bytes32(_current_item)));\n  }\n\n  function find(Address storage self, address _item)\n           public\n           constant\n           returns (uint256 _item_index)\n  {\n    _item_index = find(self.data, bytes32(_item));\n  }\n\n  function get(Address storage self, uint256 _item_index)\n           public\n           constant\n           returns (address _item)\n  {\n    _item = address(get(self.data, _item_index));\n  }\n\n\n  function find(IndexedUint storage self, bytes32 _collection_index, uint256 _item)\n           public\n           constant\n           returns (uint256 _item_index)\n  {\n    _item_index = find(self.data[_collection_index], bytes32(_item));\n  }\n\n  function get(IndexedUint storage self, bytes32 _collection_index, uint256 _item_index)\n           public\n           constant\n           returns (uint256 _item)\n  {\n    _item = uint256(get(self.data[_collection_index], _item_index));\n  }\n\n\n  function append(IndexedUint storage self, bytes32 _collection_index, uint256 _data)\n           public\n           returns (bool _success)\n  {\n    _success = append(self.data[_collection_index], bytes32(_data));\n  }\n\n  function remove(IndexedUint storage self, bytes32 _collection_index, uint256 _index)\n           internal\n           returns (bool _success)\n  {\n    _success = remove(self.data[_collection_index], _index);\n  }\n\n  function remove_item(IndexedUint storage self, bytes32 _collection_index, uint256 _item)\n           public\n           returns (bool _success)\n  {\n    _success = remove_item(self.data[_collection_index], bytes32(_item));\n  }\n\n  function total(IndexedUint storage self, bytes32 _collection_index)\n           public\n           constant\n           returns (uint256 _total_count)\n  {\n    _total_count = total(self.data[_collection_index]);\n  }\n\n  function start(IndexedUint storage self, bytes32 _collection_index)\n           public\n           constant\n           returns (uint256 _index)\n  {\n    _index = start(self.data[_collection_index]);\n  }\n\n  function start_item(IndexedUint storage self, bytes32 _collection_index)\n           public\n           constant\n           returns (uint256 _start_item)\n  {\n    _start_item = uint256(start_item(self.data[_collection_index]));\n  }\n\n\n  function end(IndexedUint storage self, bytes32 _collection_index)\n           public\n           constant\n           returns (uint256 _index)\n  {\n    _index = end(self.data[_collection_index]);\n  }\n\n  function end_item(IndexedUint storage self, bytes32 _collection_index)\n           public\n           constant\n           returns (uint256 _end_item)\n  {\n    _end_item = uint256(end_item(self.data[_collection_index]));\n  }\n\n  function valid(IndexedUint storage self, bytes32 _collection_index, uint256 _item_index)\n           public\n           constant\n           returns (bool _yes)\n  {\n    _yes = valid(self.data[_collection_index], _item_index);\n  }\n\n  function valid_item(IndexedUint storage self, bytes32 _collection_index, uint256 _item)\n           public\n           constant\n           returns (bool _yes)\n  {\n    _yes = valid_item(self.data[_collection_index], bytes32(_item));\n  }\n\n  function previous(IndexedUint storage self, bytes32 _collection_index, uint256 _current_index)\n           public\n           constant\n           returns (uint256 _previous_index)\n  {\n    _previous_index = previous(self.data[_collection_index], _current_index);\n  }\n\n  function previous_item(IndexedUint storage self, bytes32 _collection_index, uint256 _current_item)\n           public\n           constant\n           returns (uint256 _previous_item)\n  {\n    _previous_item = uint256(previous_item(self.data[_collection_index], bytes32(_current_item)));\n  }\n\n  function next(IndexedUint storage self, bytes32 _collection_index, uint256 _current_index)\n           public\n           constant\n           returns (uint256 _next_index)\n  {\n    _next_index = next(self.data[_collection_index], _current_index);\n  }\n\n  function next_item(IndexedUint storage self, bytes32 _collection_index, uint256 _current_item)\n           public\n           constant\n           returns (uint256 _next_item)\n  {\n    _next_item = uint256(next_item(self.data[_collection_index], bytes32(_current_item)));\n  }\n\n  function append(Address storage self, address _data)\n           public\n           returns (bool _success)\n  {\n    _success = append(self.data, bytes32(_data));\n  }\n\n  function remove(Address storage self, uint256 _index)\n           internal\n           returns (bool _success)\n  {\n    _success = remove(self.data, _index);\n  }\n\n\n  function remove_item(Address storage self, address _item)\n           public\n           returns (bool _success)\n  {\n    _success = remove_item(self.data, bytes32(_item));\n  }\n\n  function total(Address storage self)\n           public\n           constant\n           returns (uint256 _total_count)\n  {\n    _total_count = total(self.data);\n  }\n\n  function start(Address storage self)\n           public\n           constant\n           returns (uint256 _index)\n  {\n    _index = start(self.data);\n  }\n\n  function start_item(Address storage self)\n           public\n           constant\n           returns (address _start_item)\n  {\n    _start_item = address(start_item(self.data));\n  }\n\n\n  function end(Address storage self)\n           public\n           constant\n           returns (uint256 _index)\n  {\n    _index = end(self.data);\n  }\n\n  function end_item(Address storage self)\n           public\n           constant\n           returns (address _end_item)\n  {\n    _end_item = address(end_item(self.data));\n  }\n\n  function valid(Address storage self, uint256 _item_index)\n           public\n           constant\n           returns (bool _yes)\n  {\n    _yes = valid(self.data, _item_index);\n  }\n\n  function valid_item(Address storage self, address _item)\n           public\n           constant\n           returns (bool _yes)\n  {\n    _yes = valid_item(self.data, bytes32(_item));\n  }\n\n  function previous(Address storage self, uint256 _current_index)\n           public\n           constant\n           returns (uint256 _previous_index)\n  {\n    _previous_index = previous(self.data, _current_index);\n  }\n\n  function previous_item(Address storage self, address _current_item)\n           public\n           constant\n           returns (address _previous_item)\n  {\n    _previous_item = address(previous_item(self.data, bytes32(_current_item)));\n  }\n\n  function next(Address storage self, uint256 _current_index)\n           public\n           constant\n           returns (uint256 _next_index)\n  {\n    _next_index = next(self.data, _current_index);\n  }\n\n  function next_item(Address storage self, address _current_item)\n           public\n           constant\n           returns (address _next_item)\n  {\n    _next_item = address(next_item(self.data, bytes32(_current_item)));\n  }\n\n  function append(IndexedAddress storage self, bytes32 _collection_index, address _data)\n           public\n           returns (bool _success)\n  {\n    _success = append(self.data[_collection_index], bytes32(_data));\n  }\n\n  function remove(IndexedAddress storage self, bytes32 _collection_index, uint256 _index)\n           internal\n           returns (bool _success)\n  {\n    _success = remove(self.data[_collection_index], _index);\n  }\n\n\n  function remove_item(IndexedAddress storage self, bytes32 _collection_index, address _item)\n           public\n           returns (bool _success)\n  {\n    _success = remove_item(self.data[_collection_index], bytes32(_item));\n  }\n\n  function total(IndexedAddress storage self, bytes32 _collection_index)\n           public\n           constant\n           returns (uint256 _total_count)\n  {\n    _total_count = total(self.data[_collection_index]);\n  }\n\n  function start(IndexedAddress storage self, bytes32 _collection_index)\n           public\n           constant\n           returns (uint256 _index)\n  {\n    _index = start(self.data[_collection_index]);\n  }\n\n  function start_item(IndexedAddress storage self, bytes32 _collection_index)\n           public\n           constant\n           returns (address _start_item)\n  {\n    _start_item = address(start_item(self.data[_collection_index]));\n  }\n\n\n  function end(IndexedAddress storage self, bytes32 _collection_index)\n           public\n           constant\n           returns (uint256 _index)\n  {\n    _index = end(self.data[_collection_index]);\n  }\n\n  function end_item(IndexedAddress storage self, bytes32 _collection_index)\n           public\n           constant\n           returns (address _end_item)\n  {\n    _end_item = address(end_item(self.data[_collection_index]));\n  }\n\n  function valid(IndexedAddress storage self, bytes32 _collection_index, uint256 _item_index)\n           public\n           constant\n           returns (bool _yes)\n  {\n    _yes = valid(self.data[_collection_index], _item_index);\n  }\n\n  function valid_item(IndexedAddress storage self, bytes32 _collection_index, address _item)\n           public\n           constant\n           returns (bool _yes)\n  {\n    _yes = valid_item(self.data[_collection_index], bytes32(_item));\n  }\n\n  function previous(IndexedAddress storage self, bytes32 _collection_index, uint256 _current_index)\n           public\n           constant\n           returns (uint256 _previous_index)\n  {\n    _previous_index = previous(self.data[_collection_index], _current_index);\n  }\n\n  function previous_item(IndexedAddress storage self, bytes32 _collection_index, address _current_item)\n           public\n           constant\n           returns (address _previous_item)\n  {\n    _previous_item = address(previous_item(self.data[_collection_index], bytes32(_current_item)));\n  }\n\n  function next(IndexedAddress storage self, bytes32 _collection_index, uint256 _current_index)\n           public\n           constant\n           returns (uint256 _next_index)\n  {\n    _next_index = next(self.data[_collection_index], _current_index);\n  }\n\n  function next_item(IndexedAddress storage self, bytes32 _collection_index, address _current_item)\n           public\n           constant\n           returns (address _next_item)\n  {\n    _next_item = address(next_item(self.data[_collection_index], bytes32(_current_item)));\n  }\n\n\n  function find(Bytes storage self, bytes32 _item)\n           public\n           constant\n           returns (uint256 _item_index)\n  {\n    _item_index = find(self.data, _item);\n  }\n\n  function get(Bytes storage self, uint256 _item_index)\n           public\n           constant\n           returns (bytes32 _item)\n  {\n    _item = get(self.data, _item_index);\n  }\n\n\n  function append(Bytes storage self, bytes32 _data)\n           public\n           returns (bool _success)\n  {\n    _success = append(self.data, _data);\n  }\n\n  function remove(Bytes storage self, uint256 _index)\n           internal\n           returns (bool _success)\n  {\n    _success = remove(self.data, _index);\n  }\n\n\n  function remove_item(Bytes storage self, bytes32 _item)\n           public\n           returns (bool _success)\n  {\n    _success = remove_item(self.data, _item);\n  }\n\n  function total(Bytes storage self)\n           public\n           constant\n           returns (uint256 _total_count)\n  {\n    _total_count = total(self.data);\n  }\n\n  function start(Bytes storage self)\n           public\n           constant\n           returns (uint256 _index)\n  {\n    _index = start(self.data);\n  }\n\n  function start_item(Bytes storage self)\n           public\n           constant\n           returns (bytes32 _start_item)\n  {\n    _start_item = start_item(self.data);\n  }\n\n\n  function end(Bytes storage self)\n           public\n           constant\n           returns (uint256 _index)\n  {\n    _index = end(self.data);\n  }\n\n  function end_item(Bytes storage self)\n           public\n           constant\n           returns (bytes32 _end_item)\n  {\n    _end_item = end_item(self.data);\n  }\n\n  function valid(Bytes storage self, uint256 _item_index)\n           public\n           constant\n           returns (bool _yes)\n  {\n    _yes = valid(self.data, _item_index);\n  }\n\n  function valid_item(Bytes storage self, bytes32 _item)\n           public\n           constant\n           returns (bool _yes)\n  {\n    _yes = valid_item(self.data, _item);\n  }\n\n  function previous(Bytes storage self, uint256 _current_index)\n           public\n           constant\n           returns (uint256 _previous_index)\n  {\n    _previous_index = previous(self.data, _current_index);\n  }\n\n  function previous_item(Bytes storage self, bytes32 _current_item)\n           public\n           constant\n           returns (bytes32 _previous_item)\n  {\n    _previous_item = previous_item(self.data, _current_item);\n  }\n\n  function next(Bytes storage self, uint256 _current_index)\n           public\n           constant\n           returns (uint256 _next_index)\n  {\n    _next_index = next(self.data, _current_index);\n  }\n\n  function next_item(Bytes storage self, bytes32 _current_item)\n           public\n           constant\n           returns (bytes32 _next_item)\n  {\n    _next_item = next_item(self.data, _current_item);\n  }\n\n  function append(IndexedBytes storage self, bytes32 _collection_index, bytes32 _data)\n           public\n           returns (bool _success)\n  {\n    _success = append(self.data[_collection_index], bytes32(_data));\n  }\n\n  function remove(IndexedBytes storage self, bytes32 _collection_index, uint256 _index)\n           internal\n           returns (bool _success)\n  {\n    _success = remove(self.data[_collection_index], _index);\n  }\n\n\n  function remove_item(IndexedBytes storage self, bytes32 _collection_index, bytes32 _item)\n           public\n           returns (bool _success)\n  {\n    _success = remove_item(self.data[_collection_index], bytes32(_item));\n  }\n\n  function total(IndexedBytes storage self, bytes32 _collection_index)\n           public\n           constant\n           returns (uint256 _total_count)\n  {\n    _total_count = total(self.data[_collection_index]);\n  }\n\n  function start(IndexedBytes storage self, bytes32 _collection_index)\n           public\n           constant\n           returns (uint256 _index)\n  {\n    _index = start(self.data[_collection_index]);\n  }\n\n  function start_item(IndexedBytes storage self, bytes32 _collection_index)\n           public\n           constant\n           returns (bytes32 _start_item)\n  {\n    _start_item = bytes32(start_item(self.data[_collection_index]));\n  }\n\n\n  function end(IndexedBytes storage self, bytes32 _collection_index)\n           public\n           constant\n           returns (uint256 _index)\n  {\n    _index = end(self.data[_collection_index]);\n  }\n\n  function end_item(IndexedBytes storage self, bytes32 _collection_index)\n           public\n           constant\n           returns (bytes32 _end_item)\n  {\n    _end_item = bytes32(end_item(self.data[_collection_index]));\n  }\n\n  function valid(IndexedBytes storage self, bytes32 _collection_index, uint256 _item_index)\n           public\n           constant\n           returns (bool _yes)\n  {\n    _yes = valid(self.data[_collection_index], _item_index);\n  }\n\n  function valid_item(IndexedBytes storage self, bytes32 _collection_index, bytes32 _item)\n           public\n           constant\n           returns (bool _yes)\n  {\n    _yes = valid_item(self.data[_collection_index], bytes32(_item));\n  }\n\n  function previous(IndexedBytes storage self, bytes32 _collection_index, uint256 _current_index)\n           public\n           constant\n           returns (uint256 _previous_index)\n  {\n    _previous_index = previous(self.data[_collection_index], _current_index);\n  }\n\n  function previous_item(IndexedBytes storage self, bytes32 _collection_index, bytes32 _current_item)\n           public\n           constant\n           returns (bytes32 _previous_item)\n  {\n    _previous_item = bytes32(previous_item(self.data[_collection_index], bytes32(_current_item)));\n  }\n\n  function next(IndexedBytes storage self, bytes32 _collection_index, uint256 _current_index)\n           public\n           constant\n           returns (uint256 _next_index)\n  {\n    _next_index = next(self.data[_collection_index], _current_index);\n  }\n\n  function next_item(IndexedBytes storage self, bytes32 _collection_index, bytes32 _current_item)\n           public\n           constant\n           returns (bytes32 _next_item)\n  {\n    _next_item = bytes32(next_item(self.data[_collection_index], bytes32(_current_item)));\n  }\n\n\n}\n\n// File: @digix/solidity-collections/contracts/abstract/BytesIteratorStorage.sol\npragma solidity ^0.4.19;\n\n/**\n  @title Bytes Iterator Storage\n  @author DigixGlobal Pte Ltd\n*/\ncontract BytesIteratorStorage {\n\n  // Initialize Doubly Linked List of Bytes\n  using DoublyLinkedList for DoublyLinkedList.Bytes;\n\n  /**\n    @notice Reads the first item from the list of Bytes\n    @param _list The source list\n    @return {\"_item\": \"The first item from the list\"}\n  */\n  function read_first_from_bytesarray(DoublyLinkedList.Bytes storage _list)\n           internal\n           constant\n           returns (bytes32 _item)\n  {\n    _item = _list.start_item();\n  }\n\n  /**\n    @notice Reads the last item from the list of Bytes\n    @param _list The source list\n    @return {\"_item\": \"The last item from the list\"}\n  */\n  function read_last_from_bytesarray(DoublyLinkedList.Bytes storage _list)\n           internal\n           constant\n           returns (bytes32 _item)\n  {\n    _item = _list.end_item();\n  }\n\n  /**\n    @notice Reads the next item on the list of Bytes\n    @param _list The source list\n    @param _current_item The current item to be used as base line\n    @return {\"_item\": \"The next item from the list based on the specieid `_current_item`\"}\n    TODO: Need to verify what happens if the specified `_current_item` is the last item from the list\n  */\n  function read_next_from_bytesarray(DoublyLinkedList.Bytes storage _list, bytes32 _current_item)\n           internal\n           constant\n           returns (bytes32 _item)\n  {\n    _item = _list.next_item(_current_item);\n  }\n\n  /**\n    @notice Reads the previous item on the list of Bytes\n    @param _list The source list\n    @param _current_item The current item to be used as base line\n    @return {\"_item\": \"The previous item from the list based on the spcified `_current_item`\"}\n    TODO: Need to verify what happens if the specified `_current_item` is the first item from the list\n  */\n  function read_previous_from_bytesarray(DoublyLinkedList.Bytes storage _list, bytes32 _current_item)\n           internal\n           constant\n           returns (bytes32 _item)\n  {\n    _item = _list.previous_item(_current_item);\n  }\n\n  /**\n    @notice Reads the list of Bytes and returns the length of the list\n    @param _list The source list\n    @return {\"count\": \"`uint256` The lenght of the list\"}\n\n  */\n  function read_total_bytesarray(DoublyLinkedList.Bytes storage _list)\n           internal\n           constant\n           returns (uint256 _count)\n  {\n    _count = _list.total();\n  }\n\n}\n\n// File: contracts/common/DaoConstants.sol\npragma solidity ^0.4.25;\n\ncontract DaoConstants {\n    using SafeMath for uint256;\n    bytes32 EMPTY_BYTES = bytes32(0x0);\n    address EMPTY_ADDRESS = address(0x0);\n\n\n    bytes32 PROPOSAL_STATE_PREPROPOSAL = \"proposal_state_preproposal\";\n    bytes32 PROPOSAL_STATE_DRAFT = \"proposal_state_draft\";\n    bytes32 PROPOSAL_STATE_MODERATED = \"proposal_state_moderated\";\n    bytes32 PROPOSAL_STATE_ONGOING = \"proposal_state_ongoing\";\n    bytes32 PROPOSAL_STATE_CLOSED = \"proposal_state_closed\";\n    bytes32 PROPOSAL_STATE_ARCHIVED = \"proposal_state_archived\";\n\n    uint256 PRL_ACTION_STOP = 1;\n    uint256 PRL_ACTION_PAUSE = 2;\n    uint256 PRL_ACTION_UNPAUSE = 3;\n\n    uint256 COLLATERAL_STATUS_UNLOCKED = 1;\n    uint256 COLLATERAL_STATUS_LOCKED = 2;\n    uint256 COLLATERAL_STATUS_CLAIMED = 3;\n\n    bytes32 INTERMEDIATE_DGD_IDENTIFIER = \"inter_dgd_id\";\n    bytes32 INTERMEDIATE_MODERATOR_DGD_IDENTIFIER = \"inter_mod_dgd_id\";\n    bytes32 INTERMEDIATE_BONUS_CALCULATION_IDENTIFIER = \"inter_bonus_calculation_id\";\n\n    // interactive contracts\n    bytes32 CONTRACT_DAO = \"dao\";\n    bytes32 CONTRACT_DAO_SPECIAL_PROPOSAL = \"dao:special:proposal\";\n    bytes32 CONTRACT_DAO_STAKE_LOCKING = \"dao:stake-locking\";\n    bytes32 CONTRACT_DAO_VOTING = \"dao:voting\";\n    bytes32 CONTRACT_DAO_VOTING_CLAIMS = \"dao:voting:claims\";\n    bytes32 CONTRACT_DAO_SPECIAL_VOTING_CLAIMS = \"dao:svoting:claims\";\n    bytes32 CONTRACT_DAO_IDENTITY = \"dao:identity\";\n    bytes32 CONTRACT_DAO_REWARDS_MANAGER = \"dao:rewards-manager\";\n    bytes32 CONTRACT_DAO_REWARDS_MANAGER_EXTRAS = \"dao:rewards-extras\";\n    bytes32 CONTRACT_DAO_ROLES = \"dao:roles\";\n    bytes32 CONTRACT_DAO_FUNDING_MANAGER = \"dao:funding-manager\";\n    bytes32 CONTRACT_DAO_WHITELISTING = \"dao:whitelisting\";\n    bytes32 CONTRACT_DAO_INFORMATION = \"dao:information\";\n\n    // service contracts\n    bytes32 CONTRACT_SERVICE_ROLE = \"service:role\";\n    bytes32 CONTRACT_SERVICE_DAO_INFO = \"service:dao:info\";\n    bytes32 CONTRACT_SERVICE_DAO_LISTING = \"service:dao:listing\";\n    bytes32 CONTRACT_SERVICE_DAO_CALCULATOR = \"service:dao:calculator\";\n\n    // storage contracts\n    bytes32 CONTRACT_STORAGE_DAO = \"storage:dao\";\n    bytes32 CONTRACT_STORAGE_DAO_COUNTER = \"storage:dao:counter\";\n    bytes32 CONTRACT_STORAGE_DAO_UPGRADE = \"storage:dao:upgrade\";\n    bytes32 CONTRACT_STORAGE_DAO_IDENTITY = \"storage:dao:identity\";\n    bytes32 CONTRACT_STORAGE_DAO_POINTS = \"storage:dao:points\";\n    bytes32 CONTRACT_STORAGE_DAO_SPECIAL = \"storage:dao:special\";\n    bytes32 CONTRACT_STORAGE_DAO_CONFIG = \"storage:dao:config\";\n    bytes32 CONTRACT_STORAGE_DAO_STAKE = \"storage:dao:stake\";\n    bytes32 CONTRACT_STORAGE_DAO_REWARDS = \"storage:dao:rewards\";\n    bytes32 CONTRACT_STORAGE_DAO_WHITELISTING = \"storage:dao:whitelisting\";\n    bytes32 CONTRACT_STORAGE_INTERMEDIATE_RESULTS = \"storage:intermediate:results\";\n\n    bytes32 CONTRACT_DGD_TOKEN = \"t:dgd\";\n    bytes32 CONTRACT_DGX_TOKEN = \"t:dgx\";\n    bytes32 CONTRACT_BADGE_TOKEN = \"t:badge\";\n\n    uint8 ROLES_ROOT = 1;\n    uint8 ROLES_FOUNDERS = 2;\n    uint8 ROLES_PRLS = 3;\n    uint8 ROLES_KYC_ADMINS = 4;\n\n    uint256 QUARTER_DURATION = 90 days;\n\n    bytes32 CONFIG_MINIMUM_LOCKED_DGD = \"min_dgd_participant\";\n    bytes32 CONFIG_MINIMUM_DGD_FOR_MODERATOR = \"min_dgd_moderator\";\n    bytes32 CONFIG_MINIMUM_REPUTATION_FOR_MODERATOR = \"min_reputation_moderator\";\n\n    bytes32 CONFIG_LOCKING_PHASE_DURATION = \"locking_phase_duration\";\n    bytes32 CONFIG_QUARTER_DURATION = \"quarter_duration\";\n    bytes32 CONFIG_VOTING_COMMIT_PHASE = \"voting_commit_phase\";\n    bytes32 CONFIG_VOTING_PHASE_TOTAL = \"voting_phase_total\";\n    bytes32 CONFIG_INTERIM_COMMIT_PHASE = \"interim_voting_commit_phase\";\n    bytes32 CONFIG_INTERIM_PHASE_TOTAL = \"interim_voting_phase_total\";\n\n    bytes32 CONFIG_DRAFT_QUORUM_FIXED_PORTION_NUMERATOR = \"draft_quorum_fixed_numerator\";\n    bytes32 CONFIG_DRAFT_QUORUM_FIXED_PORTION_DENOMINATOR = \"draft_quorum_fixed_denominator\";\n    bytes32 CONFIG_DRAFT_QUORUM_SCALING_FACTOR_NUMERATOR = \"draft_quorum_sfactor_numerator\";\n    bytes32 CONFIG_DRAFT_QUORUM_SCALING_FACTOR_DENOMINATOR = \"draft_quorum_sfactor_denominator\";\n    bytes32 CONFIG_VOTING_QUORUM_FIXED_PORTION_NUMERATOR = \"vote_quorum_fixed_numerator\";\n    bytes32 CONFIG_VOTING_QUORUM_FIXED_PORTION_DENOMINATOR = \"vote_quorum_fixed_denominator\";\n    bytes32 CONFIG_VOTING_QUORUM_SCALING_FACTOR_NUMERATOR = \"vote_quorum_sfactor_numerator\";\n    bytes32 CONFIG_VOTING_QUORUM_SCALING_FACTOR_DENOMINATOR = \"vote_quorum_sfactor_denominator\";\n    bytes32 CONFIG_FINAL_REWARD_SCALING_FACTOR_NUMERATOR = \"final_reward_sfactor_numerator\";\n    bytes32 CONFIG_FINAL_REWARD_SCALING_FACTOR_DENOMINATOR = \"final_reward_sfactor_denominator\";\n\n    bytes32 CONFIG_DRAFT_QUOTA_NUMERATOR = \"draft_quota_numerator\";\n    bytes32 CONFIG_DRAFT_QUOTA_DENOMINATOR = \"draft_quota_denominator\";\n    bytes32 CONFIG_VOTING_QUOTA_NUMERATOR = \"voting_quota_numerator\";\n    bytes32 CONFIG_VOTING_QUOTA_DENOMINATOR = \"voting_quota_denominator\";\n\n    bytes32 CONFIG_MINIMAL_QUARTER_POINT = \"minimal_qp\";\n    bytes32 CONFIG_QUARTER_POINT_SCALING_FACTOR = \"quarter_point_scaling_factor\";\n    bytes32 CONFIG_REPUTATION_POINT_SCALING_FACTOR = \"rep_point_scaling_factor\";\n\n    bytes32 CONFIG_MODERATOR_MINIMAL_QUARTER_POINT = \"minimal_mod_qp\";\n    bytes32 CONFIG_MODERATOR_QUARTER_POINT_SCALING_FACTOR = \"mod_qp_scaling_factor\";\n    bytes32 CONFIG_MODERATOR_REPUTATION_POINT_SCALING_FACTOR = \"mod_rep_point_scaling_factor\";\n\n    bytes32 CONFIG_QUARTER_POINT_DRAFT_VOTE = \"quarter_point_draft_vote\";\n    bytes32 CONFIG_QUARTER_POINT_VOTE = \"quarter_point_vote\";\n    bytes32 CONFIG_QUARTER_POINT_INTERIM_VOTE = \"quarter_point_interim_vote\";\n\n    /// this is per 10000 ETHs\n    bytes32 CONFIG_QUARTER_POINT_MILESTONE_COMPLETION_PER_10000ETH = \"q_p_milestone_completion\";\n\n    bytes32 CONFIG_BONUS_REPUTATION_NUMERATOR = \"bonus_reputation_numerator\";\n    bytes32 CONFIG_BONUS_REPUTATION_DENOMINATOR = \"bonus_reputation_denominator\";\n\n    bytes32 CONFIG_SPECIAL_PROPOSAL_COMMIT_PHASE = \"special_proposal_commit_phase\";\n    bytes32 CONFIG_SPECIAL_PROPOSAL_PHASE_TOTAL = \"special_proposal_phase_total\";\n\n    bytes32 CONFIG_SPECIAL_QUOTA_NUMERATOR = \"config_special_quota_numerator\";\n    bytes32 CONFIG_SPECIAL_QUOTA_DENOMINATOR = \"config_special_quota_denominator\";\n\n    bytes32 CONFIG_SPECIAL_PROPOSAL_QUORUM_NUMERATOR = \"special_quorum_numerator\";\n    bytes32 CONFIG_SPECIAL_PROPOSAL_QUORUM_DENOMINATOR = \"special_quorum_denominator\";\n\n    bytes32 CONFIG_MAXIMUM_REPUTATION_DEDUCTION = \"config_max_reputation_deduction\";\n    bytes32 CONFIG_PUNISHMENT_FOR_NOT_LOCKING = \"config_punishment_not_locking\";\n\n    bytes32 CONFIG_REPUTATION_PER_EXTRA_QP_NUM = \"config_rep_per_extra_qp_num\";\n    bytes32 CONFIG_REPUTATION_PER_EXTRA_QP_DEN = \"config_rep_per_extra_qp_den\";\n\n    bytes32 CONFIG_MAXIMUM_MODERATOR_REPUTATION_DEDUCTION = \"config_max_m_rp_deduction\";\n    bytes32 CONFIG_REPUTATION_PER_EXTRA_MODERATOR_QP_NUM = \"config_rep_per_extra_m_qp_num\";\n    bytes32 CONFIG_REPUTATION_PER_EXTRA_MODERATOR_QP_DEN = \"config_rep_per_extra_m_qp_den\";\n\n    bytes32 CONFIG_PORTION_TO_MODERATORS_NUM = \"config_mod_portion_num\";\n    bytes32 CONFIG_PORTION_TO_MODERATORS_DEN = \"config_mod_portion_den\";\n\n    bytes32 CONFIG_DRAFT_VOTING_PHASE = \"config_draft_voting_phase\";\n\n    bytes32 CONFIG_REPUTATION_POINT_BOOST_FOR_BADGE = \"config_rp_boost_per_badge\";\n\n    bytes32 CONFIG_VOTE_CLAIMING_DEADLINE = \"config_claiming_deadline\";\n\n    bytes32 CONFIG_PREPROPOSAL_COLLATERAL = \"config_preproposal_collateral\";\n\n    bytes32 CONFIG_MAX_FUNDING_FOR_NON_DIGIX = \"config_max_funding_nonDigix\";\n    bytes32 CONFIG_MAX_MILESTONES_FOR_NON_DIGIX = \"config_max_milestones_nonDigix\";\n    bytes32 CONFIG_NON_DIGIX_PROPOSAL_CAP_PER_QUARTER = \"config_nonDigix_proposal_cap\";\n\n    bytes32 CONFIG_PROPOSAL_DEAD_DURATION = \"config_dead_duration\";\n    bytes32 CONFIG_CARBON_VOTE_REPUTATION_BONUS = \"config_cv_reputation\";\n}\n\n// File: contracts/storage/DaoWhitelistingStorage.sol\npragma solidity ^0.4.25;\n\n// This contract is basically created to restrict read access to\n// ethereum accounts, and whitelisted contracts\ncontract DaoWhitelistingStorage is ResolverClient, DaoConstants {\n\n    // we want to avoid the scenario in which an on-chain bribing contract\n    // can be deployed to distribute funds in a trustless way by verifying\n    // on-chain votes. This mapping marks whether a contract address is whitelisted\n    // to read from the read functions in DaoStorage, DaoSpecialStorage, etc.\n    mapping (address => bool) public whitelist;\n\n    constructor(address _resolver)\n        public\n    {\n        require(init(CONTRACT_STORAGE_DAO_WHITELISTING, _resolver));\n    }\n\n    function setWhitelisted(address _contractAddress, bool _senderIsAllowedToRead)\n        public\n    {\n        require(sender_is(CONTRACT_DAO_WHITELISTING));\n        whitelist[_contractAddress] = _senderIsAllowedToRead;\n    }\n}\n\n// File: contracts/common/DaoWhitelistingCommon.sol\npragma solidity ^0.4.25;\n\ncontract DaoWhitelistingCommon is ResolverClient, DaoConstants {\n\n    function daoWhitelistingStorage()\n        internal\n        view\n        returns (DaoWhitelistingStorage _contract)\n    {\n        _contract = DaoWhitelistingStorage(get_contract(CONTRACT_STORAGE_DAO_WHITELISTING));\n    }\n\n    /**\n    @notice Check if a certain address is whitelisted to read sensitive information in the storage layer\n    @dev if the address is an account, it is allowed to read. If the address is a contract, it has to be in the whitelist\n    */\n    function senderIsAllowedToRead()\n        internal\n        view\n        returns (bool _senderIsAllowedToRead)\n    {\n        // msg.sender is allowed to read only if its an EOA or a whitelisted contract\n        _senderIsAllowedToRead = (msg.sender == tx.origin) || daoWhitelistingStorage().whitelist(msg.sender);\n    }\n}\n\n// File: contracts/lib/DaoStructs.sol\npragma solidity ^0.4.25;\n\nlibrary DaoStructs {\n    using DoublyLinkedList for DoublyLinkedList.Bytes;\n    using SafeMath for uint256;\n    bytes32 constant EMPTY_BYTES = bytes32(0x0);\n\n    struct PrlAction {\n        // UTC timestamp at which the PRL action was done\n        uint256 at;\n\n        // IPFS hash of the document summarizing the action\n        bytes32 doc;\n\n        // Type of action\n        // check PRL_ACTION_* in \"./../common/DaoConstants.sol\"\n        uint256 actionId;\n    }\n\n    struct Voting {\n        // UTC timestamp at which the voting round starts\n        uint256 startTime;\n\n        // Mapping of whether a commit was used in this voting round\n        mapping (bytes32 => bool) usedCommits;\n\n        // Mapping of commits by address. These are the commits during the commit phase in a voting round\n        // This only stores the most recent commit in the voting round\n        // In case a vote is edited, the previous commit is overwritten by the new commit\n        // Only this new commit is verified at the reveal phase\n        mapping (address => bytes32) commits;\n\n        // This mapping is updated after the reveal phase, when votes are revealed\n        // It is a mapping of address to weight of vote\n        // Weight implies the lockedDGDStake of the address, at the time of revealing\n        // If the address voted \"NO\", or didn't vote, this would be 0\n        mapping (address => uint256) yesVotes;\n\n        // This mapping is updated after the reveal phase, when votes are revealed\n        // It is a mapping of address to weight of vote\n        // Weight implies the lockedDGDStake of the address, at the time of revealing\n        // If the address voted \"YES\", or didn't vote, this would be 0\n        mapping (address => uint256) noVotes;\n\n        // Boolean whether the voting round passed or not\n        bool passed;\n\n        // Boolean whether the voting round results were claimed or not\n        // refer the claimProposalVotingResult function in \"./../interative/DaoVotingClaims.sol\"\n        bool claimed;\n\n        // Boolean whether the milestone following this voting round was funded or not\n        // The milestone is funded when the proposer calls claimFunding in \"./../interactive/DaoFundingManager.sol\"\n        bool funded;\n    }\n\n    struct ProposalVersion {\n        // IPFS doc hash of this version of the proposal\n        bytes32 docIpfsHash;\n\n        // UTC timestamp at which this version was created\n        uint256 created;\n\n        // The number of milestones in the proposal as per this version\n        uint256 milestoneCount;\n\n        // The final reward asked by the proposer for completion of the entire proposal\n        uint256 finalReward;\n\n        // List of fundings required by the proposal as per this version\n        // The numbers are in wei\n        uint256[] milestoneFundings;\n\n        // When a proposal is finalized (calling Dao.finalizeProposal), the proposer can no longer add proposal versions\n        // However, they can still add more details to this final proposal version, in the form of IPFS docs.\n        // These IPFS docs are stored in this array\n        bytes32[] moreDocs;\n    }\n\n    struct Proposal {\n        // ID of the proposal. Also the IPFS hash of the first ProposalVersion\n        bytes32 proposalId;\n\n        // current state of the proposal\n        // refer PROPOSAL_STATE_* in \"./../common/DaoConstants.sol\"\n        bytes32 currentState;\n\n        // UTC timestamp at which the proposal was created\n        uint256 timeCreated;\n\n        // DoublyLinkedList of IPFS doc hashes of the various versions of the proposal\n        DoublyLinkedList.Bytes proposalVersionDocs;\n\n        // Mapping of version (IPFS doc hash) to ProposalVersion struct\n        mapping (bytes32 => ProposalVersion) proposalVersions;\n\n        // Voting struct for the draft voting round\n        Voting draftVoting;\n\n        // Mapping of voting round index (starts from 0) to Voting struct\n        // votingRounds[0] is the Voting round of the proposal, which lasts for get_uint_config(CONFIG_VOTING_PHASE_TOTAL)\n        // votingRounds[i] for i>0 are the Interim Voting rounds of the proposal, which lasts for get_uint_config(CONFIG_INTERIM_PHASE_TOTAL)\n        mapping (uint256 => Voting) votingRounds;\n\n        // Every proposal has a collateral tied to it with a value of\n        // get_uint_config(CONFIG_PREPROPOSAL_COLLATERAL) (refer \"./../storage/DaoConfigsStorage.sol\")\n        // Collateral can be in different states\n        // refer COLLATERAL_STATUS_* in \"./../common/DaoConstants.sol\"\n        uint256 collateralStatus;\n        uint256 collateralAmount;\n\n        // The final version of the proposal\n        // Every proposal needs to be finalized before it can be voted on\n        // This is the IPFS doc hash of the final version\n        bytes32 finalVersion;\n\n        // List of PrlAction structs\n        // These are all the actions done by the PRL on the proposal\n        PrlAction[] prlActions;\n\n        // Address of the user who created the proposal\n        address proposer;\n\n        // Address of the moderator who endorsed the proposal\n        address endorser;\n\n        // Boolean whether the proposal is paused/stopped at the moment\n        bool isPausedOrStopped;\n\n        // Boolean whether the proposal was created by a founder role\n        bool isDigix;\n    }\n\n    function countVotes(Voting storage _voting, address[] _allUsers)\n        external\n        view\n        returns (uint256 _for, uint256 _against)\n    {\n        uint256 _n = _allUsers.length;\n        for (uint256 i = 0; i < _n; i++) {\n            if (_voting.yesVotes[_allUsers[i]] > 0) {\n                _for = _for.add(_voting.yesVotes[_allUsers[i]]);\n            } else if (_voting.noVotes[_allUsers[i]] > 0) {\n                _against = _against.add(_voting.noVotes[_allUsers[i]]);\n            }\n        }\n    }\n\n    // get the list of voters who voted _vote (true-yes/false-no)\n    function listVotes(Voting storage _voting, address[] _allUsers, bool _vote)\n        external\n        view\n        returns (address[] memory _voters, uint256 _length)\n    {\n        uint256 _n = _allUsers.length;\n        uint256 i;\n        _length = 0;\n        _voters = new address[](_n);\n        if (_vote == true) {\n            for (i = 0; i < _n; i++) {\n                if (_voting.yesVotes[_allUsers[i]] > 0) {\n                    _voters[_length] = _allUsers[i];\n                    _length++;\n                }\n            }\n        } else {\n            for (i = 0; i < _n; i++) {\n                if (_voting.noVotes[_allUsers[i]] > 0) {\n                    _voters[_length] = _allUsers[i];\n                    _length++;\n                }\n            }\n        }\n    }\n\n    function readVote(Voting storage _voting, address _voter)\n        public\n        view\n        returns (bool _vote, uint256 _weight)\n    {\n        if (_voting.yesVotes[_voter] > 0) {\n            _weight = _voting.yesVotes[_voter];\n            _vote = true;\n        } else {\n            _weight = _voting.noVotes[_voter]; // if _voter didnt vote at all, the weight will be 0 anyway\n            _vote = false;\n        }\n    }\n\n    function revealVote(\n        Voting storage _voting,\n        address _voter,\n        bool _vote,\n        uint256 _weight\n    )\n        public\n    {\n        if (_vote) {\n            _voting.yesVotes[_voter] = _weight;\n        } else {\n            _voting.noVotes[_voter] = _weight;\n        }\n    }\n\n    function readVersion(ProposalVersion storage _version)\n        public\n        view\n        returns (\n            bytes32 _doc,\n            uint256 _created,\n            uint256[] _milestoneFundings,\n            uint256 _finalReward\n        )\n    {\n        _doc = _version.docIpfsHash;\n        _created = _version.created;\n        _milestoneFundings = _version.milestoneFundings;\n        _finalReward = _version.finalReward;\n    }\n\n    // read the funding for a particular milestone of a finalized proposal\n    // if _milestoneId is the same as _milestoneCount, it returns the final reward\n    function readProposalMilestone(Proposal storage _proposal, uint256 _milestoneIndex)\n        public\n        view\n        returns (uint256 _funding)\n    {\n        bytes32 _finalVersion = _proposal.finalVersion;\n        uint256 _milestoneCount = _proposal.proposalVersions[_finalVersion].milestoneFundings.length;\n        require(_milestoneIndex <= _milestoneCount);\n        require(_finalVersion != EMPTY_BYTES); // the proposal must have been finalized\n\n        if (_milestoneIndex < _milestoneCount) {\n            _funding = _proposal.proposalVersions[_finalVersion].milestoneFundings[_milestoneIndex];\n        } else {\n            _funding = _proposal.proposalVersions[_finalVersion].finalReward;\n        }\n    }\n\n    function addProposalVersion(\n        Proposal storage _proposal,\n        bytes32 _newDoc,\n        uint256[] _newMilestoneFundings,\n        uint256 _finalReward\n    )\n        public\n    {\n        _proposal.proposalVersionDocs.append(_newDoc);\n        _proposal.proposalVersions[_newDoc].docIpfsHash = _newDoc;\n        _proposal.proposalVersions[_newDoc].created = now;\n        _proposal.proposalVersions[_newDoc].milestoneCount = _newMilestoneFundings.length;\n        _proposal.proposalVersions[_newDoc].milestoneFundings = _newMilestoneFundings;\n        _proposal.proposalVersions[_newDoc].finalReward = _finalReward;\n    }\n\n    struct SpecialProposal {\n        // ID of the special proposal\n        // This is the IPFS doc hash of the proposal\n        bytes32 proposalId;\n\n        // UTC timestamp at which the proposal was created\n        uint256 timeCreated;\n\n        // Voting struct for the special proposal\n        Voting voting;\n\n        // List of the new uint256 configs as per the special proposal\n        uint256[] uintConfigs;\n\n        // List of the new address configs as per the special proposal\n        address[] addressConfigs;\n\n        // List of the new bytes32 configs as per the special proposal\n        bytes32[] bytesConfigs;\n\n        // Address of the user who created the special proposal\n        // This address should also be in the ROLES_FOUNDERS group\n        // refer \"./../storage/DaoIdentityStorage.sol\"\n        address proposer;\n    }\n\n    // All configs are as per the DaoConfigsStorage values at the time when\n    // calculateGlobalRewardsBeforeNewQuarter is called by founder in that quarter\n    struct DaoQuarterInfo {\n        // The minimum quarter points required\n        // below this, reputation will be deducted\n        uint256 minimalParticipationPoint;\n\n        // The scaling factor for quarter point\n        uint256 quarterPointScalingFactor;\n\n        // The scaling factor for reputation point\n        uint256 reputationPointScalingFactor;\n\n        // The summation of effectiveDGDs in the previous quarter\n        // The effectiveDGDs represents the effective participation in DigixDAO in a quarter\n        // Which depends on lockedDGDStake, quarter point and reputation point\n        // This value is the summation of all participant effectiveDGDs\n        // It will be used to calculate the fraction of effectiveDGD a user has,\n        // which will determine his portion of DGX rewards for that quarter\n        uint256 totalEffectiveDGDPreviousQuarter;\n\n        // The minimum moderator quarter point required\n        // below this, reputation will be deducted for moderators\n        uint256 moderatorMinimalParticipationPoint;\n\n        // the scaling factor for moderator quarter point\n        uint256 moderatorQuarterPointScalingFactor;\n\n        // the scaling factor for moderator reputation point\n        uint256 moderatorReputationPointScalingFactor;\n\n        // The summation of effectiveDGDs (only specific to moderators)\n        uint256 totalEffectiveModeratorDGDLastQuarter;\n\n        // UTC timestamp from which the DGX rewards for the previous quarter are distributable to Holders\n        uint256 dgxDistributionDay;\n\n        // This is the rewards pool for the previous quarter. This is the sum of the DGX fees coming in from the collector, and the demurrage that has incurred\n        // when user call claimRewards() in the previous quarter.\n        // more graphical explanation: https://ipfs.io/ipfs/QmZDgFFMbyF3dvuuDfoXv5F6orq4kaDPo7m3QvnseUguzo\n        uint256 dgxRewardsPoolLastQuarter;\n\n        // The summation of all dgxRewardsPoolLastQuarter up until this quarter\n        uint256 sumRewardsFromBeginning;\n    }\n\n    // There are many function calls where all calculations/summations cannot be done in one transaction\n    // and require multiple transactions.\n    // This struct stores the intermediate results in between the calculating transactions\n    // These intermediate results are stored in IntermediateResultsStorage\n    struct IntermediateResults {\n        // weight of \"FOR\" votes counted up until the current calculation step\n        uint256 currentForCount;\n\n        // weight of \"AGAINST\" votes counted up until the current calculation step\n        uint256 currentAgainstCount;\n\n        // summation of effectiveDGDs up until the iteration of calculation\n        uint256 currentSumOfEffectiveBalance;\n\n        // Address of user until which the calculation has been done\n        address countedUntil;\n    }\n}\n\n// File: contracts/storage/DaoStorage.sol\npragma solidity ^0.4.25;\n\ncontract DaoStorage is DaoWhitelistingCommon, BytesIteratorStorage {\n    using DoublyLinkedList for DoublyLinkedList.Bytes;\n    using DaoStructs for DaoStructs.Voting;\n    using DaoStructs for DaoStructs.Proposal;\n    using DaoStructs for DaoStructs.ProposalVersion;\n\n    // List of all the proposals ever created in DigixDAO\n    DoublyLinkedList.Bytes allProposals;\n\n    // mapping of Proposal struct by its ID\n    // ID is also the IPFS doc hash of the first ever version of this proposal\n    mapping (bytes32 => DaoStructs.Proposal) proposalsById;\n\n    // mapping from state of a proposal to list of all proposals in that state\n    // proposals are added/removed from the state's list as their states change\n    // eg. when proposal is endorsed, when proposal is funded, etc\n    mapping (bytes32 => DoublyLinkedList.Bytes) proposalsByState;\n\n    constructor(address _resolver) public {\n        require(init(CONTRACT_STORAGE_DAO, _resolver));\n    }\n\n    /////////////////////////////// READ FUNCTIONS //////////////////////////////\n\n    /// @notice read all information and details of proposal\n    /// @param _proposalId Proposal ID, i.e. hash of IPFS doc Proposal ID, i.e. hash of IPFS doc\n    /// return {\n    ///   \"_doc\": \"Original IPFS doc of proposal, also ID of proposal\",\n    ///   \"_proposer\": \"Address of the proposer\",\n    ///   \"_endorser\": \"Address of the moderator that endorsed the proposal\",\n    ///   \"_state\": \"Current state of the proposal\",\n    ///   \"_timeCreated\": \"UTC timestamp at which proposal was created\",\n    ///   \"_nVersions\": \"Number of versions of the proposal\",\n    ///   \"_latestVersionDoc\": \"IPFS doc hash of the latest version of this proposal\",\n    ///   \"_finalVersion\": \"If finalized, the version of the final proposal\",\n    ///   \"_pausedOrStopped\": \"If the proposal is paused/stopped at the moment\",\n    ///   \"_isDigixProposal\": \"If the proposal has been created by founder or not\"\n    /// }\n    function readProposal(bytes32 _proposalId)\n        public\n        view\n        returns (\n            bytes32 _doc,\n            address _proposer,\n            address _endorser,\n            bytes32 _state,\n            uint256 _timeCreated,\n            uint256 _nVersions,\n            bytes32 _latestVersionDoc,\n            bytes32 _finalVersion,\n            bool _pausedOrStopped,\n            bool _isDigixProposal\n        )\n    {\n        require(senderIsAllowedToRead());\n        DaoStructs.Proposal storage _proposal = proposalsById[_proposalId];\n        _doc = _proposal.proposalId;\n        _proposer = _proposal.proposer;\n        _endorser = _proposal.endorser;\n        _state = _proposal.currentState;\n        _timeCreated = _proposal.timeCreated;\n        _nVersions = read_total_bytesarray(_proposal.proposalVersionDocs);\n        _latestVersionDoc = read_last_from_bytesarray(_proposal.proposalVersionDocs);\n        _finalVersion = _proposal.finalVersion;\n        _pausedOrStopped = _proposal.isPausedOrStopped;\n        _isDigixProposal = _proposal.isDigix;\n    }\n\n    function readProposalProposer(bytes32 _proposalId)\n        public\n        view\n        returns (address _proposer)\n    {\n        _proposer = proposalsById[_proposalId].proposer;\n    }\n\n    function readTotalPrlActions(bytes32 _proposalId)\n        public\n        view\n        returns (uint256 _length)\n    {\n        _length = proposalsById[_proposalId].prlActions.length;\n    }\n\n    function readPrlAction(bytes32 _proposalId, uint256 _index)\n        public\n        view\n        returns (uint256 _actionId, uint256 _time, bytes32 _doc)\n    {\n        DaoStructs.PrlAction[] memory _actions = proposalsById[_proposalId].prlActions;\n        require(_index < _actions.length);\n        _actionId = _actions[_index].actionId;\n        _time = _actions[_index].at;\n        _doc = _actions[_index].doc;\n    }\n\n    function readProposalDraftVotingResult(bytes32 _proposalId)\n        public\n        view\n        returns (bool _result)\n    {\n        require(senderIsAllowedToRead());\n        _result = proposalsById[_proposalId].draftVoting.passed;\n    }\n\n    function readProposalVotingResult(bytes32 _proposalId, uint256 _index)\n        public\n        view\n        returns (bool _result)\n    {\n        require(senderIsAllowedToRead());\n        _result = proposalsById[_proposalId].votingRounds[_index].passed;\n    }\n\n    function readProposalDraftVotingTime(bytes32 _proposalId)\n        public\n        view\n        returns (uint256 _start)\n    {\n        require(senderIsAllowedToRead());\n        _start = proposalsById[_proposalId].draftVoting.startTime;\n    }\n\n    function readProposalVotingTime(bytes32 _proposalId, uint256 _index)\n        public\n        view\n        returns (uint256 _start)\n    {\n        require(senderIsAllowedToRead());\n        _start = proposalsById[_proposalId].votingRounds[_index].startTime;\n    }\n\n    function readDraftVotingCount(bytes32 _proposalId, address[] _allUsers)\n        external\n        view\n        returns (uint256 _for, uint256 _against)\n    {\n        require(senderIsAllowedToRead());\n        return proposalsById[_proposalId].draftVoting.countVotes(_allUsers);\n    }\n\n    function readVotingCount(bytes32 _proposalId, uint256 _index, address[] _allUsers)\n        external\n        view\n        returns (uint256 _for, uint256 _against)\n    {\n        require(senderIsAllowedToRead());\n        return proposalsById[_proposalId].votingRounds[_index].countVotes(_allUsers);\n    }\n\n    function readVotingRoundVotes(bytes32 _proposalId, uint256 _index, address[] _allUsers, bool _vote)\n        external\n        view\n        returns (address[] memory _voters, uint256 _length)\n    {\n        require(senderIsAllowedToRead());\n        return proposalsById[_proposalId].votingRounds[_index].listVotes(_allUsers, _vote);\n    }\n\n    function readDraftVote(bytes32 _proposalId, address _voter)\n        public\n        view\n        returns (bool _vote, uint256 _weight)\n    {\n        require(senderIsAllowedToRead());\n        return proposalsById[_proposalId].draftVoting.readVote(_voter);\n    }\n\n    /// @notice returns the latest committed vote by a voter on a proposal\n    /// @param _proposalId proposal ID\n    /// @param _voter address of the voter\n    /// @return {\n    ///   \"_commitHash\": \"\"\n    /// }\n    function readComittedVote(bytes32 _proposalId, uint256 _index, address _voter)\n        public\n        view\n        returns (bytes32 _commitHash)\n    {\n        require(senderIsAllowedToRead());\n        _commitHash = proposalsById[_proposalId].votingRounds[_index].commits[_voter];\n    }\n\n    function readVote(bytes32 _proposalId, uint256 _index, address _voter)\n        public\n        view\n        returns (bool _vote, uint256 _weight)\n    {\n        require(senderIsAllowedToRead());\n        return proposalsById[_proposalId].votingRounds[_index].readVote(_voter);\n    }\n\n    /// @notice get all information and details of the first proposal\n    /// return {\n    ///   \"_id\": \"\"\n    /// }\n    function getFirstProposal()\n        public\n        view\n        returns (bytes32 _id)\n    {\n        _id = read_first_from_bytesarray(allProposals);\n    }\n\n    /// @notice get all information and details of the last proposal\n    /// return {\n    ///   \"_id\": \"\"\n    /// }\n    function getLastProposal()\n        public\n        view\n        returns (bytes32 _id)\n    {\n        _id = read_last_from_bytesarray(allProposals);\n    }\n\n    /// @notice get all information and details of proposal next to _proposalId\n    /// @param _proposalId Proposal ID, i.e. hash of IPFS doc\n    /// return {\n    ///   \"_id\": \"\"\n    /// }\n    function getNextProposal(bytes32 _proposalId)\n        public\n        view\n        returns (bytes32 _id)\n    {\n        _id = read_next_from_bytesarray(\n            allProposals,\n            _proposalId\n        );\n    }\n\n    /// @notice get all information and details of proposal previous to _proposalId\n    /// @param _proposalId Proposal ID, i.e. hash of IPFS doc\n    /// return {\n    ///   \"_id\": \"\"\n    /// }\n    function getPreviousProposal(bytes32 _proposalId)\n        public\n        view\n        returns (bytes32 _id)\n    {\n        _id = read_previous_from_bytesarray(\n            allProposals,\n            _proposalId\n        );\n    }\n\n    /// @notice get all information and details of the first proposal in state _stateId\n    /// @param _stateId State ID of the proposal\n    /// return {\n    ///   \"_id\": \"\"\n    /// }\n    function getFirstProposalInState(bytes32 _stateId)\n        public\n        view\n        returns (bytes32 _id)\n    {\n        require(senderIsAllowedToRead());\n        _id = read_first_from_bytesarray(proposalsByState[_stateId]);\n    }\n\n    /// @notice get all information and details of the last proposal in state _stateId\n    /// @param _stateId State ID of the proposal\n    /// return {\n    ///   \"_id\": \"\"\n    /// }\n    function getLastProposalInState(bytes32 _stateId)\n        public\n        view\n        returns (bytes32 _id)\n    {\n        require(senderIsAllowedToRead());\n        _id = read_last_from_bytesarray(proposalsByState[_stateId]);\n    }\n\n    /// @notice get all information and details of the next proposal to _proposalId in state _stateId\n    /// @param _stateId State ID of the proposal\n    /// return {\n    ///   \"_id\": \"\"\n    /// }\n    function getNextProposalInState(bytes32 _stateId, bytes32 _proposalId)\n        public\n        view\n        returns (bytes32 _id)\n    {\n        require(senderIsAllowedToRead());\n        _id = read_next_from_bytesarray(\n            proposalsByState[_stateId],\n            _proposalId\n        );\n    }\n\n    /// @notice get all information and details of the previous proposal to _proposalId in state _stateId\n    /// @param _stateId State ID of the proposal\n    /// return {\n    ///   \"_id\": \"\"\n    /// }\n    function getPreviousProposalInState(bytes32 _stateId, bytes32 _proposalId)\n        public\n        view\n        returns (bytes32 _id)\n    {\n        require(senderIsAllowedToRead());\n        _id = read_previous_from_bytesarray(\n            proposalsByState[_stateId],\n            _proposalId\n        );\n    }\n\n    /// @notice read proposal version details for a specific version\n    /// @param _proposalId Proposal ID, i.e. hash of IPFS doc\n    /// @param _version Version of proposal, i.e. hash of IPFS doc for specific version\n    /// return {\n    ///   \"_doc\": \"\",\n    ///   \"_created\": \"\",\n    ///   \"_milestoneFundings\": \"\"\n    /// }\n    function readProposalVersion(bytes32 _proposalId, bytes32 _version)\n        public\n        view\n        returns (\n            bytes32 _doc,\n            uint256 _created,\n            uint256[] _milestoneFundings,\n            uint256 _finalReward\n        )\n    {\n        return proposalsById[_proposalId].proposalVersions[_version].readVersion();\n    }\n\n    /**\n    @notice Read the fundings of a finalized proposal\n    @return {\n        \"_fundings\": \"fundings for the milestones\",\n        \"_finalReward\": \"the final reward\"\n    }\n    */\n    function readProposalFunding(bytes32 _proposalId)\n        public\n        view\n        returns (uint256[] memory _fundings, uint256 _finalReward)\n    {\n        require(senderIsAllowedToRead());\n        bytes32 _finalVersion = proposalsById[_proposalId].finalVersion;\n        require(_finalVersion != EMPTY_BYTES);\n        _fundings = proposalsById[_proposalId].proposalVersions[_finalVersion].milestoneFundings;\n        _finalReward = proposalsById[_proposalId].proposalVersions[_finalVersion].finalReward;\n    }\n\n    function readProposalMilestone(bytes32 _proposalId, uint256 _index)\n        public\n        view\n        returns (uint256 _funding)\n    {\n        require(senderIsAllowedToRead());\n        _funding = proposalsById[_proposalId].readProposalMilestone(_index);\n    }\n\n    /// @notice get proposal version details for the first version\n    /// @param _proposalId Proposal ID, i.e. hash of IPFS doc\n    /// return {\n    ///   \"_version\": \"\"\n    /// }\n    function getFirstProposalVersion(bytes32 _proposalId)\n        public\n        view\n        returns (bytes32 _version)\n    {\n        DaoStructs.Proposal storage _proposal = proposalsById[_proposalId];\n        _version = read_first_from_bytesarray(_proposal.proposalVersionDocs);\n    }\n\n    /// @notice get proposal version details for the last version\n    /// @param _proposalId Proposal ID, i.e. hash of IPFS doc\n    /// return {\n    ///   \"_version\": \"\"\n    /// }\n    function getLastProposalVersion(bytes32 _proposalId)\n        public\n        view\n        returns (bytes32 _version)\n    {\n        DaoStructs.Proposal storage _proposal = proposalsById[_proposalId];\n        _version = read_last_from_bytesarray(_proposal.proposalVersionDocs);\n    }\n\n    /// @notice get proposal version details for the next version to _version\n    /// @param _proposalId Proposal ID, i.e. hash of IPFS doc\n    /// @param _version Version of proposal\n    /// return {\n    ///   \"_nextVersion\": \"\"\n    /// }\n    function getNextProposalVersion(bytes32 _proposalId, bytes32 _version)\n        public\n        view\n        returns (bytes32 _nextVersion)\n    {\n        DaoStructs.Proposal storage _proposal = proposalsById[_proposalId];\n        _nextVersion = read_next_from_bytesarray(\n            _proposal.proposalVersionDocs,\n            _version\n        );\n    }\n\n    /// @notice get proposal version details for the previous version to _version\n    /// @param _proposalId Proposal ID, i.e. hash of IPFS doc\n    /// @param _version Version of proposal\n    /// return {\n    ///   \"_previousVersion\": \"\"\n    /// }\n    function getPreviousProposalVersion(bytes32 _proposalId, bytes32 _version)\n        public\n        view\n        returns (bytes32 _previousVersion)\n    {\n        DaoStructs.Proposal storage _proposal = proposalsById[_proposalId];\n        _previousVersion = read_previous_from_bytesarray(\n            _proposal.proposalVersionDocs,\n            _version\n        );\n    }\n\n    function isDraftClaimed(bytes32 _proposalId)\n        public\n        view\n        returns (bool _claimed)\n    {\n        _claimed = proposalsById[_proposalId].draftVoting.claimed;\n    }\n\n    function isClaimed(bytes32 _proposalId, uint256 _index)\n        public\n        view\n        returns (bool _claimed)\n    {\n        _claimed = proposalsById[_proposalId].votingRounds[_index].claimed;\n    }\n\n    function readProposalCollateralStatus(bytes32 _proposalId)\n        public\n        view\n        returns (uint256 _status)\n    {\n        require(senderIsAllowedToRead());\n        _status = proposalsById[_proposalId].collateralStatus;\n    }\n\n    function readProposalCollateralAmount(bytes32 _proposalId)\n        public\n        view\n        returns (uint256 _amount)\n    {\n        _amount = proposalsById[_proposalId].collateralAmount;\n    }\n\n    /// @notice Read the additional docs that are added after the proposal is finalized\n    /// @dev Will throw if the propsal is not finalized yet\n    function readProposalDocs(bytes32 _proposalId)\n        public\n        view\n        returns (bytes32[] _moreDocs)\n    {\n        bytes32 _finalVersion = proposalsById[_proposalId].finalVersion;\n        require(_finalVersion != EMPTY_BYTES);\n        _moreDocs = proposalsById[_proposalId].proposalVersions[_finalVersion].moreDocs;\n    }\n\n    function readIfMilestoneFunded(bytes32 _proposalId, uint256 _milestoneId)\n        public\n        view\n        returns (bool _funded)\n    {\n        require(senderIsAllowedToRead());\n        _funded = proposalsById[_proposalId].votingRounds[_milestoneId].funded;\n    }\n\n    ////////////////////////////// WRITE FUNCTIONS //////////////////////////////\n\n    function addProposal(\n        bytes32 _doc,\n        address _proposer,\n        uint256[] _milestoneFundings,\n        uint256 _finalReward,\n        bool _isFounder\n    )\n        external\n    {\n        require(sender_is(CONTRACT_DAO));\n        require(\n          (proposalsById[_doc].proposalId == EMPTY_BYTES) &&\n          (_doc != EMPTY_BYTES)\n        );\n\n        allProposals.append(_doc);\n        proposalsByState[PROPOSAL_STATE_PREPROPOSAL].append(_doc);\n        proposalsById[_doc].proposalId = _doc;\n        proposalsById[_doc].proposer = _proposer;\n        proposalsById[_doc].currentState = PROPOSAL_STATE_PREPROPOSAL;\n        proposalsById[_doc].timeCreated = now;\n        proposalsById[_doc].isDigix = _isFounder;\n        proposalsById[_doc].addProposalVersion(_doc, _milestoneFundings, _finalReward);\n    }\n\n    function editProposal(\n        bytes32 _proposalId,\n        bytes32 _newDoc,\n        uint256[] _newMilestoneFundings,\n        uint256 _finalReward\n    )\n        external\n    {\n        require(sender_is(CONTRACT_DAO));\n\n        proposalsById[_proposalId].addProposalVersion(_newDoc, _newMilestoneFundings, _finalReward);\n    }\n\n    /// @notice change fundings of a proposal\n    /// @dev Will throw if the proposal is not finalized yet\n    function changeFundings(bytes32 _proposalId, uint256[] _newMilestoneFundings, uint256 _finalReward)\n        external\n    {\n        require(sender_is(CONTRACT_DAO));\n\n        bytes32 _finalVersion = proposalsById[_proposalId].finalVersion;\n        require(_finalVersion != EMPTY_BYTES);\n        proposalsById[_proposalId].proposalVersions[_finalVersion].milestoneFundings = _newMilestoneFundings;\n        proposalsById[_proposalId].proposalVersions[_finalVersion].finalReward = _finalReward;\n    }\n\n    /// @dev Will throw if the proposal is not finalized yet\n    function addProposalDoc(bytes32 _proposalId, bytes32 _newDoc)\n        public\n    {\n        require(sender_is(CONTRACT_DAO));\n\n        bytes32 _finalVersion = proposalsById[_proposalId].finalVersion;\n        require(_finalVersion != EMPTY_BYTES); //already checked in interactive layer, but why not\n        proposalsById[_proposalId].proposalVersions[_finalVersion].moreDocs.push(_newDoc);\n    }\n\n    function finalizeProposal(bytes32 _proposalId)\n        public\n    {\n        require(sender_is(CONTRACT_DAO));\n\n        proposalsById[_proposalId].finalVersion = getLastProposalVersion(_proposalId);\n    }\n\n    function updateProposalEndorse(\n        bytes32 _proposalId,\n        address _endorser\n    )\n        public\n    {\n        require(sender_is(CONTRACT_DAO));\n\n        DaoStructs.Proposal storage _proposal = proposalsById[_proposalId];\n        _proposal.endorser = _endorser;\n        _proposal.currentState = PROPOSAL_STATE_DRAFT;\n        proposalsByState[PROPOSAL_STATE_PREPROPOSAL].remove_item(_proposalId);\n        proposalsByState[PROPOSAL_STATE_DRAFT].append(_proposalId);\n    }\n\n    function setProposalDraftPass(bytes32 _proposalId, bool _result)\n        public\n    {\n        require(sender_is(CONTRACT_DAO_VOTING_CLAIMS));\n\n        proposalsById[_proposalId].draftVoting.passed = _result;\n        if (_result) {\n            proposalsByState[PROPOSAL_STATE_DRAFT].remove_item(_proposalId);\n            proposalsByState[PROPOSAL_STATE_MODERATED].append(_proposalId);\n            proposalsById[_proposalId].currentState = PROPOSAL_STATE_MODERATED;\n        } else {\n            closeProposalInternal(_proposalId);\n        }\n    }\n\n    function setProposalPass(bytes32 _proposalId, uint256 _index, bool _result)\n        public\n    {\n        require(sender_is(CONTRACT_DAO_VOTING_CLAIMS));\n\n        if (!_result) {\n            closeProposalInternal(_proposalId);\n        } else if (_index == 0) {\n            proposalsByState[PROPOSAL_STATE_MODERATED].remove_item(_proposalId);\n            proposalsByState[PROPOSAL_STATE_ONGOING].append(_proposalId);\n            proposalsById[_proposalId].currentState = PROPOSAL_STATE_ONGOING;\n        }\n        proposalsById[_proposalId].votingRounds[_index].passed = _result;\n    }\n\n    function setProposalDraftVotingTime(\n        bytes32 _proposalId,\n        uint256 _time\n    )\n        public\n    {\n        require(sender_is(CONTRACT_DAO));\n\n        proposalsById[_proposalId].draftVoting.startTime = _time;\n    }\n\n    function setProposalVotingTime(\n        bytes32 _proposalId,\n        uint256 _index,\n        uint256 _time\n    )\n        public\n    {\n        require(sender_is_from([CONTRACT_DAO, CONTRACT_DAO_VOTING_CLAIMS, EMPTY_BYTES]));\n\n        proposalsById[_proposalId].votingRounds[_index].startTime = _time;\n    }\n\n    function setDraftVotingClaim(bytes32 _proposalId, bool _claimed)\n        public\n    {\n        require(sender_is(CONTRACT_DAO_VOTING_CLAIMS));\n        proposalsById[_proposalId].draftVoting.claimed = _claimed;\n    }\n\n    function setVotingClaim(bytes32 _proposalId, uint256 _index, bool _claimed)\n        public\n    {\n        require(sender_is(CONTRACT_DAO_VOTING_CLAIMS));\n        proposalsById[_proposalId].votingRounds[_index].claimed = _claimed;\n    }\n\n    function setProposalCollateralStatus(bytes32 _proposalId, uint256 _status)\n        public\n    {\n        require(sender_is_from([CONTRACT_DAO_VOTING_CLAIMS, CONTRACT_DAO_FUNDING_MANAGER, CONTRACT_DAO]));\n        proposalsById[_proposalId].collateralStatus = _status;\n    }\n\n    function setProposalCollateralAmount(bytes32 _proposalId, uint256 _amount)\n        public\n    {\n        require(sender_is(CONTRACT_DAO));\n        proposalsById[_proposalId].collateralAmount = _amount;\n    }\n\n    function updateProposalPRL(\n        bytes32 _proposalId,\n        uint256 _action,\n        bytes32 _doc,\n        uint256 _time\n    )\n        public\n    {\n        require(sender_is(CONTRACT_DAO));\n        require(proposalsById[_proposalId].currentState != PROPOSAL_STATE_CLOSED);\n\n        DaoStructs.PrlAction memory prlAction;\n        prlAction.at = _time;\n        prlAction.doc = _doc;\n        prlAction.actionId = _action;\n        proposalsById[_proposalId].prlActions.push(prlAction);\n\n        if (_action == PRL_ACTION_PAUSE) {\n          proposalsById[_proposalId].isPausedOrStopped = true;\n        } else if (_action == PRL_ACTION_UNPAUSE) {\n          proposalsById[_proposalId].isPausedOrStopped = false;\n        } else { // STOP\n          proposalsById[_proposalId].isPausedOrStopped = true;\n          closeProposalInternal(_proposalId);\n        }\n    }\n\n    function closeProposalInternal(bytes32 _proposalId)\n        internal\n    {\n        bytes32 _currentState = proposalsById[_proposalId].currentState;\n        proposalsByState[_currentState].remove_item(_proposalId);\n        proposalsByState[PROPOSAL_STATE_CLOSED].append(_proposalId);\n        proposalsById[_proposalId].currentState = PROPOSAL_STATE_CLOSED;\n    }\n\n    function addDraftVote(\n        bytes32 _proposalId,\n        address _voter,\n        bool _vote,\n        uint256 _weight\n    )\n        public\n    {\n        require(sender_is(CONTRACT_DAO_VOTING));\n\n        DaoStructs.Proposal storage _proposal = proposalsById[_proposalId];\n        if (_vote) {\n            _proposal.draftVoting.yesVotes[_voter] = _weight;\n            if (_proposal.draftVoting.noVotes[_voter] > 0) { // minimize number of writes to storage, since EIP-1087 is not implemented yet\n                _proposal.draftVoting.noVotes[_voter] = 0;\n            }\n        } else {\n            _proposal.draftVoting.noVotes[_voter] = _weight;\n            if (_proposal.draftVoting.yesVotes[_voter] > 0) {\n                _proposal.draftVoting.yesVotes[_voter] = 0;\n            }\n        }\n    }\n\n    function commitVote(\n        bytes32 _proposalId,\n        bytes32 _hash,\n        address _voter,\n        uint256 _index\n    )\n        public\n    {\n        require(sender_is(CONTRACT_DAO_VOTING));\n\n        proposalsById[_proposalId].votingRounds[_index].commits[_voter] = _hash;\n    }\n\n    function revealVote(\n        bytes32 _proposalId,\n        address _voter,\n        bool _vote,\n        uint256 _weight,\n        uint256 _index\n    )\n        public\n    {\n        require(sender_is(CONTRACT_DAO_VOTING));\n\n        proposalsById[_proposalId].votingRounds[_index].revealVote(_voter, _vote, _weight);\n    }\n\n    function closeProposal(bytes32 _proposalId)\n        public\n    {\n        require(sender_is(CONTRACT_DAO));\n        closeProposalInternal(_proposalId);\n    }\n\n    function archiveProposal(bytes32 _proposalId)\n        public\n    {\n        require(sender_is(CONTRACT_DAO_VOTING_CLAIMS));\n        bytes32 _currentState = proposalsById[_proposalId].currentState;\n        proposalsByState[_currentState].remove_item(_proposalId);\n        proposalsByState[PROPOSAL_STATE_ARCHIVED].append(_proposalId);\n        proposalsById[_proposalId].currentState = PROPOSAL_STATE_ARCHIVED;\n    }\n\n    function setMilestoneFunded(bytes32 _proposalId, uint256 _milestoneId)\n        public\n    {\n        require(sender_is(CONTRACT_DAO_FUNDING_MANAGER));\n        proposalsById[_proposalId].votingRounds[_milestoneId].funded = true;\n    }\n}\n\n// File: @digix/solidity-collections/contracts/abstract/AddressIteratorStorage.sol\npragma solidity ^0.4.19;\n\n/**\n  @title Address Iterator Storage\n  @author DigixGlobal Pte Ltd\n  @notice See: [Doubly Linked List](/DoublyLinkedList)\n*/\ncontract AddressIteratorStorage {\n\n  // Initialize Doubly Linked List of Address\n  using DoublyLinkedList for DoublyLinkedList.Address;\n\n  /**\n    @notice Reads the first item from the list of Address\n    @param _list The source list\n    @return {\"_item\" : \"The first item from the list\"}\n  */\n  function read_first_from_addresses(DoublyLinkedList.Address storage _list)\n           internal\n           constant\n           returns (address _item)\n  {\n    _item = _list.start_item();\n  }\n\n\n  /**\n    @notice Reads the last item from the list of Address\n    @param _list The source list\n    @return {\"_item\" : \"The last item from the list\"}\n  */\n  function read_last_from_addresses(DoublyLinkedList.Address storage _list)\n           internal\n           constant\n           returns (address _item)\n  {\n    _item = _list.end_item();\n  }\n\n  /**\n    @notice Reads the next item on the list of Address\n    @param _list The source list\n    @param _current_item The current item to be used as base line\n    @return {\"_item\" : \"The next item from the list based on the specieid `_current_item`\"}\n  */\n  function read_next_from_addresses(DoublyLinkedList.Address storage _list, address _current_item)\n           internal\n           constant\n           returns (address _item)\n  {\n    _item = _list.next_item(_current_item);\n  }\n\n  /**\n    @notice Reads the previous item on the list of Address\n    @param _list The source list\n    @param _current_item The current item to be used as base line\n    @return {\"_item\" : \"The previous item from the list based on the spcified `_current_item`\"}\n  */\n  function read_previous_from_addresses(DoublyLinkedList.Address storage _list, address _current_item)\n           internal\n           constant\n           returns (address _item)\n  {\n    _item = _list.previous_item(_current_item);\n  }\n\n  /**\n    @notice Reads the list of Address and returns the length of the list\n    @param _list The source list\n    @return {\"_count\": \"The lenght of the list\"}\n  */\n  function read_total_addresses(DoublyLinkedList.Address storage _list)\n           internal\n           constant\n           returns (uint256 _count)\n  {\n    _count = _list.total();\n  }\n\n}\n\n// File: contracts/storage/DaoStakeStorage.sol\npragma solidity ^0.4.25;\n\ncontract DaoStakeStorage is ResolverClient, DaoConstants, AddressIteratorStorage {\n    using DoublyLinkedList for DoublyLinkedList.Address;\n\n    // This is the DGD stake of a user (one that is considered in the DAO)\n    mapping (address => uint256) public lockedDGDStake;\n\n    // This is the actual number of DGDs locked by user\n    // may be more than the lockedDGDStake\n    // in case they locked during the main phase\n    mapping (address => uint256) public actualLockedDGD;\n\n    // The total locked DGDs in the DAO (summation of lockedDGDStake)\n    uint256 public totalLockedDGDStake;\n\n    // The total locked DGDs by moderators\n    uint256 public totalModeratorLockedDGDStake;\n\n    // The list of participants in DAO\n    // actual participants will be subset of this list\n    DoublyLinkedList.Address allParticipants;\n\n    // The list of moderators in DAO\n    // actual moderators will be subset of this list\n    DoublyLinkedList.Address allModerators;\n\n    // Boolean to mark if an address has redeemed\n    // reputation points for their DGD Badge\n    mapping (address => bool) public redeemedBadge;\n\n    // mapping to note whether an address has claimed their\n    // reputation bonus for carbon vote participation\n    mapping (address => bool) public carbonVoteBonusClaimed;\n\n    constructor(address _resolver) public {\n        require(init(CONTRACT_STORAGE_DAO_STAKE, _resolver));\n    }\n\n    function redeemBadge(address _user)\n        public\n    {\n        require(sender_is(CONTRACT_DAO_STAKE_LOCKING));\n        redeemedBadge[_user] = true;\n    }\n\n    function setCarbonVoteBonusClaimed(address _user)\n        public\n    {\n        require(sender_is(CONTRACT_DAO_STAKE_LOCKING));\n        carbonVoteBonusClaimed[_user] = true;\n    }\n\n    function updateTotalLockedDGDStake(uint256 _totalLockedDGDStake)\n        public\n    {\n        require(sender_is_from([CONTRACT_DAO_STAKE_LOCKING, CONTRACT_DAO_REWARDS_MANAGER, EMPTY_BYTES]));\n        totalLockedDGDStake = _totalLockedDGDStake;\n    }\n\n    function updateTotalModeratorLockedDGDs(uint256 _totalLockedDGDStake)\n        public\n    {\n        require(sender_is_from([CONTRACT_DAO_STAKE_LOCKING, CONTRACT_DAO_REWARDS_MANAGER, EMPTY_BYTES]));\n        totalModeratorLockedDGDStake = _totalLockedDGDStake;\n    }\n\n    function updateUserDGDStake(address _user, uint256 _actualLockedDGD, uint256 _lockedDGDStake)\n        public\n    {\n        require(sender_is(CONTRACT_DAO_STAKE_LOCKING));\n        actualLockedDGD[_user] = _actualLockedDGD;\n        lockedDGDStake[_user] = _lockedDGDStake;\n    }\n\n    function readUserDGDStake(address _user)\n        public\n        view\n        returns (\n            uint256 _actualLockedDGD,\n            uint256 _lockedDGDStake\n        )\n    {\n        _actualLockedDGD = actualLockedDGD[_user];\n        _lockedDGDStake = lockedDGDStake[_user];\n    }\n\n    function addToParticipantList(address _user)\n        public\n        returns (bool _success)\n    {\n        require(sender_is(CONTRACT_DAO_STAKE_LOCKING));\n        _success = allParticipants.append(_user);\n    }\n\n    function removeFromParticipantList(address _user)\n        public\n        returns (bool _success)\n    {\n        require(sender_is(CONTRACT_DAO_STAKE_LOCKING));\n        _success = allParticipants.remove_item(_user);\n    }\n\n    function addToModeratorList(address _user)\n        public\n        returns (bool _success)\n    {\n        require(sender_is(CONTRACT_DAO_STAKE_LOCKING));\n        _success = allModerators.append(_user);\n    }\n\n    function removeFromModeratorList(address _user)\n        public\n        returns (bool _success)\n    {\n        require(sender_is(CONTRACT_DAO_STAKE_LOCKING));\n        _success = allModerators.remove_item(_user);\n    }\n\n    function isInParticipantList(address _user)\n        public\n        view\n        returns (bool _is)\n    {\n        _is = allParticipants.find(_user) != 0;\n    }\n\n    function isInModeratorsList(address _user)\n        public\n        view\n        returns (bool _is)\n    {\n        _is = allModerators.find(_user) != 0;\n    }\n\n    function readFirstModerator()\n        public\n        view\n        returns (address _item)\n    {\n        _item = read_first_from_addresses(allModerators);\n    }\n\n    function readLastModerator()\n        public\n        view\n        returns (address _item)\n    {\n        _item = read_last_from_addresses(allModerators);\n    }\n\n    function readNextModerator(address _current_item)\n        public\n        view\n        returns (address _item)\n    {\n        _item = read_next_from_addresses(allModerators, _current_item);\n    }\n\n    function readPreviousModerator(address _current_item)\n        public\n        view\n        returns (address _item)\n    {\n        _item = read_previous_from_addresses(allModerators, _current_item);\n    }\n\n    function readTotalModerators()\n        public\n        view\n        returns (uint256 _total_count)\n    {\n        _total_count = read_total_addresses(allModerators);\n    }\n\n    function readFirstParticipant()\n        public\n        view\n        returns (address _item)\n    {\n        _item = read_first_from_addresses(allParticipants);\n    }\n\n    function readLastParticipant()\n        public\n        view\n        returns (address _item)\n    {\n        _item = read_last_from_addresses(allParticipants);\n    }\n\n    function readNextParticipant(address _current_item)\n        public\n        view\n        returns (address _item)\n    {\n        _item = read_next_from_addresses(allParticipants, _current_item);\n    }\n\n    function readPreviousParticipant(address _current_item)\n        public\n        view\n        returns (address _item)\n    {\n        _item = read_previous_from_addresses(allParticipants, _current_item);\n    }\n\n    function readTotalParticipant()\n        public\n        view\n        returns (uint256 _total_count)\n    {\n        _total_count = read_total_addresses(allParticipants);\n    }\n}\n\n// File: contracts/service/DaoListingService.sol\npragma solidity ^0.4.25;\n\n/**\n@title Contract to list various storage states from DigixDAO\n@author Digix Holdings\n*/\ncontract DaoListingService is\n    AddressIteratorInteractive,\n    BytesIteratorInteractive,\n    IndexedBytesIteratorInteractive,\n    DaoWhitelistingCommon\n{\n\n    /**\n    @notice Constructor\n    @param _resolver address of contract resolver\n    */\n    constructor(address _resolver) public {\n        require(init(CONTRACT_SERVICE_DAO_LISTING, _resolver));\n    }\n\n    function daoStakeStorage()\n        internal\n        view\n        returns (DaoStakeStorage _contract)\n    {\n        _contract = DaoStakeStorage(get_contract(CONTRACT_STORAGE_DAO_STAKE));\n    }\n\n    function daoStorage()\n        internal\n        view\n        returns (DaoStorage _contract)\n    {\n        _contract = DaoStorage(get_contract(CONTRACT_STORAGE_DAO));\n    }\n\n    /**\n    @notice function to list moderators\n    @dev note that this list may include some additional entries that are\n         not moderators in the current quarter. This may happen if they\n         were moderators in the previous quarter, but have not confirmed\n         their participation in the current quarter. For a single address,\n         a better way to know if moderator or not is:\n         Dao.isModerator(_user)\n    @param _count number of addresses to list\n    @param _from_start boolean, whether to list from start or end\n    @return {\n      \"_moderators\": \"list of moderator addresses\"\n    }\n    */\n    function listModerators(uint256 _count, bool _from_start)\n        public\n        view\n        returns (address[] _moderators)\n    {\n        _moderators = list_addresses(\n            _count,\n            daoStakeStorage().readFirstModerator,\n            daoStakeStorage().readLastModerator,\n            daoStakeStorage().readNextModerator,\n            daoStakeStorage().readPreviousModerator,\n            _from_start\n        );\n    }\n\n    /**\n    @notice function to list moderators from a particular moderator\n    @dev note that this list may include some additional entries that are\n         not moderators in the current quarter. This may happen if they\n         were moderators in the previous quarter, but have not confirmed\n         their participation in the current quarter. For a single address,\n         a better way to know if moderator or not is:\n         Dao.isModerator(_user)\n\n         Another note: this function will start listing AFTER the _currentModerator\n         For example: we have [address1, address2, address3, address4]. listModeratorsFrom(address1, 2, true) = [address2, address3]\n    @param _currentModerator start the list after this moderator address\n    @param _count number of addresses to list\n    @param _from_start boolean, whether to list from start or end\n    @return {\n      \"_moderators\": \"list of moderator addresses\"\n    }\n    */\n    function listModeratorsFrom(\n        address _currentModerator,\n        uint256 _count,\n        bool _from_start\n    )\n        public\n        view\n        returns (address[] _moderators)\n    {\n        _moderators = list_addresses_from(\n            _currentModerator,\n            _count,\n            daoStakeStorage().readFirstModerator,\n            daoStakeStorage().readLastModerator,\n            daoStakeStorage().readNextModerator,\n            daoStakeStorage().readPreviousModerator,\n            _from_start\n        );\n    }\n\n    /**\n    @notice function to list participants\n    @dev note that this list may include some additional entries that are\n         not participants in the current quarter. This may happen if they\n         were participants in the previous quarter, but have not confirmed\n         their participation in the current quarter. For a single address,\n         a better way to know if participant or not is:\n         Dao.isParticipant(_user)\n    @param _count number of addresses to list\n    @param _from_start boolean, whether to list from start or end\n    @return {\n      \"_participants\": \"list of participant addresses\"\n    }\n    */\n    function listParticipants(uint256 _count, bool _from_start)\n        public\n        view\n        returns (address[] _participants)\n    {\n        _participants = list_addresses(\n            _count,\n            daoStakeStorage().readFirstParticipant,\n            daoStakeStorage().readLastParticipant,\n            daoStakeStorage().readNextParticipant,\n            daoStakeStorage().readPreviousParticipant,\n            _from_start\n        );\n    }\n\n    /**\n    @notice function to list participants from a particular participant\n    @dev note that this list may include some additional entries that are\n         not participants in the current quarter. This may happen if they\n         were participants in the previous quarter, but have not confirmed\n         their participation in the current quarter. For a single address,\n         a better way to know if participant or not is:\n         contracts.dao.isParticipant(_user)\n\n         Another note: this function will start listing AFTER the _currentParticipant\n         For example: we have [address1, address2, address3, address4]. listParticipantsFrom(address1, 2, true) = [address2, address3]\n    @param _currentParticipant list from AFTER this participant address\n    @param _count number of addresses to list\n    @param _from_start boolean, whether to list from start or end\n    @return {\n      \"_participants\": \"list of participant addresses\"\n    }\n    */\n    function listParticipantsFrom(\n        address _currentParticipant,\n        uint256 _count,\n        bool _from_start\n    )\n        public\n        view\n        returns (address[] _participants)\n    {\n        _participants = list_addresses_from(\n            _currentParticipant,\n            _count,\n            daoStakeStorage().readFirstParticipant,\n            daoStakeStorage().readLastParticipant,\n            daoStakeStorage().readNextParticipant,\n            daoStakeStorage().readPreviousParticipant,\n            _from_start\n        );\n    }\n\n    /**\n    @notice function to list _count no. of proposals\n    @param _count number of proposals to list\n    @param _from_start boolean value, true if count from start, false if count from end\n    @return {\n      \"_proposals\": \"the list of proposal IDs\"\n    }\n    */\n    function listProposals(\n        uint256 _count,\n        bool _from_start\n    )\n        public\n        view\n        returns (bytes32[] _proposals)\n    {\n        _proposals = list_bytesarray(\n            _count,\n            daoStorage().getFirstProposal,\n            daoStorage().getLastProposal,\n            daoStorage().getNextProposal,\n            daoStorage().getPreviousProposal,\n            _from_start\n        );\n    }\n\n    /**\n    @notice function to list _count no. of proposals from AFTER _currentProposal\n    @param _currentProposal ID of proposal to list proposals from\n    @param _count number of proposals to list\n    @param _from_start boolean value, true if count forwards, false if count backwards\n    @return {\n      \"_proposals\": \"the list of proposal IDs\"\n    }\n    */\n    function listProposalsFrom(\n        bytes32 _currentProposal,\n        uint256 _count,\n        bool _from_start\n    )\n        public\n        view\n        returns (bytes32[] _proposals)\n    {\n        _proposals = list_bytesarray_from(\n            _currentProposal,\n            _count,\n            daoStorage().getFirstProposal,\n            daoStorage().getLastProposal,\n            daoStorage().getNextProposal,\n            daoStorage().getPreviousProposal,\n            _from_start\n        );\n    }\n\n    /**\n    @notice function to list _count no. of proposals in state _stateId\n    @param _stateId state of proposal\n    @param _count number of proposals to list\n    @param _from_start boolean value, true if count from start, false if count from end\n    @return {\n      \"_proposals\": \"the list of proposal IDs\"\n    }\n    */\n    function listProposalsInState(\n        bytes32 _stateId,\n        uint256 _count,\n        bool _from_start\n    )\n        public\n        view\n        returns (bytes32[] _proposals)\n    {\n        require(senderIsAllowedToRead());\n        _proposals = list_indexed_bytesarray(\n            _stateId,\n            _count,\n            daoStorage().getFirstProposalInState,\n            daoStorage().getLastProposalInState,\n            daoStorage().getNextProposalInState,\n            daoStorage().getPreviousProposalInState,\n            _from_start\n        );\n    }\n\n    /**\n    @notice function to list _count no. of proposals in state _stateId from AFTER _currentProposal\n    @param _stateId state of proposal\n    @param _currentProposal ID of proposal to list proposals from\n    @param _count number of proposals to list\n    @param _from_start boolean value, true if count forwards, false if count backwards\n    @return {\n      \"_proposals\": \"the list of proposal IDs\"\n    }\n    */\n    function listProposalsInStateFrom(\n        bytes32 _stateId,\n        bytes32 _currentProposal,\n        uint256 _count,\n        bool _from_start\n    )\n        public\n        view\n        returns (bytes32[] _proposals)\n    {\n        require(senderIsAllowedToRead());\n        _proposals = list_indexed_bytesarray_from(\n            _stateId,\n            _currentProposal,\n            _count,\n            daoStorage().getFirstProposalInState,\n            daoStorage().getLastProposalInState,\n            daoStorage().getNextProposalInState,\n            daoStorage().getPreviousProposalInState,\n            _from_start\n        );\n    }\n\n    /**\n    @notice function to list proposal versions\n    @param _proposalId ID of the proposal\n    @param _count number of proposal versions to list\n    @param _from_start boolean, true to list from start, false to list from end\n    @return {\n      \"_versions\": \"list of proposal versions\"\n    }\n    */\n    function listProposalVersions(\n        bytes32 _proposalId,\n        uint256 _count,\n        bool _from_start\n    )\n        public\n        view\n        returns (bytes32[] _versions)\n    {\n        _versions = list_indexed_bytesarray(\n            _proposalId,\n            _count,\n            daoStorage().getFirstProposalVersion,\n            daoStorage().getLastProposalVersion,\n            daoStorage().getNextProposalVersion,\n            daoStorage().getPreviousProposalVersion,\n            _from_start\n        );\n    }\n\n    /**\n    @notice function to list proposal versions from AFTER a particular version\n    @param _proposalId ID of the proposal\n    @param _currentVersion version to list _count versions from\n    @param _count number of proposal versions to list\n    @param _from_start boolean, true to list from start, false to list from end\n    @return {\n      \"_versions\": \"list of proposal versions\"\n    }\n    */\n    function listProposalVersionsFrom(\n        bytes32 _proposalId,\n        bytes32 _currentVersion,\n        uint256 _count,\n        bool _from_start\n    )\n        public\n        view\n        returns (bytes32[] _versions)\n    {\n        _versions = list_indexed_bytesarray_from(\n            _proposalId,\n            _currentVersion,\n            _count,\n            daoStorage().getFirstProposalVersion,\n            daoStorage().getLastProposalVersion,\n            daoStorage().getNextProposalVersion,\n            daoStorage().getPreviousProposalVersion,\n            _from_start\n        );\n    }\n}\n\n// File: @digix/solidity-collections/contracts/abstract/IndexedAddressIteratorStorage.sol\npragma solidity ^0.4.19;\n\n/**\n  @title Indexed Address IteratorStorage\n  @author DigixGlobal Pte Ltd\n  @notice This contract utilizes: [Doubly Linked List](/DoublyLinkedList)\n*/\ncontract IndexedAddressIteratorStorage {\n\n  using DoublyLinkedList for DoublyLinkedList.IndexedAddress;\n  /**\n    @notice Reads the first item from an Indexed Address Doubly Linked List\n    @param _list The source list\n    @param _collection_index Index of the Collection to evaluate\n    @return {\"_item\" : \"First item on the list\"}\n  */\n  function read_first_from_indexed_addresses(DoublyLinkedList.IndexedAddress storage _list, bytes32 _collection_index)\n           internal\n           constant\n           returns (address _item)\n  {\n    _item = _list.start_item(_collection_index);\n  }\n\n  /**\n    @notice Reads the last item from an Indexed Address Doubly Linked list\n    @param _list The source list\n    @param _collection_index Index of the Collection to evaluate\n    @return {\"_item\" : \"First item on the list\"}\n  */\n  function read_last_from_indexed_addresses(DoublyLinkedList.IndexedAddress storage _list, bytes32 _collection_index)\n           internal\n           constant\n           returns (address _item)\n  {\n    _item = _list.end_item(_collection_index);\n  }\n\n  /**\n    @notice Reads the next item from an Indexed Address Doubly Linked List based on the specified `_current_item`\n    @param _list The source list\n    @param _collection_index Index of the Collection to evaluate\n    @param _current_item The current item to use as base line\n    @return {\"_item\": \"The next item on the list\"}\n  */\n  function read_next_from_indexed_addresses(DoublyLinkedList.IndexedAddress storage _list, bytes32 _collection_index, address _current_item)\n           internal\n           constant\n           returns (address _item)\n  {\n    _item = _list.next_item(_collection_index, _current_item);\n  }\n\n  /**\n    @notice Reads the previous item from an Index Address Doubly Linked List based on the specified `_current_item`\n    @param _list The source list\n    @param _collection_index Index of the Collection to evaluate\n    @param _current_item The current item to use as base line\n    @return {\"_item\" : \"The previous item on the list\"}\n  */\n  function read_previous_from_indexed_addresses(DoublyLinkedList.IndexedAddress storage _list, bytes32 _collection_index, address _current_item)\n           internal\n           constant\n           returns (address _item)\n  {\n    _item = _list.previous_item(_collection_index, _current_item);\n  }\n\n\n  /**\n    @notice Reads the total number of items in an Indexed Address Doubly Linked List\n    @param _list  The source list\n    @param _collection_index Index of the Collection to evaluate\n    @return {\"_count\": \"Length of the Doubly Linked list\"}\n  */\n  function read_total_indexed_addresses(DoublyLinkedList.IndexedAddress storage _list, bytes32 _collection_index)\n           internal\n           constant\n           returns (uint256 _count)\n  {\n    _count = _list.total(_collection_index);\n  }\n\n}\n\n// File: @digix/solidity-collections/contracts/abstract/UintIteratorStorage.sol\npragma solidity ^0.4.19;\n\n/**\n  @title Uint Iterator Storage\n  @author DigixGlobal Pte Ltd\n*/\ncontract UintIteratorStorage {\n\n  using DoublyLinkedList for DoublyLinkedList.Uint;\n\n  /**\n    @notice Returns the first item from a `DoublyLinkedList.Uint` list\n    @param _list The DoublyLinkedList.Uint list\n    @return {\"_item\": \"The first item\"}\n  */\n  function read_first_from_uints(DoublyLinkedList.Uint storage _list)\n           internal\n           constant\n           returns (uint256 _item)\n  {\n    _item = _list.start_item();\n  }\n\n  /**\n    @notice Returns the last item from a `DoublyLinkedList.Uint` list\n    @param _list The DoublyLinkedList.Uint list\n    @return {\"_item\": \"The last item\"}\n  */\n  function read_last_from_uints(DoublyLinkedList.Uint storage _list)\n           internal\n           constant\n           returns (uint256 _item)\n  {\n    _item = _list.end_item();\n  }\n\n  /**\n    @notice Returns the next item from a `DoublyLinkedList.Uint` list based on the specified `_current_item`\n    @param _list The DoublyLinkedList.Uint list\n    @param _current_item The current item\n    @return {\"_item\": \"The next item\"}\n  */\n  function read_next_from_uints(DoublyLinkedList.Uint storage _list, uint256 _current_item)\n           internal\n           constant\n           returns (uint256 _item)\n  {\n    _item = _list.next_item(_current_item);\n  }\n\n  /**\n    @notice Returns the previous item from a `DoublyLinkedList.Uint` list based on the specified `_current_item`\n    @param _list The DoublyLinkedList.Uint list\n    @param _current_item The current item\n    @return {\"_item\": \"The previous item\"}\n  */\n  function read_previous_from_uints(DoublyLinkedList.Uint storage _list, uint256 _current_item)\n           internal\n           constant\n           returns (uint256 _item)\n  {\n    _item = _list.previous_item(_current_item);\n  }\n\n  /**\n    @notice Returns the total count of itemsfrom a `DoublyLinkedList.Uint` list\n    @param _list The DoublyLinkedList.Uint list\n    @return {\"_count\": \"The total count of items\"}\n  */\n  function read_total_uints(DoublyLinkedList.Uint storage _list)\n           internal\n           constant\n           returns (uint256 _count)\n  {\n    _count = _list.total();\n  }\n\n}\n\n// File: @digix/cdap/contracts/storage/DirectoryStorage.sol\npragma solidity ^0.4.16;\n\n/**\n@title Directory Storage contains information of a directory\n@author DigixGlobal\n*/\ncontract DirectoryStorage is IndexedAddressIteratorStorage, UintIteratorStorage {\n\n  using DoublyLinkedList for DoublyLinkedList.IndexedAddress;\n  using DoublyLinkedList for DoublyLinkedList.Uint;\n\n  struct User {\n    bytes32 document;\n    bool active;\n  }\n\n  struct Group {\n    bytes32 name;\n    bytes32 document;\n    uint256 role_id;\n    mapping(address => User) members_by_address;\n  }\n\n  struct System {\n    DoublyLinkedList.Uint groups;\n    DoublyLinkedList.IndexedAddress groups_collection;\n    mapping (uint256 => Group) groups_by_id;\n    mapping (address => uint256) group_ids_by_address;\n    mapping (uint256 => bytes32) roles_by_id;\n    bool initialized;\n    uint256 total_groups;\n  }\n\n  System system;\n\n  /**\n  @notice Initializes directory settings\n  @return _success If directory initialization is successful\n  */\n  function initialize_directory()\n           internal\n           returns (bool _success)\n  {\n    require(system.initialized == false);\n    system.total_groups = 0;\n    system.initialized = true;\n    internal_create_role(1, \"root\");\n    internal_create_group(1, \"root\", \"\");\n    _success = internal_update_add_user_to_group(1, tx.origin, \"\");\n  }\n\n  /**\n  @notice Creates a new role with the given information\n  @param _role_id Id of the new role\n  @param _name Name of the new role\n  @return {\"_success\": \"If creation of new role is successful\"}\n  */\n  function internal_create_role(uint256 _role_id, bytes32 _name)\n           internal\n           returns (bool _success)\n  {\n    require(_role_id > 0);\n    require(_name != bytes32(0x0));\n    system.roles_by_id[_role_id] = _name;\n    _success = true;\n  }\n\n  /**\n  @notice Returns the role's name of a role id\n  @param _role_id Id of the role\n  @return {\"_name\": \"Name of the role\"}\n  */\n  function read_role(uint256 _role_id)\n           public\n           constant\n           returns (bytes32 _name)\n  {\n    _name = system.roles_by_id[_role_id];\n  }\n\n  /**\n  @notice Creates a new group with the given information\n  @param _role_id Role id of the new group\n  @param _name Name of the new group\n  @param _document Document of the new group\n  @return {\n    \"_success\": \"If creation of the new group is successful\",\n    \"_group_id: \"Id of the new group\"\n  }\n  */\n  function internal_create_group(uint256 _role_id, bytes32 _name, bytes32 _document)\n           internal\n           returns (bool _success, uint256 _group_id)\n  {\n    require(_role_id > 0);\n    require(read_role(_role_id) != bytes32(0x0));\n    _group_id = ++system.total_groups;\n    system.groups.append(_group_id);\n    system.groups_by_id[_group_id].role_id = _role_id;\n    system.groups_by_id[_group_id].name = _name;\n    system.groups_by_id[_group_id].document = _document;\n    _success = true;\n  }\n\n  /**\n  @notice Returns the group's information\n  @param _group_id Id of the group\n  @return {\n    \"_role_id\": \"Role id of the group\",\n    \"_name: \"Name of the group\",\n    \"_document: \"Document of the group\"\n  }\n  */\n  function read_group(uint256 _group_id)\n           public\n           constant\n           returns (uint256 _role_id, bytes32 _name, bytes32 _document, uint256 _members_count)\n  {\n    if (system.groups.valid_item(_group_id)) {\n      _role_id = system.groups_by_id[_group_id].role_id;\n      _name = system.groups_by_id[_group_id].name;\n      _document = system.groups_by_id[_group_id].document;\n      _members_count = read_total_indexed_addresses(system.groups_collection, bytes32(_group_id));\n    } else {\n      _role_id = 0;\n      _name = \"invalid\";\n      _document = \"\";\n      _members_count = 0;\n    }\n  }\n\n  /**\n  @notice Adds new user with the given information to a group\n  @param _group_id Id of the group\n  @param _user Address of the new user\n  @param _document Information of the new user\n  @return {\"_success\": \"If adding new user to a group is successful\"}\n  */\n  function internal_update_add_user_to_group(uint256 _group_id, address _user, bytes32 _document)\n           internal\n           returns (bool _success)\n  {\n    if (system.groups_by_id[_group_id].members_by_address[_user].active == false && system.group_ids_by_address[_user] == 0 && system.groups_by_id[_group_id].role_id != 0) {\n\n      system.groups_by_id[_group_id].members_by_address[_user].active = true;\n      system.group_ids_by_address[_user] = _group_id;\n      system.groups_collection.append(bytes32(_group_id), _user);\n      system.groups_by_id[_group_id].members_by_address[_user].document = _document;\n      _success = true;\n    } else {\n      _success = false;\n    }\n  }\n\n  /**\n  @notice Removes user from its group\n  @param _user Address of the user\n  @return {\"_success\": \"If removing of user is successful\"}\n  */\n  function internal_destroy_group_user(address _user)\n           internal\n           returns (bool _success)\n  {\n    uint256 _group_id = system.group_ids_by_address[_user];\n    if ((_group_id == 1) && (system.groups_collection.total(bytes32(_group_id)) == 1)) {\n      _success = false;\n    } else {\n      system.groups_by_id[_group_id].members_by_address[_user].active = false;\n      system.group_ids_by_address[_user] = 0;\n      delete system.groups_by_id[_group_id].members_by_address[_user];\n      _success = system.groups_collection.remove_item(bytes32(_group_id), _user);\n    }\n  }\n\n  /**\n  @notice Returns the role id of a user\n  @param _user Address of a user\n  @return {\"_role_id\": \"Role id of the user\"}\n  */\n  function read_user_role_id(address _user)\n           constant\n           public\n           returns (uint256 _role_id)\n  {\n    uint256 _group_id = system.group_ids_by_address[_user];\n    _role_id = system.groups_by_id[_group_id].role_id;\n  }\n\n  /**\n  @notice Returns the user's information\n  @param _user Address of the user\n  @return {\n    \"_group_id\": \"Group id of the user\",\n    \"_role_id\": \"Role id of the user\",\n    \"_document\": \"Information of the user\"\n  }\n  */\n  function read_user(address _user)\n           public\n           constant\n           returns (uint256 _group_id, uint256 _role_id, bytes32 _document)\n  {\n    _group_id = system.group_ids_by_address[_user];\n    _role_id = system.groups_by_id[_group_id].role_id;\n    _document = system.groups_by_id[_group_id].members_by_address[_user].document;\n  }\n\n  /**\n  @notice Returns the id of the first group\n  @return {\"_group_id\": \"Id of the first group\"}\n  */\n  function read_first_group()\n           view\n           external\n           returns (uint256 _group_id)\n  {\n    _group_id = read_first_from_uints(system.groups);\n  }\n\n  /**\n  @notice Returns the id of the last group\n  @return {\"_group_id\": \"Id of the last group\"}\n  */\n  function read_last_group()\n           view\n           external\n           returns (uint256 _group_id)\n  {\n    _group_id = read_last_from_uints(system.groups);\n  }\n\n  /**\n  @notice Returns the id of the previous group depending on the given current group\n  @param _current_group_id Id of the current group\n  @return {\"_group_id\": \"Id of the previous group\"}\n  */\n  function read_previous_group_from_group(uint256 _current_group_id)\n           view\n           external\n           returns (uint256 _group_id)\n  {\n    _group_id = read_previous_from_uints(system.groups, _current_group_id);\n  }\n\n  /**\n  @notice Returns the id of the next group depending on the given current group\n  @param _current_group_id Id of the current group\n  @return {\"_group_id\": \"Id of the next group\"}\n  */\n  function read_next_group_from_group(uint256 _current_group_id)\n           view\n           external\n           returns (uint256 _group_id)\n  {\n    _group_id = read_next_from_uints(system.groups, _current_group_id);\n  }\n\n  /**\n  @notice Returns the total number of groups\n  @return {\"_total_groups\": \"Total number of groups\"}\n  */\n  function read_total_groups()\n           view\n           external\n           returns (uint256 _total_groups)\n  {\n    _total_groups = read_total_uints(system.groups);\n  }\n\n  /**\n  @notice Returns the first user of a group\n  @param _group_id Id of the group\n  @return {\"_user\": \"Address of the user\"}\n  */\n  function read_first_user_in_group(bytes32 _group_id)\n           view\n           external\n           returns (address _user)\n  {\n    _user = read_first_from_indexed_addresses(system.groups_collection, bytes32(_group_id));\n  }\n\n  /**\n  @notice Returns the last user of a group\n  @param _group_id Id of the group\n  @return {\"_user\": \"Address of the user\"}\n  */\n  function read_last_user_in_group(bytes32 _group_id)\n           view\n           external\n           returns (address _user)\n  {\n    _user = read_last_from_indexed_addresses(system.groups_collection, bytes32(_group_id));\n  }\n\n  /**\n  @notice Returns the next user of a group depending on the given current user\n  @param _group_id Id of the group\n  @param _current_user Address of the current user\n  @return {\"_user\": \"Address of the next user\"}\n  */\n  function read_next_user_in_group(bytes32 _group_id, address _current_user)\n           view\n           external\n           returns (address _user)\n  {\n    _user = read_next_from_indexed_addresses(system.groups_collection, bytes32(_group_id), _current_user);\n  }\n\n  /**\n  @notice Returns the previous user of a group depending on the given current user\n  @param _group_id Id of the group\n  @param _current_user Address of the current user\n  @return {\"_user\": \"Address of the last user\"}\n  */\n  function read_previous_user_in_group(bytes32 _group_id, address _current_user)\n           view\n           external\n           returns (address _user)\n  {\n    _user = read_previous_from_indexed_addresses(system.groups_collection, bytes32(_group_id), _current_user);\n  }\n\n  /**\n  @notice Returns the total number of users of a group\n  @param _group_id Id of the group\n  @return {\"_total_users\": \"Total number of users\"}\n  */\n  function read_total_users_in_group(bytes32 _group_id)\n           view\n           external\n           returns (uint256 _total_users)\n  {\n    _total_users = read_total_indexed_addresses(system.groups_collection, bytes32(_group_id));\n  }\n}\n\n// File: contracts/storage/DaoIdentityStorage.sol\npragma solidity ^0.4.25;\n\ncontract DaoIdentityStorage is ResolverClient, DaoConstants, DirectoryStorage {\n\n    // struct for KYC details\n    // doc is the IPFS doc hash for any information regarding this KYC\n    // id_expiration is the UTC timestamp at which this KYC will expire\n    // at any time after this, the user's KYC is invalid, and that user\n    // MUST re-KYC before doing any proposer related operation in DigixDAO\n    struct KycDetails {\n        bytes32 doc;\n        uint256 id_expiration;\n    }\n\n    // a mapping of address to the KYC details\n    mapping (address => KycDetails) kycInfo;\n\n    constructor(address _resolver)\n        public\n    {\n        require(init(CONTRACT_STORAGE_DAO_IDENTITY, _resolver));\n        require(initialize_directory());\n    }\n\n    function create_group(uint256 _role_id, bytes32 _name, bytes32 _document)\n        public\n        returns (bool _success, uint256 _group_id)\n    {\n        require(sender_is(CONTRACT_DAO_IDENTITY));\n        (_success, _group_id) = internal_create_group(_role_id, _name, _document);\n        require(_success);\n    }\n\n    function create_role(uint256 _role_id, bytes32 _name)\n        public\n        returns (bool _success)\n    {\n        require(sender_is(CONTRACT_DAO_IDENTITY));\n        _success = internal_create_role(_role_id, _name);\n        require(_success);\n    }\n\n    function update_add_user_to_group(uint256 _group_id, address _user, bytes32 _document)\n        public\n        returns (bool _success)\n    {\n        require(sender_is(CONTRACT_DAO_IDENTITY));\n        _success = internal_update_add_user_to_group(_group_id, _user, _document);\n        require(_success);\n    }\n\n    function update_remove_group_user(address _user)\n        public\n        returns (bool _success)\n    {\n        require(sender_is(CONTRACT_DAO_IDENTITY));\n        _success = internal_destroy_group_user(_user);\n        require(_success);\n    }\n\n    function update_kyc(address _user, bytes32 _doc, uint256 _id_expiration)\n        public\n    {\n        require(sender_is(CONTRACT_DAO_IDENTITY));\n        kycInfo[_user].doc = _doc;\n        kycInfo[_user].id_expiration = _id_expiration;\n    }\n\n    function read_kyc_info(address _user)\n        public\n        view\n        returns (bytes32 _doc, uint256 _id_expiration)\n    {\n        _doc = kycInfo[_user].doc;\n        _id_expiration = kycInfo[_user].id_expiration;\n    }\n\n    function is_kyc_approved(address _user)\n        public\n        view\n        returns (bool _approved)\n    {\n        uint256 _id_expiration;\n        (,_id_expiration) = read_kyc_info(_user);\n        _approved = _id_expiration > now;\n    }\n}\n\n// File: contracts/common/IdentityCommon.sol\npragma solidity ^0.4.25;\n\ncontract IdentityCommon is DaoWhitelistingCommon {\n\n    modifier if_root() {\n        require(identity_storage().read_user_role_id(msg.sender) == ROLES_ROOT);\n        _;\n    }\n\n    modifier if_founder() {\n        require(is_founder());\n        _;\n    }\n\n    function is_founder()\n        internal\n        view\n        returns (bool _isFounder)\n    {\n        _isFounder = identity_storage().read_user_role_id(msg.sender) == ROLES_FOUNDERS;\n    }\n\n    modifier if_prl() {\n        require(identity_storage().read_user_role_id(msg.sender) == ROLES_PRLS);\n        _;\n    }\n\n    modifier if_kyc_admin() {\n        require(identity_storage().read_user_role_id(msg.sender) == ROLES_KYC_ADMINS);\n        _;\n    }\n\n    function identity_storage()\n        internal\n        view\n        returns (DaoIdentityStorage _contract)\n    {\n        _contract = DaoIdentityStorage(get_contract(CONTRACT_STORAGE_DAO_IDENTITY));\n    }\n}\n\n// File: contracts/storage/DaoConfigsStorage.sol\npragma solidity ^0.4.25;\n\ncontract DaoConfigsStorage is ResolverClient, DaoConstants {\n\n    // mapping of config name to config value\n    // config names can be found in DaoConstants contract\n    mapping (bytes32 => uint256) public uintConfigs;\n\n    // mapping of config name to config value\n    // config names can be found in DaoConstants contract\n    mapping (bytes32 => address) public addressConfigs;\n\n    // mapping of config name to config value\n    // config names can be found in DaoConstants contract\n    mapping (bytes32 => bytes32) public bytesConfigs;\n\n    uint256 ONE_BILLION = 1000000000;\n    uint256 ONE_MILLION = 1000000;\n\n    constructor(address _resolver)\n        public\n    {\n        require(init(CONTRACT_STORAGE_DAO_CONFIG, _resolver));\n\n        uintConfigs[CONFIG_LOCKING_PHASE_DURATION] = 10 days;\n        uintConfigs[CONFIG_QUARTER_DURATION] = QUARTER_DURATION;\n        uintConfigs[CONFIG_VOTING_COMMIT_PHASE] = 14 days;\n        uintConfigs[CONFIG_VOTING_PHASE_TOTAL] = 21 days;\n        uintConfigs[CONFIG_INTERIM_COMMIT_PHASE] = 7 days;\n        uintConfigs[CONFIG_INTERIM_PHASE_TOTAL] = 14 days;\n\n\n\n        uintConfigs[CONFIG_DRAFT_QUORUM_FIXED_PORTION_NUMERATOR] = 5; // 5%\n        uintConfigs[CONFIG_DRAFT_QUORUM_FIXED_PORTION_DENOMINATOR] = 100; // 5%\n        uintConfigs[CONFIG_DRAFT_QUORUM_SCALING_FACTOR_NUMERATOR] = 35; // 35%\n        uintConfigs[CONFIG_DRAFT_QUORUM_SCALING_FACTOR_DENOMINATOR] = 100; // 35%\n\n\n        uintConfigs[CONFIG_VOTING_QUORUM_FIXED_PORTION_NUMERATOR] = 5; // 5%\n        uintConfigs[CONFIG_VOTING_QUORUM_FIXED_PORTION_DENOMINATOR] = 100; // 5%\n        uintConfigs[CONFIG_VOTING_QUORUM_SCALING_FACTOR_NUMERATOR] = 25; // 25%\n        uintConfigs[CONFIG_VOTING_QUORUM_SCALING_FACTOR_DENOMINATOR] = 100; // 25%\n\n        uintConfigs[CONFIG_DRAFT_QUOTA_NUMERATOR] = 1; // >50%\n        uintConfigs[CONFIG_DRAFT_QUOTA_DENOMINATOR] = 2; // >50%\n        uintConfigs[CONFIG_VOTING_QUOTA_NUMERATOR] = 1; // >50%\n        uintConfigs[CONFIG_VOTING_QUOTA_DENOMINATOR] = 2; // >50%\n\n\n        uintConfigs[CONFIG_QUARTER_POINT_DRAFT_VOTE] = ONE_BILLION;\n        uintConfigs[CONFIG_QUARTER_POINT_VOTE] = ONE_BILLION;\n        uintConfigs[CONFIG_QUARTER_POINT_INTERIM_VOTE] = ONE_BILLION;\n\n        uintConfigs[CONFIG_QUARTER_POINT_MILESTONE_COMPLETION_PER_10000ETH] = 20000 * ONE_BILLION;\n\n        uintConfigs[CONFIG_BONUS_REPUTATION_NUMERATOR] = 15; // 15% bonus for consistent votes\n        uintConfigs[CONFIG_BONUS_REPUTATION_DENOMINATOR] = 100; // 15% bonus for consistent votes\n\n        uintConfigs[CONFIG_SPECIAL_PROPOSAL_COMMIT_PHASE] = 28 days;\n        uintConfigs[CONFIG_SPECIAL_PROPOSAL_PHASE_TOTAL] = 35 days;\n\n\n\n        uintConfigs[CONFIG_SPECIAL_QUOTA_NUMERATOR] = 1; // >50%\n        uintConfigs[CONFIG_SPECIAL_QUOTA_DENOMINATOR] = 2; // >50%\n\n        uintConfigs[CONFIG_SPECIAL_PROPOSAL_QUORUM_NUMERATOR] = 40; // 40%\n        uintConfigs[CONFIG_SPECIAL_PROPOSAL_QUORUM_DENOMINATOR] = 100; // 40%\n\n        uintConfigs[CONFIG_MAXIMUM_REPUTATION_DEDUCTION] = 8334 * ONE_MILLION;\n\n        uintConfigs[CONFIG_PUNISHMENT_FOR_NOT_LOCKING] = 1666 * ONE_MILLION;\n        uintConfigs[CONFIG_REPUTATION_PER_EXTRA_QP_NUM] = 1; // 1 extra QP gains 1/1 RP\n        uintConfigs[CONFIG_REPUTATION_PER_EXTRA_QP_DEN] = 1;\n\n\n        uintConfigs[CONFIG_MINIMAL_QUARTER_POINT] = 2 * ONE_BILLION;\n        uintConfigs[CONFIG_QUARTER_POINT_SCALING_FACTOR] = 400 * ONE_BILLION;\n        uintConfigs[CONFIG_REPUTATION_POINT_SCALING_FACTOR] = 2000 * ONE_BILLION;\n\n        uintConfigs[CONFIG_MODERATOR_MINIMAL_QUARTER_POINT] = 4 * ONE_BILLION;\n        uintConfigs[CONFIG_MODERATOR_QUARTER_POINT_SCALING_FACTOR] = 400 * ONE_BILLION;\n        uintConfigs[CONFIG_MODERATOR_REPUTATION_POINT_SCALING_FACTOR] = 2000 * ONE_BILLION;\n\n        uintConfigs[CONFIG_PORTION_TO_MODERATORS_NUM] = 42; //4.2% of DGX to moderator voting activity\n        uintConfigs[CONFIG_PORTION_TO_MODERATORS_DEN] = 1000;\n\n        uintConfigs[CONFIG_DRAFT_VOTING_PHASE] = 10 days;\n\n        uintConfigs[CONFIG_REPUTATION_POINT_BOOST_FOR_BADGE] = 412500 * ONE_MILLION;\n\n        uintConfigs[CONFIG_FINAL_REWARD_SCALING_FACTOR_NUMERATOR] = 7; // 7%\n        uintConfigs[CONFIG_FINAL_REWARD_SCALING_FACTOR_DENOMINATOR] = 100; // 7%\n\n        uintConfigs[CONFIG_MAXIMUM_MODERATOR_REPUTATION_DEDUCTION] = 12500 * ONE_MILLION;\n        uintConfigs[CONFIG_REPUTATION_PER_EXTRA_MODERATOR_QP_NUM] = 1;\n        uintConfigs[CONFIG_REPUTATION_PER_EXTRA_MODERATOR_QP_DEN] = 1;\n\n        uintConfigs[CONFIG_VOTE_CLAIMING_DEADLINE] = 10 days;\n\n        uintConfigs[CONFIG_MINIMUM_LOCKED_DGD] = 10 * ONE_BILLION;\n        uintConfigs[CONFIG_MINIMUM_DGD_FOR_MODERATOR] = 842 * ONE_BILLION;\n        uintConfigs[CONFIG_MINIMUM_REPUTATION_FOR_MODERATOR] = 400 * ONE_BILLION;\n\n        uintConfigs[CONFIG_PREPROPOSAL_COLLATERAL] = 2 ether;\n\n        uintConfigs[CONFIG_MAX_FUNDING_FOR_NON_DIGIX] = 100 ether;\n        uintConfigs[CONFIG_MAX_MILESTONES_FOR_NON_DIGIX] = 5;\n        uintConfigs[CONFIG_NON_DIGIX_PROPOSAL_CAP_PER_QUARTER] = 80;\n\n        uintConfigs[CONFIG_PROPOSAL_DEAD_DURATION] = 90 days;\n        uintConfigs[CONFIG_CARBON_VOTE_REPUTATION_BONUS] = 10 * ONE_BILLION;\n    }\n\n    function updateUintConfigs(uint256[] _uintConfigs)\n        external\n    {\n        require(sender_is(CONTRACT_DAO_SPECIAL_VOTING_CLAIMS));\n        uintConfigs[CONFIG_LOCKING_PHASE_DURATION] = _uintConfigs[0];\n        /*\n        This used to be a config that can be changed. Now, _uintConfigs[1] is just a dummy config that doesnt do anything\n        uintConfigs[CONFIG_QUARTER_DURATION] = _uintConfigs[1];\n        */\n        uintConfigs[CONFIG_VOTING_COMMIT_PHASE] = _uintConfigs[2];\n        uintConfigs[CONFIG_VOTING_PHASE_TOTAL] = _uintConfigs[3];\n        uintConfigs[CONFIG_INTERIM_COMMIT_PHASE] = _uintConfigs[4];\n        uintConfigs[CONFIG_INTERIM_PHASE_TOTAL] = _uintConfigs[5];\n        uintConfigs[CONFIG_DRAFT_QUORUM_FIXED_PORTION_NUMERATOR] = _uintConfigs[6];\n        uintConfigs[CONFIG_DRAFT_QUORUM_FIXED_PORTION_DENOMINATOR] = _uintConfigs[7];\n        uintConfigs[CONFIG_DRAFT_QUORUM_SCALING_FACTOR_NUMERATOR] = _uintConfigs[8];\n        uintConfigs[CONFIG_DRAFT_QUORUM_SCALING_FACTOR_DENOMINATOR] = _uintConfigs[9];\n        uintConfigs[CONFIG_VOTING_QUORUM_FIXED_PORTION_NUMERATOR] = _uintConfigs[10];\n        uintConfigs[CONFIG_VOTING_QUORUM_FIXED_PORTION_DENOMINATOR] = _uintConfigs[11];\n        uintConfigs[CONFIG_VOTING_QUORUM_SCALING_FACTOR_NUMERATOR] = _uintConfigs[12];\n        uintConfigs[CONFIG_VOTING_QUORUM_SCALING_FACTOR_DENOMINATOR] = _uintConfigs[13];\n        uintConfigs[CONFIG_DRAFT_QUOTA_NUMERATOR] = _uintConfigs[14];\n        uintConfigs[CONFIG_DRAFT_QUOTA_DENOMINATOR] = _uintConfigs[15];\n        uintConfigs[CONFIG_VOTING_QUOTA_NUMERATOR] = _uintConfigs[16];\n        uintConfigs[CONFIG_VOTING_QUOTA_DENOMINATOR] = _uintConfigs[17];\n        uintConfigs[CONFIG_QUARTER_POINT_DRAFT_VOTE] = _uintConfigs[18];\n        uintConfigs[CONFIG_QUARTER_POINT_VOTE] = _uintConfigs[19];\n        uintConfigs[CONFIG_QUARTER_POINT_INTERIM_VOTE] = _uintConfigs[20];\n        uintConfigs[CONFIG_MINIMAL_QUARTER_POINT] = _uintConfigs[21];\n        uintConfigs[CONFIG_QUARTER_POINT_MILESTONE_COMPLETION_PER_10000ETH] = _uintConfigs[22];\n        uintConfigs[CONFIG_BONUS_REPUTATION_NUMERATOR] = _uintConfigs[23];\n        uintConfigs[CONFIG_BONUS_REPUTATION_DENOMINATOR] = _uintConfigs[24];\n        uintConfigs[CONFIG_SPECIAL_PROPOSAL_COMMIT_PHASE] = _uintConfigs[25];\n        uintConfigs[CONFIG_SPECIAL_PROPOSAL_PHASE_TOTAL] = _uintConfigs[26];\n        uintConfigs[CONFIG_SPECIAL_QUOTA_NUMERATOR] = _uintConfigs[27];\n        uintConfigs[CONFIG_SPECIAL_QUOTA_DENOMINATOR] = _uintConfigs[28];\n        uintConfigs[CONFIG_SPECIAL_PROPOSAL_QUORUM_NUMERATOR] = _uintConfigs[29];\n        uintConfigs[CONFIG_SPECIAL_PROPOSAL_QUORUM_DENOMINATOR] = _uintConfigs[30];\n        uintConfigs[CONFIG_MAXIMUM_REPUTATION_DEDUCTION] = _uintConfigs[31];\n        uintConfigs[CONFIG_PUNISHMENT_FOR_NOT_LOCKING] = _uintConfigs[32];\n        uintConfigs[CONFIG_REPUTATION_PER_EXTRA_QP_NUM] = _uintConfigs[33];\n        uintConfigs[CONFIG_REPUTATION_PER_EXTRA_QP_DEN] = _uintConfigs[34];\n        uintConfigs[CONFIG_QUARTER_POINT_SCALING_FACTOR] = _uintConfigs[35];\n        uintConfigs[CONFIG_REPUTATION_POINT_SCALING_FACTOR] = _uintConfigs[36];\n        uintConfigs[CONFIG_MODERATOR_MINIMAL_QUARTER_POINT] = _uintConfigs[37];\n        uintConfigs[CONFIG_MODERATOR_QUARTER_POINT_SCALING_FACTOR] = _uintConfigs[38];\n        uintConfigs[CONFIG_MODERATOR_REPUTATION_POINT_SCALING_FACTOR] = _uintConfigs[39];\n        uintConfigs[CONFIG_PORTION_TO_MODERATORS_NUM] = _uintConfigs[40];\n        uintConfigs[CONFIG_PORTION_TO_MODERATORS_DEN] = _uintConfigs[41];\n        uintConfigs[CONFIG_DRAFT_VOTING_PHASE] = _uintConfigs[42];\n        uintConfigs[CONFIG_REPUTATION_POINT_BOOST_FOR_BADGE] = _uintConfigs[43];\n        uintConfigs[CONFIG_FINAL_REWARD_SCALING_FACTOR_NUMERATOR] = _uintConfigs[44];\n        uintConfigs[CONFIG_FINAL_REWARD_SCALING_FACTOR_DENOMINATOR] = _uintConfigs[45];\n        uintConfigs[CONFIG_MAXIMUM_MODERATOR_REPUTATION_DEDUCTION] = _uintConfigs[46];\n        uintConfigs[CONFIG_REPUTATION_PER_EXTRA_MODERATOR_QP_NUM] = _uintConfigs[47];\n        uintConfigs[CONFIG_REPUTATION_PER_EXTRA_MODERATOR_QP_DEN] = _uintConfigs[48];\n        uintConfigs[CONFIG_VOTE_CLAIMING_DEADLINE] = _uintConfigs[49];\n        uintConfigs[CONFIG_MINIMUM_LOCKED_DGD] = _uintConfigs[50];\n        uintConfigs[CONFIG_MINIMUM_DGD_FOR_MODERATOR] = _uintConfigs[51];\n        uintConfigs[CONFIG_MINIMUM_REPUTATION_FOR_MODERATOR] = _uintConfigs[52];\n        uintConfigs[CONFIG_PREPROPOSAL_COLLATERAL] = _uintConfigs[53];\n        uintConfigs[CONFIG_MAX_FUNDING_FOR_NON_DIGIX] = _uintConfigs[54];\n        uintConfigs[CONFIG_MAX_MILESTONES_FOR_NON_DIGIX] = _uintConfigs[55];\n        uintConfigs[CONFIG_NON_DIGIX_PROPOSAL_CAP_PER_QUARTER] = _uintConfigs[56];\n        uintConfigs[CONFIG_PROPOSAL_DEAD_DURATION] = _uintConfigs[57];\n        uintConfigs[CONFIG_CARBON_VOTE_REPUTATION_BONUS] = _uintConfigs[58];\n    }\n\n    function readUintConfigs()\n        public\n        view\n        returns (uint256[])\n    {\n        uint256[] memory _uintConfigs = new uint256[](59);\n        _uintConfigs[0] = uintConfigs[CONFIG_LOCKING_PHASE_DURATION];\n        _uintConfigs[1] = uintConfigs[CONFIG_QUARTER_DURATION];\n        _uintConfigs[2] = uintConfigs[CONFIG_VOTING_COMMIT_PHASE];\n        _uintConfigs[3] = uintConfigs[CONFIG_VOTING_PHASE_TOTAL];\n        _uintConfigs[4] = uintConfigs[CONFIG_INTERIM_COMMIT_PHASE];\n        _uintConfigs[5] = uintConfigs[CONFIG_INTERIM_PHASE_TOTAL];\n        _uintConfigs[6] = uintConfigs[CONFIG_DRAFT_QUORUM_FIXED_PORTION_NUMERATOR];\n        _uintConfigs[7] = uintConfigs[CONFIG_DRAFT_QUORUM_FIXED_PORTION_DENOMINATOR];\n        _uintConfigs[8] = uintConfigs[CONFIG_DRAFT_QUORUM_SCALING_FACTOR_NUMERATOR];\n        _uintConfigs[9] = uintConfigs[CONFIG_DRAFT_QUORUM_SCALING_FACTOR_DENOMINATOR];\n        _uintConfigs[10] = uintConfigs[CONFIG_VOTING_QUORUM_FIXED_PORTION_NUMERATOR];\n        _uintConfigs[11] = uintConfigs[CONFIG_VOTING_QUORUM_FIXED_PORTION_DENOMINATOR];\n        _uintConfigs[12] = uintConfigs[CONFIG_VOTING_QUORUM_SCALING_FACTOR_NUMERATOR];\n        _uintConfigs[13] = uintConfigs[CONFIG_VOTING_QUORUM_SCALING_FACTOR_DENOMINATOR];\n        _uintConfigs[14] = uintConfigs[CONFIG_DRAFT_QUOTA_NUMERATOR];\n        _uintConfigs[15] = uintConfigs[CONFIG_DRAFT_QUOTA_DENOMINATOR];\n        _uintConfigs[16] = uintConfigs[CONFIG_VOTING_QUOTA_NUMERATOR];\n        _uintConfigs[17] = uintConfigs[CONFIG_VOTING_QUOTA_DENOMINATOR];\n        _uintConfigs[18] = uintConfigs[CONFIG_QUARTER_POINT_DRAFT_VOTE];\n        _uintConfigs[19] = uintConfigs[CONFIG_QUARTER_POINT_VOTE];\n        _uintConfigs[20] = uintConfigs[CONFIG_QUARTER_POINT_INTERIM_VOTE];\n        _uintConfigs[21] = uintConfigs[CONFIG_MINIMAL_QUARTER_POINT];\n        _uintConfigs[22] = uintConfigs[CONFIG_QUARTER_POINT_MILESTONE_COMPLETION_PER_10000ETH];\n        _uintConfigs[23] = uintConfigs[CONFIG_BONUS_REPUTATION_NUMERATOR];\n        _uintConfigs[24] = uintConfigs[CONFIG_BONUS_REPUTATION_DENOMINATOR];\n        _uintConfigs[25] = uintConfigs[CONFIG_SPECIAL_PROPOSAL_COMMIT_PHASE];\n        _uintConfigs[26] = uintConfigs[CONFIG_SPECIAL_PROPOSAL_PHASE_TOTAL];\n        _uintConfigs[27] = uintConfigs[CONFIG_SPECIAL_QUOTA_NUMERATOR];\n        _uintConfigs[28] = uintConfigs[CONFIG_SPECIAL_QUOTA_DENOMINATOR];\n        _uintConfigs[29] = uintConfigs[CONFIG_SPECIAL_PROPOSAL_QUORUM_NUMERATOR];\n        _uintConfigs[30] = uintConfigs[CONFIG_SPECIAL_PROPOSAL_QUORUM_DENOMINATOR];\n        _uintConfigs[31] = uintConfigs[CONFIG_MAXIMUM_REPUTATION_DEDUCTION];\n        _uintConfigs[32] = uintConfigs[CONFIG_PUNISHMENT_FOR_NOT_LOCKING];\n        _uintConfigs[33] = uintConfigs[CONFIG_REPUTATION_PER_EXTRA_QP_NUM];\n        _uintConfigs[34] = uintConfigs[CONFIG_REPUTATION_PER_EXTRA_QP_DEN];\n        _uintConfigs[35] = uintConfigs[CONFIG_QUARTER_POINT_SCALING_FACTOR];\n        _uintConfigs[36] = uintConfigs[CONFIG_REPUTATION_POINT_SCALING_FACTOR];\n        _uintConfigs[37] = uintConfigs[CONFIG_MODERATOR_MINIMAL_QUARTER_POINT];\n        _uintConfigs[38] = uintConfigs[CONFIG_MODERATOR_QUARTER_POINT_SCALING_FACTOR];\n        _uintConfigs[39] = uintConfigs[CONFIG_MODERATOR_REPUTATION_POINT_SCALING_FACTOR];\n        _uintConfigs[40] = uintConfigs[CONFIG_PORTION_TO_MODERATORS_NUM];\n        _uintConfigs[41] = uintConfigs[CONFIG_PORTION_TO_MODERATORS_DEN];\n        _uintConfigs[42] = uintConfigs[CONFIG_DRAFT_VOTING_PHASE];\n        _uintConfigs[43] = uintConfigs[CONFIG_REPUTATION_POINT_BOOST_FOR_BADGE];\n        _uintConfigs[44] = uintConfigs[CONFIG_FINAL_REWARD_SCALING_FACTOR_NUMERATOR];\n        _uintConfigs[45] = uintConfigs[CONFIG_FINAL_REWARD_SCALING_FACTOR_DENOMINATOR];\n        _uintConfigs[46] = uintConfigs[CONFIG_MAXIMUM_MODERATOR_REPUTATION_DEDUCTION];\n        _uintConfigs[47] = uintConfigs[CONFIG_REPUTATION_PER_EXTRA_MODERATOR_QP_NUM];\n        _uintConfigs[48] = uintConfigs[CONFIG_REPUTATION_PER_EXTRA_MODERATOR_QP_DEN];\n        _uintConfigs[49] = uintConfigs[CONFIG_VOTE_CLAIMING_DEADLINE];\n        _uintConfigs[50] = uintConfigs[CONFIG_MINIMUM_LOCKED_DGD];\n        _uintConfigs[51] = uintConfigs[CONFIG_MINIMUM_DGD_FOR_MODERATOR];\n        _uintConfigs[52] = uintConfigs[CONFIG_MINIMUM_REPUTATION_FOR_MODERATOR];\n        _uintConfigs[53] = uintConfigs[CONFIG_PREPROPOSAL_COLLATERAL];\n        _uintConfigs[54] = uintConfigs[CONFIG_MAX_FUNDING_FOR_NON_DIGIX];\n        _uintConfigs[55] = uintConfigs[CONFIG_MAX_MILESTONES_FOR_NON_DIGIX];\n        _uintConfigs[56] = uintConfigs[CONFIG_NON_DIGIX_PROPOSAL_CAP_PER_QUARTER];\n        _uintConfigs[57] = uintConfigs[CONFIG_PROPOSAL_DEAD_DURATION];\n        _uintConfigs[58] = uintConfigs[CONFIG_CARBON_VOTE_REPUTATION_BONUS];\n        return _uintConfigs;\n    }\n}\n\n// File: contracts/storage/DaoProposalCounterStorage.sol\npragma solidity ^0.4.25;\n\ncontract DaoProposalCounterStorage is ResolverClient, DaoConstants {\n\n    constructor(address _resolver) public {\n        require(init(CONTRACT_STORAGE_DAO_COUNTER, _resolver));\n    }\n\n    // This is to mark the number of proposals that have been funded in a specific quarter\n    // this is to take care of the cap on the number of funded proposals in a quarter\n    mapping (uint256 => uint256) public proposalCountByQuarter;\n\n    function addNonDigixProposalCountInQuarter(uint256 _quarterNumber)\n        public\n    {\n        require(sender_is(CONTRACT_DAO_VOTING_CLAIMS));\n        proposalCountByQuarter[_quarterNumber] = proposalCountByQuarter[_quarterNumber].add(1);\n    }\n}\n\n// File: contracts/storage/DaoUpgradeStorage.sol\npragma solidity ^0.4.25;\n\ncontract DaoUpgradeStorage is ResolverClient, DaoConstants {\n\n    // this UTC timestamp marks the start of the first quarter\n    // of DigixDAO. All time related calculations in DaoCommon\n    // depend on this value\n    uint256 public startOfFirstQuarter;\n\n    // this boolean marks whether the DAO contracts have been replaced\n    // by newer versions or not. The process of migration is done by deploying\n    // a new set of contracts, transferring funds from these contracts to the new ones\n    // migrating some state variables, and finally setting this boolean to true\n    // All operations in these contracts that may transfer tokens, claim ether,\n    // boost one's reputation, etc. SHOULD fail if this is true\n    bool public isReplacedByNewDao;\n\n    // this is the address of the new Dao contract\n    address public newDaoContract;\n\n    // this is the address of the new DaoFundingManager contract\n    // ether funds will be moved from the current version's contract to this\n    // new contract\n    address public newDaoFundingManager;\n\n    // this is the address of the new DaoRewardsManager contract\n    // DGX funds will be moved from the current version of contract to this\n    // new contract\n    address public newDaoRewardsManager;\n\n    constructor(address _resolver) public {\n        require(init(CONTRACT_STORAGE_DAO_UPGRADE, _resolver));\n    }\n\n    function setStartOfFirstQuarter(uint256 _start)\n        public\n    {\n        require(sender_is(CONTRACT_DAO));\n        startOfFirstQuarter = _start;\n    }\n\n\n    function setNewContractAddresses(\n        address _newDaoContract,\n        address _newDaoFundingManager,\n        address _newDaoRewardsManager\n    )\n        public\n    {\n        require(sender_is(CONTRACT_DAO));\n        newDaoContract = _newDaoContract;\n        newDaoFundingManager = _newDaoFundingManager;\n        newDaoRewardsManager = _newDaoRewardsManager;\n    }\n\n\n    function updateForDaoMigration()\n        public\n    {\n        require(sender_is(CONTRACT_DAO));\n        isReplacedByNewDao = true;\n    }\n}\n\n// File: contracts/storage/DaoSpecialStorage.sol\npragma solidity ^0.4.25;\n\ncontract DaoSpecialStorage is DaoWhitelistingCommon {\n    using DoublyLinkedList for DoublyLinkedList.Bytes;\n    using DaoStructs for DaoStructs.SpecialProposal;\n    using DaoStructs for DaoStructs.Voting;\n\n    // List of all the special proposals ever created in DigixDAO\n    DoublyLinkedList.Bytes proposals;\n\n    // mapping of the SpecialProposal struct by its ID\n    // ID is also the IPFS doc hash of the proposal\n    mapping (bytes32 => DaoStructs.SpecialProposal) proposalsById;\n\n    constructor(address _resolver) public {\n        require(init(CONTRACT_STORAGE_DAO_SPECIAL, _resolver));\n    }\n\n    function addSpecialProposal(\n        bytes32 _proposalId,\n        address _proposer,\n        uint256[] _uintConfigs,\n        address[] _addressConfigs,\n        bytes32[] _bytesConfigs\n    )\n        public\n    {\n        require(sender_is(CONTRACT_DAO_SPECIAL_PROPOSAL));\n        require(\n          (proposalsById[_proposalId].proposalId == EMPTY_BYTES) &&\n          (_proposalId != EMPTY_BYTES)\n        );\n        proposals.append(_proposalId);\n        proposalsById[_proposalId].proposalId = _proposalId;\n        proposalsById[_proposalId].proposer = _proposer;\n        proposalsById[_proposalId].timeCreated = now;\n        proposalsById[_proposalId].uintConfigs = _uintConfigs;\n        proposalsById[_proposalId].addressConfigs = _addressConfigs;\n        proposalsById[_proposalId].bytesConfigs = _bytesConfigs;\n    }\n\n    function readProposal(bytes32 _proposalId)\n        public\n        view\n        returns (\n            bytes32 _id,\n            address _proposer,\n            uint256 _timeCreated,\n            uint256 _timeVotingStarted\n        )\n    {\n        _id = proposalsById[_proposalId].proposalId;\n        _proposer = proposalsById[_proposalId].proposer;\n        _timeCreated = proposalsById[_proposalId].timeCreated;\n        _timeVotingStarted = proposalsById[_proposalId].voting.startTime;\n    }\n\n    function readProposalProposer(bytes32 _proposalId)\n        public\n        view\n        returns (address _proposer)\n    {\n        _proposer = proposalsById[_proposalId].proposer;\n    }\n\n    function readConfigs(bytes32 _proposalId)\n        public\n        view\n        returns (\n            uint256[] memory _uintConfigs,\n            address[] memory _addressConfigs,\n            bytes32[] memory _bytesConfigs\n        )\n    {\n        _uintConfigs = proposalsById[_proposalId].uintConfigs;\n        _addressConfigs = proposalsById[_proposalId].addressConfigs;\n        _bytesConfigs = proposalsById[_proposalId].bytesConfigs;\n    }\n\n    function readVotingCount(bytes32 _proposalId, address[] _allUsers)\n        external\n        view\n        returns (uint256 _for, uint256 _against)\n    {\n        require(senderIsAllowedToRead());\n        return proposalsById[_proposalId].voting.countVotes(_allUsers);\n    }\n\n    function readVotingTime(bytes32 _proposalId)\n        public\n        view\n        returns (uint256 _start)\n    {\n        require(senderIsAllowedToRead());\n        _start = proposalsById[_proposalId].voting.startTime;\n    }\n\n    function commitVote(\n        bytes32 _proposalId,\n        bytes32 _hash,\n        address _voter\n    )\n        public\n    {\n        require(sender_is(CONTRACT_DAO_VOTING));\n        proposalsById[_proposalId].voting.commits[_voter] = _hash;\n    }\n\n    function readComittedVote(bytes32 _proposalId, address _voter)\n        public\n        view\n        returns (bytes32 _commitHash)\n    {\n        require(senderIsAllowedToRead());\n        _commitHash = proposalsById[_proposalId].voting.commits[_voter];\n    }\n\n    function setVotingTime(bytes32 _proposalId, uint256 _time)\n        public\n    {\n        require(sender_is(CONTRACT_DAO_SPECIAL_PROPOSAL));\n        proposalsById[_proposalId].voting.startTime = _time;\n    }\n\n    function readVotingResult(bytes32 _proposalId)\n        public\n        view\n        returns (bool _result)\n    {\n        require(senderIsAllowedToRead());\n        _result = proposalsById[_proposalId].voting.passed;\n    }\n\n    function setPass(bytes32 _proposalId, bool _result)\n        public\n    {\n        require(sender_is(CONTRACT_DAO_SPECIAL_VOTING_CLAIMS));\n        proposalsById[_proposalId].voting.passed = _result;\n    }\n\n    function setVotingClaim(bytes32 _proposalId, bool _claimed)\n        public\n    {\n        require(sender_is(CONTRACT_DAO_SPECIAL_VOTING_CLAIMS));\n        DaoStructs.SpecialProposal storage _proposal = proposalsById[_proposalId];\n        _proposal.voting.claimed = _claimed;\n    }\n\n    function isClaimed(bytes32 _proposalId)\n        public\n        view\n        returns (bool _claimed)\n    {\n        require(senderIsAllowedToRead());\n        _claimed = proposalsById[_proposalId].voting.claimed;\n    }\n\n    function readVote(bytes32 _proposalId, address _voter)\n        public\n        view\n        returns (bool _vote, uint256 _weight)\n    {\n        require(senderIsAllowedToRead());\n        return proposalsById[_proposalId].voting.readVote(_voter);\n    }\n\n    function revealVote(\n        bytes32 _proposalId,\n        address _voter,\n        bool _vote,\n        uint256 _weight\n    )\n        public\n    {\n        require(sender_is(CONTRACT_DAO_VOTING));\n        proposalsById[_proposalId].voting.revealVote(_voter, _vote, _weight);\n    }\n}\n\n// File: contracts/storage/DaoPointsStorage.sol\npragma solidity ^0.4.25;\n\ncontract DaoPointsStorage is ResolverClient, DaoConstants {\n\n    // struct for a non-transferrable token\n    struct Token {\n        uint256 totalSupply;\n        mapping (address => uint256) balance;\n    }\n\n    // the reputation point token\n    // since reputation is cumulative, we only need to store one value\n    Token reputationPoint;\n\n    // since quarter points are specific to quarters, we need a mapping from\n    // quarter number to the quarter point token for that quarter\n    mapping (uint256 => Token) quarterPoint;\n\n    // the same is the case with quarter moderator points\n    // these are specific to quarters\n    mapping (uint256 => Token) quarterModeratorPoint;\n\n    constructor(address _resolver)\n        public\n    {\n        require(init(CONTRACT_STORAGE_DAO_POINTS, _resolver));\n    }\n\n    /// @notice add quarter points for a _participant for a _quarterNumber\n    function addQuarterPoint(address _participant, uint256 _point, uint256 _quarterNumber)\n        public\n        returns (uint256 _newPoint, uint256 _newTotalPoint)\n    {\n        require(sender_is_from([CONTRACT_DAO_VOTING, CONTRACT_DAO_VOTING_CLAIMS, EMPTY_BYTES]));\n        quarterPoint[_quarterNumber].totalSupply = quarterPoint[_quarterNumber].totalSupply.add(_point);\n        quarterPoint[_quarterNumber].balance[_participant] = quarterPoint[_quarterNumber].balance[_participant].add(_point);\n\n        _newPoint = quarterPoint[_quarterNumber].balance[_participant];\n        _newTotalPoint = quarterPoint[_quarterNumber].totalSupply;\n    }\n\n    function addModeratorQuarterPoint(address _participant, uint256 _point, uint256 _quarterNumber)\n        public\n        returns (uint256 _newPoint, uint256 _newTotalPoint)\n    {\n        require(sender_is_from([CONTRACT_DAO_VOTING, CONTRACT_DAO_VOTING_CLAIMS, EMPTY_BYTES]));\n        quarterModeratorPoint[_quarterNumber].totalSupply = quarterModeratorPoint[_quarterNumber].totalSupply.add(_point);\n        quarterModeratorPoint[_quarterNumber].balance[_participant] = quarterModeratorPoint[_quarterNumber].balance[_participant].add(_point);\n\n        _newPoint = quarterModeratorPoint[_quarterNumber].balance[_participant];\n        _newTotalPoint = quarterModeratorPoint[_quarterNumber].totalSupply;\n    }\n\n    /// @notice get quarter points for a _participant in a _quarterNumber\n    function getQuarterPoint(address _participant, uint256 _quarterNumber)\n        public\n        view\n        returns (uint256 _point)\n    {\n        _point = quarterPoint[_quarterNumber].balance[_participant];\n    }\n\n    function getQuarterModeratorPoint(address _participant, uint256 _quarterNumber)\n        public\n        view\n        returns (uint256 _point)\n    {\n        _point = quarterModeratorPoint[_quarterNumber].balance[_participant];\n    }\n\n    /// @notice get total quarter points for a particular _quarterNumber\n    function getTotalQuarterPoint(uint256 _quarterNumber)\n        public\n        view\n        returns (uint256 _totalPoint)\n    {\n        _totalPoint = quarterPoint[_quarterNumber].totalSupply;\n    }\n\n    function getTotalQuarterModeratorPoint(uint256 _quarterNumber)\n        public\n        view\n        returns (uint256 _totalPoint)\n    {\n        _totalPoint = quarterModeratorPoint[_quarterNumber].totalSupply;\n    }\n\n    /// @notice add reputation points for a _participant\n    function increaseReputation(address _participant, uint256 _point)\n        public\n        returns (uint256 _newPoint, uint256 _totalPoint)\n    {\n        require(sender_is_from([CONTRACT_DAO_VOTING_CLAIMS, CONTRACT_DAO_REWARDS_MANAGER, CONTRACT_DAO_STAKE_LOCKING]));\n        reputationPoint.totalSupply = reputationPoint.totalSupply.add(_point);\n        reputationPoint.balance[_participant] = reputationPoint.balance[_participant].add(_point);\n\n        _newPoint = reputationPoint.balance[_participant];\n        _totalPoint = reputationPoint.totalSupply;\n    }\n\n    /// @notice subtract reputation points for a _participant\n    function reduceReputation(address _participant, uint256 _point)\n        public\n        returns (uint256 _newPoint, uint256 _totalPoint)\n    {\n        require(sender_is_from([CONTRACT_DAO_VOTING_CLAIMS, CONTRACT_DAO_REWARDS_MANAGER, EMPTY_BYTES]));\n        uint256 _toDeduct = _point;\n        if (reputationPoint.balance[_participant] > _point) {\n            reputationPoint.balance[_participant] = reputationPoint.balance[_participant].sub(_point);\n        } else {\n            _toDeduct = reputationPoint.balance[_participant];\n            reputationPoint.balance[_participant] = 0;\n        }\n\n        reputationPoint.totalSupply = reputationPoint.totalSupply.sub(_toDeduct);\n\n        _newPoint = reputationPoint.balance[_participant];\n        _totalPoint = reputationPoint.totalSupply;\n    }\n\n  /// @notice get reputation points for a _participant\n  function getReputation(address _participant)\n      public\n      view\n      returns (uint256 _point)\n  {\n      _point = reputationPoint.balance[_participant];\n  }\n\n  /// @notice get total reputation points distributed in the dao\n  function getTotalReputation()\n      public\n      view\n      returns (uint256 _totalPoint)\n  {\n      _totalPoint = reputationPoint.totalSupply;\n  }\n}\n\n// File: contracts/storage/DaoRewardsStorage.sol\npragma solidity ^0.4.25;\n\n// this contract will receive DGXs fees from the DGX fees distributors\ncontract DaoRewardsStorage is ResolverClient, DaoConstants {\n    using DaoStructs for DaoStructs.DaoQuarterInfo;\n\n    // DaoQuarterInfo is a struct that stores the quarter specific information\n    // regarding totalEffectiveDGDs, DGX distribution day, etc. pls check\n    // docs in lib/DaoStructs\n    mapping(uint256 => DaoStructs.DaoQuarterInfo) public allQuartersInfo;\n\n    // Mapping that stores the DGX that can be claimed as rewards by\n    // an address (a participant of DigixDAO)\n    mapping(address => uint256) public claimableDGXs;\n\n    // This stores the total DGX value that has been claimed by participants\n    // this can be done by calling the DaoRewardsManager.claimRewards method\n    // Note that this value is the only outgoing DGX from DaoRewardsManager contract\n    // Note that this value also takes into account the demurrage that has been paid\n    // by participants for simply holding their DGXs in the DaoRewardsManager contract\n    uint256 public totalDGXsClaimed;\n\n    // The Quarter ID in which the user last participated in\n    // To participate means they had locked more than CONFIG_MINIMUM_LOCKED_DGD\n    // DGD tokens. In addition, they should not have withdrawn those tokens in the same\n    // quarter. Basically, in the main phase of the quarter, if DaoCommon.isParticipant(_user)\n    // was true, they were participants. And that quarter was their lastParticipatedQuarter\n    mapping (address => uint256) public lastParticipatedQuarter;\n\n    // This mapping is only used to update the lastParticipatedQuarter to the\n    // previousLastParticipatedQuarter in case users lock and withdraw DGDs\n    // within the same quarter's locking phase\n    mapping (address => uint256) public previousLastParticipatedQuarter;\n\n    // This number marks the Quarter in which the rewards were last updated for that user\n    // Since the rewards calculation for a specific quarter is only done once that\n    // quarter is completed, we need this value to note the last quarter when the rewards were updated\n    // We then start adding the rewards for all quarters after that quarter, until the current quarter\n    mapping (address => uint256) public lastQuarterThatRewardsWasUpdated;\n\n    // Similar as the lastQuarterThatRewardsWasUpdated, but this is for reputation updates\n    // Note that reputation can also be deducted for no participation (not locking DGDs)\n    // This value is used to update the reputation based on all quarters from the lastQuarterThatReputationWasUpdated\n    // to the current quarter\n    mapping (address => uint256) public lastQuarterThatReputationWasUpdated;\n\n    constructor(address _resolver)\n           public\n    {\n        require(init(CONTRACT_STORAGE_DAO_REWARDS, _resolver));\n    }\n\n    function updateQuarterInfo(\n        uint256 _quarterNumber,\n        uint256 _minimalParticipationPoint,\n        uint256 _quarterPointScalingFactor,\n        uint256 _reputationPointScalingFactor,\n        uint256 _totalEffectiveDGDPreviousQuarter,\n\n        uint256 _moderatorMinimalQuarterPoint,\n        uint256 _moderatorQuarterPointScalingFactor,\n        uint256 _moderatorReputationPointScalingFactor,\n        uint256 _totalEffectiveModeratorDGDLastQuarter,\n\n        uint256 _dgxDistributionDay,\n        uint256 _dgxRewardsPoolLastQuarter,\n        uint256 _sumRewardsFromBeginning\n    )\n        public\n    {\n        require(sender_is(CONTRACT_DAO_REWARDS_MANAGER));\n        allQuartersInfo[_quarterNumber].minimalParticipationPoint = _minimalParticipationPoint;\n        allQuartersInfo[_quarterNumber].quarterPointScalingFactor = _quarterPointScalingFactor;\n        allQuartersInfo[_quarterNumber].reputationPointScalingFactor = _reputationPointScalingFactor;\n        allQuartersInfo[_quarterNumber].totalEffectiveDGDPreviousQuarter = _totalEffectiveDGDPreviousQuarter;\n\n        allQuartersInfo[_quarterNumber].moderatorMinimalParticipationPoint = _moderatorMinimalQuarterPoint;\n        allQuartersInfo[_quarterNumber].moderatorQuarterPointScalingFactor = _moderatorQuarterPointScalingFactor;\n        allQuartersInfo[_quarterNumber].moderatorReputationPointScalingFactor = _moderatorReputationPointScalingFactor;\n        allQuartersInfo[_quarterNumber].totalEffectiveModeratorDGDLastQuarter = _totalEffectiveModeratorDGDLastQuarter;\n\n        allQuartersInfo[_quarterNumber].dgxDistributionDay = _dgxDistributionDay;\n        allQuartersInfo[_quarterNumber].dgxRewardsPoolLastQuarter = _dgxRewardsPoolLastQuarter;\n        allQuartersInfo[_quarterNumber].sumRewardsFromBeginning = _sumRewardsFromBeginning;\n    }\n\n    function updateClaimableDGX(address _user, uint256 _newClaimableDGX)\n        public\n    {\n        require(sender_is(CONTRACT_DAO_REWARDS_MANAGER));\n        claimableDGXs[_user] = _newClaimableDGX;\n    }\n\n    function updateLastParticipatedQuarter(address _user, uint256 _lastQuarter)\n        public\n    {\n        require(sender_is(CONTRACT_DAO_STAKE_LOCKING));\n        lastParticipatedQuarter[_user] = _lastQuarter;\n    }\n\n    function updatePreviousLastParticipatedQuarter(address _user, uint256 _lastQuarter)\n        public\n    {\n        require(sender_is(CONTRACT_DAO_STAKE_LOCKING));\n        previousLastParticipatedQuarter[_user] = _lastQuarter;\n    }\n\n    function updateLastQuarterThatRewardsWasUpdated(address _user, uint256 _lastQuarter)\n        public\n    {\n        require(sender_is_from([CONTRACT_DAO_REWARDS_MANAGER, CONTRACT_DAO_STAKE_LOCKING, EMPTY_BYTES]));\n        lastQuarterThatRewardsWasUpdated[_user] = _lastQuarter;\n    }\n\n    function updateLastQuarterThatReputationWasUpdated(address _user, uint256 _lastQuarter)\n        public\n    {\n        require(sender_is_from([CONTRACT_DAO_REWARDS_MANAGER, CONTRACT_DAO_STAKE_LOCKING, EMPTY_BYTES]));\n        lastQuarterThatReputationWasUpdated[_user] = _lastQuarter;\n    }\n\n    function addToTotalDgxClaimed(uint256 _dgxClaimed)\n        public\n    {\n        require(sender_is(CONTRACT_DAO_REWARDS_MANAGER));\n        totalDGXsClaimed = totalDGXsClaimed.add(_dgxClaimed);\n    }\n\n    function readQuarterInfo(uint256 _quarterNumber)\n        public\n        view\n        returns (\n            uint256 _minimalParticipationPoint,\n            uint256 _quarterPointScalingFactor,\n            uint256 _reputationPointScalingFactor,\n            uint256 _totalEffectiveDGDPreviousQuarter,\n\n            uint256 _moderatorMinimalQuarterPoint,\n            uint256 _moderatorQuarterPointScalingFactor,\n            uint256 _moderatorReputationPointScalingFactor,\n            uint256 _totalEffectiveModeratorDGDLastQuarter,\n\n            uint256 _dgxDistributionDay,\n            uint256 _dgxRewardsPoolLastQuarter,\n            uint256 _sumRewardsFromBeginning\n        )\n    {\n        _minimalParticipationPoint = allQuartersInfo[_quarterNumber].minimalParticipationPoint;\n        _quarterPointScalingFactor = allQuartersInfo[_quarterNumber].quarterPointScalingFactor;\n        _reputationPointScalingFactor = allQuartersInfo[_quarterNumber].reputationPointScalingFactor;\n        _totalEffectiveDGDPreviousQuarter = allQuartersInfo[_quarterNumber].totalEffectiveDGDPreviousQuarter;\n        _moderatorMinimalQuarterPoint = allQuartersInfo[_quarterNumber].moderatorMinimalParticipationPoint;\n        _moderatorQuarterPointScalingFactor = allQuartersInfo[_quarterNumber].moderatorQuarterPointScalingFactor;\n        _moderatorReputationPointScalingFactor = allQuartersInfo[_quarterNumber].moderatorReputationPointScalingFactor;\n        _totalEffectiveModeratorDGDLastQuarter = allQuartersInfo[_quarterNumber].totalEffectiveModeratorDGDLastQuarter;\n        _dgxDistributionDay = allQuartersInfo[_quarterNumber].dgxDistributionDay;\n        _dgxRewardsPoolLastQuarter = allQuartersInfo[_quarterNumber].dgxRewardsPoolLastQuarter;\n        _sumRewardsFromBeginning = allQuartersInfo[_quarterNumber].sumRewardsFromBeginning;\n    }\n\n    function readQuarterGeneralInfo(uint256 _quarterNumber)\n        public\n        view\n        returns (\n            uint256 _dgxDistributionDay,\n            uint256 _dgxRewardsPoolLastQuarter,\n            uint256 _sumRewardsFromBeginning\n        )\n    {\n        _dgxDistributionDay = allQuartersInfo[_quarterNumber].dgxDistributionDay;\n        _dgxRewardsPoolLastQuarter = allQuartersInfo[_quarterNumber].dgxRewardsPoolLastQuarter;\n        _sumRewardsFromBeginning = allQuartersInfo[_quarterNumber].sumRewardsFromBeginning;\n    }\n\n    function readQuarterModeratorInfo(uint256 _quarterNumber)\n        public\n        view\n        returns (\n            uint256 _moderatorMinimalQuarterPoint,\n            uint256 _moderatorQuarterPointScalingFactor,\n            uint256 _moderatorReputationPointScalingFactor,\n            uint256 _totalEffectiveModeratorDGDLastQuarter\n        )\n    {\n        _moderatorMinimalQuarterPoint = allQuartersInfo[_quarterNumber].moderatorMinimalParticipationPoint;\n        _moderatorQuarterPointScalingFactor = allQuartersInfo[_quarterNumber].moderatorQuarterPointScalingFactor;\n        _moderatorReputationPointScalingFactor = allQuartersInfo[_quarterNumber].moderatorReputationPointScalingFactor;\n        _totalEffectiveModeratorDGDLastQuarter = allQuartersInfo[_quarterNumber].totalEffectiveModeratorDGDLastQuarter;\n    }\n\n    function readQuarterParticipantInfo(uint256 _quarterNumber)\n        public\n        view\n        returns (\n            uint256 _minimalParticipationPoint,\n            uint256 _quarterPointScalingFactor,\n            uint256 _reputationPointScalingFactor,\n            uint256 _totalEffectiveDGDPreviousQuarter\n        )\n    {\n        _minimalParticipationPoint = allQuartersInfo[_quarterNumber].minimalParticipationPoint;\n        _quarterPointScalingFactor = allQuartersInfo[_quarterNumber].quarterPointScalingFactor;\n        _reputationPointScalingFactor = allQuartersInfo[_quarterNumber].reputationPointScalingFactor;\n        _totalEffectiveDGDPreviousQuarter = allQuartersInfo[_quarterNumber].totalEffectiveDGDPreviousQuarter;\n    }\n\n    function readDgxDistributionDay(uint256 _quarterNumber)\n        public\n        view\n        returns (uint256 _distributionDay)\n    {\n        _distributionDay = allQuartersInfo[_quarterNumber].dgxDistributionDay;\n    }\n\n    function readTotalEffectiveDGDLastQuarter(uint256 _quarterNumber)\n        public\n        view\n        returns (uint256 _totalEffectiveDGDPreviousQuarter)\n    {\n        _totalEffectiveDGDPreviousQuarter = allQuartersInfo[_quarterNumber].totalEffectiveDGDPreviousQuarter;\n    }\n\n    function readTotalEffectiveModeratorDGDLastQuarter(uint256 _quarterNumber)\n        public\n        view\n        returns (uint256 _totalEffectiveModeratorDGDLastQuarter)\n    {\n        _totalEffectiveModeratorDGDLastQuarter = allQuartersInfo[_quarterNumber].totalEffectiveModeratorDGDLastQuarter;\n    }\n\n    function readRewardsPoolOfLastQuarter(uint256 _quarterNumber)\n        public\n        view\n        returns (uint256 _rewardsPool)\n    {\n        _rewardsPool = allQuartersInfo[_quarterNumber].dgxRewardsPoolLastQuarter;\n    }\n}\n\n// File: contracts/storage/IntermediateResultsStorage.sol\npragma solidity ^0.4.25;\n\ncontract IntermediateResultsStorage is ResolverClient, DaoConstants {\n    using DaoStructs for DaoStructs.IntermediateResults;\n\n    constructor(address _resolver) public {\n        require(init(CONTRACT_STORAGE_INTERMEDIATE_RESULTS, _resolver));\n    }\n\n    // There are scenarios in which we must loop across all participants/moderators\n    // in a function call. For a big number of operations, the function call may be short of gas\n    // To tackle this, we use an IntermediateResults struct to store the intermediate results\n    // The same function is then called multiple times until all operations are completed\n    // If the operations cannot be done in that iteration, the intermediate results are stored\n    // else, the final outcome is returned\n    // Please check the lib/DaoStructs for docs on this struct\n    mapping (bytes32 => DaoStructs.IntermediateResults) allIntermediateResults;\n\n    function getIntermediateResults(bytes32 _key)\n        public\n        view\n        returns (\n            address _countedUntil,\n            uint256 _currentForCount,\n            uint256 _currentAgainstCount,\n            uint256 _currentSumOfEffectiveBalance\n        )\n    {\n        _countedUntil = allIntermediateResults[_key].countedUntil;\n        _currentForCount = allIntermediateResults[_key].currentForCount;\n        _currentAgainstCount = allIntermediateResults[_key].currentAgainstCount;\n        _currentSumOfEffectiveBalance = allIntermediateResults[_key].currentSumOfEffectiveBalance;\n    }\n\n    function resetIntermediateResults(bytes32 _key)\n        public\n    {\n        require(sender_is_from([CONTRACT_DAO_REWARDS_MANAGER, CONTRACT_DAO_VOTING_CLAIMS, CONTRACT_DAO_SPECIAL_VOTING_CLAIMS]));\n        allIntermediateResults[_key].countedUntil = address(0x0);\n    }\n\n    function setIntermediateResults(\n        bytes32 _key,\n        address _countedUntil,\n        uint256 _currentForCount,\n        uint256 _currentAgainstCount,\n        uint256 _currentSumOfEffectiveBalance\n    )\n        public\n    {\n        require(sender_is_from([CONTRACT_DAO_REWARDS_MANAGER, CONTRACT_DAO_VOTING_CLAIMS, CONTRACT_DAO_SPECIAL_VOTING_CLAIMS]));\n        allIntermediateResults[_key].countedUntil = _countedUntil;\n        allIntermediateResults[_key].currentForCount = _currentForCount;\n        allIntermediateResults[_key].currentAgainstCount = _currentAgainstCount;\n        allIntermediateResults[_key].currentSumOfEffectiveBalance = _currentSumOfEffectiveBalance;\n    }\n}\n\n// File: contracts/common/DaoCommonMini.sol\npragma solidity ^0.4.25;\n\ncontract DaoCommonMini is IdentityCommon {\n\n    using MathHelper for MathHelper;\n\n    /**\n    @notice Check if the DAO contracts have been replaced by a new set of contracts\n    @return _isNotReplaced true if it is not replaced, false if it has already been replaced\n    */\n    function isDaoNotReplaced()\n        public\n        view\n        returns (bool _isNotReplaced)\n    {\n        _isNotReplaced = !daoUpgradeStorage().isReplacedByNewDao();\n    }\n\n    /**\n    @notice Check if it is currently in the locking phase\n    @dev No governance activities can happen in the locking phase. The locking phase is from t=0 to t=CONFIG_LOCKING_PHASE_DURATION-1\n    @return _isLockingPhase true if it is in the locking phase\n    */\n    function isLockingPhase()\n        public\n        view\n        returns (bool _isLockingPhase)\n    {\n        _isLockingPhase = currentTimeInQuarter() < getUintConfig(CONFIG_LOCKING_PHASE_DURATION);\n    }\n\n    /**\n    @notice Check if it is currently in a main phase.\n    @dev The main phase is where all the governance activities could take plase. If the DAO is replaced, there can never be any more main phase.\n    @return _isMainPhase true if it is in a main phase\n    */\n    function isMainPhase()\n        public\n        view\n        returns (bool _isMainPhase)\n    {\n        _isMainPhase =\n            isDaoNotReplaced() &&\n            currentTimeInQuarter() >= getUintConfig(CONFIG_LOCKING_PHASE_DURATION);\n    }\n\n    /**\n    @notice Check if the calculateGlobalRewardsBeforeNewQuarter function has been done for a certain quarter\n    @dev However, there is no need to run calculateGlobalRewardsBeforeNewQuarter for the first quarter\n    */\n    modifier ifGlobalRewardsSet(uint256 _quarterNumber) {\n        if (_quarterNumber > 1) {\n            require(daoRewardsStorage().readDgxDistributionDay(_quarterNumber) > 0);\n        }\n        _;\n    }\n\n    /**\n    @notice require that it is currently during a phase, which is within _relativePhaseStart and _relativePhaseEnd seconds, after the _startingPoint\n    */\n    function requireInPhase(uint256 _startingPoint, uint256 _relativePhaseStart, uint256 _relativePhaseEnd)\n        internal\n        view\n    {\n        require(_startingPoint > 0);\n        require(now < _startingPoint.add(_relativePhaseEnd));\n        require(now >= _startingPoint.add(_relativePhaseStart));\n    }\n\n    /**\n    @notice Get the current quarter index\n    @dev Quarter indexes starts from 1\n    @return _quarterNumber the current quarter index\n    */\n    function currentQuarterNumber()\n        public\n        view\n        returns(uint256 _quarterNumber)\n    {\n        _quarterNumber = getQuarterNumber(now);\n    }\n\n    /**\n    @notice Get the quarter index of a timestamp\n    @dev Quarter indexes starts from 1\n    @return _index the quarter index\n    */\n    function getQuarterNumber(uint256 _time)\n        internal\n        view\n        returns (uint256 _index)\n    {\n        require(startOfFirstQuarterIsSet());\n        _index =\n            _time.sub(daoUpgradeStorage().startOfFirstQuarter())\n            .div(getUintConfig(CONFIG_QUARTER_DURATION))\n            .add(1);\n    }\n\n    /**\n    @notice Get the relative time in quarter of a timestamp\n    @dev For example, the timeInQuarter of the first second of any quarter n-th is always 1\n    */\n    function timeInQuarter(uint256 _time)\n        internal\n        view\n        returns (uint256 _timeInQuarter)\n    {\n        require(startOfFirstQuarterIsSet()); // must be already set\n        _timeInQuarter =\n            _time.sub(daoUpgradeStorage().startOfFirstQuarter())\n            % getUintConfig(CONFIG_QUARTER_DURATION);\n    }\n\n    /**\n    @notice Check if the start of first quarter is already set\n    @return _isSet true if start of first quarter is already set\n    */\n    function startOfFirstQuarterIsSet()\n        internal\n        view\n        returns (bool _isSet)\n    {\n        _isSet = daoUpgradeStorage().startOfFirstQuarter() != 0;\n    }\n\n    /**\n    @notice Get the current relative time in the quarter\n    @dev For example: the currentTimeInQuarter of the first second of any quarter is 1\n    @return _currentT the current relative time in the quarter\n    */\n    function currentTimeInQuarter()\n        public\n        view\n        returns (uint256 _currentT)\n    {\n        _currentT = timeInQuarter(now);\n    }\n\n    /**\n    @notice Get the time remaining in the quarter\n    */\n    function getTimeLeftInQuarter(uint256 _time)\n        internal\n        view\n        returns (uint256 _timeLeftInQuarter)\n    {\n        _timeLeftInQuarter = getUintConfig(CONFIG_QUARTER_DURATION).sub(timeInQuarter(_time));\n    }\n\n    function daoListingService()\n        internal\n        view\n        returns (DaoListingService _contract)\n    {\n        _contract = DaoListingService(get_contract(CONTRACT_SERVICE_DAO_LISTING));\n    }\n\n    function daoConfigsStorage()\n        internal\n        view\n        returns (DaoConfigsStorage _contract)\n    {\n        _contract = DaoConfigsStorage(get_contract(CONTRACT_STORAGE_DAO_CONFIG));\n    }\n\n    function daoStakeStorage()\n        internal\n        view\n        returns (DaoStakeStorage _contract)\n    {\n        _contract = DaoStakeStorage(get_contract(CONTRACT_STORAGE_DAO_STAKE));\n    }\n\n    function daoStorage()\n        internal\n        view\n        returns (DaoStorage _contract)\n    {\n        _contract = DaoStorage(get_contract(CONTRACT_STORAGE_DAO));\n    }\n\n    function daoProposalCounterStorage()\n        internal\n        view\n        returns (DaoProposalCounterStorage _contract)\n    {\n        _contract = DaoProposalCounterStorage(get_contract(CONTRACT_STORAGE_DAO_COUNTER));\n    }\n\n    function daoUpgradeStorage()\n        internal\n        view\n        returns (DaoUpgradeStorage _contract)\n    {\n        _contract = DaoUpgradeStorage(get_contract(CONTRACT_STORAGE_DAO_UPGRADE));\n    }\n\n    function daoSpecialStorage()\n        internal\n        view\n        returns (DaoSpecialStorage _contract)\n    {\n        _contract = DaoSpecialStorage(get_contract(CONTRACT_STORAGE_DAO_SPECIAL));\n    }\n\n    function daoPointsStorage()\n        internal\n        view\n        returns (DaoPointsStorage _contract)\n    {\n        _contract = DaoPointsStorage(get_contract(CONTRACT_STORAGE_DAO_POINTS));\n    }\n\n    function daoRewardsStorage()\n        internal\n        view\n        returns (DaoRewardsStorage _contract)\n    {\n        _contract = DaoRewardsStorage(get_contract(CONTRACT_STORAGE_DAO_REWARDS));\n    }\n\n    function intermediateResultsStorage()\n        internal\n        view\n        returns (IntermediateResultsStorage _contract)\n    {\n        _contract = IntermediateResultsStorage(get_contract(CONTRACT_STORAGE_INTERMEDIATE_RESULTS));\n    }\n\n    function getUintConfig(bytes32 _configKey)\n        public\n        view\n        returns (uint256 _configValue)\n    {\n        _configValue = daoConfigsStorage().uintConfigs(_configKey);\n    }\n}\n\n// File: contracts/common/DaoCommon.sol\npragma solidity ^0.4.25;\n\ncontract DaoCommon is DaoCommonMini {\n\n    using MathHelper for MathHelper;\n\n    /**\n    @notice Check if the transaction is called by the proposer of a proposal\n    @return _isFromProposer true if the caller is the proposer\n    */\n    function isFromProposer(bytes32 _proposalId)\n        internal\n        view\n        returns (bool _isFromProposer)\n    {\n        _isFromProposer = msg.sender == daoStorage().readProposalProposer(_proposalId);\n    }\n\n    /**\n    @notice Check if the proposal can still be \"editted\", or in other words, added more versions\n    @dev Once the proposal is finalized, it can no longer be editted. The proposer will still be able to add docs and change fundings though.\n    @return _isEditable true if the proposal is editable\n    */\n    function isEditable(bytes32 _proposalId)\n        internal\n        view\n        returns (bool _isEditable)\n    {\n        bytes32 _finalVersion;\n        (,,,,,,,_finalVersion,,) = daoStorage().readProposal(_proposalId);\n        _isEditable = _finalVersion == EMPTY_BYTES;\n    }\n\n    /**\n    @notice returns the balance of DaoFundingManager, which is the wei in DigixDAO\n    */\n    function weiInDao()\n        internal\n        view\n        returns (uint256 _wei)\n    {\n        _wei = get_contract(CONTRACT_DAO_FUNDING_MANAGER).balance;\n    }\n\n    /**\n    @notice Check if it is after the draft voting phase of the proposal\n    */\n    modifier ifAfterDraftVotingPhase(bytes32 _proposalId) {\n        uint256 _start = daoStorage().readProposalDraftVotingTime(_proposalId);\n        require(_start > 0); // Draft voting must have started. In other words, proposer must have finalized the proposal\n        require(now >= _start.add(getUintConfig(CONFIG_DRAFT_VOTING_PHASE)));\n        _;\n    }\n\n    modifier ifCommitPhase(bytes32 _proposalId, uint8 _index) {\n        requireInPhase(\n            daoStorage().readProposalVotingTime(_proposalId, _index),\n            0,\n            getUintConfig(_index == 0 ? CONFIG_VOTING_COMMIT_PHASE : CONFIG_INTERIM_COMMIT_PHASE)\n        );\n        _;\n    }\n\n    modifier ifRevealPhase(bytes32 _proposalId, uint256 _index) {\n      requireInPhase(\n          daoStorage().readProposalVotingTime(_proposalId, _index),\n          getUintConfig(_index == 0 ? CONFIG_VOTING_COMMIT_PHASE : CONFIG_INTERIM_COMMIT_PHASE),\n          getUintConfig(_index == 0 ? CONFIG_VOTING_PHASE_TOTAL : CONFIG_INTERIM_PHASE_TOTAL)\n      );\n      _;\n    }\n\n    modifier ifAfterProposalRevealPhase(bytes32 _proposalId, uint256 _index) {\n      uint256 _start = daoStorage().readProposalVotingTime(_proposalId, _index);\n      require(_start > 0);\n      require(now >= _start.add(getUintConfig(_index == 0 ? CONFIG_VOTING_PHASE_TOTAL : CONFIG_INTERIM_PHASE_TOTAL)));\n      _;\n    }\n\n    modifier ifDraftVotingPhase(bytes32 _proposalId) {\n        requireInPhase(\n            daoStorage().readProposalDraftVotingTime(_proposalId),\n            0,\n            getUintConfig(CONFIG_DRAFT_VOTING_PHASE)\n        );\n        _;\n    }\n\n    modifier isProposalState(bytes32 _proposalId, bytes32 _STATE) {\n        bytes32 _currentState;\n        (,,,_currentState,,,,,,) = daoStorage().readProposal(_proposalId);\n        require(_currentState == _STATE);\n        _;\n    }\n\n    /**\n    @notice Check if the DAO has enough ETHs for a particular funding request\n    */\n    modifier ifFundingPossible(uint256[] _fundings, uint256 _finalReward) {\n        require(MathHelper.sumNumbers(_fundings).add(_finalReward) <= weiInDao());\n        _;\n    }\n\n    modifier ifDraftNotClaimed(bytes32 _proposalId) {\n        require(daoStorage().isDraftClaimed(_proposalId) == false);\n        _;\n    }\n\n    modifier ifNotClaimed(bytes32 _proposalId, uint256 _index) {\n        require(daoStorage().isClaimed(_proposalId, _index) == false);\n        _;\n    }\n\n    modifier ifNotClaimedSpecial(bytes32 _proposalId) {\n        require(daoSpecialStorage().isClaimed(_proposalId) == false);\n        _;\n    }\n\n    modifier hasNotRevealed(bytes32 _proposalId, uint256 _index) {\n        uint256 _voteWeight;\n        (, _voteWeight) = daoStorage().readVote(_proposalId, _index, msg.sender);\n        require(_voteWeight == uint(0));\n        _;\n    }\n\n    modifier hasNotRevealedSpecial(bytes32 _proposalId) {\n        uint256 _weight;\n        (,_weight) = daoSpecialStorage().readVote(_proposalId, msg.sender);\n        require(_weight == uint256(0));\n        _;\n    }\n\n    modifier ifAfterRevealPhaseSpecial(bytes32 _proposalId) {\n      uint256 _start = daoSpecialStorage().readVotingTime(_proposalId);\n      require(_start > 0);\n      require(now.sub(_start) >= getUintConfig(CONFIG_SPECIAL_PROPOSAL_PHASE_TOTAL));\n      _;\n    }\n\n    modifier ifCommitPhaseSpecial(bytes32 _proposalId) {\n        requireInPhase(\n            daoSpecialStorage().readVotingTime(_proposalId),\n            0,\n            getUintConfig(CONFIG_SPECIAL_PROPOSAL_COMMIT_PHASE)\n        );\n        _;\n    }\n\n    modifier ifRevealPhaseSpecial(bytes32 _proposalId) {\n        requireInPhase(\n            daoSpecialStorage().readVotingTime(_proposalId),\n            getUintConfig(CONFIG_SPECIAL_PROPOSAL_COMMIT_PHASE),\n            getUintConfig(CONFIG_SPECIAL_PROPOSAL_PHASE_TOTAL)\n        );\n        _;\n    }\n\n    function daoWhitelistingStorage()\n        internal\n        view\n        returns (DaoWhitelistingStorage _contract)\n    {\n        _contract = DaoWhitelistingStorage(get_contract(CONTRACT_STORAGE_DAO_WHITELISTING));\n    }\n\n    function getAddressConfig(bytes32 _configKey)\n        public\n        view\n        returns (address _configValue)\n    {\n        _configValue = daoConfigsStorage().addressConfigs(_configKey);\n    }\n\n    function getBytesConfig(bytes32 _configKey)\n        public\n        view\n        returns (bytes32 _configValue)\n    {\n        _configValue = daoConfigsStorage().bytesConfigs(_configKey);\n    }\n\n    /**\n    @notice Check if a user is a participant in the current quarter\n    */\n    function isParticipant(address _user)\n        public\n        view\n        returns (bool _is)\n    {\n        _is =\n            (daoRewardsStorage().lastParticipatedQuarter(_user) == currentQuarterNumber())\n            && (daoStakeStorage().lockedDGDStake(_user) >= getUintConfig(CONFIG_MINIMUM_LOCKED_DGD));\n    }\n\n    /**\n    @notice Check if a user is a moderator in the current quarter\n    */\n    function isModerator(address _user)\n        public\n        view\n        returns (bool _is)\n    {\n        _is =\n            (daoRewardsStorage().lastParticipatedQuarter(_user) == currentQuarterNumber())\n            && (daoStakeStorage().lockedDGDStake(_user) >= getUintConfig(CONFIG_MINIMUM_DGD_FOR_MODERATOR))\n            && (daoPointsStorage().getReputation(_user) >= getUintConfig(CONFIG_MINIMUM_REPUTATION_FOR_MODERATOR));\n    }\n\n    /**\n    @notice Calculate the start of a specific milestone of a specific proposal.\n    @dev This is calculated from the voting start of the voting round preceding the milestone\n         This would throw if the voting start is 0 (the voting round has not started yet)\n         Note that if the milestoneIndex is exactly the same as the number of milestones,\n         This will just return the end of the last voting round.\n    */\n    function startOfMilestone(bytes32 _proposalId, uint256 _milestoneIndex)\n        internal\n        view\n        returns (uint256 _milestoneStart)\n    {\n        uint256 _startOfPrecedingVotingRound = daoStorage().readProposalVotingTime(_proposalId, _milestoneIndex);\n        require(_startOfPrecedingVotingRound > 0);\n        // the preceding voting round must have started\n\n        if (_milestoneIndex == 0) { // This is the 1st milestone, which starts after voting round 0\n            _milestoneStart =\n                _startOfPrecedingVotingRound\n                .add(getUintConfig(CONFIG_VOTING_PHASE_TOTAL));\n        } else { // if its the n-th milestone, it starts after voting round n-th\n            _milestoneStart =\n                _startOfPrecedingVotingRound\n                .add(getUintConfig(CONFIG_INTERIM_PHASE_TOTAL));\n        }\n    }\n\n    /**\n    @notice Calculate the actual voting start for a voting round, given the tentative start\n    @dev The tentative start is the ideal start. For example, when a proposer finish a milestone, it should be now\n         However, sometimes the tentative start is too close to the end of the quarter, hence, the actual voting start should be pushed to the next quarter\n    */\n    function getTimelineForNextVote(\n        uint256 _index,\n        uint256 _tentativeVotingStart\n    )\n        internal\n        view\n        returns (uint256 _actualVotingStart)\n    {\n        uint256 _timeLeftInQuarter = getTimeLeftInQuarter(_tentativeVotingStart);\n        uint256 _votingDuration = getUintConfig(_index == 0 ? CONFIG_VOTING_PHASE_TOTAL : CONFIG_INTERIM_PHASE_TOTAL);\n        _actualVotingStart = _tentativeVotingStart;\n        if (timeInQuarter(_tentativeVotingStart) < getUintConfig(CONFIG_LOCKING_PHASE_DURATION)) { // if the tentative start is during a locking phase\n            _actualVotingStart = _tentativeVotingStart.add(\n                getUintConfig(CONFIG_LOCKING_PHASE_DURATION).sub(timeInQuarter(_tentativeVotingStart))\n            );\n        } else if (_timeLeftInQuarter < _votingDuration.add(getUintConfig(CONFIG_VOTE_CLAIMING_DEADLINE))) { // if the time left in quarter is not enough to vote and claim voting\n            _actualVotingStart = _tentativeVotingStart.add(\n                _timeLeftInQuarter.add(getUintConfig(CONFIG_LOCKING_PHASE_DURATION)).add(1)\n            );\n        }\n    }\n\n    /**\n    @notice Check if we can add another non-Digix proposal in this quarter\n    @dev There is a max cap to the number of non-Digix proposals CONFIG_NON_DIGIX_PROPOSAL_CAP_PER_QUARTER\n    */\n    function checkNonDigixProposalLimit(bytes32 _proposalId)\n        internal\n        view\n    {\n        require(isNonDigixProposalsWithinLimit(_proposalId));\n    }\n\n    function isNonDigixProposalsWithinLimit(bytes32 _proposalId)\n        internal\n        view\n        returns (bool _withinLimit)\n    {\n        bool _isDigixProposal;\n        (,,,,,,,,,_isDigixProposal) = daoStorage().readProposal(_proposalId);\n        _withinLimit = true;\n        if (!_isDigixProposal) {\n            _withinLimit = daoProposalCounterStorage().proposalCountByQuarter(currentQuarterNumber()) < getUintConfig(CONFIG_NON_DIGIX_PROPOSAL_CAP_PER_QUARTER);\n        }\n    }\n\n    /**\n    @notice If its a non-Digix proposal, check if the fundings are within limit\n    @dev There is a max cap to the fundings and number of milestones for non-Digix proposals\n    */\n    function checkNonDigixFundings(uint256[] _milestonesFundings, uint256 _finalReward)\n        internal\n        view\n    {\n        if (!is_founder()) {\n            require(_milestonesFundings.length <= getUintConfig(CONFIG_MAX_MILESTONES_FOR_NON_DIGIX));\n            require(MathHelper.sumNumbers(_milestonesFundings).add(_finalReward) <= getUintConfig(CONFIG_MAX_FUNDING_FOR_NON_DIGIX));\n        }\n    }\n\n    /**\n    @notice Check if msg.sender can do operations as a proposer\n    @dev Note that this function does not check if he is the proposer of the proposal\n    */\n    function senderCanDoProposerOperations()\n        internal\n        view\n    {\n        require(isMainPhase());\n        require(isParticipant(msg.sender));\n        require(identity_storage().is_kyc_approved(msg.sender));\n    }\n}\n\n// File: contracts/interface/DgxDemurrageCalculator.sol\npragma solidity ^0.4.25;\n\n/// @title Digix Gold Token Demurrage Calculator\n/// @author Digix Holdings Pte Ltd\n/// @notice This contract is meant to be used by exchanges/other parties who want to calculate the DGX demurrage fees, provided an initial balance and the days elapsed\ncontract DgxDemurrageCalculator {\n    function calculateDemurrage(uint256 _initial_balance, uint256 _days_elapsed)\n        public\n        view\n        returns (uint256 _demurrage_fees, bool _no_demurrage_fees);\n}\n\n// File: contracts/service/DaoCalculatorService.sol\npragma solidity ^0.4.25;\n\ncontract DaoCalculatorService is DaoCommon {\n\n    address public dgxDemurrageCalculatorAddress;\n\n    using MathHelper for MathHelper;\n\n    constructor(address _resolver, address _dgxDemurrageCalculatorAddress)\n        public\n    {\n        require(init(CONTRACT_SERVICE_DAO_CALCULATOR, _resolver));\n        dgxDemurrageCalculatorAddress = _dgxDemurrageCalculatorAddress;\n    }\n\n\n    /**\n    @notice Calculate the additional lockedDGDStake, given the DGDs that the user has just locked in\n    @dev The earlier the locking happens, the more lockedDGDStake the user will get\n         The formula is: additionalLockedDGDStake = (90 - t)/80 * additionalDGD if t is more than 10. If t<=10, additionalLockedDGDStake = additionalDGD\n    */\n    function calculateAdditionalLockedDGDStake(uint256 _additionalDgd)\n        public\n        view\n        returns (uint256 _additionalLockedDGDStake)\n    {\n        _additionalLockedDGDStake =\n            _additionalDgd.mul(\n                getUintConfig(CONFIG_QUARTER_DURATION)\n                .sub(\n                    MathHelper.max(\n                        currentTimeInQuarter(),\n                        getUintConfig(CONFIG_LOCKING_PHASE_DURATION)\n                    )\n                )\n            )\n            .div(\n                getUintConfig(CONFIG_QUARTER_DURATION)\n                .sub(getUintConfig(CONFIG_LOCKING_PHASE_DURATION))\n            );\n    }\n\n\n    // Quorum is in terms of lockedDGDStake\n    function minimumDraftQuorum(bytes32 _proposalId)\n        public\n        view\n        returns (uint256 _minQuorum)\n    {\n        uint256[] memory _fundings;\n\n        (_fundings,) = daoStorage().readProposalFunding(_proposalId);\n        _minQuorum = calculateMinQuorum(\n            daoStakeStorage().totalModeratorLockedDGDStake(),\n            getUintConfig(CONFIG_DRAFT_QUORUM_FIXED_PORTION_NUMERATOR),\n            getUintConfig(CONFIG_DRAFT_QUORUM_FIXED_PORTION_DENOMINATOR),\n            getUintConfig(CONFIG_DRAFT_QUORUM_SCALING_FACTOR_NUMERATOR),\n            getUintConfig(CONFIG_DRAFT_QUORUM_SCALING_FACTOR_DENOMINATOR),\n            _fundings[0]\n        );\n    }\n\n\n    function draftQuotaPass(uint256 _for, uint256 _against)\n        public\n        view\n        returns (bool _passed)\n    {\n        _passed = _for.mul(getUintConfig(CONFIG_DRAFT_QUOTA_DENOMINATOR))\n                > getUintConfig(CONFIG_DRAFT_QUOTA_NUMERATOR).mul(_for.add(_against));\n    }\n\n\n    // Quorum is in terms of lockedDGDStake\n    function minimumVotingQuorum(bytes32 _proposalId, uint256 _milestone_id)\n        public\n        view\n        returns (uint256 _minQuorum)\n    {\n        require(senderIsAllowedToRead());\n        uint256[] memory _weiAskedPerMilestone;\n        uint256 _finalReward;\n        (_weiAskedPerMilestone,_finalReward) = daoStorage().readProposalFunding(_proposalId);\n        require(_milestone_id <= _weiAskedPerMilestone.length);\n        if (_milestone_id == _weiAskedPerMilestone.length) {\n            // calculate quorum for the final voting round\n            _minQuorum = calculateMinQuorum(\n                daoStakeStorage().totalLockedDGDStake(),\n                getUintConfig(CONFIG_VOTING_QUORUM_FIXED_PORTION_NUMERATOR),\n                getUintConfig(CONFIG_VOTING_QUORUM_FIXED_PORTION_DENOMINATOR),\n                getUintConfig(CONFIG_FINAL_REWARD_SCALING_FACTOR_NUMERATOR),\n                getUintConfig(CONFIG_FINAL_REWARD_SCALING_FACTOR_DENOMINATOR),\n                _finalReward\n            );\n        } else {\n            // calculate quorum for a voting round\n            _minQuorum = calculateMinQuorum(\n                daoStakeStorage().totalLockedDGDStake(),\n                getUintConfig(CONFIG_VOTING_QUORUM_FIXED_PORTION_NUMERATOR),\n                getUintConfig(CONFIG_VOTING_QUORUM_FIXED_PORTION_DENOMINATOR),\n                getUintConfig(CONFIG_VOTING_QUORUM_SCALING_FACTOR_NUMERATOR),\n                getUintConfig(CONFIG_VOTING_QUORUM_SCALING_FACTOR_DENOMINATOR),\n                _weiAskedPerMilestone[_milestone_id]\n            );\n        }\n    }\n\n\n    // Quorum is in terms of lockedDGDStake\n    function minimumVotingQuorumForSpecial()\n        public\n        view\n        returns (uint256 _minQuorum)\n    {\n      _minQuorum = getUintConfig(CONFIG_SPECIAL_PROPOSAL_QUORUM_NUMERATOR).mul(\n                       daoStakeStorage().totalLockedDGDStake()\n                   ).div(\n                       getUintConfig(CONFIG_SPECIAL_PROPOSAL_QUORUM_DENOMINATOR)\n                   );\n    }\n\n\n    function votingQuotaPass(uint256 _for, uint256 _against)\n        public\n        view\n        returns (bool _passed)\n    {\n        _passed = _for.mul(getUintConfig(CONFIG_VOTING_QUOTA_DENOMINATOR))\n                > getUintConfig(CONFIG_VOTING_QUOTA_NUMERATOR).mul(_for.add(_against));\n    }\n\n\n    function votingQuotaForSpecialPass(uint256 _for, uint256 _against)\n        public\n        view\n        returns (bool _passed)\n    {\n        _passed =_for.mul(getUintConfig(CONFIG_SPECIAL_QUOTA_DENOMINATOR))\n                > getUintConfig(CONFIG_SPECIAL_QUOTA_NUMERATOR).mul(_for.add(_against));\n    }\n\n\n    function calculateMinQuorum(\n        uint256 _totalStake,\n        uint256 _fixedQuorumPortionNumerator,\n        uint256 _fixedQuorumPortionDenominator,\n        uint256 _scalingFactorNumerator,\n        uint256 _scalingFactorDenominator,\n        uint256 _weiAsked\n    )\n        internal\n        view\n        returns (uint256 _minimumQuorum)\n    {\n        uint256 _weiInDao = weiInDao();\n        // add the fixed portion of the quorum\n        _minimumQuorum = (_totalStake.mul(_fixedQuorumPortionNumerator)).div(_fixedQuorumPortionDenominator);\n\n        // add the dynamic portion of the quorum\n        _minimumQuorum = _minimumQuorum.add(_totalStake.mul(_weiAsked.mul(_scalingFactorNumerator)).div(_weiInDao.mul(_scalingFactorDenominator)));\n    }\n\n\n    function calculateUserEffectiveBalance(\n        uint256 _minimalParticipationPoint,\n        uint256 _quarterPointScalingFactor,\n        uint256 _reputationPointScalingFactor,\n        uint256 _quarterPoint,\n        uint256 _reputationPoint,\n        uint256 _lockedDGDStake\n    )\n        public\n        pure\n        returns (uint256 _effectiveDGDBalance)\n    {\n        uint256 _baseDGDBalance = MathHelper.min(_quarterPoint, _minimalParticipationPoint).mul(_lockedDGDStake).div(_minimalParticipationPoint);\n        _effectiveDGDBalance =\n            _baseDGDBalance\n            .mul(_quarterPointScalingFactor.add(_quarterPoint).sub(_minimalParticipationPoint))\n            .mul(_reputationPointScalingFactor.add(_reputationPoint))\n            .div(_quarterPointScalingFactor.mul(_reputationPointScalingFactor));\n    }\n\n\n    function calculateDemurrage(uint256 _balance, uint256 _daysElapsed)\n        public\n        view\n        returns (uint256 _demurrageFees)\n    {\n        (_demurrageFees,) = DgxDemurrageCalculator(dgxDemurrageCalculatorAddress).calculateDemurrage(_balance, _daysElapsed);\n    }\n\n}\n\n// File: contracts/common/DaoRewardsManagerCommon.sol\npragma solidity ^0.4.25;\n\ncontract DaoRewardsManagerCommon is DaoCommonMini {\n\n    using DaoStructs for DaoStructs.DaoQuarterInfo;\n\n    // this is a struct that store information relevant for calculating the user rewards\n    // for the last participating quarter\n    struct UserRewards {\n        uint256 lastParticipatedQuarter;\n        uint256 lastQuarterThatRewardsWasUpdated;\n        uint256 effectiveDGDBalance;\n        uint256 effectiveModeratorDGDBalance;\n        DaoStructs.DaoQuarterInfo qInfo;\n    }\n\n    // struct to store variables needed in the execution of calculateGlobalRewardsBeforeNewQuarter\n    struct QuarterRewardsInfo {\n        uint256 previousQuarter;\n        uint256 totalEffectiveDGDPreviousQuarter;\n        uint256 totalEffectiveModeratorDGDLastQuarter;\n        uint256 dgxRewardsPoolLastQuarter;\n        uint256 userCount;\n        uint256 i;\n        DaoStructs.DaoQuarterInfo qInfo;\n        address currentUser;\n        address[] users;\n        bool doneCalculatingEffectiveBalance;\n        bool doneCalculatingModeratorEffectiveBalance;\n    }\n\n    // get the struct for the relevant information for calculating a user's DGX rewards for the last participated quarter\n    function getUserRewardsStruct(address _user)\n        internal\n        view\n        returns (UserRewards memory _data)\n    {\n        _data.lastParticipatedQuarter = daoRewardsStorage().lastParticipatedQuarter(_user);\n        _data.lastQuarterThatRewardsWasUpdated = daoRewardsStorage().lastQuarterThatRewardsWasUpdated(_user);\n        _data.qInfo = readQuarterInfo(_data.lastParticipatedQuarter);\n    }\n\n    // read the DaoQuarterInfo struct of a certain quarter\n    function readQuarterInfo(uint256 _quarterNumber)\n        internal\n        view\n        returns (DaoStructs.DaoQuarterInfo _qInfo)\n    {\n        (\n            _qInfo.minimalParticipationPoint,\n            _qInfo.quarterPointScalingFactor,\n            _qInfo.reputationPointScalingFactor,\n            _qInfo.totalEffectiveDGDPreviousQuarter\n        ) = daoRewardsStorage().readQuarterParticipantInfo(_quarterNumber);\n        (\n            _qInfo.moderatorMinimalParticipationPoint,\n            _qInfo.moderatorQuarterPointScalingFactor,\n            _qInfo.moderatorReputationPointScalingFactor,\n            _qInfo.totalEffectiveModeratorDGDLastQuarter\n        ) = daoRewardsStorage().readQuarterModeratorInfo(_quarterNumber);\n        (\n            _qInfo.dgxDistributionDay,\n            _qInfo.dgxRewardsPoolLastQuarter,\n            _qInfo.sumRewardsFromBeginning\n        ) = daoRewardsStorage().readQuarterGeneralInfo(_quarterNumber);\n    }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\npragma solidity ^0.4.24;\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * See https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address _who) public view returns (uint256);\n  function transfer(address _to, uint256 _value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\npragma solidity ^0.4.24;\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address _owner, address _spender)\n    public view returns (uint256);\n\n  function transferFrom(address _from, address _to, uint256 _value)\n    public returns (bool);\n\n  function approve(address _spender, uint256 _value) public returns (bool);\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}\n\n// File: contracts/interactive/DaoRewardsManagerExtras.sol\npragma solidity ^0.4.25;\n\ncontract DaoRewardsManagerExtras is DaoRewardsManagerCommon {\n\n    constructor(address _resolver) public {\n        require(init(CONTRACT_DAO_REWARDS_MANAGER_EXTRAS, _resolver));\n    }\n\n    function daoCalculatorService()\n        internal\n        view\n        returns (DaoCalculatorService _contract)\n    {\n        _contract = DaoCalculatorService(get_contract(CONTRACT_SERVICE_DAO_CALCULATOR));\n    }\n\n    // done\n    // calculate dgx rewards; This is basically the DGXs that user has earned from participating in lastParticipatedQuarter, and can be withdrawn on the dgxDistributionDay of the (lastParticipatedQuarter + 1)\n    // when user actually withdraw some time after that, he will be deducted demurrage.\n    function calculateUserRewardsForLastParticipatingQuarter(address _user)\n        public\n        view\n        returns (uint256 _dgxRewardsAsParticipant, uint256 _dgxRewardsAsModerator)\n    {\n        UserRewards memory data = getUserRewardsStruct(_user);\n\n        data.effectiveDGDBalance = daoCalculatorService().calculateUserEffectiveBalance(\n            data.qInfo.minimalParticipationPoint,\n            data.qInfo.quarterPointScalingFactor,\n            data.qInfo.reputationPointScalingFactor,\n            daoPointsStorage().getQuarterPoint(_user, data.lastParticipatedQuarter),\n\n            // RP has been updated at the beginning of the lastParticipatedQuarter in\n            // a call to updateRewardsAndReputationBeforeNewQuarter(); It should not have changed since then\n            daoPointsStorage().getReputation(_user),\n\n            // lockedDGDStake should have stayed the same throughout since the lastParticipatedQuarter\n            // if this participant has done anything (lock/unlock/continue) to change the lockedDGDStake,\n            // updateUserRewardsForLastParticipatingQuarter, and hence this function, would have been called first before the lockedDGDStake is changed\n            daoStakeStorage().lockedDGDStake(_user)\n        );\n\n        data.effectiveModeratorDGDBalance = daoCalculatorService().calculateUserEffectiveBalance(\n            data.qInfo.moderatorMinimalParticipationPoint,\n            data.qInfo.moderatorQuarterPointScalingFactor,\n            data.qInfo.moderatorReputationPointScalingFactor,\n            daoPointsStorage().getQuarterModeratorPoint(_user, data.lastParticipatedQuarter),\n\n            // RP has been updated at the beginning of the lastParticipatedQuarter in\n            // a call to updateRewardsAndReputationBeforeNewQuarter();\n            daoPointsStorage().getReputation(_user),\n\n            // lockedDGDStake should have stayed the same throughout since the lastParticipatedQuarter\n            // if this participant has done anything (lock/unlock/continue) to change the lockedDGDStake,\n            // updateUserRewardsForLastParticipatingQuarter would have been called first before the lockedDGDStake is changed\n            daoStakeStorage().lockedDGDStake(_user)\n        );\n\n        // will not need to calculate if the totalEffectiveDGDLastQuarter is 0 (no one participated)\n        if (daoRewardsStorage().readTotalEffectiveDGDLastQuarter(data.lastParticipatedQuarter.add(1)) > 0) {\n            _dgxRewardsAsParticipant =\n                data.effectiveDGDBalance\n                .mul(daoRewardsStorage().readRewardsPoolOfLastQuarter(\n                    data.lastParticipatedQuarter.add(1)\n                ))\n                .mul(\n                    getUintConfig(CONFIG_PORTION_TO_MODERATORS_DEN)\n                    .sub(getUintConfig(CONFIG_PORTION_TO_MODERATORS_NUM))\n                )\n                .div(daoRewardsStorage().readTotalEffectiveDGDLastQuarter(\n                    data.lastParticipatedQuarter.add(1)\n                ))\n                .div(getUintConfig(CONFIG_PORTION_TO_MODERATORS_DEN));\n        }\n\n        // will not need to calculate if the totalEffectiveModeratorDGDLastQuarter is 0 (no one participated)\n        if (daoRewardsStorage().readTotalEffectiveModeratorDGDLastQuarter(data.lastParticipatedQuarter.add(1)) > 0) {\n            _dgxRewardsAsModerator =\n                data.effectiveModeratorDGDBalance\n                .mul(daoRewardsStorage().readRewardsPoolOfLastQuarter(\n                    data.lastParticipatedQuarter.add(1)\n                ))\n                .mul(\n                     getUintConfig(CONFIG_PORTION_TO_MODERATORS_NUM)\n                )\n                .div(daoRewardsStorage().readTotalEffectiveModeratorDGDLastQuarter(\n                    data.lastParticipatedQuarter.add(1)\n                ))\n                .div(getUintConfig(CONFIG_PORTION_TO_MODERATORS_DEN));\n        }\n    }\n}\n\n// File: contracts/interactive/DaoRewardsManager.sol\npragma solidity ^0.4.25;\n\n/**\n@title Contract to manage DGX rewards\n@author Digix Holdings\n*/\ncontract DaoRewardsManager is DaoRewardsManagerCommon {\n    using MathHelper for MathHelper;\n    using DaoStructs for DaoStructs.DaoQuarterInfo;\n    using DaoStructs for DaoStructs.IntermediateResults;\n\n    // is emitted when calculateGlobalRewardsBeforeNewQuarter has been done in the beginning of the quarter\n    // after which, all the other DAO activities could happen\n    event StartNewQuarter(uint256 indexed _quarterNumber);\n\n    address public ADDRESS_DGX_TOKEN;\n\n    function daoCalculatorService()\n        internal\n        view\n        returns (DaoCalculatorService _contract)\n    {\n        _contract = DaoCalculatorService(get_contract(CONTRACT_SERVICE_DAO_CALCULATOR));\n    }\n\n    function daoRewardsManagerExtras()\n        internal\n        view\n        returns (DaoRewardsManagerExtras _contract)\n    {\n        _contract = DaoRewardsManagerExtras(get_contract(CONTRACT_DAO_REWARDS_MANAGER_EXTRAS));\n    }\n\n    /**\n    @notice Constructor (set the DaoQuarterInfo struct for the first quarter)\n    @param _resolver Address of the Contract Resolver contract\n    @param _dgxAddress Address of the Digix Gold Token contract\n    */\n    constructor(address _resolver, address _dgxAddress)\n        public\n    {\n        require(init(CONTRACT_DAO_REWARDS_MANAGER, _resolver));\n        ADDRESS_DGX_TOKEN = _dgxAddress;\n\n        // set the DaoQuarterInfo for the first quarter\n        daoRewardsStorage().updateQuarterInfo(\n            1,\n            getUintConfig(CONFIG_MINIMAL_QUARTER_POINT),\n            getUintConfig(CONFIG_QUARTER_POINT_SCALING_FACTOR),\n            getUintConfig(CONFIG_REPUTATION_POINT_SCALING_FACTOR),\n            0, // totalEffectiveDGDPreviousQuarter, Not Applicable, this value should not be used ever\n            getUintConfig(CONFIG_MODERATOR_MINIMAL_QUARTER_POINT),\n            getUintConfig(CONFIG_MODERATOR_QUARTER_POINT_SCALING_FACTOR),\n            getUintConfig(CONFIG_MODERATOR_REPUTATION_POINT_SCALING_FACTOR),\n            0, // _totalEffectiveModeratorDGDLastQuarter , Not applicable, this value should not be used ever\n\n            // _dgxDistributionDay, Not applicable, there shouldnt be any DGX rewards in the DAO now. The actual DGX fees that have been collected\n            // before the deployment of DigixDAO contracts would be counted as part of the DGX fees incurred in the first quarter\n            // this value should not be used ever\n            now,\n\n            0, // _dgxRewardsPoolLastQuarter, not applicable, this value should not be used ever\n            0 // sumRewardsFromBeginning, which is 0\n        );\n    }\n\n\n    /**\n    @notice Function to transfer the claimableDGXs to the new DaoRewardsManager\n    @dev This is done during the migrateToNewDao procedure\n    @param _newDaoRewardsManager Address of the new daoRewardsManager contract\n    */\n    function moveDGXsToNewDao(address _newDaoRewardsManager)\n        public\n    {\n        require(sender_is(CONTRACT_DAO));\n        uint256 _dgxBalance = ERC20(ADDRESS_DGX_TOKEN).balanceOf(address(this));\n        ERC20(ADDRESS_DGX_TOKEN).transfer(_newDaoRewardsManager, _dgxBalance);\n    }\n\n\n    /**\n    @notice Function for users to claim the claimable DGX rewards\n    @dev Will revert if _claimableDGX < MINIMUM_TRANSFER_AMOUNT of DGX.\n         Can only be called after calculateGlobalRewardsBeforeNewQuarter() has been called in the current quarter\n         This cannot be called once the current version of Dao contracts have been migrated to newer version\n    */\n    function claimRewards()\n        public\n        ifGlobalRewardsSet(currentQuarterNumber())\n    {\n        require(isDaoNotReplaced());\n\n        address _user = msg.sender;\n        uint256 _claimableDGX;\n\n        // update rewards for the quarter that he last participated in\n        (, _claimableDGX) = updateUserRewardsForLastParticipatingQuarter(_user);\n\n        // withdraw from his claimableDGXs\n        // This has to take into account demurrage\n        // Basically, the value of claimableDGXs in the contract is for the dgxDistributionDay of (lastParticipatedQuarter + 1)\n        // if now is after that, we need to deduct demurrage\n        uint256 _days_elapsed = now\n            .sub(\n                daoRewardsStorage().readDgxDistributionDay(\n                    daoRewardsStorage().lastQuarterThatRewardsWasUpdated(_user).add(1) // lastQuarterThatRewardsWasUpdated should be the same as lastParticipatedQuarter now\n                )\n            )\n            .div(1 days);\n\n         // similar logic as in the similar step in updateUserRewardsForLastParticipatingQuarter.\n         // it is as if the user has withdrawn all _claimableDGX, and the demurrage is paid back into the DAO immediately\n        daoRewardsStorage().addToTotalDgxClaimed(_claimableDGX);\n\n        _claimableDGX = _claimableDGX.sub(\n            daoCalculatorService().calculateDemurrage(\n                _claimableDGX,\n                _days_elapsed\n            ));\n\n        daoRewardsStorage().updateClaimableDGX(_user, 0);\n        ERC20(ADDRESS_DGX_TOKEN).transfer(_user, _claimableDGX);\n        // the _demurrageFees is implicitly \"transfered\" back into the DAO, and would be counted in the dgxRewardsPool of this quarter (in other words, dgxRewardsPoolLastQuarter of next quarter)\n    }\n\n\n    /**\n    @notice Function to update DGX rewards of user. This is only called during locking/withdrawing DGDs, or continuing participation for new quarter\n    @param _user Address of the DAO participant\n    */\n    function updateRewardsAndReputationBeforeNewQuarter(address _user)\n        public\n    {\n        require(sender_is(CONTRACT_DAO_STAKE_LOCKING));\n\n        updateUserRewardsForLastParticipatingQuarter(_user);\n        updateUserReputationUntilPreviousQuarter(_user);\n    }\n\n\n    // This function would ALWAYS make sure that the user's Reputation Point is updated for ALL activities that has happened\n    // BEFORE this current quarter. These activities include:\n    //  - Reputation bonus/penalty due to participation in all of the previous quarters\n    //  - Reputation penalty for not participating for a few quarters, up until and including the previous quarter\n    //  - Badges redemption and carbon vote reputation redemption (that happens in the first time locking)\n    // As such, after this function is called on quarter N, the updated reputation point of the user would tentatively be used to calculate the rewards for quarter N\n    // Its tentative because the user can also redeem a badge during the period of quarter N to add to his reputation point.\n    function updateUserReputationUntilPreviousQuarter (address _user)\n        private\n    {\n        uint256 _lastParticipatedQuarter = daoRewardsStorage().lastParticipatedQuarter(_user);\n        uint256 _lastQuarterThatReputationWasUpdated = daoRewardsStorage().lastQuarterThatReputationWasUpdated(_user);\n        uint256 _reputationDeduction;\n\n        // If the reputation was already updated until the previous quarter\n        // nothing needs to be done\n        if (\n            _lastQuarterThatReputationWasUpdated.add(1) >= currentQuarterNumber()\n        ) {\n            return;\n        }\n\n        // first, we calculate and update the reputation change due to the user's governance activities in lastParticipatedQuarter, if it is not already updated.\n        // reputation is not updated for lastParticipatedQuarter yet is equivalent to _lastQuarterThatReputationWasUpdated == _lastParticipatedQuarter - 1\n        if (\n            (_lastQuarterThatReputationWasUpdated.add(1) == _lastParticipatedQuarter)\n        ) {\n            updateRPfromQP(\n                _user,\n                daoPointsStorage().getQuarterPoint(_user, _lastParticipatedQuarter),\n                getUintConfig(CONFIG_MINIMAL_QUARTER_POINT),\n                getUintConfig(CONFIG_MAXIMUM_REPUTATION_DEDUCTION),\n                getUintConfig(CONFIG_REPUTATION_PER_EXTRA_QP_NUM),\n                getUintConfig(CONFIG_REPUTATION_PER_EXTRA_QP_DEN)\n            );\n\n            // this user is not a Moderator for current quarter\n            // coz this step is done before updating the refreshModerator.\n            // But may have been a Moderator before, and if was moderator in their\n            // lastParticipatedQuarter, we will find them in the DoublyLinkedList.\n            if (daoStakeStorage().isInModeratorsList(_user)) {\n                updateRPfromQP(\n                    _user,\n                    daoPointsStorage().getQuarterModeratorPoint(_user, _lastParticipatedQuarter),\n                    getUintConfig(CONFIG_MODERATOR_MINIMAL_QUARTER_POINT),\n                    getUintConfig(CONFIG_MAXIMUM_MODERATOR_REPUTATION_DEDUCTION),\n                    getUintConfig(CONFIG_REPUTATION_PER_EXTRA_MODERATOR_QP_NUM),\n                    getUintConfig(CONFIG_REPUTATION_PER_EXTRA_MODERATOR_QP_DEN)\n                );\n            }\n            _lastQuarterThatReputationWasUpdated = _lastParticipatedQuarter;\n        }\n\n        // at this point, the _lastQuarterThatReputationWasUpdated MUST be at least the _lastParticipatedQuarter already\n        // Hence, any quarters between the _lastQuarterThatReputationWasUpdated and now must be a non-participating quarter,\n        // and this participant should be penalized for those.\n\n        // If this is their first ever participation, It is fine as well, as the reputation would be still be 0 after this step.\n        // note that the carbon vote's reputation bonus will be added after this, so its fine\n\n        _reputationDeduction =\n            (currentQuarterNumber().sub(1).sub(_lastQuarterThatReputationWasUpdated))\n            .mul(\n                getUintConfig(CONFIG_MAXIMUM_REPUTATION_DEDUCTION)\n                .add(getUintConfig(CONFIG_PUNISHMENT_FOR_NOT_LOCKING))\n            );\n\n        if (_reputationDeduction > 0) daoPointsStorage().reduceReputation(_user, _reputationDeduction);\n        daoRewardsStorage().updateLastQuarterThatReputationWasUpdated(_user, currentQuarterNumber().sub(1));\n    }\n\n\n    // update ReputationPoint of a participant based on QuarterPoint/ModeratorQuarterPoint in a quarter\n    function updateRPfromQP (\n        address _user,\n        uint256 _userQP,\n        uint256 _minimalQP,\n        uint256 _maxRPDeduction,\n        uint256 _rpPerExtraQP_num,\n        uint256 _rpPerExtraQP_den\n    ) internal {\n        uint256 _reputationDeduction;\n        uint256 _reputationAddition;\n        if (_userQP < _minimalQP) {\n            _reputationDeduction =\n                _minimalQP.sub(_userQP)\n                .mul(_maxRPDeduction)\n                .div(_minimalQP);\n\n            daoPointsStorage().reduceReputation(_user, _reputationDeduction);\n        } else {\n            _reputationAddition =\n                _userQP.sub(_minimalQP)\n                .mul(_rpPerExtraQP_num)\n                .div(_rpPerExtraQP_den);\n\n            daoPointsStorage().increaseReputation(_user, _reputationAddition);\n        }\n    }\n\n    // if the DGX rewards has not been calculated for the user's lastParticipatedQuarter, calculate and update it\n    function updateUserRewardsForLastParticipatingQuarter(address _user)\n        internal\n        returns (bool _valid, uint256 _userClaimableDgx)\n    {\n        UserRewards memory data = getUserRewardsStruct(_user);\n        _userClaimableDgx = daoRewardsStorage().claimableDGXs(_user);\n\n        // There is nothing to do if:\n        //   - The participant is already participating this quarter and hence this function has been called in this quarter\n        //   - We have updated the rewards to the lastParticipatedQuarter\n        // In ANY other cases: it means that the lastParticipatedQuarter is NOT this quarter, and its greater than lastQuarterThatRewardsWasUpdated, hence\n        // This also means that this participant has ALREADY PARTICIPATED at least once IN THE PAST, and we have not calculated for this quarter\n        // Thus, we need to calculate the Rewards for the lastParticipatedQuarter\n        if (\n            (currentQuarterNumber() == data.lastParticipatedQuarter) ||\n            (data.lastParticipatedQuarter <= data.lastQuarterThatRewardsWasUpdated)\n        ) {\n            return (false, _userClaimableDgx);\n        }\n\n        // now we will calculate the user rewards based on info of the data.lastParticipatedQuarter\n\n        // first we \"deduct the demurrage\" for the existing claimable DGXs for time period from\n        // dgxDistributionDay of (lastQuarterThatRewardsWasUpdated + 1) to dgxDistributionDay of (lastParticipatedQuarter + 1)\n        // (note that, when people participate in quarter n, the DGX rewards for quarter n is only released at the dgxDistributionDay of (n+1)th quarter)\n        uint256 _days_elapsed = daoRewardsStorage().readDgxDistributionDay(data.lastParticipatedQuarter.add(1))\n            .sub(daoRewardsStorage().readDgxDistributionDay(data.lastQuarterThatRewardsWasUpdated.add(1)))\n            .div(1 days);\n        uint256 _demurrageFees = daoCalculatorService().calculateDemurrage(\n            _userClaimableDgx,\n            _days_elapsed\n        );\n        _userClaimableDgx = _userClaimableDgx.sub(_demurrageFees);\n        // this demurrage fees will not be accurate to the hours, but we will leave it as this.\n\n        // this deducted demurrage is then added to the totalDGXsClaimed\n        // This is as if, the user claims exactly _demurrageFees DGXs, which would be used immediately to pay for the demurrage on his claimableDGXs,\n        // from dgxDistributionDay of (lastQuarterThatRewardsWasUpdated + 1) to dgxDistributionDay of (lastParticipatedQuarter + 1)\n        // This is done as such, so that this _demurrageFees would \"flow back into the DAO\" and be counted in the dgxRewardsPool of this current quarter (in other words, dgxRewardsPoolLastQuarter of the next quarter, as will be calculated in calculateGlobalRewardsBeforeNewQuarter of the next quarter)\n        // this is not 100% techinally correct as a demurrage concept, because this demurrage fees could have been incurred for the duration of the quarters in the past, but we will account them this way, as if its demurrage fees for this quarter, for simplicity.\n        daoRewardsStorage().addToTotalDgxClaimed(_demurrageFees);\n\n        uint256 _dgxRewardsAsParticipant;\n        uint256 _dgxRewardsAsModerator;\n        (_dgxRewardsAsParticipant, _dgxRewardsAsModerator) = daoRewardsManagerExtras().calculateUserRewardsForLastParticipatingQuarter(_user);\n        _userClaimableDgx = _userClaimableDgx.add(_dgxRewardsAsParticipant).add(_dgxRewardsAsModerator);\n\n        // update claimableDGXs. The calculation just now should have taken into account demurrage\n        // such that the demurrage has been paid until dgxDistributionDay of (lastParticipatedQuarter + 1)\n        daoRewardsStorage().updateClaimableDGX(_user, _userClaimableDgx);\n\n        // update lastQuarterThatRewardsWasUpdated\n        daoRewardsStorage().updateLastQuarterThatRewardsWasUpdated(_user, data.lastParticipatedQuarter);\n        _valid = true;\n    }\n\n    /**\n    @notice Function called by the founder after transfering the DGX fees into the DAO at the beginning of the quarter\n    @dev This function needs to do lots of calculation, so it might not fit into one transaction\n         As such, it could be done in multiple transactions, each time passing _operations which is the number of operations we want to calculate.\n         When the value of _done is finally true, that's when the calculation is done.\n         Only after this function runs, any other activities in the DAO could happen.\n\n         Basically, if there were M participants and N moderators in the previous quarter, it takes M+N \"operations\".\n\n         In summary, the function populates the DaoQuarterInfo of this quarter.\n         The bulk of the calculation is to go through every participant in the previous quarter to calculate their effectiveDGDBalance and sum them to get the\n         totalEffectiveDGDLastQuarter\n    */\n    function calculateGlobalRewardsBeforeNewQuarter(uint256 _operations)\n        public\n        if_founder()\n        returns (bool _done)\n    {\n        require(isDaoNotReplaced());\n        require(daoUpgradeStorage().startOfFirstQuarter() != 0); // start of first quarter must have been set already\n        require(isLockingPhase());\n        require(daoRewardsStorage().readDgxDistributionDay(currentQuarterNumber()) == 0); // throw if this function has already finished running this quarter\n\n        QuarterRewardsInfo memory info;\n        info.previousQuarter = currentQuarterNumber().sub(1);\n        require(info.previousQuarter > 0); // throw if this is the first quarter\n        info.qInfo = readQuarterInfo(info.previousQuarter);\n\n        DaoStructs.IntermediateResults memory interResults;\n        (\n            interResults.countedUntil,,,\n            info.totalEffectiveDGDPreviousQuarter\n        ) = intermediateResultsStorage().getIntermediateResults(\n            getIntermediateResultsIdForGlobalRewards(info.previousQuarter, false)\n        );\n\n        uint256 _operationsLeft = sumEffectiveBalance(info, false, _operations, interResults);\n        // now we are left with _operationsLeft operations\n        // the results is saved in interResults\n\n        // if we have not done with calculating the effective balance, quit.\n        if (!info.doneCalculatingEffectiveBalance) { return false; }\n\n        (\n            interResults.countedUntil,,,\n            info.totalEffectiveModeratorDGDLastQuarter\n        ) = intermediateResultsStorage().getIntermediateResults(\n            getIntermediateResultsIdForGlobalRewards(info.previousQuarter, true)\n        );\n\n        sumEffectiveBalance(info, true, _operationsLeft, interResults);\n\n        // if we have not done with calculating the moderator effective balance, quit.\n        if (!info.doneCalculatingModeratorEffectiveBalance) { return false; }\n\n        // we have done the heavey calculation, now save the quarter info\n        processGlobalRewardsUpdate(info);\n        _done = true;\n\n        emit StartNewQuarter(currentQuarterNumber());\n    }\n\n\n    // get the Id for the intermediateResult for a quarter's global rewards calculation\n    function getIntermediateResultsIdForGlobalRewards(uint256 _quarterNumber, bool _forModerator) internal view returns (bytes32 _id) {\n        _id = keccak256(abi.encodePacked(\n            _forModerator ? INTERMEDIATE_MODERATOR_DGD_IDENTIFIER : INTERMEDIATE_DGD_IDENTIFIER,\n            _quarterNumber\n        ));\n    }\n\n\n    // final step in calculateGlobalRewardsBeforeNewQuarter, which is to save the DaoQuarterInfo struct for this quarter\n    function processGlobalRewardsUpdate(QuarterRewardsInfo memory info) internal {\n        // calculate how much DGX rewards we got for this quarter\n        info.dgxRewardsPoolLastQuarter =\n            ERC20(ADDRESS_DGX_TOKEN).balanceOf(address(this))\n            .add(daoRewardsStorage().totalDGXsClaimed())\n            .sub(info.qInfo.sumRewardsFromBeginning);\n\n        // starting new quarter, no one locked in DGDs yet\n        daoStakeStorage().updateTotalLockedDGDStake(0);\n        daoStakeStorage().updateTotalModeratorLockedDGDs(0);\n\n        daoRewardsStorage().updateQuarterInfo(\n            info.previousQuarter.add(1),\n            getUintConfig(CONFIG_MINIMAL_QUARTER_POINT),\n            getUintConfig(CONFIG_QUARTER_POINT_SCALING_FACTOR),\n            getUintConfig(CONFIG_REPUTATION_POINT_SCALING_FACTOR),\n            info.totalEffectiveDGDPreviousQuarter,\n\n            getUintConfig(CONFIG_MODERATOR_MINIMAL_QUARTER_POINT),\n            getUintConfig(CONFIG_MODERATOR_QUARTER_POINT_SCALING_FACTOR),\n            getUintConfig(CONFIG_MODERATOR_REPUTATION_POINT_SCALING_FACTOR),\n            info.totalEffectiveModeratorDGDLastQuarter,\n\n            now,\n            info.dgxRewardsPoolLastQuarter,\n            info.qInfo.sumRewardsFromBeginning.add(info.dgxRewardsPoolLastQuarter)\n        );\n    }\n\n\n    // Sum the effective balance (could be effectiveDGDBalance or effectiveModeratorDGDBalance), given that we have _operations left\n    function sumEffectiveBalance (\n        QuarterRewardsInfo memory info,\n        bool _badgeCalculation, // false if this is the first step, true if its the second step\n        uint256 _operations,\n        DaoStructs.IntermediateResults memory _interResults\n    )\n        internal\n        returns (uint _operationsLeft)\n    {\n        if (_operations == 0) return _operations; // no more operations left, quit\n\n        if (_interResults.countedUntil == EMPTY_ADDRESS) {\n            // if this is the first time we are doing this calculation, we need to\n            // get the list of the participants to calculate by querying the first _operations participants\n            info.users = _badgeCalculation ?\n                daoListingService().listModerators(_operations, true)\n                : daoListingService().listParticipants(_operations, true);\n        } else {\n            info.users = _badgeCalculation ?\n                daoListingService().listModeratorsFrom(_interResults.countedUntil, _operations, true)\n                : daoListingService().listParticipantsFrom(_interResults.countedUntil, _operations, true);\n\n            // if this list is the already empty, it means this is the first step (calculating effective balance), and its already done;\n            if (info.users.length == 0) {\n                info.doneCalculatingEffectiveBalance = true;\n                return _operations;\n            }\n        }\n\n        address _lastAddress;\n        _lastAddress = info.users[info.users.length - 1];\n\n        info.userCount = info.users.length;\n        for (info.i=0;info.i<info.userCount;info.i++) {\n            info.currentUser = info.users[info.i];\n            // check if this participant really did participate in the previous quarter\n            if (daoRewardsStorage().lastParticipatedQuarter(info.currentUser) != info.previousQuarter) {\n                continue;\n            }\n            if (_badgeCalculation) {\n                info.totalEffectiveModeratorDGDLastQuarter = info.totalEffectiveModeratorDGDLastQuarter.add(daoCalculatorService().calculateUserEffectiveBalance(\n                    info.qInfo.moderatorMinimalParticipationPoint,\n                    info.qInfo.moderatorQuarterPointScalingFactor,\n                    info.qInfo.moderatorReputationPointScalingFactor,\n                    daoPointsStorage().getQuarterModeratorPoint(info.currentUser, info.previousQuarter),\n                    daoPointsStorage().getReputation(info.currentUser),\n                    daoStakeStorage().lockedDGDStake(info.currentUser)\n                ));\n            } else {\n                info.totalEffectiveDGDPreviousQuarter = info.totalEffectiveDGDPreviousQuarter.add(daoCalculatorService().calculateUserEffectiveBalance(\n                    info.qInfo.minimalParticipationPoint,\n                    info.qInfo.quarterPointScalingFactor,\n                    info.qInfo.reputationPointScalingFactor,\n                    daoPointsStorage().getQuarterPoint(info.currentUser, info.previousQuarter),\n                    daoPointsStorage().getReputation(info.currentUser),\n                    daoStakeStorage().lockedDGDStake(info.currentUser)\n                ));\n            }\n        }\n\n        // check if we have reached the last guy in the current list\n        if (_lastAddress == daoStakeStorage().readLastModerator() && _badgeCalculation) {\n            info.doneCalculatingModeratorEffectiveBalance = true;\n        }\n        if (_lastAddress == daoStakeStorage().readLastParticipant() && !_badgeCalculation) {\n            info.doneCalculatingEffectiveBalance = true;\n        }\n        // save to the intermediateResult storage\n        intermediateResultsStorage().setIntermediateResults(\n            getIntermediateResultsIdForGlobalRewards(info.previousQuarter, _badgeCalculation),\n            _lastAddress,\n            0,0,\n            _badgeCalculation ? info.totalEffectiveModeratorDGDLastQuarter : info.totalEffectiveDGDPreviousQuarter\n        );\n\n        _operationsLeft = _operations.sub(info.userCount);\n    }\n}\n\n// File: contracts/interface/NumberCarbonVoting.sol\npragma solidity ^0.4.25;\n\ncontract NumberCarbonVoting {\n    function voted(address _voter) public view returns (bool);\n}\n\n// File: contracts/interactive/DaoStakeLocking.sol\npragma solidity ^0.4.25;\n\n/**\n@title Contract to handle staking/withdrawing of DGDs for participation in DAO\n@author Digix Holdings\n*/\ncontract DaoStakeLocking is DaoCommon {\n\n    event RedeemBadge(address indexed _user);\n    event LockDGD(address indexed _user, uint256 _amount, uint256 _currentLockedDGDStake);\n    event WithdrawDGD(address indexed _user, uint256 _amount, uint256 _currentLockedDGDStake);\n\n    address public dgdToken;\n    address public dgdBadgeToken;\n\n    // carbonVoting1 refers to this carbon vote: https://digix.global/carbonvote/1/#/\n    // the contract is at: https://etherscan.io/address/0x9f56f330bceb9d4e756be94581298673e94ed592#code\n    address public carbonVoting1;\n\n    // carbonVoting2 refers to this carbon vote: https://digix.global/carbonvote/2/#/\n    // the contract is at: https://etherscan.io/address/0xdec6c0dc7004ba23940c9ee7cb4a0528ec4c0580#code\n    address public carbonVoting2;\n\n    // The two carbon votes implement the NumberCarbonVoting interface, which has a voted(address) function to find out\n    // whether an address has voted in the carbon vote.\n    // Addresses will be awarded a fixed amount of Reputation Point (CONFIG_CARBON_VOTE_REPUTATION_BONUS) for every carbon votes that they participated in\n\n    struct StakeInformation {\n        // this is the amount of DGDs that a user has actualy locked up\n        uint256 userActualLockedDGD;\n\n        // this is the DGDStake that the user get from locking up their DGDs.\n        // this amount might be smaller than the userActualLockedDGD, because the user has locked some DGDs in the middle of the quarter\n        // and those DGDs will not fetch as much DGDStake\n        uint256 userLockedDGDStake;\n\n        // this is the sum of everyone's DGD Stake\n        uint256 totalLockedDGDStake;\n    }\n\n\n    constructor(\n        address _resolver,\n        address _dgdToken,\n        address _dgdBadgeToken,\n        address _carbonVoting1,\n        address _carbonVoting2\n    ) public {\n        require(init(CONTRACT_DAO_STAKE_LOCKING, _resolver));\n        dgdToken = _dgdToken;\n        dgdBadgeToken = _dgdBadgeToken;\n        carbonVoting1 = _carbonVoting1;\n        carbonVoting2 = _carbonVoting2;\n    }\n\n    function daoCalculatorService()\n        internal\n        view\n        returns (DaoCalculatorService _contract)\n    {\n        _contract = DaoCalculatorService(get_contract(CONTRACT_SERVICE_DAO_CALCULATOR));\n    }\n\n    function daoRewardsManager()\n        internal\n        view\n        returns (DaoRewardsManager _contract)\n    {\n        _contract = DaoRewardsManager(get_contract(CONTRACT_DAO_REWARDS_MANAGER));\n    }\n\n\n    /**\n    @notice Function to convert a DGD Badge to Reputation Points\n    @dev The Badge holder can redeem the Badge anytime in the first quarter, or\n         Otherwise, the participant must either lock/withdraw/continue in the current quarter first, before he can redeem a badge\n         Only 1 DGD Badge is accepted from an address, so holders with multiple badges\n         should either sell their other badges or redeem reputation to another address\n    */\n    function redeemBadge()\n        public\n    {\n        // should not have redeemed a badge\n        require(!daoStakeStorage().redeemedBadge(msg.sender));\n\n        // Can only redeem a badge if the reputation has been updated to the previous quarter.\n        // In other words, this holder must have called either lockDGD/withdrawDGD/confirmContinuedParticipation in this quarter (hence, rewards for last quarter was already calculated)\n        // This is to prevent users from changing the Reputation point that would be used to calculate their rewards for the previous quarter.\n\n        // Note that after lockDGD/withdrawDGD/confirmContinuedParticipation is called, the reputation is always updated to the previous quarter\n        require(\n            daoRewardsStorage().lastQuarterThatReputationWasUpdated(msg.sender) == (currentQuarterNumber() - 1)\n        );\n\n        daoStakeStorage().redeemBadge(msg.sender);\n        daoPointsStorage().increaseReputation(msg.sender, getUintConfig(CONFIG_REPUTATION_POINT_BOOST_FOR_BADGE));\n\n        // update moderator status\n        StakeInformation memory _info = getStakeInformation(msg.sender);\n        refreshModeratorStatus(msg.sender, _info, _info);\n\n        // transfer the badge to this contract\n        require(ERC20(dgdBadgeToken).transferFrom(msg.sender, address(this), 1));\n\n        emit RedeemBadge(msg.sender);\n    }\n\n    function lockDGD(uint256 _amount) public {\n        require(_amount > 0);\n        lockDGDInternal(_amount);\n    }\n\n\n    /**\n    @notice Function to lock DGD tokens to participate in the DAO\n    @dev Users must `approve` the DaoStakeLocking contract to transfer DGDs from them\n         Contracts are not allowed to participate in DigixDAO\n    @param _amount Amount of DGDs to lock\n    */\n    function lockDGDInternal(uint256 _amount)\n        internal\n        ifGlobalRewardsSet(currentQuarterNumber())\n    {\n        // msg.sender must be an EOA. Disallows any contract from participating in the DAO.\n        require(msg.sender == tx.origin);\n\n        StakeInformation memory _info = getStakeInformation(msg.sender);\n        StakeInformation memory _newInfo = refreshDGDStake(msg.sender, _info);\n\n        uint256 _additionalStake = 0;\n        if (_amount > 0) _additionalStake = daoCalculatorService().calculateAdditionalLockedDGDStake(_amount);\n\n        _newInfo.userActualLockedDGD = _newInfo.userActualLockedDGD.add(_amount);\n        _newInfo.userLockedDGDStake = _newInfo.userLockedDGDStake.add(_additionalStake);\n        _newInfo.totalLockedDGDStake = _newInfo.totalLockedDGDStake.add(_additionalStake);\n\n        // This has to happen at least once before user can participate in next quarter\n        daoRewardsManager().updateRewardsAndReputationBeforeNewQuarter(msg.sender);\n\n        daoStakeStorage().updateUserDGDStake(msg.sender, _newInfo.userActualLockedDGD, _newInfo.userLockedDGDStake);\n\n\n        //since Reputation is updated, we need to refresh moderator status\n        refreshModeratorStatus(msg.sender, _info, _newInfo);\n\n        uint256 _lastParticipatedQuarter = daoRewardsStorage().lastParticipatedQuarter(msg.sender);\n        uint256 _currentQuarter = currentQuarterNumber();\n\n        // Note: there might be a case when user locked in very small amount A that is less than Minimum locked DGD\n        // then, lock again in the middle of the quarter. This will not take into account that A was staked in earlier. Its as if A is only staked in now.\n        // Its not ideal, but we will keep it this way.\n        if (_newInfo.userLockedDGDStake >= getUintConfig(CONFIG_MINIMUM_LOCKED_DGD)) {\n            daoStakeStorage().addToParticipantList(msg.sender); // this will not add a second duplicate of the address if its already there\n\n            // if this is the first time we lock/unlock/continue in this quarter, save the previous lastParticipatedQuarter\n            // the purpose of the previousLastParticipatedQuarter is so that, if this participant withdraw all his DGD after locking in,\n            // we will revert his lastParticipatedQuarter to the previousLastParticipatedQuarter, so as to not screw up any calculation\n            // that uses the lastParticipatedQuarter (for example, for calculating the Reputation penalty for not participating in a number of quarters)\n            if (_lastParticipatedQuarter < _currentQuarter) {\n                daoRewardsStorage().updatePreviousLastParticipatedQuarter(msg.sender, _lastParticipatedQuarter);\n                daoRewardsStorage().updateLastParticipatedQuarter(msg.sender, _currentQuarter);\n            }\n\n            // if this is the first time they're locking tokens, ever,\n            // reward them with bonus for carbon voting activity\n            if (_lastParticipatedQuarter == 0) {\n                rewardCarbonVotingBonus(msg.sender);\n            }\n        } else { // this participant doesnt have enough DGD to be a participant\n            // Absolute: The lastParticipatedQuarter of this participant WILL NEVER be the current quarter\n            // Otherwise, his lockedDGDStake must be above the CONFIG_MINIMUM_LOCKED_DGDd\n\n            // Hence, the refreshDGDStake() function must have added _newInfo.userLockedDGDStake to _newInfo.totalLockedDGDStake\n\n            // Since this participant is not counted as a participant, we need to deduct _newInfo.userLockedDGDStake from _newInfo.totalLockedDGDStake\n            _newInfo.totalLockedDGDStake = _newInfo.totalLockedDGDStake.sub(_newInfo.userLockedDGDStake);\n            daoStakeStorage().removeFromParticipantList(msg.sender);\n        }\n\n        daoStakeStorage().updateTotalLockedDGDStake(_newInfo.totalLockedDGDStake);\n\n        // interaction happens last\n        require(ERC20(dgdToken).transferFrom(msg.sender, address(this), _amount));\n        emit LockDGD(msg.sender, _amount, _newInfo.userLockedDGDStake);\n    }\n\n\n    /**\n    @notice Function to withdraw DGD tokens from this contract (can only be withdrawn in the locking phase of quarter)\n    @param _amount Number of DGD tokens to withdraw\n    @return {\n      \"_success\": \"Boolean, true if the withdrawal was successful, revert otherwise\"\n    }\n    */\n    function withdrawDGD(uint256 _amount)\n        public\n        ifGlobalRewardsSet(currentQuarterNumber())\n    {\n        require(isLockingPhase() || daoUpgradeStorage().isReplacedByNewDao()); // If the DAO is already replaced, everyone is free to withdraw their DGDs anytime\n        StakeInformation memory _info = getStakeInformation(msg.sender);\n        StakeInformation memory _newInfo = refreshDGDStake(msg.sender, _info);\n\n        // This address must have at least some DGDs locked in, to withdraw\n        // Otherwise, its meaningless anw\n        // This also makes sure that the first participation ever must be a lockDGD() call, to avoid unnecessary complications\n        require(_info.userActualLockedDGD > 0);\n\n        require(_info.userActualLockedDGD >= _amount);\n        _newInfo.userActualLockedDGD = _newInfo.userActualLockedDGD.sub(_amount);\n        _newInfo.userLockedDGDStake = _newInfo.userLockedDGDStake.sub(_amount);\n        _newInfo.totalLockedDGDStake = _newInfo.totalLockedDGDStake.sub(_amount);\n\n        //_newInfo.totalLockedDGDStake = _newInfo.totalLockedDGDStake.sub(_amount);\n\n        // This has to happen at least once before user can participate in next quarter\n        daoRewardsManager().updateRewardsAndReputationBeforeNewQuarter(msg.sender);\n\n        //since Reputation is updated, we need to refresh moderator status\n        refreshModeratorStatus(msg.sender, _info, _newInfo);\n\n        uint256 _lastParticipatedQuarter = daoRewardsStorage().lastParticipatedQuarter(msg.sender);\n        uint256 _currentQuarter = currentQuarterNumber();\n\n        if (_newInfo.userLockedDGDStake < getUintConfig(CONFIG_MINIMUM_LOCKED_DGD)) { // this participant doesnt have enough DGD to be a participant\n            // if this participant has lock/unlock/continue in this quarter before, we need to revert the lastParticipatedQuarter to the previousLastParticipatedQuarter\n            if (_lastParticipatedQuarter == _currentQuarter) {\n                daoRewardsStorage().updateLastParticipatedQuarter(msg.sender, daoRewardsStorage().previousLastParticipatedQuarter(msg.sender));\n            }\n\n            // if this participant is not counted as a participant, the totalLockedDGDStake should not take into account the userLockedDGDStake at all\n            _newInfo.totalLockedDGDStake = _newInfo.totalLockedDGDStake.sub(_newInfo.userLockedDGDStake);\n\n            daoStakeStorage().removeFromParticipantList(msg.sender);\n        } else { // This participant still remains as a participant\n            // if this is the first time we lock/unlock/continue in this quarter, save the previous lastParticipatedQuarter\n            if (_lastParticipatedQuarter < _currentQuarter) {\n                daoRewardsStorage().updatePreviousLastParticipatedQuarter(msg.sender, _lastParticipatedQuarter);\n                daoRewardsStorage().updateLastParticipatedQuarter(msg.sender, _currentQuarter);\n\n            }\n            // the totalLockedDGDStake after refreshDGDStake() should decrease by _amount, since this guy withdraws _amount\n        }\n\n        daoStakeStorage().updateUserDGDStake(msg.sender, _newInfo.userActualLockedDGD, _newInfo.userLockedDGDStake);\n        daoStakeStorage().updateTotalLockedDGDStake(_newInfo.totalLockedDGDStake);\n\n        require(ERC20(dgdToken).transfer(msg.sender, _amount));\n\n        emit WithdrawDGD(msg.sender, _amount, _newInfo.userLockedDGDStake);\n    }\n\n\n    /**\n    @notice Function to be called by someone who doesnt change their DGDStake for the next quarter to confirm that they're participating\n    @dev This can be done in the middle of the quarter as well.\n         If someone just lets their DGDs sit in the DAO, and don't call this function, they are not counted as a participant in the quarter.\n    */\n    function confirmContinuedParticipation()\n        public\n    {\n        lockDGDInternal(0);\n    }\n\n\n    /**\n    @notice This function refreshes the DGD stake of a user before doing any staking action(locking/withdrawing/continuing) in a new quarter\n    @dev We need to do this because sometimes, the user locked DGDs in the middle of the previous quarter. Hence, his DGDStake in the record now\n         is not correct. Note that this function might be called in the middle of the current quarter as well.\n\n        This has no effect if the user has already done some staking action in the current quarter\n         _infoBefore has the user's current stake information\n         _infoAfter will be the user's stake information after refreshing\n\n         This function updates the totalLockedDGDStake as if, the _user is participating in this quarter\n         Therefore, if the _user actually will not qualify as a participant, the caller of this function needs to deduct\n         _infoAfter.userLockedDGDStake from _infoAfter.totalLockedDGDStake\n    */\n    function refreshDGDStake(address _user, StakeInformation _infoBefore)\n        internal\n        view\n        returns (StakeInformation memory _infoAfter)\n    {\n        _infoAfter.userLockedDGDStake = _infoBefore.userLockedDGDStake;\n        _infoAfter.userActualLockedDGD = _infoBefore.userActualLockedDGD;\n        _infoAfter.totalLockedDGDStake = _infoBefore.totalLockedDGDStake;\n\n        // only need to refresh if this is the first refresh in this new quarter;\n        uint256 _currentQuarter = currentQuarterNumber();\n        if (daoRewardsStorage().lastParticipatedQuarter(_user) < _currentQuarter) {\n            _infoAfter.userLockedDGDStake = daoCalculatorService().calculateAdditionalLockedDGDStake(_infoBefore.userActualLockedDGD);\n\n            _infoAfter.totalLockedDGDStake = _infoAfter.totalLockedDGDStake.add(\n                _infoAfter.userLockedDGDStake\n            );\n        }\n    }\n\n\n    /**\n    @notice This function refreshes the Moderator status of a user, to be done right after ANY STEP where a user's reputation or DGDStake is changed\n    @dev _infoBefore is the stake information of the user before this transaction, _infoAfter is the stake information after this transaction\n         This function needs to:\n            - add/remove addresses from the moderator list accordingly\n            - adjust the totalModeratorLockedDGDStake accordingly as well\n    */\n    function refreshModeratorStatus(address _user, StakeInformation _infoBefore, StakeInformation _infoAfter)\n        internal\n    {\n        bool _alreadyParticipatedInThisQuarter = daoRewardsStorage().lastParticipatedQuarter(_user) == currentQuarterNumber();\n        uint256 _currentTotalModeratorLockedDGDs = daoStakeStorage().totalModeratorLockedDGDStake();\n\n        if (daoStakeStorage().isInModeratorsList(_user) == true) {\n            // this participant was already in the moderator list\n\n            if (_infoAfter.userLockedDGDStake < getUintConfig(CONFIG_MINIMUM_DGD_FOR_MODERATOR) ||\n                daoPointsStorage().getReputation(_user) < getUintConfig(CONFIG_MINIMUM_REPUTATION_FOR_MODERATOR)) {\n                // this participant is no longer a moderator this quarter, should be removed\n\n                // Throw if this is the last moderator. There must be at least one moderator in the moderator list. Otherwise calculateGlobalRewardsBeforeNewQuarter() will fail.\n                // after replacing DAO, we will want all moderators to withdraw their DGDs, hence the check\n                require(\n                    (daoStakeStorage().readTotalModerators() > 1) ||\n                    (!isDaoNotReplaced())\n                );\n\n                daoStakeStorage().removeFromModeratorList(_user);\n\n                // only need to deduct the dgdStake from the totalModeratorLockedDGDStake if this participant has participated in this quarter before this transaction\n                if (_alreadyParticipatedInThisQuarter) {\n                    daoStakeStorage().updateTotalModeratorLockedDGDs(\n                        _currentTotalModeratorLockedDGDs.sub(_infoBefore.userLockedDGDStake)\n                    );\n                }\n\n            } else { // this moderator was in the moderator list and still remains a moderator now\n                if (_alreadyParticipatedInThisQuarter) { // if already participated in this quarter, just account for the difference in dgdStake\n                    daoStakeStorage().updateTotalModeratorLockedDGDs(\n                        _currentTotalModeratorLockedDGDs.sub(_infoBefore.userLockedDGDStake).add(_infoAfter.userLockedDGDStake)\n                    );\n                } else { // has not participated in this quarter before this transaction\n                    daoStakeStorage().updateTotalModeratorLockedDGDs(\n                        _currentTotalModeratorLockedDGDs.add(_infoAfter.userLockedDGDStake)\n                    );\n                }\n            }\n        } else { // was not in moderator list\n            if (_infoAfter.userLockedDGDStake >= getUintConfig(CONFIG_MINIMUM_DGD_FOR_MODERATOR) &&\n                daoPointsStorage().getReputation(_user) >= getUintConfig(CONFIG_MINIMUM_REPUTATION_FOR_MODERATOR)) {\n\n                daoStakeStorage().addToModeratorList(_user);\n                daoStakeStorage().updateTotalModeratorLockedDGDs(\n                    _currentTotalModeratorLockedDGDs.add(_infoAfter.userLockedDGDStake)\n                );\n            }\n        }\n    }\n\n\n    /**\n    @notice Get the actualLockedDGD and lockedDGDStake of a user, as well as the totalLockedDGDStake of all users\n    */\n    function getStakeInformation(address _user)\n        internal\n        view\n        returns (StakeInformation _info)\n    {\n        (_info.userActualLockedDGD, _info.userLockedDGDStake) = daoStakeStorage().readUserDGDStake(_user);\n        _info.totalLockedDGDStake = daoStakeStorage().totalLockedDGDStake();\n    }\n\n\n    /**\n    @notice Reward the voters of carbon voting rounds with initial bonus reputation\n    @dev This is only called when they're locking tokens for the first time, enough tokens to be a participant\n    */\n    function rewardCarbonVotingBonus(address _user)\n        internal\n    {\n        // if the bonus has already been given out once to this user, return\n        if (daoStakeStorage().carbonVoteBonusClaimed(_user)) return;\n\n        // for carbon voting 1, if voted, give out a bonus\n        if (NumberCarbonVoting(carbonVoting1).voted(_user)) {\n            daoPointsStorage().increaseReputation(_user, getUintConfig(CONFIG_CARBON_VOTE_REPUTATION_BONUS));\n        }\n        // for carbon voting 2, if voted, give out a bonus\n        if (NumberCarbonVoting(carbonVoting2).voted(_user)) {\n            daoPointsStorage().increaseReputation(_user, getUintConfig(CONFIG_CARBON_VOTE_REPUTATION_BONUS));\n        }\n\n        // we changed reputation, so we need to update the last quarter that reputation was updated\n        // This is to take care of this situation:\n        // Holder A locks DGD for the first time in quarter 5, gets some bonus RP for the carbon votes\n        // Then, A withdraw all his DGDs right away. Essentially, he's not participating in quarter 5 anymore\n        // Now, when he comes back at quarter 10, he should be deducted reputation for 5 quarters that he didnt participated in: from quarter 5 to quarter 9\n        daoRewardsStorage().updateLastQuarterThatReputationWasUpdated(msg.sender, currentQuarterNumber().sub(1));\n\n        // set that this user's carbon voting bonus has been given out\n        daoStakeStorage().setCarbonVoteBonusClaimed(_user);\n    }\n}",
  "abi": "[{\"constant\":true,\"inputs\":[],\"name\":\"resolver\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"lockDGD\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dgdBadgeToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_configKey\",\"type\":\"bytes32\"}],\"name\":\"getAddressConfig\",\"outputs\":[{\"name\":\"_configValue\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"key\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"get_contract\",\"outputs\":[{\"name\":\"_contract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentTimeInQuarter\",\"outputs\":[{\"name\":\"_currentT\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isMainPhase\",\"outputs\":[{\"name\":\"_isMainPhase\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"confirmContinuedParticipation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isLockingPhase\",\"outputs\":[{\"name\":\"_isLockingPhase\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentQuarterNumber\",\"outputs\":[{\"name\":\"_quarterNumber\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"isParticipant\",\"outputs\":[{\"name\":\"_is\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_configKey\",\"type\":\"bytes32\"}],\"name\":\"getBytesConfig\",\"outputs\":[{\"name\":\"_configValue\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawDGD\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"carbonVoting1\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_configKey\",\"type\":\"bytes32\"}],\"name\":\"getUintConfig\",\"outputs\":[{\"name\":\"_configValue\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dgdToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isDaoNotReplaced\",\"outputs\":[{\"name\":\"_isNotReplaced\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"redeemBadge\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"isModerator\",\"outputs\":[{\"name\":\"_is\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"carbonVoting2\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_resolver\",\"type\":\"address\"},{\"name\":\"_dgdToken\",\"type\":\"address\"},{\"name\":\"_dgdBadgeToken\",\"type\":\"address\"},{\"name\":\"_carbonVoting1\",\"type\":\"address\"},{\"name\":\"_carbonVoting2\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"RedeemBadge\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_currentLockedDGDStake\",\"type\":\"uint256\"}],\"name\":\"LockDGD\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_currentLockedDGDStake\",\"type\":\"uint256\"}],\"name\":\"WithdrawDGD\",\"type\":\"event\"}]",
  "bytecode": "608060405260006001026003906000191690556000600460006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055507f70726f706f73616c5f73746174655f70726570726f706f73616c0000000000006005906000191690557f70726f706f73616c5f73746174655f64726166740000000000000000000000006006906000191690557f70726f706f73616c5f73746174655f6d6f6465726174656400000000000000006007906000191690557f70726f706f73616c5f73746174655f6f6e676f696e67000000000000000000006008906000191690557f70726f706f73616c5f73746174655f636c6f73656400000000000000000000006009906000191690557f70726f706f73616c5f73746174655f6172636869766564000000000000000000600a906000191690556001600b556002600c556003600d556001600e556002600f5560036010557f696e7465725f6467645f696400000000000000000000000000000000000000006011906000191690557f696e7465725f6d6f645f6467645f6964000000000000000000000000000000006012906000191690557f696e7465725f626f6e75735f63616c63756c6174696f6e5f69640000000000006013906000191690557f64616f00000000000000000000000000000000000000000000000000000000006014906000191690557f64616f3a7370656369616c3a70726f706f73616c0000000000000000000000006015906000191690557f64616f3a7374616b652d6c6f636b696e670000000000000000000000000000006016906000191690557f64616f3a766f74696e67000000000000000000000000000000000000000000006017906000191690557f64616f3a766f74696e673a636c61696d730000000000000000000000000000006018906000191690557f64616f3a73766f74696e673a636c61696d7300000000000000000000000000006019906000191690557f64616f3a6964656e746974790000000000000000000000000000000000000000601a906000191690557f64616f3a726577617264732d6d616e6167657200000000000000000000000000601b906000191690557f64616f3a726577617264732d6578747261730000000000000000000000000000601c906000191690557f64616f3a726f6c65730000000000000000000000000000000000000000000000601d906000191690557f64616f3a66756e64696e672d6d616e6167657200000000000000000000000000601e906000191690557f64616f3a77686974656c697374696e6700000000000000000000000000000000601f906000191690557f64616f3a696e666f726d6174696f6e00000000000000000000000000000000006020906000191690557f736572766963653a726f6c6500000000000000000000000000000000000000006021906000191690557f736572766963653a64616f3a696e666f000000000000000000000000000000006022906000191690557f736572766963653a64616f3a6c697374696e67000000000000000000000000006023906000191690557f736572766963653a64616f3a63616c63756c61746f72000000000000000000006024906000191690557f73746f726167653a64616f0000000000000000000000000000000000000000006025906000191690557f73746f726167653a64616f3a636f756e746572000000000000000000000000006026906000191690557f73746f726167653a64616f3a75706772616465000000000000000000000000006027906000191690557f73746f726167653a64616f3a6964656e746974790000000000000000000000006028906000191690557f73746f726167653a64616f3a706f696e747300000000000000000000000000006029906000191690557f73746f726167653a64616f3a7370656369616c00000000000000000000000000602a906000191690557f73746f726167653a64616f3a636f6e6669670000000000000000000000000000602b906000191690557f73746f726167653a64616f3a7374616b65000000000000000000000000000000602c906000191690557f73746f726167653a64616f3a7265776172647300000000000000000000000000602d906000191690557f73746f726167653a64616f3a77686974656c697374696e670000000000000000602e906000191690557f73746f726167653a696e7465726d6564696174653a726573756c747300000000602f906000191690557f743a6467640000000000000000000000000000000000000000000000000000006030906000191690557f743a6467780000000000000000000000000000000000000000000000000000006031906000191690557f743a6261646765000000000000000000000000000000000000000000000000006032906000191690556001603360006101000a81548160ff021916908360ff1602179055506002603360016101000a81548160ff021916908360ff1602179055506003603360026101000a81548160ff021916908360ff1602179055506004603360036101000a81548160ff021916908360ff1602179055506276a7006034557f6d696e5f6467645f7061727469636970616e74000000000000000000000000006035906000191690557f6d696e5f6467645f6d6f64657261746f720000000000000000000000000000006036906000191690557f6d696e5f72657075746174696f6e5f6d6f64657261746f7200000000000000006037906000191690557f6c6f636b696e675f70686173655f6475726174696f6e000000000000000000006038906000191690557f717561727465725f6475726174696f6e000000000000000000000000000000006039906000191690557f766f74696e675f636f6d6d69745f706861736500000000000000000000000000603a906000191690557f766f74696e675f70686173655f746f74616c0000000000000000000000000000603b906000191690557f696e746572696d5f766f74696e675f636f6d6d69745f70686173650000000000603c906000191690557f696e746572696d5f766f74696e675f70686173655f746f74616c000000000000603d906000191690557f64726166745f71756f72756d5f66697865645f6e756d657261746f7200000000603e906000191690557f64726166745f71756f72756d5f66697865645f64656e6f6d696e61746f720000603f906000191690557f64726166745f71756f72756d5f73666163746f725f6e756d657261746f7200006040906000191690557f64726166745f71756f72756d5f73666163746f725f64656e6f6d696e61746f726041906000191690557f766f74655f71756f72756d5f66697865645f6e756d657261746f7200000000006042906000191690557f766f74655f71756f72756d5f66697865645f64656e6f6d696e61746f720000006043906000191690557f766f74655f71756f72756d5f73666163746f725f6e756d657261746f720000006044906000191690557f766f74655f71756f72756d5f73666163746f725f64656e6f6d696e61746f72006045906000191690557f66696e616c5f7265776172645f73666163746f725f6e756d657261746f7200006046906000191690557f66696e616c5f7265776172645f73666163746f725f64656e6f6d696e61746f726047906000191690557f64726166745f71756f74615f6e756d657261746f7200000000000000000000006048906000191690557f64726166745f71756f74615f64656e6f6d696e61746f720000000000000000006049906000191690557f766f74696e675f71756f74615f6e756d657261746f7200000000000000000000604a906000191690557f766f74696e675f71756f74615f64656e6f6d696e61746f720000000000000000604b906000191690557f6d696e696d616c5f717000000000000000000000000000000000000000000000604c906000191690557f717561727465725f706f696e745f7363616c696e675f666163746f7200000000604d906000191690557f7265705f706f696e745f7363616c696e675f666163746f720000000000000000604e906000191690557f6d696e696d616c5f6d6f645f7170000000000000000000000000000000000000604f906000191690557f6d6f645f71705f7363616c696e675f666163746f7200000000000000000000006050906000191690557f6d6f645f7265705f706f696e745f7363616c696e675f666163746f72000000006051906000191690557f717561727465725f706f696e745f64726166745f766f746500000000000000006052906000191690557f717561727465725f706f696e745f766f746500000000000000000000000000006053906000191690557f717561727465725f706f696e745f696e746572696d5f766f74650000000000006054906000191690557f715f705f6d696c6573746f6e655f636f6d706c6574696f6e00000000000000006055906000191690557f626f6e75735f72657075746174696f6e5f6e756d657261746f720000000000006056906000191690557f626f6e75735f72657075746174696f6e5f64656e6f6d696e61746f72000000006057906000191690557f7370656369616c5f70726f706f73616c5f636f6d6d69745f70686173650000006058906000191690557f7370656369616c5f70726f706f73616c5f70686173655f746f74616c000000006059906000191690557f636f6e6669675f7370656369616c5f71756f74615f6e756d657261746f720000605a906000191690557f636f6e6669675f7370656369616c5f71756f74615f64656e6f6d696e61746f72605b906000191690557f7370656369616c5f71756f72756d5f6e756d657261746f720000000000000000605c906000191690557f7370656369616c5f71756f72756d5f64656e6f6d696e61746f72000000000000605d906000191690557f636f6e6669675f6d61785f72657075746174696f6e5f646564756374696f6e00605e906000191690557f636f6e6669675f70756e6973686d656e745f6e6f745f6c6f636b696e67000000605f906000191690557f636f6e6669675f7265705f7065725f65787472615f71705f6e756d00000000006060906000191690557f636f6e6669675f7265705f7065725f65787472615f71705f64656e00000000006061906000191690557f636f6e6669675f6d61785f6d5f72705f646564756374696f6e000000000000006062906000191690557f636f6e6669675f7265705f7065725f65787472615f6d5f71705f6e756d0000006063906000191690557f636f6e6669675f7265705f7065725f65787472615f6d5f71705f64656e0000006064906000191690557f636f6e6669675f6d6f645f706f7274696f6e5f6e756d000000000000000000006065906000191690557f636f6e6669675f6d6f645f706f7274696f6e5f64656e000000000000000000006066906000191690557f636f6e6669675f64726166745f766f74696e675f7068617365000000000000006067906000191690557f636f6e6669675f72705f626f6f73745f7065725f6261646765000000000000006068906000191690557f636f6e6669675f636c61696d696e675f646561646c696e6500000000000000006069906000191690557f636f6e6669675f70726570726f706f73616c5f636f6c6c61746572616c000000606a906000191690557f636f6e6669675f6d61785f66756e64696e675f6e6f6e44696769780000000000606b906000191690557f636f6e6669675f6d61785f6d696c6573746f6e65735f6e6f6e44696769780000606c906000191690557f636f6e6669675f6e6f6e44696769785f70726f706f73616c5f63617000000000606d906000191690557f636f6e6669675f646561645f6475726174696f6e000000000000000000000000606e906000191690557f636f6e6669675f63765f72657075746174696f6e000000000000000000000000606f906000191690553480156200113457600080fd5b5060405160a080620058ff83398101806040528101908080519060200190929190805190602001909291908051906020019092919080519060200190929190805190602001909291905050506200119d60165486620012b8640100000000026401000000009004565b1515620011a957600080fd5b83607060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555082607160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555081607260006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555080607360006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550505050505062001549565b6000808273ffffffffffffffffffffffffffffffffffffffff16636d19a8826040518163ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401602060405180830381600087803b1580156200132057600080fd5b505af115801562001335573d6000803e3d6000fd5b505050506040513d60208110156200134c57600080fd5b810190808051906020019092919050505090506000151581151514156200153d5730600260006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550826000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555083600181600019169055506000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663c0f6ef4a600154600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff166040518363ffffffff167c01000000000000000000000000000000000000000000000000000000000281526004018083600019166000191681526020018273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200192505050602060405180830381600087803b158015620014ea57600080fd5b505af1158015620014ff573d6000803e3d6000fd5b505050506040513d60208110156200151657600080fd5b810190808051906020019092919050505015156200153357600080fd5b6001915062001542565b600091505b5092915050565b6143a680620015596000396000f300608060405260043610610128576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806304f3bcec1461012d57806314efcd3c146101845780631b1e53ef146101b15780631d8ccd04146102085780633943380c146102795780633f83acff146102ac578063560a25ea1461031d578063685330601461034857806374cd7f6d146103775780637d6fed801461038e5780637f6a26b6146103bd578063929066f5146103e857806393ddad0814610443578063963cdbfd146104905780639bd71354146104bd578063b1e2b9dd14610514578063be6999c414610559578063d70d9358146105b0578063db4ecbc1146105df578063dda249f514610636578063fa6f39361461064d578063fbc28462146106a8575b600080fd5b34801561013957600080fd5b506101426106ff565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b34801561019057600080fd5b506101af60048036038101908080359060200190929190505050610724565b005b3480156101bd57600080fd5b506101c661073f565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b34801561021457600080fd5b506102376004803603810190808035600019169060200190929190505050610765565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b34801561028557600080fd5b5061028e610827565b60405180826000191660001916815260200191505060405180910390f35b3480156102b857600080fd5b506102db600480360381019080803560001916906020019092919050505061082d565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b34801561032957600080fd5b50610332610909565b6040518082815260200191505060405180910390f35b34801561035457600080fd5b5061035d610919565b604051808215151515815260200191505060405180910390f35b34801561038357600080fd5b5061038c610945565b005b34801561039a57600080fd5b506103a3610951565b604051808215151515815260200191505060405180910390f35b3480156103c957600080fd5b506103d261096c565b6040518082815260200191505060405180910390f35b3480156103f457600080fd5b50610429600480360381019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919050505061097c565b604051808215151515815260200191505060405180910390f35b34801561044f57600080fd5b506104726004803603810190808035600019169060200190929190505050610b5d565b60405180826000191660001916815260200191505060405180910390f35b34801561049c57600080fd5b506104bb60048036038101908080359060200190929190505050610c1f565b005b3480156104c957600080fd5b506104d2611731565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b34801561052057600080fd5b506105436004803603810190808035600019169060200190929190505050611757565b6040518082815260200191505060405180910390f35b34801561056557600080fd5b5061056e611819565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b3480156105bc57600080fd5b506105c561183f565b604051808215151515815260200191505060405180910390f35b3480156105eb57600080fd5b506105f46118ed565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b34801561064257600080fd5b5061064b611913565b005b34801561065957600080fd5b5061068e600480360381019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611e48565b604051808215151515815260200191505060405180910390f35b3480156106b457600080fd5b506106bd61211b565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b60008111151561073357600080fd5b61073c81612141565b50565b607160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b600061076f612bea565b73ffffffffffffffffffffffffffffffffffffffff1663e6b39eab836040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808260001916600019168152602001915050602060405180830381600087803b1580156107e557600080fd5b505af11580156107f9573d6000803e3d6000fd5b505050506040513d602081101561080f57600080fd5b81019080805190602001909291905050509050919050565b60015481565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16633f83acff836040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808260001916600019168152602001915050602060405180830381600087803b1580156108c757600080fd5b505af11580156108db573d6000803e3d6000fd5b505050506040513d60208110156108f157600080fd5b81019080805190602001909291905050509050919050565b600061091442612bfc565b905090565b600061092361183f565b80156109405750610935603854611757565b61093d610909565b10155b905090565b61094f6000612141565b565b600061095e603854611757565b610966610909565b10905090565b600061097742612ce5565b905090565b600061098661096c565b61098e612de8565b73ffffffffffffffffffffffffffffffffffffffff1663cefc2bff846040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050602060405180830381600087803b158015610a2857600080fd5b505af1158015610a3c573d6000803e3d6000fd5b505050506040513d6020811015610a5257600080fd5b8101908080519060200190929190505050148015610b565750610a76603554611757565b610a7e612dfa565b73ffffffffffffffffffffffffffffffffffffffff1663cd094a27846040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050602060405180830381600087803b158015610b1857600080fd5b505af1158015610b2c573d6000803e3d6000fd5b505050506040513d6020811015610b4257600080fd5b810190808051906020019092919050505010155b9050919050565b6000610b67612bea565b73ffffffffffffffffffffffffffffffffffffffff1663c0a8405d836040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808260001916600019168152602001915050602060405180830381600087803b158015610bdd57600080fd5b505af1158015610bf1573d6000803e3d6000fd5b505050506040513d6020811015610c0757600080fd5b81019080805190602001909291905050509050919050565b610c27614358565b610c2f614358565b600080610c3a61096c565b6001811115610d03576000610c4d612de8565b73ffffffffffffffffffffffffffffffffffffffff1663a78e00d6836040518263ffffffff167c010000000000000000000000000000000000000000000000000000000002815260040180828152602001915050602060405180830381600087803b158015610cbb57600080fd5b505af1158015610ccf573d6000803e3d6000fd5b505050506040513d6020811015610ce557600080fd5b8101908080519060200190929190505050111515610d0257600080fd5b5b610d0b610951565b80610db85750610d19612e0c565b73ffffffffffffffffffffffffffffffffffffffff16638bc865fd6040518163ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401602060405180830381600087803b158015610d7c57600080fd5b505af1158015610d90573d6000803e3d6000fd5b505050506040513d6020811015610da657600080fd5b81019080805190602001909291905050505b1515610dc357600080fd5b610dcc33612e1e565b9450610dd83386612fd2565b935060008560000151111515610ded57600080fd5b85856000015110151515610e0057600080fd5b610e178685600001516131de90919063ffffffff16565b846000018181525050610e378685602001516131de90919063ffffffff16565b846020018181525050610e578685604001516131de90919063ffffffff16565b846040018181525050610e686131f7565b73ffffffffffffffffffffffffffffffffffffffff166349da49bc336040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050600060405180830381600087803b158015610f0257600080fd5b505af1158015610f16573d6000803e3d6000fd5b50505050610f25338686613209565b610f2d612de8565b73ffffffffffffffffffffffffffffffffffffffff1663cefc2bff336040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050602060405180830381600087803b158015610fc757600080fd5b505af1158015610fdb573d6000803e3d6000fd5b505050506040513d6020811015610ff157600080fd5b8101908080519060200190929190505050925061100c61096c565b9150611019603554611757565b846020015110156112d257818314156111cb57611034612de8565b73ffffffffffffffffffffffffffffffffffffffff1663927bb66833611058612de8565b73ffffffffffffffffffffffffffffffffffffffff1663bcda6424336040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050602060405180830381600087803b1580156110f257600080fd5b505af1158015611106573d6000803e3d6000fd5b505050506040513d602081101561111c57600080fd5b81019080805190602001909291905050506040518363ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200182815260200192505050600060405180830381600087803b1580156111b257600080fd5b505af11580156111c6573d6000803e3d6000fd5b505050505b6111e6846020015185604001516131de90919063ffffffff16565b8460400181815250506111f7612dfa565b73ffffffffffffffffffffffffffffffffffffffff166344d9bfe6336040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050602060405180830381600087803b15801561129157600080fd5b505af11580156112a5573d6000803e3d6000fd5b505050506040513d60208110156112bb57600080fd5b810190808051906020019092919050505050611460565b8183101561145f576112e2612de8565b73ffffffffffffffffffffffffffffffffffffffff1663863eb74a33856040518363ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200182815260200192505050600060405180830381600087803b15801561138457600080fd5b505af1158015611398573d6000803e3d6000fd5b505050506113a4612de8565b73ffffffffffffffffffffffffffffffffffffffff1663927bb66833846040518363ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200182815260200192505050600060405180830381600087803b15801561144657600080fd5b505af115801561145a573d6000803e3d6000fd5b505050505b5b611468612dfa565b73ffffffffffffffffffffffffffffffffffffffff1663ad5c464733866000015187602001516040518463ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018381526020018281526020019350505050600060405180830381600087803b15801561151a57600080fd5b505af115801561152e573d6000803e3d6000fd5b5050505061153a612dfa565b73ffffffffffffffffffffffffffffffffffffffff16631538e68c85604001516040518263ffffffff167c010000000000000000000000000000000000000000000000000000000002815260040180828152602001915050600060405180830381600087803b1580156115ac57600080fd5b505af11580156115c0573d6000803e3d6000fd5b50505050607060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb33886040518363ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200182815260200192505050602060405180830381600087803b15801561168957600080fd5b505af115801561169d573d6000803e3d6000fd5b505050506040513d60208110156116b357600080fd5b810190808051906020019092919050505015156116cf57600080fd5b3373ffffffffffffffffffffffffffffffffffffffff167f854445a9a1b2b97212d606c21f3640b8b15b514332fc52b957f9c93125a274a4878660200151604051808381526020018281526020019250505060405180910390a2505050505050565b607260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6000611761612bea565b73ffffffffffffffffffffffffffffffffffffffff1663734c1168836040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808260001916600019168152602001915050602060405180830381600087803b1580156117d757600080fd5b505af11580156117eb573d6000803e3d6000fd5b505050506040513d602081101561180157600080fd5b81019080805190602001909291905050509050919050565b607060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6000611849612e0c565b73ffffffffffffffffffffffffffffffffffffffff16638bc865fd6040518163ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401602060405180830381600087803b1580156118ac57600080fd5b505af11580156118c0573d6000803e3d6000fd5b505050506040513d60208110156118d657600080fd5b810190808051906020019092919050505015905090565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b61191b614358565b611923612dfa565b73ffffffffffffffffffffffffffffffffffffffff1663f01a13e1336040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050602060405180830381600087803b1580156119bd57600080fd5b505af11580156119d1573d6000803e3d6000fd5b505050506040513d60208110156119e757600080fd5b8101908080519060200190929190505050151515611a0457600080fd5b6001611a0e61096c565b03611a17612de8565b73ffffffffffffffffffffffffffffffffffffffff1663bd695d21336040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050602060405180830381600087803b158015611ab157600080fd5b505af1158015611ac5573d6000803e3d6000fd5b505050506040513d6020811015611adb57600080fd5b8101908080519060200190929190505050141515611af857600080fd5b611b00612dfa565b73ffffffffffffffffffffffffffffffffffffffff166303cc89b4336040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050600060405180830381600087803b158015611b9a57600080fd5b505af1158015611bae573d6000803e3d6000fd5b50505050611bba613be1565b73ffffffffffffffffffffffffffffffffffffffff1663ded86d6833611be1606854611757565b6040518363ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001828152602001925050506040805180830381600087803b158015611c6557600080fd5b505af1158015611c79573d6000803e3d6000fd5b505050506040513d6040811015611c8f57600080fd5b8101908080519060200190929190805190602001909291905050505050611cb533612e1e565b9050611cc2338283613209565b607160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd333060016040518463ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018281526020019350505050602060405180830381600087803b158015611dbc57600080fd5b505af1158015611dd0573d6000803e3d6000fd5b505050506040513d6020811015611de657600080fd5b81019080805190602001909291905050501515611e0257600080fd5b3373ffffffffffffffffffffffffffffffffffffffff167f212ab1ff1ffcea0692d08ce958ff341c42bca858661e7811a8bd71e5d7fcba4260405160405180910390a250565b6000611e5261096c565b611e5a612de8565b73ffffffffffffffffffffffffffffffffffffffff1663cefc2bff846040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050602060405180830381600087803b158015611ef457600080fd5b505af1158015611f08573d6000803e3d6000fd5b505050506040513d6020811015611f1e57600080fd5b81019080805190602001909291905050501480156120225750611f42603654611757565b611f4a612dfa565b73ffffffffffffffffffffffffffffffffffffffff1663cd094a27846040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050602060405180830381600087803b158015611fe457600080fd5b505af1158015611ff8573d6000803e3d6000fd5b505050506040513d602081101561200e57600080fd5b810190808051906020019092919050505010155b80156121145750612034603754611757565b61203c613be1565b73ffffffffffffffffffffffffffffffffffffffff16639c89a0e2846040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050602060405180830381600087803b1580156120d657600080fd5b505af11580156120ea573d6000803e3d6000fd5b505050506040513d602081101561210057600080fd5b810190808051906020019092919050505010155b9050919050565b607360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b612149614358565b612151614358565b600080600061215e61096c565b6001811115612227576000612171612de8565b73ffffffffffffffffffffffffffffffffffffffff1663a78e00d6836040518263ffffffff167c010000000000000000000000000000000000000000000000000000000002815260040180828152602001915050602060405180830381600087803b1580156121df57600080fd5b505af11580156121f3573d6000803e3d6000fd5b505050506040513d602081101561220957600080fd5b810190808051906020019092919050505011151561222657600080fd5b5b3273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614151561226157600080fd5b61226a33612e1e565b95506122763387612fd2565b94506000935060008711156123395761228d613bf3565b73ffffffffffffffffffffffffffffffffffffffff16630b3b1595886040518263ffffffff167c010000000000000000000000000000000000000000000000000000000002815260040180828152602001915050602060405180830381600087803b1580156122fb57600080fd5b505af115801561230f573d6000803e3d6000fd5b505050506040513d602081101561232557600080fd5b810190808051906020019092919050505093505b612350878660000151613c0590919063ffffffff16565b856000018181525050612370848660200151613c0590919063ffffffff16565b856020018181525050612390848660400151613c0590919063ffffffff16565b8560400181815250506123a16131f7565b73ffffffffffffffffffffffffffffffffffffffff166349da49bc336040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050600060405180830381600087803b15801561243b57600080fd5b505af115801561244f573d6000803e3d6000fd5b5050505061245b612dfa565b73ffffffffffffffffffffffffffffffffffffffff1663ad5c464733876000015188602001516040518463ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018381526020018281526020019350505050600060405180830381600087803b15801561250d57600080fd5b505af1158015612521573d6000803e3d6000fd5b50505050612530338787613209565b612538612de8565b73ffffffffffffffffffffffffffffffffffffffff1663cefc2bff336040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050602060405180830381600087803b1580156125d257600080fd5b505af11580156125e6573d6000803e3d6000fd5b505050506040513d60208110156125fc57600080fd5b8101908080519060200190929190505050925061261761096c565b9150612624603554611757565b85602001511015156128b357612638612dfa565b73ffffffffffffffffffffffffffffffffffffffff1663e41b4c5c336040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050602060405180830381600087803b1580156126d257600080fd5b505af11580156126e6573d6000803e3d6000fd5b505050506040513d60208110156126fc57600080fd5b8101908080519060200190929190505050508183101561289b5761271e612de8565b73ffffffffffffffffffffffffffffffffffffffff1663863eb74a33856040518363ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200182815260200192505050600060405180830381600087803b1580156127c057600080fd5b505af11580156127d4573d6000803e3d6000fd5b505050506127e0612de8565b73ffffffffffffffffffffffffffffffffffffffff1663927bb66833846040518363ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200182815260200192505050600060405180830381600087803b15801561288257600080fd5b505af1158015612896573d6000803e3d6000fd5b505050505b60008314156128ae576128ad33613c21565b5b6129b6565b6128ce856020015186604001516131de90919063ffffffff16565b8560400181815250506128df612dfa565b73ffffffffffffffffffffffffffffffffffffffff166344d9bfe6336040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050602060405180830381600087803b15801561297957600080fd5b505af115801561298d573d6000803e3d6000fd5b505050506040513d60208110156129a357600080fd5b8101908080519060200190929190505050505b6129be612dfa565b73ffffffffffffffffffffffffffffffffffffffff16631538e68c86604001516040518263ffffffff167c010000000000000000000000000000000000000000000000000000000002815260040180828152602001915050600060405180830381600087803b158015612a3057600080fd5b505af1158015612a44573d6000803e3d6000fd5b50505050607060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd33308a6040518463ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018281526020019350505050602060405180830381600087803b158015612b4157600080fd5b505af1158015612b55573d6000803e3d6000fd5b505050506040513d6020811015612b6b57600080fd5b81019080805190602001909291905050501515612b8757600080fd5b3373ffffffffffffffffffffffffffffffffffffffff167f31234eaf60e5e9eb15f098a26504dfe889551da611f4f904c9031e8b52382050888760200151604051808381526020018281526020019250505060405180910390a250505050505050565b6000612bf7602b5461082d565b905090565b6000612c06614292565b1515612c1157600080fd5b612c1c603954611757565b612cd4612c27612e0c565b73ffffffffffffffffffffffffffffffffffffffff1663d9c6bb206040518163ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401602060405180830381600087803b158015612c8a57600080fd5b505af1158015612c9e573d6000803e3d6000fd5b505050506040513d6020811015612cb457600080fd5b8101908080519060200190929190505050846131de90919063ffffffff16565b811515612cdd57fe5b069050919050565b6000612cef614292565b1515612cfa57600080fd5b612de16001612dd3612d0d603954611757565b612dc5612d18612e0c565b73ffffffffffffffffffffffffffffffffffffffff1663d9c6bb206040518163ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401602060405180830381600087803b158015612d7b57600080fd5b505af1158015612d8f573d6000803e3d6000fd5b505050506040513d6020811015612da557600080fd5b8101908080519060200190929190505050876131de90919063ffffffff16565b61434290919063ffffffff16565b613c0590919063ffffffff16565b9050919050565b6000612df5602d5461082d565b905090565b6000612e07602c5461082d565b905090565b6000612e1960275461082d565b905090565b612e26614358565b612e2e612dfa565b73ffffffffffffffffffffffffffffffffffffffff16635bdd2743836040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019150506040805180830381600087803b158015612ec757600080fd5b505af1158015612edb573d6000803e3d6000fd5b505050506040513d6040811015612ef157600080fd5b810190808051906020019092919080519060200190929190505050826000018360200182815250828152505050612f26612dfa565b73ffffffffffffffffffffffffffffffffffffffff1663abed029a6040518163ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401602060405180830381600087803b158015612f8957600080fd5b505af1158015612f9d573d6000803e3d6000fd5b505050506040513d6020811015612fb357600080fd5b8101908080519060200190929190505050816040018181525050919050565b612fda614358565b600082602001518260200181815250508260000151826000018181525050826040015182604001818152505061300e61096c565b905080613019612de8565b73ffffffffffffffffffffffffffffffffffffffff1663cefc2bff866040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050602060405180830381600087803b1580156130b357600080fd5b505af11580156130c7573d6000803e3d6000fd5b505050506040513d60208110156130dd57600080fd5b810190808051906020019092919050505010156131d7576130fc613bf3565b73ffffffffffffffffffffffffffffffffffffffff16630b3b159584600001516040518263ffffffff167c010000000000000000000000000000000000000000000000000000000002815260040180828152602001915050602060405180830381600087803b15801561316e57600080fd5b505af1158015613182573d6000803e3d6000fd5b505050506040513d602081101561319857600080fd5b81019080805190602001909291905050508260200181815250506131cd82602001518360400151613c0590919063ffffffff16565b8260400181815250505b5092915050565b60008282111515156131ec57fe5b818303905092915050565b6000613204601b5461082d565b905090565b60008061321461096c565b61321c612de8565b73ffffffffffffffffffffffffffffffffffffffff1663cefc2bff876040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050602060405180830381600087803b1580156132b657600080fd5b505af11580156132ca573d6000803e3d6000fd5b505050506040513d60208110156132e057600080fd5b81019080805190602001909291905050501491506132fc612dfa565b73ffffffffffffffffffffffffffffffffffffffff1663bf448a876040518163ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401602060405180830381600087803b15801561335f57600080fd5b505af1158015613373573d6000803e3d6000fd5b505050506040513d602081101561338957600080fd5b81019080805190602001909291905050509050600115156133a8612dfa565b73ffffffffffffffffffffffffffffffffffffffff166388954a6c876040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050602060405180830381600087803b15801561344257600080fd5b505af1158015613456573d6000803e3d6000fd5b505050506040513d602081101561346c57600080fd5b81019080805190602001909291905050501515141561394d57613490603654611757565b8360200151108061358657506134a7603754611757565b6134af613be1565b73ffffffffffffffffffffffffffffffffffffffff16639c89a0e2876040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050602060405180830381600087803b15801561354957600080fd5b505af115801561355d573d6000803e3d6000fd5b505050506040513d602081101561357357600080fd5b8101908080519060200190929190505050105b156137dd576001613595612dfa565b73ffffffffffffffffffffffffffffffffffffffff1663e3bc96ba6040518163ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401602060405180830381600087803b1580156135f857600080fd5b505af115801561360c573d6000803e3d6000fd5b505050506040513d602081101561362257600080fd5b81019080805190602001909291905050501180613644575061364261183f565b155b151561364f57600080fd5b613657612dfa565b73ffffffffffffffffffffffffffffffffffffffff1663f2388b42866040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050602060405180830381600087803b1580156136f157600080fd5b505af1158015613705573d6000803e3d6000fd5b505050506040513d602081101561371b57600080fd5b81019080805190602001909291905050505081156137d85761373b612dfa565b73ffffffffffffffffffffffffffffffffffffffff166391baa14461376d8660200151846131de90919063ffffffff16565b6040518263ffffffff167c010000000000000000000000000000000000000000000000000000000002815260040180828152602001915050600060405180830381600087803b1580156137bf57600080fd5b505af11580156137d3573d6000803e3d6000fd5b505050505b613948565b81156138a2576137eb612dfa565b73ffffffffffffffffffffffffffffffffffffffff166391baa14461383385602001516138258860200151866131de90919063ffffffff16565b613c0590919063ffffffff16565b6040518263ffffffff167c010000000000000000000000000000000000000000000000000000000002815260040180828152602001915050600060405180830381600087803b15801561388557600080fd5b505af1158015613899573d6000803e3d6000fd5b50505050613947565b6138aa612dfa565b73ffffffffffffffffffffffffffffffffffffffff166391baa1446138dc856020015184613c0590919063ffffffff16565b6040518263ffffffff167c010000000000000000000000000000000000000000000000000000000002815260040180828152602001915050600060405180830381600087803b15801561392e57600080fd5b505af1158015613942573d6000803e3d6000fd5b505050505b5b613bda565b613958603654611757565b836020015110158015613a515750613971603754611757565b613979613be1565b73ffffffffffffffffffffffffffffffffffffffff16639c89a0e2876040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050602060405180830381600087803b158015613a1357600080fd5b505af1158015613a27573d6000803e3d6000fd5b505050506040513d6020811015613a3d57600080fd5b810190808051906020019092919050505010155b15613bd957613a5e612dfa565b73ffffffffffffffffffffffffffffffffffffffff166303a996a1866040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050602060405180830381600087803b158015613af857600080fd5b505af1158015613b0c573d6000803e3d6000fd5b505050506040513d6020811015613b2257600080fd5b810190808051906020019092919050505050613b3c612dfa565b73ffffffffffffffffffffffffffffffffffffffff166391baa144613b6e856020015184613c0590919063ffffffff16565b6040518263ffffffff167c010000000000000000000000000000000000000000000000000000000002815260040180828152602001915050600060405180830381600087803b158015613bc057600080fd5b505af1158015613bd4573d6000803e3d6000fd5b505050505b5b5050505050565b6000613bee60295461082d565b905090565b6000613c0060245461082d565b905090565b60008183019050828110151515613c1857fe5b80905092915050565b613c29612dfa565b73ffffffffffffffffffffffffffffffffffffffff16636d080338826040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050602060405180830381600087803b158015613cc357600080fd5b505af1158015613cd7573d6000803e3d6000fd5b505050506040513d6020811015613ced57600080fd5b810190808051906020019092919050505015613d085761428f565b607260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663aec2ccae826040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050602060405180830381600087803b158015613dc557600080fd5b505af1158015613dd9573d6000803e3d6000fd5b505050506040513d6020811015613def57600080fd5b810190808051906020019092919050505015613f0057613e0d613be1565b73ffffffffffffffffffffffffffffffffffffffff1663ded86d6882613e34606f54611757565b6040518363ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001828152602001925050506040805180830381600087803b158015613eb857600080fd5b505af1158015613ecc573d6000803e3d6000fd5b505050506040513d6040811015613ee257600080fd5b81019080805190602001909291908051906020019092919050505050505b607360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663aec2ccae826040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050602060405180830381600087803b158015613fbd57600080fd5b505af1158015613fd1573d6000803e3d6000fd5b505050506040513d6020811015613fe757600080fd5b8101908080519060200190929190505050156140f857614005613be1565b73ffffffffffffffffffffffffffffffffffffffff1663ded86d688261402c606f54611757565b6040518363ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001828152602001925050506040805180830381600087803b1580156140b057600080fd5b505af11580156140c4573d6000803e3d6000fd5b505050506040513d60408110156140da57600080fd5b81019080805190602001909291908051906020019092919050505050505b614100612de8565b73ffffffffffffffffffffffffffffffffffffffff166312d9b93933614137600161412961096c565b6131de90919063ffffffff16565b6040518363ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200182815260200192505050600060405180830381600087803b1580156141bc57600080fd5b505af11580156141d0573d6000803e3d6000fd5b505050506141dc612dfa565b73ffffffffffffffffffffffffffffffffffffffff16635515eb2c826040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050600060405180830381600087803b15801561427657600080fd5b505af115801561428a573d6000803e3d6000fd5b505050505b50565b60008061429d612e0c565b73ffffffffffffffffffffffffffffffffffffffff1663d9c6bb206040518163ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401602060405180830381600087803b15801561430057600080fd5b505af1158015614314573d6000803e3d6000fd5b505050506040513d602081101561432a57600080fd5b81019080805190602001909291905050501415905090565b6000818381151561434f57fe5b04905092915050565b60606040519081016040528060008152602001600081526020016000815250905600a165627a7a723058206176b0418a919026e5b54966c25f1b60b0a32151009fea4534e69ea8e16af3bc0029000000000000000000000000005f60ef7e1443f82ca7de947711f0966ca6e3b5000000000000000000000000e0b7927c4af23765cb51314a0e0521a9645f0e2a00000000000000000000000054bda709fed875224eae569bb6817d96ef7ed9ad0000000000000000000000009f56f330bceb9d4e756be94581298673e94ed592000000000000000000000000dec6c0dc7004ba23940c9ee7cb4a0528ec4c0580",
  "constructorArguments": "000000000000000000000000005f60ef7e1443f82ca7de947711f0966ca6e3b5000000000000000000000000E0B7927c4aF23765Cb51314A0E0521A9645F0E2A00000000000000000000000054BDa709FED875224EAe569bb6817d96ef7Ed9ad0000000000000000000000009f56f330bcEB9d4e756BE94581298673e94ED592000000000000000000000000DEC6c0Dc7004BA23940C9eE7cB4a0528Ec4C0580"
}