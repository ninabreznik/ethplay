{
  "address": "0x86fe3c20379ac71ebbf8c0499b41fd2b457e4e9e",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "Trade.io: Token Sale",
  "contractName": "TIOCrowdsale",
  "compilerVersion": "v0.4.18+commit.9cf6e910",
  "optimization": false,
  "runs": "0",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2017-12-03\n*/\n\npragma solidity ^0.4.18;\n\n/**\n * TradeToken Crowdsale Contract\n *\n * This is the crowdsale contract for the TradeToken. It utilizes Majoolr's\n * CrowdsaleLib library to reduce custom source code surface area and increase\n * overall security.Majoolr provides smart contract services and security reviews\n * for contract deployments in addition to working on open source projects in the\n * Ethereum community.\n * For further information: trade.io, majoolr.io\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\ncontract TIOCrowdsale {\n  using DirectCrowdsaleLib for DirectCrowdsaleLib.DirectCrowdsaleStorage;\n\n  DirectCrowdsaleLib.DirectCrowdsaleStorage sale;\n  bool public greenshoeActive;\n  function TIOCrowdsale(\n                address owner,\n                uint256[] saleData,           // [1512633600, 50, 0, 1513238400, 56, 0, 1513843200, 64, 0, 1514448000, 75, 0]\n                uint256 fallbackExchangeRate, // 45000\n                uint256 capAmountInCents,     // 24750000000\n                uint256 endTime,              // 1515052740\n                uint8 percentBurn,            // 100\n                CrowdsaleToken token)         // 0x80bc5512561c7f85a3a9508c7df7901b370fa1df\n  {\n  \tsale.init(owner, saleData, fallbackExchangeRate, capAmountInCents, endTime, percentBurn, token);\n  }\n\n  // fallback function can be used to buy tokens\n  function () payable {\n    sendPurchase();\n  }\n\n  function sendPurchase() payable returns (bool) {\n    uint256 _tokensSold = getTokensSold();\n    if(_tokensSold > 270000000000000000000000000 && (!greenshoeActive)){\n      bool success = activateGreenshoe();\n      assert(success);\n    }\n  \treturn sale.receivePurchase(msg.value);\n  }\n\n  function activateGreenshoe() private returns (bool) {\n    uint256 _currentPrice = sale.base.saleData[sale.base.milestoneTimes[sale.base.currentMilestone]][0];\n    while(sale.base.milestoneTimes.length > sale.base.currentMilestone + 1)\n    {\n      sale.base.currentMilestone += 1;\n      sale.base.saleData[sale.base.milestoneTimes[sale.base.currentMilestone]][0] = _currentPrice;\n    }\n    greenshoeActive = true;\n    return true;\n  }\n\n  function withdrawTokens() returns (bool) {\n  \treturn sale.withdrawTokens();\n  }\n\n  function withdrawLeftoverWei() returns (bool) {\n    return sale.withdrawLeftoverWei();\n  }\n\n  function withdrawOwnerEth() returns (bool) {\n    return sale.withdrawOwnerEth();\n  }\n\n  function crowdsaleActive() constant returns (bool) {\n    return sale.crowdsaleActive();\n  }\n\n  function crowdsaleEnded() constant returns (bool) {\n    return sale.crowdsaleEnded();\n  }\n\n  function setTokenExchangeRate(uint256 _exchangeRate) returns (bool) {\n    return sale.setTokenExchangeRate(_exchangeRate);\n  }\n\n  function setTokens() returns (bool) {\n    return sale.setTokens();\n  }\n\n  function getOwner() constant returns (address) {\n    return sale.base.owner;\n  }\n\n  function getTokensPerEth() constant returns (uint256) {\n    return sale.base.tokensPerEth;\n  }\n\n  function getExchangeRate() constant returns (uint256) {\n    return sale.base.exchangeRate;\n  }\n\n  function getCapAmount() constant returns (uint256) {\n    if(!greenshoeActive) {\n      return sale.base.capAmount - 160000000000000000000000;\n    } else {\n      return sale.base.capAmount;\n    }\n  }\n\n  function getStartTime() constant returns (uint256) {\n    return sale.base.startTime;\n  }\n\n  function getEndTime() constant returns (uint256) {\n    return sale.base.endTime;\n  }\n\n  function getEthRaised() constant returns (uint256) {\n    return sale.base.ownerBalance;\n  }\n\n  function getContribution(address _buyer) constant returns (uint256) {\n  \treturn sale.base.hasContributed[_buyer];\n  }\n\n  function getTokenPurchase(address _buyer) constant returns (uint256) {\n  \treturn sale.base.withdrawTokensMap[_buyer];\n  }\n\n  function getLeftoverWei(address _buyer) constant returns (uint256) {\n    return sale.base.leftoverWei[_buyer];\n  }\n\n  function getSaleData(uint256 timestamp) constant returns (uint256[3]) {\n    return sale.getSaleData(timestamp);\n  }\n\n  function getTokensSold() constant returns (uint256) {\n    return sale.base.startingTokenBalance - sale.base.withdrawTokensMap[sale.base.owner];\n  }\n\n  function getPercentBurn() constant returns (uint256) {\n    return sale.base.percentBurn;\n  }\n}\n\nlibrary DirectCrowdsaleLib {\n  using BasicMathLib for uint256;\n  using CrowdsaleLib for CrowdsaleLib.CrowdsaleStorage;\n\n  struct DirectCrowdsaleStorage {\n\n  \tCrowdsaleLib.CrowdsaleStorage base; // base storage from CrowdsaleLib\n\n  }\n\n  event LogTokensBought(address indexed buyer, uint256 amount);\n  event LogAddressCapExceeded(address indexed buyer, uint256 amount, string Msg);\n  event LogErrorMsg(uint256 amount, string Msg);\n  event LogTokenPriceChange(uint256 amount, string Msg);\n\n\n  /// @dev Called by a crowdsale contract upon creation.\n  /// @param self Stored crowdsale from crowdsale contract\n  /// @param _owner Address of crowdsale owner\n  /// @param _saleData Array of 3 item sets such that, in each 3 element\n  /// set, 1 is timestamp, 2 is price in cents at that time,\n  /// 3 is address purchase cap at that time, 0 if no address cap\n  /// @param _fallbackExchangeRate Exchange rate of cents/ETH\n  /// @param _capAmountInCents Total to be raised in cents\n  /// @param _endTime Timestamp of sale end time\n  /// @param _percentBurn Percentage of extra tokens to burn\n  /// @param _token Token being sold\n  function init(DirectCrowdsaleStorage storage self,\n                address _owner,\n                uint256[] _saleData,\n                uint256 _fallbackExchangeRate,\n                uint256 _capAmountInCents,\n                uint256 _endTime,\n                uint8 _percentBurn,\n                CrowdsaleToken _token)\n                public\n  {\n  \tself.base.init(_owner,\n                _saleData,\n                _fallbackExchangeRate,\n                _capAmountInCents,\n                _endTime,\n                _percentBurn,\n                _token);\n  }\n\n  /// @dev Called when an address wants to purchase tokens\n  /// @param self Stored crowdsale from crowdsale contract\n  /// @param _amount amount of wei that the buyer is sending\n  /// @return true on succesful purchase\n  function receivePurchase(DirectCrowdsaleStorage storage self, uint256 _amount)\n                           public\n                           returns (bool)\n  {\n    require(msg.sender != self.base.owner);\n  \trequire(self.base.validPurchase());\n\n  \t// if the token price increase interval has passed, update the current day and change the token price\n  \tif ((self.base.milestoneTimes.length > self.base.currentMilestone + 1) &&\n        (now > self.base.milestoneTimes[self.base.currentMilestone + 1]))\n    {\n        while((self.base.milestoneTimes.length > self.base.currentMilestone + 1) &&\n              (now > self.base.milestoneTimes[self.base.currentMilestone + 1]))\n        {\n          self.base.currentMilestone += 1;\n        }\n\n        self.base.changeTokenPrice(self.base.saleData[self.base.milestoneTimes[self.base.currentMilestone]][0]);\n        LogTokenPriceChange(self.base.tokensPerEth,\"Token Price has changed!\");\n    }\n\n  \tuint256 _numTokens; //number of tokens that will be purchased\n    uint256 _newBalance; //the new balance of the owner of the crowdsale\n    uint256 _weiTokens; //temp calc holder\n    uint256 _leftoverWei; //wei change for purchaser\n    uint256 _remainder; //temp calc holder\n    bool err;\n\n    if((self.base.ownerBalance + _amount) > self.base.capAmount){\n      _leftoverWei = (self.base.ownerBalance + _amount) - self.base.capAmount;\n      _amount = _amount - _leftoverWei;\n    }\n\n    // Find the number of tokens as a function in wei\n    (err,_weiTokens) = _amount.times(self.base.tokensPerEth);\n    require(!err);\n\n    _numTokens = _weiTokens / 1000000000000000000;\n    _remainder = _weiTokens % 1000000000000000000;\n    _remainder = _remainder / self.base.tokensPerEth;\n    _leftoverWei = _leftoverWei + _remainder;\n    _amount = _amount - _remainder;\n    self.base.leftoverWei[msg.sender] += _leftoverWei;\n\n    // can't overflow because it is under the cap\n    self.base.hasContributed[msg.sender] += _amount;\n\n    assert(_numTokens <= self.base.token.balanceOf(this));\n\n    // calculate the amount of ether in the owners balance\n    (err,_newBalance) = self.base.ownerBalance.plus(_amount);\n    require(!err);\n\n    self.base.ownerBalance = _newBalance;   // \"deposit\" the amount\n\n    // can't overflow because it will be under the cap\n\t  self.base.withdrawTokensMap[msg.sender] += _numTokens;\n\n    //subtract tokens from owner's share\n    (err,_remainder) = self.base.withdrawTokensMap[self.base.owner].minus(_numTokens);\n    require(!err);\n    self.base.withdrawTokensMap[self.base.owner] = _remainder;\n\n\t  LogTokensBought(msg.sender, _numTokens);\n\n    return true;\n  }\n\n  /*Functions \"inherited\" from CrowdsaleLib library*/\n\n  function setTokenExchangeRate(DirectCrowdsaleStorage storage self, uint256 _exchangeRate)\n                                public\n                                returns (bool)\n  {\n    return self.base.setTokenExchangeRate(_exchangeRate);\n  }\n\n  function setTokens(DirectCrowdsaleStorage storage self) public returns (bool) {\n    return self.base.setTokens();\n  }\n\n  function withdrawTokens(DirectCrowdsaleStorage storage self) public returns (bool) {\n    return self.base.withdrawTokens();\n  }\n\n  function withdrawLeftoverWei(DirectCrowdsaleStorage storage self) public returns (bool) {\n    return self.base.withdrawLeftoverWei();\n  }\n\n  function withdrawOwnerEth(DirectCrowdsaleStorage storage self) public returns (bool) {\n    return self.base.withdrawOwnerEth();\n  }\n\n  function getSaleData(DirectCrowdsaleStorage storage self, uint256 timestamp)\n                       public\n                       view\n                       returns (uint256[3])\n  {\n    return self.base.getSaleData(timestamp);\n  }\n\n  function getTokensSold(DirectCrowdsaleStorage storage self) public view returns (uint256) {\n    return self.base.getTokensSold();\n  }\n\n  function crowdsaleActive(DirectCrowdsaleStorage storage self) public view returns (bool) {\n    return self.base.crowdsaleActive();\n  }\n\n  function crowdsaleEnded(DirectCrowdsaleStorage storage self) public view returns (bool) {\n    return self.base.crowdsaleEnded();\n  }\n}\n\nlibrary CrowdsaleLib {\n  using BasicMathLib for uint256;\n\n  struct CrowdsaleStorage {\n  \taddress owner;     //owner of the crowdsale\n\n  \tuint256 tokensPerEth;  //number of tokens received per ether\n  \tuint256 capAmount; //Maximum amount to be raised in wei\n  \tuint256 startTime; //ICO start time, timestamp\n  \tuint256 endTime; //ICO end time, timestamp automatically calculated\n    uint256 exchangeRate; //cents/ETH exchange rate at the time of the sale\n    uint256 ownerBalance; //owner wei Balance\n    uint256 startingTokenBalance; //initial amount of tokens for sale\n    uint256[] milestoneTimes; //Array of timestamps when token price and address cap changes\n    uint8 currentMilestone; //Pointer to the current milestone\n    uint8 tokenDecimals; //stored token decimals for calculation later\n    uint8 percentBurn; //percentage of extra tokens to burn\n    bool tokensSet; //true if tokens have been prepared for crowdsale\n    bool rateSet; //true if exchange rate has been set\n\n    //Maps timestamp to token price and address purchase cap starting at that time\n    mapping (uint256 => uint256[2]) saleData;\n\n    //shows how much wei an address has contributed\n  \tmapping (address => uint256) hasContributed;\n\n    //For token withdraw function, maps a user address to the amount of tokens they can withdraw\n  \tmapping (address => uint256) withdrawTokensMap;\n\n    // any leftover wei that buyers contributed that didn't add up to a whole token amount\n    mapping (address => uint256) leftoverWei;\n\n  \tCrowdsaleToken token; //token being sold\n  }\n\n  // Indicates when an address has withdrawn their supply of tokens\n  event LogTokensWithdrawn(address indexed _bidder, uint256 Amount);\n\n  // Indicates when an address has withdrawn their supply of extra wei\n  event LogWeiWithdrawn(address indexed _bidder, uint256 Amount);\n\n  // Logs when owner has pulled eth\n  event LogOwnerEthWithdrawn(address indexed owner, uint256 amount, string Msg);\n\n  // Generic Notice message that includes and address and number\n  event LogNoticeMsg(address _buyer, uint256 value, string Msg);\n\n  // Indicates when an error has occurred in the execution of a function\n  event LogErrorMsg(uint256 amount, string Msg);\n\n  /// @dev Called by a crowdsale contract upon creation.\n  /// @param self Stored crowdsale from crowdsale contract\n  /// @param _owner Address of crowdsale owner\n  /// @param _saleData Array of 3 item sets such that, in each 3 element\n  /// set, 1 is timestamp, 2 is price in cents at that time,\n  /// 3 is address token purchase cap at that time, 0 if no address cap\n  /// @param _fallbackExchangeRate Exchange rate of cents/ETH\n  /// @param _capAmountInCents Total to be raised in cents\n  /// @param _endTime Timestamp of sale end time\n  /// @param _percentBurn Percentage of extra tokens to burn\n  /// @param _token Token being sold\n  function init(CrowdsaleStorage storage self,\n                address _owner,\n                uint256[] _saleData,\n                uint256 _fallbackExchangeRate,\n                uint256 _capAmountInCents,\n                uint256 _endTime,\n                uint8 _percentBurn,\n                CrowdsaleToken _token)\n                public\n  {\n  \trequire(self.capAmount == 0);\n  \trequire(self.owner == 0);\n    require(_saleData.length > 0);\n    require((_saleData.length%3) == 0); // ensure saleData is 3-item sets\n    require(_saleData[0] > (now + 3 days));\n    require(_endTime > _saleData[0]);\n    require(_capAmountInCents > 0);\n    require(_owner > 0);\n    require(_fallbackExchangeRate > 0);\n    require(_percentBurn <= 100);\n    self.owner = _owner;\n    self.capAmount = ((_capAmountInCents/_fallbackExchangeRate) + 1)*(10**18);\n    self.startTime = _saleData[0];\n    self.endTime = _endTime;\n    self.token = _token;\n    self.tokenDecimals = _token.decimals();\n    self.percentBurn = _percentBurn;\n    self.exchangeRate = _fallbackExchangeRate;\n\n    uint256 _tempTime;\n    for(uint256 i = 0; i < _saleData.length; i += 3){\n      require(_saleData[i] > _tempTime);\n      require(_saleData[i + 1] > 0);\n      require((_saleData[i + 2] == 0) || (_saleData[i + 2] >= 100));\n      self.milestoneTimes.push(_saleData[i]);\n      self.saleData[_saleData[i]][0] = _saleData[i + 1];\n      self.saleData[_saleData[i]][1] = _saleData[i + 2];\n      _tempTime = _saleData[i];\n    }\n    changeTokenPrice(self, _saleData[1]);\n  }\n\n  /// @dev function to check if the crowdsale is currently active\n  /// @param self Stored crowdsale from crowdsale contract\n  /// @return success\n  function crowdsaleActive(CrowdsaleStorage storage self) public view returns (bool) {\n  \treturn (now >= self.startTime && now <= self.endTime);\n  }\n\n  /// @dev function to check if the crowdsale has ended\n  /// @param self Stored crowdsale from crowdsale contract\n  /// @return success\n  function crowdsaleEnded(CrowdsaleStorage storage self) public view returns (bool) {\n  \treturn now > self.endTime;\n  }\n\n  /// @dev function to check if a purchase is valid\n  /// @param self Stored crowdsale from crowdsale contract\n  /// @return true if the transaction can buy tokens\n  function validPurchase(CrowdsaleStorage storage self) internal returns (bool) {\n    bool nonZeroPurchase = msg.value != 0;\n    if (crowdsaleActive(self) && nonZeroPurchase) {\n      return true;\n    } else {\n      LogErrorMsg(msg.value, \"Invalid Purchase! Check start time and amount of ether.\");\n      return false;\n    }\n  }\n\n  /// @dev Function called by purchasers to pull tokens\n  /// @param self Stored crowdsale from crowdsale contract\n  /// @return true if tokens were withdrawn\n  function withdrawTokens(CrowdsaleStorage storage self) public returns (bool) {\n    bool ok;\n\n    if (self.withdrawTokensMap[msg.sender] == 0) {\n      LogErrorMsg(0, \"Sender has no tokens to withdraw!\");\n      return false;\n    }\n\n    if (msg.sender == self.owner) {\n      if(!crowdsaleEnded(self)){\n        LogErrorMsg(0, \"Owner cannot withdraw extra tokens until after the sale!\");\n        return false;\n      } else {\n        if(self.percentBurn > 0){\n          uint256 _burnAmount = (self.withdrawTokensMap[msg.sender] * self.percentBurn)/100;\n          self.withdrawTokensMap[msg.sender] = self.withdrawTokensMap[msg.sender] - _burnAmount;\n          ok = self.token.burnToken(_burnAmount);\n          require(ok);\n        }\n      }\n    }\n\n    var total = self.withdrawTokensMap[msg.sender];\n    self.withdrawTokensMap[msg.sender] = 0;\n    ok = self.token.transfer(msg.sender, total);\n    require(ok);\n    LogTokensWithdrawn(msg.sender, total);\n    return true;\n  }\n\n  /// @dev Function called by purchasers to pull leftover wei from their purchases\n  /// @param self Stored crowdsale from crowdsale contract\n  /// @return true if wei was withdrawn\n  function withdrawLeftoverWei(CrowdsaleStorage storage self) public returns (bool) {\n    if (self.leftoverWei[msg.sender] == 0) {\n      LogErrorMsg(0, \"Sender has no extra wei to withdraw!\");\n      return false;\n    }\n\n    var total = self.leftoverWei[msg.sender];\n    self.leftoverWei[msg.sender] = 0;\n    msg.sender.transfer(total);\n    LogWeiWithdrawn(msg.sender, total);\n    return true;\n  }\n\n  /// @dev send ether from the completed crowdsale to the owners wallet address\n  /// @param self Stored crowdsale from crowdsale contract\n  /// @return true if owner withdrew eth\n  function withdrawOwnerEth(CrowdsaleStorage storage self) public returns (bool) {\n    if ((!crowdsaleEnded(self)) && (self.token.balanceOf(this)>0)) {\n      LogErrorMsg(0, \"Cannot withdraw owner ether until after the sale!\");\n      return false;\n    }\n\n    require(msg.sender == self.owner);\n    require(self.ownerBalance > 0);\n\n    uint256 amount = self.ownerBalance;\n    self.ownerBalance = 0;\n    self.owner.transfer(amount);\n    LogOwnerEthWithdrawn(msg.sender,amount,\"Crowdsale owner has withdrawn all funds!\");\n\n    return true;\n  }\n\n  /// @dev Function to change the price of the token\n  /// @param self Stored crowdsale from crowdsale contract\n  /// @param _newPrice new token price (amount of tokens per ether)\n  /// @return true if the token price changed successfully\n  function changeTokenPrice(CrowdsaleStorage storage self,\n                            uint256 _newPrice)\n                            internal\n                            returns (bool)\n  {\n  \trequire(_newPrice > 0);\n\n    bool err;\n    uint256 result;\n\n    (err, result) = self.exchangeRate.times(10**uint256(self.tokenDecimals));\n    require(!err);\n\n    self.tokensPerEth = result / _newPrice;\n\n    return true;\n  }\n\n  /// @dev function that is called three days before the sale to set the token and price\n  /// @param self Stored Crowdsale from crowdsale contract\n  /// @param _exchangeRate  ETH exchange rate expressed in cents/ETH\n  /// @return true if the exchange rate has been set\n  function setTokenExchangeRate(CrowdsaleStorage storage self, uint256 _exchangeRate)\n                                public\n                                returns (bool)\n  {\n    require(msg.sender == self.owner);\n    require((now > (self.startTime - 3 days)) && (now < (self.startTime)));\n    require(!self.rateSet);   // the exchange rate can only be set once!\n    require(self.token.balanceOf(this) > 0);\n    require(_exchangeRate > 0);\n\n    uint256 _capAmountInCents;\n    bool err;\n\n    (err, _capAmountInCents) = self.exchangeRate.times(self.capAmount);\n    require(!err);\n\n    self.exchangeRate = _exchangeRate;\n    self.capAmount = (_capAmountInCents/_exchangeRate) + 1;\n    changeTokenPrice(self,self.saleData[self.milestoneTimes[0]][0]);\n    self.rateSet = true;\n\n    err = !(setTokens(self));\n    require(!err);\n\n    LogNoticeMsg(msg.sender,self.tokensPerEth,\"Owner has set the exchange Rate and tokens bought per ETH!\");\n    return true;\n  }\n\n  /// @dev fallback function to set tokens if the exchange rate function was not called\n  /// @param self Stored Crowdsale from crowdsale contract\n  /// @return true if tokens set successfully\n  function setTokens(CrowdsaleStorage storage self) public returns (bool) {\n    require((msg.sender == self.owner) || (msg.sender == address(this)));\n    require(!self.tokensSet);\n\n    uint256 _tokenBalance;\n\n    _tokenBalance = self.token.balanceOf(this);\n    self.withdrawTokensMap[msg.sender] = _tokenBalance;\n    self.startingTokenBalance = _tokenBalance;\n    self.tokensSet = true;\n\n    return true;\n  }\n\n  /// @dev Gets the price and buy cap for individual addresses at the given milestone index\n  /// @param self Stored Crowdsale from crowdsale contract\n  /// @param timestamp Time during sale for which data is requested\n  /// @return A 3-element array with 0 the timestamp, 1 the price in cents, 2 the address cap\n  function getSaleData(CrowdsaleStorage storage self, uint256 timestamp)\n                       public\n                       view\n                       returns (uint256[3])\n  {\n    uint256[3] memory _thisData;\n    uint256 index;\n\n    while((index < self.milestoneTimes.length) && (self.milestoneTimes[index] < timestamp)) {\n      index++;\n    }\n    if(index == 0)\n      index++;\n\n    _thisData[0] = self.milestoneTimes[index - 1];\n    _thisData[1] = self.saleData[_thisData[0]][0];\n    _thisData[2] = self.saleData[_thisData[0]][1];\n    return _thisData;\n  }\n\n  /// @dev Gets the number of tokens sold thus far\n  /// @param self Stored Crowdsale from crowdsale contract\n  /// @return Number of tokens sold\n  function getTokensSold(CrowdsaleStorage storage self) public view returns (uint256) {\n    return self.startingTokenBalance - self.token.balanceOf(this);\n  }\n}\n\nlibrary TokenLib {\n  using BasicMathLib for uint256;\n\n  struct TokenStorage {\n    bool initialized;\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n\n    string name;\n    string symbol;\n    uint256 totalSupply;\n    uint256 initialSupply;\n    address owner;\n    uint8 decimals;\n    bool stillMinting;\n  }\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event OwnerChange(address from, address to);\n  event Burn(address indexed burner, uint256 value);\n  event MintingClosed(bool mintingClosed);\n\n  /// @dev Called by the Standard Token upon creation.\n  /// @param self Stored token from token contract\n  /// @param _name Name of the new token\n  /// @param _symbol Symbol of the new token\n  /// @param _decimals Decimal places for the token represented\n  /// @param _initial_supply The initial token supply\n  /// @param _allowMinting True if additional tokens can be created, false otherwise\n  function init(TokenStorage storage self,\n                address _owner,\n                string _name,\n                string _symbol,\n                uint8 _decimals,\n                uint256 _initial_supply,\n                bool _allowMinting)\n                public\n  {\n    require(!self.initialized);\n    self.initialized = true;\n    self.name = _name;\n    self.symbol = _symbol;\n    self.totalSupply = _initial_supply;\n    self.initialSupply = _initial_supply;\n    self.decimals = _decimals;\n    self.owner = _owner;\n    self.stillMinting = _allowMinting;\n    self.balances[_owner] = _initial_supply;\n  }\n\n  /// @dev Transfer tokens from caller's account to another account.\n  /// @param self Stored token from token contract\n  /// @param _to Address to send tokens\n  /// @param _value Number of tokens to send\n  /// @return True if completed\n  function transfer(TokenStorage storage self, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    bool err;\n    uint256 balance;\n\n    (err,balance) = self.balances[msg.sender].minus(_value);\n    require(!err);\n    self.balances[msg.sender] = balance;\n    //It's not possible to overflow token supply\n    self.balances[_to] = self.balances[_to] + _value;\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /// @dev Authorized caller transfers tokens from one account to another\n  /// @param self Stored token from token contract\n  /// @param _from Address to send tokens from\n  /// @param _to Address to send tokens to\n  /// @param _value Number of tokens to send\n  /// @return True if completed\n  function transferFrom(TokenStorage storage self,\n                        address _from,\n                        address _to,\n                        uint256 _value)\n                        public\n                        returns (bool)\n  {\n    var _allowance = self.allowed[_from][msg.sender];\n    bool err;\n    uint256 balanceOwner;\n    uint256 balanceSpender;\n\n    (err,balanceOwner) = self.balances[_from].minus(_value);\n    require(!err);\n\n    (err,balanceSpender) = _allowance.minus(_value);\n    require(!err);\n\n    self.balances[_from] = balanceOwner;\n    self.allowed[_from][msg.sender] = balanceSpender;\n    self.balances[_to] = self.balances[_to] + _value;\n\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /// @dev Retrieve token balance for an account\n  /// @param self Stored token from token contract\n  /// @param _owner Address to retrieve balance of\n  /// @return balance The number of tokens in the subject account\n  function balanceOf(TokenStorage storage self, address _owner) public view returns (uint256 balance) {\n    return self.balances[_owner];\n  }\n\n  /// @dev Authorize an account to send tokens on caller's behalf\n  /// @param self Stored token from token contract\n  /// @param _spender Address to authorize\n  /// @param _value Number of tokens authorized account may send\n  /// @return True if completed\n  function approve(TokenStorage storage self, address _spender, uint256 _value) public returns (bool) {\n    // must set to zero before changing approval amount in accordance with spec\n    require((_value == 0) || (self.allowed[msg.sender][_spender] == 0));\n\n    self.allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /// @dev Remaining tokens third party spender has to send\n  /// @param self Stored token from token contract\n  /// @param _owner Address of token holder\n  /// @param _spender Address of authorized spender\n  /// @return remaining Number of tokens spender has left in owner's account\n  function allowance(TokenStorage storage self, address _owner, address _spender)\n                     public\n                     view\n                     returns (uint256 remaining) {\n    return self.allowed[_owner][_spender];\n  }\n\n  /// @dev Authorize third party transfer by increasing/decreasing allowed rather than setting it\n  /// @param self Stored token from token contract\n  /// @param _spender Address to authorize\n  /// @param _valueChange Increase or decrease in number of tokens authorized account may send\n  /// @param _increase True if increasing allowance, false if decreasing allowance\n  /// @return True if completed\n  function approveChange (TokenStorage storage self, address _spender, uint256 _valueChange, bool _increase)\n                          public returns (bool)\n  {\n    uint256 _newAllowed;\n    bool err;\n\n    if(_increase) {\n      (err, _newAllowed) = self.allowed[msg.sender][_spender].plus(_valueChange);\n      require(!err);\n\n      self.allowed[msg.sender][_spender] = _newAllowed;\n    } else {\n      if (_valueChange > self.allowed[msg.sender][_spender]) {\n        self.allowed[msg.sender][_spender] = 0;\n      } else {\n        _newAllowed = self.allowed[msg.sender][_spender] - _valueChange;\n        self.allowed[msg.sender][_spender] = _newAllowed;\n      }\n    }\n\n    Approval(msg.sender, _spender, _newAllowed);\n    return true;\n  }\n\n  /// @dev Change owning address of the token contract, specifically for minting\n  /// @param self Stored token from token contract\n  /// @param _newOwner Address for the new owner\n  /// @return True if completed\n  function changeOwner(TokenStorage storage self, address _newOwner) public returns (bool) {\n    require((self.owner == msg.sender) && (_newOwner > 0));\n\n    self.owner = _newOwner;\n    OwnerChange(msg.sender, _newOwner);\n    return true;\n  }\n\n  /// @dev Mints additional tokens, new tokens go to owner\n  /// @param self Stored token from token contract\n  /// @param _amount Number of tokens to mint\n  /// @return True if completed\n  function mintToken(TokenStorage storage self, uint256 _amount) public returns (bool) {\n    require((self.owner == msg.sender) && self.stillMinting);\n    uint256 _newAmount;\n    bool err;\n\n    (err, _newAmount) = self.totalSupply.plus(_amount);\n    require(!err);\n\n    self.totalSupply =  _newAmount;\n    self.balances[self.owner] = self.balances[self.owner] + _amount;\n    Transfer(0x0, self.owner, _amount);\n    return true;\n  }\n\n  /// @dev Permanent stops minting\n  /// @param self Stored token from token contract\n  /// @return True if completed\n  function closeMint(TokenStorage storage self) public returns (bool) {\n    require(self.owner == msg.sender);\n\n    self.stillMinting = false;\n    MintingClosed(true);\n    return true;\n  }\n\n  /// @dev Permanently burn tokens\n  /// @param self Stored token from token contract\n  /// @param _amount Amount of tokens to burn\n  /// @return True if completed\n  function burnToken(TokenStorage storage self, uint256 _amount) public returns (bool) {\n      uint256 _newBalance;\n      bool err;\n\n      (err, _newBalance) = self.balances[msg.sender].minus(_amount);\n      require(!err);\n\n      self.balances[msg.sender] = _newBalance;\n      self.totalSupply = self.totalSupply - _amount;\n      Burn(msg.sender, _amount);\n      Transfer(msg.sender, 0x0, _amount);\n      return true;\n  }\n}\n\nlibrary BasicMathLib {\n  /// @dev Multiplies two numbers and checks for overflow before returning.\n  /// Does not throw.\n  /// @param a First number\n  /// @param b Second number\n  /// @return err False normally, or true if there is overflow\n  /// @return res The product of a and b, or 0 if there is overflow\n  function times(uint256 a, uint256 b) public view returns (bool err,uint256 res) {\n    assembly{\n      res := mul(a,b)\n      switch or(iszero(b), eq(div(res,b), a))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  /// @dev Divides two numbers but checks for 0 in the divisor first.\n  /// Does not throw.\n  /// @param a First number\n  /// @param b Second number\n  /// @return err False normally, or true if `b` is 0\n  /// @return res The quotient of a and b, or 0 if `b` is 0\n  function dividedBy(uint256 a, uint256 b) public view returns (bool err,uint256 i) {\n    uint256 res;\n    assembly{\n      switch iszero(b)\n      case 0 {\n        res := div(a,b)\n        let loc := mload(0x40)\n        mstore(add(loc,0x20),res)\n        i := mload(add(loc,0x20))\n      }\n      default {\n        err := 1\n        i := 0\n      }\n    }\n  }\n\n  /// @dev Adds two numbers and checks for overflow before returning.\n  /// Does not throw.\n  /// @param a First number\n  /// @param b Second number\n  /// @return err False normally, or true if there is overflow\n  /// @return res The sum of a and b, or 0 if there is overflow\n  function plus(uint256 a, uint256 b) public view returns (bool err, uint256 res) {\n    assembly{\n      res := add(a,b)\n      switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b)))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  /// @dev Subtracts two numbers and checks for underflow before returning.\n  /// Does not throw but rather logs an Err event if there is underflow.\n  /// @param a First number\n  /// @param b Second number\n  /// @return err False normally, or true if there is underflow\n  /// @return res The difference between a and b, or 0 if there is underflow\n  function minus(uint256 a, uint256 b) public view returns (bool err,uint256 res) {\n    assembly{\n      res := sub(a,b)\n      switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1)\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n}\n\ncontract CrowdsaleToken {\n  using TokenLib for TokenLib.TokenStorage;\n\n  TokenLib.TokenStorage public token;\n\n  function CrowdsaleToken(address owner,\n                                   string name,\n                                   string symbol,\n                                   uint8 decimals,\n                                   uint256 initialSupply,\n                                   bool allowMinting)\n                                   public\n  {\n    token.init(owner, name, symbol, decimals, initialSupply, allowMinting);\n  }\n\n  function name() public view returns (string) {\n    return token.name;\n  }\n\n  function symbol() public view returns (string) {\n    return token.symbol;\n  }\n\n  function decimals() public view returns (uint8) {\n    return token.decimals;\n  }\n\n  function totalSupply() public view returns (uint256) {\n    return token.totalSupply;\n  }\n\n  function initialSupply() public view returns (uint256) {\n    return token.initialSupply;\n  }\n\n  function balanceOf(address who) public view returns (uint256) {\n    return token.balanceOf(who);\n  }\n\n  function allowance(address owner, address spender) public view returns (uint256) {\n    return token.allowance(owner, spender);\n  }\n\n  function transfer(address to, uint256 value) public returns (bool ok) {\n    return token.transfer(to, value);\n  }\n\n  function transferFrom(address from, address to, uint value) public returns (bool ok) {\n    return token.transferFrom(from, to, value);\n  }\n\n  function approve(address spender, uint256 value) public returns (bool ok) {\n    return token.approve(spender, value);\n  }\n\n  function approveChange(address spender, uint256 valueChange, bool increase)\n                         public\n                         returns (bool)\n  {\n    return token.approveChange(spender, valueChange, increase);\n  }\n\n  function changeOwner(address newOwner) public returns (bool ok) {\n    return token.changeOwner(newOwner);\n  }\n\n  function burnToken(uint256 amount) public returns (bool ok) {\n    return token.burnToken(amount);\n  }\n}",
  "bytecode": "6060604052341561000f57600080fd5b604051611139380380611139833981016040528080519060200190919080518201919060200180519060200190919080519060200190919080519060200190919080519060200190919080519060200190919050506000738f43b453f187658e9519b04ac221ebc9478218c4637de64c899091898989898989896040518963ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808981526020018873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001806020018781526020018681526020018581526020018460ff1660ff1681526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001828103825288818151815260200191508051906020019060200280838360005b8381101561017f578082015181840152602081019050610164565b50505050905001995050505050505050505060006040518083038186803b15156101a857600080fd5b6102c65a03f415156101b957600080fd5b50505050505050505050610f67806101d26000396000f300606060405260043610610128576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680630b87cf10146101335780630c1ca1ba1461016057806321eff7fc1461018d5780632367f35d146101da57806329dacb60146102075780633391176314610230578063413100e01461025d578063439f5ac2146102aa578063559ed339146102d357806367532c8e146103005780636893f63f1461032257806386630b7b1461034b578063893d20e8146103aa5780638d8f2adb146103ff5780639fac6ddc1461042c578063bdf1211e14610459578063c828371e14610482578063cb7b8673146104ab578063d8ad1c5c146104e6578063e6aa216c1461050f578063ee7c0db014610538578063f59ae82c14610561575b6101306105ae565b50005b341561013e57600080fd5b61014661069d565b604051808215151515815260200191505060405180910390f35b341561016b57600080fd5b610173610734565b604051808215151515815260200191505060405180910390f35b341561019857600080fd5b6101c4600480803573ffffffffffffffffffffffffffffffffffffffff169060200190919050506107cb565b6040518082815260200191505060405180910390f35b34156101e557600080fd5b6101ed610819565b604051808215151515815260200191505060405180910390f35b341561021257600080fd5b61021a6108b0565b6040518082815260200191505060405180910390f35b341561023b57600080fd5b6102436108bf565b604051808215151515815260200191505060405180910390f35b341561026857600080fd5b610294600480803573ffffffffffffffffffffffffffffffffffffffff169060200190919050506108d2565b6040518082815260200191505060405180910390f35b34156102b557600080fd5b6102bd610920565b6040518082815260200191505060405180910390f35b34156102de57600080fd5b6102e661092f565b604051808215151515815260200191505060405180910390f35b6103086105ae565b604051808215151515815260200191505060405180910390f35b341561032d57600080fd5b6103356109c6565b6040518082815260200191505060405180910390f35b341561035657600080fd5b61036c60048080359060200190919050506109d5565b6040518082600360200280838360005b8381101561039757808201518184015260208101905061037c565b5050505090500191505060405180910390f35b34156103b557600080fd5b6103bd610a80565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b341561040a57600080fd5b610412610aaf565b604051808215151515815260200191505060405180910390f35b341561043757600080fd5b61043f610b46565b604051808215151515815260200191505060405180910390f35b341561046457600080fd5b61046c610bdd565b6040518082815260200191505060405180910390f35b341561048d57600080fd5b610495610bfc565b6040518082815260200191505060405180910390f35b34156104b657600080fd5b6104cc6004808035906020019091905050610c0b565b604051808215151515815260200191505060405180910390f35b34156104f157600080fd5b6104f9610cac565b6040518082815260200191505060405180910390f35b341561051a57600080fd5b610522610ced565b6040518082815260200191505060405180910390f35b341561054357600080fd5b61054b610cfc565b6040518082815260200191505060405180910390f35b341561056c57600080fd5b610598600480803573ffffffffffffffffffffffffffffffffffffffff16906020019091905050610d78565b6040518082815260200191505060405180910390f35b60008060006105bb610cfc565b91506adf56b9541c229fce000000821180156105e45750600f60009054906101000a900460ff16155b156105fd576105f1610dc6565b90508015156105fc57fe5b5b6000738f43b453f187658e9519b04ac221ebc9478218c463e1f0a45a9091346000604051602001526040518363ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808381526020018281526020019250505060206040518083038186803b151561067b57600080fd5b6102c65a03f4151561068c57600080fd5b505050604051805190509250505090565b600080738f43b453f187658e9519b04ac221ebc9478218c463aae1288a90916000604051602001526040518263ffffffff167c01000000000000000000000000000000000000000000000000000000000281526004018082815260200191505060206040518083038186803b151561071457600080fd5b6102c65a03f4151561072557600080fd5b50505060405180519050905090565b600080738f43b453f187658e9519b04ac221ebc9478218c4638e7a533690916000604051602001526040518263ffffffff167c01000000000000000000000000000000000000000000000000000000000281526004018082815260200191505060206040518083038186803b15156107ab57600080fd5b6102c65a03f415156107bc57600080fd5b50505060405180519050905090565b600080600001600b0160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050919050565b600080738f43b453f187658e9519b04ac221ebc9478218c4630acfb98590916000604051602001526040518263ffffffff167c01000000000000000000000000000000000000000000000000000000000281526004018082815260200191505060206040518083038186803b151561089057600080fd5b6102c65a03f415156108a157600080fd5b50505060405180519050905090565b60008060000160060154905090565b600f60009054906101000a900460ff1681565b600080600001600d0160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050919050565b60008060000160040154905090565b600080738f43b453f187658e9519b04ac221ebc9478218c463112c1e9090916000604051602001526040518263ffffffff167c01000000000000000000000000000000000000000000000000000000000281526004018082815260200191505060206040518083038186803b15156109a657600080fd5b6102c65a03f415156109b757600080fd5b50505060405180519050905090565b60008060000160010154905090565b6109dd610f13565b6000738f43b453f187658e9519b04ac221ebc9478218c4630239796e9091846000604051606001526040518363ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808381526020018281526020019250505060606040518083038186803b1515610a5b57600080fd5b6102c65a03f41515610a6c57600080fd5b505050604051806060016040529050919050565b60008060000160000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b600080738f43b453f187658e9519b04ac221ebc9478218c4637b84bfb590916000604051602001526040518263ffffffff167c01000000000000000000000000000000000000000000000000000000000281526004018082815260200191505060206040518083038186803b1515610b2657600080fd5b6102c65a03f41515610b3757600080fd5b50505060405180519050905090565b600080738f43b453f187658e9519b04ac221ebc9478218c463eb40c0d690916000604051602001526040518263ffffffff167c01000000000000000000000000000000000000000000000000000000000281526004018082815260200191505060206040518083038186803b1515610bbd57600080fd5b6102c65a03f41515610bce57600080fd5b50505060405180519050905090565b60008060000160090160029054906101000a900460ff1660ff16905090565b60008060000160030154905090565b600080738f43b453f187658e9519b04ac221ebc9478218c463d99083f39091846000604051602001526040518363ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808381526020018281526020019250505060206040518083038186803b1515610c8a57600080fd5b6102c65a03f41515610c9b57600080fd5b505050604051805190509050919050565b6000600f60009054906101000a900460ff161515610cdf576921e19e0c9bab240000006000800160020154039050610cea565b600080016002015490505b90565b60008060000160050154905090565b600080600001600c0160008060000160000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054600080016007015403905090565b600080600001600c0160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050919050565b60008060008001600a016000806000016008016000800160090160009054906101000a900460ff1660ff16815481101515610dfd57fe5b90600052602060002090015481526020019081526020016000206000600281101515610e2557fe5b015490505b60016000800160090160009054906101000a900460ff160160ff1660008001600801805490501115610ef05760016000800160090160008282829054906101000a900460ff160192506101000a81548160ff021916908360ff1602179055508060008001600a016000806000016008016000800160090160009054906101000a900460ff1660ff16815481101515610ebe57fe5b90600052602060002090015481526020019081526020016000206000600281101515610ee657fe5b0181905550610e2a565b6001600f60006101000a81548160ff021916908315150217905550600191505090565b6060604051908101604052806003905b6000815260200190600190039081610f2357905050905600a165627a7a723058201a78412ddf052c99c7aa46ecf45ef347e95f68216e1fee040367ff3fc9c55fb7002900000000000000000000000058f75ddacffb183a30f69fe58a67a0d0985fce0f00000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000afc800000000000000000000000000000000000000000000000000000005c3370780000000000000000000000000000000000000000000000000000000005a4ddec4000000000000000000000000000000000000000000000000000000000000006400000000000000000000000080bc5512561c7f85a3a9508c7df7901b370fa1df000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000005a28f50000000000000000000000000000000000000000000000000000000000000000320000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005a322f8000000000000000000000000000000000000000000000000000000000000000380000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005a3b6a0000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005a44a480000000000000000000000000000000000000000000000000000000000000004b0000000000000000000000000000000000000000000000000000000000000000",
  "constructorArguments": "00000000000000000000000058f75ddacffb183a30f69fe58a67a0d0985fce0f00000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000afc800000000000000000000000000000000000000000000000000000005c3370780000000000000000000000000000000000000000000000000000000005a4ddec4000000000000000000000000000000000000000000000000000000000000006400000000000000000000000080bc5512561c7f85a3a9508c7df7901b370fa1df000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000005a28f50000000000000000000000000000000000000000000000000000000000000000320000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005a322f8000000000000000000000000000000000000000000000000000000000000000380000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005a3b6a0000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005a44a480000000000000000000000000000000000000000000000000000000000000004b0000000000000000000000000000000000000000000000000000000000000000",
  "libraries": [
    {
      "name": "DirectCrowdsaleLib",
      "address": "0x8F43b453f187658e9519b04AC221ebc9478218c4"
    }
  ]
}