{
  "address": "0x573e869ca9355299cddb3a912d444f137ded397c",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "Fortis",
  "compilerVersion": "v0.4.24+commit.e67f0147",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2018-08-10\n*/\n\npragma solidity ^0.4.24;\n\n/**\n\n  https://fortisgames.com https://fortisgames.com https://fortisgames.com https://fortisgames.com https://fortisgames.com\n\n                                                                                                  \nFFFFFFFFFFFFFFFFFFFFFF                                           tttt            iiii                   \nF::::::::::::::::::::F                                        ttt:::t           i::::i                  \nF::::::::::::::::::::F                                        t:::::t            iiii                   \nFF::::::FFFFFFFFF::::F                                        t:::::t                                   \n  F:::::F       FFFFFFooooooooooo   rrrrr   rrrrrrrrr   ttttttt:::::ttttttt    iiiiiii     ssssssssss   \n  F:::::F           oo:::::::::::oo r::::rrr:::::::::r  t:::::::::::::::::t    i:::::i   ss::::::::::s  \n  F::::::FFFFFFFFFFo:::::::::::::::or:::::::::::::::::r t:::::::::::::::::t     i::::i ss:::::::::::::s \n  F:::::::::::::::Fo:::::ooooo:::::orr::::::rrrrr::::::rtttttt:::::::tttttt     i::::i s::::::ssss:::::s\n  F:::::::::::::::Fo::::o     o::::o r:::::r     r:::::r      t:::::t           i::::i  s:::::s  ssssss \n  F::::::FFFFFFFFFFo::::o     o::::o r:::::r     rrrrrrr      t:::::t           i::::i    s::::::s      \n  F:::::F          o::::o     o::::o r:::::r                  t:::::t           i::::i       s::::::s   \n  F:::::F          o::::o     o::::o r:::::r                  t:::::t    tttttt i::::i ssssss   s:::::s \nFF:::::::FF        o:::::ooooo:::::o r:::::r                  t::::::tttt:::::ti::::::is:::::ssss::::::s\nF::::::::FF        o:::::::::::::::o r:::::r                  tt::::::::::::::ti::::::is::::::::::::::s \nF::::::::FF         oo:::::::::::oo  r:::::r                    tt:::::::::::tti::::::i s:::::::::::ss  \nFFFFFFFFFFF           ooooooooooo    rrrrrrr                      ttttttttttt  iiiiiiii  sssssssssss    \n                                                                                                        \n\nAn interactive, variable-dividend rate contract with an ICO-capped price floor and collectibles.\n\nDiscord:   https://discord.gg/gDtTX62\n\n\n**/\n\n\ncontract Fortis {\n  using SafeMath for uint;\n\n  /*=================================\n  =            MODIFIERS            =\n  =================================*/\n\n  modifier onlyHolders() {\n    require(myFrontEndTokens() > 0);\n    _;\n  }\n\n  modifier dividendHolder() {\n    require(myDividends(true) > 0);\n    _;\n  }\n\n  modifier onlyAdministrator(){\n    address _customerAddress = msg.sender;\n    require(administrators[_customerAddress]);\n    _;\n  }\n\n  /*==============================\n  =            EVENTS            =\n  ==============================*/\n\n  event onTokenPurchase(\n    address indexed customerAddress,\n    uint incomingEthereum,\n    uint tokensMinted,\n    address indexed referredBy\n  );\n\n  event UserDividendRate(\n    address user,\n    uint divRate\n  );\n\n  event onTokenSell(\n    address indexed customerAddress,\n    uint tokensBurned,\n    uint ethereumEarned\n  );\n\n  event onReinvestment(\n    address indexed customerAddress,\n    uint ethereumReinvested,\n    uint tokensMinted\n  );\n\n  event onWithdraw(\n    address indexed customerAddress,\n    uint ethereumWithdrawn\n  );\n\n  event Transfer(\n    address indexed from,\n    address indexed to,\n    uint tokens\n  );\n\n  event Approval(\n    address indexed tokenOwner,\n    address indexed spender,\n    uint tokens\n  );\n\n  event Allocation(\n    uint toBankRoll,\n    uint toReferrer,\n    uint toTokenHolders,\n    uint toDivCardHolders,\n    uint forTokens\n  );\n\n  event Referral(\n    address referrer,\n    uint amountReceived\n  );\n\n  /*=====================================\n  =            CONSTANTS                =\n  =====================================*/\n\n  uint8 constant public                decimals              = 18;\n\n  uint constant internal               tokenPriceInitial_    = 0.000653 ether;\n  uint constant internal               magnitude             = 2**64;\n\n  uint constant internal               icoHardCap            = 250 ether;\n  uint constant internal               addressICOLimit       = 1   ether;\n  uint constant internal               icoMinBuyIn           = 0.1 finney;\n  uint constant internal               icoMaxGasPrice        = 50000000000 wei;\n\n  uint constant internal               MULTIPLIER            = 9615;\n\n  uint constant internal               MIN_ETH_BUYIN         = 0.0001 ether;\n  uint constant internal               MIN_TOKEN_SELL_AMOUNT = 0.0001 ether;\n  uint constant internal               MIN_TOKEN_TRANSFER    = 1e10;\n  uint constant internal               referrer_percentage   = 25;\n\n  uint public                          stakingRequirement    = 100e18;\n\n  /*================================\n   =          CONFIGURABLES         =\n   ================================*/\n\n  string public                        name               = \"Fortis\";\n  string public                        symbol             = \"IRON\";\n\n  bytes32 constant public              icoHashedPass      = bytes32(0x5ddcde33b94b19bdef79dd9ea75be591942b9ec78286d64b44a356280fb6a262);\n\n  address internal                     bankrollAddress;\n\n  ZethrDividendCards                   divCardContract;\n\n  /*================================\n   =            DATASETS            =\n   ================================*/\n\n  // Tracks front & backend tokens\n  mapping(address => uint) internal    frontTokenBalanceLedger_;\n  mapping(address => uint) internal    dividendTokenBalanceLedger_;\n  mapping(address =>\n  mapping (address => uint))\n  public      allowed;\n\n  // Tracks dividend rates for users\n  mapping(uint8   => bool)    internal validDividendRates_;\n  mapping(address => bool)    internal userSelectedRate;\n  mapping(address => uint8)   internal userDividendRate;\n\n  // Payout tracking\n  mapping(address => uint)    internal referralBalance_;\n  mapping(address => int256)  internal payoutsTo_;\n\n  // ICO per-address limit tracking\n  mapping(address => uint)    internal ICOBuyIn;\n\n  uint public                          tokensMintedDuringICO;\n  uint public                          ethInvestedDuringICO;\n\n  uint public                          currentEthInvested;\n\n  uint internal                        tokenSupply    = 0;\n  uint internal                        divTokenSupply = 0;\n\n  uint internal                        profitPerDivToken;\n\n  mapping(address => bool) public      administrators;\n\n  bool public                          icoPhase     = false;\n  bool public                          regularPhase = false;\n\n  uint                                 icoOpenTime;\n\n  /*=======================================\n  =            PUBLIC FUNCTIONS           =\n  =======================================*/\n  constructor (address _bankrollAddress, address _divCardAddress)\n  public\n  {\n    bankrollAddress = _bankrollAddress;\n    divCardContract = ZethrDividendCards(_divCardAddress);\n\n    administrators[0x9b3bb44b1a9243db229e5ccc6d20cada9efce5f8] = true; // Rayner\n    administrators[0x487a03097b4d7320d5a0e7451f6a0e1224c37f09] = true; // Rustam\n    administrators[0x24d6e2d15a85c27b0282bbc2afbc06cfbd9c15a0] = true; // Glandur\n\n    administrators[msg.sender] = true; // Helps with debugging!\n\n    validDividendRates_[2] = true;\n    validDividendRates_[5] = true;\n    validDividendRates_[10] = true;\n    validDividendRates_[15] = true;\n    validDividendRates_[20] = true;\n    validDividendRates_[25] = true;\n    validDividendRates_[33] = true;\n\n    userSelectedRate[bankrollAddress] = true;\n    userDividendRate[bankrollAddress] = 33;\n\n  }\n\n  /**\n   * Same as buy, but explicitly sets your dividend percentage.\n   * If this has been called before, it will update your `default' dividend\n   *   percentage for regular buy transactions going forward.\n   */\n  function buyAndSetDivPercentage(address _referredBy, uint8 _divChoice, string providedUnhashedPass)\n  public\n  payable\n  returns (uint)\n  {\n    require(icoPhase || regularPhase);\n\n    if (icoPhase) {\n \n      // Anti-bot measures - not perfect, but should help some.\n      bytes32 hashedProvidedPass = keccak256(providedUnhashedPass);\n      require(hashedProvidedPass == icoHashedPass || msg.sender == bankrollAddress);\n\n      uint gasPrice = tx.gasprice;\n\n      // Prevents ICO buyers from getting substantially burned if the ICO is reached\n      //   before their transaction is processed.\n      require(gasPrice <= icoMaxGasPrice && ethInvestedDuringICO <= icoHardCap);\n\n    }\n\n    // Dividend percentage should be a currently accepted value.\n    require (validDividendRates_[_divChoice]);\n\n    // Set the dividend fee percentage denominator.\n    userSelectedRate[msg.sender] = true;\n    userDividendRate[msg.sender] = _divChoice;\n    emit UserDividendRate(msg.sender, _divChoice);\n\n    // Finally, purchase tokens.\n    purchaseTokens(msg.value, _referredBy);\n  }\n\n  // All buys except for the above one require regular phase.\n\n  function buy(address _referredBy)\n  public\n  payable\n  returns(uint)\n  {\n    require(regularPhase);\n    address _customerAddress = msg.sender;\n    require (userSelectedRate[_customerAddress]);\n    purchaseTokens(msg.value, _referredBy);\n  }\n\n  function buyAndTransfer(address _referredBy, address target)\n  public\n  payable\n  {\n    bytes memory empty;\n    buyAndTransfer(_referredBy,target, empty, 20);\n  }\n\n  function buyAndTransfer(address _referredBy, address target, bytes _data)\n  public\n  payable\n  {\n    buyAndTransfer(_referredBy, target, _data, 20);\n  }\n\n  // Overload\n  function buyAndTransfer(address _referredBy, address target, bytes _data, uint8 divChoice)\n  public\n  payable\n  {\n    require(regularPhase);\n    address _customerAddress = msg.sender;\n    uint256 frontendBalance = frontTokenBalanceLedger_[msg.sender];\n    if (userSelectedRate[_customerAddress] && divChoice == 0) {\n      purchaseTokens(msg.value, _referredBy);\n    } else {\n      buyAndSetDivPercentage(_referredBy, divChoice, \"0x0\");\n    }\n    uint256 difference = SafeMath.sub(frontTokenBalanceLedger_[msg.sender], frontendBalance);\n    transferTo(msg.sender, target, difference, _data);\n  }\n\n  // Fallback function only works during regular phase - part of anti-bot protection.\n  function()\n  payable\n  public\n  {\n    /**\n    / If the user has previously set a dividend rate, sending\n    /   Ether directly to the contract simply purchases more at\n    /   the most recent rate. If this is their first time, they\n    /   are automatically placed into the 20% rate `bucket'.\n    **/\n    require(regularPhase);\n    address _customerAddress = msg.sender;\n    if (userSelectedRate[_customerAddress]) {\n      purchaseTokens(msg.value, 0x0);\n    } else {\n      buyAndSetDivPercentage(0x0, 20, \"0x0\");\n    }\n  }\n\n  function reinvest()\n  dividendHolder()\n  public\n  {\n    require(regularPhase);\n    uint _dividends = myDividends(false);\n\n    // Pay out requisite `virtual' dividends.\n    address _customerAddress            = msg.sender;\n    payoutsTo_[_customerAddress]       += (int256) (_dividends * magnitude);\n\n    _dividends                         += referralBalance_[_customerAddress];\n    referralBalance_[_customerAddress]  = 0;\n\n    uint _tokens                        = purchaseTokens(_dividends, 0x0);\n\n    // Fire logging event.\n    emit onReinvestment(_customerAddress, _dividends, _tokens);\n  }\n\n  function exit()\n  public\n  {\n    require(regularPhase);\n    // Retrieve token balance for caller, then sell them all.\n    address _customerAddress = msg.sender;\n    uint _tokens             = frontTokenBalanceLedger_[_customerAddress];\n\n    if(_tokens > 0) sell(_tokens);\n\n    withdraw(_customerAddress);\n  }\n\n  function withdraw(address _recipient)\n  dividendHolder()\n  public\n  {\n    require(regularPhase);\n    // Setup data\n    address _customerAddress           = msg.sender;\n    uint _dividends                    = myDividends(false);\n\n    // update dividend tracker\n    payoutsTo_[_customerAddress]       +=  (int256) (_dividends * magnitude);\n\n    // add ref. bonus\n    _dividends                         += referralBalance_[_customerAddress];\n    referralBalance_[_customerAddress]  = 0;\n\n    if (_recipient == address(0x0)){\n      _recipient = msg.sender;\n    }\n    _recipient.transfer(_dividends);\n\n    // Fire logging event.\n    emit onWithdraw(_recipient, _dividends);\n  }\n\n  // Sells front-end tokens.\n  // Logic concerning step-pricing of tokens pre/post-ICO is encapsulated in tokensToEthereum_.\n  function sell(uint _amountOfTokens)\n  onlyHolders()\n  public\n  {\n    // No selling during the ICO. You don't get to flip that fast, sorry!\n    require(!icoPhase);\n    require(regularPhase);\n\n    require(_amountOfTokens <= frontTokenBalanceLedger_[msg.sender]);\n\n    uint _frontEndTokensToBurn = _amountOfTokens;\n\n    // Calculate how many dividend tokens this action burns.\n    // Computed as the caller's average dividend rate multiplied by the number of front-end tokens held.\n    // As an additional guard, we ensure that the dividend rate is between 2 and 50 inclusive.\n    uint userDivRate  = getUserAverageDividendRate(msg.sender);\n    require ((2*magnitude) <= userDivRate && (50*magnitude) >= userDivRate );\n    uint _divTokensToBurn = (_frontEndTokensToBurn.mul(userDivRate)).div(magnitude);\n\n    // Calculate ethereum received before dividends\n    uint _ethereum = tokensToEthereum_(_frontEndTokensToBurn);\n\n    if (_ethereum > currentEthInvested){\n      // Well, congratulations, you've emptied the coffers.\n      currentEthInvested = 0;\n    } else { currentEthInvested = currentEthInvested - _ethereum; }\n\n    // Calculate dividends generated from the sale.\n    uint _dividends = (_ethereum.mul(getUserAverageDividendRate(msg.sender)).div(100)).div(magnitude);\n\n    // Calculate Ethereum receivable net of dividends.\n    uint _taxedEthereum = _ethereum.sub(_dividends);\n\n    // Burn the sold tokens (both front-end and back-end variants).\n    tokenSupply         = tokenSupply.sub(_frontEndTokensToBurn);\n    divTokenSupply      = divTokenSupply.sub(_divTokensToBurn);\n\n    // Subtract the token balances for the seller\n    frontTokenBalanceLedger_[msg.sender]    = frontTokenBalanceLedger_[msg.sender].sub(_frontEndTokensToBurn);\n    dividendTokenBalanceLedger_[msg.sender] = dividendTokenBalanceLedger_[msg.sender].sub(_divTokensToBurn);\n\n    // Update dividends tracker\n    int256 _updatedPayouts  = (int256) (profitPerDivToken * _divTokensToBurn + (_taxedEthereum * magnitude));\n    payoutsTo_[msg.sender] -= _updatedPayouts;\n\n    // Let's avoid breaking arithmetic where we can, eh?\n    if (divTokenSupply > 0) {\n      // Update the value of each remaining back-end dividend token.\n      profitPerDivToken = profitPerDivToken.add((_dividends * magnitude) / divTokenSupply);\n    }\n\n    // Fire logging event.\n    emit onTokenSell(msg.sender, _frontEndTokensToBurn, _taxedEthereum);\n  }\n\n  /**\n   * Transfer tokens from the caller to a new holder.\n   * No charge incurred for the transfer. We'd make a terrible bank.\n   */\n  function transfer(address _toAddress, uint _amountOfTokens)\n  onlyHolders()\n  public\n  returns(bool)\n  {\n    require(_amountOfTokens >= MIN_TOKEN_TRANSFER\n    && _amountOfTokens <= frontTokenBalanceLedger_[msg.sender]);\n    bytes memory empty;\n    transferFromInternal(msg.sender, _toAddress, _amountOfTokens, empty);\n    return true;\n\n  }\n\n  function approve(address spender, uint tokens)\n  public\n  returns (bool)\n  {\n    address _customerAddress           = msg.sender;\n    allowed[_customerAddress][spender] = tokens;\n\n    // Fire logging event.\n    emit Approval(_customerAddress, spender, tokens);\n\n    // Good old ERC20.\n    return true;\n  }\n\n  /**\n   * Transfer tokens from the caller to a new holder: the Used By Smart Contracts edition.\n   * No charge incurred for the transfer. No seriously, we'd make a terrible bank.\n   */\n  function transferFrom(address _from, address _toAddress, uint _amountOfTokens)\n  public\n  returns(bool)\n  {\n    // Setup variables\n    address _customerAddress     = _from;\n    bytes memory empty;\n    // Make sure we own the tokens we're transferring, are ALLOWED to transfer that many tokens,\n    // and are transferring at least one full token.\n    require(_amountOfTokens >= MIN_TOKEN_TRANSFER\n    && _amountOfTokens <= frontTokenBalanceLedger_[_customerAddress]\n    && _amountOfTokens <= allowed[_customerAddress][msg.sender]);\n\n    transferFromInternal(_from, _toAddress, _amountOfTokens, empty);\n\n    // Good old ERC20.\n    return true;\n\n  }\n\n  function transferTo (address _from, address _to, uint _amountOfTokens, bytes _data)\n  public\n  {\n    if (_from != msg.sender){\n      require(_amountOfTokens >= MIN_TOKEN_TRANSFER\n      && _amountOfTokens <= frontTokenBalanceLedger_[_from]\n      && _amountOfTokens <= allowed[_from][msg.sender]);\n    }\n    else{\n      require(_amountOfTokens >= MIN_TOKEN_TRANSFER\n      && _amountOfTokens <= frontTokenBalanceLedger_[_from]);\n    }\n\n    transferFromInternal(_from, _to, _amountOfTokens, _data);\n  }\n\n  // Who'd have thought we'd need this thing floating around?\n  function totalSupply()\n  public\n  view\n  returns (uint256)\n  {\n    return tokenSupply;\n  }\n\n  // Anyone can start the regular phase 2 weeks after the ICO phase starts.\n  // In case the devs die. Or something.\n  function publicStartRegularPhase()\n  public\n  {\n    require(now > (icoOpenTime + 2 weeks) && icoOpenTime != 0);\n\n    icoPhase     = false;\n    regularPhase = true;\n  }\n\n  /*----------  ADMINISTRATOR ONLY FUNCTIONS  ----------*/\n\n\n  // Fire the starting gun and then duck for cover.\n  function startICOPhase()\n  onlyAdministrator()\n  public\n  {\n    // Prevent us from startaring the ICO phase again\n    require(icoOpenTime == 0);\n    icoPhase = true;\n    icoOpenTime = now;\n  }\n\n  // Fire the ... ending gun?\n  function endICOPhase()\n  onlyAdministrator()\n  public\n  {\n    icoPhase = false;\n  }\n\n  function startRegularPhase()\n  onlyAdministrator\n  public\n  {\n    // disable ico phase in case if that was not disabled yet\n    icoPhase = false;\n    regularPhase = true;\n  }\n\n  // The death of a great man demands the birth of a great son.\n  function setAdministrator(address _newAdmin, bool _status)\n  onlyAdministrator()\n  public\n  {\n    administrators[_newAdmin] = _status;\n  }\n\n  function setStakingRequirement(uint _amountOfTokens)\n  onlyAdministrator()\n  public\n  {\n    // This plane only goes one way, lads. Never below the initial.\n    require (_amountOfTokens >= 100e18);\n    stakingRequirement = _amountOfTokens;\n  }\n\n  function setName(string _name)\n  onlyAdministrator()\n  public\n  {\n    name = _name;\n  }\n\n  function setSymbol(string _symbol)\n  onlyAdministrator()\n  public\n  {\n    symbol = _symbol;\n  }\n\n  function changeBankroll(address _newBankrollAddress)\n  onlyAdministrator\n  public\n  {\n    bankrollAddress = _newBankrollAddress;\n  }\n\n  /*----------  HELPERS AND CALCULATORS  ----------*/\n\n  function totalEthereumBalance()\n  public\n  view\n  returns(uint)\n  {\n    return address(this).balance;\n  }\n\n  function totalEthereumICOReceived()\n  public\n  view\n  returns(uint)\n  {\n    return ethInvestedDuringICO;\n  }\n\n  /**\n   * Retrieves your currently selected dividend rate.\n   */\n  function getMyDividendRate()\n  public\n  view\n  returns(uint8)\n  {\n    address _customerAddress = msg.sender;\n    require(userSelectedRate[_customerAddress]);\n    return userDividendRate[_customerAddress];\n  }\n\n  /**\n   * Retrieve the total frontend token supply\n   */\n  function getFrontEndTokenSupply()\n  public\n  view\n  returns(uint)\n  {\n    return tokenSupply;\n  }\n\n  /**\n   * Retreive the total dividend token supply\n   */\n  function getDividendTokenSupply()\n  public\n  view\n  returns(uint)\n  {\n    return divTokenSupply;\n  }\n\n  /**\n   * Retrieve the frontend tokens owned by the caller\n   */\n  function myFrontEndTokens()\n  public\n  view\n  returns(uint)\n  {\n    address _customerAddress = msg.sender;\n    return getFrontEndTokenBalanceOf(_customerAddress);\n  }\n\n  /**\n   * Retrieve the dividend tokens owned by the caller\n   */\n  function myDividendTokens()\n  public\n  view\n  returns(uint)\n  {\n    address _customerAddress = msg.sender;\n    return getDividendTokenBalanceOf(_customerAddress);\n  }\n\n  function myReferralDividends()\n  public\n  view\n  returns(uint)\n  {\n    return myDividends(true) - myDividends(false);\n  }\n\n  function myDividends(bool _includeReferralBonus)\n  public\n  view\n  returns(uint)\n  {\n    address _customerAddress = msg.sender;\n    return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;\n  }\n\n  function theDividendsOf(bool _includeReferralBonus, address _customerAddress)\n  public\n  view\n  returns(uint)\n  {\n    return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;\n  }\n\n  function getFrontEndTokenBalanceOf(address _customerAddress)\n  view\n  public\n  returns(uint)\n  {\n    return frontTokenBalanceLedger_[_customerAddress];\n  }\n\n  function balanceOf(address _owner)\n  view\n  public\n  returns(uint)\n  {\n    return getFrontEndTokenBalanceOf(_owner);\n  }\n\n  function getDividendTokenBalanceOf(address _customerAddress)\n  view\n  public\n  returns(uint)\n  {\n    return dividendTokenBalanceLedger_[_customerAddress];\n  }\n\n  function dividendsOf(address _customerAddress)\n  view\n  public\n  returns(uint)\n  {\n    return (uint) ((int256)(profitPerDivToken * dividendTokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;\n  }\n\n  // Get the sell price at the user's average dividend rate\n  function sellPrice()\n  public\n  view\n  returns(uint)\n  {\n    uint price;\n\n    if (icoPhase || currentEthInvested < ethInvestedDuringICO) {\n      price = tokenPriceInitial_;\n    } else {\n\n      // Calculate the tokens received for 100 finney.\n      // Divide to find the average, to calculate the price.\n      uint tokensReceivedForEth = ethereumToTokens_(0.001 ether);\n\n      price = (1e18 * 0.001 ether) / tokensReceivedForEth;\n    }\n\n    // Factor in the user's average dividend rate\n    uint theSellPrice = price.sub((price.mul(getUserAverageDividendRate(msg.sender)).div(100)).div(magnitude));\n\n    return theSellPrice;\n  }\n\n  // Get the buy price at a particular dividend rate\n  function buyPrice(uint dividendRate)\n  public\n  view\n  returns(uint)\n  {\n    uint price;\n\n    if (icoPhase || currentEthInvested < ethInvestedDuringICO) {\n      price = tokenPriceInitial_;\n    } else {\n\n      // Calculate the tokens received for 100 finney.\n      // Divide to find the average, to calculate the price.\n      uint tokensReceivedForEth = ethereumToTokens_(0.001 ether);\n\n      price = (1e18 * 0.001 ether) / tokensReceivedForEth;\n    }\n\n    // Factor in the user's selected dividend rate\n    uint theBuyPrice = (price.mul(dividendRate).div(100)).add(price);\n\n    return theBuyPrice;\n  }\n\n  function calculateTokensReceived(uint _ethereumToSpend)\n  public\n  view\n  returns(uint)\n  {\n    uint _dividends      = (_ethereumToSpend.mul(userDividendRate[msg.sender])).div(100);\n    uint _taxedEthereum  = _ethereumToSpend.sub(_dividends);\n    uint _amountOfTokens = ethereumToTokens_(_taxedEthereum);\n    return  _amountOfTokens;\n  }\n\n  // When selling tokens, we need to calculate the user's current dividend rate.\n  // This is different from their selected dividend rate.\n  function calculateEthereumReceived(uint _tokensToSell)\n  public\n  view\n  returns(uint)\n  {\n    require(_tokensToSell <= tokenSupply);\n    uint _ethereum               = tokensToEthereum_(_tokensToSell);\n    uint userAverageDividendRate = getUserAverageDividendRate(msg.sender);\n    uint _dividends              = (_ethereum.mul(userAverageDividendRate).div(100)).div(magnitude);\n    uint _taxedEthereum          = _ethereum.sub(_dividends);\n    return  _taxedEthereum;\n  }\n\n  /*\n   * Get's a user's average dividend rate - which is just their divTokenBalance / tokenBalance\n   * We multiply by magnitude to avoid precision errors.\n   */\n\n  function getUserAverageDividendRate(address user) public view returns (uint) {\n    return (magnitude * dividendTokenBalanceLedger_[user]).div(frontTokenBalanceLedger_[user]);\n  }\n\n  function getMyAverageDividendRate() public view returns (uint) {\n    return getUserAverageDividendRate(msg.sender);\n  }\n\n  /*==========================================\n  =            INTERNAL FUNCTIONS            =\n  ==========================================*/\n\n  /* Purchase tokens with Ether.\n     During ICO phase, dividends should go to the bankroll\n     During normal operation:\n       0.5% should go to the master dividend card\n       0.5% should go to the matching dividend card\n       25% of dividends should go to the referrer, if any is provided. */\n  function purchaseTokens(uint _incomingEthereum, address _referredBy)\n  internal\n  returns(uint)\n  {\n    require(_incomingEthereum >= MIN_ETH_BUYIN || msg.sender == bankrollAddress, \"Tried to buy below the min eth buyin threshold.\");\n\n    uint toBankRoll;\n    uint toReferrer;\n    uint toTokenHolders;\n    uint toDivCardHolders;\n\n    uint dividendAmount;\n\n    uint tokensBought;\n    uint dividendTokensBought;\n\n    uint remainingEth = _incomingEthereum;\n\n    uint fee;\n\n    // 1% for dividend card holders is taken off before anything else\n    if (regularPhase) {\n      toDivCardHolders = _incomingEthereum.div(100);\n      remainingEth = remainingEth.sub(toDivCardHolders);\n    }\n\n    /* Next, we tax for dividends:\n       Dividends = (ethereum * div%) / 100\n       Important note: if we're out of the ICO phase, the 1% sent to div-card holders\n                       is handled prior to any dividend taxes are considered. */\n\n    // Grab the user's dividend rate\n    uint dividendRate = userDividendRate[msg.sender];\n\n    // Calculate the total dividends on this buy\n    dividendAmount = (remainingEth.mul(dividendRate)).div(100);\n\n    remainingEth   = remainingEth.sub(dividendAmount);\n\n    // If we're in the ICO and bankroll is buying, don't tax\n    if (icoPhase && msg.sender == bankrollAddress) {\n      remainingEth = remainingEth + dividendAmount;\n    }\n\n    // Calculate how many tokens to buy:\n    tokensBought         = ethereumToTokens_(remainingEth);\n    dividendTokensBought = tokensBought.mul(dividendRate);\n\n    // This is where we actually mint tokens:\n    tokenSupply    = tokenSupply.add(tokensBought);\n    divTokenSupply = divTokenSupply.add(dividendTokensBought);\n\n    /* Update the total investment tracker\n       Note that this must be done AFTER we calculate how many tokens are bought -\n       because ethereumToTokens needs to know the amount *before* investment, not *after* investment. */\n\n    currentEthInvested = currentEthInvested + remainingEth;\n\n    // If ICO phase, all the dividends go to the bankroll\n    if (icoPhase) {\n      toBankRoll     = dividendAmount;\n\n      // If the bankroll is buying, we don't want to send eth back to the bankroll\n      // Instead, let's just give it the tokens it would get in an infinite recursive buy\n      if (msg.sender == bankrollAddress) {\n        toBankRoll = 0;\n      }\n\n      toReferrer     = 0;\n      toTokenHolders = 0;\n\n      /* ethInvestedDuringICO tracks how much Ether goes straight to tokens,\n         not how much Ether we get total.\n         this is so that our calculation using \"investment\" is accurate. */\n      ethInvestedDuringICO = ethInvestedDuringICO + remainingEth;\n      tokensMintedDuringICO = tokensMintedDuringICO + tokensBought;\n\n      // Cannot purchase more than the hard cap during ICO.\n      require(ethInvestedDuringICO <= icoHardCap);\n      // Contracts aren't allowed to participate in the ICO.\n      require(tx.origin == msg.sender || msg.sender == bankrollAddress);\n\n      // Cannot purchase more then the limit per address during the ICO.\n      ICOBuyIn[msg.sender] += remainingEth;\n      require(ICOBuyIn[msg.sender] <= addressICOLimit || msg.sender == bankrollAddress);\n\n      // Stop the ICO phase if we reach the hard cap\n      if (ethInvestedDuringICO == icoHardCap){\n        icoPhase = false;\n      }\n\n    } else {\n      // Not ICO phase, check for referrals\n\n      // 25% goes to referrers, if set\n      // toReferrer = (dividends * 25)/100\n      if (_referredBy != 0x0000000000000000000000000000000000000000 &&\n      _referredBy != msg.sender &&\n      frontTokenBalanceLedger_[_referredBy] >= stakingRequirement)\n      {\n        toReferrer = (dividendAmount.mul(referrer_percentage)).div(100);\n        referralBalance_[_referredBy] += toReferrer;\n        emit Referral(_referredBy, toReferrer);\n      }\n\n      // The rest of the dividends go to token holders\n      toTokenHolders = dividendAmount.sub(toReferrer);\n\n      fee = toTokenHolders * magnitude;\n      fee = fee - (fee - (dividendTokensBought * (toTokenHolders * magnitude / (divTokenSupply))));\n\n      // Finally, increase the divToken value\n      profitPerDivToken       = profitPerDivToken.add((toTokenHolders.mul(magnitude)).div(divTokenSupply));\n      payoutsTo_[msg.sender] += (int256) ((profitPerDivToken * dividendTokensBought) - fee);\n    }\n\n    // Update the buyer's token amounts\n    frontTokenBalanceLedger_[msg.sender] = frontTokenBalanceLedger_[msg.sender].add(tokensBought);\n    dividendTokenBalanceLedger_[msg.sender] = dividendTokenBalanceLedger_[msg.sender].add(dividendTokensBought);\n\n    // Transfer to bankroll and div cards\n    if (toBankRoll != 0) { ZethrBankroll(bankrollAddress).receiveDividends.value(toBankRoll)(); }\n    if (regularPhase) { divCardContract.receiveDividends.value(toDivCardHolders)(dividendRate); }\n\n    // This event should help us track where all the eth is going\n    emit Allocation(toBankRoll, toReferrer, toTokenHolders, toDivCardHolders, remainingEth);\n\n    // Sanity checking\n    uint sum = toBankRoll + toReferrer + toTokenHolders + toDivCardHolders + remainingEth - _incomingEthereum;\n    assert(sum == 0);\n  }\n\n  // How many tokens one gets from a certain amount of ethereum.\n  function ethereumToTokens_(uint _ethereumAmount)\n  public\n  view\n  returns(uint)\n  {\n    require(_ethereumAmount > MIN_ETH_BUYIN, \"Tried to buy tokens with too little eth.\");\n\n    if (icoPhase) {\n      return _ethereumAmount.div(tokenPriceInitial_) * 1e18;\n    }\n\n    /*\n     *  i = investment, p = price, t = number of tokens\n     *\n     *  i_current = p_initial * t_current                   (for t_current <= t_initial)\n     *  i_current = i_initial + (2/3)(t_current)^(3/2)      (for t_current >  t_initial)\n     *\n     *  t_current = i_current / p_initial                   (for i_current <= i_initial)\n     *  t_current = t_initial + ((3/2)(i_current))^(2/3)    (for i_current >  i_initial)\n     */\n\n    // First, separate out the buy into two segments:\n    //  1) the amount of eth going towards ico-price tokens\n    //  2) the amount of eth going towards pyramid-price (variable) tokens\n    uint ethTowardsICOPriceTokens = 0;\n    uint ethTowardsVariablePriceTokens = 0;\n\n    if (currentEthInvested >= ethInvestedDuringICO) {\n      // Option One: All the ETH goes towards variable-price tokens\n      ethTowardsVariablePriceTokens = _ethereumAmount;\n\n    } else if (currentEthInvested < ethInvestedDuringICO && currentEthInvested + _ethereumAmount <= ethInvestedDuringICO) {\n      // Option Two: All the ETH goes towards ICO-price tokens\n      ethTowardsICOPriceTokens = _ethereumAmount;\n\n    } else if (currentEthInvested < ethInvestedDuringICO && currentEthInvested + _ethereumAmount > ethInvestedDuringICO) {\n      // Option Three: Some ETH goes towards ICO-price tokens, some goes towards variable-price tokens\n      ethTowardsICOPriceTokens = ethInvestedDuringICO.sub(currentEthInvested);\n      ethTowardsVariablePriceTokens = _ethereumAmount.sub(ethTowardsICOPriceTokens);\n    } else {\n      // Option Four: Should be impossible, and compiler should optimize it out of existence.\n      revert();\n    }\n\n    // Sanity check:\n    assert(ethTowardsICOPriceTokens + ethTowardsVariablePriceTokens == _ethereumAmount);\n\n    // Separate out the number of tokens of each type this will buy:\n    uint icoPriceTokens = 0;\n    uint varPriceTokens = 0;\n\n    // Now calculate each one per the above formulas.\n    // Note: since tokens have 18 decimals of precision we multiply the result by 1e18.\n    if (ethTowardsICOPriceTokens != 0) {\n      icoPriceTokens = ethTowardsICOPriceTokens.mul(1e18).div(tokenPriceInitial_);\n    }\n\n    if (ethTowardsVariablePriceTokens != 0) {\n      // Note: we can't use \"currentEthInvested\" for this calculation, we must use:\n      //  currentEthInvested + ethTowardsICOPriceTokens\n      // This is because a split-buy essentially needs to simulate two separate buys -\n      // including the currentEthInvested update that comes BEFORE variable price tokens are bought!\n\n      uint simulatedEthBeforeInvested = toPowerOfThreeHalves(tokenSupply.div(MULTIPLIER * 1e6)).mul(2).div(3) + ethTowardsICOPriceTokens;\n      uint simulatedEthAfterInvested  = simulatedEthBeforeInvested + ethTowardsVariablePriceTokens;\n\n      /* We have the equations for total tokens above; note that this is for TOTAL.\n         To get the number of tokens this purchase buys, use the simulatedEthInvestedBefore\n         and the simulatedEthInvestedAfter and calculate the difference in tokens.\n         This is how many we get. */\n\n      uint tokensBefore = toPowerOfTwoThirds(simulatedEthBeforeInvested.mul(3).div(2)).mul(MULTIPLIER);\n      uint tokensAfter  = toPowerOfTwoThirds(simulatedEthAfterInvested.mul(3).div(2)).mul(MULTIPLIER);\n\n      /* Note that we could use tokensBefore = tokenSupply + icoPriceTokens instead of dynamically calculating tokensBefore;\n         either should work.\n\n         Investment IS already multiplied by 1e18; however, because this is taken to a power of (2/3),\n         we need to multiply the result by 1e6 to get back to the correct number of decimals. */\n\n      varPriceTokens = (1e6) * tokensAfter.sub(tokensBefore);\n    }\n\n    uint totalTokensReceived = icoPriceTokens + varPriceTokens;\n\n    assert(totalTokensReceived > 0);\n    return totalTokensReceived;\n  }\n\n  // How much Ether we get from selling N tokens\n  function tokensToEthereum_(uint _tokens)\n  public\n  view\n  returns(uint)\n  {\n    require (_tokens >= MIN_TOKEN_SELL_AMOUNT, \"Tried to sell too few tokens.\");\n\n    /*\n     *  i = investment, p = price, t = number of tokens\n     *\n     *  i_current = p_initial * t_current                   (for t_current <= t_initial)\n     *  i_current = i_initial + (2/3)(t_current)^(3/2)      (for t_current >  t_initial)\n     *\n     *  t_current = i_current / p_initial                   (for i_current <= i_initial)\n     *  t_current = t_initial + ((3/2)(i_current))^(2/3)    (for i_current >  i_initial)\n     */\n\n    // First, separate out the sell into two segments:\n    //  1) the amount of tokens selling at the ICO price.\n    //  2) the amount of tokens selling at the variable (pyramid) price\n    uint tokensToSellAtICOPrice = 0;\n    uint tokensToSellAtVariablePrice = 0;\n\n    if (tokenSupply <= tokensMintedDuringICO) {\n      // Option One: All the tokens sell at the ICO price.\n      tokensToSellAtICOPrice = _tokens;\n\n    } else if (tokenSupply > tokensMintedDuringICO && tokenSupply - _tokens >= tokensMintedDuringICO) {\n      // Option Two: All the tokens sell at the variable price.\n      tokensToSellAtVariablePrice = _tokens;\n\n    } else if (tokenSupply > tokensMintedDuringICO && tokenSupply - _tokens < tokensMintedDuringICO) {\n      // Option Three: Some tokens sell at the ICO price, and some sell at the variable price.\n      tokensToSellAtVariablePrice = tokenSupply.sub(tokensMintedDuringICO);\n      tokensToSellAtICOPrice      = _tokens.sub(tokensToSellAtVariablePrice);\n\n    } else {\n      // Option Four: Should be impossible, and the compiler should optimize it out of existence.\n      revert();\n    }\n\n    // Sanity check:\n    assert(tokensToSellAtVariablePrice + tokensToSellAtICOPrice == _tokens);\n\n    // Track how much Ether we get from selling at each price function:\n    uint ethFromICOPriceTokens;\n    uint ethFromVarPriceTokens;\n\n    // Now, actually calculate:\n\n    if (tokensToSellAtICOPrice != 0) {\n\n      /* Here, unlike the sister equation in ethereumToTokens, we DON'T need to multiply by 1e18, since\n         we will be passed in an amount of tokens to sell that's already at the 18-decimal precision.\n         We need to divide by 1e18 or we'll have too much Ether. */\n\n      ethFromICOPriceTokens = tokensToSellAtICOPrice.mul(tokenPriceInitial_).div(1e18);\n    }\n\n    if (tokensToSellAtVariablePrice != 0) {\n\n      /* Note: Unlike the sister function in ethereumToTokens, we don't have to calculate any \"virtual\" token count.\n         This is because in sells, we sell the variable price tokens **first**, and then we sell the ICO-price tokens.\n         Thus there isn't any weird stuff going on with the token supply.\n\n         We have the equations for total investment above; note that this is for TOTAL.\n         To get the eth received from this sell, we calculate the new total investment after this sell.\n         Note that we divide by 1e6 here as the inverse of multiplying by 1e6 in ethereumToTokens. */\n\n      uint investmentBefore = toPowerOfThreeHalves(tokenSupply.div(MULTIPLIER * 1e6)).mul(2).div(3);\n      uint investmentAfter  = toPowerOfThreeHalves((tokenSupply - tokensToSellAtVariablePrice).div(MULTIPLIER * 1e6)).mul(2).div(3);\n\n      ethFromVarPriceTokens = investmentBefore.sub(investmentAfter);\n    }\n\n    uint totalEthReceived = ethFromVarPriceTokens + ethFromICOPriceTokens;\n\n    assert(totalEthReceived > 0);\n    return totalEthReceived;\n  }\n\n  function transferFromInternal(address _from, address _toAddress, uint _amountOfTokens, bytes _data)\n  internal\n  {\n    require(regularPhase);\n    require(_toAddress != address(0x0));\n    address _customerAddress     = _from;\n    uint _amountOfFrontEndTokens = _amountOfTokens;\n\n    // Withdraw all outstanding dividends first (including those generated from referrals).\n    if(theDividendsOf(true, _customerAddress) > 0) withdrawFrom(_customerAddress);\n\n    // Calculate how many back-end dividend tokens to transfer.\n    // This amount is proportional to the caller's average dividend rate multiplied by the proportion of tokens being transferred.\n    uint _amountOfDivTokens = _amountOfFrontEndTokens.mul(getUserAverageDividendRate(_customerAddress)).div(magnitude);\n\n    if (_customerAddress != msg.sender){\n      // Update the allowed balance.\n      // Don't update this if we are transferring our own tokens (via transfer or buyAndTransfer)\n      allowed[_customerAddress][msg.sender] -= _amountOfTokens;\n    }\n\n    // Exchange tokens\n    frontTokenBalanceLedger_[_customerAddress]    = frontTokenBalanceLedger_[_customerAddress].sub(_amountOfFrontEndTokens);\n    frontTokenBalanceLedger_[_toAddress]          = frontTokenBalanceLedger_[_toAddress].add(_amountOfFrontEndTokens);\n    dividendTokenBalanceLedger_[_customerAddress] = dividendTokenBalanceLedger_[_customerAddress].sub(_amountOfDivTokens);\n    dividendTokenBalanceLedger_[_toAddress]       = dividendTokenBalanceLedger_[_toAddress].add(_amountOfDivTokens);\n\n    // Recipient inherits dividend percentage if they have not already selected one.\n    if(!userSelectedRate[_toAddress])\n    {\n      userSelectedRate[_toAddress] = true;\n      userDividendRate[_toAddress] = userDividendRate[_customerAddress];\n    }\n\n    // Update dividend trackers\n    payoutsTo_[_customerAddress] -= (int256) (profitPerDivToken * _amountOfDivTokens);\n    payoutsTo_[_toAddress]       += (int256) (profitPerDivToken * _amountOfDivTokens);\n\n    uint length;\n\n    assembly {\n      length := extcodesize(_toAddress)\n    }\n\n    if (length > 0){\n      // its a contract\n      // note: at ethereum update ALL addresses are contracts\n      ERC223Receiving receiver = ERC223Receiving(_toAddress);\n      receiver.tokenFallback(_from, _amountOfTokens, _data);\n    }\n\n    // Fire logging event.\n    emit Transfer(_customerAddress, _toAddress, _amountOfFrontEndTokens);\n  }\n\n  // Called from transferFrom. Always checks if _customerAddress has dividends.\n  function withdrawFrom(address _customerAddress)\n  internal\n  {\n    // Setup data\n    uint _dividends                    = theDividendsOf(false, _customerAddress);\n\n    // update dividend tracker\n    payoutsTo_[_customerAddress]       +=  (int256) (_dividends * magnitude);\n\n    // add ref. bonus\n    _dividends                         += referralBalance_[_customerAddress];\n    referralBalance_[_customerAddress]  = 0;\n\n    _customerAddress.transfer(_dividends);\n\n    // Fire logging event.\n    emit onWithdraw(_customerAddress, _dividends);\n  }\n\n\n  /*=======================\n   =    RESET FUNCTIONS   =\n   ======================*/\n\n  function injectEther()\n  public\n  payable\n  onlyAdministrator\n  {\n\n  }\n\n  /*=======================\n   =   MATHS FUNCTIONS    =\n   ======================*/\n\n  function toPowerOfThreeHalves(uint x) public pure returns (uint) {\n    // m = 3, n = 2\n    // sqrt(x^3)\n    return sqrt(x**3);\n  }\n\n  function toPowerOfTwoThirds(uint x) public pure returns (uint) {\n    // m = 2, n = 3\n    // cbrt(x^2)\n    return cbrt(x**2);\n  }\n\n  function sqrt(uint x) public pure returns (uint y) {\n    uint z = (x + 1) / 2;\n    y = x;\n    while (z < y) {\n      y = z;\n      z = (x / z + z) / 2;\n    }\n  }\n\n  function cbrt(uint x) public pure returns (uint y) {\n    uint z = (x + 1) / 3;\n    y = x;\n    while (z < y) {\n      y = z;\n      z = (x / (z*z) + 2 * z) / 3;\n    }\n  }\n}\n\n/*=======================\n =     INTERFACES       =\n ======================*/\n\n\ncontract ZethrDividendCards {\n  function ownerOf(uint /*_divCardId*/) public pure returns (address) {}\n  function receiveDividends(uint /*_divCardRate*/) public payable {}\n}\n\ncontract ZethrBankroll{\n  function receiveDividends() public payable {}\n}\n\n\ncontract ERC223Receiving {\n  function tokenFallback(address _from, uint _amountOfTokens, bytes _data) public returns (bool);\n}\n\n// Think it's safe to say y'all know what this is.\n\nlibrary SafeMath {\n\n  function mul(uint a, uint b) internal pure returns (uint) {\n    if (a == 0) {\n      return 0;\n    }\n    uint c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function div(uint a, uint b) internal pure returns (uint) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  function sub(uint a, uint b) internal pure returns (uint) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint a, uint b) internal pure returns (uint) {\n    uint c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}",
  "bytecode": "68056bc75e2d6310000060005560c0604052600660808190527f466f72746973000000000000000000000000000000000000000000000000000060a09081526200004d9160019190620002ee565b506040805180820190915260048082527f49524f4e0000000000000000000000000000000000000000000000000000000060209092019182526200009491600291620002ee565b50600060118190556012556015805461ffff19169055348015620000b757600080fd5b506040516040806200303b833981016040908152815160209283015160038054600160a060020a03938416600160a060020a0319918216178255600480549385169390911692909217909155601484527fefffe042c54fd97a0f5176a14ff27fcc327c9b7bc562d3cc2e5ebc5dc43a383d805460ff1990811660019081179092557ff90f10d33459c03fd621f0d93120533d9108c0e72c8a63bf44905bbda5d611e980548216831790557f86058ce1b668267c95ae938fafb3fed6c535d9f4a2c97a5c123e1566d5f30400805482168317905533600090815285812080548316841790557f6add646517a5b0f6793cd5891b7937d28a5b2981a5d88ebc7cd776088fea904180548316841790557f91238f30f286c9a1c6e901c4eda3b214c381c846e3dbe48df95c21488e8e1fdb80548316841790557f586689db7536874b78a6eac0f58556a56a106985743f7c16a699b27bb02f88bd80548316841790557f8fab3b3b6d3bf24f9b00213fe8dda2fb1e188fcd88f523fcb711ff1f6aed59e380548316841790557fbb1110247bce6eaaf3cb168d5660645ab99866afefe1e7c6fa4388014157e5ba80548316841790557f18fd5681ae57cb24534810e7d412d5f5690a9c6f8b4cd1522e2df7c22ae0888680548316841790557f1e00437c059ded11d56fbc0f9acb2b99126636f749097c5c8224b228fcea6fe18054831684179055835485168152600987528581208054831690931790925591549092168252600a909352208054909116602117905562000393565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f106200033157805160ff191683800117855562000361565b8280016001018555821562000361579182015b828111156200036157825182559160200191906001019062000344565b506200036f92915062000373565b5090565b6200039091905b808211156200036f57600081556001016200037a565b90565b612c9880620003a36000396000f3006080604052600436106102de5763ffffffff7c010000000000000000000000000000000000000000000000000000000060003504166265318b811461036857806303d499ef1461039b57806306fdde03146103b0578063095ea7b31461043a5780630c3c450e1461047257806310d0ffdd1461048757806318160ddd1461049f57806319fb361f146104b45780631b1686b614610525578063214dda841461053a578063226093731461054f57806323b872dd14610567578063269a7c3f1461059157806327dffba6146105ab5780632a9121c7146105c0578063313ce567146105d85780633c7d6f30146106035780634b750334146106185780634c146f381461062d578063513920411461064e57806351cff8d91461066f57806356d399e8146106905780635c658165146106a55780635ccb5460146106cc5780636135e084146106e1578063627aa6d2146106f6578063677342ce1461075d578063688abbf71461077557806368955fb11461078f5780636a3a2119146107a45780636b2f4632146107ac57806370a08231146107c1578063724fcd4c146107e257806376be1585146108415780637b89eef2146108625780638328b6101461087757806387c950581461088f57806395d89b41146108b557806396242f411461049f578063965447d9146108ca578063a3a06c54146108e2578063a6d87f7d146108f7578063a78bcf6e1461090c578063a9059cbb1461092d578063b1f253f614610951578063b607068c14610977578063b84c82461461098c578063bcaa218e146109e5578063bf3b397b146109fa578063c47f002714610a12578063c4dbf62214610a6b578063ccb5336514610a83578063d161b56a14610a98578063e4849b3214610aad578063e9fad8ee14610ac5578063f088d54714610ada578063f2f8569f14610aee578063f42c56c214610b50578063f8ead7cf14610b68578063fdb5a03e14610b89578063fdc89f7314610b9e578063ffcb1edb14610bb6575b601554600090610100900460ff1615156102f757600080fd5b503360008181526009602052604090205460ff16156103215761031b346000610bcb565b50610365565b610363600060146040805190810160405280600381526020017f307830000000000000000000000000000000000000000000000000000000000081525061119f565b505b50005b34801561037457600080fd5b50610389600160a060020a0360043516611344565b60408051918252519081900360200190f35b3480156103a757600080fd5b5061038961137f565b3480156103bc57600080fd5b506103c5611386565b6040805160208082528351818301528351919283929083019185019080838360005b838110156103ff5781810151838201526020016103e7565b50505050905090810190601f16801561042c5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b34801561044657600080fd5b5061045e600160a060020a0360043516602435611413565b604080519115158252519081900360200190f35b34801561047e57600080fd5b50610389611480565b34801561049357600080fd5b506103896004356114a4565b3480156104ab57600080fd5b506103896114fb565b3480156104c057600080fd5b50604080516020601f60643560048181013592830184900484028501840190955281845261052394600160a060020a0381358116956024803590921695604435953695608494019181908401838280828437509497506115019650505050505050565b005b34801561053157600080fd5b506103896115c7565b34801561054657600080fd5b5061045e6115cd565b34801561055b57600080fd5b506103896004356115db565b34801561057357600080fd5b5061045e600160a060020a0360043581169060243516604435611646565b610523600160a060020a03600435811690602435166116ca565b3480156105b757600080fd5b506105236116de565b3480156105cc57600080fd5b5061038960043561170e565b3480156105e457600080fd5b506105ed61197c565b6040805160ff9092168252519081900360200190f35b34801561060f57600080fd5b50610523611981565b34801561062457600080fd5b506103896119b4565b34801561063957600080fd5b50610389600160a060020a0360043516611a57565b34801561065a57600080fd5b50610389600160a060020a0360043516611a72565b34801561067b57600080fd5b50610523600160a060020a0360043516611a8d565b34801561069c57600080fd5b50610389611b8e565b3480156106b157600080fd5b50610389600160a060020a0360043581169060243516611b94565b3480156106d857600080fd5b50610389611bb1565b3480156106ed57600080fd5b50610389611bb7565b604080516020600460443581810135601f8101849004840285018401909552848452610523948235600160a060020a03908116956024803590921695369594606494929301919081908401838280828437509497505050923560ff169350611bca92505050565b34801561076957600080fd5b50610389600435611ca3565b34801561078157600080fd5b506103896004351515611cde565b34801561079b57600080fd5b5061045e611d1f565b610523611d28565b3480156107b857600080fd5b50610389611d49565b3480156107cd57600080fd5b50610389600160a060020a0360043516611d4e565b604080516020600460443581810135601f8101849004840285018401909552848452610389948235600160a060020a0316946024803560ff169536959460649492019190819084018382808284375094975061119f9650505050505050565b34801561084d57600080fd5b5061045e600160a060020a0360043516611d5f565b34801561086e57600080fd5b50610389611d74565b34801561088357600080fd5b50610523600435611d84565b34801561089b57600080fd5b50610523600160a060020a03600435166024351515611dbe565b3480156108c157600080fd5b506103c5611e08565b3480156108d657600080fd5b50610389600435611e60565b3480156108ee57600080fd5b50610523611e6e565b34801561090357600080fd5b50610389611e99565b34801561091857600080fd5b50610523600160a060020a0360043516611eb5565b34801561093957600080fd5b5061045e600160a060020a0360043516602435611f03565b34801561095d57600080fd5b506103896004351515600160a060020a0360243516611f60565b34801561098357600080fd5b506105ed611f92565b34801561099857600080fd5b506040805160206004803580820135601f8101849004840285018401909552848452610523943694929360249392840191908190840183828082843750949750611fd39650505050505050565b3480156109f157600080fd5b50610389612004565b348015610a0657600080fd5b50610389600435612010565b348015610a1e57600080fd5b506040805160206004803580820135601f81018490048402850184019095528484526105239436949293602493928401919081908401838280828437509497506121d79650505050505050565b348015610a7757600080fd5b50610389600435612208565b348015610a8f57600080fd5b5061052361228d565b348015610aa457600080fd5b506103896122cc565b348015610ab957600080fd5b506105236004356122d2565b348015610ad157600080fd5b50610523612519565b610389600160a060020a0360043516612564565b604080516020600460443581810135601f8101849004840285018401909552848452610523948235600160a060020a03908116956024803590921695369594606494929301919081908401838280828437509497506125af9650505050505050565b348015610b5c57600080fd5b506103896004356125bc565b348015610b7457600080fd5b50610389600160a060020a03600435166125f6565b348015610b9557600080fd5b50610523612637565b348015610baa57600080fd5b50610389600435612703565b348015610bc257600080fd5b50610389612711565b600080600080600080600080600080600080655af3107a40008e101580610bfc5750600354600160a060020a031633145b1515610c8f57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602f60248201527f547269656420746f206275792062656c6f7720746865206d696e20657468206260448201527f7579696e207468726573686f6c642e0000000000000000000000000000000000606482015290519081900360840190fd5b6015548e9450610100900460ff1615610cc857610cb38e606463ffffffff61271716565b9750610cc5848963ffffffff61272e16565b93505b336000908152600a602052604090205460ff169150610cfe6064610cf2868563ffffffff61274016565b9063ffffffff61271716565b9650610d10848863ffffffff61272e16565b60155490945060ff168015610d2f5750600354600160a060020a031633145b15610d3957928601925b610d428461170e565b9550610d54868363ffffffff61274016565b601154909550610d6a908763ffffffff61276b16565b601155601254610d80908663ffffffff61276b16565b601255601080548501905560155460ff1615610e6957600354969a508a96600160a060020a0316331415610db35760009a505b600f8054850190819055600e80548801905560009a508a9950680d8d726b7177a800001015610de157600080fd5b32331480610df95750600354600160a060020a031633145b1515610e0457600080fd5b336000908152600d602052604090208054850190819055670de0b6b3a7640000101580610e3b5750600354600160a060020a031633145b1515610e4657600080fd5b680d8d726b7177a80000600f541415610e64576015805460ff191690555b610fb2565b600160a060020a038d1615801590610e8a5750600160a060020a038d163314155b8015610eaf575060008054600160a060020a038f168252600560205260409091205410155b15610f2557610eca6064610cf289601963ffffffff61274016565b600160a060020a038e166000818152600b6020908152604091829020805485019055815192835282018390528051929c507f5db31c63b6c985d138b0b2896458c45ecf94b259da29b7623bdef92b5853d0cd92918290030190a15b610f35878b63ffffffff61272e16565b601254909950680100000000000000008a02935083811515610f5357fe5b048502830383039250610f90610f81601254610cf2680100000000000000008d61274090919063ffffffff16565b6013549063ffffffff61276b16565b6013819055336000908152600c60205260409020805491870285900390910190555b33600090815260056020526040902054610fd2908763ffffffff61276b16565b33600090815260056020908152604080832093909355600690522054610ffe908663ffffffff61276b16565b336000908152600660205260409020558a1561109a57600360009054906101000a9004600160a060020a0316600160a060020a03166379fc46878c6040518263ffffffff167c01000000000000000000000000000000000000000000000000000000000281526004016000604051808303818588803b15801561108057600080fd5b505af1158015611094573d6000803e3d6000fd5b50505050505b601554610100900460ff161561112b5760048054604080517ff2c7d33100000000000000000000000000000000000000000000000000000000815292830185905251600160a060020a039091169163f2c7d331918b9160248082019260009290919082900301818588803b15801561111157600080fd5b505af1158015611125573d6000803e3d6000fd5b50505050505b604080518c8152602081018c90528082018b9052606081018a90526080810186905290517f7dcbb47dfce2f719d7e1984fd3345bbf7923b236005b64931d95b9205100de829181900360a00190a1508989018801870183018d9003801561118e57fe5b505050505050505050505092915050565b6015546000908190819060ff16806111be5750601554610100900460ff165b15156111c957600080fd5b60155460ff16156112a457836040518082805190602001908083835b602083106112045780518252601f1990920191602091820191016111e5565b5181516020939093036101000a600019018019909116921691909117905260405192018290039091209450507f5ddcde33b94b19bdef79dd9ea75be591942b9ec78286d64b44a356280fb6a2628414915081905061126c5750600354600160a060020a031633145b151561127757600080fd5b503a640ba43b740081118015906112995750680d8d726b7177a80000600f5411155b15156112a457600080fd5b60ff8086166000908152600860205260409020541615156112c457600080fd5b336000818152600960209081526040808320805460ff19908116600117909155600a835292819020805460ff8b1694168417905580519384529083019190915280517fc95fc9f67beb97905ada724494d1acfcaa30a3c96b432a0eac1824899f9f97c29281900390910190a161133a3487610bcb565b5050509392505050565b600160a060020a03166000908152600c6020908152604080832054600690925290912054601354680100000000000000009102919091030490565b600f545b90565b60018054604080516020600284861615610100026000190190941693909304601f8101849004840282018401909252818152929183018282801561140b5780601f106113e05761010080835404028352916020019161140b565b820191906000526020600020905b8154815290600101906020018083116113ee57829003601f168201915b505050505081565b336000818152600760209081526040808320600160a060020a03871680855290835281842086905581518681529151939493909284927f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925929081900390910190a3600191505b5092915050565b7f5ddcde33b94b19bdef79dd9ea75be591942b9ec78286d64b44a356280fb6a26281565b336000908152600a60205260408120548190819081906114d590606490610cf290889060ff1663ffffffff61274016565b92506114e7858463ffffffff61272e16565b91506114f28261170e565b95945050505050565b60115490565b600160a060020a038416331461157d576402540be400821015801561153e5750600160a060020a0384166000908152600560205260409020548211155b801561156d5750600160a060020a03841660009081526007602090815260408083203384529091529020548211155b151561157857600080fd5b6115b5565b6402540be40082101580156115aa5750600160a060020a0384166000908152600560205260409020548211155b15156115b557600080fd5b6115c18484848461277a565b50505050565b60105481565b601554610100900460ff1681565b600080600080600060115486111515156115f457600080fd5b6115fd86612010565b9350611608336125f6565b925061162a68010000000000000000610cf2606481888863ffffffff61274016565b915061163c848363ffffffff61272e16565b9695505050505050565b60008360606402540be40084108015906116785750600160a060020a0382166000908152600560205260409020548411155b80156116a75750600160a060020a03821660009081526007602090815260408083203384529091529020548411155b15156116b257600080fd5b6116be8686868461277a565b50600195945050505050565b60606116d98383836014611bca565b505050565b3360008181526014602052604090205460ff1615156116fc57600080fd5b506015805461ffff1916610100179055565b6000808080808080808080655af3107a40008b116117b357604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602860248201527f547269656420746f2062757920746f6b656e73207769746820746f6f206c697460448201527f746c65206574682e000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b60155460ff16156117e6576117d58b660251e66909d00063ffffffff61271716565b670de0b6b3a764000002995061196e565b600f5460105460009a508a995010611800578a9750611876565b600f546010541080156118195750600f548b6010540111155b15611826578a9850611876565b600f5460105410801561183e5750600f548b60105401115b1561187157601054600f546118589163ffffffff61272e16565b985061186a8b8a63ffffffff61272e16565b9750611876565b600080fd5b8888018b1461188157fe5b6000965086955088156118b4576118b1660251e66909d000610cf28b670de0b6b3a764000063ffffffff61274016565b96505b871561195c57886118f56003610cf260026118e96118e461258f620f42400260115461271790919063ffffffff16565b612703565b9063ffffffff61274016565b019450878501935061192161258f6118e961191c6002610cf28a600363ffffffff61274016565b611e60565b925061194261258f6118e961191c6002610cf289600363ffffffff61274016565b9150611954828463ffffffff61272e16565b620f42400295505b508585016000811161196a57fe5b8099505b505050505050505050919050565b601281565b601654621275000142118015611998575060165415155b15156119a357600080fd5b6015805461ffff1916610100179055565b60155460009081908190819060ff16806119d15750600f54601054105b156119e557660251e66909d0009250611a14565b6119f566038d7ea4c6800061170e565b9150816d314dc6448d9338c15b0a00000000811515611a1057fe5b0492505b611a4f611a4268010000000000000000610cf26064610cf2611a35336125f6565b899063ffffffff61274016565b849063ffffffff61272e16565b949350505050565b600160a060020a031660009081526005602052604090205490565b600160a060020a031660009081526006602052604090205490565b6000806000611a9c6001611cde565b11611aa657600080fd5b601554610100900460ff161515611abc57600080fd5b339150611ac96000611cde565b600160a060020a038084166000908152600c602090815260408083208054680100000000000000008702019055600b90915281208054919055909101915083161515611b13573392505b604051600160a060020a0384169082156108fc029083906000818181858888f19350505050158015611b49573d6000803e3d6000fd5b50604080518281529051600160a060020a038516917fccad973dcd043c7d680389db4378bd6b9775db7124092e9e0422c9e46d7985dc919081900360200190a2505050565b60005481565b600760209081526000928352604080842090915290825290205481565b600f5481565b600033611bc381611a72565b91505b5090565b6000806000601560019054906101000a900460ff161515611bea57600080fd5b33600081815260056020908152604080832054600990925290912054919450925060ff168015611c1b575060ff8416155b15611c3057611c2a3488610bcb565b50611c72565b611c7087856040805190810160405280600381526020017f307830000000000000000000000000000000000000000000000000000000000081525061119f565b505b33600090815260056020526040902054611c8c908361272e565b9050611c9a33878388611501565b50505050505050565b80600260018201045b81811015611cd8578091506002818285811515611cc557fe5b0401811515611cd057fe5b049050611cac565b50919050565b60003382611cf457611cef81611344565b611d18565b600160a060020a0381166000908152600b6020526040902054611d1682611344565b015b9392505050565b60155460ff1681565b3360008181526014602052604090205460ff161515611d4657600080fd5b50565b303190565b6000611d5982611a57565b92915050565b60146020526000908152604090205460ff1681565b6000611d7f336125f6565b905090565b3360008181526014602052604090205460ff161515611da257600080fd5b68056bc75e2d63100000821015611db857600080fd5b50600055565b3360008181526014602052604090205460ff161515611ddc57600080fd5b50600160a060020a03919091166000908152601460205260409020805460ff1916911515919091179055565b6002805460408051602060018416156101000260001901909316849004601f8101849004840282018401909252818152929183018282801561140b5780601f106113e05761010080835404028352916020019161140b565b6000611d596002830a6125bc565b3360008181526014602052604090205460ff161515611e8c57600080fd5b506015805460ff19169055565b6000611ea56000611cde565b611eaf6001611cde565b03905090565b3360008181526014602052604090205460ff161515611ed357600080fd5b506003805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b600060606000611f11612004565b11611f1b57600080fd5b6402540be4008310158015611f3f5750336000908152600560205260409020548311155b1515611f4a57600080fd5b611f563385858461277a565b5060019392505050565b600082611f7057611cef82611344565b600160a060020a0382166000908152600b6020526040902054611d1683611344565b3360008181526009602052604081205490919060ff161515611fb357600080fd5b600160a060020a03166000908152600a602052604090205460ff16919050565b3360008181526014602052604090205460ff161515611ff157600080fd5b81516116d9906002906020850190612bde565b600033611bc381611a57565b600080808080808080655af3107a400089101561208e57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f547269656420746f2073656c6c20746f6f2066657720746f6b656e732e000000604482015290519081900360640190fd5b600e5460115460009850889750116120a857889650612115565b600e546011541180156120c15750600e54896011540310155b156120ce57889550612115565b600e546011541180156120e65750600e548960115403105b1561187157600e546011546121009163ffffffff61272e16565b9550612112898763ffffffff61272e16565b96505b858701891461212057fe5b861561214c57612149670de0b6b3a7640000610cf289660251e66909d00063ffffffff61274016565b94505b85156121bd5761217b6003610cf260026118e96118e461258f620f42400260115461271790919063ffffffff16565b92506121a86003610cf260026118e96118e461258f620f4240028c6011540361271790919063ffffffff16565b91506121ba838363ffffffff61272e16565b93505b50828401600081116121cb57fe5b98975050505050505050565b3360008181526014602052604090205460ff1615156121f557600080fd5b81516116d9906001906020850190612bde565b60155460009081908190819060ff16806122255750600f54601054105b1561223957660251e66909d0009250612268565b61224966038d7ea4c6800061170e565b9150816d314dc6448d9338c15b0a0000000081151561226457fe5b0492505b6114f2836122816064610cf2838a63ffffffff61274016565b9063ffffffff61276b16565b3360008181526014602052604090205460ff1615156122ab57600080fd5b601654156122b857600080fd5b506015805460ff1916600117905542601655565b600e5481565b6000806000806000806000806122e6612004565b116122f057600080fd5b60155460ff161561230057600080fd5b601554610100900460ff16151561231657600080fd5b3360009081526005602052604090205488111561233257600080fd5b87965061233e336125f6565b95506802000000000000000086108015906123625750683200000000000000008611155b151561236d57600080fd5b61238a68010000000000000000610cf2898963ffffffff61274016565b945061239587612010565b93506010548411156123ab5760006010556123b5565b6010805485900390555b6123d368010000000000000000610cf26064610cf2611a35336125f6565b92506123e5848463ffffffff61272e16565b6011549092506123fb908863ffffffff61272e16565b601155601254612411908663ffffffff61272e16565b60125533600090815260056020526040902054612434908863ffffffff61272e16565b33600090815260056020908152604080832093909355600690522054612460908663ffffffff61272e16565b33600090815260066020908152604080832093909355601354600c90915291812080549288026801000000000000000086020192839003905560125491925010156124d5576124d16012546801000000000000000085028115156124c057fe5b60135491900463ffffffff61276b16565b6013555b6040805188815260208101849052815133927fc4823739c5787d2ca17e404aa47d5569ae71dfb49cbf21b3f6152ed238a31139928290030190a25050505050505050565b6015546000908190610100900460ff16151561253457600080fd5b5050336000818152600560205260408120549081111561255757612557816122d2565b61256082611a8d565b5050565b6015546000908190610100900460ff16151561257f57600080fd5b503360008181526009602052604090205460ff16151561259e57600080fd5b6125a83484610bcb565b5050919050565b6116d98383836014611bca565b80600360018201045b81811015611cd857809150600381600202828302858115156125e357fe5b04018115156125ee57fe5b0490506125c5565b600160a060020a0381166000908152600560209081526040808320546006909252822054611d5991680100000000000000009091029063ffffffff61271716565b6000806000806126476001611cde565b1161265157600080fd5b601554610100900460ff16151561266757600080fd5b6126716000611cde565b336000818152600c602090815260408083208054680100000000000000008702019055600b9091528120805490829055909201945092506126b3908490610bcb565b905081600160a060020a03167fbe339fc14b041c2b0e0f3dd2cd325d0c3668b78378001e53160eab36153264588483604051808381526020018281526020019250505060405180910390a2505050565b6000611d596003830a611ca3565b60125490565b600080828481151561272557fe5b04949350505050565b60008282111561273a57fe5b50900390565b6000808315156127535760009150611479565b5082820282848281151561276357fe5b0414611d1857fe5b600082820183811015611d1857fe5b6000806000806000601560019054906101000a900460ff16151561279d57600080fd5b600160a060020a03881615156127b257600080fd5b88945086935060006127c5600187611f60565b11156127d4576127d485612b24565b6127fa68010000000000000000610cf26127ed886125f6565b879063ffffffff61274016565b9250600160a060020a038516331461283757600160a060020a03851660009081526007602090815260408083203384529091529020805488900390555b600160a060020a038516600090815260056020526040902054612860908563ffffffff61272e16565b600160a060020a0380871660009081526005602052604080822093909355908a1681522054612895908563ffffffff61276b16565b600160a060020a03808a166000908152600560209081526040808320949094559188168152600690915220546128d1908463ffffffff61272e16565b600160a060020a0380871660009081526006602052604080822093909355908a1681522054612906908463ffffffff61276b16565b600160a060020a03891660009081526006602090815260408083209390935560099052205460ff16151561298057600160a060020a038089166000818152600960209081526040808320805460ff19908116600117909155948a168352600a909152808220549282529020805490921660ff919091161790555b60138054600160a060020a038781166000908152600c602052604080822080549489029094039093559254908b16835290822080549186029091019055883b9250821115612ace57506040517fc0ee0b8a000000000000000000000000000000000000000000000000000000008152600160a060020a0389811660048301908152602483018990526060604484019081528851606485015288518b949385169363c0ee0b8a938e938d938d9360840190602085019080838360005b83811015612a53578181015183820152602001612a3b565b50505050905090810190601f168015612a805780820380516001836020036101000a031916815260200191505b50945050505050602060405180830381600087803b158015612aa157600080fd5b505af1158015612ab5573d6000803e3d6000fd5b505050506040513d6020811015612acb57600080fd5b50505b87600160a060020a031685600160a060020a03167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef866040518082815260200191505060405180910390a3505050505050505050565b6000612b31600083611f60565b600160a060020a0383166000818152600c602090815260408083208054680100000000000000008702019055600b909152808220805490839055905193019350909183156108fc0291849190818181858888f19350505050158015612b9a573d6000803e3d6000fd5b50604080518281529051600160a060020a038416917fccad973dcd043c7d680389db4378bd6b9775db7124092e9e0422c9e46d7985dc919081900360200190a25050565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f10612c1f57805160ff1916838001178555612c4c565b82800160010185558215612c4c579182015b82811115612c4c578251825591602001919060010190612c31565b50611bc6926113839250905b80821115611bc65760008155600101612c585600a165627a7a72305820ecbadd67dfa297ed58555928663c93d5b1a267d30ce452d8b6399be4164014f50029000000000000000000000000818189b1a0ba4f9e543de04eb76669ec8354e12200000000000000000000000030699ca0288c96b5bd4f2b633b097889d59086d9",
  "constructorArguments": "000000000000000000000000818189b1a0ba4f9e543de04eb76669ec8354e12200000000000000000000000030699ca0288c96b5bd4f2b633b097889d59086d9"
}