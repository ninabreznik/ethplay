{
  "address": "0x6954354a6c94b2d5c4d1b8e40b4bee1e0615d72e",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "CryptoBoss",
  "compilerVersion": "v0.4.24+commit.e67f0147",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2018-06-06\n*/\n\npragma solidity ^0.4.17;\n\n/**\n * @title ERC721 interface\n * @dev see https://github.com/ethereum/eips/issues/721\n */\n\n/* solium-disable zeppelin/missing-natspec-comments */\ncontract ERC721 {\n  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n  function balanceOf(address _owner) public view returns (uint256 _balance);\n  function ownerOf(uint256 _tokenId) public view returns (address _owner);\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) public;\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;\n  function transfer(address _to, uint256 _tokenId) external;\n  function transferFrom(address _from, address _to, uint256 _tokenId) public;\n  function approve(address _to, uint256 _tokenId) external;\n  function setApprovalForAll(address _to, bool _approved) external;\n  function getApproved(uint256 _tokenId) public view returns (address);\n  function isApprovedForAll(address _owner, address _operator) public view returns (bool);\n}\n\ninterface ERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceID The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n\n/// @dev Note: the ERC-165 identifier for this interface is 0xf0b9e5ba\ninterface ERC721TokenReceiver {\n    /// @notice Handle the receipt of an NFT\n    /// @dev The ERC721 smart contract calls this function on the recipient\n    ///  after a `transfer`. This function MAY throw to revert and reject the\n    ///  transfer. This function MUST use 50,000 gas or less. Return of other\n    ///  than the magic value MUST result in the transaction being reverted.\n    ///  Note: the contract address is always the message sender.\n    /// @param _from The sending address\n    /// @param _tokenId The NFT identifier which is being transfered\n    /// @param _data Additional data with no specified format\n    /// @return `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`\n    ///  unless throwing\n  function onERC721Received(address _from, uint256 _tokenId, bytes _data) external returns(bytes4);\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  /**\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipRenounced(address indexed previousOwner);\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n  /**\n   * @dev Allows the current owner to relinquish control of the contract.\n   */\n  function renounceOwnership() public onlyOwner {\n    emit OwnershipRenounced(owner);\n    owner = address(0);\n  }\n}\nlibrary Strings {\n  // via https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.5.sol\n  function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n      bytes memory _ba = bytes(_a);\n      bytes memory _bb = bytes(_b);\n      bytes memory _bc = bytes(_c);\n      bytes memory _bd = bytes(_d);\n      bytes memory _be = bytes(_e);\n      string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n      bytes memory babcde = bytes(abcde);\n      uint k = 0;\n      for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n      for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n      for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n      for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n      for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n      return string(babcde);\n    }\n\n    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n        return strConcat(_a, _b, _c, _d, \"\");\n    }\n\n    function strConcat(string _a, string _b, string _c) internal pure returns (string) {\n        return strConcat(_a, _b, _c, \"\", \"\");\n    }\n\n    function strConcat(string _a, string _b) internal pure returns (string) {\n        return strConcat(_a, _b, \"\", \"\", \"\");\n    }\n\n    function uint2str(uint i) internal pure returns (string) {\n        if (i == 0) return \"0\";\n        uint j = i;\n        uint len;\n        while (j != 0){\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint k = len - 1;\n        while (i != 0){\n            bstr[k--] = byte(48 + i % 10);\n            i /= 10;\n        }\n        return string(bstr);\n    }\n}\n\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n///  Note: the ERC-165 identifier for this interface is 0x5b5e139f\ninterface ERC721Metadata /* is ERC721 */ {\n    /// @notice A descriptive name for a collection of NFTs in this contract\n    function name() external pure returns (string _name);\n\n    /// @notice An abbreviated name for NFTs in this contract\n    function symbol() external pure returns (string _symbol);\n\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n    ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\n    ///  Metadata JSON Schema\".\n    function tokenURI(uint256 _tokenId) external view returns (string);\n}\ncontract ERC721SlimToken is Ownable, ERC721, ERC165, ERC721Metadata {\n  using SafeMath for uint256;\n\n  string public constant NAME = \"EtherLoot\";\n  string public constant SYMBOL = \"ETLT\";\n  string public tokenMetadataBaseURI = \"http://api.etherloot.moonshadowgames.com/tokenmetadata/\";\n\n  struct AddressAndTokenIndex {\n    address owner;\n    uint32 tokenIndex;\n  }\n\n  mapping (uint256 => AddressAndTokenIndex) private tokenOwnerAndTokensIndex;\n\n  mapping (address => uint256[]) private ownedTokens;\n\n  mapping (uint256 => address) private tokenApprovals;\n\n  mapping (address => mapping (address => bool)) private operatorApprovals;\n\n  mapping (address => bool) private approvedContractAddresses;\n\n  bool approvedContractsFinalized = false;\n\n  function implementsERC721() external pure returns (bool) {\n    return true;\n  }\n\n\n\n  function supportsInterface(\n    bytes4 interfaceID)\n    external view returns (bool)\n  {\n    return\n      interfaceID == this.supportsInterface.selector || // ERC165\n      interfaceID == 0x5b5e139f || // ERC721Metadata\n      interfaceID == 0x6466353c; // ERC-721\n  }\n\n  function name() external pure returns (string) {\n    return NAME;\n  }\n\n  function symbol() external pure returns (string) {\n    return SYMBOL;\n  }\n\n  function setTokenMetadataBaseURI(string _tokenMetadataBaseURI) external onlyOwner {\n    tokenMetadataBaseURI = _tokenMetadataBaseURI;\n  }\n\n  function tokenURI(uint256 tokenId)\n    external\n    view\n    returns (string infoUrl)\n  {\n    return Strings.strConcat(\n      tokenMetadataBaseURI,\n      Strings.uint2str(tokenId));\n  }\n\n  /**\n  * @notice Guarantees msg.sender is owner of the given token\n  * @param _tokenId uint256 ID of the token to validate its ownership belongs to msg.sender\n  */\n  modifier onlyOwnerOf(uint256 _tokenId) {\n    require(ownerOf(_tokenId) == msg.sender, \"not owner\");\n    _;\n  }\n\n  /**\n  * @notice Gets the balance of the specified address\n  * @param _owner address to query the balance of\n  * @return uint256 representing the amount owned by the passed address\n  */\n  function balanceOf(address _owner) public view returns (uint256) {\n    require(_owner != address(0), \"null owner\");\n    return ownedTokens[_owner].length;\n  }\n\n  /**\n  * @notice Gets the list of tokens owned by a given address\n  * @param _owner address to query the tokens of\n  * @return uint256[] representing the list of tokens owned by the passed address\n  */\n  function tokensOf(address _owner) public view returns (uint256[]) {\n    return ownedTokens[_owner];\n  }\n\n  /**\n  * @notice Enumerate NFTs assigned to an owner\n  * @dev Throws if `_index` >= `balanceOf(_owner)` or if\n  *  `_owner` is the zero address, representing invalid NFTs.\n  * @param _owner An address where we are interested in NFTs owned by them\n  * @param _index A counter less than `balanceOf(_owner)`\n  * @return The token identifier for the `_index`th NFT assigned to `_owner`,\n  */\n  function tokenOfOwnerByIndex(address _owner, uint256 _index)\n    external\n    view\n    returns (uint256 _tokenId)\n  {\n    require(_index < balanceOf(_owner), \"invalid index\");\n    return ownedTokens[_owner][_index];\n  }\n\n  /**\n  * @notice Gets the owner of the specified token ID\n  * @param _tokenId uint256 ID of the token to query the owner of\n  * @return owner address currently marked as the owner of the given token ID\n  */\n  function ownerOf(uint256 _tokenId) public view returns (address) {\n    address _owner = tokenOwnerAndTokensIndex[_tokenId].owner;\n    require(_owner != address(0), \"invalid owner\");\n    return _owner;\n  }\n\n  function exists(uint256 _tokenId) public view returns (bool) {\n    address _owner = tokenOwnerAndTokensIndex[_tokenId].owner;\n    return (_owner != address(0));\n  }\n\n  /**\n   * @notice Gets the approved address to take ownership of a given token ID\n   * @param _tokenId uint256 ID of the token to query the approval of\n   * @return address currently approved to take ownership of the given token ID\n   */\n  function getApproved(uint256 _tokenId) public view returns (address) {\n    return tokenApprovals[_tokenId];\n  }\n\n  /**\n   * @notice Tells whether the msg.sender is approved to transfer the given token ID or not\n   * Checks both for specific approval and operator approval\n   * @param _tokenId uint256 ID of the token to query the approval of\n   * @return bool whether transfer by msg.sender is approved for the given token ID or not\n   */\n  function isSenderApprovedFor(uint256 _tokenId) internal view returns (bool) {\n    return\n      ownerOf(_tokenId) == msg.sender ||\n      isSpecificallyApprovedFor(msg.sender, _tokenId) ||\n      isApprovedForAll(ownerOf(_tokenId), msg.sender);\n  }\n\n  /**\n   * @notice Tells whether the msg.sender is approved for the given token ID or not\n   * @param _asker address of asking for approval\n   * @param _tokenId uint256 ID of the token to query the approval of\n   * @return bool whether the msg.sender is approved for the given token ID or not\n   */\n  function isSpecificallyApprovedFor(address _asker, uint256 _tokenId) internal view returns (bool) {\n    return getApproved(_tokenId) == _asker;\n  }\n\n  /**\n   * @notice Tells whether an operator is approved by a given owner\n   * @param _owner owner address which you want to query the approval of\n   * @param _operator operator address which you want to query the approval of\n   * @return bool whether the given operator is approved by the given owner\n   */\n  function isApprovedForAll(address _owner, address _operator) public view returns (bool)\n  {\n    return operatorApprovals[_owner][_operator];\n  }\n\n  /**\n  * @notice Transfers the ownership of a given token ID to another address\n  * @param _to address to receive the ownership of the given token ID\n  * @param _tokenId uint256 ID of the token to be transferred\n  */\n  function transfer(address _to, uint256 _tokenId)\n    external\n    onlyOwnerOf(_tokenId)\n  {\n    _clearApprovalAndTransfer(msg.sender, _to, _tokenId);\n  }\n\n  /**\n  * @notice Approves another address to claim for the ownership of the given token ID\n  * @param _to address to be approved for the given token ID\n  * @param _tokenId uint256 ID of the token to be approved\n  */\n  function approve(address _to, uint256 _tokenId)\n    external\n    onlyOwnerOf(_tokenId)\n  {\n    address _owner = ownerOf(_tokenId);\n    require(_to != _owner, \"already owns\");\n    if (getApproved(_tokenId) != 0 || _to != 0) {\n      tokenApprovals[_tokenId] = _to;\n      emit Approval(_owner, _to, _tokenId);\n    }\n  }\n\n  /**\n  * @notice Enable or disable approval for a third party (\"operator\") to manage all your assets\n  * @dev Emits the ApprovalForAll event\n  * @param _to Address to add to the set of authorized operators.\n  * @param _approved True if the operators is approved, false to revoke approval\n  */\n  function setApprovalForAll(address _to, bool _approved)\n    external\n  {\n    if(_approved) {\n      approveAll(_to);\n    } else {\n      disapproveAll(_to);\n    }\n  }\n\n  /**\n  * @notice Approves another address to claim for the ownership of any tokens owned by this account\n  * @param _to address to be approved for the given token ID\n  */\n  function approveAll(address _to)\n    public\n  {\n    require(_to != msg.sender, \"cant approve yourself\");\n    require(_to != address(0), \"invalid owner\");\n    operatorApprovals[msg.sender][_to] = true;\n    emit ApprovalForAll(msg.sender, _to, true);\n  }\n\n  /**\n  * @notice Removes approval for another address to claim for the ownership of any\n  *  tokens owned by this account.\n  * @dev Note that this only removes the operator approval and\n  *  does not clear any independent, specific approvals of token transfers to this address\n  * @param _to address to be disapproved for the given token ID\n  */\n  function disapproveAll(address _to)\n    public\n  {\n    require(_to != msg.sender, \"cant unapprove yourself\");\n    delete operatorApprovals[msg.sender][_to];\n    emit ApprovalForAll(msg.sender, _to, false);\n  }\n\n  /**\n  * @notice Claims the ownership of a given token ID\n  * @param _tokenId uint256 ID of the token being claimed by the msg.sender\n  */\n  function takeOwnership(uint256 _tokenId)\n   external\n  {\n    require(isSenderApprovedFor(_tokenId), \"not approved\");\n    _clearApprovalAndTransfer(ownerOf(_tokenId), msg.sender, _tokenId);\n  }\n\n  /**\n  * @notice Transfer a token owned by another address, for which the calling address has\n  *  previously been granted transfer approval by the owner.\n  * @param _from The address that owns the token\n  * @param _to The address that will take ownership of the token. Can be any address, including the caller\n  * @param _tokenId The ID of the token to be transferred\n  */\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId\n  )\n    public\n  {\n    address tokenOwner = ownerOf(_tokenId);\n    require(isSenderApprovedFor(_tokenId) || \n      (approvedContractAddresses[msg.sender] && tokenOwner == tx.origin), \"not an approved sender\");\n    require(tokenOwner == _from, \"wrong owner\");\n    _clearApprovalAndTransfer(ownerOf(_tokenId), _to, _tokenId);\n  }\n\n  /**\n  * @notice Transfers the ownership of an NFT from one address to another address\n  * @dev Throws unless `msg.sender` is the current owner, an authorized\n  * operator, or the approved address for this NFT. Throws if `_from` is\n  * not the current owner. Throws if `_to` is the zero address. Throws if\n  * `_tokenId` is not a valid NFT. When transfer is complete, this function\n  * checks if `_to` is a smart contract (code size > 0). If so, it calls\n  * `onERC721Received` on `_to` and throws if the return value is not\n  * `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`.\n  * @param _from The current owner of the NFT\n  * @param _to The new owner\n  * @param _tokenId The NFT to transfer\n  * @param _data Additional data with no specified format, sent in call to `_to`\n  */\n  function safeTransferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    bytes _data\n  )\n    public\n  {\n    require(_to != address(0), \"invalid target address\");\n    transferFrom(_from, _to, _tokenId);\n    if (_isContract(_to)) {\n      bytes4 tokenReceiverResponse = ERC721TokenReceiver(_to).onERC721Received.gas(50000)(\n        _from, _tokenId, _data\n      );\n      require(tokenReceiverResponse == bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\")), \"invalid receiver respononse\");\n    }\n  }\n\n  /*\n   * @notice Transfers the ownership of an NFT from one address to another address\n   * @dev This works identically to the other function with an extra data parameter,\n   *  except this function just sets data to \"\"\n   * @param _from The current owner of the NFT\n   * @param _to The new owner\n   * @param _tokenId The NFT to transfer\n  */\n  function safeTransferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId\n  )\n    external\n  {\n    safeTransferFrom(_from, _to, _tokenId, \"\");\n  }\n\n  /**\n  * @notice Approve a contract address for minting tokens and transferring tokens, when approved by the owner\n  * @param contractAddress The address that will be approved\n  */\n  function addApprovedContractAddress(address contractAddress) public onlyOwner\n  {\n    require(!approvedContractsFinalized);\n    approvedContractAddresses[contractAddress] = true;\n  }\n\n  /**\n  * @notice Unapprove a contract address for minting tokens and transferring tokens\n  * @param contractAddress The address that will be unapproved\n  */\n  function removeApprovedContractAddress(address contractAddress) public onlyOwner\n  {\n    require(!approvedContractsFinalized);\n    approvedContractAddresses[contractAddress] = false;\n  }\n\n  /**\n  * @notice Finalize the contract so it will be forever impossible to change the approved contracts list\n  */\n  function finalizeApprovedContracts() public onlyOwner {\n    approvedContractsFinalized = true;\n  }\n\n  /**\n  * @notice Mint token function\n  * @param _to The address that will own the minted token\n  * @param _tokenId uint256 ID of the token to be minted by the msg.sender\n  */\n  function mint(address _to, uint256 _tokenId) public {\n    require(\n      approvedContractAddresses[msg.sender] ||\n      msg.sender == owner, \"minter not approved\"\n    );\n    _mint(_to, _tokenId);\n  }\n\n  /**\n  * @notice Mint token function\n  * @param _to The address that will own the minted token\n  * @param _tokenId uint256 ID of the token to be minted by the msg.sender\n  */\n  function _mint(address _to, uint256 _tokenId) internal {\n    require(_to != address(0), \"invalid target address\");\n    require(tokenOwnerAndTokensIndex[_tokenId].owner == address(0), \"token already exists\");\n    _addToken(_to, _tokenId);\n    emit Transfer(0x0, _to, _tokenId);\n  }\n\n  /**\n  * @notice Internal function to clear current approval and transfer the ownership of a given token ID\n  * @param _from address which you want to send tokens from\n  * @param _to address which you want to transfer the token to\n  * @param _tokenId uint256 ID of the token to be transferred\n  */\n  function _clearApprovalAndTransfer(address _from, address _to, uint256 _tokenId) internal {\n    require(_to != address(0), \"invalid target address\");\n    require(_to != ownerOf(_tokenId), \"already owns\");\n    require(ownerOf(_tokenId) == _from, \"wrong owner\");\n\n    _clearApproval(_from, _tokenId);\n    _removeToken(_from, _tokenId);\n    _addToken(_to, _tokenId);\n    emit Transfer(_from, _to, _tokenId);\n  }\n\n  /**\n  * @notice Internal function to clear current approval of a given token ID\n  * @param _tokenId uint256 ID of the token to be transferred\n  */\n  function _clearApproval(address _owner, uint256 _tokenId) private {\n    require(ownerOf(_tokenId) == _owner, \"wrong owner\");\n    if (tokenApprovals[_tokenId] != 0) {\n      tokenApprovals[_tokenId] = 0;\n      emit Approval(_owner, 0, _tokenId);\n    }\n  }\n\n  /**\n  * @notice Internal function to add a token ID to the list of a given address\n  * @param _to address representing the new owner of the given token ID\n  * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\n  */\n  function _addToken(address _to, uint256 _tokenId) private {\n    uint256 newTokenIndex = ownedTokens[_to].length;\n    ownedTokens[_to].push(_tokenId);\n\n    // I don't expect anyone to own 4 billion tokens, but just in case...\n    require(newTokenIndex == uint256(uint32(newTokenIndex)), \"overflow\");\n\n    tokenOwnerAndTokensIndex[_tokenId] = AddressAndTokenIndex({owner: _to, tokenIndex: uint32(newTokenIndex)});\n  }\n\n  /**\n  * @notice Internal function to remove a token ID from the list of a given address\n  * @param _from address representing the previous owner of the given token ID\n  * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\n  */\n  function _removeToken(address _from, uint256 _tokenId) private {\n    require(ownerOf(_tokenId) == _from, \"wrong owner\");\n\n    uint256 tokenIndex = tokenOwnerAndTokensIndex[_tokenId].tokenIndex;\n    uint256 lastTokenIndex = ownedTokens[_from].length.sub(1);\n    uint256 lastToken = ownedTokens[_from][lastTokenIndex];\n\n    ownedTokens[_from][tokenIndex] = lastToken;\n\n    ownedTokens[_from].length--;\n    tokenOwnerAndTokensIndex[lastToken] = AddressAndTokenIndex({owner: _from, tokenIndex: uint32(tokenIndex)});\n  }\n\n  function _isContract(address addr) internal view returns (bool) {\n    uint size;\n    assembly { size := extcodesize(addr) }\n    return size > 0;\n  }\n}\n/**\n * @title Math\n * @dev Assorted math operations\n */\nlibrary Math {\n  function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n    return a >= b ? a : b;\n  }\n\n  function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n    return a < b ? a : b;\n  }\n\n  function max256(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a >= b ? a : b;\n  }\n\n  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a < b ? a : b;\n  }\n\n  function smax256(int256 a, int256 b) internal pure returns (int256) {\n    return a >= b ? a : b;\n  }\n}\n\ncontract ContractAccessControl {\n\n  event ContractUpgrade(address newContract);\n  event Paused();\n  event Unpaused();\n\n  address public ceoAddress;\n\n  address public cfoAddress;\n\n  address public cooAddress;\n\n  address public withdrawalAddress;\n\n  bool public paused = false;\n\n  modifier onlyCEO() {\n    require(msg.sender == ceoAddress);\n    _;\n  }\n\n  modifier onlyCFO() {\n    require(msg.sender == cfoAddress);\n    _;\n  }\n\n  modifier onlyCOO() {\n    require(msg.sender == cooAddress);\n    _;\n  }\n\n  modifier onlyCLevel() {\n    require(\n      msg.sender == cooAddress ||\n      msg.sender == ceoAddress ||\n      msg.sender == cfoAddress\n    );\n    _;\n  }\n\n  modifier onlyCEOOrCFO() {\n    require(\n      msg.sender == cfoAddress ||\n      msg.sender == ceoAddress\n    );\n    _;\n  }\n\n  modifier onlyCEOOrCOO() {\n    require(\n      msg.sender == cooAddress ||\n      msg.sender == ceoAddress\n    );\n    _;\n  }\n\n  function setCEO(address _newCEO) external onlyCEO {\n    require(_newCEO != address(0));\n    ceoAddress = _newCEO;\n  }\n\n  function setCFO(address _newCFO) external onlyCEO {\n    require(_newCFO != address(0));\n    cfoAddress = _newCFO;\n  }\n\n  function setCOO(address _newCOO) external onlyCEO {\n    require(_newCOO != address(0));\n    cooAddress = _newCOO;\n  }\n\n  function setWithdrawalAddress(address _newWithdrawalAddress) external onlyCEO {\n    require(_newWithdrawalAddress != address(0));\n    withdrawalAddress = _newWithdrawalAddress;\n  }\n\n  function withdrawBalance() external onlyCEOOrCFO {\n    require(withdrawalAddress != address(0));\n    withdrawalAddress.transfer(this.balance);\n  }\n\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  function pause() public onlyCLevel whenNotPaused {\n    paused = true;\n    emit Paused();\n  }\n\n  function unpause() public onlyCEO whenPaused {\n    paused = false;\n    emit Unpaused();\n  }\n}\n\ncontract CryptoBoss is ContractAccessControl {\n\n  address constant tokenContractAddress = 0xe1015a79a7d488f8fecf073b187d38c6f1a77368;\n  ERC721SlimToken constant tokenContract = ERC721SlimToken(tokenContractAddress);\n\n  event Participating(address indexed player, uint encounterId);\n  event LootClaimed(address indexed player, uint encounterId);\n  event DailyLootClaimed(uint day);\n\n  struct ParticipantData {\n    uint32 damage;\n    uint64 cumulativeDamage;\n    uint8 forgeWeaponRarity;\n    uint8 forgeWeaponDamagePure;\n    bool lootClaimed;\n    bool consolationPrizeClaimed;\n  }\n\n  struct Encounter {\n    mapping (address => ParticipantData) participantData;\n    address[] participants;\n  }\n\n  //encounterId is the starting block number / encounterBlockDuration\n  mapping (uint => Encounter) encountersById;\n\n  mapping (uint => address) winnerPerDay;\n  mapping (uint => mapping (address => uint)) dayToAddressToScore;\n  mapping (uint => bool) dailyLootClaimedPerDay;\n\n   uint constant encounterBlockDuration = 80;\n   uint constant blocksInADay = 5760;\n\n//   uint constant encounterBlockDuration = 20;\n//   uint constant blocksInADay = 60;    // must be a multiple of encounterBlockDuration\n\n  uint256 gasRefundForClaimLoot = 279032000000000;\n  uint256 gasRefundForClaimConsolationPrizeLoot = 279032000000000;\n  uint256 gasRefundForClaimLootWithConsolationPrize = 279032000000000;\n\n  uint participateFee = 0.002 ether;\n  uint participateDailyLootContribution = 0.001 ether;\n\n  constructor() public {\n\n    paused = false;\n\n    ceoAddress = msg.sender;\n    cooAddress = msg.sender;\n    cfoAddress = msg.sender;\n    withdrawalAddress = msg.sender;\n  }\n  \n  function setGasRefundForClaimLoot(uint256 _gasRefundForClaimLoot) external onlyCEO {\n      gasRefundForClaimLoot = _gasRefundForClaimLoot;\n  }\n\n  function setGasRefundForClaimConsolationPrizeLoot(uint256 _gasRefundForClaimConsolationPrizeLoot) external onlyCEO {\n      gasRefundForClaimConsolationPrizeLoot = _gasRefundForClaimConsolationPrizeLoot;\n  }\n\n  function setGasRefundForClaimLootWithConsolationPrize(uint256 _gasRefundForClaimLootWithConsolationPrize) external onlyCEO {\n      gasRefundForClaimLootWithConsolationPrize = _gasRefundForClaimLootWithConsolationPrize;\n  }\n\n  function setParticipateFee(uint _participateFee) public onlyCLevel {\n    participateFee = _participateFee;\n  }\n\n  function setParticipateDailyLootContribution(uint _participateDailyLootContribution) public onlyCLevel {\n    participateDailyLootContribution = _participateDailyLootContribution;\n  }\n\n  function getFirstEncounterIdFromDay(uint day) internal pure returns (uint) {\n    return (day * blocksInADay) / encounterBlockDuration;\n  }\n\n  function leaderboardEntries(uint day) public view returns\n    (uint etherPot, bool dailyLootClaimed, uint blockDeadline, address[] memory entryAddresses, uint[] memory entryDamages) {    \n\n    dailyLootClaimed = dailyLootClaimedPerDay[day];\n    blockDeadline = (((day+1) * blocksInADay) / encounterBlockDuration) * encounterBlockDuration;\n\n    uint participantCount = 0;\n    etherPot = 0;\n\n    for (uint encounterId = getFirstEncounterIdFromDay(day); encounterId < getFirstEncounterIdFromDay(day+1); encounterId++)\n    {\n      address[] storage participants = encountersById[encounterId].participants;\n      participantCount += participants.length;\n      etherPot += participateDailyLootContribution * participants.length;\n    }\n\n    entryAddresses = new address[](participantCount);\n    entryDamages = new uint[](participantCount);\n\n    participantCount = 0;\n\n    for (encounterId = getFirstEncounterIdFromDay(day); encounterId < getFirstEncounterIdFromDay(day+1); encounterId++)\n    {\n      participants = encountersById[encounterId].participants;\n      mapping (address => ParticipantData) participantData = encountersById[encounterId].participantData;\n      for (uint i = 0; i < participants.length; i++)\n      {\n        address participant = participants[i];\n        entryAddresses[participantCount] = participant;\n        entryDamages[participantCount] = participantData[participant].damage;\n        participantCount++;\n      }\n    }\n  }\n\n  function claimDailyLoot(uint day) public {\n    require(!dailyLootClaimedPerDay[day]);\n    require(winnerPerDay[day] == msg.sender);\n\n    uint firstEncounterId = day * blocksInADay / encounterBlockDuration;\n    uint firstEncounterIdTomorrow = ((day+1) * blocksInADay / encounterBlockDuration);\n    uint etherPot = 0;\n    for (uint encounterId = firstEncounterId; encounterId < firstEncounterIdTomorrow; encounterId++)\n    {\n      etherPot += participateDailyLootContribution * encountersById[encounterId].participants.length;\n    }\n\n    dailyLootClaimedPerDay[day] = true;\n\n    msg.sender.transfer(etherPot);\n\n    emit DailyLootClaimed(day);\n  }\n\n  function blockBeforeEncounter(uint encounterId) private pure returns (uint) {\n    return encounterId*encounterBlockDuration - 1;\n  }\n\n  function getEncounterDetails() public view\n    returns (uint encounterId, uint encounterFinishedBlockNumber, bool isParticipating, uint day, uint monsterDna) {\n    encounterId = block.number / encounterBlockDuration;\n    encounterFinishedBlockNumber = (encounterId+1) * encounterBlockDuration;\n    Encounter storage encounter = encountersById[encounterId];\n    isParticipating = (encounter.participantData[msg.sender].damage != 0);\n    day = (encounterId * encounterBlockDuration) / blocksInADay;\n    monsterDna = uint(blockhash(blockBeforeEncounter(encounterId)));\n  }\n\n  function getParticipants(uint encounterId) public view returns (address[]) {\n\n    Encounter storage encounter = encountersById[encounterId];\n    return encounter.participants;\n  }\n\n  function calculateWinner(uint numParticipants, Encounter storage encounter, uint blockToHash) internal view returns\n    (address winnerAddress, uint rand, uint totalDamageDealt) {\n\n    if (numParticipants == 0) {\n      return;\n    }\n\n    totalDamageDealt = encounter.participantData[encounter.participants[numParticipants-1]].cumulativeDamage;\n\n    rand = uint(keccak256(blockhash(blockToHash)));\n    uint winnerDamageValue = rand % totalDamageDealt;\n\n    uint winnerIndex = numParticipants;\n\n    // binary search for a value winnerIndex where\n    // winnerDamageValue < cumulativeDamage[winnerIndex] and \n    // winnerDamageValue >= cumulativeDamage[winnerIndex-1]\n\n    uint min = 0;\n    uint max = numParticipants - 1;\n    while(max >= min) {\n      uint guess = (min+max)/2;\n      if (guess > 0 && winnerDamageValue < encounter.participantData[encounter.participants[guess-1]].cumulativeDamage) {\n        max = guess-1;\n      }\n      else if (winnerDamageValue >= encounter.participantData[encounter.participants[guess]].cumulativeDamage) {\n        min = guess+1;\n      } else {\n        winnerIndex = guess;\n        break;\n      }\n\n    }\n\n    require(winnerIndex < numParticipants, \"error in binary search\");\n\n    winnerAddress = encounter.participants[winnerIndex];\n  }\n\n  function getBlockToHashForResults(uint encounterId) public view returns (uint) {\n      \n    uint blockToHash = (encounterId+1)*encounterBlockDuration - 1;\n    \n    require(block.number > blockToHash);\n    \n    uint diff = block.number - (blockToHash+1);\n    if (diff > 255) {\n        blockToHash += (diff/256)*256;\n    }\n    \n    return blockToHash;\n  }\n  \n  function getEncounterResults(uint encounterId, address player) public view returns (\n    address winnerAddress, uint lootTokenId, uint consolationPrizeTokenId,\n    bool lootClaimed, uint damageDealt, uint totalDamageDealt) {\n\n    uint blockToHash = getBlockToHashForResults(encounterId);\n\n    Encounter storage encounter = encountersById[encounterId];\n    uint numParticipants = encounter.participants.length;\n    if (numParticipants == 0) {\n      return (address(0), 0, 0, false, 0, 0);\n    }\n\n    damageDealt = encounter.participantData[player].damage;\n\n    uint rand;\n    (winnerAddress, rand, totalDamageDealt) = calculateWinner(numParticipants, encounter, blockToHash);\n\n    lootTokenId = constructWeaponTokenIdForWinner(rand, numParticipants);\n\n    lootClaimed = true;\n    consolationPrizeTokenId = getConsolationPrizeTokenId(encounterId, player);\n\n    if (consolationPrizeTokenId != 0) {\n        lootClaimed = encounter.participantData[player].consolationPrizeClaimed;\n        \n        // This way has problems:\n    //   lootClaimed = tokenContract.exists(consolationPrizeTokenId);\n    }\n  }\n  \n    function getLootClaimed(uint encounterId, address player) external view returns (bool, bool) {\n        ParticipantData memory participantData = encountersById[encounterId].participantData[player];\n        return (\n            participantData.lootClaimed,\n            participantData.consolationPrizeClaimed\n        );\n    }\n\n  function constructWeaponTokenIdForWinner(uint rand, uint numParticipants) pure internal returns (uint) {\n\n    uint rarity = 0;\n    if (numParticipants > 1) rarity = 1;\n    if (numParticipants > 10) rarity = 2;\n\n    return constructWeaponTokenId(rand, rarity, 0);\n  }\n\n  function getWeaponRarityFromTokenId(uint tokenId) pure internal returns (uint) {\n    return tokenId & 0xff;\n  }  \n\n  // damageType: 0=physical 1=magic 2=water 3=earth 4=fire\n  function getWeaponDamageFromTokenId(uint tokenId, uint damageType) pure internal returns (uint) {\n    return ((tokenId >> (64 + damageType*8)) & 0xff);\n  }  \n\n  function getPureWeaponDamageFromTokenId(uint tokenId) pure internal returns (uint) {\n    return ((tokenId >> (56)) & 0xff);\n  }  \n\n  function getMonsterDefenseFromDna(uint monsterDna, uint damageType) pure internal returns (uint) {\n    return ((monsterDna >> (64 + damageType*8)) & 0xff);\n  }\n\n\n  // constant lookup table\n\n  bytes10 constant elementsAvailableForCommon =     hex\"01020408100102040810\";   // Each byte has 1 bit set\n  bytes10 constant elementsAvailableForRare =       hex\"030506090A0C11121418\";   // Each byte has 2 bits set\n  bytes10 constant elementsAvailableForEpic =       hex\"070B0D0E131516191A1C\";   // 3 bits\n  bytes10 constant elementsAvailableForLegendary =  hex\"0F171B1D1E0F171B1D1E\";   // 4 bits\n\n  // rarity 0: common (1 element)\n  // rarity 1: rare (2 elements)\n  // rarity 2: epic (3 elements)\n  // rarity 3: legendary (4 elements)\n  // rarity 4: ultimate (all 5 elements)\n  function constructWeaponTokenId(uint rand, uint rarity, uint pureDamage) pure internal returns (uint) {\n    uint lootTokenId = (rand & 0xffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000) + rarity;\n\n    bytes10[4] memory elementsAvailablePerRarity = [\n      elementsAvailableForCommon,\n      elementsAvailableForRare,\n      elementsAvailableForEpic,\n      elementsAvailableForLegendary\n      ];\n\n    bytes10 elementsAvailable = elementsAvailablePerRarity[rarity];\n    // Select a random byte in elementsAvailable\n    uint8 elementsUsed = uint8(elementsAvailable[((rand >> 104) & 0xffff) % 10]);\n    // The bits of elementsUsed represent which elements we will allow this weapon to deal damage for\n    // Zero out the other element damages\n    for (uint i = 0; i < 5; i++) {\n      if ((elementsUsed & (1 << i)) == 0) {\n        lootTokenId = lootTokenId & ~(0xff << (64 + i*8));\n      }\n    }\n\n    pureDamage = Math.min256(100, pureDamage);\n\n    lootTokenId = lootTokenId | (pureDamage << 56);\n\n    return lootTokenId;\n  }\n\n  function weaponTokenIdToDamageForEncounter(uint weaponTokenId, uint encounterId) view internal returns (uint) {\n    uint monsterDna = uint(blockhash(encounterId*encounterBlockDuration - 1));\n\n    uint physicalDamage = uint(Math.smax256(0, int(getWeaponDamageFromTokenId(weaponTokenId, 0)) - int(getMonsterDefenseFromDna(monsterDna, 0))));\n    uint fireDamage = uint(Math.smax256(0, int(getWeaponDamageFromTokenId(weaponTokenId, 4)) - int(getMonsterDefenseFromDna(monsterDna, 4))));\n    uint earthDamage = uint(Math.smax256(0, int(getWeaponDamageFromTokenId(weaponTokenId, 3)) - int(getMonsterDefenseFromDna(monsterDna, 3))));\n    uint waterDamage = uint(Math.smax256(0, int(getWeaponDamageFromTokenId(weaponTokenId, 2)) - int(getMonsterDefenseFromDna(monsterDna, 2))));\n    uint magicDamage = uint(Math.smax256(0, int(getWeaponDamageFromTokenId(weaponTokenId, 1)) - int(getMonsterDefenseFromDna(monsterDna, 1))));\n    uint pureDamage = getPureWeaponDamageFromTokenId(weaponTokenId);\n\n    uint damage = physicalDamage + fireDamage + earthDamage + waterDamage + magicDamage + pureDamage;\n    damage = Math.max256(1, damage);\n\n    return damage;\n  }\n\n  function forgeWeaponPureDamage(uint sacrificeTokenId1, uint sacrificeTokenId2, uint sacrificeTokenId3, uint sacrificeTokenId4)\n    internal pure returns (uint8) {\n    if (sacrificeTokenId1 == 0) {\n      return 0;\n    }\n    return uint8(Math.min256(255,\n        getPureWeaponDamageFromTokenId(sacrificeTokenId1) +\n        getPureWeaponDamageFromTokenId(sacrificeTokenId2) +\n        getPureWeaponDamageFromTokenId(sacrificeTokenId3) +\n        getPureWeaponDamageFromTokenId(sacrificeTokenId4)));\n  }\n\n  function forgeWeaponRarity(uint sacrificeTokenId1, uint sacrificeTokenId2, uint sacrificeTokenId3, uint sacrificeTokenId4)\n    internal pure returns (uint8) {\n    if (sacrificeTokenId1 == 0) {\n      return 0;\n    }\n    uint rarity = getWeaponRarityFromTokenId(sacrificeTokenId1);\n    rarity = Math.min256(rarity, getWeaponRarityFromTokenId(sacrificeTokenId2));\n    rarity = Math.min256(rarity, getWeaponRarityFromTokenId(sacrificeTokenId3));\n    rarity = Math.min256(rarity, getWeaponRarityFromTokenId(sacrificeTokenId4)) + 1;\n    require(rarity < 5, \"cant forge an ultimate weapon\");\n    return uint8(rarity);\n  }\n\n  function participate(uint encounterId, uint weaponTokenId,\n    uint sacrificeTokenId1, uint sacrificeTokenId2, uint sacrificeTokenId3, uint sacrificeTokenId4) public whenNotPaused payable {\n    require(msg.value >= participateFee);  // half goes to dev, half goes to ether pot\n\n    require(encounterId == block.number / encounterBlockDuration, \"a new encounter is available\");\n\n    Encounter storage encounter = encountersById[encounterId];\n\n    require(encounter.participantData[msg.sender].damage == 0, \"you are already participating\");\n\n    uint damage = 1;\n    // weaponTokenId of zero means they are using their fists\n    if (weaponTokenId != 0) {\n      require(tokenContract.ownerOf(weaponTokenId) == msg.sender, \"you dont own that weapon\");\n      damage = weaponTokenIdToDamageForEncounter(weaponTokenId, encounterId);\n    }\n\n    uint day = (encounterId * encounterBlockDuration) / blocksInADay;\n    uint newScore = dayToAddressToScore[day][msg.sender] + damage;\n    dayToAddressToScore[day][msg.sender] = newScore;\n\n    if (newScore > dayToAddressToScore[day][winnerPerDay[day]] &&\n      winnerPerDay[day] != msg.sender) {\n      winnerPerDay[day] = msg.sender;\n    }\n\n    uint cumulativeDamage = damage;\n    if (encounter.participants.length > 0) {\n      cumulativeDamage = cumulativeDamage + encounter.participantData[encounter.participants[encounter.participants.length-1]].cumulativeDamage;\n    }\n\n    if (sacrificeTokenId1 != 0) {\n\n      // the requires in the transfer functions here will verify\n      // that msg.sender owns all of these tokens and they are unique\n\n      // burn all four input tokens\n\n      tokenContract.transferFrom(msg.sender, 1, sacrificeTokenId1);\n      tokenContract.transferFrom(msg.sender, 1, sacrificeTokenId2);\n      tokenContract.transferFrom(msg.sender, 1, sacrificeTokenId3);\n      tokenContract.transferFrom(msg.sender, 1, sacrificeTokenId4);\n    }\n\n    encounter.participantData[msg.sender] = ParticipantData(uint32(damage), uint64(cumulativeDamage), \n      forgeWeaponRarity(sacrificeTokenId1, sacrificeTokenId2, sacrificeTokenId3, sacrificeTokenId4),\n      forgeWeaponPureDamage(sacrificeTokenId1, sacrificeTokenId2, sacrificeTokenId3, sacrificeTokenId4),\n      false, false);\n    encounter.participants.push(msg.sender);\n\n    emit Participating(msg.sender, encounterId);\n  }\n\n  function claimLoot(uint encounterId, address player) public whenNotPaused {\n    address winnerAddress;\n    uint lootTokenId;\n    uint consolationPrizeTokenId;\n    (winnerAddress, lootTokenId, consolationPrizeTokenId, , ,,) = getEncounterResults(encounterId, player);\n    require(winnerAddress == player, \"player is not the winner\");\n\n    ParticipantData storage participantData = encountersById[encounterId].participantData[player];\n\n    require(!participantData.lootClaimed, \"loot already claimed\");\n\n    participantData.lootClaimed = true;\n    tokenContract.mint(player, lootTokenId);\n\n    // The winner also gets a consolation prize\n    // It's possible he called claimConsolationPrizeLoot first, so allow that\n\n    require(consolationPrizeTokenId != 0, \"consolation prize invalid\");\n\n    if (!participantData.consolationPrizeClaimed) {\n        participantData.consolationPrizeClaimed = true;\n        // this will throw if the token already exists\n        tokenContract.mint(player, consolationPrizeTokenId);\n\n        // refund gas\n        msg.sender.transfer(gasRefundForClaimLootWithConsolationPrize);\n    } else {\n        \n        // refund gas\n        msg.sender.transfer(gasRefundForClaimLoot);\n    }\n\n    emit LootClaimed(player, encounterId);\n  }\n\n  function getConsolationPrizeTokenId(uint encounterId, address player) internal view returns (uint) {\n\n    ParticipantData memory participantData = encountersById[encounterId].participantData[player];\n    if (participantData.damage == 0) {\n      return 0;\n    }\n\n    uint blockToHash = getBlockToHashForResults(encounterId);\n\n    uint rand = uint(keccak256(uint(blockhash(blockToHash)) ^ uint(player)));\n\n    if (participantData.forgeWeaponRarity != 0) {\n      return constructWeaponTokenId(rand, participantData.forgeWeaponRarity, participantData.forgeWeaponDamagePure);\n    }\n\n    return constructWeaponTokenId(rand, 0, 0);\n  }\n\n  function claimConsolationPrizeLoot(uint encounterId, address player) public whenNotPaused {\n    uint lootTokenId = getConsolationPrizeTokenId(encounterId, player);\n    require(lootTokenId != 0, \"player didnt participate\");\n\n    ParticipantData storage participantData = encountersById[encounterId].participantData[player];\n    require(!participantData.consolationPrizeClaimed, \"consolation prize already claimed\");\n\n    participantData.consolationPrizeClaimed = true;\n    tokenContract.mint(player, lootTokenId);\n\n    msg.sender.transfer(gasRefundForClaimConsolationPrizeLoot);\n\n    emit LootClaimed(player, encounterId);\n  }\n\n  function balanceOf(address _owner) public view returns (uint256) {\n    return tokenContract.balanceOf(_owner);\n  }\n\n  function tokensOf(address _owner) public view returns (uint256[]) {\n    return tokenContract.tokensOf(_owner);\n  }\n\n  function tokenOfOwnerByIndex(address _owner, uint256 _index)\n    external\n    view\n    returns (uint256 _tokenId)\n  {\n    return tokenContract.tokenOfOwnerByIndex(_owner, _index);\n  }\n}",
  "bytecode": "60806040526003805460a060020a60ff021916905565fdc7333db00060088190556009819055600a5566071afd498d0000600b5566038d7ea4c68000600c5534801561004a57600080fd5b506003805460008054600160a060020a031990811633908117909255600280548216831790556001805490911682179055600160a860020a0319909116179055612740806100996000396000f30060806040526004361061017f5763ffffffff7c01000000000000000000000000000000000000000000000000000000006000350416630519ce798114610184578063058fa067146101b55780630597f3aa146101cf5780630a0f8168146101e75780631b9fec58146101fc57806321b8092e1461022657806327121b761461024757806327d7874c1461025f5780632ba73c15146102805780632f745c59146102a15780632fd0f37e146102c55780633f4ba83a146102e95780634e0a3379146102fe57806356575bd71461031f5780635a3f2672146103375780635c975abb146103a85780635fd8c710146103d157806361df5c4d146103e657806370a08231146104475780638456cb59146104685780638534b3a81461047d578063a17eee5614610495578063ae4a8c88146104ad578063b047fb50146104d1578063bacc2c42146104e6578063c1e3bd3e14610500578063d4f397b514610518578063d7b2f36014610557578063e3e7d4f414610597578063f2bcd02214610661575b600080fd5b34801561019057600080fd5b50610199610676565b60408051600160a060020a039092168252519081900360200190f35b3480156101c157600080fd5b506101cd600435610685565b005b3480156101db57600080fd5b506101cd6004356106a1565b3480156101f357600080fd5b506101996106bd565b34801561020857600080fd5b506102146004356106cc565b60408051918252519081900360200190f35b34801561023257600080fd5b506101cd600160a060020a036004351661070c565b34801561025357600080fd5b506101cd600435610767565b34801561026b57600080fd5b506101cd600160a060020a0360043516610870565b34801561028c57600080fd5b506101cd600160a060020a03600435166108cb565b3480156102ad57600080fd5b50610214600160a060020a0360043516602435610926565b3480156102d157600080fd5b506101cd600435600160a060020a03602435166109d2565b3480156102f557600080fd5b506101cd610c19565b34801561030a57600080fd5b506101cd600160a060020a0360043516610c91565b34801561032b57600080fd5b506101cd600435610cec565b34801561034357600080fd5b50610358600160a060020a0360043516610d34565b60408051602080825283518183015283519192839290830191858101910280838360005b8381101561039457818101518382015260200161037c565b505050509050019250505060405180910390f35b3480156103b457600080fd5b506103bd610e37565b604080519115158252519081900360200190f35b3480156103dd57600080fd5b506101cd610e47565b3480156103f257600080fd5b5061040a600435600160a060020a0360243516610ec9565b60408051600160a060020a0390971687526020870195909552858501939093529015156060850152608084015260a0830152519081900360c00190f35b34801561045357600080fd5b50610214600160a060020a0360043516610fa4565b34801561047457600080fd5b506101cd611048565b34801561048957600080fd5b506101cd6004356110f1565b3480156104a157600080fd5b506101cd600435611139565b3480156104b957600080fd5b506101cd600435600160a060020a0360243516611155565b3480156104dd57600080fd5b506101996114ef565b6101cd60043560243560443560643560843560a4356114fe565b34801561050c57600080fd5b50610358600435611bd3565b34801561052457600080fd5b5061053c600435600160a060020a0360243516611c45565b60408051921515835290151560208301528051918290030190f35b34801561056357600080fd5b5061056c611d0e565b6040805195865260208601949094529115158484015260608401526080830152519081900360a00190f35b3480156105a357600080fd5b506105af600435611d64565b60405180868152602001851515151581526020018481526020018060200180602001838103835285818151815260200191508051906020019060200280838360005b838110156106095781810151838201526020016105f1565b50505050905001838103825284818151815260200191508051906020019060200280838360005b83811015610648578181015183820152602001610630565b5050505090500197505050505050505060405180910390f35b34801561066d57600080fd5b50610199611f25565b600154600160a060020a031681565b600054600160a060020a0316331461069c57600080fd5b600a55565b600054600160a060020a031633146106b857600080fd5b600955565b600054600160a060020a031681565b60006000196001830160500201814382106106e657600080fd5b816001014303905060ff81111561070557610100810461010002820191505b5092915050565b600054600160a060020a0316331461072357600080fd5b600160a060020a038116151561073857600080fd5b6003805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b60008181526007602052604081205481908190819060ff161561078957600080fd5b600085815260056020526040902054600160a060020a031633146107ac57600080fd5b50506050611680848102829004935060018501020490506000825b828110156107f2576000818152600460205260409020600190810154600c54029290920191016107c7565b600085815260076020526040808220805460ff1916600117905551339184156108fc02918591818181858888f19350505050158015610835573d6000803e3d6000fd5b506040805186815290517fec58a7c19cf7272fdb039e2d59ad99f1c3dbd88a8f48ceb7517b59d3689b19de9181900360200190a15050505050565b600054600160a060020a0316331461088757600080fd5b600160a060020a038116151561089c57600080fd5b6000805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b600054600160a060020a031633146108e257600080fd5b600160a060020a03811615156108f757600080fd5b6002805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b604080517f2f745c59000000000000000000000000000000000000000000000000000000008152600160a060020a03841660048201526024810183905290516000916000805160206126f583398151915291632f745c599160448082019260209290919082900301818787803b15801561099f57600080fd5b505af11580156109b3573d6000803e3d6000fd5b505050506040513d60208110156109c957600080fd5b50519392505050565b600354600090819060a060020a900460ff16156109ee57600080fd5b6109f88484611f34565b9150811515610a51576040805160e560020a62461bcd02815260206004820152601860248201527f706c61796572206469646e742070617274696369706174650000000000000000604482015290519081900360640190fd5b506000838152600460209081526040808320600160a060020a038616845290915290208054607860020a900460ff1615610afb576040805160e560020a62461bcd02815260206004820152602160248201527f636f6e736f6c6174696f6e207072697a6520616c726561647920636c61696d6560448201527f6400000000000000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b80546fff0000000000000000000000000000001916607860020a178155604080517f40c10f19000000000000000000000000000000000000000000000000000000008152600160a060020a03851660048201526024810184905290516000805160206126f5833981519152916340c10f1991604480830192600092919082900301818387803b158015610b8d57600080fd5b505af1158015610ba1573d6000803e3d6000fd5b505060095460405133935081156108fc0292506000818181858888f19350505050158015610bd3573d6000803e3d6000fd5b50604080518581529051600160a060020a038516917f0ad024e0fa76fa1f6961141f63c0bf3f0ead6b56c05b3ba21b5f9fceb3badb8e919081900360200190a250505050565b600054600160a060020a03163314610c3057600080fd5b60035460a060020a900460ff161515610c4857600080fd5b6003805474ff0000000000000000000000000000000000000000191690556040517fa45f47fdea8a1efdd9029a5691c7f759c32b7c698632b563573e155625d1693390600090a1565b600054600160a060020a03163314610ca857600080fd5b600160a060020a0381161515610cbd57600080fd5b6001805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b600254600160a060020a0316331480610d0f5750600054600160a060020a031633145b80610d245750600154600160a060020a031633145b1515610d2f57600080fd5b600c55565b604080517f5a3f2672000000000000000000000000000000000000000000000000000000008152600160a060020a038316600482015290516060916000805160206126f583398151915291635a3f26729160248082019260009290919082900301818387803b158015610da657600080fd5b505af1158015610dba573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526020811015610de357600080fd5b810190808051640100000000811115610dfb57600080fd5b82016020810184811115610e0e57600080fd5b8151856020820283011164010000000082111715610e2b57600080fd5b50909695505050505050565b60035460a060020a900460ff1681565b600154600160a060020a0316331480610e6a5750600054600160a060020a031633145b1515610e7557600080fd5b600354600160a060020a03161515610e8c57600080fd5b600354604051600160a060020a0390911690303180156108fc02916000818181858888f19350505050158015610ec6573d6000803e3d6000fd5b50565b600080600080600080600080600080610ee18c6106cc565b60008d8152600460205260409020600181015491955093509150811515610f1a5760009950899850889750879650869550859450610f96565b600160a060020a038b1660009081526020849052604090205463ffffffff169550610f46828486612070565b919b509095509050610f58818361227f565b985060019650610f688c8c611f34565b97508715610f9657600160a060020a038b16600090815260208490526040902054607860020a900460ff1696505b505050509295509295509295565b604080517f70a08231000000000000000000000000000000000000000000000000000000008152600160a060020a038316600482015290516000916000805160206126f5833981519152916370a082319160248082019260209290919082900301818787803b15801561101657600080fd5b505af115801561102a573d6000803e3d6000fd5b505050506040513d602081101561104057600080fd5b505192915050565b600254600160a060020a031633148061106b5750600054600160a060020a031633145b806110805750600154600160a060020a031633145b151561108b57600080fd5b60035460a060020a900460ff16156110a257600080fd5b6003805474ff0000000000000000000000000000000000000000191660a060020a1790556040517f9e87fac88ff661f02d44f95383c817fece4bce600a3dab7a54406878b965e75290600090a1565b600254600160a060020a03163314806111145750600054600160a060020a031633145b806111295750600154600160a060020a031633145b151561113457600080fd5b600b55565b600054600160a060020a0316331461115057600080fd5b600855565b60035460009081908190819060a060020a900460ff161561117557600080fd5b61117f8686610ec9565b5093975091955093505050600160a060020a03808516908616146111ed576040805160e560020a62461bcd02815260206004820152601860248201527f706c61796572206973206e6f74207468652077696e6e65720000000000000000604482015290519081900360640190fd5b506000858152600460209081526040808320600160a060020a0388168452909152902080546e010000000000000000000000000000900460ff161561127c576040805160e560020a62461bcd02815260206004820152601460248201527f6c6f6f7420616c726561647920636c61696d6564000000000000000000000000604482015290519081900360640190fd5b80546eff000000000000000000000000000019166e010000000000000000000000000000178155604080517f40c10f19000000000000000000000000000000000000000000000000000000008152600160a060020a03871660048201526024810185905290516000805160206126f5833981519152916340c10f1991604480830192600092919082900301818387803b15801561131857600080fd5b505af115801561132c573d6000803e3d6000fd5b5050508215159050611388576040805160e560020a62461bcd02815260206004820152601960248201527f636f6e736f6c6174696f6e207072697a6520696e76616c696400000000000000604482015290519081900360640190fd5b8054607860020a900460ff1615156114785780546fff0000000000000000000000000000001916607860020a178155604080517f40c10f19000000000000000000000000000000000000000000000000000000008152600160a060020a03871660048201526024810184905290516000805160206126f5833981519152916340c10f1991604480830192600092919082900301818387803b15801561142c57600080fd5b505af1158015611440573d6000803e3d6000fd5b5050600a5460405133935081156108fc0292506000818181858888f19350505050158015611472573d6000803e3d6000fd5b506114a8565b600854604051339180156108fc02916000818181858888f193505050501580156114a6573d6000803e3d6000fd5b505b604080518781529051600160a060020a038716917f0ad024e0fa76fa1f6961141f63c0bf3f0ead6b56c05b3ba21b5f9fceb3badb8e919081900360200190a2505050505050565b600254600160a060020a031681565b6000806000806000600360149054906101000a900460ff1615151561152257600080fd5b600b5434101561153157600080fd5b605043048b1461158b576040805160e560020a62461bcd02815260206004820152601c60248201527f61206e657720656e636f756e74657220697320617661696c61626c6500000000604482015290519081900360640190fd5b60008b8152600460209081526040808320338452918290529091205490955063ffffffff1615611605576040805160e560020a62461bcd02815260206004820152601d60248201527f796f752061726520616c72656164792070617274696369706174696e67000000604482015290519081900360640190fd5b6001935089156117205733600160a060020a03166000805160206126f5833981519152600160a060020a0316636352211e8c6040518263ffffffff167c010000000000000000000000000000000000000000000000000000000002815260040180828152602001915050602060405180830381600087803b15801561168957600080fd5b505af115801561169d573d6000803e3d6000fd5b505050506040513d60208110156116b357600080fd5b5051600160a060020a031614611713576040805160e560020a62461bcd02815260206004820152601860248201527f796f7520646f6e74206f776e207468617420776561706f6e0000000000000000604482015290519081900360640190fd5b61171d8a8c6122b0565b93505b61168060508c0204600081815260066020908152604080832033845280835281842080548a01908190558585526005845282852054600160a060020a031685529252909120549194509250821180156117905750600083815260056020526040902054600160a060020a03163314155b156117c1576000838152600560205260409020805473ffffffffffffffffffffffffffffffffffffffff1916331790555b50600184015483906000101561182457600185018054869160009160001981019081106117ea57fe5b6000918252602080832090910154600160a060020a0316835282019290925260400190205467ffffffffffffffff64010000000090910416015b88156119ff576040805160e060020a6323b872dd02815233600482015260016024820152604481018b905290516000805160206126f5833981519152916323b872dd91606480830192600092919082900301818387803b15801561188757600080fd5b505af115801561189b573d6000803e3d6000fd5b50506040805160e060020a6323b872dd02815233600482015260016024820152604481018c905290516000805160206126f583398151915293506323b872dd9250606480830192600092919082900301818387803b1580156118fc57600080fd5b505af1158015611910573d6000803e3d6000fd5b50506040805160e060020a6323b872dd02815233600482015260016024820152604481018b905290516000805160206126f583398151915293506323b872dd9250606480830192600092919082900301818387803b15801561197157600080fd5b505af1158015611985573d6000803e3d6000fd5b50506040805160e060020a6323b872dd02815233600482015260016024820152604481018a905290516000805160206126f583398151915293506323b872dd9250606480830192600092919082900301818387803b1580156119e657600080fd5b505af11580156119fa573d6000803e3d6000fd5b505050505b60c0604051908101604052808563ffffffff1681526020018267ffffffffffffffff168152602001611a338b8b8b8b612388565b60ff168152602001611a478b8b8b8b612440565b60ff9081168252600060208084018290526040938401829052338083528a825284832086518154888501518989015160608b015160808c015160a0909c01511515607860020a026fff000000000000000000000000000000199c15156e010000000000000000000000000000026eff000000000000000000000000000019928c166d0100000000000000000000000000026dff000000000000000000000000001994909c166c01000000000000000000000000026cff0000000000000000000000001967ffffffffffffffff909616640100000000026bffffffffffffffff000000001963ffffffff90991663ffffffff19909816979097179790971695909517939093169490941716979097179190911617969096169390931790945560018981018054918201815582529084902001805473ffffffffffffffffffffffffffffffffffffffff19168217905581518e8152915190927f7ab1f709e166545a6be2eecd19d5336e42999ae73035ef4d68120a59ae2cb6bc928290030190a25050505050505050505050565b6000818152600460209081526040918290206001810180548451818502810185019095528085526060949293830182828015611c3857602002820191906000526020600020905b8154600160a060020a03168152600190910190602001808311611c1a575b5050505050915050919050565b600080611c506126a0565b5050506000918252600460209081526040808420600160a060020a0393909316845291815291819020815160c081018352905463ffffffff8116825267ffffffffffffffff6401000000008204169382019390935260ff6c0100000000000000000000000084048116928201929092526d01000000000000000000000000008304821660608201526e01000000000000000000000000000083048216151560808201819052607860020a909304909116151560a09091018190529091565b60504381900460008181526004602090815260408083203384529182905282205492936001850181029363ffffffff161515926116809186029190910491611d558661248b565b40600190049150509091929394565b60008181526007602052604081205460ff166050611680600185010281900402606080848080808080611d968c612495565b94505b611da58c600101612495565b851015611dda57600085815260046020526040902060019081018054600c5481029d909d019c97909701969501949350611d99565b85604051908082528060200260200182016040528015611e04578160200160208202803883390190505b50975085604051908082528060200260200182016040528015611e31578160200160208202803883390190505b50965060009550611e418c612495565b94505b611e508c600101612495565b851015611f16576000858152600460205260408120600181019550935091505b8354821015611f0b578382815481101515611e8757fe5b6000918252602090912001548851600160a060020a0390911691508190899088908110611eb057fe5b600160a060020a0392831660209182029092018101919091529082166000908152908490526040902054875163ffffffff90911690889088908110611ef157fe5b602090810290910101526001958601959190910190611e70565b600190940193611e44565b50505050505091939590929450565b600354600160a060020a031681565b6000611f3e6126a0565b506000838152600460209081526040808320600160a060020a03861684528252808320815160c081018352905463ffffffff811680835267ffffffffffffffff6401000000008304169483019490945260ff6c0100000000000000000000000082048116938301939093526d01000000000000000000000000008104831660608301526e0100000000000000000000000000008104831615156080830152607860020a9004909116151560a08201529190819015156120005760009350612067565b612009866106cc565b604080518240600160a060020a038916188152815190819003602001902090850151919350915060ff16156120585761205181846040015160ff16856060015160ff166124a2565b9350612067565b612064816000806124a2565b93505b50505092915050565b6000808080808080808a151561208557612271565b60018a0180548b916000916000198f0190811061209e57fe5b6000918252602080832090910154600160a060020a0316835282810193909352604091820190205481518c4081529151918290039092019020975067ffffffffffffffff64010000000090910416955085878115156120f957fe5b0694508a93506000925060018b0391505b8282106121f25750600281830104600081118015612177575060018a0180548b91600091600019850190811061213c57fe5b6000918252602080832090910154600160a060020a0316835282019290925260400190205467ffffffffffffffff6401000000009091041685105b15612187576001810391506121ed565b60018a0180548b916000918490811061219c57fe5b6000918252602080832090910154600160a060020a0316835282019290925260400190205467ffffffffffffffff6401000000009091041685106121e5578060010192506121ed565b8093506121f2565b61210a565b8a8410612249576040805160e560020a62461bcd02815260206004820152601660248201527f6572726f7220696e2062696e6172792073656172636800000000000000000000604482015290519081900360640190fd5b60018a0180548590811061225957fe5b600091825260209091200154600160a060020a031697505b505050505093509350939050565b600080600183111561228f575060015b600a83111561229c575060025b6122a8848260006124a2565b949350505050565b6000600019605083020140818080808080806122e1816122d08a82612640565b6122db8e6000612640565b03612651565b96506122fe60006122f38a6004612640565b6122db8e6004612640565b955061231b60006123108a6003612640565b6122db8e6003612640565b9450612338600061232d8a6002612640565b6122db8e6002612640565b9350612355600061234a8a6001612640565b6122db8e6001612640565b92506123608b61266a565b915050858501840183018201810161237960018261267b565b9b9a5050505050505050505050565b60008085151561239b5760009150612437565b6123a48661268b565b90506123b8816123b38761268b565b612691565b90506123c7816123b38661268b565b90506123d6816123b38561268b565b600101905060058110612433576040805160e560020a62461bcd02815260206004820152601d60248201527f63616e7420666f72676520616e20756c74696d61746520776561706f6e000000604482015290519081900360640190fd5b8091505b50949350505050565b6000841515612451575060006122a8565b61248260ff61245f8461266a565b6124688661266a565b6124718861266a565b61247a8a61266a565b010101612691565b95945050505050565b6050026000190190565b6050611680919091020490565b6000806124ad6126d5565b5050604080516080810182527f010204081001020408100000000000000000000000000000000000000000000081527f030506090a0c111214180000000000000000000000000000000000000000000060208201527f070b0d0e131516191a1c00000000000000000000000000000000000000000000918101919091527f0f171b1d1e0f171b1d1e00000000000000000000000000000000000000000000606082015267ffffffffffffffff1985168401906000808083886004811061256f57fe5b6020020151925082600a61ffff6d01000000000000000000000000008c041606600a811061259957fe5b1a7f0100000000000000000000000000000000000000000000000000000000000000027f010000000000000000000000000000000000000000000000000000000000000090049150600090505b600581101561261b57600281900a821660ff161515612613578060080260400160ff9060020a0219851694505b6001016125e6565b612626606488612691565b670100000000000000029490941798975050505050505050565b60080260400160020a900460ff1690565b6000818312156126615781612663565b825b9392505050565b670100000000000000900460ff1690565b6000818310156126615781612663565b60ff1690565b60008183106126615781612663565b6040805160c081018252600080825260208201819052918101829052606081018290526080810182905260a081019190915290565b60806040519081016040528060049060208202803883395091929150505600000000000000000000000000e1015a79a7d488f8fecf073b187d38c6f1a77368a165627a7a7230582033a778ef341459a4ce5d08c09bade27b21c732b3568befa52524b84331a49a280029"
}