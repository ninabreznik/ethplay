{
  "address": "0x8ea74569c1b9bbb13780114b6b5e93396910070a",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "Baliv",
  "compilerVersion": "v0.4.21+commit.dfe3193c",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2018-04-16\n*/\n\npragma solidity ^0.4.21;\n\n/*\nProject: XPA Exchange - https://xpa.exchange\nAuthor : Luphia Chang - [email protected]\n */\n\ninterface Token {\n    function totalSupply() constant external returns (uint256 ts);\n    function balanceOf(address _owner) constant external returns (uint256 balance);\n    function transfer(address _to, uint256 _value) external returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n    function approve(address _spender, uint256 _value) external returns (bool success);\n    function allowance(address _owner, address _spender) constant external returns (uint256 remaining);\n}\n\ncontract SafeMath {\n    function safeAdd(uint x, uint y)\n        internal\n        pure\n    returns(uint) {\n      uint256 z = x + y;\n      require((z >= x) && (z >= y));\n      return z;\n    }\n\n    function safeSub(uint x, uint y)\n        internal\n        pure\n    returns(uint) {\n      require(x >= y);\n      uint256 z = x - y;\n      return z;\n    }\n\n    function safeMul(uint x, uint y)\n        internal\n        pure\n    returns(uint) {\n      uint z = x * y;\n      require((x == 0) || (z / x == y));\n      return z;\n    }\n    \n    function safeDiv(uint x, uint y)\n        internal\n        pure\n    returns(uint) {\n        require(y > 0);\n        return x / y;\n    }\n\n    function random(uint N, uint salt)\n        internal\n        view\n    returns(uint) {\n      bytes32 hash = keccak256(block.number, msg.sender, salt);\n      return uint(hash) % N;\n    }\n}\n\ncontract Authorization {\n    mapping(address => address) public agentBooks;\n    address public owner;\n    address public operator;\n    address public bank;\n    bool public powerStatus = true;\n\n    function Authorization()\n        public\n    {\n        owner = msg.sender;\n        operator = msg.sender;\n        bank = msg.sender;\n    }\n\n    modifier onlyOwner\n    {\n        assert(msg.sender == owner);\n        _;\n    }\n    modifier onlyOperator\n    {\n        assert(msg.sender == operator || msg.sender == owner);\n        _;\n    }\n    modifier onlyActive\n    {\n        assert(powerStatus);\n        _;\n    }\n\n    function powerSwitch(\n        bool onOff_\n    )\n        public\n        onlyOperator\n    {\n        powerStatus = onOff_;\n    }\n\n    function transferOwnership(address newOwner_)\n        onlyOwner\n        public\n    {\n        owner = newOwner_;\n    }\n    \n    function assignOperator(address user_)\n        public\n        onlyOwner\n    {\n        operator = user_;\n        agentBooks[bank] = user_;\n    }\n    \n    function assignBank(address bank_)\n        public\n        onlyOwner\n    {\n        bank = bank_;\n    }\n\n    function assignAgent(\n        address agent_\n    )\n        public\n    {\n        agentBooks[msg.sender] = agent_;\n    }\n\n    function isRepresentor(\n        address representor_\n    )\n        public\n        view\n    returns(bool) {\n        return agentBooks[representor_] == msg.sender;\n    }\n\n    function getUser(\n        address representor_\n    )\n        internal\n        view\n    returns(address) {\n        return isRepresentor(representor_) ? representor_ : msg.sender;\n    }\n}\n\n/*  Error Code\n    0: insufficient funds (user)\n    1: insufficient funds (contract)\n    2: invalid amount\n    3: invalid price\n */\n\n/*\n    1. 檢驗是否指定代理用戶，若是且為合法代理人則將操作角色轉換為被代理人，否則操作角色不變\n    2. 檢驗此操作是否有存入 ETH，有則暫時紀錄存入額度 A，若掛單指定 fromToken 不是 ETH 則直接更新用戶 ETH 帳戶餘額\n    3. 檢驗此操作是否有存入 fromToken，有則暫時紀錄存入額度 A\n    4. 檢驗用戶 fromToken 帳戶餘額 + 存入額度 A 是否 >= Amount，若是送出 makeOrder 掛單事件，否則結束操作\n    5. 依照 fromToken、toToken 尋找可匹配的交易對 P\n    6. 找出 P 的最低價格單進行匹配，記錄匹配數量，送出 fillOrder 成交事件，並結算 maker 交易結果，若成交完還有掛單數量有剩且未達迴圈次數上限則重複此步驟\n    7. 統計步驟 6 總成交量、交易價差利潤、交易手續費\n    8. 若扣除總成交量後 Taker 掛單尚未撮合完，則將剩餘額度轉換為 Maker 單\n    9. 結算交易所手續費\n    10. 結算 Taker 交易結果\n */\n\ncontract Baliv is SafeMath, Authorization {\n    /* struct for exchange data */\n    struct linkedBook {\n        uint256 amount;\n        address nextUser;\n    }\n\n    /* business options */\n    mapping(address => uint256) public minAmount;\n    uint256[3] public feerate = [0, 1 * (10 ** 15), 1 * (10 ** 15)];\n    uint256 public autoMatch = 10;\n    uint256 public maxAmount = 10 ** 27;\n    uint256 public maxPrice = 10 ** 36;\n    address public XPAToken = 0x0090528aeb3a2b736b780fd1b6c478bb7e1d643170;\n\n    /* exchange data */\n    mapping(address => mapping(address => mapping(uint256 => mapping(address => linkedBook)))) public orderBooks;\n    mapping(address => mapping(address => mapping(uint256 => uint256))) public nextOrderPrice;\n    mapping(address => mapping(address => uint256)) public priceBooks;\n    \n    /* user data */\n    mapping(address => mapping(address => uint256)) public balances;\n    mapping(address => bool) internal manualWithdraw;\n\n    /* event */\n    event eDeposit(address user,address token, uint256 amount);\n    event eWithdraw(address user,address token, uint256 amount);\n    event eMakeOrder(address fromToken, address toToken, uint256 price, address user, uint256 amount);\n    event eFillOrder(address fromToken, address toToken, uint256 price, address user, uint256 amount);\n    event eCancelOrder(address fromToken, address toToken, uint256 price, address user, uint256 amount);\n\n    event Error(uint256 code);\n\n    /* constructor */\n    function Baliv() public {\n        minAmount[0] = 10 ** 16;\n    }\n\n    /* Operator Function\n        function setup(uint256 autoMatch, uint256 maxAmount, uint256 maxPrice) external;\n        function setMinAmount(address token, uint256 amount) external;\n        function setFeerate(uint256[3] [maker, taker, autoWithdraw]) external;\n    */\n\n    /* External Function\n        function () public payable;\n        function deposit(address token, address representor) external payable;\n        function withdraw(address token, uint256 amount, address representor) external returns(bool);\n        function userTakeOrder(address fromToken, address toToken, uint256 price, uint256 amount, address representor) external payable returns(bool);\n        function userCancelOrder(address fromToken, address toToken, uint256 price, uint256 amount, address representor) external returns(bool);\n        function caculateFee(address user, uint256 amount, uint8 role) external returns(uint256 remaining, uint256 fee);\n        function trade(address fromToken, address toToken) external;\n        function setManualWithdraw(bool) external;\n        function getMinAmount(address) external returns(uint256);\n        function getPrice(address fromToken, address toToken) external returns(uint256);\n    */\n\n    /* Internal Function\n        function depositAndFreeze(address token, address user) internal payable returns(uint256 amount);\n        function checkBalance(address user, address token, uint256 amount, uint256 depositAmount) internal returns(bool);\n        function checkAmount(address token, uint256 amount) internal returns(bool);\n        function checkPriceAmount(uint256 price) internal returns(bool);\n        function makeOrder(address fromToken, address toToken, uint256 price, uint256 amount, address user, uint256 depositAmount) internal returns(uint256 amount);\n        function findAndTrade(address fromToken, address toToken, uint256 price, uint256 amount) internal returns(uint256[2] totalMatchAmount[fromToken, toToken], uint256[2] profit[fromToken, toToken]);\n        function makeTrade(address fromToken, address toToken, uint256 price, uint256 bestPrice, uint256 remainingAmount) internal returns(uint256[3] [fillTaker, fillMaker, makerFee]);\n        function makeTradeDetail(address fromToken, address toToken, uint256 price, uint256 bestPrice, address maker, uint256 remainingAmount) internal returns(uint256[3] [fillTaker, fillMaker, makerFee]);\n        function caculateFill(uint256 provide, uint256 require, uint256 price, uint256 pairProvide) internal pure returns(uint256 fillAmount);\n        function checkPricePair(uint256 price, uint256 bestPrice) internal pure returns(bool matched);\n        function fillOrder(address fromToken, address toToken, uint256 price, uint256 amount) internal returns(uint256 fee);\n        function transferToken(address user, address token, uint256 amount) internal returns(bool);\n        function updateBalance(address user, address token, uint256 amount, bool addOrSub) internal returns(bool);\n        function connectOrderPrice(address fromToken, address toToken, uint256 price, uint256 prevPrice) internal;\n        function connectOrderUser(address fromToken, address toToken, uint256 price, address user) internal;\n        function disconnectOrderPrice(address fromToken, address toToken, uint256 price) internal;\n        function disconnectOrderUser(address fromToken, address toToken, uint256 price, address user) internal;\n        function getNextOrderPrice(address fromToken, address toToken, uint256 price) internal view returns(uint256 price);\n        function updateNextOrderPrice(address fromToken, address toToken, uint256 price, uint256 nextPrice) internal;\n        function getNexOrdertUser(address fromToken, address toToken, uint256 price, address user) internal view returns(address nextUser);\n        function getOrderAmount(address fromToken, address toToken, uint256 price, address user) internal view returns(uint256 amount);\n        function updateNextOrderUser(address fromToken, address toToken, uint256 price, address user, address nextUser) internal;\n        function updateOrderAmount(address fromToken, address toToken, uint256 price, address user, uint256 amount, bool addOrSub) internal;\n        function logPrice(address fromToken, address toToken, uint256 price) internal;\n    */\n\n    /* Operator function */\n    function setup(\n        uint256 autoMatch_,\n        uint256 maxAmount_,\n        uint256 maxPrice_\n    )\n        onlyOperator\n        public\n    {\n        autoMatch = autoMatch_;\n        maxAmount = maxAmount_;\n        maxPrice = maxPrice_;\n    }\n    \n    function setMinAmount(\n        address token_,\n        uint256 amount_\n    )\n        onlyOperator\n        public\n    {\n        minAmount[token_] = amount_;\n    }\n    \n    function getMinAmount(\n        address token_\n    )\n        public\n        view\n    returns(uint256) {\n        return minAmount[token_] > 0\n            ? minAmount[token_]\n            : minAmount[0];\n    }\n    \n    function setFeerate(\n        uint256[3] feerate_\n    )\n        onlyOperator\n        public\n    {\n        require(feerate_[0] < 0.05 ether && feerate_[1] < 0.05 ether && feerate_[2] < 0.05 ether);\n        feerate = feerate_;\n    }\n\n    /* External function */\n    // fallback\n    function ()\n        public\n        payable\n    {\n        deposit(0, 0);\n    }\n\n    // deposit all allowance\n    function deposit(\n        address token_,\n        address representor_\n    )\n        public\n        payable\n        onlyActive\n    {\n        address user = getUser(representor_);\n        uint256 amount = depositAndFreeze(token_, user);\n        if(amount > 0) {\n            updateBalance(msg.sender, token_, amount, true);\n        }\n    }\n\n    function withdraw(\n        address token_,\n        uint256 amount_,\n        address representor_\n    )\n        public\n    returns(bool) {\n        address user = getUser(representor_);\n        if(updateBalance(user, token_, amount_, false)) {\n            require(transferToken(user, token_, amount_));\n            return true;\n        }\n    }\n\n    function agentMakeOrder(\n        address fromToken_,\n        address toToken_,\n        uint256 price_,\n        uint256 amount_,\n        address representor_\n    )\n        public\n        payable\n    returns(bool) {\n        // depositToken => makeOrder => updateBalance\n        uint256 depositAmount = depositAndFreeze(fromToken_, representor_);\n        if(\n            checkAmount(fromToken_, amount_) &&\n            checkPriceAmount(price_)\n        ) {\n            require(representor_ != address(0));\n            address user = representor_;\n            uint256 costAmount = makeOrder(fromToken_, toToken_, price_, amount_, user, depositAmount);\n\n            // log event: MakeOrder\n            emit eMakeOrder(fromToken_, toToken_, price_, user, amount_);\n\n            require(costAmount <= depositAmount);\n            updateBalance(msg.sender, fromToken_, safeSub(depositAmount, costAmount), true);\n            return true;\n        }\n    }\n\n    function userTakeOrder(\n        address fromToken_,\n        address toToken_,\n        uint256 price_,\n        uint256 amount_,\n        address representor_\n    )\n        public\n        payable\n        onlyActive\n    returns(bool) {\n        // checkBalance => findAndTrade => userMakeOrder => updateBalance\n        address user = getUser(representor_);\n        uint256 depositAmount = depositAndFreeze(fromToken_, user);\n        if(\n            checkAmount(fromToken_, amount_) &&\n            checkPriceAmount(price_) &&\n            checkBalance(user, fromToken_, amount_, depositAmount)\n        ) {\n            // log event: MakeOrder\n            emit eMakeOrder(fromToken_, toToken_, price_, user, amount_);\n\n            uint256[2] memory fillAmount;\n            uint256[2] memory profit;\n            (fillAmount, profit) = findAndTrade(fromToken_, toToken_, price_, amount_);\n            uint256 fee;\n            uint256 toAmount;\n            uint256 orderAmount;\n\n            if(fillAmount[0] > 0) {\n                // log event: makeTrade\n                emit eFillOrder(fromToken_, toToken_, price_, user, fillAmount[0]);\n\n                toAmount = safeDiv(safeMul(fillAmount[0], price_), 1 ether);\n                if(amount_ > fillAmount[0]) {\n                    orderAmount = safeSub(amount_, fillAmount[0]);\n                    makeOrder(fromToken_, toToken_, price_, orderAmount, user, depositAmount);\n                }\n                if(toAmount > 0) {\n                    (toAmount, fee) = caculateFee(user, toAmount, 1);\n                    profit[1] = profit[1] + fee;\n\n                    // save profit\n                    updateBalance(bank, fromToken_, profit[0], true);\n                    updateBalance(bank, toToken_, profit[1], true);\n\n                    // transfer to Taker\n                    if(manualWithdraw[user]) {\n                        updateBalance(user, toToken_, toAmount, true);\n                    } else {\n                        transferToken(user, toToken_, toAmount);\n                    }\n                }\n            } else {\n                orderAmount = amount_;\n                makeOrder(fromToken_, toToken_, price_, orderAmount, user, depositAmount);\n            }\n\n            // update balance\n            if(amount_ > depositAmount) {\n                updateBalance(user, fromToken_, safeSub(amount_, depositAmount), false);\n            } else if(amount_ < depositAmount) {\n                updateBalance(user, fromToken_, safeSub(depositAmount, amount_), true);\n            }\n\n            return true;\n        } else if(depositAmount > 0) {\n            updateBalance(user, fromToken_, depositAmount, true);\n        }\n    }\n\n    function userCancelOrder(\n        address fromToken_,\n        address toToken_,\n        uint256 price_,\n        uint256 amount_,\n        address representor_\n    )\n        public\n    returns(bool) {\n        // updateOrderAmount => disconnectOrderUser => withdraw\n        address user = getUser(representor_);\n        uint256 amount = getOrderAmount(fromToken_, toToken_, price_, user);\n        amount = amount > amount_ ? amount_ : amount;\n        if(amount > 0) {\n            // log event: CancelOrder\n            emit eCancelOrder(fromToken_, toToken_, price_, user, amount);\n\n            updateOrderAmount(fromToken_, toToken_, price_, user, amount, false);\n            if(manualWithdraw[user]) {\n                updateBalance(user, fromToken_, amount, true);\n            } else {\n                transferToken(user, fromToken_, amount);\n            }\n            return true;\n        }\n    }\n\n    /* role - 0: maker 1: taker */\n    function caculateFee(\n        address user_,\n        uint256 amount_,\n        uint8 role_\n    )\n        public\n        view\n    returns(uint256, uint256) {\n        uint256 myXPABalance = Token(XPAToken).balanceOf(user_);\n        uint256 myFeerate = manualWithdraw[user_]\n            ? feerate[role_]\n            : feerate[role_] + feerate[2];\n        myFeerate =\n            myXPABalance > 1000000 ether ? myFeerate * 0.5 ether / 1 ether :\n            myXPABalance > 100000 ether ? myFeerate * 0.6 ether / 1 ether :\n            myXPABalance > 10000 ether ? myFeerate * 0.8 ether / 1 ether :\n            myFeerate;\n        uint256 fee = safeDiv(safeMul(amount_, myFeerate), 1 ether);\n        uint256 toAmount = safeSub(amount_, fee);\n        return(toAmount, fee);\n    }\n\n    function trade(\n        address fromToken_,\n        address toToken_\n    )\n        public\n        onlyActive\n    {\n        // Don't worry, this takes maker feerate\n        uint256 takerPrice = getNextOrderPrice(fromToken_, toToken_, 0);\n        address taker = getNextOrderUser(fromToken_, toToken_, takerPrice, 0);\n        uint256 takerAmount = getOrderAmount(fromToken_, toToken_, takerPrice, taker);\n        /*\n            fillAmount[0] = TakerFill\n            fillAmount[1] = MakerFill\n            profit[0] = fromTokenProfit\n            profit[1] = toTokenProfit\n         */\n        uint256[2] memory fillAmount;\n        uint256[2] memory profit;\n        (fillAmount, profit) = findAndTrade(fromToken_, toToken_, takerPrice, takerAmount);\n        if(fillAmount[0] > 0) {\n            profit[1] = profit[1] + fillOrder(fromToken_, toToken_, takerPrice, taker, fillAmount[0]);\n\n            // save profit to operator\n            updateBalance(msg.sender, fromToken_, profit[0], true);\n            updateBalance(msg.sender, toToken_, profit[1], true);\n        }\n    }\n\n    function setManualWithdraw(\n        bool manual_\n    )\n        public\n    {\n        manualWithdraw[msg.sender] = manual_;\n    }\n\n    function getPrice(\n        address fromToken_,\n        address toToken_\n    )\n        public\n        view\n    returns(uint256) {\n        if(uint256(fromToken_) >= uint256(toToken_)) {\n            return priceBooks[fromToken_][toToken_];            \n        } else {\n            return priceBooks[toToken_][fromToken_] > 0 ? safeDiv(10 ** 36, priceBooks[toToken_][fromToken_]) : 0;\n        }\n    }\n\n    /* Internal Function */\n    // deposit all allowance\n    function depositAndFreeze(\n        address token_,\n        address user\n    )\n        internal\n    returns(uint256) {\n        uint256 amount;\n        if(token_ == address(0)) {\n            // log event: Deposit\n            emit eDeposit(user, address(0), msg.value);\n\n            amount = msg.value;\n            return amount;\n        } else {\n            if(msg.value > 0) {\n                // log event: Deposit\n                emit eDeposit(user, address(0), msg.value);\n\n                updateBalance(user, address(0), msg.value, true);\n            }\n            amount = Token(token_).allowance(msg.sender, this);\n            if(\n                amount > 0 &&\n                Token(token_).transferFrom(msg.sender, this, amount)\n            ) {\n                // log event: Deposit\n                emit eDeposit(user, token_, amount);\n\n                return amount;\n            }\n        }\n    }\n\n    function checkBalance(\n        address user_,\n        address token_,\n        uint256 amount_,\n        uint256 depositAmount_\n    )\n        internal\n    returns(bool) {\n        if(safeAdd(balances[user_][token_], depositAmount_) >= amount_) {\n            return true;\n        } else {\n            emit Error(0);\n            return false;\n        }\n    }\n\n    function checkAmount(\n        address token_,\n        uint256 amount_\n    )\n        internal\n    returns(bool) {\n        uint256 min = getMinAmount(token_);\n        if(amount_ > maxAmount || amount_ < min) {\n            emit Error(2);\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    function checkPriceAmount(\n        uint256 price_\n    )\n        internal\n    returns(bool) {\n        if(price_ == 0 || price_ > maxPrice) {\n            emit Error(3);\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    function makeOrder(\n        address fromToken_,\n        address toToken_,\n        uint256 price_,\n        uint256 amount_,\n        address user_,\n        uint256 depositAmount_\n    )\n        internal\n    returns(uint256) {\n        if(checkBalance(user_, fromToken_, amount_, depositAmount_)) {\n            updateOrderAmount(fromToken_, toToken_, price_, user_, amount_, true);\n            connectOrderPrice(fromToken_, toToken_, price_, 0);\n            connectOrderUser(fromToken_, toToken_, price_, user_);\n            return amount_;\n        } else {\n            return 0;\n        }\n    }\n\n    function findAndTrade(\n        address fromToken_,\n        address toToken_,\n        uint256 price_,\n        uint256 amount_\n    )\n        internal\n    returns(uint256[2], uint256[2]) {\n        /*\n            totalMatchAmount[0]: Taker total match amount\n            totalMatchAmount[1]: Maker total match amount\n            profit[0]: fromToken profit\n            profit[1]: toToken profit\n            matchAmount[0]: Taker match amount\n            matchAmount[1]: Maker match amount\n         */\n        uint256[2] memory totalMatchAmount;\n        uint256[2] memory profit;\n        uint256[3] memory matchAmount;\n        uint256 toAmount;\n        uint256 remaining = amount_;\n        uint256 matches = 0;\n        uint256 prevBestPrice = 0;\n        uint256 bestPrice = getNextOrderPrice(toToken_, fromToken_, prevBestPrice);\n        for(; matches < autoMatch && remaining > 0;) {\n            matchAmount = makeTrade(fromToken_, toToken_, price_, bestPrice, remaining);\n            if(matchAmount[0] > 0) {\n                remaining = safeSub(remaining, matchAmount[0]);\n                totalMatchAmount[0] = safeAdd(totalMatchAmount[0], matchAmount[0]);\n                totalMatchAmount[1] = safeAdd(totalMatchAmount[1], matchAmount[1]);\n                profit[0] = safeAdd(profit[0], matchAmount[2]);\n                \n                // for next loop\n                matches++;\n                prevBestPrice = bestPrice;\n                bestPrice = getNextOrderPrice(toToken_, fromToken_, prevBestPrice);\n            } else {\n                break;\n            }\n        }\n\n        if(totalMatchAmount[0] > 0) {\n            // log price\n            logPrice(toToken_, fromToken_, prevBestPrice);\n\n            // calculating spread profit\n            toAmount = safeDiv(safeMul(totalMatchAmount[0], price_), 1 ether);\n            profit[1] = safeSub(totalMatchAmount[1], toAmount);\n            if(totalMatchAmount[1] >= safeDiv(safeMul(amount_, price_), 1 ether)) {\n                // fromProfit += amount_ - takerFill;\n                profit[0] = profit[0] + amount_ - totalMatchAmount[0];\n                // fullfill Taker order\n                totalMatchAmount[0] = amount_;\n            } else {\n                toAmount = totalMatchAmount[1];\n                // fromProfit += takerFill - (toAmount / price_ * 1 ether)\n                profit[0] = profit[0] + totalMatchAmount[0] - (toAmount * 1 ether /price_);\n                // (real) takerFill = toAmount / price_ * 1 ether\n                totalMatchAmount[0] = safeDiv(safeMul(toAmount, 1 ether), price_);\n            }\n        }\n\n        return (totalMatchAmount, profit);\n    }\n\n    function makeTrade(\n        address fromToken_,\n        address toToken_,\n        uint256 price_,\n        uint256 bestPrice_,\n        uint256 remaining_\n    )\n        internal\n    returns(uint256[3]) {\n        if(checkPricePair(price_, bestPrice_)) {\n            address prevMaker = address(0);\n            address maker = getNextOrderUser(toToken_, fromToken_, bestPrice_, 0);\n            uint256 remaining = remaining_;\n\n            /*\n                totalFill[0]: Total Taker fillAmount\n                totalFill[1]: Total Maker fillAmount\n                totalFill[2]: Total Maker fee\n             */\n            uint256[3] memory totalFill;\n            for(uint256 i = 0; i < autoMatch && remaining > 0 && maker != address(0); i++) {\n                uint256[3] memory fill;\n                fill = makeTradeDetail(fromToken_, toToken_, price_, bestPrice_, maker, remaining);\n                if(fill[0] > 0) {\n                    remaining = safeSub(remaining, fill[0]);\n                    totalFill[0] = safeAdd(totalFill[0], fill[0]);\n                    totalFill[1] = safeAdd(totalFill[1], fill[1]);\n                    totalFill[2] = safeAdd(totalFill[2], fill[2]);\n                    prevMaker = maker;\n                    maker = getNextOrderUser(toToken_, fromToken_, bestPrice_, prevMaker);\n                    if(maker == address(0)) {\n                        break;\n                    }\n                } else {\n                    break;\n                }\n            }\n        }\n        return totalFill;\n    }\n\n    function makeTradeDetail(\n        address fromToken_,\n        address toToken_,\n        uint256 price_,\n        uint256 bestPrice_,\n        address maker_,\n        uint256 remaining_\n    )\n        internal\n    returns(uint256[3]) {\n        /*\n            fillAmount[0]: Taker fillAmount\n            fillAmount[1]: Maker fillAmount\n            fillAmount[2]: Maker fee\n         */\n        uint256[3] memory fillAmount;\n        uint256 takerProvide = remaining_;\n        uint256 takerRequire = safeDiv(safeMul(takerProvide, price_), 1 ether);\n        uint256 makerProvide = getOrderAmount(toToken_, fromToken_, bestPrice_, maker_);\n        uint256 makerRequire = safeDiv(safeMul(makerProvide, bestPrice_), 1 ether);\n        fillAmount[0] = caculateFill(takerProvide, takerRequire, price_, makerProvide);\n        fillAmount[1] = caculateFill(makerProvide, makerRequire, bestPrice_, takerProvide);\n        fillAmount[2] = fillOrder(toToken_, fromToken_, bestPrice_, maker_, fillAmount[1]);\n        return (fillAmount);\n    }\n\n    function caculateFill(\n        uint256 provide_,\n        uint256 require_,\n        uint256 price_,\n        uint256 pairProvide_\n    )\n        internal\n        pure\n    returns(uint256) {\n        return require_ > pairProvide_ ? safeDiv(safeMul(pairProvide_, 1 ether), price_) : provide_;\n    }\n\n    function checkPricePair(\n        uint256 price_,\n        uint256 bestPrice_\n    )\n        internal pure \n    returns(bool) {\n        if(bestPrice_ < price_) {\n            return checkPricePair(bestPrice_, price_);\n        } else if(bestPrice_ < 1 ether) {\n            return true;\n        } else if(price_ > 1 ether) {\n            return false;\n        } else {\n            return price_ * bestPrice_ <= 1 ether * 1 ether;\n        }\n    }\n\n    function fillOrder(\n        address fromToken_,\n        address toToken_,\n        uint256 price_,\n        address user_,\n        uint256 amount_\n    )\n        internal\n    returns(uint256) {\n        // log event: fillOrder\n        emit eFillOrder(fromToken_, toToken_, price_, user_, amount_);\n\n        uint256 toAmount = safeDiv(safeMul(amount_, price_), 1 ether);\n        uint256 fee;\n        updateOrderAmount(fromToken_, toToken_, price_, user_, amount_, false);\n        (toAmount, fee) = caculateFee(user_, toAmount, 0);\n\n        if(manualWithdraw[user_]) {\n            updateBalance(user_, toToken_, toAmount, true);\n        } else {\n            transferToken(user_, toToken_, toAmount);\n        }\n        return fee;\n    }\n    function transferToken(\n        address user_,\n        address token_,\n        uint256 amount_\n    )\n        internal\n    returns(bool) {\n        if(amount_ > 0) {\n            if(token_ == address(0)) {\n                if(address(this).balance < amount_) {\n                    emit Error(1);\n                    return false;\n                } else {\n                    // log event: Withdraw\n                    emit eWithdraw(user_, token_, amount_);\n    \n                    user_.transfer(amount_);\n                    return true;\n                }\n            } else if(Token(token_).transfer(user_, amount_)) {\n                // log event: Withdraw\n                emit eWithdraw(user_, token_, amount_);\n    \n                return true;\n            } else {\n                emit Error(1);\n                return false;\n            }\n        } else {\n            return true;\n        }\n    }\n\n    function updateBalance(\n        address user_,\n        address token_,\n        uint256 amount_,\n        bool addOrSub_\n    )\n        internal\n    returns(bool) {\n        if(addOrSub_) {\n            balances[user_][token_] = safeAdd(balances[user_][token_], amount_);\n        } else {\n            if(checkBalance(user_, token_, amount_, 0)){\n                balances[user_][token_] = safeSub(balances[user_][token_], amount_);\n                return true;\n            } else {\n                return false;\n            }\n        }\n    }\n\n    function connectOrderPrice(\n        address fromToken_,\n        address toToken_,\n        uint256 price_,\n        uint256 prev_\n    )\n        internal\n    {\n        if(checkPriceAmount(price_)) {\n            uint256 prevPrice = getNextOrderPrice(fromToken_, toToken_, prev_);\n            uint256 nextPrice = getNextOrderPrice(fromToken_, toToken_, prevPrice);\n            if(prev_ != price_ && prevPrice != price_ && nextPrice != price_) {\n                if(price_ < prevPrice) {\n                    updateNextOrderPrice(fromToken_, toToken_, prev_, price_);\n                    updateNextOrderPrice(fromToken_, toToken_, price_, prevPrice);\n                } else if(nextPrice == 0) {\n                    updateNextOrderPrice(fromToken_, toToken_, prevPrice, price_);\n                } else {\n                    connectOrderPrice(fromToken_, toToken_, price_, prevPrice);\n                }\n            }\n        }\n    }\n\n    function connectOrderUser(\n        address fromToken_,\n        address toToken_,\n        uint256 price_,\n        address user_\n    )\n        internal \n    {\n        address firstUser = getNextOrderUser(fromToken_, toToken_, price_, 0);\n        if(user_ != address(0) && user_ != firstUser) {\n            updateNextOrderUser(fromToken_, toToken_, price_, 0, user_);\n            if(firstUser != address(0)) {\n                updateNextOrderUser(fromToken_, toToken_, price_, user_, firstUser);\n            }\n        }\n    }\n\n    function disconnectOrderPrice(\n        address fromToken_,\n        address toToken_,\n        uint256 price_\n    )\n        internal\n    {\n        uint256 currPrice = getNextOrderPrice(fromToken_, toToken_, 0);\n        uint256 nextPrice = getNextOrderPrice(fromToken_, toToken_, currPrice);\n        if(price_ == currPrice) {\n            updateNextOrderPrice(fromToken_, toToken_, 0, nextPrice);\n        }\n    }\n\n    function disconnectOrderUser(\n        address fromToken_,\n        address toToken_,\n        uint256 price_,\n        address user_\n    )\n        public\n    {\n        if(user_ == address(0) || getOrderAmount(fromToken_, toToken_, price_, user_) > 0) {\n            return;\n        }\n        address currUser = getNextOrderUser(fromToken_, toToken_, price_, address(0));\n        address nextUser = getNextOrderUser(fromToken_, toToken_, price_, currUser);\n        if(currUser == user_) {\n            updateNextOrderUser(fromToken_, toToken_, price_, address(0), nextUser);\n            if(nextUser == address(0)) {\n                disconnectOrderPrice(fromToken_, toToken_, price_);\n            }\n        }\n    }\n\n    function getNextOrderPrice(\n        address fromToken_,\n        address toToken_,\n        uint256 price_\n    )\n        internal\n        view\n    returns(uint256) {\n        return nextOrderPrice[fromToken_][toToken_][price_];\n    }\n\n    function updateNextOrderPrice(\n        address fromToken_,\n        address toToken_,\n        uint256 price_,\n        uint256 nextPrice_\n    )\n        internal\n    {\n        nextOrderPrice[fromToken_][toToken_][price_] = nextPrice_;\n    }\n\n    function getNextOrderUser(\n        address fromToken_,\n        address toToken_,\n        uint256 price_,\n        address user_\n    )\n        internal\n        view\n    returns(address) {\n        return orderBooks[fromToken_][toToken_][price_][user_].nextUser;\n    }\n\n    function getOrderAmount(\n        address fromToken_,\n        address toToken_,\n        uint256 price_,\n        address user_\n    )\n        internal\n        view\n    returns(uint256) {\n        return orderBooks[fromToken_][toToken_][price_][user_].amount;\n    }\n\n    function updateNextOrderUser(\n        address fromToken_,\n        address toToken_,\n        uint256 price_,\n        address user_,\n        address nextUser_\n    )\n        internal\n    {\n        orderBooks[fromToken_][toToken_][price_][user_].nextUser = nextUser_;\n    }\n\n    function updateOrderAmount(\n        address fromToken_,\n        address toToken_,\n        uint256 price_,\n        address user_,\n        uint256 amount_,\n        bool addOrSub_\n    )\n        internal\n    {\n        if(addOrSub_) {\n            orderBooks[fromToken_][toToken_][price_][user_].amount = safeAdd(orderBooks[fromToken_][toToken_][price_][user_].amount, amount_);\n        } else {\n            orderBooks[fromToken_][toToken_][price_][user_].amount = safeSub(orderBooks[fromToken_][toToken_][price_][user_].amount, amount_);\n            disconnectOrderUser(fromToken_, toToken_, price_, user_);\n        }\n    }\n\n    function logPrice(\n        address fromToken_,\n        address toToken_,\n        uint256 price_\n    )\n        internal\n    {\n        if(price_ > 0) {\n            if(uint256(fromToken_) >= uint256(toToken_)) {\n                priceBooks[fromToken_][toToken_] = price_;\n            } else  {\n                priceBooks[toToken_][fromToken_] = safeDiv(10 ** 36, price_);\n            }\n        }\n    }\n}",
  "bytecode": "606060408181526003805460a060020a60ff021916740100000000000000000000000000000000000000001790555190810160409081526000825266038d7ea4c6800060208301819052908201526200005d90600590600362000127565b50600a60088190556b033b2e3c9fd0803ce80000006009556ec097ce7bc90715b34b9f10000000009055600b8054600160a060020a0319167390528aeb3a2b736b780fd1b6c478bb7e1d6431701790553415620000b957600080fd5b60018054600160a060020a033316600160a060020a0319918216811790925560028054821683179055600380549091169091179055600080526004602052662386f26fc100007f17ef568e3e12ab5b9c7254a8d58478811de00f9e6eb34345acd53bf8fd09d3ec5562000195565b826003810192821562000163579160200282015b8281111562000163578251829066ffffffffffffff169055916020019190600101906200013b565b506200017192915062000175565b5090565b6200019291905b808211156200017157600081556001016200017c565b90565b61248280620001a56000396000f30060606040526004361061019d5763ffffffff60e060020a60003504166305df5e8681146101aa5780630c42e8df146101d957806320e979b11461021057806326a520191461022f57806326f4b3de1461026b5780633c39e63c146102935780633c54ca8c146102bb5780634d0a32db146102e0578063570ca735146102ff5780635eb62178146103125780635f48f393146103315780635fc6518f1461034457806366abbcbd14610363578063683674dc146103b357806369328dec146103e25780636d147c841461040b57806376cdb03b1461042157806384385c6f146104345780638da5cb5b14610453578063a028d74914610466578063a46c792c146104a6578063a4bef732146104c5578063ac41865a146104f8578063b90d86b91461051d578063bc80bee814610530578063c23f001f14610569578063c75abf241461058e578063cc9a31a7146105aa578063d5708d5a146105c9578063dd1219fd146105eb578063df9204b614610603578063e38d6b5c14610616578063f2fde38b14610629578063f9609f0814610648578063f9d176b414610662575b6101a860008061067a565b005b34156101b557600080fd5b6101bd6106da565b604051600160a060020a03909116815260200160405180910390f35b34156101e457600080fd5b6101fe600160a060020a03600435811690602435166106e9565b60405190815260200160405180910390f35b341561021b57600080fd5b6101a8600160a060020a0360043516610706565b610257600160a060020a0360043581169060243581169060443590606435906084351661074d565b604051901515815260200160405180910390f35b610257600160a060020a0360043581169060243581169060443590606435906084351661083b565b341561029e57600080fd5b6101fe600160a060020a0360043581169060243516604435610b04565b34156102c657600080fd5b6101a8600160a060020a0360043581169060243516610b27565b34156102eb57600080fd5b6101fe600160a060020a0360043516610bee565b341561030a57600080fd5b6101bd610c00565b341561031d57600080fd5b6101fe600160a060020a0360043516610c0f565b341561033c57600080fd5b6101fe610c81565b341561034f57600080fd5b6101bd600160a060020a0360043516610c87565b341561036e57600080fd5b610392600160a060020a036004358116906024358116906044359060643516610ca2565b604051918252600160a060020a031660208201526040908101905180910390f35b34156103be57600080fd5b6101a8600160a060020a036004358116906024358116906044359060643516610cde565b34156103ed57600080fd5b610257600160a060020a036004358116906024359060443516610d74565b341561041657600080fd5b6101fe600435610db7565b341561042c57600080fd5b6101bd610dcb565b341561043f57600080fd5b6101a8600160a060020a0360043516610dda565b341561045e57600080fd5b6101bd610e3d565b341561047157600080fd5b61048e600160a060020a036004351660243560ff60443516610e4c565b60405191825260208201526040908101905180910390f35b34156104b157600080fd5b6101a8600160a060020a0360043516610fc2565b34156104d057600080fd5b610257600160a060020a03600435811690602435811690604435906064359060843516610fff565b341561050357600080fd5b6101fe600160a060020a03600435811690602435166110f7565b341561052857600080fd5b6101fe6111b5565b341561053b57600080fd5b6101a860046064816003606060405190810160405291908282606080828437509395506111bb945050505050565b341561057457600080fd5b6101fe600160a060020a0360043581169060243516611241565b341561059957600080fd5b6101a860043560243560443561125e565b34156105b557600080fd5b610257600160a060020a036004351661129f565b34156105d457600080fd5b6101a8600160a060020a03600435166024356112c2565b34156105f657600080fd5b6101a86004351515611311565b341561060e57600080fd5b610257611384565b341561062157600080fd5b6101fe6113a5565b341561063457600080fd5b6101a8600160a060020a03600435166113ab565b6101a8600160a060020a036004358116906024351661067a565b341561066d57600080fd5b6101a860043515156113f2565b600354600090819074010000000000000000000000000000000000000000900460ff1615156106a557fe5b6106ae8361141b565b91506106ba8483611434565b905060008111156106d4576106d2338583600161165e565b505b50505050565b600b54600160a060020a031681565b600e60209081526000928352604080842090915290825290205481565b60015433600160a060020a0390811691161461071e57fe5b6003805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b60008060008061075d8986611434565b9250610769898761173d565b8015610779575061077987611793565b1561082f57600160a060020a038516151561079357600080fd5b8491506107a48989898986886117da565b90507f21a11f4eebc19ad6895c4753dfae2e40d729e2c0a88ff21c5f7b433925f3d542898989858a604051600160a060020a039586168152938516602085015260408085019390935293166060830152608082019290925260a001905180910390a18281111561081357600080fd5b610829338a610822868561182a565b600161165e565b50600193505b50505095945050505050565b600080600061084861239f565b61085061239f565b6000806000600360149054906101000a900460ff16151561086d57fe5b6108768961141b565b96506108828d88611434565b955061088e8d8b61173d565b801561089e575061089e8b611793565b80156108b157506108b1878e8c89611841565b15610adc577f21a11f4eebc19ad6895c4753dfae2e40d729e2c0a88ff21c5f7b433925f3d5428d8d8d8a8e604051600160a060020a039586168152938516602085015260408085019390935293166060830152608082019290925260a001905180910390a16109228d8d8d8d6118ac565b9095509350600085511115610a84577f7df4b7671e89cf44d438b410348aefa7f1fec4753f50d093449fa17b0660051d8d8d8d8a8951604051600160a060020a039586168152938516602085015260408085019390935293166060830152608082019290925260a001905180910390a16109ae6109a086518d611a3b565b670de0b6b3a7640000611a69565b915084518a11156109dd576109cb8a8660005b602002015161182a565b90506109db8d8d8d848b8b6117da565b505b6000821115610a7f576109f287836001610e4c565b93509150826020850151016020850152600354610a2390600160a060020a03168e8660005b6020020151600161165e565b50600354610a3d90600160a060020a03168d866001610a17565b50600160a060020a03871660009081526010602052604090205460ff1615610a7257610a6c878d84600161165e565b50610a7f565b610a7d878d84611a8a565b505b610a96565b5088610a948d8d8d848b8b6117da565b505b858a1115610aba57610ab4878e610aad8d8a61182a565b600061165e565b50610ad3565b858a1015610ad357610ad1878e610822898e61182a565b505b60019750610af4565b6000861115610af457610af2878e88600161165e565b505b5050505050505095945050505050565b600d60209081526000938452604080852082529284528284209052825290205481565b6000806000610b3461239f565b610b3c61239f565b60035474010000000000000000000000000000000000000000900460ff161515610b6257fe5b610b6e87876000611c5d565b9450610b7d8787876000611c8f565b9350610b8b87878787611ccf565b9250610b99878787866118ac565b9092509050600082511115610be557610bbd878787878660005b6020020151611d0d565b6020820151016020820152610bd53388836000610a17565b50610be33387836001610a17565b505b50505050505050565b60046020526000908152604090205481565b600254600160a060020a031681565b600160a060020a038116600090815260046020526040812054819011610c5f576000805260046020527f17ef568e3e12ab5b9c7254a8d58478811de00f9e6eb34345acd53bf8fd09d3ec54610c79565b600160a060020a0382166000908152600460205260409020545b90505b919050565b60095481565b600060208190529081526040902054600160a060020a031681565b600c60209081526000948552604080862082529385528385208152918452828420909152825290208054600190910154600160a060020a031682565b600080600160a060020a0383161580610d0257506000610d0087878787611ccf565b115b15610d0c57610d6c565b610d198686866000611c8f565b9150610d2786868685611c8f565b905082600160a060020a031682600160a060020a03161415610d6c57610d51868686600085611ded565b600160a060020a0381161515610d6c57610d6c868686611e4f565b505050505050565b600080610d808361141b565b9050610d8f818686600061165e565b15610daf57610d9f818686611a8a565b1515610daa57600080fd5b600191505b509392505050565b60058160038110610dc457fe5b0154905081565b600354600160a060020a031681565b60015433600160a060020a03908116911614610df257fe5b60028054600160a060020a0392831673ffffffffffffffffffffffffffffffffffffffff19918216811790925560035490921660009081526020819052604090208054909216179055565b600154600160a060020a031681565b600b5460009081908190819081908190600160a060020a03166370a082318a60405160e060020a63ffffffff8416028152600160a060020a039091166004820152602401602060405180830381600087803b1515610ea957600080fd5b5af11515610eb657600080fd5b5050506040518051600160a060020a038b1660009081526010602052604090205490955060ff169050610efe57600754600560ff891660038110610ef657fe5b015401610f11565b600560ff881660038110610f0e57fe5b01545b925069d3c21bcecceda10000008411610f825769152d02c7e14af68000008411610f675769021e19e0c9bab24000008411610f4c5782610f62565b670de0b6b3a7640000670b1a2bc2ec5000008402045b610f7d565b670de0b6b3a7640000670853a0d2313c00008402045b610f98565b670de0b6b3a76400006706f05b59d3b200008402045b9250610fa76109a08985611a3b565b9150610fb3888361182a565b99919850909650505050505050565b600160a060020a03338116600090815260208190526040902080549190921673ffffffffffffffffffffffffffffffffffffffff19909116179055565b600080600061100d8461141b565b915061101b88888885611ccf565b905084811161102a578061102c565b845b905060008111156110ec577f83afd934d95c384688c268000b159b077ce4b9f5d380c429b1b77c87c3a6cf988888888585604051600160a060020a039586168152938516602085015260408085019390935293166060830152608082019290925260a001905180910390a16110a688888885856000611e82565b600160a060020a03821660009081526010602052604090205460ff16156110da576110d4828983600161165e565b506110e7565b6110e5828983611a8a565b505b600192505b505095945050505050565b6000600160a060020a03808316908416106111385750600160a060020a038083166000908152600e60209081526040808320938516835292905220546111af565b600160a060020a038083166000908152600e602090815260408083209387168352929052908120541161116c5760006111ac565b600160a060020a038083166000908152600e60209081526040808320938716835292905220546111ac906ec097ce7bc90715b34b9f100000000090611a69565b90505b92915050565b60085481565b60025433600160a060020a03908116911614806111e6575060015433600160a060020a039081169116145b15156111ee57fe5b66b1a2bc2ec50000815110801561120f575066b1a2bc2ec500006020820151105b8015611225575066b1a2bc2ec500006040820151105b151561123057600080fd5b61123d60058260036123c5565b5050565b600f60209081526000928352604080842090915290825290205481565b60025433600160a060020a0390811691161480611289575060015433600160a060020a039081169116145b151561129157fe5b600892909255600955600a55565b600160a060020a0390811660009081526020819052604090205433821691161490565b60025433600160a060020a03908116911614806112ed575060015433600160a060020a039081169116145b15156112f557fe5b600160a060020a03909116600090815260046020526040902055565b60025433600160a060020a039081169116148061133c575060015433600160a060020a039081169116145b151561134457fe5b60038054911515740100000000000000000000000000000000000000000274ff000000000000000000000000000000000000000019909216919091179055565b60035474010000000000000000000000000000000000000000900460ff1681565b600a5481565b60015433600160a060020a039081169116146113c357fe5b6001805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b33600160a060020a03166000908152601060205260409020805460ff1916911515919091179055565b60006114268261129f565b6114305733610c79565b5090565b600080600160a060020a03841615156114a2577fb5c75b0495cec767a1e77bcff82a0d104a24248c3f20156b43acd771e3846df383600034604051600160a060020a039384168152919092166020820152604080820192909252606001905180910390a15034905080611657565b600034111561150c577fb5c75b0495cec767a1e77bcff82a0d104a24248c3f20156b43acd771e3846df383600034604051600160a060020a039384168152919092166020820152604080820192909252606001905180910390a161150a83600034600161165e565b505b83600160a060020a031663dd62ed3e333060405160e060020a63ffffffff8516028152600160a060020a03928316600482015291166024820152604401602060405180830381600087803b151561156257600080fd5b5af1151561156f57600080fd5b50505060405180519150506000811180156115fe575083600160a060020a03166323b872dd33308460405160e060020a63ffffffff8616028152600160a060020a0393841660048201529190921660248201526044810191909152606401602060405180830381600087803b15156115e657600080fd5b5af115156115f357600080fd5b505050604051805190505b15611657577fb5c75b0495cec767a1e77bcff82a0d104a24248c3f20156b43acd771e3846df3838583604051600160a060020a039384168152919092166020820152604080820192909252606001905180910390a18091505b5092915050565b600081156116c157600160a060020a038086166000908152600f60209081526040808320938816835292905220546116969084611f8d565b600160a060020a038087166000908152600f6020908152604080832093891683529290522055611735565b6116ce8585856000611841565b1561173157600160a060020a038086166000908152600f6020908152604080832093881683529290522054611703908461182a565b600160a060020a038087166000908152600f6020908152604080832093891683529290522055506001611735565b5060005b949350505050565b60008061174984610c0f565b905060095483118061175a57508083105b1561178a57600080516020612437833981519152600260405190815260200160405180910390a160009150611657565b60019150611657565b60008115806117a35750600a5482115b156117d257600080516020612437833981519152600360405190815260200160405180910390a1506000610c7c565b506001610c7c565b60006117e883888685611841565b1561181c576117fc87878786886001611e82565b6118098787876000611faa565b6118158787878661203a565b5082611820565b5060005b9695505050505050565b6000808284101561183a57600080fd5b5050900390565b600160a060020a038085166000908152600f6020908152604080832093871683529290529081205483906118759084611f8d565b1061188257506001611735565b600080516020612437833981519152600060405190815260200160405180910390a1506000611735565b6118b461239f565b6118bc61239f565b6118c461239f565b6118cc61239f565b6118d46123ff565b6000868180806118e58d8f83611c5d565b90505b600854831080156118f95750600084115b156119845761190b8e8e8e84886120a4565b955060008651111561197a57611923848760006109c1565b935061193888518760005b6020020151611f8d565b885261194a602089015187600161192e565b602089015261195c875187600261192e565b8752600192909201919050806119738d8f83611c5d565b905061197f565b611984565b6118e8565b600088511115611a27576119998d8f846121c5565b6119a76109a089518e611a3b565b94506119b760208901518661182a565b60208801526119c96109a08c8e611a3b565b6020890151106119e45787518b8851010387528a8852611a27565b602088015194508b85670de0b6b3a764000002811515611a0057fe5b048851885101038752611a24611a1e86670de0b6b3a7640000611a3b565b8d611a69565b88525b50959c949b50939950505050505050505050565b6000828202831580611a575750828482811515611a5457fe5b04145b1515611a6257600080fd5b9392505050565b6000808211611a7757600080fd5b8183811515611a8257fe5b049392505050565b600080821115611b6157600160a060020a0383161515611b69578130600160a060020a0316311015611ae057600080516020612437833981519152600160405190815260200160405180910390a1506000611a62565b7fc4e9fd0b0814b142a8dce2da2fb5bbbc63e23ecc9dc77fbdf7e6785b65821073848484604051600160a060020a039384168152919092166020820152604080820192909252606001905180910390a1600160a060020a03841682156108fc0283604051600060405180830381858888f193505050501515611b6157600080fd5b506001611a62565b82600160a060020a031663a9059cbb858460405160e060020a63ffffffff8516028152600160a060020a0390921660048301526024820152604401602060405180830381600087803b1515611bbd57600080fd5b5af11515611bca57600080fd5b5050506040518051905015611c31577fc4e9fd0b0814b142a8dce2da2fb5bbbc63e23ecc9dc77fbdf7e6785b65821073848484604051600160a060020a039384168152919092166020820152604080820192909252606001905180910390a1506001611a62565b600080516020612437833981519152600160405190815260200160405180910390a15060009392505050565b600160a060020a039283166000908152600d602090815260408083209490951682529283528381209181529152205490565b600160a060020a039384166000908152600c6020908152604080832095871683529481528482209382529283528381209185168152915220600101541690565b600160a060020a039384166000908152600c602090815260408083209587168352948152848220938252928352838120919094168452905290205490565b60008060007f7df4b7671e89cf44d438b410348aefa7f1fec4753f50d093449fa17b0660051d8888888888604051600160a060020a039586168152938516602085015260408085019390935293166060830152608082019290925260a001905180910390a1611d7f6109a08588611a3b565b9150611d9088888888886000611e82565b611d9c85836000610e4c565b600160a060020a038716600090815260106020526040902054919350915060ff1615611dd557611dcf858884600161165e565b50611de2565b611de0858884611a8a565b505b979650505050505050565b600160a060020a039485166000908152600c60209081526040808320968816835295815285822094825293845284812092861681529190925291909120600101805473ffffffffffffffffffffffffffffffffffffffff191691909216179055565b600080611e5e85856000611c5d565b9150611e6b858584611c5d565b9050818314156106d2576106d28585600084612253565b8015611f0757600160a060020a038087166000908152600c6020908152604080832089851684528252808320888452825280832093871683529290522054611eca9083611f8d565b600160a060020a038088166000908152600c602090815260408083208a851684528252808320898452825280832093881683529290522055610d6c565b600160a060020a038087166000908152600c6020908152604080832089851684528252808320888452825280832093871683529290522054611f49908361182a565b600160a060020a038088166000908152600c602090815260408083208a851684528252808320898452825280832093881683529290522055610d6c86868686610cde565b6000828201838110801590611a57575082811015611a6257600080fd5b600080611fb684611793565b15610d6c57611fc6868685611c5d565b9150611fd3868684611c5d565b9050838314158015611fe55750838214155b8015611ff15750838114155b15610d6c578184101561201b5761200a86868587612253565b61201686868685612253565b610d6c565b80151561202e5761201686868487612253565b610d6c86868685611faa565b60006120498585856000611c8f565b9050600160a060020a03821615801590612075575080600160a060020a031682600160a060020a031614155b156106d257612088858585600086611ded565b600160a060020a038116156106d2576106d28585858585611ded565b6120ac6123ff565b60008060006120b96123ff565b60006120c36123ff565b6120cd8a8a612289565b156121b557600095506120e38b8d8b6000611c8f565b9450879350600091505b600854821080156120fe5750600084115b80156121125750600160a060020a03851615155b156121b5576121258c8c8c8c89896122e8565b90506000815111156121a55761213d848260006109c1565b935061214c835182600061192e565b835261215e602084015182600161192e565b6020840152612173604084015182600261192e565b604084015293945084936121898b8d8b88611c8f565b9450600160a060020a03851615156121a0576121b5565b6121aa565b6121b5565b6001909101906120ed565b50909a9950505050505050505050565b600081111561224e57600160a060020a038083169084161061220e57600160a060020a038084166000908152600e6020908152604080832093861683529290522081905561224e565b6122276ec097ce7bc90715b34b9f100000000082611a69565b600160a060020a038084166000908152600e60209081526040808320938816835292905220555b505050565b600160a060020a039384166000908152600d60209081526040808320959096168252938452848120928152919092529190912055565b60008282101561229d576111ac8284612289565b670de0b6b3a76400008210156122b5575060016111af565b670de0b6b3a76400008311156122cd575060006111af565b506ec097ce7bc90715b34b9f100000000082820211156111af565b6122f06123ff565b6122f86123ff565b826000808061230a6109a0858c611a3b565b92506123188b8d8b8b611ccf565b91506123276109a0838b611a3b565b905061233584848c8561236c565b855261234382828b8761236c565b60208601526123578b8d8b8b896001610bb3565b604086015250929a9950505050505050505050565b600081841161237b5784612396565b61239661239083670de0b6b3a7640000611a3b565b84611a69565b95945050505050565b604080519081016040526002815b60008152602001906001900390816123ad5790505090565b82600381019282156123f3579160200282015b828111156123f35782518255916020019190600101906123d8565b50611430929150612419565b6060604051908101604052600081526002602082016123ad565b61243391905b80821115611430576000815560010161241f565b9056002e36a7093f25f22bd4cbdeb6040174c3ba4c5fe8f1abc04e7c3c48f26c7413e0a165627a7a723058200372d04afbc11fe6e3cedfd1962615e5214a1898505b350a755b995887a75ba60029"
}