{
  "address": "0xf12b9b6956b719a2c07873154f9e56bd13dfa24e",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "P6",
  "compilerVersion": "v0.4.24+commit.e67f0147",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2018-11-03\n*/\n\npragma solidity ^0.4.23;\n\n// File: contracts/Bankroll.sol\n\ninterface Bankroll {\n\n    //Customer functions\n\n    /// @dev Stores ETH funds for customer\n    function credit(address _customerAddress, uint256 amount) external returns (uint256);\n\n    /// @dev Debits address by an amount\n    function debit(address _customerAddress, uint256 amount) external returns (uint256);\n\n    /// @dev Withraws balance for address; returns amount sent\n    function withdraw(address _customerAddress) external returns (uint256);\n\n    /// @dev Retrieve the token balance of any single address.\n    function balanceOf(address _customerAddress) external view returns (uint256);\n\n    /// @dev Stats of any single address\n    function statsOf(address _customerAddress) external view returns (uint256[8]);\n\n\n    // System functions\n\n    // @dev Deposit funds\n    function deposit() external payable;\n\n    // @dev Deposit on behalf of an address; it is not a credit\n    function depositBy(address _customerAddress) external payable;\n\n    // @dev Distribute house profit\n    function houseProfit(uint256 amount)  external;\n\n\n    /// @dev Get all the ETH stored in contract minus credits to customers\n    function netEthereumBalance() external view returns (uint256);\n\n\n    /// @dev Get all the ETH stored in contract\n    function totalEthereumBalance() external view returns (uint256);\n\n}\n\n// File: contracts/P4RTYRelay.sol\n\n/*\n * Visit: https://p4rty.io\n * Discord: https://discord.gg/7y3DHYF\n*/\n\ninterface P4RTYRelay {\n    /**\n    * @dev Will relay to internal implementation\n    * @param beneficiary Token purchaser\n    * @param tokenAmount Number of tokens to be minted\n    */\n    function relay(address beneficiary, uint256 tokenAmount) external;\n}\n\n// File: contracts/SessionQueue.sol\n\n/// A FIFO queue for storing addresses\ncontract SessionQueue {\n\n    mapping(uint256 => address) private queue;\n    uint256 private first = 1;\n    uint256 private last = 0;\n\n    /// @dev Push into queue\n    function enqueue(address data) internal {\n        last += 1;\n        queue[last] = data;\n    }\n\n    /// @dev Returns true if the queue has elements in it\n    function available() internal view returns (bool) {\n        return last >= first;\n    }\n\n    /// @dev Returns the size of the queue\n    function depth() internal view returns (uint256) {\n        return last - first + 1;\n    }\n\n    /// @dev Pops from the head of the queue\n    function dequeue() internal returns (address data) {\n        require(last >= first);\n        // non-empty queue\n\n        data = queue[first];\n\n        delete queue[first];\n        first += 1;\n    }\n\n    /// @dev Returns the head of the queue without a pop\n    function peek() internal view returns (address data) {\n        require(last >= first);\n        // non-empty queue\n\n        data = queue[first];\n    }\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n// File: openzeppelin-solidity/contracts/ownership/Whitelist.sol\n\n/**\n * @title Whitelist\n * @dev The Whitelist contract has a whitelist of addresses, and provides basic authorization control functions.\n * @dev This simplifies the implementation of \"user permissions\".\n */\ncontract Whitelist is Ownable {\n  mapping(address => bool) public whitelist;\n\n  event WhitelistedAddressAdded(address addr);\n  event WhitelistedAddressRemoved(address addr);\n\n  /**\n   * @dev Throws if called by any account that's not whitelisted.\n   */\n  modifier onlyWhitelisted() {\n    require(whitelist[msg.sender]);\n    _;\n  }\n\n  /**\n   * @dev add an address to the whitelist\n   * @param addr address\n   * @return true if the address was added to the whitelist, false if the address was already in the whitelist\n   */\n  function addAddressToWhitelist(address addr) onlyOwner public returns(bool success) {\n    if (!whitelist[addr]) {\n      whitelist[addr] = true;\n      emit WhitelistedAddressAdded(addr);\n      success = true;\n    }\n  }\n\n  /**\n   * @dev add addresses to the whitelist\n   * @param addrs addresses\n   * @return true if at least one address was added to the whitelist,\n   * false if all addresses were already in the whitelist\n   */\n  function addAddressesToWhitelist(address[] addrs) onlyOwner public returns(bool success) {\n    for (uint256 i = 0; i < addrs.length; i++) {\n      if (addAddressToWhitelist(addrs[i])) {\n        success = true;\n      }\n    }\n  }\n\n  /**\n   * @dev remove an address from the whitelist\n   * @param addr address\n   * @return true if the address was removed from the whitelist,\n   * false if the address wasn't in the whitelist in the first place\n   */\n  function removeAddressFromWhitelist(address addr) onlyOwner public returns(bool success) {\n    if (whitelist[addr]) {\n      whitelist[addr] = false;\n      emit WhitelistedAddressRemoved(addr);\n      success = true;\n    }\n  }\n\n  /**\n   * @dev remove addresses from the whitelist\n   * @param addrs addresses\n   * @return true if at least one address was removed from the whitelist,\n   * false if all addresses weren't in the whitelist in the first place\n   */\n  function removeAddressesFromWhitelist(address[] addrs) onlyOwner public returns(bool success) {\n    for (uint256 i = 0; i < addrs.length; i++) {\n      if (removeAddressFromWhitelist(addrs[i])) {\n        success = true;\n      }\n    }\n  }\n\n}\n\n// File: contracts/P6.sol\n\n// solhint-disable-line\n\n\n\n\n\n\n/*\n * Visit: https://p4rty.io\n * Discord: https://discord.gg/7y3DHYF\n * Stable + DIVIS: Whale and Minow Friendly\n * Fees balanced for maximum dividends for ALL\n * Active depositors rewarded with P4RTY tokens\n * 50% of ETH value in earned P4RTY token rewards\n * 2% of dividends fund a gaming bankroll; gaming profits are paid back into P6\n * P4RTYRelay is notified on all dividend producing transactions\n * Smart Launch phase which is anti-whale & anti-snipe\n *\n * P6\n * The worry free way to earn A TON OF ETH & P4RTY reward tokens\n *\n * -> What?\n * The first Ethereum Bonded Pure Dividend Token:\n * [✓] The only dividend printing press that is part of the P4RTY Entertainment Network\n * [✓] Earn ERC20 P4RTY tokens on all ETH deposit activities\n * [✓] 3% P6 Faucet for free P6 / P4RTY\n * [✓] Auto-Reinvests\n * [✓] 10% exchange fees on buys and sells\n * [✓] 100 tokens to activate faucet\n *\n * -> How?\n * To replay or use the faucet the contract must be fully launched\n * To sell or transfer you need to be vested (maximum of 3 days) after a reinvest\n*/\n\ncontract P6 is Whitelist, SessionQueue {\n\n\n    /*=================================\n    =            MODIFIERS            =\n    =================================*/\n\n    /// @dev Only people with tokens\n    modifier onlyTokenHolders {\n        require(myTokens() > 0);\n        _;\n    }\n\n    /// @dev Only people with profits\n    modifier onlyDivis {\n        require(myDividends(true) > 0);\n        _;\n    }\n\n    /// @dev Only invested; If participating in prelaunch have to buy tokens\n    modifier invested {\n        require(stats[msg.sender].invested > 0, \"Must buy tokens once to withdraw\");\n        _;\n\n    }\n\n    /// @dev Owner not allowed\n    modifier ownerRestricted {\n        require(msg.sender != owner, \"Reap not available, too soon\");\n        _;\n    }\n\n\n    /// @dev The faucet has a rewardPeriod\n    modifier teamPlayer {\n        require(msg.sender == owner || now - lastReward[msg.sender] > rewardProcessingPeriod, \"No spamming\");\n        _;\n    }\n\n\n    /*==============================\n    =            EVENTS            =\n    ==============================*/\n\n    event onLog(\n        string heading,\n        address caller,\n        address subj,\n        uint val\n    );\n\n    event onTokenPurchase(\n        address indexed customerAddress,\n        uint256 incomingEthereum,\n        uint256 tokensMinted,\n        address indexed referredBy,\n        uint timestamp,\n        uint256 price\n    );\n\n    event onTokenSell(\n        address indexed customerAddress,\n        uint256 tokensBurned,\n        uint256 ethereumEarned,\n        uint timestamp,\n        uint256 price\n    );\n\n    event onReinvestment(\n        address indexed customerAddress,\n        uint256 ethereumReinvested,\n        uint256 tokensMinted\n    );\n\n    event onCommunityReward(\n        address indexed sourceAddress,\n        address indexed destinationAddress,\n        uint256 ethereumEarned\n    );\n\n    event onReinvestmentProxy(\n        address indexed customerAddress,\n        address indexed destinationAddress,\n        uint256 ethereumReinvested\n    );\n\n    event onWithdraw(\n        address indexed customerAddress,\n        uint256 ethereumWithdrawn\n    );\n\n    event onDeposit(\n        address indexed customerAddress,\n        uint256 ethereumDeposited\n    );\n\n    // ERC20\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 tokens\n    );\n\n\n    /*=====================================\n    =            CONFIGURABLES            =\n    =====================================*/\n\n    /// @dev 10% dividends for token purchase\n    uint256  internal entryFee_ = 10;\n\n    /// @dev 1% dividends for token transfer\n    uint256  internal transferFee_ = 1;\n\n    /// @dev 10% dividends for token selling\n    uint256  internal exitFee_ = 10;\n\n    /// @dev 3% of entryFee_  is given to faucet\n    /// traditional referral mechanism repurposed as a many to many faucet\n    /// powers auto reinvest\n    uint256  internal referralFee_ = 30;\n\n    /// @dev 20% of entryFee/exit fee is given to Bankroll\n    uint256  internal maintenanceFee_ = 20;\n    address  internal maintenanceAddress;\n\n    //Advanced Config\n    uint256 constant internal botAllowance = 10 ether;\n    uint256 constant internal bankrollThreshold = 0.5 ether;\n    uint256 constant internal botThreshold = 0.01 ether;\n    uint256 constant internal launchPeriod = 24 hours;\n    uint256 constant rewardProcessingPeriod = 3 hours;\n    uint256 constant reapPeriod = 7 days;\n    uint256 public  maxProcessingCap = 10;\n    uint256 constant  launchGasMaximum = 500000;\n    uint256 constant launchETHMaximum = 2 ether;\n    uint256 internal creationTime;\n    bool public contractIsLaunched = false;\n    uint public lastReaped;\n\n\n    uint256 constant internal tokenPriceInitial_ = 0.0000001 ether;\n    uint256 constant internal tokenPriceIncremental_ = 0.00000001 ether;\n\n    uint256 constant internal magnitude = 2 ** 64;\n\n    /// @dev proof of stake (defaults at 100 tokens)\n    uint256 public stakingRequirement = 100e18;\n\n\n    /*=================================\n     =            DATASETS            =\n     ================================*/\n\n    // bookkeeping for autoreinvest\n    struct Bot {\n        bool active;\n        bool queued;\n        uint256 lastBlock;\n    }\n\n    // Onchain Stats!!!\n    struct Stats {\n        uint invested;\n        uint reinvested;\n        uint withdrawn;\n        uint rewarded;\n        uint contributed;\n        uint transferredTokens;\n        uint receivedTokens;\n        uint faucetTokens;\n        uint xInvested;\n        uint xReinvested;\n        uint xRewarded;\n        uint xContributed;\n        uint xWithdrawn;\n        uint xTransferredTokens;\n        uint xReceivedTokens;\n        uint xFaucet;\n    }\n\n\n    // amount of shares for each address (scaled number)\n    mapping(address => uint256) internal lastReward;\n    mapping(address => uint256) internal tokenBalanceLedger_;\n    mapping(address => uint256) internal referralBalance_;\n    mapping(address => int256) internal payoutsTo_;\n    mapping(address => Bot) internal bot;\n    mapping(address => Stats) internal stats;\n    //on chain referral tracking\n    mapping(address => address) public referrals;\n    uint256 internal tokenSupply_;\n    uint256 internal profitPerShare_;\n\n    P4RTYRelay internal relay;\n    Bankroll internal bankroll;\n    bool internal bankrollEnabled = true;\n\n    /*=======================================\n    =            PUBLIC FUNCTIONS           =\n    =======================================*/\n\n    constructor(address relayAddress)  public {\n\n        relay = P4RTYRelay(relayAddress);\n        updateMaintenanceAddress(msg.sender);\n        creationTime = now;\n    }\n\n    //Maintenance Functions\n\n    /// @dev Minted P4RTY tokens are sent to the maintenance address\n    function updateMaintenanceAddress(address maintenance) onlyOwner public {\n        maintenanceAddress = maintenance;\n    }\n\n    /// @dev Update the bankroll; 2% of dividends go to the bankroll\n    function updateBankrollAddress(address bankrollAddress) onlyOwner public {\n        bankroll = Bankroll(bankrollAddress);\n    }\n\n    /// @dev The cap determines the amount of addresses processed when a user runs the faucet\n    function updateProcessingCap(uint cap) onlyOwner public {\n        require(cap >= 5 && cap <= 15, \"Capacity set outside of policy range\");\n        maxProcessingCap = cap;\n    }\n\n\n    function getRegisteredAddresses() public view returns (address[2]){\n        return [address(relay), address(bankroll)];\n    }\n\n\n    //Bot Functions\n\n    /* Activates the bot and queues if necessary; else removes */\n    function activateBot(bool auto) public {\n\n        if (auto) {\n            // does the referrer have at least X whole tokens?\n            // i.e is the referrer a godly chad masternode\n            // We are doing this to avoid spamming the queue with addresses with no P6\n            require(tokenBalanceLedger_[msg.sender] >= stakingRequirement);\n\n            bot[msg.sender].active = auto;\n\n            //Spam protection for customerAddress\n            if (!bot[msg.sender].queued) {\n                bot[msg.sender].queued = true;\n                enqueue(msg.sender);\n            }\n\n        } else {\n            // If you want to turn it off lets just do that\n            bot[msg.sender].active = auto;\n        }\n    }\n\n    /* Returns if the sender has the reinvestment not enabled */\n    function botEnabled() public view returns (bool){\n        return bot[msg.sender].active;\n    }\n\n\n    function fundBankRoll(uint256 amount) internal {\n        bankroll.deposit.value(amount)();\n    }\n\n    /// @dev Converts all incoming ethereum to tokens for the caller, and passes down the referral addy (if any)\n    function buyFor(address _customerAddress) onlyWhitelisted public payable returns (uint256) {\n        return purchaseTokens(_customerAddress, msg.value);\n    }\n\n    /// @dev Converts all incoming ethereum to tokens for the caller\n    function buy() public payable returns (uint256) {\n\n        if (contractIsLaunched || msg.sender == owner) {\n            return purchaseTokens(msg.sender, msg.value);\n        } else {\n            return launchBuy();\n        }\n    }\n\n    /// @dev Provides a buiyin and opens the contract for public use outside of the launch phase\n    function launchBuy() internal returns (uint256){\n\n        /* YAY WE ARE LAUNCHING BABY!!!! */\n\n        // BankrollBot needs to buyin\n        require(stats[owner].invested > botAllowance, \"The bot requires a minimum war chest to protect and serve\");\n\n        // Keep it fair, but this is crypto...\n        require(SafeMath.add(stats[msg.sender].invested, msg.value) <= launchETHMaximum, \"Exceeded investment cap\");\n\n        //See if we are done with the launchPeriod\n        if (now - creationTime > launchPeriod ){\n            contractIsLaunched = true;\n        }\n\n        return purchaseTokens(msg.sender, msg.value);\n    }\n\n    /// @dev Returns the remaining time before full launch and max buys\n    function launchTimer() public view returns (uint256){\n       uint lapse = now - creationTime;\n\n       if (launchPeriod > lapse){\n           return SafeMath.sub(launchPeriod, lapse);\n       }  else {\n           return 0;\n       }\n    }\n\n    /**\n     * @dev Fallback function to handle ethereum that was send straight to the contract\n     *  Unfortunately we cannot use a referral address this way.\n     */\n    function() payable public {\n        purchaseTokens(msg.sender, msg.value);\n    }\n\n    /// @dev Converts all of caller's dividends to tokens.\n    function reinvest() onlyDivis public {\n        reinvestFor(msg.sender);\n    }\n\n    /// @dev Internal utility method for reinvesting\n    function reinvestFor(address _customerAddress) internal returns (uint256) {\n\n        // fetch dividends\n        uint256 _dividends = totalDividends(_customerAddress, false);\n        // retrieve ref. bonus later in the code\n\n        payoutsTo_[_customerAddress] += (int256) (_dividends * magnitude);\n\n        // retrieve ref. bonus\n        _dividends += referralBalance_[_customerAddress];\n        referralBalance_[_customerAddress] = 0;\n\n        // dispatch a buy order with the virtualized \"withdrawn dividends\"\n        uint256 _tokens = purchaseTokens(_customerAddress, _dividends);\n\n        // fire event\n        emit onReinvestment(_customerAddress, _dividends, _tokens);\n\n        //Stats\n        stats[_customerAddress].reinvested = SafeMath.add(stats[_customerAddress].reinvested, _dividends);\n        stats[_customerAddress].xReinvested += 1;\n\n        return _tokens;\n\n    }\n\n    /// @dev Withdraws all of the callers earnings.\n    function withdraw() onlyDivis  public {\n        withdrawFor(msg.sender);\n    }\n\n    /// @dev Utility function for withdrawing earnings\n    function withdrawFor(address _customerAddress) internal {\n\n        // setup data\n        uint256 _dividends = totalDividends(_customerAddress, false);\n        // get ref. bonus later in the code\n\n        // update dividend tracker\n        payoutsTo_[_customerAddress] += (int256) (_dividends * magnitude);\n\n        // add ref. bonus\n        _dividends += referralBalance_[_customerAddress];\n        referralBalance_[_customerAddress] = 0;\n\n        // lambo delivery service\n        _customerAddress.transfer(_dividends);\n\n        //stats\n        stats[_customerAddress].withdrawn = SafeMath.add(stats[_customerAddress].withdrawn, _dividends);\n        stats[_customerAddress].xWithdrawn += 1;\n\n        // fire event\n        emit onWithdraw(_customerAddress, _dividends);\n    }\n\n\n    /// @dev Liquifies tokens to ethereum.\n    function sell(uint256 _amountOfTokens) onlyTokenHolders ownerRestricted public {\n        address _customerAddress = msg.sender;\n\n        //Selling deactivates auto reinvest\n        bot[_customerAddress].active = false;\n\n\n        require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\n        uint256 _tokens = _amountOfTokens;\n        uint256 _ethereum = tokensToEthereum_(_tokens);\n\n\n        uint256 _undividedDividends = SafeMath.div(SafeMath.mul(_ethereum, exitFee_), 100);\n        uint256 _maintenance = SafeMath.div(SafeMath.mul(_undividedDividends, maintenanceFee_), 100);\n        //maintenance and referral come out of the exitfee\n        uint256 _dividends = SafeMath.sub(_undividedDividends, _maintenance);\n        uint256 _taxedEthereum = SafeMath.sub(_ethereum, _undividedDividends);\n\n        // burn the sold tokens\n        tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);\n        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);\n\n        // update dividends tracker\n        int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens + (_taxedEthereum * magnitude));\n        payoutsTo_[_customerAddress] -= _updatedPayouts;\n\n\n        //Apply maintenance fee to the bankroll\n        fundBankRoll(_maintenance);\n\n        // dividing by zero is a bad idea\n        if (tokenSupply_ > 0) {\n            // update the amount of dividends per token\n            profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);\n        }\n\n        // fire event\n        emit onTokenSell(_customerAddress, _tokens, _taxedEthereum, now, buyPrice());\n\n        //GO!!! Bankroll Bot GO!!!\n        brbReinvest(_customerAddress);\n    }\n\n    //@dev Bankroll Bot can only transfer 10% of funds during a reapPeriod\n    //Its funds will always be locked because it always reinvests\n    function reap(address _toAddress) public onlyOwner {\n        require(now - lastReaped > reapPeriod, \"Reap not available, too soon\");\n        lastReaped = now;\n        transferTokens(owner, _toAddress, SafeMath.div(balanceOf(owner), 10));\n\n    }\n\n    /**\n     * @dev Transfer tokens from the caller to a new holder.\n     *  Remember, there's a 1% fee here as well.\n     */\n    function transfer(address _toAddress, uint256 _amountOfTokens) onlyTokenHolders ownerRestricted external returns (bool){\n        address _customerAddress = msg.sender;\n        return transferTokens(_customerAddress, _toAddress, _amountOfTokens);\n    }\n\n    /// @dev Utility function for transfering tokens\n    function transferTokens(address _customerAddress, address _toAddress, uint256 _amountOfTokens) internal returns (bool){\n\n        // make sure we have the requested tokens\n        require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\n\n        // withdraw all outstanding dividends first\n        if (totalDividends(_customerAddress, true) > 0) {\n            withdrawFor(_customerAddress);\n        }\n\n        // liquify a percentage of the tokens that are transfered\n        // these are dispersed to shareholders\n        uint256 _tokenFee = SafeMath.div(SafeMath.mul(_amountOfTokens, transferFee_), 100);\n        uint256 _taxedTokens = SafeMath.sub(_amountOfTokens, _tokenFee);\n        uint256 _dividends = tokensToEthereum_(_tokenFee);\n\n        // burn the fee tokens\n        tokenSupply_ = SafeMath.sub(tokenSupply_, _tokenFee);\n\n        // exchange tokens\n        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\n        tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _taxedTokens);\n\n        // update dividend trackers\n        payoutsTo_[_customerAddress] -= (int256) (profitPerShare_ * _amountOfTokens);\n        payoutsTo_[_toAddress] += (int256) (profitPerShare_ * _taxedTokens);\n\n        // disperse dividends among holders\n        profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);\n\n        // fire event\n        emit Transfer(_customerAddress, _toAddress, _taxedTokens);\n\n        //Stats\n        stats[_customerAddress].xTransferredTokens += 1;\n        stats[_customerAddress].transferredTokens += _amountOfTokens;\n        stats[_toAddress].receivedTokens += _taxedTokens;\n        stats[_toAddress].xReceivedTokens += 1;\n\n        // ERC20\n        return true;\n    }\n\n\n    /*=====================================\n    =      HELPERS AND CALCULATORS        =\n    =====================================*/\n\n    /**\n     * @dev Method to view the current Ethereum stored in the contract\n     *  Example: totalEthereumBalance()\n     */\n    function totalEthereumBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    /// @dev Retrieve the total token supply.\n    function totalSupply() public view returns (uint256) {\n        return tokenSupply_;\n    }\n\n    /// @dev Retrieve the tokens owned by the caller.\n    function myTokens() public view returns (uint256) {\n        address _customerAddress = msg.sender;\n        return balanceOf(_customerAddress);\n    }\n\n    /**\n     * @dev Retrieve the dividends owned by the caller.\n     *  If `_includeReferralBonus` is to to 1/true, the referral bonus will be included in the calculations.\n     *  The reason for this, is that in the frontend, we will want to get the total divs (global + ref)\n     *  But in the internal calculations, we want them separate.\n     */\n    /**\n     * @dev Retrieve the dividends owned by the caller.\n     *  If `_includeReferralBonus` is to to 1/true, the referral bonus will be included in the calculations.\n     *  The reason for this, is that in the frontend, we will want to get the total divs (global + ref)\n     *  But in the internal calculations, we want them separate.\n     */\n    function myDividends(bool _includeReferralBonus) public view returns (uint256) {\n        return totalDividends(msg.sender, _includeReferralBonus);\n    }\n\n    function totalDividends(address _customerAddress, bool _includeReferralBonus) internal view returns (uint256) {\n        return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress);\n    }\n\n    /// @dev Retrieve the token balance of any single address.\n    function balanceOf(address _customerAddress) public view returns (uint256) {\n        return tokenBalanceLedger_[_customerAddress];\n    }\n\n    /// @dev Stats of any single address\n    function statsOf(address _customerAddress) public view returns (uint256[16]){\n        Stats memory s = stats[_customerAddress];\n        uint256[16] memory statArray = [s.invested, s.withdrawn, s.rewarded, s.contributed, s.transferredTokens, s.receivedTokens, s.xInvested, s.xRewarded, s.xContributed, s.xWithdrawn, s.xTransferredTokens, s.xReceivedTokens, s.reinvested, s.xReinvested, s.faucetTokens, s.xFaucet];\n        return statArray;\n    }\n\n    /// @dev Retrieve the dividend balance of any single address.\n    function dividendsOf(address _customerAddress) public view returns (uint256) {\n        return (uint256) ((int256) (profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;\n    }\n\n    /// @dev Return the sell price of 1 individual token.\n    function sellPrice() public view returns (uint256) {\n        // our calculation relies on the token supply, so we need supply. Doh.\n        if (tokenSupply_ == 0) {\n            return tokenPriceInitial_ - tokenPriceIncremental_;\n        } else {\n            uint256 _ethereum = tokensToEthereum_(1e18);\n            uint256 _dividends = SafeMath.div(_ethereum, exitFee_);\n            uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);\n            return _taxedEthereum;\n        }\n\n    }\n\n    /// @dev Return the buy price of 1 individual token.\n    function buyPrice() public view returns (uint256) {\n        // our calculation relies on the token supply, so we need supply. Doh.\n        if (tokenSupply_ == 0) {\n            return tokenPriceInitial_ + tokenPriceIncremental_;\n        } else {\n            uint256 _ethereum = tokensToEthereum_(1e18);\n            uint256 _dividends = SafeMath.div(_ethereum, entryFee_);\n            uint256 _taxedEthereum = SafeMath.add(_ethereum, _dividends);\n            return _taxedEthereum;\n        }\n\n    }\n\n    /// @dev Function for the frontend to dynamically retrieve the price scaling of buy orders.\n    function calculateTokensReceived(uint256 _ethereumToSpend) public view returns (uint256) {\n        uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereumToSpend, entryFee_), 100);\n        uint256 _taxedEthereum = SafeMath.sub(_ethereumToSpend, _dividends);\n        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);\n\n        return _amountOfTokens;\n    }\n\n    /// @dev Function for the frontend to dynamically retrieve the price scaling of sell orders.\n    function calculateEthereumReceived(uint256 _tokensToSell) public view returns (uint256) {\n        require(_tokensToSell <= tokenSupply_);\n        uint256 _ethereum = tokensToEthereum_(_tokensToSell);\n        uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, exitFee_), 100);\n        uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);\n        return _taxedEthereum;\n    }\n\n\n    /*==========================================\n    =            INTERNAL FUNCTIONS            =\n    ==========================================*/\n\n    /// @dev Internal function to actually purchase the tokens.\n    function purchaseTokens(address _customerAddress, uint256 _incomingEthereum) internal returns (uint256) {\n        // data setup\n        address _referredBy = msg.sender;\n        uint256 _undividedDividends = SafeMath.div(SafeMath.mul(_incomingEthereum, entryFee_), 100);\n        uint256 _maintenance = SafeMath.div(SafeMath.mul(_undividedDividends, maintenanceFee_), 100);\n        uint256 _referralBonus = SafeMath.div(SafeMath.mul(_undividedDividends, referralFee_), 100);\n        //maintenance and referral come out of the buyin\n        uint256 _dividends = SafeMath.sub(_undividedDividends, SafeMath.add(_referralBonus, _maintenance));\n        uint256 _taxedEthereum = SafeMath.sub(_incomingEthereum, _undividedDividends);\n        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);\n        uint256 _fee = _dividends * magnitude;\n        uint256 _tokenAllocation = SafeMath.div(_incomingEthereum, 2);\n\n\n        // prevents overflow in the case that the pyramid somehow magically starts being used by everyone in the world\n        // (or hackers)\n        // and yes we know that the safemath function automatically rules out the \"greater then\" equasion.\n        require(_amountOfTokens > 0 && SafeMath.add(_amountOfTokens, tokenSupply_) > tokenSupply_);\n\n        //Apply maintenance fee to bankroll\n        fundBankRoll(_maintenance);\n\n        // is the user referred by a masternode?\n        if (\n\n        // no cheating!\n            _referredBy != _customerAddress &&\n\n            // does the referrer have at least X whole tokens?\n            // i.e is the referrer a godly chad masternode\n            tokenBalanceLedger_[_referredBy] >= stakingRequirement\n        ) {\n            // wealth redistribution\n            referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], _referralBonus);\n\n            //Stats\n            stats[_referredBy].rewarded = SafeMath.add(stats[_referredBy].rewarded, _referralBonus);\n            stats[_referredBy].xRewarded += 1;\n            stats[_customerAddress].contributed = SafeMath.add(stats[_customerAddress].contributed, _referralBonus);\n            stats[_customerAddress].xContributed += 1;\n\n            //It pays to play\n            emit onCommunityReward(_customerAddress, _referredBy, _referralBonus);\n        } else {\n            // no ref purchase\n            // add the referral bonus back to the global dividends cake\n            _dividends = SafeMath.add(_dividends, _referralBonus);\n            _fee = _dividends * magnitude;\n        }\n\n        // we can't give people infinite ethereum\n        if (tokenSupply_ > 0) {\n            // add tokens to the pool\n            tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);\n\n            // take the amount of dividends gained through this transaction, and allocates them evenly to each shareholder\n            profitPerShare_ += (_dividends * magnitude / tokenSupply_);\n\n            // calculate the amount of tokens the customer receives over his purchase\n            _fee = _fee - (_fee - (_amountOfTokens * (_dividends * magnitude / tokenSupply_)));\n        } else {\n            // add tokens to the pool\n            tokenSupply_ = _amountOfTokens;\n        }\n\n        // update circulating supply & the ledger address for the customer\n        tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\n\n        // Tells the contract that the buyer doesn't deserve dividends for the tokens before they owned them;\n        // really i know you think you do but you don't\n        int256 _updatedPayouts = (int256) (profitPerShare_ * _amountOfTokens - _fee);\n        payoutsTo_[_customerAddress] += _updatedPayouts;\n\n        //Notifying the relay is simple and should represent the total economic activity which is the _incomingEthereum\n        //Every player is a customer and mints their own tokens when the buy or reinvest, relay P4RTY 50/50\n        relay.relay(maintenanceAddress, _tokenAllocation);\n        relay.relay(_customerAddress, _tokenAllocation);\n\n        // fire event\n        emit onTokenPurchase(_customerAddress, _incomingEthereum, _amountOfTokens, _referredBy, now, buyPrice());\n\n        //Stats\n        stats[_customerAddress].invested = SafeMath.add(stats[_customerAddress].invested, _incomingEthereum);\n        stats[_customerAddress].xInvested += 1;\n\n        //GO!!! Bankroll Bot GO!!!\n        brbReinvest(_customerAddress);\n\n        return _amountOfTokens;\n    }\n\n    /**\n     * Calculate Token price based on an amount of incoming ethereum\n     * It's an algorithm, hopefully we gave you the whitepaper with it in scientific notation;\n     * Some conversions occurred to prevent decimal errors or underflows / overflows in solidity code.\n     */\n    function ethereumToTokens_(uint256 _ethereum) internal view returns (uint256)\n    {\n        uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;\n        uint256 _tokensReceived =\n        (\n        (\n        // underflow attempts BTFO\n        SafeMath.sub(\n            (sqrt\n        (\n            (_tokenPriceInitial ** 2)\n            +\n            (2 * (tokenPriceIncremental_ * 1e18) * (_ethereum * 1e18))\n            +\n            (((tokenPriceIncremental_) ** 2) * (tokenSupply_ ** 2))\n            +\n            (2 * (tokenPriceIncremental_) * _tokenPriceInitial * tokenSupply_)\n        )\n            ), _tokenPriceInitial\n        )\n        ) / (tokenPriceIncremental_)\n        ) - (tokenSupply_)\n        ;\n\n        return _tokensReceived;\n    }\n\n    /**\n     * Calculate token sell value.\n     * It's an algorithm, hopefully we gave you the whitepaper with it in scientific notation;\n     * Some conversions occurred to prevent decimal errors or underflows / overflows in solidity code.\n     */\n    function tokensToEthereum_(uint256 _tokens) internal view returns (uint256)\n    {\n\n        uint256 tokens_ = (_tokens + 1e18);\n        uint256 _tokenSupply = (tokenSupply_ + 1e18);\n        uint256 _etherReceived =\n        (\n        // underflow attempts BTFO\n        SafeMath.sub(\n            (\n            (\n            (\n            tokenPriceInitial_ + (tokenPriceIncremental_ * (_tokenSupply / 1e18))\n            ) - tokenPriceIncremental_\n            ) * (tokens_ - 1e18)\n            ), (tokenPriceIncremental_ * ((tokens_ ** 2 - tokens_) / 1e18)) / 2\n        )\n        / 1e18);\n        return _etherReceived;\n    }\n\n    /*\n        Is end user eligible to process rewards?\n    */\n    function rewardAvailable() public view returns (bool){\n        return available() && now - lastReward[msg.sender] > rewardProcessingPeriod &&\n        tokenBalanceLedger_[msg.sender] >= stakingRequirement;\n    }\n\n    /// @dev Returns timer info used for the vesting and the faucet\n    function timerInfo() public view returns (uint, uint, uint){\n        return (now, lastReward[msg.sender], rewardProcessingPeriod);\n    }\n\n\n    //This is where all your gas goes, sorry\n    //Not sorry, you probably only paid 1 gwei\n    function sqrt(uint x) internal pure returns (uint y) {\n        uint z = (x + 1) / 2;\n        y = x;\n        while (z < y) {\n            y = z;\n            z = (x / z + z) / 2;\n        }\n    }\n\n    //\n    // BankRollBot Functions\n    //\n\n    //Reinvest on all buys and sells\n    function brbReinvest(address _customerAddress) internal {\n        if (_customerAddress != owner && bankrollEnabled) {\n            if (totalDividends(owner, true) > bankrollThreshold) {\n                reinvestFor(owner);\n            }\n        }\n\n\n    }\n\n    /*\n        Can only be run once per day from the caller avoid bots\n        Minimum of 100 P6\n        Minimum of 5 P4RTY + amount minted based on dividends processed in 24 hour period\n    */\n    function processRewards() public teamPlayer {\n        require(tokenBalanceLedger_[msg.sender] >= stakingRequirement, \"Must meet staking requirement\");\n\n\n        uint256 count = 0;\n        address _customer;\n\n        while (available() && count < maxProcessingCap) {\n\n            //If this queue has already been processed in this block exit without altering the queue\n            _customer = peek();\n\n            if (bot[_customer].lastBlock == block.number) {\n                break;\n            }\n\n            //Pop\n            dequeue();\n\n\n            //Update tracking\n            bot[_customer].lastBlock = block.number;\n            bot[_customer].queued = false;\n\n            //User could have deactivated while still being queued\n            if (bot[_customer].active) {\n\n                // don't queue or process empty accounts\n                if (tokenBalanceLedger_[_customer] >= stakingRequirement) {\n\n                    //Reinvest divs; be gas efficient\n                    if (totalDividends(_customer, true) > botThreshold) {\n\n                        //No bankroll reinvest when processing the queue\n                        bankrollEnabled = false;\n                        reinvestFor(_customer);\n                        bankrollEnabled = true;\n                    }\n\n                    enqueue(_customer);\n                    bot[_customer].queued = true;\n\n                } else {\n                    // If minimums aren't met deactivate\n                    bot[_customer].active = false;\n                }\n            }\n\n            count++;\n        }\n\n        stats[msg.sender].xFaucet += 1;\n        lastReward[msg.sender] = now;\n        stats[msg.sender].faucetTokens = reinvestFor(msg.sender);\n    }\n\n\n}",
  "bytecode": "6080604052600160038190556000600455600a60058190556006919091556007819055601e6008556014600955600b55600d805460ff1916905568056bc75e2d63100000600f55601a805460a060020a60ff0219167401000000000000000000000000000000000000000017905534801561007957600080fd5b50604051602080620025d983398101604052516000805433600160a060020a0319918216811790925560198054909116600160a060020a0384161790556100c8906401000000006100d2810204565b5042600c5561010b565b600054600160a060020a031633146100e957600080fd5b600a8054600160a060020a031916600160a060020a0392909216919091179055565b6124be806200011b6000396000f3006080604052600436106101d35763ffffffff60e060020a60003504166265318b81146101e05780630bc0504e1461021357806310d0ffdd1461023657806313f3c37b1461024e57806315cfc4051461026357806318160ddd146102bd5780632150097f146102d25780632260937314610305578063227ef0611461031d57806324953eaa14610349578063275893a9146103b2578063286dd3f5146103d35780633ccfd60b146103f45780634b7503341461040957806356d399e81461041e578063681a6e8414610433578063688abbf7146104485780636b2f4632146104625780636f0b51801461047757806370a082311461048b57806374a57889146104ac5780637b9417c8146104c15780638620410b146104e25780638af9f493146104f75780638da5cb5b14610518578063949e8acd146105495780639b19251a1461055e5780639ca423b31461057f578063a1282c9b146105a0578063a6f2ae3a146105b8578063a9059cbb146105c0578063e2ec6ec3146105e4578063e4849b3214610639578063e4f8bfd114610651578063e815cc9414610666578063ed70000114610680578063f2fde38b14610695578063f9fc0d07146106b6578063fca3b304146106cb578063fdb5a03e146106e0575b6101dd33346106f5565b50005b3480156101ec57600080fd5b50610201600160a060020a0360043516610bb2565b60408051918252519081900360200190f35b34801561021f57600080fd5b50610234600160a060020a0360043516610bf0565b005b34801561024257600080fd5b50610201600435610c36565b34801561025a57600080fd5b50610201610c6b565b34801561026f57600080fd5b50610284600160a060020a0360043516610c71565b604051808261020080838360005b838110156102aa578181015183820152602001610292565b5050505090500191505060405180910390f35b3480156102c957600080fd5b50610201610e1c565b3480156102de57600080fd5b506102e7610e23565b60408051938452602084019290925282820152519081900360600190f35b34801561031157600080fd5b50610201600435610e3b565b34801561032957600080fd5b50610332610e78565b604080518251815290819083908083836020610292565b34801561035557600080fd5b506040805160206004803580820135838102808601850190965280855261039e95369593946024949385019291829185019084908082843750949750610ea79650505050505050565b604080519115158252519081900360200190f35b3480156103be57600080fd5b50610234600160a060020a0360043516610f06565b3480156103df57600080fd5b5061039e600160a060020a0360043516610f4c565b34801561040057600080fd5b50610234610fe2565b34801561041557600080fd5b50610201611003565b34801561042a57600080fd5b50610201611058565b34801561043f57600080fd5b5061020161105e565b34801561045457600080fd5b50610201600435151561108e565b34801561046e57600080fd5b506102016110a0565b610201600160a060020a03600435166110a5565b34801561049757600080fd5b50610201600160a060020a03600435166110cd565b3480156104b857600080fd5b5061039e6110e8565b3480156104cd57600080fd5b5061039e600160a060020a03600435166110fe565b3480156104ee57600080fd5b50610201611199565b34801561050357600080fd5b50610234600160a060020a03600435166111e2565b34801561052457600080fd5b5061052d61128a565b60408051600160a060020a039092168252519081900360200190f35b34801561055557600080fd5b50610201611299565b34801561056a57600080fd5b5061039e600160a060020a03600435166112ab565b34801561058b57600080fd5b5061052d600160a060020a03600435166112c0565b3480156105ac57600080fd5b506102346004356112db565b610201611384565b3480156105cc57600080fd5b5061039e600160a060020a03600435166024356113c0565b3480156105f057600080fd5b506040805160206004803580820135838102808601850190965280855261039e9536959394602494938501929182918501908490808284375094975061144f9650505050505050565b34801561064557600080fd5b506102346004356114a8565b34801561065d57600080fd5b506102016116c5565b34801561067257600080fd5b5061023460043515156116cb565b34801561068c57600080fd5b5061039e611764565b3480156106a157600080fd5b50610234600160a060020a036004351661176d565b3480156106c257600080fd5b50610234611801565b3480156106d757600080fd5b5061039e611aba565b3480156106ec57600080fd5b50610234611b07565b600080600080600080600080600080600033995061071f6107188d600554611b26565b6064611b4f565b98506107306107188a600954611b26565b97506107416107188a600854611b26565b965061075689610751898b611b64565b611b71565b95506107628c8a611b71565b945061076d85611b83565b935068010000000000000000860292506107888c6002611b4f565b91506000841180156107a457506017546107a28582611b64565b115b15156107af57600080fd5b6107b888611c1b565b8c600160a060020a03168a600160a060020a0316141580156107f45750600f54600160a060020a038b1660009081526011602052604090205410155b156108fe57600160a060020a038a1660009081526012602052604090205461081c9088611b64565b600160a060020a038b1660009081526012602090815260408083209390935560159052206003015461084e9088611b64565b600160a060020a03808c166000908152601560205260408082206003810194909455600a90930180546001019055908f16815220600401546108909088611b64565b600160a060020a03808f166000818152601560209081526040918290206004810195909555600b9094018054600101905580518b81529051928e169391927f1f199f5326ae23f37e738f64ee17ce22576cfb9cd73fa7872b0797fd6a8fecc4929181900390910190a3610919565b6109088688611b64565b955068010000000000000000860292505b6000601754111561097d5761093060175485611b64565b601781905568010000000000000000870281151561094a57fe5b6018805492909104909101905560175468010000000000000000870281151561096f57fe5b048402830383039250610983565b60178490555b600160a060020a038d166000908152601160205260409020546109a69085611b64565b600160a060020a03808f16600090815260116020908152604080832094909455601854601390915283822080549189028890039182019055601954600a5485517feeec0e2400000000000000000000000000000000000000000000000000000000815290851660048201526024810188905294519195509092169263eeec0e24926044808301939282900301818387803b158015610a4357600080fd5b505af1158015610a57573d6000803e3d6000fd5b50505050601960009054906101000a9004600160a060020a0316600160a060020a031663eeec0e248e846040518363ffffffff1660e060020a0281526004018083600160a060020a0316600160a060020a0316815260200182815260200192505050600060405180830381600087803b158015610ad357600080fd5b505af1158015610ae7573d6000803e3d6000fd5b5050505089600160a060020a03168d600160a060020a03167f8032875b28d82ddbd303a9e4e5529d047a14ecb6290f80012a81b7e6227ff1ab8e8742610b2b611199565b604080519485526020850193909352838301919091526060830152519081900360800190a3600160a060020a038d16600090815260156020526040902054610b73908d611b64565b600160a060020a038e16600090815260156020526040902090815560080180546001019055610ba18d611c8a565b50919b9a5050505050505050505050565b600160a060020a038116600090815260136020908152604080832054601190925282205460185468010000000000000000929102030490505b919050565b600054600160a060020a03163314610c0757600080fd5b601a805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b600080600080610c4b61071886600554611b26565b9250610c578584611b71565b9150610c6282611b83565b95945050505050565b600b5481565b610c796123d9565b610c816123f9565b610c896123d9565b6015600085600160a060020a0316600160a060020a03168152602001908152602001600020610200604051908101604052908160008201548152602001600182015481526020016002820154815260200160038201548152602001600482015481526020016005820154815260200160068201548152602001600782015481526020016008820154815260200160098201548152602001600a8201548152602001600b8201548152602001600c8201548152602001600d8201548152602001600e8201548152602001600f82015481525050915061020060405190810160405280836000015181526020018360400151815260200183606001518152602001836080015181526020018360a0015181526020018360c0015181526020018361010001518152602001836101400151815260200183610160015181526020018361018001518152602001836101a001518152602001836101c0015181526020018360200151815260200183610120015181526020018360e001518152602001836101e0015181525090508092505050919050565b6017545b90565b336000908152601060205260409020544291612a3090565b6000806000806017548511151515610e5257600080fd5b610e5b85611d03565b9250610e6c61071884600754611b26565b9150610c628383611b71565b610e80612477565b5060408051808201909152601954600160a060020a039081168252601a5416602082015290565b600080548190600160a060020a03163314610ec157600080fd5b5060005b8251811015610f0057610eee8382815181101515610edf57fe5b90602001906020020151610f4c565b15610ef857600191505b600101610ec5565b50919050565b600054600160a060020a03163314610f1d57600080fd5b600a805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b60008054600160a060020a03163314610f6457600080fd5b600160a060020a03821660009081526001602052604090205460ff1615610beb57600160a060020a038216600081815260016020908152604091829020805460ff19169055815192835290517ff1abf01a1043b7c244d128e8595cf0c1d10743b022b03a02dffd8ca3bf729f5a9281900390910190a1506001919050565b6000610fee600161108e565b11610ff857600080fd5b61100133611d6f565b565b60008060008060175460001415611021576414f46b04009350611052565b611032670de0b6b3a7640000611d03565b925061104083600754611b4f565b915061104c8383611b71565b90508093505b50505090565b600f5481565b600c546000904203620151808110156110855761107e6201518082611b71565b915061108a565b600091505b5090565b600061109a3383611e72565b92915050565b303190565b3360009081526001602052604081205460ff1615156110c357600080fd5b61109a82346106f5565b600160a060020a031660009081526011602052604090205490565b3360009081526014602052604090205460ff1690565b60008054600160a060020a0316331461111657600080fd5b600160a060020a03821660009081526001602052604090205460ff161515610beb57600160a060020a038216600081815260016020818152604092839020805460ff1916909217909155815192835290517fd1bba68c128cc3f427e5831b3c6f99f480b6efa6b9e80c757768f6124158cc3f9281900390910190a1506001919050565b600080600080601754600014156111b75764199c82cc009350611052565b6111c8670de0b6b3a7640000611d03565b92506111d683600554611b4f565b915061104c8383611b64565b600054600160a060020a031633146111f957600080fd5b62093a80600e544203111515611259576040805160e560020a62461bcd02815260206004820152601c60248201527f52656170206e6f7420617661696c61626c652c20746f6f20736f6f6e00000000604482015290519081900360640190fd5b42600e5560005461128690600160a060020a03168261128161127a836110cd565b600a611b4f565b611eb2565b5050565b600054600160a060020a031681565b6000336112a5816110cd565b91505090565b60016020526000908152604090205460ff1681565b601660205260009081526040902054600160a060020a031681565b600054600160a060020a031633146112f257600080fd5b600581101580156113045750600f8111155b151561137f576040805160e560020a62461bcd028152602060048201526024808201527f436170616369747920736574206f757473696465206f6620706f6c696379207260448201527f616e676500000000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b600b55565b600d5460009060ff16806113a25750600054600160a060020a031633145b156113b8576113b133346106f5565b9050610e20565b6113b161208f565b60008060006113cd611299565b116113d757600080fd5b600054600160a060020a031633141561143a576040805160e560020a62461bcd02815260206004820152601c60248201527f52656170206e6f7420617661696c61626c652c20746f6f20736f6f6e00000000604482015290519081900360640190fd5b5033611447818585611eb2565b949350505050565b600080548190600160a060020a0316331461146957600080fd5b5060005b8251811015610f0057611496838281518110151561148757fe5b906020019060200201516110fe565b156114a057600191505b60010161146d565b60008060008060008060008060006114be611299565b116114c857600080fd5b600054600160a060020a031633141561152b576040805160e560020a62461bcd02815260206004820152601c60248201527f52656170206e6f7420617661696c61626c652c20746f6f20736f6f6e00000000604482015290519081900360640190fd5b336000818152601460209081526040808320805460ff19169055601190915290205490985089111561155c57600080fd5b88965061156887611d03565b955061157961071887600754611b26565b945061158a61071886600954611b26565b93506115968585611b71565b92506115a28686611b71565b91506115b060175488611b71565b601755600160a060020a0388166000908152601160205260409020546115d69088611b71565b600160a060020a0389166000908152601160209081526040808320939093556018546013909152919020805491890268010000000000000000850201918290039055905061162384611c1b565b600060175411156116565761165260185460175468010000000000000000860281151561164c57fe5b04611b64565b6018555b87600160a060020a03167f8d3a0130073dbd54ab6ac632c05946df540553d3b514c9f8165b4ab7f2b1805e88844261168c611199565b604080519485526020850193909352838301919091526060830152519081900360800190a26116ba88611c8a565b505050505050505050565b600e5481565b801561174557600f543360009081526011602052604090205410156116ef57600080fd5b336000908152601460205260409020805460ff1916821515179081905560ff61010090910416151561174057336000818152601460205260409020805461ff001916610100179055611740906121cd565b611761565b336000908152601460205260409020805460ff19168215151790555b50565b600d5460ff1681565b600054600160a060020a0316331461178457600080fd5b600160a060020a038116151561179957600080fd5b60008054604051600160a060020a03808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a36000805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b600080548190600160a060020a0316331480611832575033600090815260106020526040902054612a304291909103115b1515611888576040805160e560020a62461bcd02815260206004820152600b60248201527f4e6f207370616d6d696e67000000000000000000000000000000000000000000604482015290519081900360640190fd5b600f543360009081526011602052604090205410156118f1576040805160e560020a62461bcd02815260206004820152601d60248201527f4d757374206d656574207374616b696e6720726571756972656d656e74000000604482015290519081900360640190fd5b600091505b6118fe612213565b801561190b5750600b5482105b15611a745761191861221e565b600160a060020a03811660009081526014602052604090206001015490915043141561194357611a74565b61194b612252565b50600160a060020a0381166000908152601460205260409020436001820155805461ff0019811690915560ff1615611a6957600f54600160a060020a03821660009081526011602052604090205410611a4857662386f26fc100006119b1826001611e72565b1115611a1557601a805474ff0000000000000000000000000000000000000000191690556119de816122ab565b50601a805474ff00000000000000000000000000000000000000001916740100000000000000000000000000000000000000001790555b611a1e816121cd565b600160a060020a0381166000908152601460205260409020805461ff001916610100179055611a69565b600160a060020a0381166000908152601460205260409020805460ff191690555b6001909101906118f6565b336000818152601560209081526040808320600f018054600101905560109091529020429055611aa3906122ab565b336000908152601560205260409020600701555050565b6000611ac4612213565b8015611ae5575033600090815260106020526040902054612a304291909103115b8015611b025750600f543360009081526011602052604090205410155b905090565b6000611b13600161108e565b11611b1d57600080fd5b611761336122ab565b6000821515611b375750600061109a565b50818102818382811515611b4757fe5b041461109a57fe5b60008183811515611b5c57fe5b049392505050565b8181018281101561109a57fe5b600082821115611b7d57fe5b50900390565b6017546000906c01431e0fae6d7217caa00000009082906402540be400611c08611c02730380d4bd8a8678c1bb542c80deb4800000000000880268056bc75e2d631000006002860a02017005e0a1fd2712875988becaad0000000000850201780197d4df19d605767337e9f14d3eec8920e400000000000000016123a4565b85611b71565b811515611c1157fe5b0403949350505050565b601a60009054906101000a9004600160a060020a0316600160a060020a031663d0e30db0826040518263ffffffff1660e060020a0281526004016000604051808303818588803b158015611c6e57600080fd5b505af1158015611c82573d6000803e3d6000fd5b505050505050565b600054600160a060020a03828116911614801590611cc25750601a5474010000000000000000000000000000000000000000900460ff165b15611761576000546706f05b59d3b2000090611ce890600160a060020a03166001611e72565b11156117615760005461128690600160a060020a03166122ab565b601754600090670de0b6b3a7640000838101918101908390611d5c6414f46b04008285046402540be40002018702600283670de0b6b3a763ffff1982890a8b900301046402540be40002811515611d5657fe5b04611b71565b811515611d6557fe5b0495945050505050565b6000611d7c826000611e72565b600160a060020a038316600081815260136020908152604080832080546801000000000000000087020190556012909152808220805490839055905193019350909183156108fc0291849190818181858888f19350505050158015611de5573d6000803e3d6000fd5b50600160a060020a038216600090815260156020526040902060020154611e0c9082611b64565b600160a060020a0383166000818152601560209081526040918290206002810194909455600c909301805460010190558051848152905191927fccad973dcd043c7d680389db4378bd6b9775db7124092e9e0422c9e46d7985dc92918290030190a25050565b600081611e8757611e8283610bb2565b611eab565b600160a060020a038316600090815260126020526040902054611ea984610bb2565b015b9392505050565b600160a060020a038316600090815260116020526040812054819081908190851115611edd57600080fd5b6000611eea886001611e72565b1115611ef957611ef987611d6f565b611f0861071886600654611b26565b9250611f148584611b71565b9150611f1f83611d03565b9050611f2d60175484611b71565b601755600160a060020a038716600090815260116020526040902054611f539086611b71565b600160a060020a038089166000908152601160205260408082209390935590881681522054611f829083611b64565b600160a060020a0387811660008181526011602090815260408083209590955560188054948d16835260139091528482208054948b02909403909355825491815292909220805492850290920190915554601754611ff0919068010000000000000000840281151561164c57fe5b601855604080518381529051600160a060020a0380891692908a16917fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef9181900360200190a3600160a060020a03808816600090815260156020526040808220600d810180546001908101909155600590910180548a0190559289168252902060068101805485019055600e0180548201905593505050509392505050565b60008054600160a060020a0316815260156020526040812054678ac7230489e800001061212c576040805160e560020a62461bcd02815260206004820152603960248201527f54686520626f742072657175697265732061206d696e696d756d20776172206360448201527f6865737420746f2070726f7465637420616e6420736572766500000000000000606482015290519081900360840190fd5b33600090815260156020526040902054671bc16d674ec80000906121509034611b64565b11156121a6576040805160e560020a62461bcd02815260206004820152601760248201527f457863656564656420696e766573746d656e7420636170000000000000000000604482015290519081900360640190fd5b62015180600c54420311156121c357600d805460ff191660011790555b611b0233346106f5565b60048054600101908190556000908152600260205260409020805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b600354600454101590565b60006003546004541015151561223357600080fd5b50600354600090815260026020526040902054600160a060020a031690565b60006003546004541015151561226757600080fd5b50600380546000908152600260205260409020805473ffffffffffffffffffffffffffffffffffffffff1981169091558154600101909155600160a060020a031690565b60008060006122bb846000611e72565b600160a060020a0385166000908152601360209081526040808320805468010000000000000000860201905560129091528120805491905501915061230084836106f5565b905083600160a060020a03167fbe339fc14b041c2b0e0f3dd2cd325d0c3668b78378001e53160eab36153264588383604051808381526020018281526020019250505060405180910390a2600160a060020a0384166000908152601560205260409020600101546123719083611b64565b600160a060020a038516600090815260156020526040902060018082019290925560090180549091019055915050919050565b80600260018201045b81811015610f005780915060028182858115156123c657fe5b04018115156123d157fe5b0490506123ad565b610200604051908101604052806010906020820280388339509192915050565b61020060405190810160405280600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b604080518082018252906002908290803883395091929150505600a165627a7a72305820affaf4bb23f0a1991e8027e4acc2750125cbc58244372cd123fd257c2374d2e900290000000000000000000000000a0a80cd0ff4f906ce7617a415787614a9651e1a",
  "constructorArguments": "0000000000000000000000000a0a80cd0ff4f906ce7617a415787614a9651e1a"
}