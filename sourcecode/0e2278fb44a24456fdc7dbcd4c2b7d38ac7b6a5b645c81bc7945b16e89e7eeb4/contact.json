{
  "address": "0x6be50c4a12edc59ad663ddb8b8814fe46f9bbf5c",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "MintAndBurnAdmin",
  "compilerVersion": "v0.5.4+commit.9549d8ff",
  "optimization": true,
  "runs": "10000000",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2019-06-07\n*/\n\ncontract MintAndBurnAdmin {\n\n    // TYPES\n\n    struct Proposal {\n        address addr;\n        uint256 value;\n        bool isMint;\n        uint256 time;\n        bool closed;\n    }\n\n    // DATA\n\n    ReserveDollar public reserve;\n    uint256 public constant delay = 12 hours;\n    address public admin;\n\n    Proposal[] public proposals;\n\n    // EVENTS\n\n    event ProposalCreated(uint256 index, address indexed addr, uint256 value, bool isMint, uint256 delayUntil);\n    event ProposalConfirmed(uint256 index, address indexed addr, uint256 value, bool isMint);\n    event ProposalCancelled(uint256 index, address indexed addr, uint256 value, bool isMint);\n    event AllProposalsCancelled();\n\n    // FUNCTIONALITY\n\n    constructor(address reserveDollar) public {\n        reserve = ReserveDollar(reserveDollar);\n        admin = msg.sender;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"must be admin\");\n        _;\n    }\n\n    /// Propose a new mint or burn, which can be confirmed after 12 hours.\n    function propose(address addr, uint256 value, bool isMint) external onlyAdmin {\n        // Delay by at least 12 hours.\n        // We are relying on block.timestamp for this, and aware of the possibility of its\n        // manipulation by miners. But given the in-protocol bounds on the change in\n        // block.timestamp and the way we are using it, we are satisfied with this choice.\n        // solium-disable-next-line security/no-block-members\n        uint256 delayUntil = now + delay;\n\n        proposals.push(Proposal({\n            addr: addr,\n            value: value,\n            isMint: isMint,\n            time: delayUntil,\n            closed: false\n        }));\n\n        emit ProposalCreated(proposals.length - 1, addr, value, isMint, delayUntil);\n    }\n\n    /// Cancel a proposed mint or burn.\n    function cancel(uint256 index, address addr, uint256 value, bool isMint) external onlyAdmin {\n        // Check authorization.\n        requireMatchingOpenProposal(index, addr, value, isMint);\n\n        // Cancel proposal.\n        proposals[index].closed = true;\n        emit ProposalCancelled(index, addr, value, isMint);\n    }\n\n    /// Cancel all proposals.\n    function cancelAll() external onlyAdmin {\n        proposals.length = 0;\n        emit AllProposalsCancelled();\n    }\n\n    /// Confirm and execute a proposed mint or burn, if enough time has passed since the proposal.\n    function confirm(uint256 index, address addr, uint256 value, bool isMint) external onlyAdmin {\n        // Check authorization.\n        requireMatchingOpenProposal(index, addr, value, isMint);\n\n        // See commentary above about using `now`.\n        // solium-disable-next-line security/no-block-members\n        require(proposals[index].time < now, \"too early\");\n\n        // Record execution of proposal.\n        proposals[index].closed = true;\n        emit ProposalConfirmed(index, addr, value, isMint);\n\n        // Proceed with execution of proposal.\n        if (proposals[index].isMint) {\n            reserve.mint(addr, value);\n        } else {\n            reserve.burnFrom(addr, value);\n        }\n    }\n\n    /// Throw unless the given proposal exists and matches `addr`, `value`, and `isMint`.\n    function requireMatchingOpenProposal(uint256 index, address addr, uint256 value, bool isMint) private view {\n        require(!proposals[index].closed, \"proposal already closed\");\n\n        // Slither reports \"dangerous strict equality\" for each of these, but it's OK.\n        // These equalities are to confirm that the proposal entered is equal to the\n        // matching previous proposal. We're vetting data entry; strict equality is appropriate.\n        require(proposals[index].addr == addr, \"addr mismatched\");\n        require(proposals[index].value == value, \"value mismatched\");\n        require(proposals[index].isMint == isMint, \"isMint mismatched\");\n    }\n}\n\ninterface IERC20 {\n    function transfer(address, uint256) external returns (bool);\n    function approve(address, uint256) external returns (bool);\n    function transferFrom(address, address, uint256) external returns (bool);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address) external view returns (uint256);\n    function allowance(address, address) external view returns (uint256);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed holder, address indexed spender, uint256 value);\n}\n\ncontract ReserveDollar is IERC20 {\n    using SafeMath for uint256;\n\n\n    // DATA\n\n\n    // Non-constant-sized data\n    ReserveDollarEternalStorage internal data;\n\n    // Basic token data\n    string public name = \"Reserve Dollar\";\n    string public symbol = \"RSVD\";\n    uint8 public constant decimals = 18;\n    uint256 public totalSupply;\n\n    // Paused data\n    bool public paused;\n\n    // Auth roles\n    address public owner;\n    address public minter;\n    address public pauser;\n    address public freezer;\n    address public nominatedOwner;\n\n\n    // EVENTS\n\n\n    // Auth role change events\n    event OwnerChanged(address indexed newOwner);\n    event MinterChanged(address indexed newMinter);\n    event PauserChanged(address indexed newPauser);\n    event FreezerChanged(address indexed newFreezer);\n\n    // Pause events\n    event Paused(address indexed account);\n    event Unpaused(address indexed account);\n\n    // Name change event\n    event NameChanged(string newName, string newSymbol);\n\n    // Law enforcement events\n    event Frozen(address indexed freezer, address indexed account);\n    event Unfrozen(address indexed freezer, address indexed account);\n    event Wiped(address indexed freezer, address indexed wiped);\n\n\n    // FUNCTIONALITY\n\n\n    /// Initialize critical fields.\n    constructor() public {\n        data = new ReserveDollarEternalStorage(msg.sender);\n        owner = msg.sender;\n        pauser = msg.sender;\n        // Other roles deliberately default to the zero address.\n    }\n\n    /// Accessor for eternal storage contract address.\n    function getEternalStorageAddress() external view returns(address) {\n        return address(data);\n    }\n\n\n    // ==== Admin functions ====\n\n\n    /// Modifies a function to only run if sent by `role`.\n    modifier only(address role) {\n        require(msg.sender == role, \"unauthorized: not role holder\");\n        _;\n    }\n\n    /// Modifies a function to only run if sent by `role` or the contract's `owner`.\n    modifier onlyOwnerOr(address role) {\n        require(msg.sender == owner || msg.sender == role, \"unauthorized: not role holder and not owner\");\n        _;\n    }\n\n    /// Change who holds the `minter` role.\n    function changeMinter(address newMinter) external onlyOwnerOr(minter) {\n        minter = newMinter;\n        emit MinterChanged(newMinter);\n    }\n\n    /// Change who holds the `pauser` role.\n    function changePauser(address newPauser) external onlyOwnerOr(pauser) {\n        pauser = newPauser;\n        emit PauserChanged(newPauser);\n    }\n\n    /// Change who holds the `freezer` role.\n    function changeFreezer(address newFreezer) external onlyOwnerOr(freezer) {\n        freezer = newFreezer;\n        emit FreezerChanged(newFreezer);\n    }\n\n    /// Nominate a new `owner`.  We want to ensure that `owner` is always valid, so we don't\n    /// actually change `owner` to `nominatedOwner` until `nominatedOwner` calls `acceptOwnership`.\n    function nominateNewOwner(address nominee) external only(owner) {\n        nominatedOwner = nominee;\n    }\n\n    /// Accept nomination for ownership.\n    /// This completes the `nominateNewOwner` handshake.\n    function acceptOwnership() external onlyOwnerOr(nominatedOwner) {\n        if (msg.sender != owner) {\n            emit OwnerChanged(msg.sender);\n        }\n        owner = msg.sender;\n        nominatedOwner = address(0);\n    }\n\n    /// Set `owner` to 0.\n    /// Only do this to deliberately lock in the current permissions.\n    function renounceOwnership() external only(owner) {\n        owner = address(0);\n        emit OwnerChanged(owner);\n    }\n\n    /// Make a different address own the EternalStorage contract.\n    /// This will break this contract, so only do it if you're\n    /// abandoning this contract, e.g., for an upgrade.\n    function transferEternalStorage(address newOwner) external only(owner) {\n        data.transferOwnership(newOwner);\n    }\n\n    /// Change the name and ticker symbol of this token.\n    function changeName(string calldata newName, string calldata newSymbol) external only(owner) {\n        name = newName;\n        symbol = newSymbol;\n        emit NameChanged(newName, newSymbol);\n    }\n\n    /// Pause the contract.\n    function pause() external only(pauser) {\n        paused = true;\n        emit Paused(pauser);\n    }\n\n    /// Unpause the contract.\n    function unpause() external only(pauser) {\n        paused = false;\n        emit Unpaused(pauser);\n    }\n\n    /// Modifies a function to run only when the contract is not paused.\n    modifier notPaused() {\n        require(!paused, \"contract is paused\");\n        _;\n    }\n\n    /// Freeze token transactions for a particular address.\n    function freeze(address account) external only(freezer) {\n        require(data.frozenTime(account) == 0, \"account already frozen\");\n\n        // In `wipe` we use block.timestamp (aka `now`) to check that enough time has passed since\n        // this freeze happened. That required time delay -- 4 weeks -- is a long time relative to\n        // the maximum drift of block.timestamp, so it is fine to trust the miner here.\n        // solium-disable-next-line security/no-block-members\n        data.setFrozenTime(account, now);\n\n        emit Frozen(freezer, account);\n    }\n\n    /// Unfreeze token transactions for a particular address.\n    function unfreeze(address account) external only(freezer) {\n        require(data.frozenTime(account) > 0, \"account not frozen\");\n        data.setFrozenTime(account, 0);\n        emit Unfrozen(freezer, account);\n    }\n\n    /// Modifies a function to run only when the `account` is not frozen.\n    modifier notFrozen(address account) {\n        require(data.frozenTime(account) == 0, \"account frozen\");\n        _;\n    }\n\n    /// Burn the balance of an account that has been frozen for at least 4 weeks.\n    function wipe(address account) external only(freezer) {\n        require(data.frozenTime(account) > 0, \"cannot wipe unfrozen account\");\n        // See commentary above about using block.timestamp.\n        // solium-disable-next-line security/no-block-members\n        require(data.frozenTime(account) + 4 weeks < now, \"cannot wipe frozen account before 4 weeks\");\n        _burn(account, data.balance(account));\n        emit Wiped(freezer, account);\n    }\n\n\n    // ==== Token transfers, allowances, minting, and burning ====\n\n\n    /// @return how many attotokens are held by `holder`.\n    function balanceOf(address holder) external view returns (uint256) {\n        return data.balance(holder);\n    }\n\n    /// @return how many attotokens `holder` has allowed `spender` to control.\n    function allowance(address holder, address spender) external view returns (uint256) {\n        return data.allowed(holder, spender);\n    }\n\n    /// Transfer `value` attotokens from `msg.sender` to `to`.\n    function transfer(address to, uint256 value)\n        external\n        notPaused\n        notFrozen(msg.sender)\n        notFrozen(to)\n        returns (bool)\n    {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * Approve `spender` to spend `value` attotokens on behalf of `msg.sender`.\n     *\n     * Beware that changing a nonzero allowance with this method brings the risk that\n     * someone may use both the old and the new allowance by unfortunate transaction ordering. One\n     * way to mitigate this risk is to first reduce the spender's allowance\n     * to 0, and then set the desired value afterwards, per\n     * [this ERC-20 issue](https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729).\n     *\n     * A simpler workaround is to use `increaseAllowance` or `decreaseAllowance`, below.\n     *\n     * @param spender address The address which will spend the funds.\n     * @param value uint256 How many attotokens to allow `spender` to spend.\n     */\n    function approve(address spender, uint256 value)\n        external\n        notPaused\n        notFrozen(msg.sender)\n        notFrozen(spender)\n        returns (bool)\n    {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    /// Transfer approved tokens from one address to another.\n    /// @param from address The address to send tokens from.\n    /// @param to address The address to send tokens to.\n    /// @param value uint256 The number of attotokens to send.\n    function transferFrom(address from, address to, uint256 value)\n        external\n        notPaused\n        notFrozen(msg.sender)\n        notFrozen(from)\n        notFrozen(to)\n        returns (bool)\n    {\n        _transfer(from, to, value);\n        _approve(from, msg.sender, data.allowed(from, msg.sender).sub(value));\n        return true;\n    }\n\n    /// Increase `spender`'s allowance of the sender's tokens.\n    /// @dev From MonolithDAO Token.sol\n    /// @param spender The address which will spend the funds.\n    /// @param addedValue How many attotokens to increase the allowance by.\n    function increaseAllowance(address spender, uint256 addedValue)\n        external\n        notPaused\n        notFrozen(msg.sender)\n        notFrozen(spender)\n        returns (bool)\n    {\n        _approve(msg.sender, spender, data.allowed(msg.sender, spender).add(addedValue));\n        return true;\n    }\n\n    /// Decrease `spender`'s allowance of the sender's tokens.\n    /// @dev From MonolithDAO Token.sol\n    /// @param spender The address which will spend the funds.\n    /// @param subtractedValue How many attotokens to decrease the allowance by.\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        external\n        notPaused\n        notFrozen(msg.sender)\n        // This is the one case in which changing the allowance of a frozen spender is allowed.\n        // notFrozen(spender)\n        returns (bool)\n    {\n        _approve(msg.sender, spender, data.allowed(msg.sender, spender).sub(subtractedValue));\n        return true;\n    }\n\n    /// Mint `value` new attotokens to `account`.\n    function mint(address account, uint256 value)\n        external\n        notPaused\n        notFrozen(account)\n        only(minter)\n    {\n        require(account != address(0), \"can't mint to address zero\");\n\n        totalSupply = totalSupply.add(value);\n        data.addBalance(account, value);\n        emit Transfer(address(0), account, value);\n    }\n\n    /// Burn `value` attotokens from `account`, if sender has that much allowance from `account`.\n    function burnFrom(address account, uint256 value)\n        external\n        notPaused\n        notFrozen(account)\n        only(minter)\n    {\n        _burn(account, value);\n        _approve(account, msg.sender, data.allowed(account, msg.sender).sub(value));\n    }\n\n    /// @dev Transfer of `value` attotokens from `from` to `to`.\n    /// Internal; doesn't check permissions.\n    function _transfer(address from, address to, uint256 value) internal {\n        require(to != address(0), \"can't transfer to address zero\");\n\n        data.subBalance(from, value);\n        data.addBalance(to, value);\n        emit Transfer(from, to, value);\n    }\n\n    /// @dev Burn `value` attotokens from `account`.\n    /// Internal; doesn't check permissions.\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0), \"can't burn from address zero\");\n\n        totalSupply = totalSupply.sub(value);\n        data.subBalance(account, value);\n        emit Transfer(account, address(0), value);\n    }\n\n    /// @dev Set `spender`'s allowance on `holder`'s tokens to `value` attotokens.\n    /// Internal; doesn't check permissions.\n    function _approve(address holder, address spender, uint256 value) internal {\n        require(spender != address(0), \"spender cannot be address zero\");\n        require(holder != address(0), \"holder cannot be address zero\");\n\n        data.setAllowed(holder, spender, value);\n        emit Approval(holder, spender, value);\n    }\n}\n\ncontract ReserveDollarEternalStorage {\n\n    using SafeMath for uint256;\n\n\n\n    // ===== auth =====\n\n    address public owner;\n    address public escapeHatch;\n\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\n    event EscapeHatchTransferred(address indexed oldEscapeHatch, address indexed newEscapeHatch);\n\n    /// On construction, set auth fields.\n    constructor(address escapeHatchAddress) public {\n        owner = msg.sender;\n        escapeHatch = escapeHatchAddress;\n    }\n\n    /// Only run modified function if sent by `owner`.\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"onlyOwner\");\n        _;\n    }\n\n    /// Set `owner`.\n    function transferOwnership(address newOwner) external {\n        require(msg.sender == owner || msg.sender == escapeHatch, \"not authorized\");\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n\n    /// Set `escape hatch`.\n    function transferEscapeHatch(address newEscapeHatch) external {\n        require(msg.sender == escapeHatch, \"not authorized\");\n        emit EscapeHatchTransferred(escapeHatch, newEscapeHatch);\n        escapeHatch = newEscapeHatch;\n    }\n\n    // ===== balance =====\n\n    mapping(address => uint256) public balance;\n\n    /// Add `value` to `balance[key]`, unless this causes integer overflow.\n    ///\n    /// @dev This is a slight divergence from the strict Eternal Storage pattern, but it reduces the gas\n    /// for the by-far most common token usage, it's a *very simple* divergence, and `setBalance` is\n    /// available anyway.\n    function addBalance(address key, uint256 value) external onlyOwner {\n        balance[key] = balance[key].add(value);\n    }\n\n    /// Subtract `value` from `balance[key]`, unless this causes integer underflow.\n    function subBalance(address key, uint256 value) external onlyOwner {\n        balance[key] = balance[key].sub(value);\n    }\n\n    /// Set `balance[key]` to `value`.\n    function setBalance(address key, uint256 value) external onlyOwner {\n        balance[key] = value;\n    }\n\n\n\n    // ===== allowed =====\n\n    mapping(address => mapping(address => uint256)) public allowed;\n\n    /// Set `to`'s allowance of `from`'s tokens to `value`.\n    function setAllowed(address from, address to, uint256 value) external onlyOwner {\n        allowed[from][to] = value;\n    }\n\n\n\n    // ===== frozenTime =====\n\n    /// @dev When `frozenTime[addr] == 0`, `addr` is not frozen. This is the normal state.\n    /// When `frozenTime[addr] == t` and `t > 0`, `addr` was last frozen at timestamp `t`.\n    /// So, to unfreeze an address `addr`, set `frozenTime[addr] = 0`.\n    mapping(address => uint256) public frozenTime;\n\n    /// Set `frozenTime[who]` to `time`.\n    function setFrozenTime(address who, uint256 time) external onlyOwner {\n        frozenTime[who] = time;\n    }\n}\n\nlibrary SafeMath {\n    /**\n     * @dev Multiplies two unsigned integers, reverts on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two unsigned integers, reverts on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n     * reverts when dividing by zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}",
  "abi": "[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposals\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"isMint\",\"type\":\"bool\"},{\"name\":\"time\",\"type\":\"uint256\"},{\"name\":\"closed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cancelAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"isMint\",\"type\":\"bool\"}],\"name\":\"cancel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"isMint\",\"type\":\"bool\"}],\"name\":\"propose\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"delay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserve\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"isMint\",\"type\":\"bool\"}],\"name\":\"confirm\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"reserveDollar\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"isMint\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"delayUntil\",\"type\":\"uint256\"}],\"name\":\"ProposalCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"isMint\",\"type\":\"bool\"}],\"name\":\"ProposalConfirmed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"isMint\",\"type\":\"bool\"}],\"name\":\"ProposalCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"AllProposalsCancelled\",\"type\":\"event\"}]",
  "bytecode": "608060405234801561001057600080fd5b50604051602080610e3c8339810180604052602081101561003057600080fd5b505160008054600160a060020a03909216600160a060020a03199283161790556001805490911633179055610dd28061006a6000396000f3fe608060405234801561001057600080fd5b50600436106100a5576000357c0100000000000000000000000000000000000000000000000000000000900480636a42b8f8116100785780636a42b8f81461019d578063cd3293de146101b7578063dba82a45146101e8578063f851a4401461022f576100a5565b8063013cf08b146100aa57806318cb2b181461010b57806334a0f49a146101155780635e77e64e1461015c575b600080fd5b6100c7600480360360208110156100c057600080fd5b5035610237565b6040805173ffffffffffffffffffffffffffffffffffffffff9096168652602086019490945291151584840152606084015215156080830152519081900360a00190f35b610113610294565b005b6101136004803603608081101561012b57600080fd5b5080359073ffffffffffffffffffffffffffffffffffffffff60208201351690604081013590606001351515610353565b6101136004803603606081101561017257600080fd5b5073ffffffffffffffffffffffffffffffffffffffff81351690602081013590604001351515610498565b6101a5610715565b60408051918252519081900360200190f35b6101bf61071b565b6040805173ffffffffffffffffffffffffffffffffffffffff9092168252519081900360200190f35b610113600480360360808110156101fe57600080fd5b5080359073ffffffffffffffffffffffffffffffffffffffff60208201351690604081013590606001351515610737565b6101bf610a5c565b600280548290811061024557fe5b60009182526020909120600590910201805460018201546002830154600384015460049094015473ffffffffffffffffffffffffffffffffffffffff9093169450909260ff9182169290911685565b60015473ffffffffffffffffffffffffffffffffffffffff16331461031a57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600d60248201527f6d7573742062652061646d696e00000000000000000000000000000000000000604482015290519081900360640190fd5b6000610327600282610ce9565b506040517f3732302b0efc3e1e883bb80d83c641031dc1e32223cb406c3e4d5de68208c4e990600090a1565b60015473ffffffffffffffffffffffffffffffffffffffff1633146103d957604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600d60248201527f6d7573742062652061646d696e00000000000000000000000000000000000000604482015290519081900360640190fd5b6103e584848484610a78565b60016002858154811015156103f657fe5b600091825260209182902060046005909202010180549215157fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff009093169290921790915560408051868152918201849052821515828201525173ffffffffffffffffffffffffffffffffffffffff8516917fc1ea9ad7fe3cfb48a741fc229353411aabb3b135d9446697bf6db7c197a9ac0f919081900360600190a250505050565b60015473ffffffffffffffffffffffffffffffffffffffff16331461051e57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600d60248201527f6d7573742062652061646d696e00000000000000000000000000000000000000604482015290519081900360640190fd5b6040805160a08101825273ffffffffffffffffffffffffffffffffffffffff858116808352602080840187815286151585870181815261a8c04201606080890182815260006080808c0182815260028054600181018255938190529c517f405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace600590940293840180547fffffffffffffffffffffffff00000000000000000000000000000000000000001691909d1617909b5596517f405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5acf82015593517f405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ad0850180547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0090811692151592909217905590517f405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ad185015597517f405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ad2909301805490981692151592909217909655955487517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff919091018152928301899052828701529381018390529351919390927fd1d2eb762bbbecbc03b8a9dd22368874018771d0c93d855cd08c5a8fa6086b9692918290030190a250505050565b61a8c081565b60005473ffffffffffffffffffffffffffffffffffffffff1681565b60015473ffffffffffffffffffffffffffffffffffffffff1633146107bd57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600d60248201527f6d7573742062652061646d696e00000000000000000000000000000000000000604482015290519081900360640190fd5b6107c984848484610a78565b426002858154811015156107d957fe5b90600052602060002090600502016003015410151561085957604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600960248201527f746f6f206561726c790000000000000000000000000000000000000000000000604482015290519081900360640190fd5b600160028581548110151561086a57fe5b600091825260209182902060046005909202010180549215157fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff009093169290921790915560408051868152918201849052821515828201525173ffffffffffffffffffffffffffffffffffffffff8516917fc398e86b1dfd2596a48f97df67ac573ef31251ea5b65d73e4096be478df18f57919081900360600190a2600280548590811061091457fe5b600091825260209091206002600590920201015460ff16156109c55760008054604080517f40c10f1900000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff878116600483015260248201879052915191909216926340c10f19926044808201939182900301818387803b1580156109a857600080fd5b505af11580156109bc573d6000803e3d6000fd5b50505050610a56565b60008054604080517f79cc679000000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff878116600483015260248201879052915191909216926379cc6790926044808201939182900301818387803b158015610a3d57600080fd5b505af1158015610a51573d6000803e3d6000fd5b505050505b50505050565b60015473ffffffffffffffffffffffffffffffffffffffff1681565b6002805485908110610a8657fe5b600091825260209091206004600590920201015460ff1615610b0957604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601760248201527f70726f706f73616c20616c726561647920636c6f736564000000000000000000604482015290519081900360640190fd5b8273ffffffffffffffffffffffffffffffffffffffff16600285815481101515610b2f57fe5b600091825260209091206005909102015473ffffffffffffffffffffffffffffffffffffffff1614610bc257604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600f60248201527f61646472206d69736d6174636865640000000000000000000000000000000000604482015290519081900360640190fd5b81600285815481101515610bd257fe5b906000526020600020906005020160010154141515610c5257604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601060248201527f76616c7565206d69736d61746368656400000000000000000000000000000000604482015290519081900360640190fd5b801515600285815481101515610c6457fe5b600091825260209091206002600590920201015460ff16151514610a5657604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f69734d696e74206d69736d617463686564000000000000000000000000000000604482015290519081900360640190fd5b815481835581811115610d1557600502816005028360005260206000209182019101610d159190610d1a565b505050565b610da391905b80821115610d9f5780547fffffffffffffffffffffffff00000000000000000000000000000000000000001681556000600182018190556002820180547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0090811690915560038301919091556004820180549091169055600501610d20565b5090565b9056fea165627a7a723058207c62bc273ac46c34a1c824db13d9f026b689e4d893f4d69383ab1c7b7d6cece90029000000000000000000000000ffceeba0bdb21304a9f3d575dbcfebe583192c24",
  "constructorArguments": "000000000000000000000000ffceeba0bdb21304a9f3d575dbcfebe583192c24"
}