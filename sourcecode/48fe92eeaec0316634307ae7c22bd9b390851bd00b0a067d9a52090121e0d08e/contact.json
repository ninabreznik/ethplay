{
  "address": "0x2bae491b065032a76be1db9e9ecf5738afae203e",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "DutchExchange",
  "compilerVersion": "v0.5.2+commit.1df8f40c",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2019-02-08\n*/\n\npragma solidity ^0.5.2;\n\n// File: @gnosis.pm/util-contracts/contracts/Proxy.sol\n\n/// @title Proxied - indicates that a contract will be proxied. Also defines storage requirements for Proxy.\n/// @author Alan Lu - <[email protected]>\ncontract Proxied {\n    address public masterCopy;\n}\n\n/// @title Proxy - Generic proxy contract allows to execute all transactions applying the code of a master contract.\n/// @author Stefan George - <[email protected]>\ncontract Proxy is Proxied {\n    /// @dev Constructor function sets address of master copy contract.\n    /// @param _masterCopy Master copy address.\n    constructor(address _masterCopy) public {\n        require(_masterCopy != address(0), \"The master copy is required\");\n        masterCopy = _masterCopy;\n    }\n\n    /// @dev Fallback function forwards all transactions and returns all received return data.\n    function() external payable {\n        address _masterCopy = masterCopy;\n        assembly {\n            calldatacopy(0, 0, calldatasize)\n            let success := delegatecall(not(0), _masterCopy, 0, calldatasize, 0, 0)\n            returndatacopy(0, 0, returndatasize)\n            switch success\n                case 0 {\n                    revert(0, returndatasize)\n                }\n                default {\n                    return(0, returndatasize)\n                }\n        }\n    }\n}\n\n// File: @gnosis.pm/util-contracts/contracts/Token.sol\n\n/// Implements ERC 20 Token standard: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\npragma solidity ^0.5.2;\n\n/// @title Abstract token contract - Functions to be implemented by token contracts\ncontract Token {\n    /*\n     *  Events\n     */\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n\n    /*\n     *  Public functions\n     */\n    function transfer(address to, uint value) public returns (bool);\n    function transferFrom(address from, address to, uint value) public returns (bool);\n    function approve(address spender, uint value) public returns (bool);\n    function balanceOf(address owner) public view returns (uint);\n    function allowance(address owner, address spender) public view returns (uint);\n    function totalSupply() public view returns (uint);\n}\n\n// File: @gnosis.pm/util-contracts/contracts/Math.sol\n\n/// @title Math library - Allows calculation of logarithmic and exponential functions\n/// @author Alan Lu - <[email protected]>\n/// @author Stefan George - <[email protected]>\nlibrary GnosisMath {\n    /*\n     *  Constants\n     */\n    // This is equal to 1 in our calculations\n    uint public constant ONE = 0x10000000000000000;\n    uint public constant LN2 = 0xb17217f7d1cf79ac;\n    uint public constant LOG2_E = 0x171547652b82fe177;\n\n    /*\n     *  Public functions\n     */\n    /// @dev Returns natural exponential function value of given x\n    /// @param x x\n    /// @return e**x\n    function exp(int x) public pure returns (uint) {\n        // revert if x is > MAX_POWER, where\n        // MAX_POWER = int(mp.floor(mp.log(mpf(2**256 - 1) / ONE) * ONE))\n        require(x <= 2454971259878909886679);\n        // return 0 if exp(x) is tiny, using\n        // MIN_POWER = int(mp.floor(mp.log(mpf(1) / ONE) * ONE))\n        if (x < -818323753292969962227) return 0;\n        // Transform so that e^x -> 2^x\n        x = x * int(ONE) / int(LN2);\n        // 2^x = 2^whole(x) * 2^frac(x)\n        //       ^^^^^^^^^^ is a bit shift\n        // so Taylor expand on z = frac(x)\n        int shift;\n        uint z;\n        if (x >= 0) {\n            shift = x / int(ONE);\n            z = uint(x % int(ONE));\n        } else {\n            shift = x / int(ONE) - 1;\n            z = ONE - uint(-x % int(ONE));\n        }\n        // 2^x = 1 + (ln 2) x + (ln 2)^2/2! x^2 + ...\n        //\n        // Can generate the z coefficients using mpmath and the following lines\n        // >>> from mpmath import mp\n        // >>> mp.dps = 100\n        // >>> ONE =  0x10000000000000000\n        // >>> print('\\n'.join(hex(int(mp.log(2)**i / mp.factorial(i) * ONE)) for i in range(1, 7)))\n        // 0xb17217f7d1cf79ab\n        // 0x3d7f7bff058b1d50\n        // 0xe35846b82505fc5\n        // 0x276556df749cee5\n        // 0x5761ff9e299cc4\n        // 0xa184897c363c3\n        uint zpow = z;\n        uint result = ONE;\n        result += 0xb17217f7d1cf79ab * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0x3d7f7bff058b1d50 * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0xe35846b82505fc5 * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0x276556df749cee5 * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0x5761ff9e299cc4 * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0xa184897c363c3 * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0xffe5fe2c4586 * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0x162c0223a5c8 * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0x1b5253d395e * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0x1e4cf5158b * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0x1e8cac735 * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0x1c3bd650 * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0x1816193 * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0x131496 * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0xe1b7 * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0x9c7 * zpow / ONE;\n        if (shift >= 0) {\n            if (result >> (256 - shift) > 0) return (2 ** 256 - 1);\n            return result << shift;\n        } else return result >> (-shift);\n    }\n\n    /// @dev Returns natural logarithm value of given x\n    /// @param x x\n    /// @return ln(x)\n    function ln(uint x) public pure returns (int) {\n        require(x > 0);\n        // binary search for floor(log2(x))\n        int ilog2 = floorLog2(x);\n        int z;\n        if (ilog2 < 0) z = int(x << uint(-ilog2));\n        else z = int(x >> uint(ilog2));\n        // z = x * 2^-⌊log₂x⌋\n        // so 1 <= z < 2\n        // and ln z = ln x - ⌊log₂x⌋/log₂e\n        // so just compute ln z using artanh series\n        // and calculate ln x from that\n        int term = (z - int(ONE)) * int(ONE) / (z + int(ONE));\n        int halflnz = term;\n        int termpow = term * term / int(ONE) * term / int(ONE);\n        halflnz += termpow / 3;\n        termpow = termpow * term / int(ONE) * term / int(ONE);\n        halflnz += termpow / 5;\n        termpow = termpow * term / int(ONE) * term / int(ONE);\n        halflnz += termpow / 7;\n        termpow = termpow * term / int(ONE) * term / int(ONE);\n        halflnz += termpow / 9;\n        termpow = termpow * term / int(ONE) * term / int(ONE);\n        halflnz += termpow / 11;\n        termpow = termpow * term / int(ONE) * term / int(ONE);\n        halflnz += termpow / 13;\n        termpow = termpow * term / int(ONE) * term / int(ONE);\n        halflnz += termpow / 15;\n        termpow = termpow * term / int(ONE) * term / int(ONE);\n        halflnz += termpow / 17;\n        termpow = termpow * term / int(ONE) * term / int(ONE);\n        halflnz += termpow / 19;\n        termpow = termpow * term / int(ONE) * term / int(ONE);\n        halflnz += termpow / 21;\n        termpow = termpow * term / int(ONE) * term / int(ONE);\n        halflnz += termpow / 23;\n        termpow = termpow * term / int(ONE) * term / int(ONE);\n        halflnz += termpow / 25;\n        return (ilog2 * int(ONE)) * int(ONE) / int(LOG2_E) + 2 * halflnz;\n    }\n\n    /// @dev Returns base 2 logarithm value of given x\n    /// @param x x\n    /// @return logarithmic value\n    function floorLog2(uint x) public pure returns (int lo) {\n        lo = -64;\n        int hi = 193;\n        // I use a shift here instead of / 2 because it floors instead of rounding towards 0\n        int mid = (hi + lo) >> 1;\n        while ((lo + 1) < hi) {\n            if (mid < 0 && x << uint(-mid) < ONE || mid >= 0 && x >> uint(mid) < ONE) hi = mid;\n            else lo = mid;\n            mid = (hi + lo) >> 1;\n        }\n    }\n\n    /// @dev Returns maximum of an array\n    /// @param nums Numbers to look through\n    /// @return Maximum number\n    function max(int[] memory nums) public pure returns (int maxNum) {\n        require(nums.length > 0);\n        maxNum = -2 ** 255;\n        for (uint i = 0; i < nums.length; i++) if (nums[i] > maxNum) maxNum = nums[i];\n    }\n\n    /// @dev Returns whether an add operation causes an overflow\n    /// @param a First addend\n    /// @param b Second addend\n    /// @return Did no overflow occur?\n    function safeToAdd(uint a, uint b) internal pure returns (bool) {\n        return a + b >= a;\n    }\n\n    /// @dev Returns whether a subtraction operation causes an underflow\n    /// @param a Minuend\n    /// @param b Subtrahend\n    /// @return Did no underflow occur?\n    function safeToSub(uint a, uint b) internal pure returns (bool) {\n        return a >= b;\n    }\n\n    /// @dev Returns whether a multiply operation causes an overflow\n    /// @param a First factor\n    /// @param b Second factor\n    /// @return Did no overflow occur?\n    function safeToMul(uint a, uint b) internal pure returns (bool) {\n        return b == 0 || a * b / b == a;\n    }\n\n    /// @dev Returns sum if no overflow occurred\n    /// @param a First addend\n    /// @param b Second addend\n    /// @return Sum\n    function add(uint a, uint b) internal pure returns (uint) {\n        require(safeToAdd(a, b));\n        return a + b;\n    }\n\n    /// @dev Returns difference if no overflow occurred\n    /// @param a Minuend\n    /// @param b Subtrahend\n    /// @return Difference\n    function sub(uint a, uint b) internal pure returns (uint) {\n        require(safeToSub(a, b));\n        return a - b;\n    }\n\n    /// @dev Returns product if no overflow occurred\n    /// @param a First factor\n    /// @param b Second factor\n    /// @return Product\n    function mul(uint a, uint b) internal pure returns (uint) {\n        require(safeToMul(a, b));\n        return a * b;\n    }\n\n    /// @dev Returns whether an add operation causes an overflow\n    /// @param a First addend\n    /// @param b Second addend\n    /// @return Did no overflow occur?\n    function safeToAdd(int a, int b) internal pure returns (bool) {\n        return (b >= 0 && a + b >= a) || (b < 0 && a + b < a);\n    }\n\n    /// @dev Returns whether a subtraction operation causes an underflow\n    /// @param a Minuend\n    /// @param b Subtrahend\n    /// @return Did no underflow occur?\n    function safeToSub(int a, int b) internal pure returns (bool) {\n        return (b >= 0 && a - b <= a) || (b < 0 && a - b > a);\n    }\n\n    /// @dev Returns whether a multiply operation causes an overflow\n    /// @param a First factor\n    /// @param b Second factor\n    /// @return Did no overflow occur?\n    function safeToMul(int a, int b) internal pure returns (bool) {\n        return (b == 0) || (a * b / b == a);\n    }\n\n    /// @dev Returns sum if no overflow occurred\n    /// @param a First addend\n    /// @param b Second addend\n    /// @return Sum\n    function add(int a, int b) internal pure returns (int) {\n        require(safeToAdd(a, b));\n        return a + b;\n    }\n\n    /// @dev Returns difference if no overflow occurred\n    /// @param a Minuend\n    /// @param b Subtrahend\n    /// @return Difference\n    function sub(int a, int b) internal pure returns (int) {\n        require(safeToSub(a, b));\n        return a - b;\n    }\n\n    /// @dev Returns product if no overflow occurred\n    /// @param a First factor\n    /// @param b Second factor\n    /// @return Product\n    function mul(int a, int b) internal pure returns (int) {\n        require(safeToMul(a, b));\n        return a * b;\n    }\n}\n\n// File: @gnosis.pm/util-contracts/contracts/GnosisStandardToken.sol\n\n/**\n * Deprecated: Use Open Zeppeling one instead\n */\ncontract StandardTokenData {\n    /*\n     *  Storage\n     */\n    mapping(address => uint) balances;\n    mapping(address => mapping(address => uint)) allowances;\n    uint totalTokens;\n}\n\n/**\n * Deprecated: Use Open Zeppeling one instead\n */\n/// @title Standard token contract with overflow protection\ncontract GnosisStandardToken is Token, StandardTokenData {\n    using GnosisMath for *;\n\n    /*\n     *  Public functions\n     */\n    /// @dev Transfers sender's tokens to a given address. Returns success\n    /// @param to Address of token receiver\n    /// @param value Number of tokens to transfer\n    /// @return Was transfer successful?\n    function transfer(address to, uint value) public returns (bool) {\n        if (!balances[msg.sender].safeToSub(value) || !balances[to].safeToAdd(value)) {\n            return false;\n        }\n\n        balances[msg.sender] -= value;\n        balances[to] += value;\n        emit Transfer(msg.sender, to, value);\n        return true;\n    }\n\n    /// @dev Allows allowed third party to transfer tokens from one address to another. Returns success\n    /// @param from Address from where tokens are withdrawn\n    /// @param to Address to where tokens are sent\n    /// @param value Number of tokens to transfer\n    /// @return Was transfer successful?\n    function transferFrom(address from, address to, uint value) public returns (bool) {\n        if (!balances[from].safeToSub(value) || !allowances[from][msg.sender].safeToSub(\n            value\n        ) || !balances[to].safeToAdd(value)) {\n            return false;\n        }\n        balances[from] -= value;\n        allowances[from][msg.sender] -= value;\n        balances[to] += value;\n        emit Transfer(from, to, value);\n        return true;\n    }\n\n    /// @dev Sets approved amount of tokens for spender. Returns success\n    /// @param spender Address of allowed account\n    /// @param value Number of approved tokens\n    /// @return Was approval successful?\n    function approve(address spender, uint value) public returns (bool) {\n        allowances[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /// @dev Returns number of allowed tokens for given address\n    /// @param owner Address of token owner\n    /// @param spender Address of token spender\n    /// @return Remaining allowance for spender\n    function allowance(address owner, address spender) public view returns (uint) {\n        return allowances[owner][spender];\n    }\n\n    /// @dev Returns number of tokens owned by given address\n    /// @param owner Address of token owner\n    /// @return Balance of owner\n    function balanceOf(address owner) public view returns (uint) {\n        return balances[owner];\n    }\n\n    /// @dev Returns total supply of tokens\n    /// @return Total supply\n    function totalSupply() public view returns (uint) {\n        return totalTokens;\n    }\n}\n\n// File: contracts/TokenFRT.sol\n\n/// @title Standard token contract with overflow protection\ncontract TokenFRT is Proxied, GnosisStandardToken {\n    address public owner;\n\n    string public constant symbol = \"MGN\";\n    string public constant name = \"Magnolia Token\";\n    uint8 public constant decimals = 18;\n\n    struct UnlockedToken {\n        uint amountUnlocked;\n        uint withdrawalTime;\n    }\n\n    /*\n     *  Storage\n     */\n    address public minter;\n\n    // user => UnlockedToken\n    mapping(address => UnlockedToken) public unlockedTokens;\n\n    // user => amount\n    mapping(address => uint) public lockedTokenBalances;\n\n    /*\n     *  Public functions\n     */\n\n    // @dev allows to set the minter of Magnolia tokens once.\n    // @param   _minter the minter of the Magnolia tokens, should be the DX-proxy\n    function updateMinter(address _minter) public {\n        require(msg.sender == owner, \"Only the minter can set a new one\");\n        require(_minter != address(0), \"The new minter must be a valid address\");\n\n        minter = _minter;\n    }\n\n    // @dev the intention is to set the owner as the DX-proxy, once it is deployed\n    // Then only an update of the DX-proxy contract after a 30 days delay could change the minter again.\n    function updateOwner(address _owner) public {\n        require(msg.sender == owner, \"Only the owner can update the owner\");\n        require(_owner != address(0), \"The new owner must be a valid address\");\n        owner = _owner;\n    }\n\n    function mintTokens(address user, uint amount) public {\n        require(msg.sender == minter, \"Only the minter can mint tokens\");\n\n        lockedTokenBalances[user] = add(lockedTokenBalances[user], amount);\n        totalTokens = add(totalTokens, amount);\n    }\n\n    /// @dev Lock Token\n    function lockTokens(uint amount) public returns (uint totalAmountLocked) {\n        // Adjust amount by balance\n        uint actualAmount = min(amount, balances[msg.sender]);\n\n        // Update state variables\n        balances[msg.sender] = sub(balances[msg.sender], actualAmount);\n        lockedTokenBalances[msg.sender] = add(lockedTokenBalances[msg.sender], actualAmount);\n\n        // Get return variable\n        totalAmountLocked = lockedTokenBalances[msg.sender];\n    }\n\n    function unlockTokens() public returns (uint totalAmountUnlocked, uint withdrawalTime) {\n        // Adjust amount by locked balances\n        uint amount = lockedTokenBalances[msg.sender];\n\n        if (amount > 0) {\n            // Update state variables\n            lockedTokenBalances[msg.sender] = sub(lockedTokenBalances[msg.sender], amount);\n            unlockedTokens[msg.sender].amountUnlocked = add(unlockedTokens[msg.sender].amountUnlocked, amount);\n            unlockedTokens[msg.sender].withdrawalTime = now + 24 hours;\n        }\n\n        // Get return variables\n        totalAmountUnlocked = unlockedTokens[msg.sender].amountUnlocked;\n        withdrawalTime = unlockedTokens[msg.sender].withdrawalTime;\n    }\n\n    function withdrawUnlockedTokens() public {\n        require(unlockedTokens[msg.sender].withdrawalTime < now, \"The tokens cannot be withdrawn yet\");\n        balances[msg.sender] = add(balances[msg.sender], unlockedTokens[msg.sender].amountUnlocked);\n        unlockedTokens[msg.sender].amountUnlocked = 0;\n    }\n\n    function min(uint a, uint b) public pure returns (uint) {\n        if (a < b) {\n            return a;\n        } else {\n            return b;\n        }\n    }\n    \n    /// @dev Returns whether an add operation causes an overflow\n    /// @param a First addend\n    /// @param b Second addend\n    /// @return Did no overflow occur?\n    function safeToAdd(uint a, uint b) public pure returns (bool) {\n        return a + b >= a;\n    }\n\n    /// @dev Returns whether a subtraction operation causes an underflow\n    /// @param a Minuend\n    /// @param b Subtrahend\n    /// @return Did no underflow occur?\n    function safeToSub(uint a, uint b) public pure returns (bool) {\n        return a >= b;\n    }\n\n    /// @dev Returns sum if no overflow occurred\n    /// @param a First addend\n    /// @param b Second addend\n    /// @return Sum\n    function add(uint a, uint b) public pure returns (uint) {\n        require(safeToAdd(a, b), \"It must be a safe adition\");\n        return a + b;\n    }\n\n    /// @dev Returns difference if no overflow occurred\n    /// @param a Minuend\n    /// @param b Subtrahend\n    /// @return Difference\n    function sub(uint a, uint b) public pure returns (uint) {\n        require(safeToSub(a, b), \"It must be a safe substraction\");\n        return a - b;\n    }\n}\n\n// File: @gnosis.pm/owl-token/contracts/TokenOWL.sol\n\ncontract TokenOWL is Proxied, GnosisStandardToken {\n    using GnosisMath for *;\n\n    string public constant name = \"OWL Token\";\n    string public constant symbol = \"OWL\";\n    uint8 public constant decimals = 18;\n\n    struct masterCopyCountdownType {\n        address masterCopy;\n        uint timeWhenAvailable;\n    }\n\n    masterCopyCountdownType masterCopyCountdown;\n\n    address public creator;\n    address public minter;\n\n    event Minted(address indexed to, uint256 amount);\n    event Burnt(address indexed from, address indexed user, uint256 amount);\n\n    modifier onlyCreator() {\n        // R1\n        require(msg.sender == creator, \"Only the creator can perform the transaction\");\n        _;\n    }\n    /// @dev trickers the update process via the proxyMaster for a new address _masterCopy\n    /// updating is only possible after 30 days\n    function startMasterCopyCountdown(address _masterCopy) public onlyCreator {\n        require(address(_masterCopy) != address(0), \"The master copy must be a valid address\");\n\n        // Update masterCopyCountdown\n        masterCopyCountdown.masterCopy = _masterCopy;\n        masterCopyCountdown.timeWhenAvailable = now + 30 days;\n    }\n\n    /// @dev executes the update process via the proxyMaster for a new address _masterCopy\n    function updateMasterCopy() public onlyCreator {\n        require(address(masterCopyCountdown.masterCopy) != address(0), \"The master copy must be a valid address\");\n        require(\n            block.timestamp >= masterCopyCountdown.timeWhenAvailable,\n            \"It's not possible to update the master copy during the waiting period\"\n        );\n\n        // Update masterCopy\n        masterCopy = masterCopyCountdown.masterCopy;\n    }\n\n    function getMasterCopy() public view returns (address) {\n        return masterCopy;\n    }\n\n    /// @dev Set minter. Only the creator of this contract can call this.\n    /// @param newMinter The new address authorized to mint this token\n    function setMinter(address newMinter) public onlyCreator {\n        minter = newMinter;\n    }\n\n    /// @dev change owner/creator of the contract. Only the creator/owner of this contract can call this.\n    /// @param newOwner The new address, which should become the owner\n    function setNewOwner(address newOwner) public onlyCreator {\n        creator = newOwner;\n    }\n\n    /// @dev Mints OWL.\n    /// @param to Address to which the minted token will be given\n    /// @param amount Amount of OWL to be minted\n    function mintOWL(address to, uint amount) public {\n        require(minter != address(0), \"The minter must be initialized\");\n        require(msg.sender == minter, \"Only the minter can mint OWL\");\n        balances[to] = balances[to].add(amount);\n        totalTokens = totalTokens.add(amount);\n        emit Minted(to, amount);\n    }\n\n    /// @dev Burns OWL.\n    /// @param user Address of OWL owner\n    /// @param amount Amount of OWL to be burnt\n    function burnOWL(address user, uint amount) public {\n        allowances[user][msg.sender] = allowances[user][msg.sender].sub(amount);\n        balances[user] = balances[user].sub(amount);\n        totalTokens = totalTokens.sub(amount);\n        emit Burnt(msg.sender, user, amount);\n    }\n}\n\n// File: contracts/base/SafeTransfer.sol\n\ninterface BadToken {\n    function transfer(address to, uint value) external;\n    function transferFrom(address from, address to, uint value) external;\n}\n\ncontract SafeTransfer {\n    function safeTransfer(address token, address to, uint value, bool from) internal returns (bool result) {\n        if (from) {\n            BadToken(token).transferFrom(msg.sender, address(this), value);\n        } else {\n            BadToken(token).transfer(to, value);\n        }\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            switch returndatasize\n                case 0 {\n                    // This is our BadToken\n                    result := not(0) // result is true\n                }\n                case 32 {\n                    // This is our GoodToken\n                    returndatacopy(0, 0, 32)\n                    result := mload(0) // result == returndata of external call\n                }\n                default {\n                    // This is not an ERC20 token\n                    result := 0\n                }\n        }\n        return result;\n    }\n}\n\n// File: contracts/base/AuctioneerManaged.sol\n\ncontract AuctioneerManaged {\n    // auctioneer has the power to manage some variables\n    address public auctioneer;\n\n    function updateAuctioneer(address _auctioneer) public onlyAuctioneer {\n        require(_auctioneer != address(0), \"The auctioneer must be a valid address\");\n        auctioneer = _auctioneer;\n    }\n\n    // > Modifiers\n    modifier onlyAuctioneer() {\n        // Only allows auctioneer to proceed\n        // R1\n        // require(msg.sender == auctioneer, \"Only auctioneer can perform this operation\");\n        require(msg.sender == auctioneer, \"Only the auctioneer can nominate a new one\");\n        _;\n    }\n}\n\n// File: contracts/base/TokenWhitelist.sol\n\ncontract TokenWhitelist is AuctioneerManaged {\n    // Mapping that stores the tokens, which are approved\n    // Only tokens approved by auctioneer generate frtToken tokens\n    // addressToken => boolApproved\n    mapping(address => bool) public approvedTokens;\n\n    event Approval(address indexed token, bool approved);\n\n    /// @dev for quick overview of approved Tokens\n    /// @param addressesToCheck are the ERC-20 token addresses to be checked whether they are approved\n    function getApprovedAddressesOfList(address[] calldata addressesToCheck) external view returns (bool[] memory) {\n        uint length = addressesToCheck.length;\n\n        bool[] memory isApproved = new bool[](length);\n\n        for (uint i = 0; i < length; i++) {\n            isApproved[i] = approvedTokens[addressesToCheck[i]];\n        }\n\n        return isApproved;\n    }\n    \n    function updateApprovalOfToken(address[] memory token, bool approved) public onlyAuctioneer {\n        for (uint i = 0; i < token.length; i++) {\n            approvedTokens[token[i]] = approved;\n            emit Approval(token[i], approved);\n        }\n    }\n\n}\n\n// File: contracts/base/DxMath.sol\n\ncontract DxMath {\n    // > Math fns\n    function min(uint a, uint b) public pure returns (uint) {\n        if (a < b) {\n            return a;\n        } else {\n            return b;\n        }\n    }\n\n    function atleastZero(int a) public pure returns (uint) {\n        if (a < 0) {\n            return 0;\n        } else {\n            return uint(a);\n        }\n    }\n    \n    /// @dev Returns whether an add operation causes an overflow\n    /// @param a First addend\n    /// @param b Second addend\n    /// @return Did no overflow occur?\n    function safeToAdd(uint a, uint b) public pure returns (bool) {\n        return a + b >= a;\n    }\n\n    /// @dev Returns whether a subtraction operation causes an underflow\n    /// @param a Minuend\n    /// @param b Subtrahend\n    /// @return Did no underflow occur?\n    function safeToSub(uint a, uint b) public pure returns (bool) {\n        return a >= b;\n    }\n\n    /// @dev Returns whether a multiply operation causes an overflow\n    /// @param a First factor\n    /// @param b Second factor\n    /// @return Did no overflow occur?\n    function safeToMul(uint a, uint b) public pure returns (bool) {\n        return b == 0 || a * b / b == a;\n    }\n\n    /// @dev Returns sum if no overflow occurred\n    /// @param a First addend\n    /// @param b Second addend\n    /// @return Sum\n    function add(uint a, uint b) public pure returns (uint) {\n        require(safeToAdd(a, b));\n        return a + b;\n    }\n\n    /// @dev Returns difference if no overflow occurred\n    /// @param a Minuend\n    /// @param b Subtrahend\n    /// @return Difference\n    function sub(uint a, uint b) public pure returns (uint) {\n        require(safeToSub(a, b));\n        return a - b;\n    }\n\n    /// @dev Returns product if no overflow occurred\n    /// @param a First factor\n    /// @param b Second factor\n    /// @return Product\n    function mul(uint a, uint b) public pure returns (uint) {\n        require(safeToMul(a, b));\n        return a * b;\n    }\n}\n\n// File: contracts/Oracle/DSMath.sol\n\ncontract DSMath {\n    /*\n    standard uint256 functions\n     */\n\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assert((z = x + y) >= x);\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assert((z = x - y) <= x);\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assert((z = x * y) >= x);\n    }\n\n    function div(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x / y;\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x <= y ? x : y;\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x >= y ? x : y;\n    }\n\n    /*\n    uint128 functions (h is for half)\n     */\n\n    function hadd(uint128 x, uint128 y) internal pure returns (uint128 z) {\n        assert((z = x + y) >= x);\n    }\n\n    function hsub(uint128 x, uint128 y) internal pure returns (uint128 z) {\n        assert((z = x - y) <= x);\n    }\n\n    function hmul(uint128 x, uint128 y) internal pure returns (uint128 z) {\n        assert((z = x * y) >= x);\n    }\n\n    function hdiv(uint128 x, uint128 y) internal pure returns (uint128 z) {\n        z = x / y;\n    }\n\n    function hmin(uint128 x, uint128 y) internal pure returns (uint128 z) {\n        return x <= y ? x : y;\n    }\n\n    function hmax(uint128 x, uint128 y) internal pure returns (uint128 z) {\n        return x >= y ? x : y;\n    }\n\n    /*\n    int256 functions\n     */\n\n    function imin(int256 x, int256 y) internal pure returns (int256 z) {\n        return x <= y ? x : y;\n    }\n\n    function imax(int256 x, int256 y) internal pure returns (int256 z) {\n        return x >= y ? x : y;\n    }\n\n    /*\n    WAD math\n     */\n\n    uint128 constant WAD = 10 ** 18;\n\n    function wadd(uint128 x, uint128 y) internal pure returns (uint128) {\n        return hadd(x, y);\n    }\n\n    function wsub(uint128 x, uint128 y) internal pure returns (uint128) {\n        return hsub(x, y);\n    }\n\n    function wmul(uint128 x, uint128 y) internal pure returns (uint128 z) {\n        z = cast((uint256(x) * y + WAD / 2) / WAD);\n    }\n\n    function wdiv(uint128 x, uint128 y) internal pure returns (uint128 z) {\n        z = cast((uint256(x) * WAD + y / 2) / y);\n    }\n\n    function wmin(uint128 x, uint128 y) internal pure returns (uint128) {\n        return hmin(x, y);\n    }\n\n    function wmax(uint128 x, uint128 y) internal pure returns (uint128) {\n        return hmax(x, y);\n    }\n\n    /*\n    RAY math\n     */\n\n    uint128 constant RAY = 10 ** 27;\n\n    function radd(uint128 x, uint128 y) internal pure returns (uint128) {\n        return hadd(x, y);\n    }\n\n    function rsub(uint128 x, uint128 y) internal pure returns (uint128) {\n        return hsub(x, y);\n    }\n\n    function rmul(uint128 x, uint128 y) internal pure returns (uint128 z) {\n        z = cast((uint256(x) * y + RAY / 2) / RAY);\n    }\n\n    function rdiv(uint128 x, uint128 y) internal pure returns (uint128 z) {\n        z = cast((uint256(x) * RAY + y / 2) / y);\n    }\n\n    function rpow(uint128 x, uint64 n) internal pure returns (uint128 z) {\n        // This famous algorithm is called \"exponentiation by squaring\"\n        // and calculates x^n with x as fixed-point and n as regular unsigned.\n        //\n        // It's O(log n), instead of O(n) for naive repeated multiplication.\n        //\n        // These facts are why it works:\n        //\n        //  If n is even, then x^n = (x^2)^(n/2).\n        //  If n is odd,  then x^n = x * x^(n-1),\n        //   and applying the equation for even x gives\n        //    x^n = x * (x^2)^((n-1) / 2).\n        //\n        //  Also, EVM division is flooring and\n        //    floor[(n-1) / 2] = floor[n / 2].\n\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n\n    function rmin(uint128 x, uint128 y) internal pure returns (uint128) {\n        return hmin(x, y);\n    }\n\n    function rmax(uint128 x, uint128 y) internal pure returns (uint128) {\n        return hmax(x, y);\n    }\n\n    function cast(uint256 x) internal pure returns (uint128 z) {\n        assert((z = uint128(x)) == x);\n    }\n\n}\n\n// File: contracts/Oracle/DSAuth.sol\n\ncontract DSAuthority {\n    function canCall(address src, address dst, bytes4 sig) public view returns (bool);\n}\n\n\ncontract DSAuthEvents {\n    event LogSetAuthority(address indexed authority);\n    event LogSetOwner(address indexed owner);\n}\n\n\ncontract DSAuth is DSAuthEvents {\n    DSAuthority public authority;\n    address public owner;\n\n    constructor() public {\n        owner = msg.sender;\n        emit LogSetOwner(msg.sender);\n    }\n\n    function setOwner(address owner_) public auth {\n        owner = owner_;\n        emit LogSetOwner(owner);\n    }\n\n    function setAuthority(DSAuthority authority_) public auth {\n        authority = authority_;\n        emit LogSetAuthority(address(authority));\n    }\n\n    modifier auth {\n        require(isAuthorized(msg.sender, msg.sig), \"It must be an authorized call\");\n        _;\n    }\n\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else if (authority == DSAuthority(0)) {\n            return false;\n        } else {\n            return authority.canCall(src, address(this), sig);\n        }\n    }\n}\n\n// File: contracts/Oracle/DSNote.sol\n\ncontract DSNote {\n    event LogNote(\n        bytes4 indexed sig,\n        address indexed guy,\n        bytes32 indexed foo,\n        bytes32 bar,\n        uint wad,\n        bytes fax\n    );\n\n    modifier note {\n        bytes32 foo;\n        bytes32 bar;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            foo := calldataload(4)\n            bar := calldataload(36)\n        }\n\n        emit LogNote(\n            msg.sig,\n            msg.sender,\n            foo,\n            bar,\n            msg.value,\n            msg.data\n        );\n\n        _;\n    }\n}\n\n// File: contracts/Oracle/DSThing.sol\n\ncontract DSThing is DSAuth, DSNote, DSMath {}\n\n// File: contracts/Oracle/PriceFeed.sol\n\n/// price-feed.sol\n\n// Copyright (C) 2017  DappHub, LLC\n\n// Licensed under the Apache License, Version 2.0 (the \"License\").\n// You may not use this file except in compliance with the License.\n\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND (express or implied).\n\n\n\ncontract PriceFeed is DSThing {\n    uint128 val;\n    uint32 public zzz;\n\n    function peek() public view returns (bytes32, bool) {\n        return (bytes32(uint256(val)), block.timestamp < zzz);\n    }\n\n    function read() public view returns (bytes32) {\n        assert(block.timestamp < zzz);\n        return bytes32(uint256(val));\n    }\n\n    function post(uint128 val_, uint32 zzz_, address med_) public payable note auth {\n        val = val_;\n        zzz = zzz_;\n        (bool success, ) = med_.call(abi.encodeWithSignature(\"poke()\"));\n        require(success, \"The poke must succeed\");\n    }\n\n    function void() public payable note auth {\n        zzz = 0;\n    }\n\n}\n\n// File: contracts/Oracle/DSValue.sol\n\ncontract DSValue is DSThing {\n    bool has;\n    bytes32 val;\n    function peek() public view returns (bytes32, bool) {\n        return (val, has);\n    }\n\n    function read() public view returns (bytes32) {\n        (bytes32 wut, bool _has) = peek();\n        assert(_has);\n        return wut;\n    }\n\n    function poke(bytes32 wut) public payable note auth {\n        val = wut;\n        has = true;\n    }\n\n    function void() public payable note auth {\n        // unset the value\n        has = false;\n    }\n}\n\n// File: contracts/Oracle/Medianizer.sol\n\ncontract Medianizer is DSValue {\n    mapping(bytes12 => address) public values;\n    mapping(address => bytes12) public indexes;\n    bytes12 public next = bytes12(uint96(1));\n    uint96 public minimun = 0x1;\n\n    function set(address wat) public auth {\n        bytes12 nextId = bytes12(uint96(next) + 1);\n        assert(nextId != 0x0);\n        set(next, wat);\n        next = nextId;\n    }\n\n    function set(bytes12 pos, address wat) public payable note auth {\n        require(pos != 0x0, \"pos cannot be 0x0\");\n        require(wat == address(0) || indexes[wat] == 0, \"wat is not defined or it has an index\");\n\n        indexes[values[pos]] = bytes12(0); // Making sure to remove a possible existing address in that position\n\n        if (wat != address(0)) {\n            indexes[wat] = pos;\n        }\n\n        values[pos] = wat;\n    }\n\n    function setMin(uint96 min_) public payable note auth {\n        require(min_ != 0x0, \"min cannot be 0x0\");\n        minimun = min_;\n    }\n\n    function setNext(bytes12 next_) public payable note auth {\n        require(next_ != 0x0, \"next cannot be 0x0\");\n        next = next_;\n    }\n\n    function unset(bytes12 pos) public {\n        set(pos, address(0));\n    }\n\n    function unset(address wat) public {\n        set(indexes[wat], address(0));\n    }\n\n    function poke() public {\n        poke(0);\n    }\n\n    function poke(bytes32) public payable note {\n        (val, has) = compute();\n    }\n\n    function compute() public view returns (bytes32, bool) {\n        bytes32[] memory wuts = new bytes32[](uint96(next) - 1);\n        uint96 ctr = 0;\n        for (uint96 i = 1; i < uint96(next); i++) {\n            if (values[bytes12(i)] != address(0)) {\n                (bytes32 wut, bool wuz) = DSValue(values[bytes12(i)]).peek();\n                if (wuz) {\n                    if (ctr == 0 || wut >= wuts[ctr - 1]) {\n                        wuts[ctr] = wut;\n                    } else {\n                        uint96 j = 0;\n                        while (wut >= wuts[j]) {\n                            j++;\n                        }\n                        for (uint96 k = ctr; k > j; k--) {\n                            wuts[k] = wuts[k - 1];\n                        }\n                        wuts[j] = wut;\n                    }\n                    ctr++;\n                }\n            }\n        }\n\n        if (ctr < minimun)\n            return (val, false);\n\n        bytes32 value;\n        if (ctr % 2 == 0) {\n            uint128 val1 = uint128(uint(wuts[(ctr / 2) - 1]));\n            uint128 val2 = uint128(uint(wuts[ctr / 2]));\n            value = bytes32(uint256(wdiv(hadd(val1, val2), 2 ether)));\n        } else {\n            value = wuts[(ctr - 1) / 2];\n        }\n\n        return (value, true);\n    }\n}\n\n// File: contracts/Oracle/PriceOracleInterface.sol\n\n/*\nThis contract is the interface between the MakerDAO priceFeed and our DX platform.\n*/\n\n\n\n\ncontract PriceOracleInterface {\n    address public priceFeedSource;\n    address public owner;\n    bool public emergencyMode;\n\n    // Modifiers\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only the owner can do the operation\");\n        _;\n    }\n\n    /// @dev constructor of the contract\n    /// @param _priceFeedSource address of price Feed Source -> should be maker feeds Medianizer contract\n    constructor(address _owner, address _priceFeedSource) public {\n        owner = _owner;\n        priceFeedSource = _priceFeedSource;\n    }\n    \n    /// @dev gives the owner the possibility to put the Interface into an emergencyMode, which will\n    /// output always a price of 600 USD. This gives everyone time to set up a new pricefeed.\n    function raiseEmergency(bool _emergencyMode) public onlyOwner {\n        emergencyMode = _emergencyMode;\n    }\n\n    /// @dev updates the priceFeedSource\n    /// @param _owner address of owner\n    function updateCurator(address _owner) public onlyOwner {\n        owner = _owner;\n    }\n\n    /// @dev returns the USDETH price\n    function getUsdEthPricePeek() public view returns (bytes32 price, bool valid) {\n        return Medianizer(priceFeedSource).peek();\n    }\n\n    /// @dev returns the USDETH price, ie gets the USD price from Maker feed with 18 digits, but last 18 digits are cut off\n    function getUSDETHPrice() public view returns (uint256) {\n        // if the contract is in the emergencyMode, because there is an issue with the oracle, we will simply return a price of 600 USD\n        if (emergencyMode) {\n            return 600;\n        }\n        (bytes32 price, ) = Medianizer(priceFeedSource).peek();\n\n        // ensuring that there is no underflow or overflow possible,\n        // even if the price is compromised\n        uint priceUint = uint256(price)/(1 ether);\n        if (priceUint == 0) {\n            return 1;\n        }\n        if (priceUint > 1000000) {\n            return 1000000; \n        }\n        return priceUint;\n    }\n}\n\n// File: contracts/base/EthOracle.sol\n\ncontract EthOracle is AuctioneerManaged, DxMath {\n    uint constant WAITING_PERIOD_CHANGE_ORACLE = 30 days;\n\n    // Price Oracle interface\n    PriceOracleInterface public ethUSDOracle;\n    // Price Oracle interface proposals during update process\n    PriceOracleInterface public newProposalEthUSDOracle;\n\n    uint public oracleInterfaceCountdown;\n\n    event NewOracleProposal(PriceOracleInterface priceOracleInterface);\n\n    function initiateEthUsdOracleUpdate(PriceOracleInterface _ethUSDOracle) public onlyAuctioneer {\n        require(address(_ethUSDOracle) != address(0), \"The oracle address must be valid\");\n        newProposalEthUSDOracle = _ethUSDOracle;\n        oracleInterfaceCountdown = add(block.timestamp, WAITING_PERIOD_CHANGE_ORACLE);\n        emit NewOracleProposal(_ethUSDOracle);\n    }\n\n    function updateEthUSDOracle() public {\n        require(address(newProposalEthUSDOracle) != address(0), \"The new proposal must be a valid addres\");\n        require(\n            oracleInterfaceCountdown < block.timestamp,\n            \"It's not possible to update the oracle during the waiting period\"\n        );\n        ethUSDOracle = newProposalEthUSDOracle;\n        newProposalEthUSDOracle = PriceOracleInterface(0);\n    }\n}\n\n// File: contracts/base/DxUpgrade.sol\n\ncontract DxUpgrade is Proxied, AuctioneerManaged, DxMath {\n    uint constant WAITING_PERIOD_CHANGE_MASTERCOPY = 30 days;\n\n    address public newMasterCopy;\n    // Time when new masterCopy is updatabale\n    uint public masterCopyCountdown;\n\n    event NewMasterCopyProposal(address newMasterCopy);\n\n    function startMasterCopyCountdown(address _masterCopy) public onlyAuctioneer {\n        require(_masterCopy != address(0), \"The new master copy must be a valid address\");\n\n        // Update masterCopyCountdown\n        newMasterCopy = _masterCopy;\n        masterCopyCountdown = add(block.timestamp, WAITING_PERIOD_CHANGE_MASTERCOPY);\n        emit NewMasterCopyProposal(_masterCopy);\n    }\n\n    function updateMasterCopy() public {\n        require(newMasterCopy != address(0), \"The new master copy must be a valid address\");\n        require(block.timestamp >= masterCopyCountdown, \"The master contract cannot be updated in a waiting period\");\n\n        // Update masterCopy\n        masterCopy = newMasterCopy;\n        newMasterCopy = address(0);\n    }\n\n}\n\n// File: contracts/DutchExchange.sol\n\n/// @title Dutch Exchange - exchange token pairs with the clever mechanism of the dutch auction\n/// @author Alex Herrmann - <[email protected]>\n/// @author Dominik Teiml - <[email protected]>\n\ncontract DutchExchange is DxUpgrade, TokenWhitelist, EthOracle, SafeTransfer {\n\n    // The price is a rational number, so we need a concept of a fraction\n    struct Fraction {\n        uint num;\n        uint den;\n    }\n\n    uint constant WAITING_PERIOD_NEW_TOKEN_PAIR = 6 hours;\n    uint constant WAITING_PERIOD_NEW_AUCTION = 10 minutes;\n    uint constant AUCTION_START_WAITING_FOR_FUNDING = 1;\n\n    // > Storage\n    // Ether ERC-20 token\n    address public ethToken;\n\n    // Minimum required sell funding for adding a new token pair, in USD\n    uint public thresholdNewTokenPair;\n    // Minimum required sell funding for starting antoher auction, in USD\n    uint public thresholdNewAuction;\n    // Fee reduction token (magnolia, ERC-20 token)\n    TokenFRT public frtToken;\n    // Token for paying fees\n    TokenOWL public owlToken;\n\n    // For the following three mappings, there is one mapping for each token pair\n    // The order which the tokens should be called is smaller, larger\n    // These variables should never be called directly! They have getters below\n    // Token => Token => index\n    mapping(address => mapping(address => uint)) public latestAuctionIndices;\n    // Token => Token => time\n    mapping (address => mapping (address => uint)) public auctionStarts;\n    // Token => Token => auctionIndex => time\n    mapping (address => mapping (address => mapping (uint => uint))) public clearingTimes;\n\n    // Token => Token => auctionIndex => price\n    mapping(address => mapping(address => mapping(uint => Fraction))) public closingPrices;\n\n    // Token => Token => amount\n    mapping(address => mapping(address => uint)) public sellVolumesCurrent;\n    // Token => Token => amount\n    mapping(address => mapping(address => uint)) public sellVolumesNext;\n    // Token => Token => amount\n    mapping(address => mapping(address => uint)) public buyVolumes;\n\n    // Token => user => amount\n    // balances stores a user's balance in the DutchX\n    mapping(address => mapping(address => uint)) public balances;\n\n    // Token => Token => auctionIndex => amount\n    mapping(address => mapping(address => mapping(uint => uint))) public extraTokens;\n\n    // Token => Token =>  auctionIndex => user => amount\n    mapping(address => mapping(address => mapping(uint => mapping(address => uint)))) public sellerBalances;\n    mapping(address => mapping(address => mapping(uint => mapping(address => uint)))) public buyerBalances;\n    mapping(address => mapping(address => mapping(uint => mapping(address => uint)))) public claimedAmounts;\n\n    function depositAndSell(address sellToken, address buyToken, uint amount)\n        external\n        returns (uint newBal, uint auctionIndex, uint newSellerBal)\n    {\n        newBal = deposit(sellToken, amount);\n        (auctionIndex, newSellerBal) = postSellOrder(sellToken, buyToken, 0, amount);\n    }\n\n    function claimAndWithdraw(address sellToken, address buyToken, address user, uint auctionIndex, uint amount)\n        external\n        returns (uint returned, uint frtsIssued, uint newBal)\n    {\n        (returned, frtsIssued) = claimSellerFunds(sellToken, buyToken, user, auctionIndex);\n        newBal = withdraw(buyToken, amount);\n    }\n\n    /// @dev for multiple claims\n    /// @param auctionSellTokens are the sellTokens defining an auctionPair\n    /// @param auctionBuyTokens are the buyTokens defining an auctionPair\n    /// @param auctionIndices are the auction indices on which an token should be claimedAmounts\n    /// @param user is the user who wants to his tokens\n    function claimTokensFromSeveralAuctionsAsSeller(\n        address[] calldata auctionSellTokens,\n        address[] calldata auctionBuyTokens,\n        uint[] calldata auctionIndices,\n        address user\n    ) external returns (uint[] memory, uint[] memory)\n    {\n        uint length = checkLengthsForSeveralAuctionClaiming(auctionSellTokens, auctionBuyTokens, auctionIndices);\n\n        uint[] memory claimAmounts = new uint[](length);\n        uint[] memory frtsIssuedList = new uint[](length);\n\n        for (uint i = 0; i < length; i++) {\n            (claimAmounts[i], frtsIssuedList[i]) = claimSellerFunds(\n                auctionSellTokens[i],\n                auctionBuyTokens[i],\n                user,\n                auctionIndices[i]\n            );\n        }\n\n        return (claimAmounts, frtsIssuedList);\n    }\n\n    /// @dev for multiple claims\n    /// @param auctionSellTokens are the sellTokens defining an auctionPair\n    /// @param auctionBuyTokens are the buyTokens defining an auctionPair\n    /// @param auctionIndices are the auction indices on which an token should be claimedAmounts\n    /// @param user is the user who wants to his tokens\n    function claimTokensFromSeveralAuctionsAsBuyer(\n        address[] calldata auctionSellTokens,\n        address[] calldata auctionBuyTokens,\n        uint[] calldata auctionIndices,\n        address user\n    ) external returns (uint[] memory, uint[] memory)\n    {\n        uint length = checkLengthsForSeveralAuctionClaiming(auctionSellTokens, auctionBuyTokens, auctionIndices);\n\n        uint[] memory claimAmounts = new uint[](length);\n        uint[] memory frtsIssuedList = new uint[](length);\n\n        for (uint i = 0; i < length; i++) {\n            (claimAmounts[i], frtsIssuedList[i]) = claimBuyerFunds(\n                auctionSellTokens[i],\n                auctionBuyTokens[i],\n                user,\n                auctionIndices[i]\n            );\n        }\n\n        return (claimAmounts, frtsIssuedList);\n    }\n\n    /// @dev for multiple withdraws\n    /// @param auctionSellTokens are the sellTokens defining an auctionPair\n    /// @param auctionBuyTokens are the buyTokens defining an auctionPair\n    /// @param auctionIndices are the auction indices on which an token should be claimedAmounts\n    function claimAndWithdrawTokensFromSeveralAuctionsAsSeller(\n        address[] calldata auctionSellTokens,\n        address[] calldata auctionBuyTokens,\n        uint[] calldata auctionIndices\n    ) external returns (uint[] memory, uint frtsIssued)\n    {\n        uint length = checkLengthsForSeveralAuctionClaiming(auctionSellTokens, auctionBuyTokens, auctionIndices);\n\n        uint[] memory claimAmounts = new uint[](length);\n        uint claimFrts = 0;\n\n        for (uint i = 0; i < length; i++) {\n            (claimAmounts[i], claimFrts) = claimSellerFunds(\n                auctionSellTokens[i],\n                auctionBuyTokens[i],\n                msg.sender,\n                auctionIndices[i]\n            );\n\n            frtsIssued += claimFrts;\n\n            withdraw(auctionBuyTokens[i], claimAmounts[i]);\n        }\n\n        return (claimAmounts, frtsIssued);\n    }\n\n    /// @dev for multiple withdraws\n    /// @param auctionSellTokens are the sellTokens defining an auctionPair\n    /// @param auctionBuyTokens are the buyTokens defining an auctionPair\n    /// @param auctionIndices are the auction indices on which an token should be claimedAmounts\n    function claimAndWithdrawTokensFromSeveralAuctionsAsBuyer(\n        address[] calldata auctionSellTokens,\n        address[] calldata auctionBuyTokens,\n        uint[] calldata auctionIndices\n    ) external returns (uint[] memory, uint frtsIssued)\n    {\n        uint length = checkLengthsForSeveralAuctionClaiming(auctionSellTokens, auctionBuyTokens, auctionIndices);\n\n        uint[] memory claimAmounts = new uint[](length);\n        uint claimFrts = 0;\n\n        for (uint i = 0; i < length; i++) {\n            (claimAmounts[i], claimFrts) = claimBuyerFunds(\n                auctionSellTokens[i],\n                auctionBuyTokens[i],\n                msg.sender,\n                auctionIndices[i]\n            );\n\n            frtsIssued += claimFrts;\n\n            withdraw(auctionSellTokens[i], claimAmounts[i]);\n        }\n\n        return (claimAmounts, frtsIssued);\n    }\n\n    function getMasterCopy() external view returns (address) {\n        return masterCopy;\n    }\n\n    /// @dev Constructor-Function creates exchange\n    /// @param _frtToken - address of frtToken ERC-20 token\n    /// @param _owlToken - address of owlToken ERC-20 token\n    /// @param _auctioneer - auctioneer for managing interfaces\n    /// @param _ethToken - address of ETH ERC-20 token\n    /// @param _ethUSDOracle - address of the oracle contract for fetching feeds\n    /// @param _thresholdNewTokenPair - Minimum required sell funding for adding a new token pair, in USD\n    function setupDutchExchange(\n        TokenFRT _frtToken,\n        TokenOWL _owlToken,\n        address _auctioneer,\n        address _ethToken,\n        PriceOracleInterface _ethUSDOracle,\n        uint _thresholdNewTokenPair,\n        uint _thresholdNewAuction\n    ) public\n    {\n        // Make sure contract hasn't been initialised\n        require(ethToken == address(0), \"The contract must be uninitialized\");\n\n        // Validates inputs\n        require(address(_owlToken) != address(0), \"The OWL address must be valid\");\n        require(address(_frtToken) != address(0), \"The FRT address must be valid\");\n        require(_auctioneer != address(0), \"The auctioneer address must be valid\");\n        require(_ethToken != address(0), \"The WETH address must be valid\");\n        require(address(_ethUSDOracle) != address(0), \"The oracle address must be valid\");\n\n        frtToken = _frtToken;\n        owlToken = _owlToken;\n        auctioneer = _auctioneer;\n        ethToken = _ethToken;\n        ethUSDOracle = _ethUSDOracle;\n        thresholdNewTokenPair = _thresholdNewTokenPair;\n        thresholdNewAuction = _thresholdNewAuction;\n    }\n\n    function updateThresholdNewTokenPair(uint _thresholdNewTokenPair) public onlyAuctioneer {\n        thresholdNewTokenPair = _thresholdNewTokenPair;\n    }\n\n    function updateThresholdNewAuction(uint _thresholdNewAuction) public onlyAuctioneer {\n        thresholdNewAuction = _thresholdNewAuction;\n    }\n\n    /// @param initialClosingPriceNum initial price will be 2 * initialClosingPrice. This is its numerator\n    /// @param initialClosingPriceDen initial price will be 2 * initialClosingPrice. This is its denominator\n    function addTokenPair(\n        address token1,\n        address token2,\n        uint token1Funding,\n        uint token2Funding,\n        uint initialClosingPriceNum,\n        uint initialClosingPriceDen\n    ) public\n    {\n        // R1\n        require(token1 != token2, \"You cannot add a token pair using the same token\");\n\n        // R2\n        require(initialClosingPriceNum != 0, \"You must set the numerator for the initial price\");\n\n        // R3\n        require(initialClosingPriceDen != 0, \"You must set the denominator for the initial price\");\n\n        // R4\n        require(getAuctionIndex(token1, token2) == 0, \"The token pair was already added\");\n\n        // R5: to prevent overflow\n        require(initialClosingPriceNum < 10 ** 18, \"You must set a smaller numerator for the initial price\");\n\n        // R6\n        require(initialClosingPriceDen < 10 ** 18, \"You must set a smaller denominator for the initial price\");\n\n        setAuctionIndex(token1, token2);\n\n        token1Funding = min(token1Funding, balances[token1][msg.sender]);\n        token2Funding = min(token2Funding, balances[token2][msg.sender]);\n\n        // R7\n        require(token1Funding < 10 ** 30, \"You should use a smaller funding for token 1\");\n\n        // R8\n        require(token2Funding < 10 ** 30, \"You should use a smaller funding for token 2\");\n\n        uint fundedValueUSD;\n        uint ethUSDPrice = ethUSDOracle.getUSDETHPrice();\n\n        // Compute fundedValueUSD\n        address ethTokenMem = ethToken;\n        if (token1 == ethTokenMem) {\n            // C1\n            // MUL: 10^30 * 10^6 = 10^36\n            fundedValueUSD = mul(token1Funding, ethUSDPrice);\n        } else if (token2 == ethTokenMem) {\n            // C2\n            // MUL: 10^30 * 10^6 = 10^36\n            fundedValueUSD = mul(token2Funding, ethUSDPrice);\n        } else {\n            // C3: Neither token is ethToken\n            fundedValueUSD = calculateFundedValueTokenToken(\n                token1,\n                token2,\n                token1Funding,\n                token2Funding,\n                ethTokenMem,\n                ethUSDPrice\n            );\n        }\n\n        // R5\n        require(fundedValueUSD >= thresholdNewTokenPair, \"You should surplus the threshold for adding token pairs\");\n\n        // Save prices of opposite auctions\n        closingPrices[token1][token2][0] = Fraction(initialClosingPriceNum, initialClosingPriceDen);\n        closingPrices[token2][token1][0] = Fraction(initialClosingPriceDen, initialClosingPriceNum);\n\n        // Split into two fns because of 16 local-var cap\n        addTokenPairSecondPart(token1, token2, token1Funding, token2Funding);\n    }\n\n    function deposit(address tokenAddress, uint amount) public returns (uint) {\n        // R1\n        require(safeTransfer(tokenAddress, msg.sender, amount, true), \"The deposit transaction must succeed\");\n\n        uint newBal = add(balances[tokenAddress][msg.sender], amount);\n\n        balances[tokenAddress][msg.sender] = newBal;\n\n        emit NewDeposit(tokenAddress, amount);\n\n        return newBal;\n    }\n\n    function withdraw(address tokenAddress, uint amount) public returns (uint) {\n        uint usersBalance = balances[tokenAddress][msg.sender];\n        amount = min(amount, usersBalance);\n\n        // R1\n        require(amount > 0, \"The amount must be greater than 0\");\n\n        uint newBal = sub(usersBalance, amount);\n        balances[tokenAddress][msg.sender] = newBal;\n\n        // R2\n        require(safeTransfer(tokenAddress, msg.sender, amount, false), \"The withdraw transfer must succeed\");\n        emit NewWithdrawal(tokenAddress, amount);\n\n        return newBal;\n    }\n\n    function postSellOrder(address sellToken, address buyToken, uint auctionIndex, uint amount)\n        public\n        returns (uint, uint)\n    {\n        // Note: if a user specifies auctionIndex of 0, it\n        // means he is agnostic which auction his sell order goes into\n\n        amount = min(amount, balances[sellToken][msg.sender]);\n\n        // R1\n        // require(amount >= 0, \"Sell amount should be greater than 0\");\n\n        // R2\n        uint latestAuctionIndex = getAuctionIndex(sellToken, buyToken);\n        require(latestAuctionIndex > 0);\n\n        // R3\n        uint auctionStart = getAuctionStart(sellToken, buyToken);\n        if (auctionStart == AUCTION_START_WAITING_FOR_FUNDING || auctionStart > now) {\n            // C1: We are in the 10 minute buffer period\n            // OR waiting for an auction to receive sufficient sellVolume\n            // Auction has already cleared, and index has been incremented\n            // sell order must use that auction index\n            // R1.1\n            if (auctionIndex == 0) {\n                auctionIndex = latestAuctionIndex;\n            } else {\n                require(auctionIndex == latestAuctionIndex, \"Auction index should be equal to latest auction index\");\n            }\n\n            // R1.2\n            require(add(sellVolumesCurrent[sellToken][buyToken], amount) < 10 ** 30);\n        } else {\n            // C2\n            // R2.1: Sell orders must go to next auction\n            if (auctionIndex == 0) {\n                auctionIndex = latestAuctionIndex + 1;\n            } else {\n                require(auctionIndex == latestAuctionIndex + 1);\n            }\n\n            // R2.2\n            require(add(sellVolumesNext[sellToken][buyToken], amount) < 10 ** 30);\n        }\n\n        // Fee mechanism, fees are added to extraTokens\n        uint amountAfterFee = settleFee(sellToken, buyToken, auctionIndex, amount);\n\n        // Update variables\n        balances[sellToken][msg.sender] = sub(balances[sellToken][msg.sender], amount);\n        uint newSellerBal = add(sellerBalances[sellToken][buyToken][auctionIndex][msg.sender], amountAfterFee);\n        sellerBalances[sellToken][buyToken][auctionIndex][msg.sender] = newSellerBal;\n\n        if (auctionStart == AUCTION_START_WAITING_FOR_FUNDING || auctionStart > now) {\n            // C1\n            uint sellVolumeCurrent = sellVolumesCurrent[sellToken][buyToken];\n            sellVolumesCurrent[sellToken][buyToken] = add(sellVolumeCurrent, amountAfterFee);\n        } else {\n            // C2\n            uint sellVolumeNext = sellVolumesNext[sellToken][buyToken];\n            sellVolumesNext[sellToken][buyToken] = add(sellVolumeNext, amountAfterFee);\n\n            // close previous auction if theoretically closed\n            closeTheoreticalClosedAuction(sellToken, buyToken, latestAuctionIndex);\n        }\n\n        if (auctionStart == AUCTION_START_WAITING_FOR_FUNDING) {\n            scheduleNextAuction(sellToken, buyToken);\n        }\n\n        emit NewSellOrder(sellToken, buyToken, msg.sender, auctionIndex, amountAfterFee);\n\n        return (auctionIndex, newSellerBal);\n    }\n\n    function postBuyOrder(address sellToken, address buyToken, uint auctionIndex, uint amount)\n        public\n        returns (uint newBuyerBal)\n    {\n        // R1: auction must not have cleared\n        require(closingPrices[sellToken][buyToken][auctionIndex].den == 0);\n\n        uint auctionStart = getAuctionStart(sellToken, buyToken);\n\n        // R2\n        require(auctionStart <= now);\n\n        // R4\n        require(auctionIndex == getAuctionIndex(sellToken, buyToken));\n\n        // R5: auction must not be in waiting period\n        require(auctionStart > AUCTION_START_WAITING_FOR_FUNDING);\n\n        // R6: auction must be funded\n        require(sellVolumesCurrent[sellToken][buyToken] > 0);\n\n        uint buyVolume = buyVolumes[sellToken][buyToken];\n        amount = min(amount, balances[buyToken][msg.sender]);\n\n        // R7\n        require(add(buyVolume, amount) < 10 ** 30);\n\n        // Overbuy is when a part of a buy order clears an auction\n        // In that case we only process the part before the overbuy\n        // To calculate overbuy, we first get current price\n        uint sellVolume = sellVolumesCurrent[sellToken][buyToken];\n\n        uint num;\n        uint den;\n        (num, den) = getCurrentAuctionPrice(sellToken, buyToken, auctionIndex);\n        // 10^30 * 10^37 = 10^67\n        uint outstandingVolume = atleastZero(int(mul(sellVolume, num) / den - buyVolume));\n\n        uint amountAfterFee;\n        if (amount < outstandingVolume) {\n            if (amount > 0) {\n                amountAfterFee = settleFee(buyToken, sellToken, auctionIndex, amount);\n            }\n        } else {\n            amount = outstandingVolume;\n            amountAfterFee = outstandingVolume;\n        }\n\n        // Here we could also use outstandingVolume or amountAfterFee, it doesn't matter\n        if (amount > 0) {\n            // Update variables\n            balances[buyToken][msg.sender] = sub(balances[buyToken][msg.sender], amount);\n            newBuyerBal = add(buyerBalances[sellToken][buyToken][auctionIndex][msg.sender], amountAfterFee);\n            buyerBalances[sellToken][buyToken][auctionIndex][msg.sender] = newBuyerBal;\n            buyVolumes[sellToken][buyToken] = add(buyVolumes[sellToken][buyToken], amountAfterFee);\n            emit NewBuyOrder(sellToken, buyToken, msg.sender, auctionIndex, amountAfterFee);\n        }\n\n        // Checking for equality would suffice here. nevertheless:\n        if (amount >= outstandingVolume) {\n            // Clear auction\n            clearAuction(sellToken, buyToken, auctionIndex, sellVolume);\n        }\n\n        return (newBuyerBal);\n    }\n\n    function claimSellerFunds(address sellToken, address buyToken, address user, uint auctionIndex)\n        public\n        returns (\n        // < (10^60, 10^61)\n        uint returned,\n        uint frtsIssued\n    )\n    {\n        closeTheoreticalClosedAuction(sellToken, buyToken, auctionIndex);\n        uint sellerBalance = sellerBalances[sellToken][buyToken][auctionIndex][user];\n\n        // R1\n        require(sellerBalance > 0);\n\n        // Get closing price for said auction\n        Fraction memory closingPrice = closingPrices[sellToken][buyToken][auctionIndex];\n        uint num = closingPrice.num;\n        uint den = closingPrice.den;\n\n        // R2: require auction to have cleared\n        require(den > 0);\n\n        // Calculate return\n        // < 10^30 * 10^30 = 10^60\n        returned = mul(sellerBalance, num) / den;\n\n        frtsIssued = issueFrts(\n            sellToken,\n            buyToken,\n            returned,\n            auctionIndex,\n            sellerBalance,\n            user\n        );\n\n        // Claim tokens\n        sellerBalances[sellToken][buyToken][auctionIndex][user] = 0;\n        if (returned > 0) {\n            balances[buyToken][user] = add(balances[buyToken][user], returned);\n        }\n        emit NewSellerFundsClaim(\n            sellToken,\n            buyToken,\n            user,\n            auctionIndex,\n            returned,\n            frtsIssued\n        );\n    }\n\n    function claimBuyerFunds(address sellToken, address buyToken, address user, uint auctionIndex)\n        public\n        returns (uint returned, uint frtsIssued)\n    {\n        closeTheoreticalClosedAuction(sellToken, buyToken, auctionIndex);\n\n        uint num;\n        uint den;\n        (returned, num, den) = getUnclaimedBuyerFunds(sellToken, buyToken, user, auctionIndex);\n\n        if (closingPrices[sellToken][buyToken][auctionIndex].den == 0) {\n            // Auction is running\n            claimedAmounts[sellToken][buyToken][auctionIndex][user] = add(\n                claimedAmounts[sellToken][buyToken][auctionIndex][user],\n                returned\n            );\n        } else {\n            // Auction has closed\n            // We DON'T want to check for returned > 0, because that would fail if a user claims\n            // intermediate funds & auction clears in same block (he/she would not be able to claim extraTokens)\n\n            // Assign extra sell tokens (this is possible only after auction has cleared,\n            // because buyVolume could still increase before that)\n            uint extraTokensTotal = extraTokens[sellToken][buyToken][auctionIndex];\n            uint buyerBalance = buyerBalances[sellToken][buyToken][auctionIndex][user];\n\n            // closingPrices.num represents buyVolume\n            // < 10^30 * 10^30 = 10^60\n            uint tokensExtra = mul(\n                buyerBalance,\n                extraTokensTotal\n            ) / closingPrices[sellToken][buyToken][auctionIndex].num;\n            returned = add(returned, tokensExtra);\n\n            frtsIssued = issueFrts(\n                buyToken,\n                sellToken,\n                mul(buyerBalance, den) / num,\n                auctionIndex,\n                buyerBalance,\n                user\n            );\n\n            // Auction has closed\n            // Reset buyerBalances and claimedAmounts\n            buyerBalances[sellToken][buyToken][auctionIndex][user] = 0;\n            claimedAmounts[sellToken][buyToken][auctionIndex][user] = 0;\n        }\n\n        // Claim tokens\n        if (returned > 0) {\n            balances[sellToken][user] = add(balances[sellToken][user], returned);\n        }\n\n        emit NewBuyerFundsClaim(\n            sellToken,\n            buyToken,\n            user,\n            auctionIndex,\n            returned,\n            frtsIssued\n        );\n    }\n\n    /// @dev allows to close possible theoretical closed markets\n    /// @param sellToken sellToken of an auction\n    /// @param buyToken buyToken of an auction\n    /// @param auctionIndex is the auctionIndex of the auction\n    function closeTheoreticalClosedAuction(address sellToken, address buyToken, uint auctionIndex) public {\n        if (auctionIndex == getAuctionIndex(\n            buyToken,\n            sellToken\n        ) && closingPrices[sellToken][buyToken][auctionIndex].num == 0) {\n            uint buyVolume = buyVolumes[sellToken][buyToken];\n            uint sellVolume = sellVolumesCurrent[sellToken][buyToken];\n            uint num;\n            uint den;\n            (num, den) = getCurrentAuctionPrice(sellToken, buyToken, auctionIndex);\n            // 10^30 * 10^37 = 10^67\n            if (sellVolume > 0) {\n                uint outstandingVolume = atleastZero(int(mul(sellVolume, num) / den - buyVolume));\n\n                if (outstandingVolume == 0) {\n                    postBuyOrder(sellToken, buyToken, auctionIndex, 0);\n                }\n            }\n        }\n    }\n\n    /// @dev Claim buyer funds for one auction\n    function getUnclaimedBuyerFunds(address sellToken, address buyToken, address user, uint auctionIndex)\n        public\n        view\n        returns (\n        // < (10^67, 10^37)\n        uint unclaimedBuyerFunds,\n        uint num,\n        uint den\n    )\n    {\n        // R1: checks if particular auction has ever run\n        require(auctionIndex <= getAuctionIndex(sellToken, buyToken));\n\n        (num, den) = getCurrentAuctionPrice(sellToken, buyToken, auctionIndex);\n\n        if (num == 0) {\n            // This should rarely happen - as long as there is >= 1 buy order,\n            // auction will clear before price = 0. So this is just fail-safe\n            unclaimedBuyerFunds = 0;\n        } else {\n            uint buyerBalance = buyerBalances[sellToken][buyToken][auctionIndex][user];\n            // < 10^30 * 10^37 = 10^67\n            unclaimedBuyerFunds = atleastZero(\n                int(mul(buyerBalance, den) / num - claimedAmounts[sellToken][buyToken][auctionIndex][user])\n            );\n        }\n    }\n\n    function getFeeRatio(address user)\n        public\n        view\n        returns (\n        // feeRatio < 10^4\n        uint num,\n        uint den\n    )\n    {\n        uint totalSupply = frtToken.totalSupply();\n        uint lockedFrt = frtToken.lockedTokenBalances(user);\n\n        /*\n          Fee Model:\n            locked FRT range     Fee\n            -----------------   ------\n            [0, 0.01%)           0.5%\n            [0.01%, 0.1%)        0.4%\n            [0.1%, 1%)           0.3%\n            [1%, 10%)            0.2%\n            [10%, 100%)          0.1%\n        */\n\n        if (lockedFrt * 10000 < totalSupply || totalSupply == 0) {\n            // Maximum fee, if user has locked less than 0.01% of the total FRT\n            // Fee: 0.5%\n            num = 1;\n            den = 200;\n        } else if (lockedFrt * 1000 < totalSupply) {\n            // If user has locked more than 0.01% and less than 0.1% of the total FRT\n            // Fee: 0.4%\n            num = 1;\n            den = 250;\n        } else if (lockedFrt * 100 < totalSupply) {\n            // If user has locked more than 0.1% and less than 1% of the total FRT\n            // Fee: 0.3%\n            num = 3;\n            den = 1000;\n        } else if (lockedFrt * 10 < totalSupply) {\n            // If user has locked more than 1% and less than 10% of the total FRT\n            // Fee: 0.2%\n            num = 1;\n            den = 500;\n        } else {\n            // If user has locked more than 10% of the total FRT\n            // Fee: 0.1%\n            num = 1;\n            den = 1000;\n        }\n    }\n\n    //@ dev returns price in units [token2]/[token1]\n    //@ param token1 first token for price calculation\n    //@ param token2 second token for price calculation\n    //@ param auctionIndex index for the auction to get the averaged price from\n    function getPriceInPastAuction(\n        address token1,\n        address token2,\n        uint auctionIndex\n    )\n        public\n        view\n        // price < 10^31\n        returns (uint num, uint den)\n    {\n        if (token1 == token2) {\n            // C1\n            num = 1;\n            den = 1;\n        } else {\n            // C2\n            // R2.1\n            // require(auctionIndex >= 0);\n\n            // C3\n            // R3.1\n            require(auctionIndex <= getAuctionIndex(token1, token2));\n            // auction still running\n\n            uint i = 0;\n            bool correctPair = false;\n            Fraction memory closingPriceToken1;\n            Fraction memory closingPriceToken2;\n\n            while (!correctPair) {\n                closingPriceToken2 = closingPrices[token2][token1][auctionIndex - i];\n                closingPriceToken1 = closingPrices[token1][token2][auctionIndex - i];\n\n                if (closingPriceToken1.num > 0 && closingPriceToken1.den > 0 ||\n                    closingPriceToken2.num > 0 && closingPriceToken2.den > 0)\n                {\n                    correctPair = true;\n                }\n                i++;\n            }\n\n            // At this point at least one closing price is strictly positive\n            // If only one is positive, we want to output that\n            if (closingPriceToken1.num == 0 || closingPriceToken1.den == 0) {\n                num = closingPriceToken2.den;\n                den = closingPriceToken2.num;\n            } else if (closingPriceToken2.num == 0 || closingPriceToken2.den == 0) {\n                num = closingPriceToken1.num;\n                den = closingPriceToken1.den;\n            } else {\n                // If both prices are positive, output weighted average\n                num = closingPriceToken2.den + closingPriceToken1.num;\n                den = closingPriceToken2.num + closingPriceToken1.den;\n            }\n        }\n    }\n\n    function scheduleNextAuction(\n        address sellToken,\n        address buyToken\n    )\n        internal\n    {\n        (uint sellVolume, uint sellVolumeOpp) = getSellVolumesInUSD(sellToken, buyToken);\n\n        bool enoughSellVolume = sellVolume >= thresholdNewAuction;\n        bool enoughSellVolumeOpp = sellVolumeOpp >= thresholdNewAuction;\n        bool schedule;\n        // Make sure both sides have liquidity in order to start the auction\n        if (enoughSellVolume && enoughSellVolumeOpp) {\n            schedule = true;\n        } else if (enoughSellVolume || enoughSellVolumeOpp) {\n            // But if the auction didn't start in 24h, then is enough to have\n            // liquidity in one of the two sides\n            uint latestAuctionIndex = getAuctionIndex(sellToken, buyToken);\n            uint clearingTime = getClearingTime(sellToken, buyToken, latestAuctionIndex - 1);\n            schedule = clearingTime <= now - 24 hours;\n        }\n\n        if (schedule) {\n            // Schedule next auction\n            setAuctionStart(sellToken, buyToken, WAITING_PERIOD_NEW_AUCTION);\n        } else {\n            resetAuctionStart(sellToken, buyToken);\n        }\n    }\n\n    function getSellVolumesInUSD(\n        address sellToken,\n        address buyToken\n    )\n        internal\n        view\n        returns (uint sellVolume, uint sellVolumeOpp)\n    {\n        // Check if auctions received enough sell orders\n        uint ethUSDPrice = ethUSDOracle.getUSDETHPrice();\n\n        uint sellNum;\n        uint sellDen;\n        (sellNum, sellDen) = getPriceOfTokenInLastAuction(sellToken);\n\n        uint buyNum;\n        uint buyDen;\n        (buyNum, buyDen) = getPriceOfTokenInLastAuction(buyToken);\n\n        // We use current sell volume, because in clearAuction() we set\n        // sellVolumesCurrent = sellVolumesNext before calling this function\n        // (this is so that we don't need case work,\n        // since it might also be called from postSellOrder())\n\n        // < 10^30 * 10^31 * 10^6 = 10^67\n        sellVolume = mul(mul(sellVolumesCurrent[sellToken][buyToken], sellNum), ethUSDPrice) / sellDen;\n        sellVolumeOpp = mul(mul(sellVolumesCurrent[buyToken][sellToken], buyNum), ethUSDPrice) / buyDen;\n    }\n\n    /// @dev Gives best estimate for market price of a token in ETH of any price oracle on the Ethereum network\n    /// @param token address of ERC-20 token\n    /// @return Weighted average of closing prices of opposite Token-ethToken auctions, based on their sellVolume\n    function getPriceOfTokenInLastAuction(address token)\n        public\n        view\n        returns (\n        // price < 10^31\n        uint num,\n        uint den\n    )\n    {\n        uint latestAuctionIndex = getAuctionIndex(token, ethToken);\n        // getPriceInPastAuction < 10^30\n        (num, den) = getPriceInPastAuction(token, ethToken, latestAuctionIndex - 1);\n    }\n\n    function getCurrentAuctionPrice(address sellToken, address buyToken, uint auctionIndex)\n        public\n        view\n        returns (\n        // price < 10^37\n        uint num,\n        uint den\n    )\n    {\n        Fraction memory closingPrice = closingPrices[sellToken][buyToken][auctionIndex];\n\n        if (closingPrice.den != 0) {\n            // Auction has closed\n            (num, den) = (closingPrice.num, closingPrice.den);\n        } else if (auctionIndex > getAuctionIndex(sellToken, buyToken)) {\n            (num, den) = (0, 0);\n        } else {\n            // Auction is running\n            uint pastNum;\n            uint pastDen;\n            (pastNum, pastDen) = getPriceInPastAuction(sellToken, buyToken, auctionIndex - 1);\n\n            // If we're calling the function into an unstarted auction,\n            // it will return the starting price of that auction\n            uint timeElapsed = atleastZero(int(now - getAuctionStart(sellToken, buyToken)));\n\n            // The numbers below are chosen such that\n            // P(0 hrs) = 2 * lastClosingPrice, P(6 hrs) = lastClosingPrice, P(>=24 hrs) = 0\n\n            // 10^5 * 10^31 = 10^36\n            num = atleastZero(int((24 hours - timeElapsed) * pastNum));\n            // 10^6 * 10^31 = 10^37\n            den = mul((timeElapsed + 12 hours), pastDen);\n\n            if (mul(num, sellVolumesCurrent[sellToken][buyToken]) <= mul(den, buyVolumes[sellToken][buyToken])) {\n                num = buyVolumes[sellToken][buyToken];\n                den = sellVolumesCurrent[sellToken][buyToken];\n            }\n        }\n    }\n\n    // > Helper fns\n    function getTokenOrder(address token1, address token2) public pure returns (address, address) {\n        if (token2 < token1) {\n            (token1, token2) = (token2, token1);\n        }\n\n        return (token1, token2);\n    }\n\n    function getAuctionStart(address token1, address token2) public view returns (uint auctionStart) {\n        (token1, token2) = getTokenOrder(token1, token2);\n        auctionStart = auctionStarts[token1][token2];\n    }\n\n    function getAuctionIndex(address token1, address token2) public view returns (uint auctionIndex) {\n        (token1, token2) = getTokenOrder(token1, token2);\n        auctionIndex = latestAuctionIndices[token1][token2];\n    }\n\n    function calculateFundedValueTokenToken(\n        address token1,\n        address token2,\n        uint token1Funding,\n        uint token2Funding,\n        address ethTokenMem,\n        uint ethUSDPrice\n    )\n        internal\n        view\n        returns (uint fundedValueUSD)\n    {\n        // We require there to exist ethToken-Token auctions\n        // R3.1\n        require(getAuctionIndex(token1, ethTokenMem) > 0);\n\n        // R3.2\n        require(getAuctionIndex(token2, ethTokenMem) > 0);\n\n        // Price of Token 1\n        uint priceToken1Num;\n        uint priceToken1Den;\n        (priceToken1Num, priceToken1Den) = getPriceOfTokenInLastAuction(token1);\n\n        // Price of Token 2\n        uint priceToken2Num;\n        uint priceToken2Den;\n        (priceToken2Num, priceToken2Den) = getPriceOfTokenInLastAuction(token2);\n\n        // Compute funded value in ethToken and USD\n        // 10^30 * 10^30 = 10^60\n        uint fundedValueETH = add(\n            mul(token1Funding, priceToken1Num) / priceToken1Den,\n            token2Funding * priceToken2Num / priceToken2Den\n        );\n\n        fundedValueUSD = mul(fundedValueETH, ethUSDPrice);\n    }\n\n    function addTokenPairSecondPart(\n        address token1,\n        address token2,\n        uint token1Funding,\n        uint token2Funding\n    )\n        internal\n    {\n        balances[token1][msg.sender] = sub(balances[token1][msg.sender], token1Funding);\n        balances[token2][msg.sender] = sub(balances[token2][msg.sender], token2Funding);\n\n        // Fee mechanism, fees are added to extraTokens\n        uint token1FundingAfterFee = settleFee(token1, token2, 1, token1Funding);\n        uint token2FundingAfterFee = settleFee(token2, token1, 1, token2Funding);\n\n        // Update other variables\n        sellVolumesCurrent[token1][token2] = token1FundingAfterFee;\n        sellVolumesCurrent[token2][token1] = token2FundingAfterFee;\n        sellerBalances[token1][token2][1][msg.sender] = token1FundingAfterFee;\n        sellerBalances[token2][token1][1][msg.sender] = token2FundingAfterFee;\n\n        // Save clearingTime as adding time\n        (address tokenA, address tokenB) = getTokenOrder(token1, token2);\n        clearingTimes[tokenA][tokenB][0] = now;\n\n        setAuctionStart(token1, token2, WAITING_PERIOD_NEW_TOKEN_PAIR);\n        emit NewTokenPair(token1, token2);\n    }\n\n    function setClearingTime(\n        address token1,\n        address token2,\n        uint auctionIndex,\n        uint auctionStart,\n        uint sellVolume,\n        uint buyVolume\n    )\n        internal\n    {\n        (uint pastNum, uint pastDen) = getPriceInPastAuction(token1, token2, auctionIndex - 1);\n        // timeElapsed = (12 hours)*(2 * pastNum * sellVolume - buyVolume * pastDen)/\n            // (sellVolume * pastNum + buyVolume * pastDen)\n        uint numerator = sub(mul(mul(pastNum, sellVolume), 24 hours), mul(mul(buyVolume, pastDen), 12 hours));\n        uint timeElapsed = numerator / (add(mul(sellVolume, pastNum), mul(buyVolume, pastDen)));\n        uint clearingTime = auctionStart + timeElapsed;\n        (token1, token2) = getTokenOrder(token1, token2);\n        clearingTimes[token1][token2][auctionIndex] = clearingTime;\n    }\n\n    function getClearingTime(\n        address token1,\n        address token2,\n        uint auctionIndex\n    )\n        public\n        view\n        returns (uint time)\n    {\n        (token1, token2) = getTokenOrder(token1, token2);\n        time = clearingTimes[token1][token2][auctionIndex];\n    }\n\n    function issueFrts(\n        address primaryToken,\n        address secondaryToken,\n        uint x,\n        uint auctionIndex,\n        uint bal,\n        address user\n    )\n        internal\n        returns (uint frtsIssued)\n    {\n        if (approvedTokens[primaryToken] && approvedTokens[secondaryToken]) {\n            address ethTokenMem = ethToken;\n            // Get frts issued based on ETH price of returned tokens\n            if (primaryToken == ethTokenMem) {\n                frtsIssued = bal;\n            } else if (secondaryToken == ethTokenMem) {\n                // 10^30 * 10^39 = 10^66\n                frtsIssued = x;\n            } else {\n                // Neither token is ethToken, so we use getHhistoricalPriceOracle()\n                uint pastNum;\n                uint pastDen;\n                (pastNum, pastDen) = getPriceInPastAuction(primaryToken, ethTokenMem, auctionIndex - 1);\n                // 10^30 * 10^35 = 10^65\n                frtsIssued = mul(bal, pastNum) / pastDen;\n            }\n\n            if (frtsIssued > 0) {\n                // Issue frtToken\n                frtToken.mintTokens(user, frtsIssued);\n            }\n        }\n    }\n\n    function settleFee(address primaryToken, address secondaryToken, uint auctionIndex, uint amount)\n        internal\n        returns (\n        // < 10^30\n        uint amountAfterFee\n    )\n    {\n        uint feeNum;\n        uint feeDen;\n        (feeNum, feeDen) = getFeeRatio(msg.sender);\n        // 10^30 * 10^3 / 10^4 = 10^29\n        uint fee = mul(amount, feeNum) / feeDen;\n\n        if (fee > 0) {\n            fee = settleFeeSecondPart(primaryToken, fee);\n\n            uint usersExtraTokens = extraTokens[primaryToken][secondaryToken][auctionIndex + 1];\n            extraTokens[primaryToken][secondaryToken][auctionIndex + 1] = add(usersExtraTokens, fee);\n\n            emit Fee(primaryToken, secondaryToken, msg.sender, auctionIndex, fee);\n        }\n\n        amountAfterFee = sub(amount, fee);\n    }\n\n    function settleFeeSecondPart(address primaryToken, uint fee) internal returns (uint newFee) {\n        // Allow user to reduce up to half of the fee with owlToken\n        uint num;\n        uint den;\n        (num, den) = getPriceOfTokenInLastAuction(primaryToken);\n\n        // Convert fee to ETH, then USD\n        // 10^29 * 10^30 / 10^30 = 10^29\n        uint feeInETH = mul(fee, num) / den;\n\n        uint ethUSDPrice = ethUSDOracle.getUSDETHPrice();\n        // 10^29 * 10^6 = 10^35\n        // Uses 18 decimal places <> exactly as owlToken tokens: 10**18 owlToken == 1 USD\n        uint feeInUSD = mul(feeInETH, ethUSDPrice);\n        uint amountOfowlTokenBurned = min(owlToken.allowance(msg.sender, address(this)), feeInUSD / 2);\n        amountOfowlTokenBurned = min(owlToken.balanceOf(msg.sender), amountOfowlTokenBurned);\n\n        if (amountOfowlTokenBurned > 0) {\n            owlToken.burnOWL(msg.sender, amountOfowlTokenBurned);\n            // Adjust fee\n            // 10^35 * 10^29 = 10^64\n            uint adjustment = mul(amountOfowlTokenBurned, fee) / feeInUSD;\n            newFee = sub(fee, adjustment);\n        } else {\n            newFee = fee;\n        }\n    }\n\n    // addClearTimes\n    /// @dev clears an Auction\n    /// @param sellToken sellToken of the auction\n    /// @param buyToken  buyToken of the auction\n    /// @param auctionIndex of the auction to be cleared.\n    function clearAuction(\n        address sellToken,\n        address buyToken,\n        uint auctionIndex,\n        uint sellVolume\n    )\n        internal\n    {\n        // Get variables\n        uint buyVolume = buyVolumes[sellToken][buyToken];\n        uint sellVolumeOpp = sellVolumesCurrent[buyToken][sellToken];\n        uint closingPriceOppDen = closingPrices[buyToken][sellToken][auctionIndex].den;\n        uint auctionStart = getAuctionStart(sellToken, buyToken);\n\n        // Update closing price\n        if (sellVolume > 0) {\n            closingPrices[sellToken][buyToken][auctionIndex] = Fraction(buyVolume, sellVolume);\n        }\n\n        // if (opposite is 0 auction OR price = 0 OR opposite auction cleared)\n        // price = 0 happens if auction pair has been running for >= 24 hrs\n        if (sellVolumeOpp == 0 || now >= auctionStart + 24 hours || closingPriceOppDen > 0) {\n            // Close auction pair\n            uint buyVolumeOpp = buyVolumes[buyToken][sellToken];\n            if (closingPriceOppDen == 0 && sellVolumeOpp > 0) {\n                // Save opposite price\n                closingPrices[buyToken][sellToken][auctionIndex] = Fraction(buyVolumeOpp, sellVolumeOpp);\n            }\n\n            uint sellVolumeNext = sellVolumesNext[sellToken][buyToken];\n            uint sellVolumeNextOpp = sellVolumesNext[buyToken][sellToken];\n\n            // Update state variables for both auctions\n            sellVolumesCurrent[sellToken][buyToken] = sellVolumeNext;\n            if (sellVolumeNext > 0) {\n                sellVolumesNext[sellToken][buyToken] = 0;\n            }\n            if (buyVolume > 0) {\n                buyVolumes[sellToken][buyToken] = 0;\n            }\n\n            sellVolumesCurrent[buyToken][sellToken] = sellVolumeNextOpp;\n            if (sellVolumeNextOpp > 0) {\n                sellVolumesNext[buyToken][sellToken] = 0;\n            }\n            if (buyVolumeOpp > 0) {\n                buyVolumes[buyToken][sellToken] = 0;\n            }\n\n            // Save clearing time\n            setClearingTime(sellToken, buyToken, auctionIndex, auctionStart, sellVolume, buyVolume);\n            // Increment auction index\n            setAuctionIndex(sellToken, buyToken);\n            // Check if next auction can be scheduled\n            scheduleNextAuction(sellToken, buyToken);\n        }\n\n        emit AuctionCleared(sellToken, buyToken, sellVolume, buyVolume, auctionIndex);\n    }\n\n    function setAuctionStart(address token1, address token2, uint value) internal {\n        (token1, token2) = getTokenOrder(token1, token2);\n        uint auctionStart = now + value;\n        uint auctionIndex = latestAuctionIndices[token1][token2];\n        auctionStarts[token1][token2] = auctionStart;\n        emit AuctionStartScheduled(token1, token2, auctionIndex, auctionStart);\n    }\n\n    function resetAuctionStart(address token1, address token2) internal {\n        (token1, token2) = getTokenOrder(token1, token2);\n        if (auctionStarts[token1][token2] != AUCTION_START_WAITING_FOR_FUNDING) {\n            auctionStarts[token1][token2] = AUCTION_START_WAITING_FOR_FUNDING;\n        }\n    }\n\n    function setAuctionIndex(address token1, address token2) internal {\n        (token1, token2) = getTokenOrder(token1, token2);\n        latestAuctionIndices[token1][token2] += 1;\n    }\n\n    function checkLengthsForSeveralAuctionClaiming(\n        address[] memory auctionSellTokens,\n        address[] memory auctionBuyTokens,\n        uint[] memory auctionIndices\n    ) internal pure returns (uint length)\n    {\n        length = auctionSellTokens.length;\n        uint length2 = auctionBuyTokens.length;\n        require(length == length2);\n\n        uint length3 = auctionIndices.length;\n        require(length2 == length3);\n    }\n\n    // > Events\n    event NewDeposit(address indexed token, uint amount);\n\n    event NewWithdrawal(address indexed token, uint amount);\n\n    event NewSellOrder(\n        address indexed sellToken,\n        address indexed buyToken,\n        address indexed user,\n        uint auctionIndex,\n        uint amount\n    );\n\n    event NewBuyOrder(\n        address indexed sellToken,\n        address indexed buyToken,\n        address indexed user,\n        uint auctionIndex,\n        uint amount\n    );\n\n    event NewSellerFundsClaim(\n        address indexed sellToken,\n        address indexed buyToken,\n        address indexed user,\n        uint auctionIndex,\n        uint amount,\n        uint frtsIssued\n    );\n\n    event NewBuyerFundsClaim(\n        address indexed sellToken,\n        address indexed buyToken,\n        address indexed user,\n        uint auctionIndex,\n        uint amount,\n        uint frtsIssued\n    );\n\n    event NewTokenPair(address indexed sellToken, address indexed buyToken);\n\n    event AuctionCleared(\n        address indexed sellToken,\n        address indexed buyToken,\n        uint sellVolume,\n        uint buyVolume,\n        uint indexed auctionIndex\n    );\n\n    event AuctionStartScheduled(\n        address indexed sellToken,\n        address indexed buyToken,\n        uint indexed auctionIndex,\n        uint auctionStart\n    );\n\n    event Fee(\n        address indexed primaryToken,\n        address indexed secondarToken,\n        address indexed user,\n        uint auctionIndex,\n        uint fee\n    );\n}",
  "bytecode": "608060405234801561001057600080fd5b506156f6806100206000396000f3fe608060405234801561001057600080fd5b50600436106103f45760003560e060020a9004806382a57b4311610219578063cd94a2a411610129578063edd0b5cb116100bc578063f4279d1f1161008b578063f4279d1f14611397578063f625ee281461139f578063f79710fd146113c5578063fac7abe3146113fb578063fdab1b7b14611429576103f4565b8063edd0b5cb14611317578063ee93114c1461133d578063f3fef3a314611345578063f41d97fc14611371576103f4565b8063e1c95bb9116100f8578063e1c95bb914611259578063e31c71c414611276578063e9f8cd7014611299578063ebcc0de1146112e1576103f4565b8063cd94a2a4146110ca578063d3cc8d1c146110d2578063dae595e5146111ef578063df6af7d11461121d576103f4565b8063b64c4905116101ac578063c23f001f1161017b578063c23f001f14611031578063c6af43f91461105f578063c8a4ac9c1461107c578063cb10fa761461109f578063cd04ccfc146110c2576103f4565b8063b64c490514610f76578063b67d77c514610fa4578063b8beafd614610fc7578063c1a21bf314610ff5576103f4565b8063acb10351116101e8578063acb1035114610e84578063b029385014610ed6578063b04c023914610f12578063b3c2083f14610f48576103f4565b806382a57b4314610d245780639fec8e9614610e38578063a48cef4a14610e74578063a619486e14610e7c576103f4565b80635e7f22c211610314578063706eb3ab116102a7578063796a807611610276578063796a807614610c955780637ae2b5c714610cbb5780637bf1a62714610cde578063821b98f314610ce65780638261eb1b14610d1c576103f4565b8063706eb3ab14610a7e5780637420a32f14610a86578063771602f714610abc5780637895dd2114610adf576103f4565b806365b0d711116102e357806365b0d711146109a35780636d1ea3fa14610a485780636e6260fa14610a6e5780636ea6836014610a76576103f4565b80635e7f22c2146108ed5780635ec2c7bf1461092957806365054e5514610931578063657a37ad1461096d576103f4565b80632cef4dac1161038c57806347e7ef241161035b57806347e7ef24146107ff5780634bf8e7a21461082b5780634e30a66c1461087a57806359f96ae5146108b1576103f4565b80632cef4dac146107765780633069046814610780578063377758071461079d578063403fbf54146107d9576103f4565b80630c57cfba116103c85780630c57cfba146105915780630e7c0f80146107005780631006a41f1461071a57806314584a9d14610748576103f4565b8062599e65146103f957806302ffc0b01461044d57806304e80e901461050d57806306d58f2a14610531575b600080fd5b6104276004803603604081101561040f57600080fd5b50600160a060020a038135811691602001351661145f565b60408051600160a060020a03938416815291909216602082015281519081900390910190f35b6104bd6004803603602081101561046357600080fd5b81019060208101813564010000000081111561047e57600080fd5b82018360208201111561049057600080fd5b803590602001918460208302840111640100000000831117156104b257600080fd5b509092509050611488565b60408051602080825283518183015283519192839290830191858101910280838360005b838110156104f95781810151838201526020016104e1565b505050509050019250505060405180910390f35b610515611544565b60408051600160a060020a039092168252519081900360200190f35b610573600480360360a081101561054757600080fd5b50600160a060020a03813581169160208101358216916040820135169060608101359060800135611553565b60408051938452602084019290925282820152519081900360600190f35b6106a5600480360360608110156105a757600080fd5b8101906020810181356401000000008111156105c257600080fd5b8201836020820111156105d457600080fd5b803590602001918460208302840111640100000000831117156105f657600080fd5b91939092909160208101903564010000000081111561061457600080fd5b82018360208201111561062657600080fd5b8035906020019184602083028401116401000000008311171561064857600080fd5b91939092909160208101903564010000000081111561066657600080fd5b82018360208201111561067857600080fd5b8035906020019184602083028401116401000000008311171561069a57600080fd5b509092509050611580565b6040518080602001838152602001828103825284818151815260200191508051906020019060200280838360005b838110156106eb5781810151838201526020016106d3565b50505050905001935050505060405180910390f35b61070861172f565b60408051918252519081900360200190f35b6107086004803603604081101561073057600080fd5b50600160a060020a0381358116916020013516611735565b6107086004803603604081101561075e57600080fd5b50600160a060020a0381358116916020013516611752565b61077e61178d565b005b6107086004803603602081101561079657600080fd5b5035611851565b610708600480360360808110156107b357600080fd5b50600160a060020a0381358116916020810135821691604082013591606001351661186b565b61077e600480360360208110156107ef57600080fd5b5035600160a060020a0316611897565b6107086004803603604081101561081557600080fd5b50600160a060020a0381351690602001356119ba565b6108616004803603606081101561084157600080fd5b50600160a060020a03813581169160208101359091169060400135611a9c565b6040805192835260208301919091528051918290030190f35b61089d6004803603604081101561089057600080fd5b5080359060200135611c27565b604080519115158252519081900360200190f35b610861600480360360808110156108c757600080fd5b50600160a060020a03813581169160208101359091169060408101359060600135611c2e565b6107086004803603608081101561090357600080fd5b50600160a060020a03813581169160208101359091169060408101359060600135611fcb565b610515612413565b6108616004803603608081101561094757600080fd5b50600160a060020a03813581169160208101358216916040820135169060600135612422565b6105736004803603606081101561098357600080fd5b50600160a060020a038135811691602081013590911690604001356125f6565b61077e600480360360408110156109b957600080fd5b8101906020810181356401000000008111156109d457600080fd5b8201836020820111156109e657600080fd5b80359060200191846020830284011164010000000083111715610a0857600080fd5b9190808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152509295505050503515159050612623565b61089d60048036036020811015610a5e57600080fd5b5035600160a060020a0316612729565b61070861273e565b610515612744565b610515612753565b61070860048036036060811015610a9c57600080fd5b50600160a060020a03813581169160208101359091169060400135612762565b61070860048036036040811015610ad257600080fd5b50803590602001356127a7565b610bfc60048036036080811015610af557600080fd5b810190602081018135640100000000811115610b1057600080fd5b820183602082011115610b2257600080fd5b80359060200191846020830284011164010000000083111715610b4457600080fd5b919390929091602081019035640100000000811115610b6257600080fd5b820183602082011115610b7457600080fd5b80359060200191846020830284011164010000000083111715610b9657600080fd5b919390929091602081019035640100000000811115610bb457600080fd5b820183602082011115610bc657600080fd5b80359060200191846020830284011164010000000083111715610be857600080fd5b919350915035600160a060020a03166127c3565b604051808060200180602001838103835285818151815260200191508051906020019060200280838360005b83811015610c40578181015183820152602001610c28565b50505050905001838103825284818151815260200191508051906020019060200280838360005b83811015610c7f578181015183820152602001610c67565b5050505090500194505050505060405180910390f35b61077e60048036036020811015610cab57600080fd5b5035600160a060020a0316612976565b61070860048036036040811015610cd157600080fd5b5080359060200135612a3b565b610515612a53565b61077e60048036036060811015610cfc57600080fd5b50600160a060020a03813581169160208101359091169060400135612a62565b610515612b37565b6106a560048036036060811015610d3a57600080fd5b810190602081018135640100000000811115610d5557600080fd5b820183602082011115610d6757600080fd5b80359060200191846020830284011164010000000083111715610d8957600080fd5b919390929091602081019035640100000000811115610da757600080fd5b820183602082011115610db957600080fd5b80359060200191846020830284011164010000000083111715610ddb57600080fd5b919390929091602081019035640100000000811115610df957600080fd5b820183602082011115610e0b57600080fd5b80359060200191846020830284011164010000000083111715610e2d57600080fd5b509092509050612b46565b61070860048036036080811015610e4e57600080fd5b50600160a060020a03813581169160208101358216916040820135916060013516612cab565b610708612cd7565b610515612cdd565b61077e600480360360e0811015610e9a57600080fd5b50600160a060020a0381358116916020810135821691604082013581169160608101358216916080820135169060a08101359060c00135612cec565b61086160048036036080811015610eec57600080fd5b50600160a060020a03813581169160208101358216916040820135169060600135612f78565b61070860048036036060811015610f2857600080fd5b50600160a060020a038135811691602081013590911690604001356132d2565b61070860048036036040811015610f5e57600080fd5b50600160a060020a03813581169160200135166132f5565b61070860048036036040811015610f8c57600080fd5b50600160a060020a0381358116916020013516613312565b61070860048036036040811015610fba57600080fd5b508035906020013561332f565b61070860048036036040811015610fdd57600080fd5b50600160a060020a038135811691602001351661334c565b6107086004803603608081101561100b57600080fd5b50600160a060020a03813581169160208101358216916040820135916060013516613369565b6107086004803603604081101561104757600080fd5b50600160a060020a0381358116916020013516613395565b61077e6004803603602081101561107557600080fd5b50356133b2565b6107086004803603604081101561109257600080fd5b5080359060200135613403565b61089d600480360360408110156110b557600080fd5b508035906020013561341f565b610515613441565b610515613450565b610bfc600480360360808110156110e857600080fd5b81019060208101813564010000000081111561110357600080fd5b82018360208201111561111557600080fd5b8035906020019184602083028401116401000000008311171561113757600080fd5b91939092909160208101903564010000000081111561115557600080fd5b82018360208201111561116757600080fd5b8035906020019184602083028401116401000000008311171561118957600080fd5b9193909290916020810190356401000000008111156111a757600080fd5b8201836020820111156111b957600080fd5b803590602001918460208302840111640100000000831117156111db57600080fd5b919350915035600160a060020a031661345f565b6107086004803603604081101561120557600080fd5b50600160a060020a03813581169160200135166135f4565b6105736004803603608081101561123357600080fd5b50600160a060020a0381358116916020810135821691604082013516906060013561362f565b61077e6004803603602081101561126f57600080fd5b50356136e9565b61089d6004803603604081101561128c57600080fd5b508035906020013561373a565b61077e600480360360c08110156112af57600080fd5b50600160a060020a03813581169160208101359091169060408101359060608101359060808101359060a0013561373f565b610861600480360360608110156112f757600080fd5b50600160a060020a03813581169160208101359091169060400135613c44565b6108616004803603602081101561132d57600080fd5b5035600160a060020a0316613c6e565b610708613e08565b6107086004803603604081101561135b57600080fd5b50600160a060020a038135169060200135613e0e565b6108616004803603602081101561138757600080fd5b5035600160a060020a0316613f49565b61077e613f91565b61077e600480360360208110156113b557600080fd5b5035600160a060020a0316614054565b610708600480360360608110156113db57600080fd5b50600160a060020a03813581169160208101359091169060400135614161565b6107086004803603604081101561141157600080fd5b50600160a060020a0381358116916020013516614184565b6108616004803603606081101561143f57600080fd5b50600160a060020a038135811691602081013590911690604001356141a1565b60008083600160a060020a031683600160a060020a03161015611480579192915b509192909150565b604080518281526020808402820101909152606090829082908280156114b8578160200160208202803883390190505b50905060005b8281101561153957600460008787848181106114d657fe5b90506020020135600160a060020a0316600160a060020a0316600160a060020a0316815260200190815260200160002060009054906101000a900460ff16828281518110151561152257fe5b9115156020928302909101909101526001016114be565b509150505b92915050565b600054600160a060020a031690565b600080600061156488888888612422565b90935091506115738785613e0e565b9050955095509592505050565b606060008061162389898080602002602001604051908101604052809392919081815260200183836020028082843760009201919091525050604080516020808d0282810182019093528c82529093508c92508b91829185019084908082843760009201919091525050604080516020808c0282810182019093528b82529093508b92508a91829185019084908082843760009201919091525061432e92505050565b9050606081604051908082528060200260200182016040528015611651578160200160208202803883390190505b5090506000805b8381101561171e576116b88c8c8381811061166f57fe5b90506020020135600160a060020a03168b8b84818110151561168d57fe5b90506020020135600160a060020a0316338b8b8681811015156116ac57fe5b90506020020135612f78565b84838151811015156116c657fe5b602090810290910101919091529485019491506117158c8c838181106116e857fe5b90506020020135600160a060020a0316848381518110151561170657fe5b90602001906020020151613e0e565b50600101611658565b509093505050965096945050505050565b60035481565b600e60209081526000928352604080842090915290825290205481565b600061175e838361145f565b600160a060020a039182166000908152600d602090815260408083209390941682529190915220549392505050565b600254600160a060020a031615156117d95760405160e560020a62461bcd02815260040180806020018281038252602b8152602001806154fd602b913960400191505060405180910390fd5b60035442101561181d5760405160e560020a62461bcd02815260040180806020018281038252603981526020018061546e6039913960400191505060405180910390fd5b600280546000805473ffffffffffffffffffffffffffffffffffffffff19908116600160a060020a03841617909155169055565b60008082121561186357506000611866565b50805b919050565b601760209081526000948552604080862082529385528385208152918452828420909152825290205481565b600154600160a060020a031633146118e35760405160e560020a62461bcd02815260040180806020018281038252602a8152602001806154a7602a913960400191505060405180910390fd5b600160a060020a0381161515611943576040805160e560020a62461bcd02815260206004820181905260248201527f546865206f7261636c652061646472657373206d7573742062652076616c6964604482015290519081900360640190fd5b6006805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0383161790556119784262278d006127a7565b60075560408051600160a060020a038316815290517f3f174cfd713408ca6e4620d1efcc241b23fc39aa7d4694bd98610d3384dc001c9181900360200190a150565b60006119c98333846001614355565b1515611a095760405160e560020a62461bcd0281526004018080602001828103825260248152602001806155986024913960400191505060405180910390fd5b600160a060020a0383166000908152601460209081526040808320338452909152812054611a3790846127a7565b600160a060020a03851660008181526014602090815260408083203384528252918290208490558151878152915193945091927f2cb77763bc1e8490c1a904905c4d74b4269919aca114464f4bb4d911e60de364929181900390910190a29392505050565b60008083600160a060020a031685600160a060020a03161415611ac457506001905080611c1f565b611ace8585611752565b831115611ada57600080fd5b600080611ae5615327565b611aed615327565b5b821515611bb3575050600160a060020a038087166000818152601060208181526040808420958d16808552958252808420888c038086529083528185208251808401845281548152600191820154818601529786529383528185209585529482528084209484529381528383208451808601909552805480865292015490840152919291118015611b83575060008260200151115b80611b9e575080516000108015611b9e575060008160200151115b15611ba857600192505b600190930192611aee565b81511580611bc357506020820151155b15611bd957602081015181519096509450611c1a565b80511580611be957506020810151155b15611bff57815160208301519096509450611c1a565b81600001518160200151019550816020015181600001510194505b505050505b935093915050565b8101101590565b600160a060020a03841660009081526014602090815260408083203384529091528120548190611c5f908490612a3b565b92506000611c6d8787611752565b905060008111611c7c57600080fd5b6000611c8888886135f4565b90506001811480611c9857504281115b15611d3b57851515611cac57819550611ced565b858214611ced5760405160e560020a62461bcd0281526004018080602001828103825260358152602001806155de6035913960400191505060405180910390fd5b600160a060020a038089166000908152601160209081526040808320938b16835292905220546c0c9f2c9cd04674edea4000000090611d2c90876127a7565b10611d3657600080fd5b611da5565b851515611d4d57816001019550611d5c565b600182018614611d5c57600080fd5b600160a060020a038089166000908152601260209081526040808320938b16835292905220546c0c9f2c9cd04674edea4000000090611d9b90876127a7565b10611da557600080fd5b6000611db38989898961449a565b600160a060020a038a166000908152601460209081526040808320338452909152902054909150611de4908761332f565b600160a060020a03808b166000818152601460209081526040808320338085529083528184209690965592825260168152828220938d1682529283528181208b8252835281812093815292909152812054611e3f90836127a7565b600160a060020a03808c166000908152601660209081526040808320938e1683529281528282208c8352815282822033835290522081905590506001831480611e8757504283115b15611ee857600160a060020a03808b166000908152601160209081526040808320938d1683529290522054611ebc81846127a7565b600160a060020a03808d166000908152601160209081526040808320938f168352929052205550611f4b565b600160a060020a03808b166000908152601260209081526040808320938d1683529290522054611f1881846127a7565b600160a060020a03808d166000908152601260209081526040808320938f1683529290522055611f498b8b87612a62565b505b6001831415611f5e57611f5e8a8a61459f565b33600160a060020a031689600160a060020a03168b600160a060020a03167f3681d6f6ad159bac260c32828859f6df545bbf841c6e70787bcf0acbc390512a8b86604051808381526020018281526020019250505060405180910390a49699969850959650505050505050565b600160a060020a03808516600090815260106020908152604080832093871683529281528282208583529052908120600101541561200857600080fd5b600061201486866135f4565b90504281111561202357600080fd5b61202d8686611752565b841461203857600080fd5b6001811161204557600080fd5b600160a060020a0380871660009081526011602090815260408083209389168352929052908120541161207757600080fd5b600160a060020a03808716600090815260136020908152604080832093891683529281528282205460148252838320338452909152919020546120bb908590612a3b565b93506c0c9f2c9cd04674edea400000006120d582866127a7565b106120df57600080fd5b600160a060020a038088166000908152601160209081526040808320938a1683529290529081205490806121148a8a8a6141a1565b9092509050600061213a858361212a8787613403565b81151561213357fe5b0403611851565b905060008189101561216357600089111561215e5761215b8b8d8c8c61449a565b90505b612169565b50965086805b60008911156123f157600160a060020a038b1660009081526014602090815260408083203384529091529020546121a0908a61332f565b601460008d600160a060020a0316600160a060020a03168152602001908152602001600020600033600160a060020a0316600160a060020a0316815260200190815260200160002081905550612272601760008e600160a060020a0316600160a060020a0316815260200190815260200160002060008d600160a060020a0316600160a060020a0316815260200190815260200160002060008c8152602001908152602001600020600033600160a060020a0316600160a060020a0316815260200190815260200160002054826127a7565b975087601760008e600160a060020a0316600160a060020a0316815260200190815260200160002060008d600160a060020a0316600160a060020a0316815260200190815260200160002060008c8152602001908152602001600020600033600160a060020a0316600160a060020a0316815260200190815260200160002081905550612347601360008e600160a060020a0316600160a060020a0316815260200190815260200160002060008d600160a060020a0316600160a060020a0316815260200190815260200160002054826127a7565b601360008e600160a060020a0316600160a060020a0316815260200190815260200160002060008d600160a060020a0316600160a060020a031681526020019081526020016000208190555033600160a060020a03168b600160a060020a03168d600160a060020a03167ff1751a362067564d5feb9ed26f1898bb14c17e1254e3724d454bc2ae80195c258d85604051808381526020018281526020019250505060405180910390a45b818910612404576124048c8c8c88614633565b50505050505050949350505050565b600154600160a060020a031681565b600080612430868685612a62565b600160a060020a03808716600090815260166020908152604080832089851684528252808320878452825280832093881683529290529081205490811161247657600080fd5b61247e615327565b50600160a060020a038088166000908152601060209081526040808320938a1683529281528282208783528152828220835180850190945280548085526001909101549184018290529181116124d357600080fd5b806124de8584613403565b8115156124e757fe5b0495506124f88a8a888a888d614958565b600160a060020a03808c1660009081526016602090815260408083208e8516845282528083208c84528252808320938d16835292905290812081905590955086111561259557600160a060020a03808a166000908152601460209081526040808320938c168352929052205461256e90876127a7565b600160a060020a03808b166000908152601460209081526040808320938d16835292905220555b60408051888152602081018890528082018790529051600160a060020a03808b16928c821692918e16917fa3ac9b53d029621ef95693b5f9b1d0b0da75029fe8530389271be02715e24c139181900360600190a45050505094509492505050565b600080600061260586856119ba565b92506126148686600087611c2e565b93979096509294509192505050565b600154600160a060020a0316331461266f5760405160e560020a62461bcd02815260040180806020018281038252602a8152602001806154a7602a913960400191505060405180910390fd5b60005b8251811015612724578160046000858481518110151561268e57fe5b602090810291909101810151600160a060020a03168252810191909152604001600020805460ff191691151591909117905582518390829081106126ce57fe5b90602001906020020151600160a060020a03167fc091bf3abd3a42f670f8ad1a6ad5b849311210403e1d85d6ac31f43114d5ca6e83604051808215151515815260200191505060405180910390a2600101612672565b505050565b60046020526000908152604090205460ff1681565b60095481565b600254600160a060020a031681565b600554600160a060020a031681565b600061276e848461145f565b600160a060020a039182166000908152600f60209081526040808320939094168252918252828120948152939052909120549392505050565b60006127b38383611c27565b15156127be57600080fd5b500190565b60608060006128668a8a8080602002602001604051908101604052809392919081815260200183836020028082843760009201919091525050604080516020808e0282810182019093528d82529093508d92508c91829185019084908082843760009201919091525050604080516020808d0282810182019093528c82529093508c92508b91829185019084908082843760009201919091525061432e92505050565b9050606081604051908082528060200260200182016040528015612894578160200160208202803883390190505b5090506060826040519080825280602002602001820160405280156128c3578160200160208202803883390190505b50905060005b83811015612964576129298d8d838181106128e057fe5b90506020020135600160a060020a03168c8c8481811015156128fe57fe5b90506020020135600160a060020a0316898c8c86818110151561291d57fe5b90506020020135612422565b848381518110151561293757fe5b906020019060200201848481518110151561294e57fe5b60209081029091010191909152526001016128c9565b50909b909a5098505050505050505050565b600154600160a060020a031633146129c25760405160e560020a62461bcd02815260040180806020018281038252602a8152602001806154a7602a913960400191505060405180910390fd5b600160a060020a0381161515612a0c5760405160e560020a62461bcd0281526004018080602001828103825260268152602001806154486026913960400191505060405180910390fd5b6001805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b600081831015612a4c57508161153e565b508061153e565b600854600160a060020a031681565b612a6c8284611752565b81148015612aa55750600160a060020a038084166000908152601060209081526040808320938616835292815282822084835290522054155b1561272457600160a060020a038084166000818152601360209081526040808320948716808452948252808320549383526011825280832094835293905291822054909180612af58787876141a1565b90925090506000831115612b2e576000612b14858361212a8787613403565b9050801515612b2c57612b2a8888886000611fcb565b505b505b50505050505050565b600b54600160a060020a031681565b6060600080612be989898080602002602001604051908101604052809392919081815260200183836020028082843760009201919091525050604080516020808d0282810182019093528c82529093508c92508b91829185019084908082843760009201919091525050604080516020808c0282810182019093528b82529093508b92508a91829185019084908082843760009201919091525061432e92505050565b9050606081604051908082528060200260200182016040528015612c17578160200160208202803883390190505b5090506000805b8381101561171e57612c728c8c83818110612c3557fe5b90506020020135600160a060020a03168b8b848181101515612c5357fe5b90506020020135600160a060020a0316338b8b86818110151561291d57fe5b8483815181101515612c8057fe5b60209081029091010191909152948501949150612ca28a8a838181106116e857fe5b50600101612c1e565b601860209081526000948552604080862082529385528385208152918452828420909152825290205481565b60075481565b600054600160a060020a031681565b600854600160a060020a031615612d375760405160e560020a62461bcd0281526004018080602001828103825260228152602001806153c86022913960400191505060405180910390fd5b600160a060020a0386161515612d97576040805160e560020a62461bcd02815260206004820152601d60248201527f546865204f574c2061646472657373206d7573742062652076616c6964000000604482015290519081900360640190fd5b600160a060020a0387161515612df7576040805160e560020a62461bcd02815260206004820152601d60248201527f546865204652542061646472657373206d7573742062652076616c6964000000604482015290519081900360640190fd5b600160a060020a0385161515612e415760405160e560020a62461bcd0281526004018080602001828103825260248152602001806156136024913960400191505060405180910390fd5b600160a060020a0384161515612ea1576040805160e560020a62461bcd02815260206004820152601e60248201527f54686520574554482061646472657373206d7573742062652076616c69640000604482015290519081900360640190fd5b600160a060020a0383161515612f01576040805160e560020a62461bcd02815260206004820181905260248201527f546865206f7261636c652061646472657373206d7573742062652076616c6964604482015290519081900360640190fd5b600b805473ffffffffffffffffffffffffffffffffffffffff19908116600160a060020a03998a1617909155600c8054821697891697909717909655600180548716958816959095179094556008805486169387169390931790925560058054909416941693909317909155600991909155600a55565b600080612f86868685612a62565b600080612f958888888861362f565b600160a060020a03808c166000908152601060209081526040808320938e1683529281528282208b8352905220600101549296509093509150151561305357600160a060020a0380891660009081526018602090815260408083208b8516845282528083208984528252808320938a168352929052205461301690856127a7565b600160a060020a03808a1660009081526018602090815260408083208c8516845282528083208a84528252808320938b1683529290522055613213565b600160a060020a0380891660008181526015602090815260408083208c86168085529083528184208b85528352818420548585526017845282852082865284528285208c86528452828520968d168552958352818420549484526010835281842090845282528083208a84529091528120546130cf8385613403565b8115156130d857fe5b0490506130e587826127a7565b96506131098a8c876130f78689613403565b81151561310057fe5b048b868e614958565b95506000601760008d600160a060020a0316600160a060020a0316815260200190815260200160002060008c600160a060020a0316600160a060020a0316815260200190815260200160002060008a815260200190815260200160002060008b600160a060020a0316600160a060020a03168152602001908152602001600020819055506000601860008d600160a060020a0316600160a060020a0316815260200190815260200160002060008c600160a060020a0316600160a060020a0316815260200190815260200160002060008a815260200190815260200160002060008b600160a060020a0316600160a060020a03168152602001908152602001600020819055505050505b600084111561327357600160a060020a038089166000908152601460209081526040808320938a168352929052205461324c90856127a7565b600160a060020a03808a166000908152601460209081526040808320938b16835292905220555b60408051868152602081018690528082018590529051600160a060020a03808916928a821692918c16917f4d1c39fd1a9c74f88b9f90c7b439b7e5dc6f26b6ff280fd497fdec5c538aaf529181900360600190a4505094509492505050565b600f60209081526000938452604080852082529284528284209052825290205481565b601260209081526000928352604080842090915290825290205481565b601160209081526000928352604080842090915290825290205481565b600061333b838361373a565b151561334657600080fd5b50900390565b601360209081526000928352604080842090915290825290205481565b601660209081526000948552604080862082529385528385208152918452828420909152825290205481565b601460209081526000928352604080842090915290825290205481565b600154600160a060020a031633146133fe5760405160e560020a62461bcd02815260040180806020018281038252602a8152602001806154a7602a913960400191505060405180910390fd5b600a55565b600061340f838361341f565b151561341a57600080fd5b500290565b600081158061343a5750828283850281151561343757fe5b04145b9392505050565b600654600160a060020a031681565b600c54600160a060020a031681565b60608060006135028a8a8080602002602001604051908101604052809392919081815260200183836020028082843760009201919091525050604080516020808e0282810182019093528d82529093508d92508c91829185019084908082843760009201919091525050604080516020808d0282810182019093528c82529093508c92508b91829185019084908082843760009201919091525061432e92505050565b9050606081604051908082528060200260200182016040528015613530578160200160208202803883390190505b50905060608260405190808252806020026020018201604052801561355f578160200160208202803883390190505b50905060005b83811015612964576135b98d8d8381811061357c57fe5b90506020020135600160a060020a03168c8c84818110151561359a57fe5b90506020020135600160a060020a0316898c8c8681811015156116ac57fe5b84838151811015156135c757fe5b90602001906020020184848151811015156135de57fe5b6020908102909101019190915252600101613565565b6000613600838361145f565b600160a060020a039182166000908152600e602090815260408083209390941682529190915220549392505050565b600080600061363e8787611752565b84111561364a57600080fd5b6136558787866141a1565b909250905081151561366a57600092506136df565b600160a060020a0380881660008181526017602090815260408083208b86168085529083528184208a85528352818420958b1680855295835281842054948452601883528184209084528252808320898452825280832094835293905291909120546136db908461212a8486613403565b9350505b9450945094915050565b600154600160a060020a031633146137355760405160e560020a62461bcd02815260040180806020018281038252602a8152602001806154a7602a913960400191505060405180910390fd5b600955565b111590565b600160a060020a03868116908616141561378d5760405160e560020a62461bcd0281526004018080602001828103825260308152602001806155286030913960400191505060405180910390fd5b8115156137ce5760405160e560020a62461bcd02815260040180806020018281038252603081526020018061566f6030913960400191505060405180910390fd5b80151561380f5760405160e560020a62461bcd0281526004018080602001828103825260328152602001806153756032913960400191505060405180910390fd5b6138198686611752565b1561386e576040805160e560020a62461bcd02815260206004820181905260248201527f54686520746f6b656e20706169722077617320616c7265616479206164646564604482015290519081900360640190fd5b670de0b6b3a764000082106138b75760405160e560020a62461bcd02815260040180806020018281038252603681526020018061533f6036913960400191505060405180910390fd5b670de0b6b3a764000081106139005760405160e560020a62461bcd0281526004018080602001828103825260388152602001806156376038913960400191505060405180910390fd5b61390a8686614aab565b600160a060020a0386166000908152601460209081526040808320338452909152902054613939908590612a3b565b600160a060020a038616600090815260146020908152604080832033845290915290205490945061396b908490612a3b565b92506c0c9f2c9cd04674edea4000000084106139bb5760405160e560020a62461bcd02815260040180806020018281038252602c81526020018061569f602c913960400191505060405180910390fd5b6c0c9f2c9cd04674edea400000008310613a095760405160e560020a62461bcd02815260040180806020018281038252602c8152602001806154d1602c913960400191505060405180910390fd5b600080600560009054906101000a9004600160a060020a0316600160a060020a031663a3ca17b26040518163ffffffff1660e060020a02815260040160206040518083038186803b158015613a5d57600080fd5b505afa158015613a71573d6000803e3d6000fd5b505050506040513d6020811015613a8757600080fd5b5051600854909150600160a060020a03908116908916811415613ab557613aae8783613403565b9250613aea565b80600160a060020a031688600160a060020a03161415613ad957613aae8683613403565b613ae7898989898587614ae7565b92505b600954831015613b2e5760405160e560020a62461bcd0281526004018080602001828103825260378152602001806153ea6037913960400191505060405180910390fd5b604080519081016040528086815260200185815250601060008b600160a060020a0316600160a060020a0316815260200190815260200160002060008a600160a060020a0316600160a060020a0316815260200190815260200160002060008081526020019081526020016000206000820151816000015560208201518160010155905050604080519081016040528085815260200186815250601060008a600160a060020a0316600160a060020a0316815260200190815260200160002060008b600160a060020a0316600160a060020a0316815260200190815260200160002060008081526020019081526020016000206000820151816000015560208201518160010155905050612b2a89898989614b7f565b60106020908152600093845260408085208252928452828420905282529020805460019091015482565b6000806000600b60009054906101000a9004600160a060020a0316600160a060020a03166318160ddd6040518163ffffffff1660e060020a02815260040160206040518083038186803b158015613cc457600080fd5b505afa158015613cd8573d6000803e3d6000fd5b505050506040513d6020811015613cee57600080fd5b5051600b54604080517f8b525d0c000000000000000000000000000000000000000000000000000000008152600160a060020a03888116600483015291519394506000939190921691638b525d0c916024808301926020929190829003018186803b158015613d5c57600080fd5b505afa158015613d70573d6000803e3d6000fd5b505050506040513d6020811015613d8657600080fd5b505190506127108102821180613d9a575081155b15613dac576001935060c89250613e01565b81816103e8021015613dc5576001935060fa9250613e01565b81816064021015613dde57600393506103e89250613e01565b8181600a021015613df757600193506101f49250613e01565b600193506103e892505b5050915091565b600a5481565b600160a060020a0382166000908152601460209081526040808320338452909152812054613e3c8382612a3b565b925060008311613e805760405160e560020a62461bcd0281526004018080602001828103825260218152602001806153a76021913960400191505060405180910390fd5b6000613e8c828561332f565b600160a060020a03861660009081526014602090815260408083203380855292528220839055919250613ec29187918790614355565b1515613f025760405160e560020a62461bcd0281526004018080602001828103825260228152602001806155bc6022913960400191505060405180910390fd5b604080518581529051600160a060020a038716917f6e2e05fb6a732995d6952d9158ca6b75f11cc6bf5a4af943aa1eb475a249440b919081900360200190a2949350505050565b60085460009081908190613f67908590600160a060020a0316611752565b600854909150613f86908590600160a060020a03166000198401611a9c565b909590945092505050565b600654600160a060020a03161515613fdd5760405160e560020a62461bcd0281526004018080602001828103825260278152602001806154216027913960400191505060405180910390fd5b60075442116140205760405160e560020a62461bcd0281526004018080602001828103825260408152602001806155586040913960400191505060405180910390fd5b600680546005805473ffffffffffffffffffffffffffffffffffffffff19908116600160a060020a03841617909155169055565b600154600160a060020a031633146140a05760405160e560020a62461bcd02815260040180806020018281038252602a8152602001806154a7602a913960400191505060405180910390fd5b600160a060020a03811615156140ea5760405160e560020a62461bcd02815260040180806020018281038252602b8152602001806154fd602b913960400191505060405180910390fd5b6002805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a03831617905561411f4262278d006127a7565b60035560408051600160a060020a038316815290517f36dceb79f427eda3edba9ac3c1d4db7a6e4d0b8637d97320847d93fa8e2f7a049181900360200190a150565b601560209081526000938452604080852082529284528284209052825290205481565b600d60209081526000928352604080842090915290825290205481565b6000806141ac615327565b50600160a060020a0380861660009081526010602090815260408083209388168352928152828220868352815290829020825180840190935280548352600101549082018190521561420957805160208201519093509150614325565b6142138686611752565b8411156142265760009250829150614325565b600080614237888860018903611a9c565b9092509050600061425261424b8a8a6135f4565b4203611851565b90506142648382620151800302611851565b95506142748161a8c00183613403565b600160a060020a03808b166000908152601360209081526040808320938d16835292905220549095506142a8908690613403565b600160a060020a03808b166000908152601160209081526040808320938d16835292905220546142d9908890613403565b11611c1a57600160a060020a03808a166000818152601360209081526040808320948d168084529482528083205493835260118252808320948352939052919091205490965094505050505b50935093915050565b8251825180821461433e57600080fd5b825181811461434c57600080fd5b50509392505050565b600081156143e757604080517f23b872dd000000000000000000000000000000000000000000000000000000008152336004820152306024820152604481018590529051600160a060020a038716916323b872dd91606480830192600092919082900301818387803b1580156143ca57600080fd5b505af11580156143de573d6000803e3d6000fd5b50505050614463565b84600160a060020a031663a9059cbb85856040518363ffffffff1660e060020a0281526004018083600160a060020a0316600160a060020a0316815260200182815260200192505050600060405180830381600087803b15801561444a57600080fd5b505af115801561445e573d6000803e3d6000fd5b505050505b3d801561447b57602081146144855760009150614491565b6000199150614491565b60206000803e60005191505b50949350505050565b60008060006144a833613c6e565b90925090506000816144ba8685613403565b8115156144c357fe5b0490506000811115614589576144d98882614d61565b600160a060020a03808a166000908152601560209081526040808320938c16835292815282822060018b0183529052205490915061451781836127a7565b600160a060020a03808b166000818152601560209081526040808320948e1680845294825280832060018e0184528252918290209490945580518b8152938401869052805133947f30c4d3fe752442ffa2415fd4e6398cb9e378bab963f042ce30ef4363b6ad93b692908290030190a4505b614593858261332f565b98975050505050505050565b6000806145ac8484615027565b600a5491935091508083108015918310159060009083906145ca5750815b156145d757506001614611565b82806145e05750815b156146115760006145f18888611752565b90506000614603898960018503612762565b6201517f1942011015925050505b8015614629576146248787610258615165565b612b2e565b612b2e87876151f9565b600160a060020a0380851660008181526013602090815260408083209488168084529482528083205460118352818420858552835281842054958452601083528184209484529382528083208784529091528120600101549192919061469988886135f4565b905060008511156146f0576040805180820182528581526020808201888152600160a060020a03808d16600090815260108452858120918d1681529083528481208b82529092529290209051815590516001909101555b82158061470257508062015180014210155b8061470d5750600082115b156148fa57600160a060020a038088166000908152601360209081526040808320938c1683529290522054821580156147465750600084115b15614797576040805180820182528281526020808201878152600160a060020a03808d16600090815260108452858120918f1681529083528481208c82529092529290209051815590516001909101555b600160a060020a03808a166000818152601260208181526040808420958e1680855295825280842054928252808420948452938152838320546011825284842095845294905291812082905590919082111561481657600160a060020a03808c166000908152601260209081526040808320938e168352929052908120555b600087111561484857600160a060020a03808c166000908152601360209081526040808320938e168352929052908120555b600160a060020a03808b166000908152601160209081526040808320938f1683529290529081208290558111156148a257600160a060020a03808b166000908152601260209081526040808320938f168352929052908120555b60008311156148d457600160a060020a03808b166000908152601360209081526040808320938f168352929052908120555b6148e28b8b8b878c8c615263565b6148ec8b8b614aab565b6148f68b8b61459f565b5050505b8587600160a060020a031689600160a060020a03167fb5806f8610464e96807c2b147620cc721c65309647f16cfccdf9fb7bd95152ac8888604051808381526020018281526020019250505060405180910390a45050505050505050565b600160a060020a03861660009081526004602052604081205460ff1680156149985750600160a060020a03861660009081526004602052604090205460ff165b15614aa157600854600160a060020a039081169088168114156149bd57839150614a0f565b80600160a060020a031687600160a060020a031614156149df57859150614a0f565b6000806149f08a8460018a03611a9c565b909250905080614a008784613403565b811515614a0957fe5b04935050505b6000821115614a9f57600b54604080517ff0dda65c000000000000000000000000000000000000000000000000000000008152600160a060020a038681166004830152602482018690529151919092169163f0dda65c91604480830192600092919082900301818387803b158015614a8657600080fd5b505af1158015614a9a573d6000803e3d6000fd5b505050505b505b9695505050505050565b614ab5828261145f565b600160a060020a039182166000908152600d602090815260408083209390941682529190915220805460010190555050565b600080614af48885611752565b11614afe57600080fd5b6000614b0a8785611752565b11614b1457600080fd5b600080614b2089613f49565b9092509050600080614b318a613f49565b90925090506000614b6384614b468c88613403565b811515614b4f57fe5b0483858c02811515614b5d57fe5b046127a7565b9050614b6f8188613403565b9c9b505050505050505050505050565b600160a060020a0384166000908152601460209081526040808320338452909152902054614bad908361332f565b600160a060020a0380861660009081526014602081815260408084203380865290835281852096909655938816835290815282822093825292909252902054614bf6908261332f565b600160a060020a0384166000908152601460209081526040808320338452909152812091909155614c2a858560018661449a565b90506000614c3b858760018661449a565b600160a060020a038088166000818152601160208181526040808420958c168085529582528084208990559181528183208484528152818320869055601680825282842086855282528284206001808652908352838520338087529084528486208b90559685529082528284209484529381528183209383529283528082209382529290915290812082905590915080614cd5888861145f565b600160a060020a038083166000908152600f6020908152604080832093851683529281528282208280529052204290559092509050614d178888615460615165565b86600160a060020a031688600160a060020a03167f6f4b2adffa0c3e90e47fdcd9d2c36f48b57eb3271dce519997271073dac17be960405160405180910390a35050505050505050565b6000806000614d6f85613f49565b9092509050600081614d818685613403565b811515614d8a57fe5b0490506000600560009054906101000a9004600160a060020a0316600160a060020a031663a3ca17b26040518163ffffffff1660e060020a02815260040160206040518083038186803b158015614de057600080fd5b505afa158015614df4573d6000803e3d6000fd5b505050506040513d6020811015614e0a57600080fd5b505190506000614e1a8383613403565b600c54604080517fdd62ed3e0000000000000000000000000000000000000000000000000000000081523360048201523060248201529051929350600092614ec092600160a060020a03169163dd62ed3e916044808301926020929190829003018186803b158015614e8b57600080fd5b505afa158015614e9f573d6000803e3d6000fd5b505050506040513d6020811015614eb557600080fd5b505160028404612a3b565b600c54604080517f70a082310000000000000000000000000000000000000000000000000000000081523360048201529051929350614f5d92600160a060020a03909216916370a0823191602480820192602092909190829003018186803b158015614f2b57600080fd5b505afa158015614f3f573d6000803e3d6000fd5b505050506040513d6020811015614f5557600080fd5b505182612a3b565b9050600081111561501757600c54604080517f4417f4db000000000000000000000000000000000000000000000000000000008152336004820152602481018490529051600160a060020a0390921691634417f4db9160448082019260009290919082900301818387803b158015614fd457600080fd5b505af1158015614fe8573d6000803e3d6000fd5b50505050600082614ff9838b613403565b81151561500257fe5b04905061500f898261332f565b97505061501b565b8796505b50505050505092915050565b6000806000600560009054906101000a9004600160a060020a0316600160a060020a031663a3ca17b26040518163ffffffff1660e060020a02815260040160206040518083038186803b15801561507d57600080fd5b505afa158015615091573d6000803e3d6000fd5b505050506040513d60208110156150a757600080fd5b505190506000806150b787613f49565b90925090506000806150c888613f49565b600160a060020a03808c166000908152601160209081526040808320938e168352929052205491935091508390615109906151039087613403565b87613403565b81151561511257fe5b600160a060020a03808b166000908152601160209081526040808320938f16835292905220549190049750819061514d906151039085613403565b81151561515657fe5b04955050505050509250929050565b61516f838361145f565b600160a060020a038083166000818152600d6020908152604080832094861680845294825280832054848452600e83528184208685528352928190204289019081905581518181529151979a5095985094959194859493927f20017e7b1ef8e7882103f55ff346ca3135c4afe13dff1da2f01b482aece766a5929181900390910190a45050505050565b615203828261145f565b600160a060020a038083166000908152600e6020908152604080832093851683529290522054919350915060011461525f57600160a060020a038083166000908152600e60209081526040808320938516835292905220600190555b5050565b600080615274888860018903611a9c565b9150915060006152ad61529361528a8588613403565b62015180613403565b6152a86152a08786613403565b61a8c0613403565b61332f565b905060006152cd6152be8786613403565b6152c88786613403565b6127a7565b828115156152d757fe5b0490508681016152e78b8b61145f565b600160a060020a039182166000908152600f602090815260408083209390941682529182528281209b81529a905290982097909755505050505050505050565b60408051808201909152600080825260208201529056fe596f75206d75737420736574206120736d616c6c6572206e756d657261746f7220666f722074686520696e697469616c207072696365596f75206d75737420736574207468652064656e6f6d696e61746f7220666f722074686520696e697469616c20707269636554686520616d6f756e74206d7573742062652067726561746572207468616e203054686520636f6e7472616374206d75737420626520756e696e697469616c697a6564596f752073686f756c6420737572706c757320746865207468726573686f6c6420666f7220616464696e6720746f6b656e207061697273546865206e65772070726f706f73616c206d75737420626520612076616c6964206164647265735468652061756374696f6e656572206d75737420626520612076616c69642061646472657373546865206d617374657220636f6e74726163742063616e6e6f74206265207570646174656420696e20612077616974696e6720706572696f644f6e6c79207468652061756374696f6e6565722063616e206e6f6d696e6174652061206e6577206f6e65596f752073686f756c6420757365206120736d616c6c65722066756e64696e6720666f7220746f6b656e2032546865206e6577206d617374657220636f7079206d75737420626520612076616c69642061646472657373596f752063616e6e6f7420616464206120746f6b656e2070616972207573696e67207468652073616d6520746f6b656e49742773206e6f7420706f737369626c6520746f2075706461746520746865206f7261636c6520647572696e67207468652077616974696e6720706572696f64546865206465706f736974207472616e73616374696f6e206d7573742073756363656564546865207769746864726177207472616e73666572206d757374207375636365656441756374696f6e20696e6465782073686f756c6420626520657175616c20746f206c61746573742061756374696f6e20696e6465785468652061756374696f6e6565722061646472657373206d7573742062652076616c6964596f75206d75737420736574206120736d616c6c65722064656e6f6d696e61746f7220666f722074686520696e697469616c207072696365596f75206d7573742073657420746865206e756d657261746f7220666f722074686520696e697469616c207072696365596f752073686f756c6420757365206120736d616c6c65722066756e64696e6720666f7220746f6b656e2031a165627a7a723058207c2888b04e675c63e2fcd95ada8c4645e1b6e490b95f8c3ecdcf29cc9c08faca0029"
}