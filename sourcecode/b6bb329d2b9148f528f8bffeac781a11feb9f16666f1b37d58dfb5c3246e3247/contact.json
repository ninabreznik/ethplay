{
  "address": "0x17f3af25e9a7463c35bb7f9aa3f7e633eaa5160d",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "StokrProjectManager",
  "compilerVersion": "v0.4.25+commit.59dbf8f1",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2019-04-29\n*/\n\n// File: contracts/ownership/Ownable.sol\n\npragma solidity 0.4.25;\n\n/// @title Ownable\n/// @dev Provide a simple access control with a single authority: the owner\ncontract Ownable {\n\n    // Ethereum address of current owner\n    address public owner;\n\n    // Ethereum address of the next owner\n    // (has to claim ownership first to become effective owner)\n    address public newOwner;\n\n    // @dev Log event on ownership transferred\n    // @param previousOwner Ethereum address of previous owner\n    // @param newOwner Ethereum address of new owner\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /// @dev Forbid call by anyone but owner\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Restricted to owner\");\n        _;\n    }\n\n    /// @dev Deployer account becomes initial owner\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    /// @dev  Transfer ownership to a new Ethereum account (safe method)\n    ///       Note: the new owner has to claim his ownership to become effective owner.\n    /// @param _newOwner  Ethereum address to transfer ownership to\n    function transferOwnership(address _newOwner) public onlyOwner {\n        require(_newOwner != address(0x0), \"New owner is zero\");\n\n        newOwner = _newOwner;\n    }\n\n    /// @dev  Transfer ownership to a new Ethereum account (unsafe method)\n    ///       Note: It's strongly recommended to use the safe variant via transferOwnership\n    ///             and claimOwnership, to prevent accidental transfers to a wrong address.\n    /// @param _newOwner  Ethereum address to transfer ownership to\n    function transferOwnershipUnsafe(address _newOwner) public onlyOwner {\n        require(_newOwner != address(0x0), \"New owner is zero\");\n\n        _transferOwnership(_newOwner);\n    }\n\n    /// @dev  Become effective owner (if dedicated so by previous owner)\n    function claimOwnership() public {\n        require(msg.sender == newOwner, \"Restricted to new owner\");\n\n        _transferOwnership(msg.sender);\n    }\n\n    /// @dev  Transfer ownership (internal method)\n    /// @param _newOwner  Ethereum address to transfer ownership to\n    function _transferOwnership(address _newOwner) private {\n        if (_newOwner != owner) {\n            emit OwnershipTransferred(owner, _newOwner);\n\n            owner = _newOwner;\n        }\n    }\n\n}\n\n// File: contracts/whitelist/Whitelist.sol\n\npragma solidity 0.4.25;\n\n\n\n/// @title Whitelist\n/// @author STOKR\ncontract Whitelist is Ownable {\n\n    // Set of admins\n    mapping(address => bool) public admins;\n\n    // Set of Whitelisted addresses\n    mapping(address => bool) public isWhitelisted;\n\n    /// @dev Log entry on admin added to set\n    /// @param admin An Ethereum address\n    event AdminAdded(address indexed admin);\n\n    /// @dev Log entry on admin removed from set\n    /// @param admin An Ethereum address\n    event AdminRemoved(address indexed admin);\n\n    /// @dev Log entry on investor added set\n    /// @param admin An Ethereum address\n    /// @param investor An Ethereum address\n    event InvestorAdded(address indexed admin, address indexed investor);\n\n    /// @dev Log entry on investor removed from set\n    /// @param admin An Ethereum address\n    /// @param investor An Ethereum address\n    event InvestorRemoved(address indexed admin, address indexed investor);\n\n    /// @dev Only admin\n    modifier onlyAdmin() {\n        require(admins[msg.sender], \"Restricted to whitelist admin\");\n        _;\n    }\n\n    /// @dev Add admin to set\n    /// @param _admin An Ethereum address\n    function addAdmin(address _admin) public onlyOwner {\n        require(_admin != address(0x0), \"Whitelist admin is zero\");\n\n        if (!admins[_admin]) {\n            admins[_admin] = true;\n\n            emit AdminAdded(_admin);\n        }\n    }\n\n    /// @dev Remove admin from set\n    /// @param _admin An Ethereum address\n    function removeAdmin(address _admin) public onlyOwner {\n        require(_admin != address(0x0), \"Whitelist admin is zero\");  // Necessary?\n\n        if (admins[_admin]) {\n            admins[_admin] = false;\n\n            emit AdminRemoved(_admin);\n        }\n    }\n\n    /// @dev Add investor to set of whitelisted addresses\n    /// @param _investors A list where each entry is an Ethereum address\n    function addToWhitelist(address[] _investors) external onlyAdmin {\n        for (uint256 i = 0; i < _investors.length; i++) {\n            if (!isWhitelisted[_investors[i]]) {\n                isWhitelisted[_investors[i]] = true;\n\n                emit InvestorAdded(msg.sender, _investors[i]);\n            }\n        }\n    }\n\n    /// @dev Remove investor from set of whitelisted addresses\n    /// @param _investors A list where each entry is an Ethereum address\n    function removeFromWhitelist(address[] _investors) external onlyAdmin {\n        for (uint256 i = 0; i < _investors.length; i++) {\n            if (isWhitelisted[_investors[i]]) {\n                isWhitelisted[_investors[i]] = false;\n\n                emit InvestorRemoved(msg.sender, _investors[i]);\n            }\n        }\n    }\n\n}\n\n// File: contracts/whitelist/Whitelisted.sol\n\npragma solidity 0.4.25;\n\n\n\n\n/// @title Whitelisted\n/// @author STOKR\ncontract Whitelisted is Ownable {\n\n    Whitelist public whitelist;\n\n    /// @dev  Log entry on change of whitelist contract instance\n    /// @param previous  Ethereum address of previous whitelist\n    /// @param current   Ethereum address of new whitelist\n    event WhitelistChange(address indexed previous, address indexed current);\n\n    /// @dev Ensure only whitelisted addresses can call\n    modifier onlyWhitelisted(address _address) {\n        require(whitelist.isWhitelisted(_address), \"Address is not whitelisted\");\n        _;\n    }\n\n    /// @dev Constructor\n    /// @param _whitelist address of whitelist contract\n    constructor(Whitelist _whitelist) public {\n        setWhitelist(_whitelist);\n    }\n\n    /// @dev Set the address of whitelist\n    /// @param _newWhitelist An Ethereum address\n    function setWhitelist(Whitelist _newWhitelist) public onlyOwner {\n        require(address(_newWhitelist) != address(0x0), \"Whitelist address is zero\");\n\n        if (address(_newWhitelist) != address(whitelist)) {\n            emit WhitelistChange(address(whitelist), address(_newWhitelist));\n\n            whitelist = Whitelist(_newWhitelist);\n        }\n    }\n\n}\n\n// File: contracts/token/TokenRecoverable.sol\n\npragma solidity 0.4.25;\n\n\n\n/// @title TokenRecoverable\n/// @author STOKR\ncontract TokenRecoverable is Ownable {\n\n    // Address that can do the TokenRecovery\n    address public tokenRecoverer;\n\n    /// @dev  Event emitted when the TokenRecoverer changes\n    /// @param previous  Ethereum address of previous token recoverer\n    /// @param current   Ethereum address of new token recoverer\n    event TokenRecovererChange(address indexed previous, address indexed current);\n\n    /// @dev Event emitted in case of a TokenRecovery\n    /// @param oldAddress Ethereum address of old account\n    /// @param newAddress Ethereum address of new account\n    event TokenRecovery(address indexed oldAddress, address indexed newAddress);\n\n    /// @dev Restrict operation to token recoverer\n    modifier onlyTokenRecoverer() {\n        require(msg.sender == tokenRecoverer, \"Restricted to token recoverer\");\n        _;\n    }\n\n    /// @dev Constructor\n    /// @param _tokenRecoverer Ethereum address of token recoverer\n    constructor(address _tokenRecoverer) public {\n        setTokenRecoverer(_tokenRecoverer);\n    }\n\n    /// @dev Set token recoverer\n    /// @param _newTokenRecoverer Ethereum address of new token recoverer\n    function setTokenRecoverer(address _newTokenRecoverer) public onlyOwner {\n        require(_newTokenRecoverer != address(0x0), \"New token recoverer is zero\");\n\n        if (_newTokenRecoverer != tokenRecoverer) {\n            emit TokenRecovererChange(tokenRecoverer, _newTokenRecoverer);\n\n            tokenRecoverer = _newTokenRecoverer;\n        }\n    }\n\n    /// @dev Recover token\n    /// @param _oldAddress address\n    /// @param _newAddress address\n    function recoverToken(address _oldAddress, address _newAddress) public;\n\n}\n\n// File: contracts/token/ERC20.sol\n\npragma solidity 0.4.25;\n\n\n/// @title ERC20 interface\n/// @dev see https://github.com/ethereum/EIPs/issues/20\ninterface ERC20 {\n\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n\n    function totalSupply() external view returns (uint);\n    function balanceOf(address _owner) external view returns (uint);\n    function allowance(address _owner, address _spender) external view returns (uint);\n    function approve(address _spender, uint _value) external returns (bool);\n    function transfer(address _to, uint _value) external returns (bool);\n    function transferFrom(address _from, address _to, uint _value) external returns (bool);\n\n}\n\n// File: contracts/math/SafeMath.sol\n\npragma solidity 0.4.25;\n\n\n/// @title SafeMath\n/// @dev Math operations with safety checks that throw on error\nlibrary SafeMath {\n\n    /// @dev Add two integers\n    function add(uint a, uint b) internal pure returns (uint) {\n        uint c = a + b;\n\n        assert(c >= a);\n\n        return c;\n    }\n\n    /// @dev Subtract two integers\n    function sub(uint a, uint b) internal pure returns (uint) {\n        assert(b <= a);\n\n        return a - b;\n    }\n\n    /// @dev Multiply tow integers\n    function mul(uint a, uint b) internal pure returns (uint) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint c = a * b;\n\n        assert(c / a == b);\n\n        return c;\n    }\n\n    /// @dev Floor divide two integers\n    function div(uint a, uint b) internal pure returns (uint) {\n        return a / b;\n    }\n\n}\n\n// File: contracts/token/ProfitSharing.sol\n\npragma solidity 0.4.25;\n\n\n\n\n/// @title ProfitSharing\n/// @author STOKR\ncontract ProfitSharing is Ownable {\n\n    using SafeMath for uint;\n\n\n    // An InvestorAccount object keeps track of the investor's\n    // - balance: amount of tokens he/she holds (always up-to-date)\n    // - profitShare: amount of wei this token owed him/her at the last update\n    // - lastTotalProfits: determines when his/her profitShare was updated\n    // Note, this construction requires:\n    // - totalProfits to never decrease\n    // - totalSupply to be fixed\n    // - profitShare of all involved parties to get updated prior to any token transfer\n    // - lastTotalProfits to be set to current totalProfits upon profitShare update\n    struct InvestorAccount {\n        uint balance;           // token balance\n        uint lastTotalProfits;  // totalProfits [wei] at the time of last profit share update\n        uint profitShare;       // profit share [wei] of last update\n    }\n\n\n    // Investor account database\n    mapping(address => InvestorAccount) public accounts;\n\n    // Authority who is allowed to deposit profits [wei] on this\n    address public profitDepositor;\n\n    // Authority who is allowed to distribute profit shares [wei] to investors\n    // (so, that they don't need to withdraw it by themselves)\n    address public profitDistributor;\n\n    // Amount of total profits [wei] stored to this token\n    // In contrast to the wei balance (which may be reduced due to profit share withdrawal)\n    // this value will never decrease\n    uint public totalProfits;\n\n    // As long as the total supply isn't fixed, i.e. new tokens can appear out of thin air,\n    // the investors' profit shares aren't determined\n    bool public totalSupplyIsFixed;\n\n    // Total amount of tokens\n    uint internal totalSupply_;\n\n\n    /// @dev  Log entry on change of profit deposit authority\n    /// @param previous  Ethereum address of previous profit depositor\n    /// @param current   Ethereum address of new profit depositor\n    event ProfitDepositorChange(address indexed previous, address indexed current);\n\n    /// @dev  Log entry on change of profit distribution authority\n    /// @param previous  Ethereum address of previous profit distributor\n    /// @param current   Ethereum address of new profit distributor\n    event ProfitDistributorChange(address indexed previous, address indexed current);\n\n    /// @dev Log entry on profit deposit\n    /// @param depositor Profit depositor's address\n    /// @param amount Deposited profits in wei\n    event ProfitDeposit(address indexed depositor, uint amount);\n\n    /// @dev Log entry on profit share update\n    /// @param investor Investor's address\n    /// @param amount New wei amount the token owes the investor\n    event ProfitShareUpdate(address indexed investor, uint amount);\n\n    /// @dev Log entry on profit withdrawal\n    /// @param investor Investor's address\n    /// @param amount Wei amount the investor withdrew from this token\n    event ProfitShareWithdrawal(address indexed investor, address indexed beneficiary, uint amount);\n\n\n    /// @dev Restrict operation to profit deposit authority only\n    modifier onlyProfitDepositor() {\n        require(msg.sender == profitDepositor, \"Restricted to profit depositor\");\n        _;\n    }\n\n    /// @dev Restrict operation to profit distribution authority only\n    modifier onlyProfitDistributor() {\n        require(msg.sender == profitDistributor, \"Restricted to profit distributor\");\n        _;\n    }\n\n    /// @dev Restrict operation to when total supply doesn't change anymore\n    modifier onlyWhenTotalSupplyIsFixed() {\n        require(totalSupplyIsFixed, \"Total supply may change\");\n        _;\n    }\n\n    /// @dev Constructor\n    /// @param _profitDepositor Profit deposit authority\n    constructor(address _profitDepositor, address _profitDistributor) public {\n        setProfitDepositor(_profitDepositor);\n        setProfitDistributor(_profitDistributor);\n    }\n\n    /// @dev Profit deposit if possible via fallback function\n    function () public payable {\n        require(msg.data.length == 0, \"Fallback call with data\");\n\n        depositProfit();\n    }\n\n    /// @dev Change profit depositor\n    /// @param _newProfitDepositor An Ethereum address\n    function setProfitDepositor(address _newProfitDepositor) public onlyOwner {\n        require(_newProfitDepositor != address(0x0), \"New profit depositor is zero\");\n\n        if (_newProfitDepositor != profitDepositor) {\n            emit ProfitDepositorChange(profitDepositor, _newProfitDepositor);\n\n            profitDepositor = _newProfitDepositor;\n        }\n    }\n\n    /// @dev Change profit distributor\n    /// @param _newProfitDistributor An Ethereum address\n    function setProfitDistributor(address _newProfitDistributor) public onlyOwner {\n        require(_newProfitDistributor != address(0x0), \"New profit distributor is zero\");\n\n        if (_newProfitDistributor != profitDistributor) {\n            emit ProfitDistributorChange(profitDistributor, _newProfitDistributor);\n\n            profitDistributor = _newProfitDistributor;\n        }\n    }\n\n    /// @dev Deposit profit\n    function depositProfit() public payable onlyProfitDepositor onlyWhenTotalSupplyIsFixed {\n        require(totalSupply_ > 0, \"Total supply is zero\");\n\n        totalProfits = totalProfits.add(msg.value);\n\n        emit ProfitDeposit(msg.sender, msg.value);\n    }\n\n    /// @dev Profit share owing\n    /// @param _investor An Ethereum address\n    /// @return A positive number\n    function profitShareOwing(address _investor) public view returns (uint) {\n        if (!totalSupplyIsFixed || totalSupply_ == 0) {\n            return 0;\n        }\n\n        InvestorAccount memory account = accounts[_investor];\n\n        return totalProfits.sub(account.lastTotalProfits)\n                           .mul(account.balance)\n                           .div(totalSupply_)\n                           .add(account.profitShare);\n    }\n\n    /// @dev Update profit share\n    /// @param _investor An Ethereum address\n    function updateProfitShare(address _investor) public onlyWhenTotalSupplyIsFixed {\n        uint newProfitShare = profitShareOwing(_investor);\n\n        accounts[_investor].lastTotalProfits = totalProfits;\n        accounts[_investor].profitShare = newProfitShare;\n\n        emit ProfitShareUpdate(_investor, newProfitShare);\n    }\n\n    /// @dev Withdraw profit share\n    function withdrawProfitShare() public {\n        _withdrawProfitShare(msg.sender, msg.sender);\n    }\n\n    function withdrawProfitShareTo(address _beneficiary) public {\n        _withdrawProfitShare(msg.sender, _beneficiary);\n    }\n\n    /// @dev Withdraw profit share\n    function withdrawProfitShares(address[] _investors) external onlyProfitDistributor {\n        for (uint i = 0; i < _investors.length; ++i) {\n            _withdrawProfitShare(_investors[i], _investors[i]);\n        }\n    }\n\n    /// @dev Withdraw profit share\n    function _withdrawProfitShare(address _investor, address _beneficiary) internal {\n        updateProfitShare(_investor);\n\n        uint withdrawnProfitShare = accounts[_investor].profitShare;\n\n        accounts[_investor].profitShare = 0;\n        _beneficiary.transfer(withdrawnProfitShare);\n\n        emit ProfitShareWithdrawal(_investor, _beneficiary, withdrawnProfitShare);\n    }\n\n}\n\n// File: contracts/token/MintableToken.sol\n\npragma solidity 0.4.25;\n\n\n\n\n\n/// @title MintableToken\n/// @author STOKR\n/// @dev Extension of the ERC20 compliant ProfitSharing Token\n///      that allows the creation of tokens via minting for a\n///      limited time period (until minting gets finished).\ncontract MintableToken is ERC20, ProfitSharing, Whitelisted {\n\n    address public minter;\n    uint public numberOfInvestors = 0;\n\n    /// @dev Log entry on mint\n    /// @param to Beneficiary who received the newly minted tokens\n    /// @param amount The amount of minted token units\n    event Minted(address indexed to, uint amount);\n\n    /// @dev Log entry on mint finished\n    event MintFinished();\n\n    /// @dev Restrict an operation to be callable only by the minter\n    modifier onlyMinter() {\n        require(msg.sender == minter, \"Restricted to minter\");\n        _;\n    }\n\n    /// @dev Restrict an operation to be executable only while minting was not finished\n    modifier canMint() {\n        require(!totalSupplyIsFixed, \"Total supply has been fixed\");\n        _;\n    }\n\n    /// @dev Set minter authority\n    /// @param _minter Ethereum address of minter authority\n    function setMinter(address _minter) public onlyOwner {\n        require(minter == address(0x0), \"Minter has already been set\");\n        require(_minter != address(0x0), \"Minter is zero\");\n\n        minter = _minter;\n    }\n\n    /// @dev Mint tokens, i.e. create tokens out of thin air\n    /// @param _to Beneficiary who will receive the newly minted tokens\n    /// @param _amount The amount of minted token units\n    function mint(address _to, uint _amount) public onlyMinter canMint onlyWhitelisted(_to) {\n        if (accounts[_to].balance == 0) {\n            numberOfInvestors++;\n        }\n\n        totalSupply_ = totalSupply_.add(_amount);\n        accounts[_to].balance = accounts[_to].balance.add(_amount);\n\n        emit Minted(_to, _amount);\n        emit Transfer(address(0x0), _to, _amount);\n    }\n\n    /// @dev Finish minting -- this should be irreversible\n    function finishMinting() public onlyMinter canMint {\n        totalSupplyIsFixed = true;\n\n        emit MintFinished();\n    }\n\n}\n\n// File: contracts/token/StokrToken.sol\n\npragma solidity 0.4.25;\n\n\n\n\n\n/// @title StokrToken\n/// @author Stokr\ncontract StokrToken is MintableToken, TokenRecoverable {\n\n    string public name;\n    string public symbol;\n    uint8 public constant decimals = 18;\n\n    mapping(address => mapping(address => uint)) internal allowance_;\n\n    /// @dev Log entry on self destruction of the token\n    event TokenDestroyed();\n\n    /// @dev Constructor\n    /// @param _whitelist       Ethereum address of whitelist contract\n    /// @param _tokenRecoverer  Ethereum address of token recoverer\n    constructor(\n        string _name,\n        string _symbol,\n        Whitelist _whitelist,\n        address _profitDepositor,\n        address _profitDistributor,\n        address _tokenRecoverer\n    )\n        public\n        Whitelisted(_whitelist)\n        ProfitSharing(_profitDepositor, _profitDistributor)\n        TokenRecoverable(_tokenRecoverer)\n    {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /// @dev  Self destruct can only be called by crowdsale contract in case the goal wasn't reached\n    function destruct() public onlyMinter {\n        emit TokenDestroyed();\n        selfdestruct(owner);\n    }\n\n    /// @dev Recover token\n    /// @param _oldAddress  address of old account\n    /// @param _newAddress  address of new account\n    function recoverToken(address _oldAddress, address _newAddress)\n        public\n        onlyTokenRecoverer\n        onlyWhitelisted(_newAddress)\n    {\n        // Ensure that new address is *not* an existing account.\n        // Check for account.profitShare is not needed because of following implication:\n        //   (account.lastTotalProfits == 0) ==> (account.profitShare == 0)\n        require(accounts[_newAddress].balance == 0 && accounts[_newAddress].lastTotalProfits == 0,\n                \"New address exists already\");\n\n        updateProfitShare(_oldAddress);\n\n        accounts[_newAddress] = accounts[_oldAddress];\n        delete accounts[_oldAddress];\n\n        emit TokenRecovery(_oldAddress, _newAddress);\n        emit Transfer(_oldAddress, _newAddress, accounts[_newAddress].balance);\n    }\n\n    /// @dev  Total supply of this token\n    /// @return  Token amount\n    function totalSupply() public view returns (uint) {\n        return totalSupply_;\n    }\n\n    /// @dev  Token balance\n    /// @param _investor  Ethereum address of token holder\n    /// @return           Token amount\n    function balanceOf(address _investor) public view returns (uint) {\n        return accounts[_investor].balance;\n    }\n\n    /// @dev  Allowed token amount a third party trustee may transfer\n    /// @param _investor  Ethereum address of token holder\n    /// @param _spender   Ethereum address of third party\n    /// @return           Allowed token amount\n    function allowance(address _investor, address _spender) public view returns (uint) {\n        return allowance_[_investor][_spender];\n    }\n\n    /// @dev  Approve a third party trustee to transfer tokens\n    ///       Note: additional requirements are enforced within internal function.\n    /// @param _spender  Ethereum address of third party\n    /// @param _value    Maximum token amount that is allowed to get transferred\n    /// @return          Always true\n    function approve(address _spender, uint _value) public returns (bool) {\n        return _approve(msg.sender, _spender, _value);\n    }\n\n    /// @dev  Increase the amount of tokens a third party trustee may transfer\n    ///       Note: additional requirements are enforces within internal function.\n    /// @param _spender  Ethereum address of third party\n    /// @param _amount   Additional token amount that is allowed to get transferred\n    /// @return          Always true\n    function increaseAllowance(address _spender, uint _amount) public returns (bool) {\n        require(allowance_[msg.sender][_spender] + _amount >= _amount, \"Allowance overflow\");\n\n        return _approve(msg.sender, _spender, allowance_[msg.sender][_spender].add(_amount));\n    }\n\n    /// @dev  Decrease the amount of tokens a third party trustee may transfer\n    ///       Note: additional requirements are enforces within internal function.\n    /// @param _spender  Ethereum address of third party\n    /// @param _amount   Reduced token amount that is allowed to get transferred\n    /// @return          Always true\n    function decreaseAllowance(address _spender, uint _amount) public returns (bool) {\n        require(_amount <= allowance_[msg.sender][_spender], \"Amount exceeds allowance\");\n\n        return _approve(msg.sender, _spender, allowance_[msg.sender][_spender].sub(_amount));\n    }\n\n    /// @dev  Check if a token transfer is possible\n    /// @param _from   Ethereum address of token sender\n    /// @param _to     Ethereum address of token recipient\n    /// @param _value  Token amount to transfer\n    /// @return        True iff a transfer with given pramaters would succeed\n    function canTransfer(address _from, address _to, uint _value)\n        public view returns (bool)\n    {\n        return totalSupplyIsFixed\n            && _from != address(0x0)\n            && _to != address(0x0)\n            && _value <= accounts[_from].balance\n            && whitelist.isWhitelisted(_from)\n            && whitelist.isWhitelisted(_to);\n    }\n\n    /// @dev  Check if a token transfer by third party is possible\n    /// @param _spender  Ethereum address of third party trustee\n    /// @param _from     Ethereum address of token holder\n    /// @param _to       Ethereum address of token recipient\n    /// @param _value    Token amount to transfer\n    /// @return          True iff a transfer with given pramaters would succeed\n    function canTransferFrom(address _spender, address _from, address _to, uint _value)\n        public view returns (bool)\n    {\n        return canTransfer(_from, _to, _value) && _value <= allowance_[_from][_spender];\n    }\n\n    /// @dev  Token transfer\n    ///       Note: additional requirements are enforces within internal function.\n    /// @param _to     Ethereum address of token recipient\n    /// @param _value  Token amount to transfer\n    /// @return        Always true\n    function transfer(address _to, uint _value) public returns (bool) {\n        return _transfer(msg.sender, _to, _value);\n    }\n\n    /// @dev  Token transfer by a third party\n    ///       Note: additional requirements are enforces within internal function.\n    /// @param _from   Ethereum address of token holder\n    /// @param _to     Ethereum address of token recipient\n    /// @param _value  Token amount to transfer\n    /// @return        Always true\n    function transferFrom(address _from, address _to, uint _value) public returns (bool) {\n        require(_value <= allowance_[_from][msg.sender], \"Amount exceeds allowance\");\n\n        return _approve(_from, msg.sender, allowance_[_from][msg.sender].sub(_value))\n            && _transfer(_from, _to, _value);\n    }\n\n    /// @dev  Approve a third party trustee to transfer tokens (internal implementation)\n    /// @param _from     Ethereum address of token holder\n    /// @param _spender  Ethereum address of third party\n    /// @param _value    Maximum token amount the trustee is allowed to transfer\n    /// @return          Always true\n    function _approve(address _from, address _spender, uint _value)\n        internal\n        onlyWhitelisted(_from)\n        onlyWhenTotalSupplyIsFixed\n        returns (bool)\n    {\n        allowance_[_from][_spender] = _value;\n\n        emit Approval(_from, _spender, _value);\n\n        return true;\n    }\n\n    /// @dev  Token transfer (internal implementation)\n    /// @param _from   Ethereum address of token sender\n    /// @param _to     Ethereum address of token recipient\n    /// @param _value  Token amount to transfer\n    /// @return        Always true\n    function _transfer(address _from, address _to, uint _value)\n        internal\n        onlyWhitelisted(_from)\n        onlyWhitelisted(_to)\n        onlyWhenTotalSupplyIsFixed\n        returns (bool)\n    {\n        require(_to != address(0x0), \"Recipient is zero\");\n        require(_value <= accounts[_from].balance, \"Amount exceeds balance\");\n\n        updateProfitShare(_from);\n        updateProfitShare(_to);\n\n        accounts[_from].balance = accounts[_from].balance.sub(_value);\n        accounts[_to].balance = accounts[_to].balance.add(_value);\n\n        emit Transfer(_from, _to, _value);\n\n        return true;\n    }\n\n}\n\n// File: contracts/token/StokrTokenFactory.sol\n\npragma solidity 0.4.25;\n\n\n\n// Helper contract to deploy a new StokrToken contract\n\ncontract StokrTokenFactory {\n\n    function createNewToken(\n        string name,\n        string symbol,\n        Whitelist whitelist,\n        address profitDepositor,\n        address profitDistributor,\n        address tokenRecoverer\n    )\n        public\n        returns (StokrToken)\n    {\n        StokrToken token = new StokrToken(\n            name,\n            symbol,\n            whitelist,\n            profitDepositor,\n            profitDistributor,\n            tokenRecoverer);\n\n        token.transferOwnershipUnsafe(msg.sender);\n\n        return token;\n    }\n\n}\n\n// File: contracts/crowdsale/RateSourceInterface.sol\n\npragma solidity 0.4.25;\n\n\n/// @title RateSource\n/// @author STOKR\ninterface RateSource {\n\n    /// @dev The current price of an Ether in EUR cents\n    /// @return Current ether rate\n    function etherRate() external returns(uint);\n\n}\n\n// File: contracts/crowdsale/MintingCrowdsale.sol\n\npragma solidity 0.4.25;\n\n\n\n\n\n\n/// @title MintingCrowdsale\n/// @author STOKR\ncontract MintingCrowdsale is Ownable {\n    using SafeMath for uint;\n\n    // Maximum Time of offering period after extension\n    uint constant MAXOFFERINGPERIOD = 80 days;\n\n    // Ether rate oracle contract providing the price of an Ether in EUR cents\n    RateSource public rateSource;\n\n    // The token to be sold\n    // In the following, the term \"token unit\" always refers to the smallest\n    // and non-divisible quantum. Thus, token unit amounts are always integers.\n    // One token is expected to consist of 10^18 token units.\n    MintableToken public token;\n\n    // Token amounts in token units\n    // The public and the private sale are both capped (i.e. two distinct token pools)\n    // The tokenRemaining variables keep track of how many token units are available\n    // for the respective type of sale\n    uint public tokenCapOfPublicSale;\n    uint public tokenCapOfPrivateSale;\n    uint public tokenRemainingForPublicSale;\n    uint public tokenRemainingForPrivateSale;\n\n    // Prices are in Euro cents (i.e. 1/100 EUR)\n    uint public tokenPrice;\n\n    // The minimum amount of tokens a purchaser has to buy via one transaction\n    uint public tokenPurchaseMinimum;\n\n    // The maximum total amount of tokens a purchaser may buy during start phase\n    uint public tokenPurchaseLimit;\n\n    // Total token purchased by investor (while purchase amount is limited)\n    mapping(address => uint) public tokenPurchased;\n\n    // Public sale period\n    uint public openingTime;\n    uint public closingTime;\n    uint public limitEndTime;\n\n    // Ethereum address where invested funds will be transferred to\n    address public companyWallet;\n\n    // Amount and receiver of reserved tokens\n    uint public tokenReservePerMill;\n    address public reserveAccount;\n\n    // Wether this crowdsale was finalized or not\n    bool public isFinalized = false;\n\n\n    /// @dev Log entry upon token distribution event\n    /// @param beneficiary Ethereum address of token recipient\n    /// @param amount Number of token units\n    /// @param isPublicSale Whether the distribution was via public sale\n    event TokenDistribution(address indexed beneficiary, uint amount, bool isPublicSale);\n\n    /// @dev Log entry upon token purchase event\n    /// @param buyer Ethereum address of token purchaser\n    /// @param value Worth in wei of purchased token amount\n    /// @param amount Number of token units\n    event TokenPurchase(address indexed buyer, uint value, uint amount);\n\n    /// @dev Log entry upon rate change event\n    /// @param previous Previous closing time of sale\n    /// @param current Current closing time of sale\n    event ClosingTimeChange(uint previous, uint current);\n\n    /// @dev Log entry upon finalization event\n    event Finalization();\n\n\n    /// @dev Constructor\n    /// @param _rateSource Ether rate oracle contract\n    /// @param _token The token to be sold\n    /// @param _tokenCapOfPublicSale Maximum number of token units to mint in public sale\n    /// @param _tokenCapOfPrivateSale Maximum number of token units to mint in private sale\n    /// @param _tokenPurchaseMinimum Minimum amount of tokens an investor has to buy at once\n    /// @param _tokenPurchaseLimit Maximum total token amounts individually buyable in limit phase\n    /// @param _tokenPrice Price of a token in EUR cent\n    /// @param _openingTime Block (Unix) timestamp of sale opening time\n    /// @param _closingTime Block (Unix) timestamp of sale closing time\n    /// @param _limitEndTime Block (Unix) timestamp until token purchases are limited\n    /// @param _companyWallet Ethereum account who will receive sent ether\n    /// @param _tokenReservePerMill Per mill amount of sold tokens to mint for reserve account\n    /// @param _reserveAccount Ethereum address of reserve tokens recipient\n    constructor(\n        RateSource _rateSource,\n        MintableToken _token,\n        uint _tokenCapOfPublicSale,\n        uint _tokenCapOfPrivateSale,\n        uint _tokenPurchaseMinimum,\n        uint _tokenPurchaseLimit,\n        uint _tokenReservePerMill,\n        uint _tokenPrice,\n        uint _openingTime,\n        uint _closingTime,\n        uint _limitEndTime,\n        address _companyWallet,\n        address _reserveAccount\n    )\n        public\n    {\n        require(address(_rateSource) != address(0x0), \"Rate source is zero\");\n        require(address(_token) != address(0x0), \"Token address is zero\");\n        require(_token.minter() == address(0x0), \"Token has another minter\");\n        require(_tokenCapOfPublicSale > 0, \"Cap of public sale is zero\");\n        require(_tokenCapOfPrivateSale > 0, \"Cap of private sale is zero\");\n        require(_tokenPurchaseMinimum <= _tokenCapOfPublicSale\n                && _tokenPurchaseMinimum <= _tokenCapOfPrivateSale,\n                \"Purchase minimum exceeds cap\");\n        require(_tokenPrice > 0, \"Token price is zero\");\n        require(_openingTime >= now, \"Opening lies in the past\");\n        require(_closingTime >= _openingTime, \"Closing lies before opening\");\n        require(_companyWallet != address(0x0), \"Company wallet is zero\");\n        require(_reserveAccount != address(0x0), \"Reserve account is zero\");\n\n\n        // Note: There are no time related requirements regarding limitEndTime.\n        //       If it's below openingTime, token purchases will never be limited.\n        //       If it's above closingTime, token purchases will always be limited.\n        if (_limitEndTime > _openingTime) {\n            // But, if there's a purchase limitation phase, the limit must be at\n            // least the purchase minimum or above to make purchases possible.\n            require(_tokenPurchaseLimit >= _tokenPurchaseMinimum,\n                    \"Purchase limit is below minimum\");\n        }\n\n        // Utilize safe math to ensure the sum of three token pools does't overflow\n        _tokenCapOfPublicSale.add(_tokenCapOfPrivateSale).mul(_tokenReservePerMill);\n\n        rateSource = _rateSource;\n        token = _token;\n        tokenCapOfPublicSale = _tokenCapOfPublicSale;\n        tokenCapOfPrivateSale = _tokenCapOfPrivateSale;\n        tokenPurchaseMinimum = _tokenPurchaseMinimum;\n        tokenPurchaseLimit= _tokenPurchaseLimit;\n        tokenReservePerMill = _tokenReservePerMill;\n        tokenPrice = _tokenPrice;\n        openingTime = _openingTime;\n        closingTime = _closingTime;\n        limitEndTime = _limitEndTime;\n        companyWallet = _companyWallet;\n        reserveAccount = _reserveAccount;\n\n        tokenRemainingForPublicSale = _tokenCapOfPublicSale;\n        tokenRemainingForPrivateSale = _tokenCapOfPrivateSale;\n    }\n\n\n\n    /// @dev Fallback function: buys tokens\n    function () public payable {\n        require(msg.data.length == 0, \"Fallback call with data\");\n\n        buyTokens();\n    }\n\n    /// @dev Distribute tokens purchased off-chain via public sale\n    ///      Note: additional requirements are enforced in internal function.\n    /// @param beneficiaries List of recipients' Ethereum addresses\n    /// @param amounts List of token units each recipient will receive\n    function distributeTokensViaPublicSale(address[] beneficiaries, uint[] amounts) external {\n        tokenRemainingForPublicSale =\n            distributeTokens(tokenRemainingForPublicSale, beneficiaries, amounts, true);\n    }\n\n    /// @dev Distribute tokens purchased off-chain via private sale\n    ///      Note: additional requirements are enforced in internal function.\n    /// @param beneficiaries List of recipients' Ethereum addresses\n    /// @param amounts List of token units each recipient will receive\n    function distributeTokensViaPrivateSale(address[] beneficiaries, uint[] amounts) external {\n        tokenRemainingForPrivateSale =\n            distributeTokens(tokenRemainingForPrivateSale, beneficiaries, amounts, false);\n    }\n\n    /// @dev Check whether the sale has closed\n    /// @return True iff sale closing time has passed\n    function hasClosed() public view returns (bool) {\n        return now >= closingTime;\n    }\n\n    /// @dev Check wether the sale is open\n    /// @return True iff sale opening time has passed and sale is not closed yet\n    function isOpen() public view returns (bool) {\n        return now >= openingTime && !hasClosed();\n    }\n\n    /// @dev Determine the remaining open time of sale\n    /// @return Time in seconds until sale gets closed, or 0 if sale was closed\n    function timeRemaining() public view returns (uint) {\n        if (hasClosed()) {\n            return 0;\n        }\n\n        return closingTime - now;\n    }\n\n    /// @dev Determine the amount of sold tokens (off-chain and on-chain)\n    /// @return Token units amount\n    function tokenSold() public view returns (uint) {\n        return (tokenCapOfPublicSale - tokenRemainingForPublicSale)\n             + (tokenCapOfPrivateSale - tokenRemainingForPrivateSale);\n    }\n\n    /// @dev Purchase tokens\n    function buyTokens() public payable {\n        require(isOpen(), \"Sale is not open\");\n\n        uint etherRate = rateSource.etherRate();\n\n        require(etherRate > 0, \"Ether rate is zero\");\n\n        // Units:  [1e-18*ether] * [cent/ether] / [cent/token] => [1e-18*token]\n        uint amount = msg.value.mul(etherRate).div(tokenPrice);\n\n        require(amount <= tokenRemainingForPublicSale, \"Not enough tokens available\");\n        require(amount >= tokenPurchaseMinimum, \"Investment is too low\");\n\n        // Is the total amount an investor can purchase with Ether limited?\n        if (now < limitEndTime) {\n            uint purchased = tokenPurchased[msg.sender].add(amount);\n\n            require(purchased <= tokenPurchaseLimit, \"Purchase limit reached\");\n\n            tokenPurchased[msg.sender] = purchased;\n        }\n\n        tokenRemainingForPublicSale = tokenRemainingForPublicSale.sub(amount);\n\n        token.mint(msg.sender, amount);\n        forwardFunds();\n\n        emit TokenPurchase(msg.sender, msg.value, amount);\n    }\n\n    /// @dev Extend the offering period of the crowd sale.\n    /// @param _newClosingTime new closingTime of the crowdsale\n    function changeClosingTime(uint _newClosingTime) public onlyOwner {\n        require(!hasClosed(), \"Sale has already ended\");\n        require(_newClosingTime > now, \"ClosingTime not in the future\");\n        require(_newClosingTime > openingTime, \"New offering is zero\");\n        require(_newClosingTime - openingTime <= MAXOFFERINGPERIOD, \"New offering too long\");\n\n        emit ClosingTimeChange(closingTime, _newClosingTime);\n\n        closingTime = _newClosingTime;\n    }\n\n    /// @dev Finalize, i.e. end token minting phase and enable token transfers\n    function finalize() public onlyOwner {\n        require(!isFinalized, \"Sale has already been finalized\");\n        require(hasClosed(), \"Sale has not closed\");\n\n        if (tokenReservePerMill > 0) {\n            token.mint(reserveAccount, tokenSold().mul(tokenReservePerMill).div(1000));\n        }\n        token.finishMinting();\n        isFinalized = true;\n\n        emit Finalization();\n    }\n\n    /// @dev Distribute tokens purchased off-chain (in Euro) to investors\n    /// @param tokenRemaining Token units available for sale\n    /// @param beneficiaries Ethereum addresses of purchasers\n    /// @param amounts Token unit amounts to deliver to each investor\n    /// @return Token units available for sale after distribution\n    function distributeTokens(uint tokenRemaining, address[] beneficiaries, uint[] amounts, bool isPublicSale)\n        internal\n        onlyOwner\n        returns (uint)\n    {\n        require(!isFinalized, \"Sale has been finalized\");\n        require(beneficiaries.length == amounts.length, \"Lengths are different\");\n\n        for (uint i = 0; i < beneficiaries.length; ++i) {\n            address beneficiary = beneficiaries[i];\n            uint amount = amounts[i];\n\n            require(amount <= tokenRemaining, \"Not enough tokens available\");\n\n            tokenRemaining = tokenRemaining.sub(amount);\n            token.mint(beneficiary, amount);\n\n            emit TokenDistribution(beneficiary, amount, isPublicSale);\n        }\n\n        return tokenRemaining;\n    }\n\n    /// @dev Forward invested ether to company wallet\n    function forwardFunds() internal {\n        companyWallet.transfer(address(this).balance);\n    }\n\n}\n\n// File: contracts/crowdsale/StokrCrowdsale.sol\n\npragma solidity 0.4.25;\n\n\n\n\n/// @title StokrCrowdsale\n/// @author STOKR\ncontract StokrCrowdsale is MintingCrowdsale {\n\n    // Soft cap in token units\n    uint public tokenGoal;\n\n    // As long as the goal is not reached funds of purchases are held back\n    // and investments are assigned to investors here to enable a refunding\n    // if the goal is missed upon finalization\n    mapping(address => uint) public investments;\n\n\n    // Log entry upon investor refund event\n    event InvestorRefund(address indexed investor, uint value);\n\n\n    /// @dev Constructor\n    /// @param _token The token\n    /// @param _tokenCapOfPublicSale Available token units for public sale\n    /// @param _tokenCapOfPrivateSale Available token units for private sale\n    /// @param _tokenGoal Minimum number of sold token units to be successful\n    /// @param _tokenPurchaseMinimum Minimum amount of tokens an investor has to buy at once\n    /// @param _tokenPurchaseLimit Maximum total token amounts individually buyable in limit phase\n    /// @param _tokenReservePerMill Additional reserve tokens in per mill of sold tokens\n    /// @param _tokenPrice Price of a token in EUR cent\n    /// @param _rateSource Ethereum address of ether rate setting authority\n    /// @param _openingTime Block (Unix) timestamp of sale opening time\n    /// @param _closingTime Block (Unix) timestamp of sale closing time\n    /// @param _limitEndTime Block (Unix) timestamp until token purchases are limited\n    /// @param _companyWallet Ethereum account who will receive sent ether\n    /// @param _reserveAccount An address\n    constructor(\n        RateSource _rateSource,\n        StokrToken _token,\n        uint _tokenCapOfPublicSale,\n        uint _tokenCapOfPrivateSale,\n        uint _tokenGoal,\n        uint _tokenPurchaseMinimum,\n        uint _tokenPurchaseLimit,\n        uint _tokenReservePerMill,\n        uint _tokenPrice,\n        uint _openingTime,\n        uint _closingTime,\n        uint _limitEndTime,\n        address _companyWallet,\n        address _reserveAccount\n    )\n        public\n        MintingCrowdsale(\n            _rateSource,\n            _token,\n            _tokenCapOfPublicSale,\n            _tokenCapOfPrivateSale,\n            _tokenPurchaseMinimum,\n            _tokenPurchaseLimit,\n            _tokenReservePerMill,\n            _tokenPrice,\n            _openingTime,\n            _closingTime,\n            _limitEndTime,\n            _companyWallet,\n            _reserveAccount\n        )\n    {\n        require(_tokenGoal <= _tokenCapOfPublicSale + _tokenCapOfPrivateSale, \"Goal is not attainable\");\n\n        tokenGoal = _tokenGoal;\n    }\n\n    /// @dev Wether the goal of sold tokens was reached or not\n    /// @return True if the sale can be considered successful\n    function goalReached() public view returns (bool) {\n        return tokenSold() >= tokenGoal;\n    }\n\n    /// @dev Investors can claim refunds here if crowdsale was unsuccessful\n    function distributeRefunds(address[] _investors) external {\n        for (uint i = 0; i < _investors.length; ++i) {\n            refundInvestor(_investors[i]);\n        }\n    }\n\n    /// @dev Investors can claim refunds here if crowdsale was unsuccessful\n    function claimRefund() public {\n        refundInvestor(msg.sender);\n    }\n\n    /// @dev Overwritten. Kill the token if goal was missed\n    function finalize() public onlyOwner {\n        super.finalize();\n\n        if (!goalReached()) {\n            StokrToken(token).destruct();\n        }\n    }\n\n    /// @dev Overwritten. Funds are held back until goal was reached\n    function forwardFunds() internal {\n        if (goalReached()) {\n            super.forwardFunds();\n        }\n        else {\n            investments[msg.sender] = investments[msg.sender].add(msg.value);\n        }\n    }\n\n    /// @dev Refund an investor if the sale was not successful\n    /// @param _investor Ethereum address of investor\n    function refundInvestor(address _investor) internal {\n        require(isFinalized, \"Sale has not been finalized\");\n        require(!goalReached(), \"Goal was reached\");\n\n        uint investment = investments[_investor];\n\n        if (investment > 0) {\n            investments[_investor] = 0;\n            _investor.transfer(investment);\n\n            emit InvestorRefund(_investor, investment);\n        }\n    }\n\n}\n\n// File: contracts/crowdsale/StokrCrowdsaleFactory.sol\n\npragma solidity 0.4.25;\n\n\n\n\n// Helper contract to deploy a new StokrCrowdsale contract\n\ncontract StokrCrowdsaleFactory {\n\n    function createNewCrowdsale(\n        StokrToken token,\n        uint tokenPrice,\n        uint[6] amounts,  // [tokenCapOfPublicSale, tokenCapOfPrivateSale, tokenGoal,\n                          //  tokenPurchaseMinimum, tokenPurchaseLimit, tokenReservePerMill]\n        uint[3] period,   // [openingTime, closingTime, limitEndTime]\n        address[2] wallets  // [companyWallet, reserveAccount]\n    )\n        external\n        returns (StokrCrowdsale)\n    {\n        StokrCrowdsale crowdsale = new StokrCrowdsale(\n            RateSource(msg.sender),  // rateSource\n            token,\n            amounts[0],   // tokenCapOfPublicSale\n            amounts[1],   // tokenCapOfPrivateSale\n            amounts[2],   // tokenGoal\n            amounts[3],   // tokenPurchaseMinimum\n            amounts[4],   // tokenPurchaseLimit\n            amounts[5],   // tokenReservePerMill\n            tokenPrice,   // tokenPrice\n            period[0],    // openingTime\n            period[1],    // closingTime\n            period[2],    // limitEndTime\n            wallets[0],   // companyWallet\n            wallets[1]);  // reserveAccount\n\n        crowdsale.transferOwnershipUnsafe(msg.sender);\n\n        return crowdsale;\n    }\n\n}\n\n// File: contracts/StokrProjectManager.sol\n\npragma solidity 0.4.25;\n\n\n\n\n\n\n\n\n\ncontract StokrProjectManager is Ownable, RateSource {\n\n    // Project structure\n    struct StokrProject {\n        string name;\n        Whitelist whitelist;\n        StokrToken token;\n        StokrCrowdsale crowdsale;\n    }\n\n    // Rate must be below this limit: floor(2**256 / 10)\n    uint public constant RATE_LIMIT = uint(-1) / 10;\n\n    // Block number where this contract instance was deployed\n    uint public deploymentBlockNumber;\n\n    // Ethereum address of the Ether prize setting authority\n    address public rateAdmin;\n\n    // Current price of an Ether in EUR cents\n    uint private rate;\n\n    // Current whitelist and token factory and crowdsale factory instances\n    Whitelist public currentWhitelist;\n    StokrTokenFactory public tokenFactory;\n    StokrCrowdsaleFactory public crowdsaleFactory;\n\n    // List of projects\n    StokrProject[] public projects;\n\n\n    /// @dev Log entry upon rate change event\n    /// @param previous Previous rate in EUR cent per Ether\n    /// @param current Current rate in EUR cent per Ether\n    event RateChange(uint previous, uint current);\n\n    /// @dev Log entry upon rate admin change event\n    /// @param previous Ethereum address of previous rate admin\n    /// @param current Ethereum address of current rate admin\n    event RateAdminChange(address indexed previous, address indexed current);\n\n    /// @dev Log entry upon project creation event\n    /// @param whitelist  Ethereum address of Whitelist contract\n    /// @param token  Ethereum address of StokrToken contract\n    /// @param crowdsale  Ethereum address of StokrCrowdsale contract\n    /// @param index  Index of the project within projects list\n    event ProjectCreation(\n        uint indexed index,\n        address whitelist,\n        address indexed token,\n        address indexed crowdsale\n    );\n\n\n    /// @dev Restrict operation to rate admin role\n    modifier onlyRateAdmin() {\n        require(msg.sender == rateAdmin, \"Restricted to rate admin\");\n        _;\n    }\n\n\n    /// @dev Constructor\n    /// @param etherRate Initial price of an Ether in EUR cents\n    constructor(uint etherRate) public {\n        require(etherRate > 0, \"Ether rate is zero\");\n        require(etherRate < RATE_LIMIT, \"Ether rate reaches limit\");\n\n        deploymentBlockNumber = block.number;\n        rate = etherRate;\n    }\n\n\n    /// @dev Set the current whitelist contract instance\n    /// @param newWhitelist Whitelist instance\n    function setWhitelist(Whitelist newWhitelist) public onlyOwner {\n        require(address(newWhitelist) != address(0x0), \"Whitelist is zero\");\n\n        currentWhitelist = newWhitelist;\n    }\n\n    /// @dev Set the current token factory contract instance\n    /// @param newTokenFactory StokrTokenFactory instance\n    function setTokenFactory(StokrTokenFactory newTokenFactory) public onlyOwner {\n        require(address(newTokenFactory) != address(0x0), \"Token factory is zero\");\n\n        tokenFactory = newTokenFactory;\n    }\n\n    /// @dev Set the current crowdsale factory contract instance\n    /// @param newCrowdsaleFactory StokrCrowdsaleFactory instance\n    function setCrowdsaleFactory(StokrCrowdsaleFactory newCrowdsaleFactory) public onlyOwner {\n        require(address(newCrowdsaleFactory) != address(0x0), \"Crowdsale factory is zero\");\n\n        crowdsaleFactory = newCrowdsaleFactory;\n    }\n\n    /// @dev Set rate admin, i.e. the ether rate setting authority\n    /// @param newRateAdmin Ethereum address of rate admin\n    function setRateAdmin(address newRateAdmin) public onlyOwner {\n        require(newRateAdmin != address(0x0), \"New rate admin is zero\");\n\n        if (newRateAdmin != rateAdmin) {\n            emit RateAdminChange(rateAdmin, newRateAdmin);\n\n            rateAdmin = newRateAdmin;\n        }\n    }\n\n    /// @dev Set rate, i.e. adjust to changes of EUR/ether exchange rate\n    /// @param newRate Rate in Euro cent per ether\n    function setRate(uint newRate) public onlyRateAdmin {\n        // Rate changes beyond an order of magnitude are likely just typos\n        require(rate / 10 < newRate && newRate < 10 * rate, \"Rate change too big\");\n        require(newRate < RATE_LIMIT, \"New rate reaches limit\");\n\n        if (newRate != rate) {\n            emit RateChange(rate, newRate);\n\n            rate = newRate;\n        }\n    }\n\n    /// @dev Return the current price of an Ether in EUR cents\n    /// @return Current Ether rate\n    function etherRate() public view returns (uint) {\n        return rate;\n    }\n\n    /// @dev Return the number of projects deployed by this instance\n    /// @return Projects count\n    function projectsCount() public view returns (uint) {\n        return projects.length;\n    }\n\n    /// @dev Create a new project,\n    ///      i.e. deploy a new token and crowdsale and store their address into projects\n    function createNewProject(\n        string name,\n        string symbol,\n        uint tokenPrice,\n        address[3] roles,  // [profitDepositor, profitDistributor, tokenRecoverer]\n        uint[6] amounts,   // [tokenCapOfPublicSale, tokenCapOfPrivateSale, tokenGoal,\n                           //  tokenPurchaseMinimum, tokenPurchaseLimit, tokenReservePerMill]\n        uint[3] period,    // [openingTime, closingTime, limitEndTime]\n        address[2] wallets  // [companyWallet, reserveAccount]\n    )\n        external onlyOwner\n    {\n        require(address(currentWhitelist) != address(0x0), \"Whitelist is zero\");\n        require(address(tokenFactory) != address(0x0), \"Token factory is zero\");\n        require(address(crowdsaleFactory) != address(0x0), \"Crowdsale factory is zero\");\n\n        // Parameters are given as arrays to avoid the \"stack too deep\" complaints of the\n        // Solidity compiler.\n        // Furthermore the deployment of the tokens and the crowdsale contract is done via\n        // factory contracts whose only purpose is to deploy an instance of the respective\n        // contract. This construction avoids the problem of limited bytecode length when\n        // deploying contracts (see EIP170). As a side effect, it also enables the change\n        // of one of the factories by an updated version.\n\n        // Utilize the token factory to deploy a new token contract instance\n        StokrToken token = tokenFactory.createNewToken(\n            name,\n            symbol,\n            currentWhitelist,\n            roles[0],   // profitDepositor\n            roles[1],   // profitDistributor\n            roles[2]);  // tokenRecoverer\n\n        // Utilize the crowdsale factory to deploy a new crowdsale contract instance\n        StokrCrowdsale crowdsale = crowdsaleFactory.createNewCrowdsale(\n            token,\n            tokenPrice,\n            amounts,\n            period,\n            wallets);\n\n        token.setMinter(crowdsale);  // The crowdsale should be the minter of the token\n        token.transferOwnershipUnsafe(msg.sender);  // to tokenOwner\n        crowdsale.transferOwnershipUnsafe(msg.sender);  // to crowdsaleOwner\n\n        // Store the created project into the projects array state variable\n        projects.push(StokrProject(name, currentWhitelist, token, crowdsale));\n\n        emit ProjectCreation(projects.length - 1, currentWhitelist, token, crowdsale);\n    }\n\n}",
  "bytecode": "608060405234801561001057600080fd5b50604051602080611558833981016040525160008054600160a060020a0319163317815581116100a157604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601260248201527f45746865722072617465206973207a65726f0000000000000000000000000000604482015290519081900360640190fd5b7f1999999999999999999999999999999999999999999999999999999999999999811061012f57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f457468657220726174652072656163686573206c696d69740000000000000000604482015290519081900360640190fd5b43600255600455611413806101456000396000f3006080604052600436106101115763ffffffff7c0100000000000000000000000000000000000000000000000000000000600035041663107046bd81146101165780632150cd56146101f15780632f73a9f81461021457806334fcf437146102355780634e71e0c81461024d57806362b31d6f14610262578063658e45061461028957806365e8c444146102ba578063854cff2f146102db5780638da5cb5b146102fc5780639c213fb414610311578063a824c9d214610326578063c73b302e14610347578063ca69583b1461035c578063cf00421714610371578063d0f7a60114610386578063d1d46a021461039b578063d4ee1d90146103d4578063e77772fe146103e9578063f2fde38b146103fe575b600080fd5b34801561012257600080fd5b5061012e60043561041f565b604051808060200185600160a060020a0316600160a060020a0316815260200184600160a060020a0316600160a060020a0316815260200183600160a060020a0316600160a060020a03168152602001828103825286818151815260200191508051906020019080838360005b838110156101b357818101518382015260200161019b565b50505050905090810190601f1680156101e05780820380516001836020036101000a031916815260200191505b509550505050505060405180910390f35b3480156101fd57600080fd5b50610212600160a060020a03600435166104f1565b005b34801561022057600080fd5b50610212600160a060020a036004351661060f565b34801561024157600080fd5b506102126004356106e1565b34801561025957600080fd5b50610212610875565b34801561026e57600080fd5b506102776108e2565b60408051918252519081900360200190f35b34801561029557600080fd5b5061029e610906565b60408051600160a060020a039092168252519081900360200190f35b3480156102c657600080fd5b50610212600160a060020a0360043516610915565b3480156102e757600080fd5b50610212600160a060020a03600435166109e7565b34801561030857600080fd5b5061029e610ab9565b34801561031d57600080fd5b5061029e610ac8565b34801561033257600080fd5b50610212600160a060020a0360043516610ad7565b34801561035357600080fd5b50610277610b90565b34801561036857600080fd5b5061029e610b97565b34801561037d57600080fd5b50610277610ba6565b34801561039257600080fd5b50610277610bac565b3480156103a757600080fd5b506102126024600480358281019290820135918135918201910135604435606460c46101846101e4610bb2565b3480156103e057600080fd5b5061029e6111d1565b3480156103f557600080fd5b5061029e6111e0565b34801561040a57600080fd5b50610212600160a060020a03600435166111ef565b600880548290811061042d57fe5b60009182526020918290206004919091020180546040805160026001841615610100026000190190931692909204601f8101859004850283018501909152808252919350918391908301828280156104c65780601f1061049b576101008083540402835291602001916104c6565b820191906000526020600020905b8154815290600101906020018083116104a957829003601f168201915b50505050600183015460028401546003909401549293600160a060020a039182169390821692501684565b600054600160a060020a03163314610541576040805160e560020a62461bcd02815260206004820152601360248201526000805160206113c8833981519152604482015290519081900360640190fd5b600160a060020a03811615156105a1576040805160e560020a62461bcd02815260206004820152601660248201527f4e657720726174652061646d696e206973207a65726f00000000000000000000604482015290519081900360640190fd5b600354600160a060020a0382811691161461060c57600354604051600160a060020a038084169216907f5405b45131b40f5c90451693b6dcc1cae525dd98fb1d8a34e8a97930d1c4fb6390600090a360038054600160a060020a031916600160a060020a0383161790555b50565b600054600160a060020a0316331461065f576040805160e560020a62461bcd02815260206004820152601360248201526000805160206113c8833981519152604482015290519081900360640190fd5b600160a060020a03811615156106bf576040805160e560020a62461bcd02815260206004820152601560248201527f546f6b656e20666163746f7279206973207a65726f0000000000000000000000604482015290519081900360640190fd5b60068054600160a060020a031916600160a060020a0392909216919091179055565b600354600160a060020a03163314610743576040805160e560020a62461bcd02815260206004820152601860248201527f5265737472696374656420746f20726174652061646d696e0000000000000000604482015290519081900360640190fd5b6004548190600a900410801561075d5750600454600a0281105b15156107b3576040805160e560020a62461bcd02815260206004820152601360248201527f52617465206368616e676520746f6f2062696700000000000000000000000000604482015290519081900360640190fd5b7f1999999999999999999999999999999999999999999999999999999999999999811061082a576040805160e560020a62461bcd02815260206004820152601660248201527f4e657720726174652072656163686573206c696d697400000000000000000000604482015290519081900360640190fd5b600454811461060c57600454604080519182526020820183905280517f5fe72661ec4e10c57ee25f11a7e9125b4ff994b73b2e48e8575d6ffc8dbf2bf09281900390910190a1600455565b600154600160a060020a031633146108d7576040805160e560020a62461bcd02815260206004820152601760248201527f5265737472696374656420746f206e6577206f776e6572000000000000000000604482015290519081900360640190fd5b6108e0336112c1565b565b7f199999999999999999999999999999999999999999999999999999999999999981565b600754600160a060020a031681565b600054600160a060020a03163314610965576040805160e560020a62461bcd02815260206004820152601360248201526000805160206113c8833981519152604482015290519081900360640190fd5b600160a060020a03811615156109c5576040805160e560020a62461bcd02815260206004820152601960248201527f43726f776473616c6520666163746f7279206973207a65726f00000000000000604482015290519081900360640190fd5b60078054600160a060020a031916600160a060020a0392909216919091179055565b600054600160a060020a03163314610a37576040805160e560020a62461bcd02815260206004820152601360248201526000805160206113c8833981519152604482015290519081900360640190fd5b600160a060020a0381161515610a97576040805160e560020a62461bcd02815260206004820152601160248201527f57686974656c697374206973207a65726f000000000000000000000000000000604482015290519081900360640190fd5b60058054600160a060020a031916600160a060020a0392909216919091179055565b600054600160a060020a031681565b600554600160a060020a031681565b600054600160a060020a03163314610b27576040805160e560020a62461bcd02815260206004820152601360248201526000805160206113c8833981519152604482015290519081900360640190fd5b600160a060020a0381161515610b87576040805160e560020a62461bcd02815260206004820152601160248201527f4e6577206f776e6572206973207a65726f000000000000000000000000000000604482015290519081900360640190fd5b61060c816112c1565b6008545b90565b600354600160a060020a031681565b60025481565b60045490565b600080548190600160a060020a03163314610c05576040805160e560020a62461bcd02815260206004820152601360248201526000805160206113c8833981519152604482015290519081900360640190fd5b600554600160a060020a03161515610c67576040805160e560020a62461bcd02815260206004820152601160248201527f57686974656c697374206973207a65726f000000000000000000000000000000604482015290519081900360640190fd5b600654600160a060020a03161515610cc9576040805160e560020a62461bcd02815260206004820152601560248201527f546f6b656e20666163746f7279206973207a65726f0000000000000000000000604482015290519081900360640190fd5b600754600160a060020a03161515610d2b576040805160e560020a62461bcd02815260206004820152601960248201527f43726f776473616c6520666163746f7279206973207a65726f00000000000000604482015290519081900360640190fd5b600654600554600160a060020a039182169163831ff629918e918e918e918e918116908d3581169060208f0135168e60026040517c010000000000000000000000000000000000000000000000000000000063ffffffff8c16028152600160a060020a0386811660448301528581166064830152848116608483015260209290920292909201351660a4820181905260c06004830190815260c4830189905290918190602481019060e4018b8b808284379091018481038352898152602001905089898082843782019150509a5050505050505050505050602060405180830381600087803b158015610e1d57600080fd5b505af1158015610e31573d6000803e3d6000fd5b505050506040513d6020811015610e4757600080fd5b50516007546040517f7503661c000000000000000000000000000000000000000000000000000000008152600160a060020a0380841660048301908152602483018c905293955090911691637503661c9185918b918a918a918a91906044018460c080828437909101905083606080828437909101905082604080828437820191505095505050505050602060405180830381600087803b158015610eeb57600080fd5b505af1158015610eff573d6000803e3d6000fd5b505050506040513d6020811015610f1557600080fd5b5051604080517ffca3b5aa000000000000000000000000000000000000000000000000000000008152600160a060020a03808416600483015291519293509084169163fca3b5aa9160248082019260009290919082900301818387803b158015610f7e57600080fd5b505af1158015610f92573d6000803e3d6000fd5b5050604080517fa824c9d20000000000000000000000000000000000000000000000000000000081523360048201529051600160a060020a038616935063a824c9d29250602480830192600092919082900301818387803b158015610ff657600080fd5b505af115801561100a573d6000803e3d6000fd5b5050604080517fa824c9d20000000000000000000000000000000000000000000000000000000081523360048201529051600160a060020a038516935063a824c9d29250602480830192600092919082900301818387803b15801561106e57600080fd5b505af1158015611082573d6000803e3d6000fd5b5050505060086080604051908101604052808d8d8080601f0160208091040260200160405190810160405280939291908181526020018383808284375050509284525050600554600160a060020a03908116602080850191909152878216604085015290861660609093019290925250825460018101808555600094855293829020835180516004909302909101926111209284929091019061132f565b50602082810151600183018054600160a060020a0319908116600160a060020a03938416179091556040808601516002860180548416918516919091179055606090950151600390940180549091169382169390931790925560085460055484519084168152935186841695509287169360001991909101927f5a97cc5be876fee31e23484e5fd4639ddce31370b57ac9dfbb94d7bb19dfe4d1929181900390910190a45050505050505050505050565b600154600160a060020a031681565b600654600160a060020a031681565b600054600160a060020a0316331461123f576040805160e560020a62461bcd02815260206004820152601360248201526000805160206113c8833981519152604482015290519081900360640190fd5b600160a060020a038116151561129f576040805160e560020a62461bcd02815260206004820152601160248201527f4e6577206f776e6572206973207a65726f000000000000000000000000000000604482015290519081900360640190fd5b60018054600160a060020a031916600160a060020a0392909216919091179055565b600054600160a060020a0382811691161461060c5760008054604051600160a060020a03808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a360008054600160a060020a038316600160a060020a031990911617905550565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061137057805160ff191683800117855561139d565b8280016001018555821561139d579182015b8281111561139d578251825591602001919060010190611382565b506113a99291506113ad565b5090565b610b9491905b808211156113a957600081556001016113b356005265737472696374656420746f206f776e657200000000000000000000000000a165627a7a7230582036065e64212fac17cf8ab4b3a0172a1c97e76e3b07fab3c6ce84600a5561e480002900000000000000000000000000000000000000000000000000000000000035fd",
  "constructorArguments": "00000000000000000000000000000000000000000000000000000000000035fd"
}