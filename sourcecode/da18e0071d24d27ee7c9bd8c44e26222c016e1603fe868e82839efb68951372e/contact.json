{
  "address": "0xec270e8f52b492dd0c2dcd43fc6f868e78f49f18",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "BitDraw Token",
  "contractName": "SmartzToken",
  "compilerVersion": "v0.4.24+commit.e67f0147",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2018-08-31\n*/\n\npragma solidity ^0.4.18;\n\ninterface IApprovalRecipient {\n    /**\n     * @notice Signals that token holder approved spending of tokens and some action should be taken.\n     *\n     * @param _sender token holder which approved spending of his tokens\n     * @param _value amount of tokens approved to be spent\n     * @param _extraData any extra data token holder provided to the call\n     *\n     * @dev warning: implementors should validate sender of this message (it should be the token) and make no further\n     *      assumptions unless validated them via ERC20 methods.\n     */\n    function receiveApproval(address _sender, uint256 _value, bytes _extraData) public;\n}\n\ninterface IKYCProvider {\n    function isKYCPassed(address _address) public view returns (bool);\n}\n\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\ncontract ArgumentsChecker {\n\n    /// @dev check which prevents short address attack\n    modifier payloadSizeIs(uint size) {\n       require(msg.data.length == size + 4 /* function selector */);\n       _;\n    }\n\n    /// @dev check that address is valid\n    modifier validAddress(address addr) {\n        require(addr != address(0));\n        _;\n    }\n}\n\ncontract multiowned {\n\n\t// TYPES\n\n    // struct for the status of a pending operation.\n    struct MultiOwnedOperationPendingState {\n        // count of confirmations needed\n        uint yetNeeded;\n\n        // bitmap of confirmations where owner #ownerIndex's decision corresponds to 2**ownerIndex bit\n        uint ownersDone;\n\n        // position of this operation key in m_multiOwnedPendingIndex\n        uint index;\n    }\n\n\t// EVENTS\n\n    event Confirmation(address owner, bytes32 operation);\n    event Revoke(address owner, bytes32 operation);\n    event FinalConfirmation(address owner, bytes32 operation);\n\n    // some others are in the case of an owner changing.\n    event OwnerChanged(address oldOwner, address newOwner);\n    event OwnerAdded(address newOwner);\n    event OwnerRemoved(address oldOwner);\n\n    // the last one is emitted if the required signatures change\n    event RequirementChanged(uint newRequirement);\n\n\t// MODIFIERS\n\n    // simple single-sig function modifier.\n    modifier onlyowner {\n        require(isOwner(msg.sender));\n        _;\n    }\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\n    // that later attempts can be realised as the same underlying operation and\n    // thus count as confirmations.\n    modifier onlymanyowners(bytes32 _operation) {\n        if (confirmAndCheck(_operation)) {\n            _;\n        }\n        // Even if required number of confirmations has't been collected yet,\n        // we can't throw here - because changes to the state have to be preserved.\n        // But, confirmAndCheck itself will throw in case sender is not an owner.\n    }\n\n    modifier validNumOwners(uint _numOwners) {\n        require(_numOwners > 0 && _numOwners <= c_maxOwners);\n        _;\n    }\n\n    modifier multiOwnedValidRequirement(uint _required, uint _numOwners) {\n        require(_required > 0 && _required <= _numOwners);\n        _;\n    }\n\n    modifier ownerExists(address _address) {\n        require(isOwner(_address));\n        _;\n    }\n\n    modifier ownerDoesNotExist(address _address) {\n        require(!isOwner(_address));\n        _;\n    }\n\n    modifier multiOwnedOperationIsActive(bytes32 _operation) {\n        require(isOperationActive(_operation));\n        _;\n    }\n\n\t// METHODS\n\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\n    // as well as the selection of addresses capable of confirming them (msg.sender is not added to the owners!).\n    function multiowned(address[] _owners, uint _required)\n        public\n        validNumOwners(_owners.length)\n        multiOwnedValidRequirement(_required, _owners.length)\n    {\n        assert(c_maxOwners <= 255);\n\n        m_numOwners = _owners.length;\n        m_multiOwnedRequired = _required;\n\n        for (uint i = 0; i < _owners.length; ++i)\n        {\n            address owner = _owners[i];\n            // invalid and duplicate addresses are not allowed\n            require(0 != owner && !isOwner(owner) /* not isOwner yet! */);\n\n            uint currentOwnerIndex = checkOwnerIndex(i + 1 /* first slot is unused */);\n            m_owners[currentOwnerIndex] = owner;\n            m_ownerIndex[owner] = currentOwnerIndex;\n        }\n\n        assertOwnersAreConsistent();\n    }\n\n    /// @notice replaces an owner `_from` with another `_to`.\n    /// @param _from address of owner to replace\n    /// @param _to address of new owner\n    // All pending operations will be canceled!\n    function changeOwner(address _from, address _to)\n        external\n        ownerExists(_from)\n        ownerDoesNotExist(_to)\n        onlymanyowners(keccak256(msg.data))\n    {\n        assertOwnersAreConsistent();\n\n        clearPending();\n        uint ownerIndex = checkOwnerIndex(m_ownerIndex[_from]);\n        m_owners[ownerIndex] = _to;\n        m_ownerIndex[_from] = 0;\n        m_ownerIndex[_to] = ownerIndex;\n\n        assertOwnersAreConsistent();\n        OwnerChanged(_from, _to);\n    }\n\n    /// @notice adds an owner\n    /// @param _owner address of new owner\n    // All pending operations will be canceled!\n    function addOwner(address _owner)\n        external\n        ownerDoesNotExist(_owner)\n        validNumOwners(m_numOwners + 1)\n        onlymanyowners(keccak256(msg.data))\n    {\n        assertOwnersAreConsistent();\n\n        clearPending();\n        m_numOwners++;\n        m_owners[m_numOwners] = _owner;\n        m_ownerIndex[_owner] = checkOwnerIndex(m_numOwners);\n\n        assertOwnersAreConsistent();\n        OwnerAdded(_owner);\n    }\n\n    /// @notice removes an owner\n    /// @param _owner address of owner to remove\n    // All pending operations will be canceled!\n    function removeOwner(address _owner)\n        external\n        ownerExists(_owner)\n        validNumOwners(m_numOwners - 1)\n        multiOwnedValidRequirement(m_multiOwnedRequired, m_numOwners - 1)\n        onlymanyowners(keccak256(msg.data))\n    {\n        assertOwnersAreConsistent();\n\n        clearPending();\n        uint ownerIndex = checkOwnerIndex(m_ownerIndex[_owner]);\n        m_owners[ownerIndex] = 0;\n        m_ownerIndex[_owner] = 0;\n        //make sure m_numOwners is equal to the number of owners and always points to the last owner\n        reorganizeOwners();\n\n        assertOwnersAreConsistent();\n        OwnerRemoved(_owner);\n    }\n\n    /// @notice changes the required number of owner signatures\n    /// @param _newRequired new number of signatures required\n    // All pending operations will be canceled!\n    function changeRequirement(uint _newRequired)\n        external\n        multiOwnedValidRequirement(_newRequired, m_numOwners)\n        onlymanyowners(keccak256(msg.data))\n    {\n        m_multiOwnedRequired = _newRequired;\n        clearPending();\n        RequirementChanged(_newRequired);\n    }\n\n    /// @notice Gets an owner by 0-indexed position\n    /// @param ownerIndex 0-indexed owner position\n    function getOwner(uint ownerIndex) public constant returns (address) {\n        return m_owners[ownerIndex + 1];\n    }\n\n    /// @notice Gets owners\n    /// @return memory array of owners\n    function getOwners() public constant returns (address[]) {\n        address[] memory result = new address[](m_numOwners);\n        for (uint i = 0; i < m_numOwners; i++)\n            result[i] = getOwner(i);\n\n        return result;\n    }\n\n    /// @notice checks if provided address is an owner address\n    /// @param _addr address to check\n    /// @return true if it's an owner\n    function isOwner(address _addr) public constant returns (bool) {\n        return m_ownerIndex[_addr] > 0;\n    }\n\n    /// @notice Tests ownership of the current caller.\n    /// @return true if it's an owner\n    // It's advisable to call it by new owner to make sure that the same erroneous address is not copy-pasted to\n    // addOwner/changeOwner and to isOwner.\n    function amIOwner() external constant onlyowner returns (bool) {\n        return true;\n    }\n\n    /// @notice Revokes a prior confirmation of the given operation\n    /// @param _operation operation value, typically keccak256(msg.data)\n    function revoke(bytes32 _operation)\n        external\n        multiOwnedOperationIsActive(_operation)\n        onlyowner\n    {\n        uint ownerIndexBit = makeOwnerBitmapBit(msg.sender);\n        var pending = m_multiOwnedPending[_operation];\n        require(pending.ownersDone & ownerIndexBit > 0);\n\n        assertOperationIsConsistent(_operation);\n\n        pending.yetNeeded++;\n        pending.ownersDone -= ownerIndexBit;\n\n        assertOperationIsConsistent(_operation);\n        Revoke(msg.sender, _operation);\n    }\n\n    /// @notice Checks if owner confirmed given operation\n    /// @param _operation operation value, typically keccak256(msg.data)\n    /// @param _owner an owner address\n    function hasConfirmed(bytes32 _operation, address _owner)\n        external\n        constant\n        multiOwnedOperationIsActive(_operation)\n        ownerExists(_owner)\n        returns (bool)\n    {\n        return !(m_multiOwnedPending[_operation].ownersDone & makeOwnerBitmapBit(_owner) == 0);\n    }\n\n    // INTERNAL METHODS\n\n    function confirmAndCheck(bytes32 _operation)\n        private\n        onlyowner\n        returns (bool)\n    {\n        if (512 == m_multiOwnedPendingIndex.length)\n            // In case m_multiOwnedPendingIndex grows too much we have to shrink it: otherwise at some point\n            // we won't be able to do it because of block gas limit.\n            // Yes, pending confirmations will be lost. Dont see any security or stability implications.\n            // TODO use more graceful approach like compact or removal of clearPending completely\n            clearPending();\n\n        var pending = m_multiOwnedPending[_operation];\n\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\n        if (! isOperationActive(_operation)) {\n            // reset count of confirmations needed.\n            pending.yetNeeded = m_multiOwnedRequired;\n            // reset which owners have confirmed (none) - set our bitmap to 0.\n            pending.ownersDone = 0;\n            pending.index = m_multiOwnedPendingIndex.length++;\n            m_multiOwnedPendingIndex[pending.index] = _operation;\n            assertOperationIsConsistent(_operation);\n        }\n\n        // determine the bit to set for this owner.\n        uint ownerIndexBit = makeOwnerBitmapBit(msg.sender);\n        // make sure we (the message sender) haven't confirmed this operation previously.\n        if (pending.ownersDone & ownerIndexBit == 0) {\n            // ok - check if count is enough to go ahead.\n            assert(pending.yetNeeded > 0);\n            if (pending.yetNeeded == 1) {\n                // enough confirmations: reset and run interior.\n                delete m_multiOwnedPendingIndex[m_multiOwnedPending[_operation].index];\n                delete m_multiOwnedPending[_operation];\n                FinalConfirmation(msg.sender, _operation);\n                return true;\n            }\n            else\n            {\n                // not enough: record that this owner in particular confirmed.\n                pending.yetNeeded--;\n                pending.ownersDone |= ownerIndexBit;\n                assertOperationIsConsistent(_operation);\n                Confirmation(msg.sender, _operation);\n            }\n        }\n    }\n\n    // Reclaims free slots between valid owners in m_owners.\n    // TODO given that its called after each removal, it could be simplified.\n    function reorganizeOwners() private {\n        uint free = 1;\n        while (free < m_numOwners)\n        {\n            // iterating to the first free slot from the beginning\n            while (free < m_numOwners && m_owners[free] != 0) free++;\n\n            // iterating to the first occupied slot from the end\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\n\n            // swap, if possible, so free slot is located at the end after the swap\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\n            {\n                // owners between swapped slots should't be renumbered - that saves a lot of gas\n                m_owners[free] = m_owners[m_numOwners];\n                m_ownerIndex[m_owners[free]] = free;\n                m_owners[m_numOwners] = 0;\n            }\n        }\n    }\n\n    function clearPending() private onlyowner {\n        uint length = m_multiOwnedPendingIndex.length;\n        // TODO block gas limit\n        for (uint i = 0; i < length; ++i) {\n            if (m_multiOwnedPendingIndex[i] != 0)\n                delete m_multiOwnedPending[m_multiOwnedPendingIndex[i]];\n        }\n        delete m_multiOwnedPendingIndex;\n    }\n\n    function checkOwnerIndex(uint ownerIndex) private pure returns (uint) {\n        assert(0 != ownerIndex && ownerIndex <= c_maxOwners);\n        return ownerIndex;\n    }\n\n    function makeOwnerBitmapBit(address owner) private constant returns (uint) {\n        uint ownerIndex = checkOwnerIndex(m_ownerIndex[owner]);\n        return 2 ** ownerIndex;\n    }\n\n    function isOperationActive(bytes32 _operation) private constant returns (bool) {\n        return 0 != m_multiOwnedPending[_operation].yetNeeded;\n    }\n\n\n    function assertOwnersAreConsistent() private constant {\n        assert(m_numOwners > 0);\n        assert(m_numOwners <= c_maxOwners);\n        assert(m_owners[0] == 0);\n        assert(0 != m_multiOwnedRequired && m_multiOwnedRequired <= m_numOwners);\n    }\n\n    function assertOperationIsConsistent(bytes32 _operation) private constant {\n        var pending = m_multiOwnedPending[_operation];\n        assert(0 != pending.yetNeeded);\n        assert(m_multiOwnedPendingIndex[pending.index] == _operation);\n        assert(pending.yetNeeded <= m_multiOwnedRequired);\n    }\n\n\n   \t// FIELDS\n\n    uint constant c_maxOwners = 250;\n\n    // the number of owners that must confirm the same operation before it is run.\n    uint public m_multiOwnedRequired;\n\n\n    // pointer used to find a free slot in m_owners\n    uint public m_numOwners;\n\n    // list of owners (addresses),\n    // slot 0 is unused so there are no owner which index is 0.\n    // TODO could we save space at the end of the array for the common case of <10 owners? and should we?\n    address[256] internal m_owners;\n\n    // index on the list of owners to allow reverse lookup: owner address => index in m_owners\n    mapping(address => uint) internal m_ownerIndex;\n\n\n    // the ongoing operations.\n    mapping(bytes32 => MultiOwnedOperationPendingState) internal m_multiOwnedPending;\n    bytes32[] internal m_multiOwnedPendingIndex;\n}\n\ncontract ERC20Basic {\n  uint256 public totalSupply;\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}\n\ncontract BurnableToken is BasicToken {\n\n    event Burn(address indexed from, uint256 amount);\n\n    /**\n     * Function to burn msg.sender's tokens.\n     *\n     * @param _amount amount of tokens to burn\n     *\n     * @return boolean that indicates if the operation was successful\n     */\n    function burn(uint256 _amount)\n        public\n        returns (bool)\n    {\n        address from = msg.sender;\n\n        require(_amount > 0);\n        require(_amount <= balances[from]);\n\n        totalSupply = totalSupply.sub(_amount);\n        balances[from] = balances[from].sub(_amount);\n        Burn(from, _amount);\n        Transfer(from, address(0), _amount);\n\n        return true;\n    }\n}\n\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\ncontract TokenWithApproveAndCallMethod is StandardToken {\n\n    /**\n     * @notice Approves spending tokens and immediately triggers token recipient logic.\n     *\n     * @param _spender contract which supports IApprovalRecipient and allowed to receive tokens\n     * @param _value amount of tokens approved to be spent\n     * @param _extraData any extra data which to be provided to the _spender\n     *\n     * By invoking this utility function token holder could do two things in one transaction: approve spending his\n     * tokens and execute some external contract which spends them on token holder's behalf.\n     * It can't be known if _spender's invocation succeed or not.\n     * This function will throw if approval failed.\n     */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public {\n        require(approve(_spender, _value));\n        IApprovalRecipient(_spender).receiveApproval(msg.sender, _value, _extraData);\n    }\n}\n\ncontract SmartzToken is ArgumentsChecker, multiowned, BurnableToken, StandardToken, TokenWithApproveAndCallMethod {\n\n    /// @title Unit of frozen tokens - tokens which can't be spent until certain conditions is met.\n    struct FrozenCell {\n        /// @notice amount of frozen tokens\n        uint amount;\n\n        /// @notice until this unix time the cell is considered frozen\n        uint128 thawTS;\n\n        /// @notice is KYC required for a token holder to spend this cell?\n        uint128 isKYCRequired;\n    }\n\n\n    // MODIFIERS\n\n    modifier onlySale(address account) {\n        require(isSale(account));\n        _;\n    }\n\n    modifier validUnixTS(uint ts) {\n        require(ts >= 1522046326 && ts <= 1800000000);\n        _;\n    }\n\n    modifier checkTransferInvariant(address from, address to) {\n        uint initial = balanceOf(from).add(balanceOf(to));\n        _;\n        assert(balanceOf(from).add(balanceOf(to)) == initial);\n    }\n\n    modifier privilegedAllowed {\n        require(m_allowPrivileged);\n        _;\n    }\n\n\n    // PUBLIC FUNCTIONS\n\n    /**\n     * @notice Constructs token.\n     *\n     * Initial owners have power over the token contract only during bootstrap phase (early investments and token\n     * sales). To be precise, the owners can set KYC provider and sales (which can freeze transfered tokens) during\n     * bootstrap phase. After final token sale any control over the token removed by issuing disablePrivileged call.\n     */\n    function SmartzToken()\n        public\n        payable\n        multiowned(getInitialOwners(), 1)\n    {\n        if (0 != 35000000000000000000000000) {\n            totalSupply = 35000000000000000000000000;\n            balances[msg.sender] = totalSupply;\n            Transfer(address(0), msg.sender, totalSupply);\n        }\n\n        \ntotalSupply = totalSupply.add(0);\n\n        \n    }\n\n    function getInitialOwners() private pure returns (address[]) {\n        address[] memory result = new address[](1);\nresult[0] = address(0x15B694A7C4106beC672cCB8E0b0590B1d649b4aF);\n        return result;\n    }\n\n    /**\n     * @notice Version of balanceOf() which includes all frozen tokens.\n     *\n     * @param _owner the address to query the balance of\n     *\n     * @return an uint256 representing the amount owned by the passed address\n     */\n    function balanceOf(address _owner) public view returns (uint256) {\n        uint256 balance = balances[_owner];\n\n        for (uint cellIndex = 0; cellIndex < frozenBalances[_owner].length; ++cellIndex) {\n            balance = balance.add(frozenBalances[_owner][cellIndex].amount);\n        }\n\n        return balance;\n    }\n\n    /**\n     * @notice Version of balanceOf() which includes only currently spendable tokens.\n     *\n     * @param _owner the address to query the balance of\n     *\n     * @return an uint256 representing the amount spendable by the passed address\n     */\n    function availableBalanceOf(address _owner) public view returns (uint256) {\n        uint256 balance = balances[_owner];\n\n        for (uint cellIndex = 0; cellIndex < frozenBalances[_owner].length; ++cellIndex) {\n            if (isSpendableFrozenCell(_owner, cellIndex))\n                balance = balance.add(frozenBalances[_owner][cellIndex].amount);\n        }\n\n        return balance;\n    }\n\n    /**\n     * @notice Standard transfer() overridden to have a chance to thaw sender's tokens.\n     *\n     * @param _to the address to transfer to\n     * @param _value the amount to be transferred\n     *\n     * @return true iff operation was successfully completed\n     */\n    function transfer(address _to, uint256 _value)\n        public\n        payloadSizeIs(2 * 32)\n        returns (bool)\n    {\n        thawSomeTokens(msg.sender, _value);\n        return super.transfer(_to, _value);\n    }\n\n    /**\n     * @notice Standard transferFrom overridden to have a chance to thaw sender's tokens.\n     *\n     * @param _from address the address which you want to send tokens from\n     * @param _to address the address which you want to transfer to\n     * @param _value uint256 the amount of tokens to be transferred\n     *\n     * @return true iff operation was successfully completed\n     */\n    function transferFrom(address _from, address _to, uint256 _value)\n        public\n        payloadSizeIs(3 * 32)\n        returns (bool)\n    {\n        thawSomeTokens(_from, _value);\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    \n    /**\n     * Function to burn msg.sender's tokens. Overridden to have a chance to thaw sender's tokens.\n     *\n     * @param _amount amount of tokens to burn\n     *\n     * @return boolean that indicates if the operation was successful\n     */\n    function burn(uint256 _amount)\n        public\n        payloadSizeIs(1 * 32)\n        returns (bool)\n    {\n        thawSomeTokens(msg.sender, _amount);\n        return super.burn(_amount);\n    }\n\n\n    // INFORMATIONAL FUNCTIONS (VIEWS)\n\n    /**\n     * @notice Number of frozen cells of an account.\n     *\n     * @param owner account address\n     *\n     * @return number of frozen cells\n     */\n    function frozenCellCount(address owner) public view returns (uint) {\n        return frozenBalances[owner].length;\n    }\n\n    /**\n     * @notice Retrieves information about account frozen tokens.\n     *\n     * @param owner account address\n     * @param index index of so-called frozen cell from 0 (inclusive) up to frozenCellCount(owner) exclusive\n     *\n     * @return amount amount of tokens frozen in this cell\n     * @return thawTS unix timestamp at which tokens'll become available\n     * @return isKYCRequired it's required to pass KYC to spend tokens iff isKYCRequired is true\n     */\n    function frozenCell(address owner, uint index) public view returns (uint amount, uint thawTS, bool isKYCRequired) {\n        require(index < frozenCellCount(owner));\n\n        amount = frozenBalances[owner][index].amount;\n        thawTS = uint(frozenBalances[owner][index].thawTS);\n        isKYCRequired = decodeKYCFlag(frozenBalances[owner][index].isKYCRequired);\n    }\n\n\n    // ADMINISTRATIVE FUNCTIONS\n\n    /**\n     * @notice Sets current KYC provider of the token.\n     *\n     * @param KYCProvider address of the IKYCProvider-compatible contract\n     *\n     * Function is used only during token sale phase, before disablePrivileged() is called.\n     */\n    function setKYCProvider(address KYCProvider)\n        external\n        validAddress(KYCProvider)\n        privilegedAllowed\n        onlymanyowners(keccak256(msg.data))\n    {\n        m_KYCProvider = IKYCProvider(KYCProvider);\n    }\n\n    /**\n     * @notice Sets sale status of an account.\n     *\n     * @param account account address\n     * @param isSale is this account has access to frozen* functions\n     *\n     * Function is used only during token sale phase, before disablePrivileged() is called.\n     */\n    function setSale(address account, bool isSale)\n        external\n        validAddress(account)\n        privilegedAllowed\n        onlymanyowners(keccak256(msg.data))\n    {\n        m_sales[account] = isSale;\n    }\n\n\n    /**\n     * @notice Transfers tokens to a recipient and freezes it.\n     *\n     * @param _to account to which tokens are sent\n     * @param _value amount of tokens to send\n     * @param thawTS unix timestamp at which tokens'll become available\n     * @param isKYCRequired it's required to pass KYC to spend tokens iff isKYCRequired is true\n     *\n     * Function is used only during token sale phase and available only to sale accounts.\n     */\n    function frozenTransfer(address _to, uint256 _value, uint thawTS, bool isKYCRequired)\n        external\n        validAddress(_to)\n        validUnixTS(thawTS)\n        payloadSizeIs(4 * 32)\n        privilegedAllowed\n        onlySale(msg.sender)\n        checkTransferInvariant(msg.sender, _to)\n        returns (bool)\n    {\n        require(_value <= balances[msg.sender]);\n\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        addFrozen(_to, _value, thawTS, isKYCRequired);\n        Transfer(msg.sender, _to, _value);\n\n        return true;\n    }\n\n    /**\n     * @notice Transfers frozen tokens back.\n     *\n     * @param _from account to send tokens from\n     * @param _to account to which tokens are sent\n     * @param _value amount of tokens to send\n     * @param thawTS unix timestamp at which tokens'll become available\n     * @param isKYCRequired it's required to pass KYC to spend tokens iff isKYCRequired is true\n     *\n     * Function is used only during token sale phase to make a refunds and available only to sale accounts.\n     * _from account has to explicitly approve spending with the approve() call.\n     * thawTS and isKYCRequired parameters are required to withdraw exact \"same\" tokens (to not affect availability of\n     * other tokens of the account).\n     */\n    function frozenTransferFrom(address _from, address _to, uint256 _value, uint thawTS, bool isKYCRequired)\n        external\n        validAddress(_to)\n        validUnixTS(thawTS)\n        payloadSizeIs(5 * 32)\n        privilegedAllowed\n        //onlySale(msg.sender) too many local variables - compiler fails\n        //onlySale(_to)\n        checkTransferInvariant(_from, _to)\n        returns (bool)\n    {\n        require(isSale(msg.sender) && isSale(_to));\n        require(_value <= allowed[_from][msg.sender]);\n\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n        subFrozen(_from, _value, thawTS, isKYCRequired);\n        balances[_to] = balances[_to].add(_value);\n        Transfer(_from, _to, _value);\n\n        return true;\n    }\n\n    /// @notice Disables further use of any privileged functions like freezing tokens.\n    function disablePrivileged()\n        external\n        privilegedAllowed\n        onlymanyowners(keccak256(msg.data))\n    {\n        m_allowPrivileged = false;\n    }\n\n\n    // INTERNAL FUNCTIONS\n\n    function isSale(address account) private view returns (bool) {\n        return m_sales[account];\n    }\n\n    /**\n     * @dev Tries to find existent FrozenCell that matches (thawTS, isKYCRequired).\n     *\n     * @return index in frozenBalances[_owner] which equals to frozenBalances[_owner].length in case cell is not found\n     *\n     * Because frozen* functions are only for token sales and token sale number is limited, expecting cellIndex\n     * to be ~ 1-5 and the following loop to be O(1).\n     */\n    function findFrozenCell(address owner, uint128 thawTSEncoded, uint128 isKYCRequiredEncoded)\n        private\n        view\n        returns (uint cellIndex)\n    {\n        for (cellIndex = 0; cellIndex < frozenBalances[owner].length; ++cellIndex) {\n            FrozenCell storage checkedCell = frozenBalances[owner][cellIndex];\n            if (checkedCell.thawTS == thawTSEncoded && checkedCell.isKYCRequired == isKYCRequiredEncoded)\n                break;\n        }\n\n        assert(cellIndex <= frozenBalances[owner].length);\n    }\n\n    /// @dev Says if the given cell could be spent now\n    function isSpendableFrozenCell(address owner, uint cellIndex)\n        private\n        view\n        returns (bool)\n    {\n        FrozenCell storage cell = frozenBalances[owner][cellIndex];\n        if (uint(cell.thawTS) > getTime())\n            return false;\n\n        if (0 == cell.amount)   // already spent\n            return false;\n\n        if (decodeKYCFlag(cell.isKYCRequired) && !m_KYCProvider.isKYCPassed(owner))\n            return false;\n\n        return true;\n    }\n\n    /// @dev Internal function to increment or create frozen cell.\n    function addFrozen(address _to, uint256 _value, uint thawTS, bool isKYCRequired)\n        private\n        validAddress(_to)\n        validUnixTS(thawTS)\n    {\n        uint128 thawTSEncoded = uint128(thawTS);\n        uint128 isKYCRequiredEncoded = encodeKYCFlag(isKYCRequired);\n\n        uint cellIndex = findFrozenCell(_to, thawTSEncoded, isKYCRequiredEncoded);\n\n        // In case cell is not found - creating new.\n        if (cellIndex == frozenBalances[_to].length) {\n            frozenBalances[_to].length++;\n            targetCell = frozenBalances[_to][cellIndex];\n            assert(0 == targetCell.amount);\n\n            targetCell.thawTS = thawTSEncoded;\n            targetCell.isKYCRequired = isKYCRequiredEncoded;\n        }\n\n        FrozenCell storage targetCell = frozenBalances[_to][cellIndex];\n        assert(targetCell.thawTS == thawTSEncoded && targetCell.isKYCRequired == isKYCRequiredEncoded);\n\n        targetCell.amount = targetCell.amount.add(_value);\n    }\n\n    /// @dev Internal function to decrement frozen cell.\n    function subFrozen(address _from, uint256 _value, uint thawTS, bool isKYCRequired)\n        private\n        validUnixTS(thawTS)\n    {\n        uint cellIndex = findFrozenCell(_from, uint128(thawTS), encodeKYCFlag(isKYCRequired));\n        require(cellIndex != frozenBalances[_from].length);   // has to be found\n\n        FrozenCell storage cell = frozenBalances[_from][cellIndex];\n        require(cell.amount >= _value);\n\n        cell.amount = cell.amount.sub(_value);\n    }\n\n    /// @dev Thaws tokens of owner until enough tokens could be spent or no more such tokens found.\n    function thawSomeTokens(address owner, uint requiredAmount)\n        private\n    {\n        if (balances[owner] >= requiredAmount)\n            return;     // fast path\n\n        // Checking that our goal is reachable before issuing expensive storage modifications.\n        require(availableBalanceOf(owner) >= requiredAmount);\n\n        for (uint cellIndex = 0; cellIndex < frozenBalances[owner].length; ++cellIndex) {\n            if (isSpendableFrozenCell(owner, cellIndex)) {\n                uint amount = frozenBalances[owner][cellIndex].amount;\n                frozenBalances[owner][cellIndex].amount = 0;\n                balances[owner] = balances[owner].add(amount);\n            }\n        }\n\n        assert(balances[owner] >= requiredAmount);\n    }\n\n    /// @dev to be overridden in tests\n    function getTime() internal view returns (uint) {\n        return now;\n    }\n\n    function encodeKYCFlag(bool isKYCRequired) private pure returns (uint128) {\n        return isKYCRequired ? uint128(1) : uint128(0);\n    }\n\n    function decodeKYCFlag(uint128 isKYCRequired) private pure returns (bool) {\n        return isKYCRequired != uint128(0);\n    }\n\n\n    // FIELDS\n\n    /// @notice current KYC provider of the token\n    IKYCProvider public m_KYCProvider;\n\n    /// @notice set of sale accounts which can freeze tokens\n    mapping (address => bool) public m_sales;\n\n    /// @notice frozen tokens\n    mapping (address => FrozenCell[]) public frozenBalances;\n\n    /// @notice allows privileged functions (token sale phase)\n    bool public m_allowPrivileged = true;\n\n\n    // CONSTANTS\n\n    string public constant name = 'BitDraw';\n    string public constant symbol = 'BTDW';\n    uint8 public constant decimals = 18;\n}",
  "bytecode": "608060405261010b805460ff1916600117905562000025640100000000620001db810204565b60016000806000845160008111801562000040575060fa8111155b15156200004c57600080fd5b848651600082118015620000605750808211155b15156200006c57600080fd5b8751600155600087815595505b87518610156200013b5787868151811015156200009257fe5b90602001906020020151945084600160a060020a0316600014158015620000ca5750620000c88564010000000062000241810204565b155b1515620000d657600080fd5b620000ed600187016401000000006200025e810204565b9350846002856101008110620000ff57fe5b018054600160a060020a031916600160a060020a0392831617905585166000908152610102602052604090208490556001959095019462000079565b6200014e6401000000006200027e810204565b50505050505050506a1cf389cd46047d0300000061010581905533600081815261010660209081526040808320859055805194855251929391927fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef9281900390910190a361010554620001d190600064010000000062002219620002ce82021704565b61010555620002e5565b604080516001808252818301909252606091829190602080830190803883390190505090507315b694a7c4106bec672ccb8e0b0590b1d649b4af8160008151811015156200022557fe5b600160a060020a03909216602092830290910190910152905090565b600160a060020a0316600090815261010260205260408120541190565b6000811580159062000271575060fa8211155b15156200027a57fe5b5090565b6001546000106200028b57fe5b60015460fa10156200029957fe5b600254600160a060020a031615620002ad57fe5b60005415801590620002c3575060015460005411155b1515620002cc57fe5b565b600082820183811015620002de57fe5b9392505050565b61294c80620002f56000396000f3006080604052600436106101cc5763ffffffff7c010000000000000000000000000000000000000000000000000000000060003504166306fdde0381146101d1578063095ea7b31461025b5780631019dc5914610293578063173825d9146102bb57806318160ddd146102dc5780632090b0a81461030357806323b872dd1461031857806325d998bb146103425780632f54bf6e14610363578063313ce567146103845780634123cb6b146103af57806342966c68146103c45780634e4ab830146103dc5780635ab92022146103f1578063661884631461041d5780637065cb481461044157806370a08231146104625780637696f0db14610483578063787d64e4146104a457806380340314146104b957806395d89b4114610505578063a0e67e2b1461051a578063a9059cbb1461057f578063b51fdb9a146105a3578063b75c7dc6146105c4578063ba51a6df146105dc578063c24366f0146105f4578063c2cf732614610615578063c41a360a14610639578063cae9ca511461066d578063d73dd623146106d6578063dd62ed3e146106fa578063e2ba6ce814610721578063ef18e45814610736578063f00d4b5d14610768578063f27a73ca1461078f578063f450cfee146107d3575b600080fd5b3480156101dd57600080fd5b506101e66107e8565b6040805160208082528351818301528351919283929083019185019080838360005b83811015610220578181015183820152602001610208565b50505050905090810190601f16801561024d5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b34801561026757600080fd5b5061027f600160a060020a036004351660243561081f565b604080519115158252519081900360200190f35b34801561029f57600080fd5b506102b9600160a060020a03600435166024351515610886565b005b3480156102c757600080fd5b506102b9600160a060020a0360043516610906565b3480156102e857600080fd5b506102f1610a62565b60408051918252519081900360200190f35b34801561030f57600080fd5b5061027f610a69565b34801561032457600080fd5b5061027f600160a060020a0360043581169060243516604435610a73565b34801561034e57600080fd5b506102f1600160a060020a0360043516610aa4565b34801561036f57600080fd5b5061027f600160a060020a0360043516610b4e565b34801561039057600080fd5b50610399610b6b565b6040805160ff9092168252519081900360200190f35b3480156103bb57600080fd5b506102f1610b70565b3480156103d057600080fd5b5061027f600435610b76565b3480156103e857600080fd5b5061027f610ba1565b3480156103fd57600080fd5b5061027f600160a060020a03600435166024356044356064351515610bbe565b34801561042957600080fd5b5061027f600160a060020a0360043516602435610d11565b34801561044d57600080fd5b506102b9600160a060020a0360043516610e07565b34801561046e57600080fd5b506102f1600160a060020a0360043516610f2f565b34801561048f57600080fd5b506102f1600160a060020a0360043516610fa0565b3480156104b057600080fd5b506102f1610fbc565b3480156104c557600080fd5b506104dd600160a060020a0360043516602435610fc2565b604080519384526001608060020a039283166020850152911682820152519081900360600190f35b34801561051157600080fd5b506101e661101f565b34801561052657600080fd5b5061052f611056565b60408051602080825283518183015283519192839290830191858101910280838360005b8381101561056b578181015183820152602001610553565b505050509050019250505060405180910390f35b34801561058b57600080fd5b5061027f600160a060020a03600435166024356110d5565b3480156105af57600080fd5b5061027f600160a060020a0360043516611102565b3480156105d057600080fd5b506102b9600435611118565b3480156105e857600080fd5b506102b96004356111d8565b34801561060057600080fd5b506102b9600160a060020a0360043516611269565b34801561062157600080fd5b5061027f600435600160a060020a03602435166112ec565b34801561064557600080fd5b50610651600435611341565b60408051600160a060020a039092168252519081900360200190f35b34801561067957600080fd5b50604080516020600460443581810135601f81018490048402850184019095528484526102b9948235600160a060020a03169460248035953695946064949201919081908401838280828437509497506113659650505050505050565b3480156106e257600080fd5b5061027f600160a060020a0360043516602435611474565b34801561070657600080fd5b506102f1600160a060020a036004358116906024351661150f565b34801561072d57600080fd5b5061065161153b565b34801561074257600080fd5b5061027f600160a060020a0360043581169060243516604435606435608435151561154b565b34801561077457600080fd5b506102b9600160a060020a0360043581169060243516611729565b34801561079b57600080fd5b506107b3600160a060020a0360043516602435611861565b604080519384526020840192909252151582820152519081900360600190f35b3480156107df57600080fd5b506102b9611957565b60408051808201909152600781527f4269744472617700000000000000000000000000000000000000000000000000602082015281565b33600081815261010760209081526040808320600160a060020a038716808552908352818420869055815186815291519394909390927f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925928290030190a350600192915050565b81600160a060020a038116151561089c57600080fd5b61010b5460ff1615156108ae57600080fd5b6000366040518083838082843782019150509250505060405180910390206108d5816119a4565b1561090057600160a060020a038416600090815261010960205260409020805460ff19168415151790555b50505050565b60008161091281610b4e565b151561091d57600080fd5b6001805403600081118015610933575060fa8111155b151561093e57600080fd5b60005460018054036000821180156109565750808211155b151561096157600080fd5b600036604051808383808284378201915050925050506040518091039020610988816119a4565b15610a5957610995611b5d565b61099d611ba8565b600160a060020a038716600090815261010260205260409020546109c090611c48565b9550600060028761010081106109d257fe5b01805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a03928316179055871660009081526101026020526040812055610a14611c66565b610a1c611b5d565b60408051600160a060020a038916815290517f58619076adf5bb0943d100ef88d52d7c3fd691b19d3a9071b555b651fbf418da9181900360200190a15b50505050505050565b6101055481565b61010b5460ff1681565b6000606036606414610a8457600080fd5b610a8e8584611e07565b610a99858585611f5c565b91505b509392505050565b600160a060020a03811660009081526101066020526040812054815b600160a060020a038416600090815261010a6020526040902054811015610b4357610aeb84826120ca565b15610b3b57600160a060020a038416600090815261010a602052604090208054610b38919083908110610b1a57fe5b6000918252602090912060029091020154839063ffffffff61221916565b91505b600101610ac0565b8192505b5050919050565b600160a060020a0316600090815261010260205260408120541190565b601281565b60015481565b6000602036602414610b8757600080fd5b610b913384611e07565b610b9a83612228565b9392505050565b6000610bac33610b4e565b1515610bb757600080fd5b5060015b90565b600084600160a060020a0381161515610bd657600080fd5b83635ab895768110158015610bef5750636b49d2008111155b1515610bfa57600080fd5b608036608414610c0957600080fd5b61010b5460ff161515610c1b57600080fd5b33610c258161232a565b1515610c3057600080fd5b33896000610c55610c4083610f2f565b610c4985610f2f565b9063ffffffff61221916565b33600090815261010660205260409020549091508b1115610c7557600080fd5b3360009081526101066020526040902054610c96908c63ffffffff61234916565b3360009081526101066020526040902055610cb38c8c8c8c61235b565b604080518c81529051600160a060020a038e169133916000805160206129018339815191529181900360200190a36001975080610cfb610cf284610f2f565b610c4986610f2f565b14610d0257fe5b50505050505050949350505050565b33600090815261010760209081526040808320600160a060020a038616845290915281205480831115610d685733600090815261010760209081526040808320600160a060020a0388168452909152812055610d9e565b610d78818463ffffffff61234916565b33600090815261010760209081526040808320600160a060020a03891684529091529020555b33600081815261010760209081526040808320600160a060020a0389168085529083529281902054815190815290519293927f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925929181900390910190a3600191505b5092915050565b80610e1181610b4e565b15610e1b57600080fd5b600154600101600081118015610e32575060fa8111155b1515610e3d57600080fd5b600036604051808383808284378201915050925050506040518091039020610e64816119a4565b1561090057610e71611b5d565b610e79611ba8565b6001805481019081905584906002906101008110610e9357fe5b01805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055600154610ecb90611c48565b600160a060020a03851660009081526101026020526040902055610eed611b5d565b60408051600160a060020a038616815290517f994a936646fe87ffe4f1e469d3d6aa417d6b855598397f323de5b449f765f0c39181900360200190a150505050565b600160a060020a03811660009081526101066020526040812054815b600160a060020a038416600090815261010a6020526040902054811015610b4357600160a060020a038416600090815261010a602052604090208054610f96919083908110610b1a57fe5b9150600101610f4b565b600160a060020a0316600090815261010a602052604090205490565b60005481565b61010a60205281600052604060002081815481101515610fde57fe5b6000918252602090912060029091020180546001909101549092506001608060020a0380821692507001000000000000000000000000000000009091041683565b60408051808201909152600481527f4254445700000000000000000000000000000000000000000000000000000000602082015281565b6060806000600154604051908082528060200260200182016040528015611087578160200160208202803883390190505b509150600090505b6001548110156110cf576110a281611341565b82828151811015156110b057fe5b600160a060020a0390921660209283029091019091015260010161108f565b50919050565b60006040366044146110e657600080fd5b6110f03384611e07565b6110fa8484612529565b949350505050565b6101096020526000908152604090205460ff1681565b60008082611125816125fe565b151561113057600080fd5b61113933610b4e565b151561114457600080fd5b61114d33612613565b600085815261010360205260408120600181015492955093509084161161117357600080fd5b61117c84612642565b81546001908101835582018054849003905561119784612642565b604080513381526020810186905281517fc7fb647e59b18047309aa15aad418e5d7ca96d173ad704f1031a2c3d7591734b929181900390910190a150505050565b806001546000821180156111ec5750808211155b15156111f757600080fd5b60003660405180838380828437820191505092505050604051809103902061121e816119a4565b15610900576000849055611230611ba8565b6040805185815290517facbdb084c721332ac59f9b8e392196c9eb0e4932862da8eb9beaf0dad4f550da9181900360200190a150505050565b80600160a060020a038116151561127f57600080fd5b61010b5460ff16151561129157600080fd5b6000366040518083838082843782019150509250505060405180910390206112b8816119a4565b156112e757610108805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0385161790555b505050565b6000826112f8816125fe565b151561130357600080fd5b8261130d81610b4e565b151561131857600080fd5b61132184612613565b600086815261010360205260409020600101541615159250505092915050565b6000600260018301610100811061135457fe5b0154600160a060020a031692915050565b61136f838361081f565b151561137a57600080fd5b82600160a060020a031663a2d578533384846040518463ffffffff167c01000000000000000000000000000000000000000000000000000000000281526004018084600160a060020a0316600160a060020a0316815260200183815260200180602001828103825283818151815260200191508051906020019080838360005b838110156114125781810151838201526020016113fa565b50505050905090810190601f16801561143f5780820380516001836020036101000a031916815260200191505b50945050505050600060405180830381600087803b15801561146057600080fd5b505af1158015610a59573d6000803e3d6000fd5b33600090815261010760209081526040808320600160a060020a03861684529091528120546114a9908363ffffffff61221916565b33600081815261010760209081526040808320600160a060020a0389168085529083529281902085905580519485525191937f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925929081900390910190a350600192915050565b600160a060020a0391821660009081526101076020908152604080832093909416825291909152205490565b61010854600160a060020a031681565b600084600160a060020a038116151561156357600080fd5b83635ab89576811015801561157c5750636b49d2008111155b151561158757600080fd5b60a03660a41461159657600080fd5b61010b5460ff1615156115a857600080fd5b888860006115b8610c4083610f2f565b90506115c33361232a565b80156115d357506115d38b61232a565b15156115de57600080fd5b600160a060020a038c166000908152610107602090815260408083203384529091529020548a111561160f57600080fd5b600160a060020a038c16600090815261010760209081526040808320338452909152902054611644908b63ffffffff61234916565b600160a060020a038d166000908152610107602090815260408083203384529091529020556116758c8b8b8b612690565b600160a060020a038b166000908152610106602052604090205461169f908b63ffffffff61221916565b61010660008d600160a060020a0316600160a060020a03168152602001908152602001600020819055508a600160a060020a03168c600160a060020a03166000805160206129018339815191528c6040518082815260200191505060405180910390a36001965080611713610cf284610f2f565b1461171a57fe5b50505050505095945050505050565b60008261173581610b4e565b151561174057600080fd5b8261174a81610b4e565b1561175457600080fd5b60003660405180838380828437820191505092505050604051809103902061177b816119a4565b1561185957611788611b5d565b611790611ba8565b600160a060020a038616600090815261010260205260409020546117b390611c48565b93508460028561010081106117c457fe5b01805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392831617905586811660009081526101026020526040808220829055918716815220849055611813611b5d565b60408051600160a060020a0380891682528716602082015281517fb532073b38c83145e3e5135377a08bf9aab55bc0fd7c1179cd4fb995d2a5159c929181900390910190a15b505050505050565b600080600061186f85610fa0565b841061187a57600080fd5b600160a060020a038516600090815261010a6020526040902080548590811061189f57fe5b60009182526020808320600290920290910154600160a060020a038816835261010a9091526040909120805491945090859081106118d957fe5b6000918252602080832060016002909302019190910154600160a060020a038816835261010a909152604090912080546001608060020a03909216935061194e918690811061192457fe5b906000526020600020906002020160010160109054906101000a90046001608060020a0316612758565b90509250925092565b61010b5460ff16151561196957600080fd5b600036604051808383808284378201915050925050506040518091039020611990816119a4565b156119a15761010b805460ff191690555b50565b60008060006119b233610b4e565b15156119bd57600080fd5b6101045461020014156119d2576119d2611ba8565b60008481526101036020526040902091506119ec846125fe565b1515611a3f57600080548355600180840191909155610104805491611a1391908301612858565b6002830181905561010480548692908110611a2a57fe5b600091825260209091200155611a3f84612642565b611a4833612613565b90508082600101541660001415610b47578154600010611a6457fe5b815460011415611b00576000848152610103602052604090206002015461010480549091908110611a9157fe5b60009182526020808320909101829055858252610103815260408083208381556001810184905560020192909255815133815290810186905281517f367569357efc39b74a025c4ba1d64068b2b574e3b0d081c48d42f7feeca4cd16929181900390910190a160019250610b47565b815460001901825560018201805482179055611b1b84612642565b604080513381526020810186905281517fe1c52dc63b719ade82e8bea94cc41a0d5d28e4aaf536adb5e9cccc9ff8c1aeda929181900390910190a15050919050565b600154600010611b6957fe5b60015460fa1015611b7657fe5b600254600160a060020a031615611b8957fe5b60005415801590611b9e575060015460005411155b1515611ba657fe5b565b600080611bb433610b4e565b1515611bbf57600080fd5b50506101045460005b81811015611c3757610104805482908110611bdf57fe5b60009182526020909120015415611c2f57610103600061010483815481101515611c0557fe5b60009182526020808320909101548352820192909252604001812081815560018101829055600201555b600101611bc8565b611c44610104600061287c565b5050565b60008115801590611c5a575060fa8211155b1515611c6257fe5b5090565b60015b6001548110156119a1575b60015481108015611c9c57506002816101008110611c8e57fe5b0154600160a060020a031615155b15611ca957600101611c74565b60018054118015611cd357506001546002906101008110611cc657fe5b0154600160a060020a0316155b15611ce75760018054600019019055611ca9565b60015481108015611d1257506001546002906101008110611d0457fe5b0154600160a060020a031615155b8015611d3457506002816101008110611d2757fe5b0154600160a060020a0316155b15611e02576001546002906101008110611d4a57fe5b0154600160a060020a03166002826101008110611d6357fe5b01805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a03929092169190911790558061010260006002836101008110611da357fe5b0154600160a060020a0316815260208101919091526040016000908120919091556001546002906101008110611dd557fe5b01805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a03929092169190911790555b611c69565b600160a060020a0382166000908152610106602052604081205481908311611e2e57610900565b82611e3885610aa4565b1015611e4357600080fd5b600091505b600160a060020a038416600090815261010a6020526040902054821015611f3957611e7384836120ca565b15611f2e57600160a060020a038416600090815261010a60205260409020805483908110611e9d57fe5b60009182526020808320600290920290910154600160a060020a038716835261010a9091526040822080549193509084908110611ed657fe5b60009182526020808320600290920290910192909255600160a060020a03861681526101069091526040902054611f13908263ffffffff61221916565b600160a060020a038516600090815261010660205260409020555b816001019150611e48565b600160a060020a0384166000908152610106602052604090205483111561090057fe5b6000600160a060020a0383161515611f7357600080fd5b600160a060020a03841660009081526101066020526040902054821115611f9957600080fd5b600160a060020a038416600090815261010760209081526040808320338452909152902054821115611fca57600080fd5b600160a060020a03841660009081526101066020526040902054611ff4908363ffffffff61234916565b600160a060020a0380861660009081526101066020526040808220939093559085168152205461202a908363ffffffff61221916565b600160a060020a0380851660009081526101066020908152604080832094909455918716815261010782528281203382529091522054612070908363ffffffff61234916565b600160a060020a038086166000818152610107602090815260408083203384528252918290209490945580518681529051928716939192600080516020612901833981519152929181900390910190a35060019392505050565b600160a060020a038216600090815261010a602052604081208054829190849081106120f257fe5b9060005260206000209060020201905061210a612766565b60018201546001608060020a031611156121275760009150610e00565b805415156121385760009150610e00565b60018101546121639070010000000000000000000000000000000090046001608060020a0316612758565b8015612201575061010854604080517fb35be68c000000000000000000000000000000000000000000000000000000008152600160a060020a0387811660048301529151919092169163b35be68c9160248083019260209291908290030181600087803b1580156121d357600080fd5b505af11580156121e7573d6000803e3d6000fd5b505050506040513d60208110156121fd57600080fd5b5051155b1561220f5760009150610e00565b5060019392505050565b600082820183811015610b9a57fe5b60003381831161223757600080fd5b600160a060020a0381166000908152610106602052604090205483111561225d57600080fd5b61010554612271908463ffffffff61234916565b61010555600160a060020a0381166000908152610106602052604090205461229f908463ffffffff61234916565b600160a060020a03821660008181526101066020908152604091829020939093558051868152905191927fcc16f5dbb4873280815c1ee09dbd06736cffcc184412cf7a71a0fdb75d397ca592918290030190a2604080518481529051600091600160a060020a038416916000805160206129018339815191529181900360200190a350600192915050565b600160a060020a03166000908152610109602052604090205460ff1690565b60008282111561235557fe5b50900390565b600080808087600160a060020a038116151561237657600080fd5b86635ab89576811015801561238f5750636b49d2008111155b151561239a57600080fd5b8795506123a68761276a565b94506123b38a8787612781565b600160a060020a038b16600090815261010a602052604090205490945084141561248757600160a060020a038a16600090815261010a60205260409020805490612400906001830161289a565b50600160a060020a038a16600090815261010a6020526040902080548590811061242657fe5b6000918252602090912060029091020180549093501561244257fe5b6001830180546001608060020a0387811670010000000000000000000000000000000002818a166fffffffffffffffffffffffffffffffff1990931692909217161790555b600160a060020a038a16600090815261010a602052604090208054859081106124ac57fe5b6000918252602090912060029091020160018101549093506001608060020a038781169116148015612501575060018301546001608060020a0386811670010000000000000000000000000000000090920416145b151561250957fe5b825461251b908a63ffffffff61221916565b909255505050505050505050565b6000600160a060020a038316151561254057600080fd5b336000908152610106602052604090205482111561255d57600080fd5b336000908152610106602052604090205461257e908363ffffffff61234916565b336000908152610106602052604080822092909255600160a060020a038516815220546125b1908363ffffffff61221916565b600160a060020a038416600081815261010660209081526040918290209390935580518581529051919233926000805160206129018339815191529281900390910190a350600192915050565b60009081526101036020526040902054151590565b600160a060020a03811660009081526101026020526040812054819061263890611c48565b60020a9392505050565b6000818152610103602052604090208054151561265b57fe5b60028101546101048054849290811061267057fe5b6000918252602090912001541461268357fe5b60005481541115611c4457fe5b60008083635ab8957681101580156126ac5750636b49d2008111155b15156126b757600080fd5b6126ca87866126c58761276a565b612781565b600160a060020a038816600090815261010a60205260409020549093508314156126f357600080fd5b600160a060020a038716600090815261010a6020526040902080548490811061271857fe5b906000526020600020906002020191508582600001541015151561273b57600080fd5b815461274d908763ffffffff61234916565b909155505050505050565b6001608060020a0316151590565b4290565b60008161277857600061277b565b60015b92915050565b6000805b600160a060020a038516600090815261010a602052604090205482101561283557600160a060020a038516600090815261010a602052604090208054839081106127cb57fe5b6000918252602090912060029091020160018101549091506001608060020a038581169116148015612820575060018101546001608060020a0384811670010000000000000000000000000000000090920416145b1561282a57612835565b816001019150612785565b600160a060020a038516600090815261010a6020526040902054821115610a9c57fe5b8154818355818111156112e7576000838152602090206112e79181019083016128c6565b50805460008255906000526020600020908101906119a191906128c6565b8154818355818111156112e7576002028160020283600052602060002091820191016112e791906128e0565b610bbb91905b80821115611c6257600081556001016128cc565b610bbb91905b80821115611c6257600080825560018201556002016128e65600ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa165627a7a72305820f070cb3872754571de06a3589ee7e6eaa05db2a12549c8a4d117e455cc14a6110029"
}