{
  "address": "0x4ec0cb5c73a9ed73ea821806f2701b29e6e44f0d",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "ForkTokenSale",
  "compilerVersion": "v0.4.25+commit.59dbf8f1",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2019-03-05\n*/\n\npragma solidity ^0.4.25;\n\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ninterface IERC20 {\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address who) external view returns (uint256);\n\n  function allowance(address owner, address spender)\n    external view returns (uint256);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function approve(address spender, uint256 value)\n    external returns (bool);\n\n  function transferFrom(address from, address to, uint256 value)\n    external returns (bool);\n\n  event Transfer(\n    address indexed from,\n    address indexed to,\n    uint256 value\n  );\n\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, reverts on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b);\n\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n  /**\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  /**\n  * @dev Adds two numbers, reverts on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a);\n\n    return c;\n  }\n\n  /**\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n  * reverts when dividing by zero.\n  */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0);\n    return a % b;\n  }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n * Originally based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract ERC20 is IERC20 {\n  using SafeMath for uint256;\n\n  mapping (address => uint256) private _balances;\n\n  mapping (address => mapping (address => uint256)) private _allowed;\n\n  uint256 private _totalSupply;\n\n  /**\n  * @dev Total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return _totalSupply;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param owner The address to query the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address owner) public view returns (uint256) {\n    return _balances[owner];\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param owner address The address which owns the funds.\n   * @param spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(\n    address owner,\n    address spender\n   )\n    public\n    view\n    returns (uint256)\n  {\n    return _allowed[owner][spender];\n  }\n\n  /**\n  * @dev Transfer token for a specified address\n  * @param to The address to transfer to.\n  * @param value The amount to be transferred.\n  */\n  function transfer(address to, uint256 value) public returns (bool) {\n    _transfer(msg.sender, to, value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param spender The address which will spend the funds.\n   * @param value The amount of tokens to be spent.\n   */\n  function approve(address spender, uint256 value) public returns (bool) {\n    require(spender != address(0));\n\n    _allowed[msg.sender][spender] = value;\n    emit Approval(msg.sender, spender, value);\n    return true;\n  }\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param from address The address which you want to send tokens from\n   * @param to address The address which you want to transfer to\n   * @param value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  )\n    public\n    returns (bool)\n  {\n    require(value <= _allowed[from][msg.sender]);\n\n    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n    _transfer(from, to, value);\n    return true;\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed_[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param spender The address which will spend the funds.\n   * @param addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseAllowance(\n    address spender,\n    uint256 addedValue\n  )\n    public\n    returns (bool)\n  {\n    require(spender != address(0));\n\n    _allowed[msg.sender][spender] = (\n      _allowed[msg.sender][spender].add(addedValue));\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed_[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param spender The address which will spend the funds.\n   * @param subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseAllowance(\n    address spender,\n    uint256 subtractedValue\n  )\n    public\n    returns (bool)\n  {\n    require(spender != address(0));\n\n    _allowed[msg.sender][spender] = (\n      _allowed[msg.sender][spender].sub(subtractedValue));\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n    return true;\n  }\n\n  /**\n  * @dev Transfer token for a specified addresses\n  * @param from The address to transfer from.\n  * @param to The address to transfer to.\n  * @param value The amount to be transferred.\n  */\n  function _transfer(address from, address to, uint256 value) internal {\n    require(value <= _balances[from]);\n    require(to != address(0));\n\n    _balances[from] = _balances[from].sub(value);\n    _balances[to] = _balances[to].add(value);\n    emit Transfer(from, to, value);\n  }\n\n  /**\n   * @dev Internal function that mints an amount of the token and assigns it to\n   * an account. This encapsulates the modification of balances such that the\n   * proper events are emitted.\n   * @param account The account that will receive the created tokens.\n   * @param value The amount that will be created.\n   */\n  function _mint(address account, uint256 value) internal {\n    require(account != 0);\n    _totalSupply = _totalSupply.add(value);\n    _balances[account] = _balances[account].add(value);\n    emit Transfer(address(0), account, value);\n  }\n\n  /**\n   * @dev Internal function that burns an amount of the token of a given\n   * account.\n   * @param account The account whose tokens will be burnt.\n   * @param value The amount that will be burnt.\n   */\n  function _burn(address account, uint256 value) internal {\n    require(account != 0);\n    require(value <= _balances[account]);\n\n    _totalSupply = _totalSupply.sub(value);\n    _balances[account] = _balances[account].sub(value);\n    emit Transfer(account, address(0), value);\n  }\n\n  /**\n   * @dev Internal function that burns an amount of the token of a given\n   * account, deducting from the sender's allowance for said account. Uses the\n   * internal burn function.\n   * @param account The account whose tokens will be burnt.\n   * @param value The amount that will be burnt.\n   */\n  function _burnFrom(address account, uint256 value) internal {\n    require(value <= _allowed[account][msg.sender]);\n\n    // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,\n    // this function needs to emit an event with the updated approval.\n    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(\n      value);\n    _burn(account, value);\n  }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n\n  using SafeMath for uint256;\n\n  function safeTransfer(\n    IERC20 token,\n    address to,\n    uint256 value\n  )\n    internal\n  {\n    require(token.transfer(to, value));\n  }\n\n  function safeTransferFrom(\n    IERC20 token,\n    address from,\n    address to,\n    uint256 value\n  )\n    internal\n  {\n    require(token.transferFrom(from, to, value));\n  }\n\n  function safeApprove(\n    IERC20 token,\n    address spender,\n    uint256 value\n  )\n    internal\n  {\n    // safeApprove should only be called when setting an initial allowance, \n    // or when resetting it to zero. To increase and decrease it, use \n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n    require((value == 0) || (token.allowance(address(this), spender) == 0));\n    require(token.approve(spender, value));\n  }\n\n  function safeIncreaseAllowance(\n    IERC20 token,\n    address spender,\n    uint256 value\n  )\n    internal\n  {\n    uint256 newAllowance = token.allowance(address(this), spender).add(value);\n    require(token.approve(spender, newAllowance));\n  }\n\n  function safeDecreaseAllowance(\n    IERC20 token,\n    address spender,\n    uint256 value\n  )\n    internal\n  {\n    uint256 newAllowance = token.allowance(address(this), spender).sub(value);\n    require(token.approve(spender, newAllowance));\n  }\n}\n\n// File: openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\n\n/**\n * @title Helps contracts guard against reentrancy attacks.\n * @author Remco Bloemen <[email protected]π.com>, Eenae <[email protected]>\n * @dev If you mark a function `nonReentrant`, you should also\n * mark it `external`.\n */\ncontract ReentrancyGuard {\n\n  /// @dev counter to allow mutex lock with only one SSTORE operation\n  uint256 private _guardCounter;\n\n  constructor() internal {\n    // The counter starts at one to prevent changing it from zero to a non-zero\n    // value, which is a more expensive operation.\n    _guardCounter = 1;\n  }\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   * Calling a `nonReentrant` function from another `nonReentrant`\n   * function is not supported. It is possible to prevent this from happening\n   * by making the `nonReentrant` function external, and make it call a\n   * `private` function that does the actual work.\n   */\n  modifier nonReentrant() {\n    _guardCounter += 1;\n    uint256 localCounter = _guardCounter;\n    _;\n    require(localCounter == _guardCounter);\n  }\n\n}\n\n// File: openzeppelin-solidity/contracts/crowdsale/Crowdsale.sol\n\n/**\n * @title Crowdsale\n * @dev Crowdsale is a base contract for managing a token crowdsale,\n * allowing investors to purchase tokens with ether. This contract implements\n * such functionality in its most fundamental form and can be extended to provide additional\n * functionality and/or custom behavior.\n * The external interface represents the basic interface for purchasing tokens, and conform\n * the base architecture for crowdsales. They are *not* intended to be modified / overridden.\n * The internal interface conforms the extensible and modifiable surface of crowdsales. Override\n * the methods to add functionality. Consider using 'super' where appropriate to concatenate\n * behavior.\n */\ncontract Crowdsale is ReentrancyGuard {\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n\n  // The token being sold\n  IERC20 private _token;\n\n  // Address where funds are collected\n  address private _wallet;\n\n  // How many token units a buyer gets per wei.\n  // The rate is the conversion between wei and the smallest and indivisible token unit.\n  // So, if you are using a rate of 1 with a ERC20Detailed token with 3 decimals called TOK\n  // 1 wei will give you 1 unit, or 0.001 TOK.\n  uint256 private _rate;\n\n  // Amount of wei raised\n  uint256 private _weiRaised;\n\n  /**\n   * Event for token purchase logging\n   * @param purchaser who paid for the tokens\n   * @param beneficiary who got the tokens\n   * @param value weis paid for purchase\n   * @param amount amount of tokens purchased\n   */\n  event TokensPurchased(\n    address indexed purchaser,\n    address indexed beneficiary,\n    uint256 value,\n    uint256 amount\n  );\n\n  /**\n   * @param rate Number of token units a buyer gets per wei\n   * @dev The rate is the conversion between wei and the smallest and indivisible\n   * token unit. So, if you are using a rate of 1 with a ERC20Detailed token\n   * with 3 decimals called TOK, 1 wei will give you 1 unit, or 0.001 TOK.\n   * @param wallet Address where collected funds will be forwarded to\n   * @param token Address of the token being sold\n   */\n  constructor(uint256 rate, address wallet, IERC20 token) internal {\n    require(rate > 0);\n    require(wallet != address(0));\n    require(token != address(0));\n\n    _rate = rate;\n    _wallet = wallet;\n    _token = token;\n  }\n\n  // -----------------------------------------\n  // Crowdsale external interface\n  // -----------------------------------------\n\n  /**\n   * @dev fallback function ***DO NOT OVERRIDE***\n   * Note that other contracts will transfer fund with a base gas stipend\n   * of 2300, which is not enough to call buyTokens. Consider calling\n   * buyTokens directly when purchasing tokens from a contract.\n   */\n  function () external payable {\n    buyTokens(msg.sender);\n  }\n\n  /**\n   * @return the token being sold.\n   */\n  function token() public view returns(IERC20) {\n    return _token;\n  }\n\n  /**\n   * @return the address where funds are collected.\n   */\n  function wallet() public view returns(address) {\n    return _wallet;\n  }\n\n  /**\n   * @return the number of token units a buyer gets per wei.\n   */\n  function rate() public view returns(uint256) {\n    return _rate;\n  }\n\n  /**\n   * @return the amount of wei raised.\n   */\n  function weiRaised() public view returns (uint256) {\n    return _weiRaised;\n  }\n\n  /**\n   * @dev low level token purchase ***DO NOT OVERRIDE***\n   * This function has a non-reentrancy guard, so it shouldn't be called by\n   * another `nonReentrant` function.\n   * @param beneficiary Recipient of the token purchase\n   */\n  function buyTokens(address beneficiary) public nonReentrant payable {\n\n    uint256 weiAmount = msg.value;\n    _preValidatePurchase(beneficiary, weiAmount);\n\n    // calculate token amount to be created\n    uint256 tokens = _getTokenAmount(weiAmount);\n\n    // update state\n    _weiRaised = _weiRaised.add(weiAmount);\n\n    _processPurchase(beneficiary, tokens);\n    emit TokensPurchased(\n      msg.sender,\n      beneficiary,\n      weiAmount,\n      tokens\n    );\n\n    _updatePurchasingState(beneficiary, weiAmount);\n\n    _forwardFunds();\n    _postValidatePurchase(beneficiary, weiAmount);\n  }\n\n  // -----------------------------------------\n  // Internal interface (extensible)\n  // -----------------------------------------\n\n  /**\n   * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use `super` in contracts that inherit from Crowdsale to extend their validations.\n   * Example from CappedCrowdsale.sol's _preValidatePurchase method:\n   *   super._preValidatePurchase(beneficiary, weiAmount);\n   *   require(weiRaised().add(weiAmount) <= cap);\n   * @param beneficiary Address performing the token purchase\n   * @param weiAmount Value in wei involved in the purchase\n   */\n  function _preValidatePurchase(\n    address beneficiary,\n    uint256 weiAmount\n  )\n    internal\n    view\n  {\n    require(beneficiary != address(0));\n    require(weiAmount != 0);\n  }\n\n  /**\n   * @dev Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid conditions are not met.\n   * @param beneficiary Address performing the token purchase\n   * @param weiAmount Value in wei involved in the purchase\n   */\n  function _postValidatePurchase(\n    address beneficiary,\n    uint256 weiAmount\n  )\n    internal\n    view\n  {\n    // optional override\n  }\n\n  /**\n   * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.\n   * @param beneficiary Address performing the token purchase\n   * @param tokenAmount Number of tokens to be emitted\n   */\n  function _deliverTokens(\n    address beneficiary,\n    uint256 tokenAmount\n  )\n    internal\n  {\n    _token.safeTransfer(beneficiary, tokenAmount);\n  }\n\n  /**\n   * @dev Executed when a purchase has been validated and is ready to be executed. Doesn't necessarily emit/send tokens.\n   * @param beneficiary Address receiving the tokens\n   * @param tokenAmount Number of tokens to be purchased\n   */\n  function _processPurchase(\n    address beneficiary,\n    uint256 tokenAmount\n  )\n    internal\n  {\n    _deliverTokens(beneficiary, tokenAmount);\n  }\n\n  /**\n   * @dev Override for extensions that require an internal state to check for validity (current user contributions, etc.)\n   * @param beneficiary Address receiving the tokens\n   * @param weiAmount Value in wei involved in the purchase\n   */\n  function _updatePurchasingState(\n    address beneficiary,\n    uint256 weiAmount\n  )\n    internal\n  {\n    // optional override\n  }\n\n  /**\n   * @dev Override to extend the way in which ether is converted to tokens.\n   * @param weiAmount Value in wei to be converted into tokens\n   * @return Number of tokens that can be purchased with the specified _weiAmount\n   */\n  function _getTokenAmount(uint256 weiAmount)\n    internal view returns (uint256)\n  {\n    return weiAmount.mul(_rate);\n  }\n\n  /**\n   * @dev Determines how ETH is stored/forwarded on purchases.\n   */\n  function _forwardFunds() internal {\n    _wallet.transfer(msg.value);\n  }\n}\n\n// File: openzeppelin-solidity/contracts/crowdsale/validation/TimedCrowdsale.sol\n\n/**\n * @title TimedCrowdsale\n * @dev Crowdsale accepting contributions only within a time frame.\n */\ncontract TimedCrowdsale is Crowdsale {\n  using SafeMath for uint256;\n\n  uint256 private _openingTime;\n  uint256 private _closingTime;\n\n  /**\n   * @dev Reverts if not in crowdsale time range.\n   */\n  modifier onlyWhileOpen {\n    require(isOpen());\n    _;\n  }\n\n  /**\n   * @dev Constructor, takes crowdsale opening and closing times.\n   * @param openingTime Crowdsale opening time\n   * @param closingTime Crowdsale closing time\n   */\n  constructor(uint256 openingTime, uint256 closingTime) internal {\n    // solium-disable-next-line security/no-block-members\n    require(openingTime >= block.timestamp);\n    require(closingTime > openingTime);\n\n    _openingTime = openingTime;\n    _closingTime = closingTime;\n  }\n\n  /**\n   * @return the crowdsale opening time.\n   */\n  function openingTime() public view returns(uint256) {\n    return _openingTime;\n  }\n\n  /**\n   * @return the crowdsale closing time.\n   */\n  function closingTime() public view returns(uint256) {\n    return _closingTime;\n  }\n\n  /**\n   * @return true if the crowdsale is open, false otherwise.\n   */\n  function isOpen() public view returns (bool) {\n    // solium-disable-next-line security/no-block-members\n    return block.timestamp >= _openingTime && block.timestamp <= _closingTime;\n  }\n\n  /**\n   * @dev Checks whether the period in which the crowdsale is open has already elapsed.\n   * @return Whether crowdsale period has elapsed\n   */\n  function hasClosed() public view returns (bool) {\n    // solium-disable-next-line security/no-block-members\n    return block.timestamp > _closingTime;\n  }\n\n  /**\n   * @dev Extend parent behavior requiring to be within contributing period\n   * @param beneficiary Token purchaser\n   * @param weiAmount Amount of wei contributed\n   */\n  function _preValidatePurchase(\n    address beneficiary,\n    uint256 weiAmount\n  )\n    internal\n    onlyWhileOpen\n    view\n  {\n    super._preValidatePurchase(beneficiary, weiAmount);\n  }\n\n}\n\n// File: openzeppelin-solidity/contracts/crowdsale/validation/CappedCrowdsale.sol\n\n/**\n * @title CappedCrowdsale\n * @dev Crowdsale with a limit for total contributions.\n */\ncontract CappedCrowdsale is Crowdsale {\n  using SafeMath for uint256;\n\n  uint256 private _cap;\n\n  /**\n   * @dev Constructor, takes maximum amount of wei accepted in the crowdsale.\n   * @param cap Max amount of wei to be contributed\n   */\n  constructor(uint256 cap) internal {\n    require(cap > 0);\n    _cap = cap;\n  }\n\n  /**\n   * @return the cap of the crowdsale.\n   */\n  function cap() public view returns(uint256) {\n    return _cap;\n  }\n\n  /**\n   * @dev Checks whether the cap has been reached.\n   * @return Whether the cap was reached\n   */\n  function capReached() public view returns (bool) {\n    return weiRaised() >= _cap;\n  }\n\n  /**\n   * @dev Extend parent behavior requiring purchase to respect the funding cap.\n   * @param beneficiary Token purchaser\n   * @param weiAmount Amount of wei contributed\n   */\n  function _preValidatePurchase(\n    address beneficiary,\n    uint256 weiAmount\n  )\n    internal\n    view\n  {\n    super._preValidatePurchase(beneficiary, weiAmount);\n    require(weiRaised().add(weiAmount) <= _cap);\n  }\n\n}\n\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address private _owner;\n\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  constructor() internal {\n    _owner = msg.sender;\n    emit OwnershipTransferred(address(0), _owner);\n  }\n\n  /**\n   * @return the address of the owner.\n   */\n  function owner() public view returns(address) {\n    return _owner;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(isOwner());\n    _;\n  }\n\n  /**\n   * @return true if `msg.sender` is the owner of the contract.\n   */\n  function isOwner() public view returns(bool) {\n    return msg.sender == _owner;\n  }\n\n  /**\n   * @dev Allows the current owner to relinquish control of the contract.\n   * @notice Renouncing to ownership will leave the contract without an owner.\n   * It will not be possible to call the functions with the `onlyOwner`\n   * modifier anymore.\n   */\n  function renounceOwnership() public onlyOwner {\n    emit OwnershipTransferred(_owner, address(0));\n    _owner = address(0);\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    _transferOwnership(newOwner);\n  }\n\n  /**\n   * @dev Transfers control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function _transferOwnership(address newOwner) internal {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(_owner, newOwner);\n    _owner = newOwner;\n  }\n}\n\n// File: eth-token-recover/contracts/TokenRecover.sol\n\n/**\n * @title TokenRecover\n * @author Vittorio Minacori (https://github.com/vittominacori)\n * @dev Allow to recover any ERC20 sent into the contract for error\n */\ncontract TokenRecover is Ownable {\n\n  /**\n   * @dev Remember that only owner can call so be careful when use on contracts generated from other contracts.\n   * @param tokenAddress The token contract address\n   * @param tokenAmount Number of tokens to be sent\n   */\n  function recoverERC20(\n    address tokenAddress,\n    uint256 tokenAmount\n  )\n    public\n    onlyOwner\n  {\n    IERC20(tokenAddress).transfer(owner(), tokenAmount);\n  }\n}\n\n// File: openzeppelin-solidity/contracts/access/Roles.sol\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n  struct Role {\n    mapping (address => bool) bearer;\n  }\n\n  /**\n   * @dev give an account access to this role\n   */\n  function add(Role storage role, address account) internal {\n    require(account != address(0));\n    require(!has(role, account));\n\n    role.bearer[account] = true;\n  }\n\n  /**\n   * @dev remove an account's access to this role\n   */\n  function remove(Role storage role, address account) internal {\n    require(account != address(0));\n    require(has(role, account));\n\n    role.bearer[account] = false;\n  }\n\n  /**\n   * @dev check if an account has this role\n   * @return bool\n   */\n  function has(Role storage role, address account)\n    internal\n    view\n    returns (bool)\n  {\n    require(account != address(0));\n    return role.bearer[account];\n  }\n}\n\n// File: ico-maker/contracts/access/roles/OperatorRole.sol\n\ncontract OperatorRole {\n  using Roles for Roles.Role;\n\n  event OperatorAdded(address indexed account);\n  event OperatorRemoved(address indexed account);\n\n  Roles.Role private _operators;\n\n  constructor() internal {\n    _addOperator(msg.sender);\n  }\n\n  modifier onlyOperator() {\n    require(isOperator(msg.sender));\n    _;\n  }\n\n  function isOperator(address account) public view returns (bool) {\n    return _operators.has(account);\n  }\n\n  function addOperator(address account) public onlyOperator {\n    _addOperator(account);\n  }\n\n  function renounceOperator() public {\n    _removeOperator(msg.sender);\n  }\n\n  function _addOperator(address account) internal {\n    _operators.add(account);\n    emit OperatorAdded(account);\n  }\n\n  function _removeOperator(address account) internal {\n    _operators.remove(account);\n    emit OperatorRemoved(account);\n  }\n}\n\n// File: ico-maker/contracts/crowdsale/utils/Contributions.sol\n\n/**\n * @title Contributions\n * @author Vittorio Minacori (https://github.com/vittominacori)\n * @dev Utility contract where to save any information about Crowdsale contributions\n */\ncontract Contributions is OperatorRole, TokenRecover {\n\n  using SafeMath for uint256;\n\n  struct Contributor {\n    uint256 weiAmount;\n    uint256 tokenAmount;\n    bool exists;\n  }\n\n  // the number of sold tokens\n  uint256 private _totalSoldTokens;\n\n  // the number of wei raised\n  uint256 private _totalWeiRaised;\n\n  // list of addresses who contributed in crowdsales\n  address[] private _addresses;\n\n  // map of contributors\n  mapping(address => Contributor) private _contributors;\n\n  constructor() public {}\n\n  /**\n   * @return the number of sold tokens\n   */\n  function totalSoldTokens() public view returns(uint256) {\n    return _totalSoldTokens;\n  }\n\n  /**\n   * @return the number of wei raised\n   */\n  function totalWeiRaised() public view returns(uint256) {\n    return _totalWeiRaised;\n  }\n\n  /**\n   * @return address of a contributor by list index\n   */\n  function getContributorAddress(uint256 index) public view returns(address) {\n    return _addresses[index];\n  }\n\n  /**\n   * @dev return the contributions length\n   * @return uint\n   */\n  function getContributorsLength() public view returns (uint) {\n    return _addresses.length;\n  }\n\n  /**\n   * @dev get wei contribution for the given address\n   * @param account Address has contributed\n   * @return uint256\n   */\n  function weiContribution(address account) public view returns (uint256) {\n    return _contributors[account].weiAmount;\n  }\n\n  /**\n   * @dev get token balance for the given address\n   * @param account Address has contributed\n   * @return uint256\n   */\n  function tokenBalance(address account) public view returns (uint256) {\n    return _contributors[account].tokenAmount;\n  }\n\n  /**\n   * @dev check if a contributor exists\n   * @param account The address to check\n   * @return bool\n   */\n  function contributorExists(address account) public view returns (bool) {\n    return _contributors[account].exists;\n  }\n\n  /**\n   * @dev add contribution into the contributions array\n   * @param account Address being contributing\n   * @param weiAmount Amount of wei contributed\n   * @param tokenAmount Amount of token received\n   */\n  function addBalance(\n    address account,\n    uint256 weiAmount,\n    uint256 tokenAmount\n  )\n    public\n    onlyOperator\n  {\n    if (!_contributors[account].exists) {\n      _addresses.push(account);\n      _contributors[account].exists = true;\n    }\n\n    _contributors[account].weiAmount = _contributors[account].weiAmount.add(weiAmount);\n    _contributors[account].tokenAmount = _contributors[account].tokenAmount.add(tokenAmount);\n\n    _totalWeiRaised = _totalWeiRaised.add(weiAmount);\n    _totalSoldTokens = _totalSoldTokens.add(tokenAmount);\n  }\n\n  /**\n   * @dev remove the `operator` role from address\n   * @param account Address you want to remove role\n   */\n  function removeOperator(address account) public onlyOwner {\n    _removeOperator(account);\n  }\n}\n\n// File: ico-maker/contracts/crowdsale/BaseCrowdsale.sol\n\n/**\n * @title BaseCrowdsale\n * @author Vittorio Minacori (https://github.com/vittominacori)\n * @dev Extends from Crowdsale with more stuffs like TimedCrowdsale, CappedCrowdsale.\n *  Base for any other Crowdsale contract\n */\ncontract BaseCrowdsale is TimedCrowdsale, CappedCrowdsale, TokenRecover {\n\n  // reference to Contributions contract\n  Contributions private _contributions;\n\n  // the minimum value of contribution in wei\n  uint256 private _minimumContribution;\n\n  /**\n   * @dev Reverts if less than minimum contribution\n   */\n  modifier onlyGreaterThanMinimum(uint256 weiAmount) {\n    require(weiAmount >= _minimumContribution);\n    _;\n  }\n\n  /**\n   * @param openingTime Crowdsale opening time\n   * @param closingTime Crowdsale closing time\n   * @param rate Number of token units a buyer gets per wei\n   * @param wallet Address where collected funds will be forwarded to\n   * @param cap Max amount of wei to be contributed\n   * @param minimumContribution Min amount of wei to be contributed\n   * @param token Address of the token being sold\n   * @param contributions Address of the contributions contract\n   */\n  constructor(\n    uint256 openingTime,\n    uint256 closingTime,\n    uint256 rate,\n    address wallet,\n    uint256 cap,\n    uint256 minimumContribution,\n    address token,\n    address contributions\n  )\n    public\n    Crowdsale(rate, wallet, ERC20(token))\n    TimedCrowdsale(openingTime, closingTime)\n    CappedCrowdsale(cap)\n  {\n    require(contributions != address(0));\n    _contributions = Contributions(contributions);\n    _minimumContribution = minimumContribution;\n  }\n\n  /**\n   * @return the crowdsale contributions contract\n   */\n  function contributions() public view returns(Contributions) {\n    return _contributions;\n  }\n\n  /**\n   * @return the minimum value of contribution in wei\n   */\n  function minimumContribution() public view returns(uint256) {\n    return _minimumContribution;\n  }\n\n  /**\n   * @dev false if the ico is not started, true if the ico is started and running, true if the ico is completed\n   * @return bool\n   */\n  function started() public view returns(bool) {\n    return block.timestamp >= openingTime(); // solhint-disable-line not-rely-on-time\n  }\n\n  /**\n   * @dev false if the ico is not started, false if the ico is started and running, true if the ico is completed\n   * @return bool\n   */\n  function ended() public view returns(bool) {\n    return hasClosed() || capReached();\n  }\n\n  /**\n   * @dev Extend parent behavior requiring purchase to respect the minimumContribution.\n   * @param beneficiary Token purchaser\n   * @param weiAmount Amount of wei contributed\n   */\n  function _preValidatePurchase(\n    address beneficiary,\n    uint256 weiAmount\n  )\n    internal\n    onlyGreaterThanMinimum(weiAmount)\n    view\n  {\n    super._preValidatePurchase(beneficiary, weiAmount);\n  }\n\n  /**\n   * @dev Update the contributions contract states\n   * @param beneficiary Address receiving the tokens\n   * @param weiAmount Value in wei involved in the purchase\n   */\n  function _updatePurchasingState(\n    address beneficiary,\n    uint256 weiAmount\n  )\n    internal\n  {\n    super._updatePurchasingState(beneficiary, weiAmount);\n    _contributions.addBalance(\n      beneficiary,\n      weiAmount,\n      _getTokenAmount(weiAmount)\n    );\n  }\n}\n\n// File: contracts/crowdsale/ForkTokenSale.sol\n\n/**\n * @title ForkTokenSale\n * @author Vittorio Minacori (https://github.com/vittominacori)\n * @dev Extends from BaseCrowdsale with the ability to change rate\n */\ncontract ForkTokenSale is BaseCrowdsale {\n\n  uint256 private _currentRate;\n\n  uint256 private _soldTokens;\n\n  constructor(\n    uint256 openingTime,\n    uint256 closingTime,\n    uint256 rate,\n    address wallet,\n    uint256 cap,\n    uint256 minimumContribution,\n    address token,\n    address contributions\n  )\n    public\n    BaseCrowdsale(\n      openingTime,\n      closingTime,\n      rate,\n      wallet,\n      cap,\n      minimumContribution,\n      token,\n      contributions\n    )\n  {\n    _currentRate = rate;\n  }\n\n  /**\n   * @dev Function to update rate\n   * @param newRate The rate is the conversion between wei and the smallest and indivisible token unit\n   */\n  function setRate(uint256 newRate) public onlyOwner {\n    require(newRate > 0);\n    _currentRate = newRate;\n  }\n\n  /**\n   * @return the number of token units a buyer gets per wei.\n   */\n  function rate() public view returns(uint256) {\n    return _currentRate;\n  }\n\n  /**\n   * @return the number of sold tokens.\n   */\n  function soldTokens() public view returns(uint256) {\n    return _soldTokens;\n  }\n\n  /**\n   * @dev Override to extend the way in which ether is converted to tokens.\n   * @param weiAmount Value in wei to be converted into tokens\n   * @return Number of tokens that can be purchased with the specified _weiAmount\n   */\n  function _getTokenAmount(uint256 weiAmount) internal view returns (uint256) {\n    return weiAmount.mul(rate());\n  }\n\n  /**\n   * @dev Update the contributions contract states\n   * @param beneficiary Address receiving the tokens\n   * @param weiAmount Value in wei involved in the purchase\n   */\n  function _updatePurchasingState(\n    address beneficiary,\n    uint256 weiAmount\n  )\n    internal\n  {\n    _soldTokens = _soldTokens.add(_getTokenAmount(weiAmount));\n    super._updatePurchasingState(beneficiary, weiAmount);\n  }\n}",
  "bytecode": "608060405234801561001057600080fd5b5060405161010080610b4c83398101604090815281516020830151918301516060840151608085015160a086015160c087015160e09097015160016000908155959794959394929391929188908890889088908890889088908890849089908990899089908790831161008257600080fd5b600160a060020a038216151561009757600080fd5b600160a060020a03811615156100ac57600080fd5b60039290925560028054600160a060020a03928316600160a060020a03199182161790915560018054929093169116179055428210156100eb57600080fd5b8181116100f757600080fd5b6005919091556006556000811161010d57600080fd5b60075560088054600160a060020a031916331790819055604051600160a060020a0391909116906000907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0908290a3600160a060020a038116151561017157600080fd5b60098054600160a060020a03909216600160a060020a031990921691909117905550600a55505050600b97909755505050505050505050610995806101b76000396000f30060806040526004361061010e5763ffffffff60e060020a600035041663029eabcb811461011957806312fa6feb1461014a5780631515bc2b146101735780631f2698ab146101885780632c4e722e1461019d57806334fcf437146101c4578063355274ea146101dc5780634042b66f146101f157806347535d7b146102065780634b6753bc1461021b5780634f93594514610230578063521eb273146102455780635ed9ebfc1461025a578063715018a61461026f5780638980f11f146102845780638da5cb5b146102a85780638f32d59b146102bd578063937e09b1146102d2578063b7a8807c146102e7578063ec8ac4d8146102fc578063f2fde38b14610310578063fc0c546a14610331575b61011733610346565b005b34801561012557600080fd5b5061012e610401565b60408051600160a060020a039092168252519081900360200190f35b34801561015657600080fd5b5061015f610410565b604080519115158252519081900360200190f35b34801561017f57600080fd5b5061015f61042d565b34801561019457600080fd5b5061015f610435565b3480156101a957600080fd5b506101b2610447565b60408051918252519081900360200190f35b3480156101d057600080fd5b5061011760043561044d565b3480156101e857600080fd5b506101b2610472565b3480156101fd57600080fd5b506101b2610478565b34801561021257600080fd5b5061015f61047e565b34801561022757600080fd5b506101b2610497565b34801561023c57600080fd5b5061015f61049d565b34801561025157600080fd5b5061012e6104b1565b34801561026657600080fd5b506101b26104c0565b34801561027b57600080fd5b506101176104c6565b34801561029057600080fd5b50610117600160a060020a0360043516602435610530565b3480156102b457600080fd5b5061012e6105d7565b3480156102c957600080fd5b5061015f6105e6565b3480156102de57600080fd5b506101b26105f7565b3480156102f357600080fd5b506101b26105fd565b610117600160a060020a0360043516610346565b34801561031c57600080fd5b50610117600160a060020a0360043516610603565b34801561033d57600080fd5b5061012e610622565b6000805460010180825534919061035d8484610631565b61036683610651565b60045490925061037c908463ffffffff61067116565b600455610389848361068e565b60408051848152602081018490528151600160a060020a0387169233927f6faf93231a456e552dbc9961f58d9713ee4f2e69d15f1975b050ef0911053a7b929081900390910190a36103db848461069c565b6103e36106c4565b6103ed8484610698565b60005481146103fb57600080fd5b50505050565b600954600160a060020a031690565b600061041a61042d565b80610428575061042861049d565b905090565b600654421190565b600061043f6105fd565b421015905090565b600b5490565b6104556105e6565b151561046057600080fd5b6000811161046d57600080fd5b600b55565b60075490565b60045490565b6000600554421015801561042857505060065442111590565b60065490565b60006007546104aa610478565b1015905090565b600254600160a060020a031690565b600c5490565b6104ce6105e6565b15156104d957600080fd5b600854604051600091600160a060020a0316907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0908390a36008805473ffffffffffffffffffffffffffffffffffffffff19169055565b6105386105e6565b151561054357600080fd5b81600160a060020a031663a9059cbb61055a6105d7565b836040518363ffffffff1660e060020a0281526004018083600160a060020a0316600160a060020a0316815260200182815260200192505050602060405180830381600087803b1580156105ad57600080fd5b505af11580156105c1573d6000803e3d6000fd5b505050506040513d60208110156103fb57600080fd5b600854600160a060020a031690565b600854600160a060020a0316331490565b600a5490565b60055490565b61060b6105e6565b151561061657600080fd5b61061f816106fd565b50565b600154600160a060020a031690565b600a54819081101561064257600080fd5b61064c838361077b565b505050565b600061066b61065e610447565b839063ffffffff6107ab16565b92915050565b60008282018381101561068357600080fd5b8091505b5092915050565b61069882826107d9565b5050565b6106b76106a882610651565b600c549063ffffffff61067116565b600c5561069882826107f6565b600254604051600160a060020a03909116903480156108fc02916000818181858888f1935050505015801561061f573d6000803e3d6000fd5b600160a060020a038116151561071257600080fd5b600854604051600160a060020a038084169216907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a36008805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b6107858282610891565b6007546107a082610794610478565b9063ffffffff61067116565b111561069857600080fd5b6000808315156107be5760009150610687565b508282028284828115156107ce57fe5b041461068357600080fd5b60015461069890600160a060020a0316838363ffffffff6108ae16565b6108008282610698565b600954600160a060020a031663cfad7410838361081c81610651565b6040518463ffffffff1660e060020a0281526004018084600160a060020a0316600160a060020a031681526020018381526020018281526020019350505050600060405180830381600087803b15801561087557600080fd5b505af1158015610889573d6000803e3d6000fd5b505050505050565b61089961047e565b15156108a457600080fd5b6106988282610948565b82600160a060020a031663a9059cbb83836040518363ffffffff1660e060020a0281526004018083600160a060020a0316600160a060020a0316815260200182815260200192505050602060405180830381600087803b15801561091157600080fd5b505af1158015610925573d6000803e3d6000fd5b505050506040513d602081101561093b57600080fd5b5051151561064c57600080fd5b600160a060020a038216151561095d57600080fd5b80151561069857600080fd00a165627a7a72305820890871690d757a0138c68ca38451ee2b17afb8b2005c77d8854f455ff2e5bced0029000000000000000000000000000000000000000000000000000000005c824b30000000000000000000000000000000000000000000000000000000005d188820000000000000000000000000000000000000000000000000000000000000f6180000000000000000000000005dc43e28ae90fc2888c67d1770eff4f34b814f1e00000000000000000000000000000000000000000000003635c9adc5dea00000000000000000000000000000000000000000000000000000016345785d8a00000000000000000000000000005bb1632fa0023e1aa76a1ae92b4635c8dba49fa2000000000000000000000000d44fb08008d35e1310319b17aef355a432edd123",
  "constructorArguments": "000000000000000000000000000000000000000000000000000000005c824b30000000000000000000000000000000000000000000000000000000005d188820000000000000000000000000000000000000000000000000000000000000f6180000000000000000000000005dc43e28ae90fc2888c67d1770eff4f34b814f1e00000000000000000000000000000000000000000000003635c9adc5dea00000000000000000000000000000000000000000000000000000016345785d8a00000000000000000000000000005bb1632fa0023e1aa76a1ae92b4635c8dba49fa2000000000000000000000000d44fb08008d35e1310319b17aef355a432edd123"
}