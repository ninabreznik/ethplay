{
  "address": "0xb64db2153861ddde62c8038c6a3c6199fcfbd094",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "MarketplaceProxy",
  "compilerVersion": "v0.5.7+commit.6da8b019",
  "optimization": false,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2019-04-28\n*/\n\npragma solidity ^0.5.0;\n\ncontract DSMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x);\n    }\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x);\n    }\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n\n    function min(uint x, uint y) internal pure returns (uint z) {\n        return x <= y ? x : y;\n    }\n    function max(uint x, uint y) internal pure returns (uint z) {\n        return x >= y ? x : y;\n    }\n    function imin(int x, int y) internal pure returns (int z) {\n        return x <= y ? x : y;\n    }\n    function imax(int x, int y) internal pure returns (int z) {\n        return x >= y ? x : y;\n    }\n\n    uint constant WAD = 10 ** 18;\n    uint constant RAY = 10 ** 27;\n\n    function wmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n    function rmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    // This famous algorithm is called \"exponentiation by squaring\"\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\n    //\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\n    //\n    // These facts are why it works:\n    //\n    //  If n is even, then x^n = (x^2)^(n/2).\n    //  If n is odd,  then x^n = x * x^(n-1),\n    //   and applying the equation for even x gives\n    //    x^n = x * (x^2)^((n-1) / 2).\n    //\n    //  Also, EVM division is flooring and\n    //    floor[(n-1) / 2] = floor[n / 2].\n    //\n    function rpow(uint x, uint n) internal pure returns (uint z) {\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n}\n\ncontract TokenInterface {\n    function allowance(address, address) public returns (uint);\n    function balanceOf(address) public returns (uint);\n    function approve(address, uint) public;\n    function transfer(address, uint) public returns (bool);\n    function transferFrom(address, address, uint) public returns (bool);\n    function deposit() public payable;\n    function withdraw(uint) public;\n}\n\ncontract PipInterface {\n    function read() public returns (bytes32);\n}\n\ncontract PepInterface {\n    function peek() public returns (bytes32, bool);\n}\n\ncontract VoxInterface {\n    function par() public returns (uint);\n}\n\ncontract TubInterface {\n    event LogNewCup(address indexed lad, bytes32 cup);\n\n    function open() public returns (bytes32);\n    function join(uint) public;\n    function exit(uint) public;\n    function lock(bytes32, uint) public;\n    function free(bytes32, uint) public;\n    function draw(bytes32, uint) public;\n    function wipe(bytes32, uint) public;\n    function give(bytes32, address) public;\n    function shut(bytes32) public;\n    function bite(bytes32) public;\n    function cups(bytes32) public returns (address, uint, uint, uint);\n    function gem() public returns (TokenInterface);\n    function gov() public returns (TokenInterface);\n    function skr() public returns (TokenInterface);\n    function sai() public returns (TokenInterface);\n    function vox() public returns (VoxInterface);\n    function ask(uint) public returns (uint);\n    function mat() public returns (uint);\n    function chi() public returns (uint);\n    function ink(bytes32) public returns (uint);\n    function tab(bytes32) public returns (uint);\n    function rap(bytes32) public returns (uint);\n    function per() public returns (uint);\n    function pip() public returns (PipInterface);\n    function pep() public returns (PepInterface);\n    function tag() public returns (uint);\n    function drip() public;\n    function lad(bytes32 cup) public view returns (address);\n}\n\ncontract DSGuard {\n    function canCall(address src_, address dst_, bytes4 sig) public view returns (bool);\n\n    function permit(bytes32 src, bytes32 dst, bytes32 sig) public;\n    function forbid(bytes32 src, bytes32 dst, bytes32 sig) public;\n\n    function permit(address src, address dst, bytes32 sig) public;\n    function forbid(address src, address dst, bytes32 sig) public;\n\n}\n\ncontract DSGuardFactory {\n    function newGuard() public returns (DSGuard guard);\n}\n\ncontract DSAuthEvents {\n    event LogSetAuthority (address indexed authority);\n    event LogSetOwner     (address indexed owner);\n}\n\ncontract DSAuthority {\n    function canCall(\n        address src, address dst, bytes4 sig\n    ) public view returns (bool);\n}\n\ncontract DSAuth is DSAuthEvents {\n    DSAuthority  public  authority;\n    address      public  owner;\n\n    constructor() public {\n        owner = msg.sender;\n        emit LogSetOwner(msg.sender);\n    }\n\n    function setOwner(address owner_)\n        public\n        auth\n    {\n        owner = owner_;\n        emit LogSetOwner(owner);\n    }\n\n    function setAuthority(DSAuthority authority_)\n        public\n        auth\n    {\n        authority = authority_;\n        emit LogSetAuthority(address(authority));\n    }\n\n    modifier auth {\n        require(isAuthorized(msg.sender, msg.sig));\n        _;\n    }\n\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else if (authority == DSAuthority(0)) {\n            return false;\n        } else {\n            return authority.canCall(src, address(this), sig);\n        }\n    }\n}\n\ncontract DSProxyInterface {\n    function execute(bytes memory _code, bytes memory _data) public payable returns (address, bytes32);\n\n    function execute(address _target, bytes memory _data) public payable returns (bytes32);\n\n    function setCache(address _cacheAddr) public payable returns (bool);\n\n    function owner() public returns (address);\n}\n\n\ncontract ProxyRegistryInterface {\n    function proxies(address _owner) public view returns(DSProxyInterface);\n    function build(address) public returns (address);\n}\n\ncontract Marketplace is DSAuth, DSMath {\n\n    struct SaleItem {\n        address payable owner;\n        address payable proxy;\n        uint discount;\n        bool active;\n    }\n \n    mapping (bytes32 => SaleItem) public items;\n    mapping (bytes32 => uint) public itemPos;\n    bytes32[] public itemsArr;\n\n    address public marketplaceProxy;\n\n    // 2 decimal percision when defining the disocunt value\n    uint public fee = 100; //1% fee\n\n    // KOVAN\n    // ProxyRegistryInterface public registry = ProxyRegistryInterface(0x64A436ae831C1672AE81F674CAb8B6775df3475C);\n    // TubInterface public tub = TubInterface(0xa71937147b55Deb8a530C7229C442Fd3F31b7db2);\n    \n    // MAINNET\n    ProxyRegistryInterface public registry = ProxyRegistryInterface(0x4678f0a6958e4D2Bc4F1BAF7Bc52E8F3564f3fE4);\n    TubInterface public tub = TubInterface(0x448a5065aeBB8E423F0896E6c5D525C040f59af3);\n\n    event OnSale(bytes32 indexed cup, address indexed proxy, address owner, uint discount);\n\n    event Bought(bytes32 indexed cup, address indexed newLad, address indexed oldProxy,\n                address oldOwner, uint discount);\n\n    constructor(address _marketplaceProxy) public {\n        marketplaceProxy = _marketplaceProxy;\n    }\n\n    /// @notice User calls this method to put a CDP on sale which he must own\n    /// @dev Must be called by DSProxy contract in order to authorize for sale\n    /// @param _cup Id of the CDP that is being put on sale\n    /// @param _discount Discount of the original value, goes from 0 - 99% with 2 decimal percision\n    function putOnSale(bytes32 _cup, uint _discount) public {\n        require(isOwner(msg.sender, _cup), \"msg.sender must be proxy which owns the cup\");\n        require(_discount < 10000 && _discount > 100, \"can't have 100% discount and must be over 1%\");\n        require(tub.ink(_cup) > 0 && tub.tab(_cup) > 0, \"must have collateral and debt to put on sale\");\n        require(!isOnSale(_cup), \"can't put a cdp on sale twice\");\n\n        address payable owner = address(uint160(DSProxyInterface(msg.sender).owner()));\n\n        items[_cup] = SaleItem({\n            discount: _discount,\n            proxy: msg.sender,\n            owner: owner,\n            active: true\n        });\n\n        itemsArr.push(_cup);\n        itemPos[_cup] = itemsArr.length - 1;\n\n        emit OnSale(_cup, msg.sender, owner, _discount);\n    }\n\n    /// @notice Any user can call this method to buy a CDP\n    /// @dev This will fail if the CDP owner was changed\n    /// @param _cup Id of the CDP you want to buy\n    function buy(bytes32 _cup, address _newOwner) public payable {\n        SaleItem storage item = items[_cup];\n\n        require(item.active == true, \"Check if cup is on sale\");\n        require(item.proxy == tub.lad(_cup), \"The owner must stay the same\");\n\n        uint cdpPrice;\n        uint feeAmount;\n\n        (cdpPrice, feeAmount) = getCdpPrice(_cup);\n\n        require(msg.value >= cdpPrice, \"Check if enough ether is sent for this cup\");\n\n        item.active = false;\n\n        // give the cup to the buyer, him becoming the lad that owns the cup\n        DSProxyInterface(item.proxy).execute(marketplaceProxy, \n            abi.encodeWithSignature(\"give(bytes32,address)\", _cup, _newOwner));\n\n        item.owner.transfer(sub(cdpPrice, feeAmount)); // transfer money to the seller\n\n        emit Bought(_cup, msg.sender, item.proxy, item.owner, item.discount);\n\n        removeItem(_cup);\n\n    }\n\n    /// @notice Remove the CDP from the marketplace\n    /// @param _cup Id of the CDP\n    function cancel(bytes32 _cup) public {\n        require(isOwner(msg.sender, _cup), \"msg.sender must proxy which owns the cup\");\n        require(isOnSale(_cup), \"only cancel cdps that are on sale\");\n        \n        removeItem(_cup);\n    }\n\n    /// @notice A only owner functon which withdraws Eth balance\n    function withdraw() public auth {\n        msg.sender.transfer(address(this).balance);\n    }\n\n    /// @notice Calculates the price of the CDP given the discount and the fee\n    /// @param _cup Id of the CDP\n    /// @return It returns the price of the CDP and the amount needed for the contracts fee\n    function getCdpPrice(bytes32 _cup) public returns(uint, uint) {\n        SaleItem memory item = items[_cup];\n\n        uint collateral = rmul(tub.ink(_cup), tub.per()); // collateral in Eth\n        uint govFee = wdiv(rmul(tub.tab(_cup), rdiv(tub.rap(_cup), tub.tab(_cup))), uint(tub.pip().read()));\n        uint debt = add(govFee, wdiv(tub.tab(_cup), uint(tub.pip().read()))); // debt in Eth\n\n        uint difference = 0;\n\n        if (item.discount > fee) {\n            difference = sub(item.discount, fee);\n        } else {\n            difference = item.discount;\n        }\n\n        uint cdpPrice = mul(sub(collateral, debt), (sub(10000, difference))) / 10000;\n        uint feeAmount = mul(sub(collateral, debt), fee) / 10000;\n\n        return (cdpPrice, feeAmount);\n    }\n\n    /// @notice Used by front to fetch what is on sale\n    /// @return Returns all CDP ids that are on sale and are not closed\n    function getItemsOnSale() public view returns(bytes32[] memory arr) {\n        uint n = 0;\n\n        arr = new bytes32[](itemsArr.length);\n        for (uint i = 0; i < itemsArr.length; ++i) {\n            if (tub.lad(itemsArr[i]) != address(0)) {\n                arr[n] = itemsArr[i];\n                n++;\n            }\n        }\n\n    }\n\n    /// @notice Helper method to check if a CDP is on sale\n    /// @return True|False depending if it is on sale\n    function isOnSale(bytes32 _cup) public view returns (bool) {\n        return items[_cup].active;\n    }\n\n    function removeItem(bytes32 _cup) internal {\n        delete items[_cup];\n\n        uint index = itemPos[_cup];\n        itemsArr[index] = itemsArr[itemsArr.length - 1];\n\n        itemPos[_cup] = 0;\n        itemPos[itemsArr[itemsArr.length - 1]] = index;\n\n        itemsArr.length--;\n    }\n\n    function isOwner(address _owner, bytes32 _cup) internal view returns(bool) {         \n        require(tub.lad(_cup) == _owner);\n\n        return true;\n    }\n\n}\n\n/// @title MarketplaceProxy handles authorization and interaction with the Marketplace contract\ncontract MarketplaceProxy {\n    // Kovan\n    // address public constant TUB_ADDRESS = 0xa71937147b55Deb8a530C7229C442Fd3F31b7db2;\n    // address public constant FACTORY_ADDRESS = 0xc72E74E474682680a414b506699bBcA44ab9a930;\n    \n    // Mainnet\n    address public constant TUB_ADDRESS = 0x448a5065aeBB8E423F0896E6c5D525C040f59af3;\n    address public constant FACTORY_ADDRESS = 0x5a15566417e6C1c9546523066500bDDBc53F88C7;\n\n    ///@dev Called by the Marketplace contract, will give CDP only if you're authorized or CDP owner\n    ///@param _cup CDP Id\n    ///@param _newOwner Transfer the CDP to this address\n    function give(bytes32 _cup, address _newOwner) public {\n        TubInterface tub = TubInterface(TUB_ADDRESS);\n\n        tub.give(_cup, _newOwner);\n    }\n\n    ///@dev Creates a new DSGuard for the user, authorizes the marketplace contract and puts on sale the cdp\n    ///@param _cup CDP Id\n    ///@param _discount 4 digit number representing a discount of CDP value (0-9999)\n    ///@param _marketplace Address of the marketplace contract \n    function createAuthorizeAndSell(bytes32 _cup, uint _discount, address _marketplace, address _proxy) public {\n        DSGuard guard = DSGuardFactory(FACTORY_ADDRESS).newGuard();\n        DSAuth(_proxy).setAuthority(DSAuthority(address(guard)));\n\n        guard.permit(_marketplace, _proxy, bytes4(keccak256(\"execute(address,bytes)\")));\n\n        Marketplace(_marketplace).putOnSale(_cup, _discount);\n    }\n\n    ///@dev If the user already own a DSGuard but isn't authorized, authorizes the marketplace contract and sell\n    ///@param _cup CDP Id\n    ///@param _discount 4 digit number representing a discount of CDP value (0-9999)\n    ///@param _marketplace Address of the marketplace contract \n    function authorizeAndSell(bytes32 _cup, uint _discount, address _marketplace, address _proxy) public {\n        DSGuard guard = DSGuard(address(DSAuth(_proxy).authority()));\n        guard.permit(_marketplace, _proxy, bytes4(keccak256(\"execute(address,bytes)\")));\n\n        Marketplace(_marketplace).putOnSale(_cup, _discount);\n    }\n\n    ///@dev Put a cdp on sale, if the user already has a DSGuard and authorized it\n    ///@param _cup CDP Id\n    ///@param _discount 4 digit number representing a discount of CDP value (0-9999)\n    ///@param _marketplace Address of the marketplace contract \n    function sell(bytes32 _cup, uint _discount, address _marketplace) public {\n        Marketplace(_marketplace).putOnSale(_cup, _discount);\n    }\n\n    ///@dev Cancel a CDP on sale\n    ///@param _cup CDP Id\n    ///@param _marketplace Address of the marketplace contract \n    function cancel(bytes32 _cup, address _marketplace) public {\n        Marketplace(_marketplace).cancel(_cup);\n    }\n}",
  "bytecode": "608060405234801561001057600080fd5b506109f3806100206000396000f3fe608060405234801561001057600080fd5b506004361061007d5760003560e01c806390423e441161005b57806390423e4414610192578063baa8529c146101ea578063d3ee658114610238578063f0d405e5146102b05761007d565b806318c6926e1461008257806322cae9a2146100fa5780638823151b14610148575b600080fd5b6100f86004803603608081101561009857600080fd5b810190808035906020019092919080359060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506102fa565b005b6101466004803603604081101561011057600080fd5b8101908080359060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610520565b005b61015061058f565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b6101e8600480360360608110156101a857600080fd5b810190808035906020019092919080359060200190929190803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506105a7565b005b6102366004803603604081101561020057600080fd5b8101908080359060200190929190803573ffffffffffffffffffffffffffffffffffffffff16906020019092919050505061061f565b005b6102ae6004803603608081101561024e57600080fd5b810190808035906020019092919080359060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506106dc565b005b6102b86109af565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b60008173ffffffffffffffffffffffffffffffffffffffff1663bf7e214f6040518163ffffffff1660e01b815260040160206040518083038186803b15801561034257600080fd5b505afa158015610356573d6000803e3d6000fd5b505050506040513d602081101561036c57600080fd5b810190808051906020019092919050505090508073ffffffffffffffffffffffffffffffffffffffff1663cbeea68c848460405180807f6578656375746528616464726573732c62797465732900000000000000000000815250601601905060405180910390206040518463ffffffff1660e01b8152600401808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff191681526020019350505050600060405180830381600087803b15801561048e57600080fd5b505af11580156104a2573d6000803e3d6000fd5b505050508273ffffffffffffffffffffffffffffffffffffffff16634db4f98186866040518363ffffffff1660e01b81526004018083815260200182815260200192505050600060405180830381600087803b15801561050157600080fd5b505af1158015610515573d6000803e3d6000fd5b505050505050505050565b8073ffffffffffffffffffffffffffffffffffffffff1663c4d252f5836040518263ffffffff1660e01b815260040180828152602001915050600060405180830381600087803b15801561057357600080fd5b505af1158015610587573d6000803e3d6000fd5b505050505050565b735a15566417e6c1c9546523066500bddbc53f88c781565b8073ffffffffffffffffffffffffffffffffffffffff16634db4f98184846040518363ffffffff1660e01b81526004018083815260200182815260200192505050600060405180830381600087803b15801561060257600080fd5b505af1158015610616573d6000803e3d6000fd5b50505050505050565b600073448a5065aebb8e423f0896e6c5d525c040f59af390508073ffffffffffffffffffffffffffffffffffffffff1663baa8529c84846040518363ffffffff1660e01b8152600401808381526020018273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200192505050600060405180830381600087803b1580156106bf57600080fd5b505af11580156106d3573d6000803e3d6000fd5b50505050505050565b6000735a15566417e6c1c9546523066500bddbc53f88c773ffffffffffffffffffffffffffffffffffffffff166365688cc96040518163ffffffff1660e01b8152600401602060405180830381600087803b15801561073a57600080fd5b505af115801561074e573d6000803e3d6000fd5b505050506040513d602081101561076457600080fd5b810190808051906020019092919050505090508173ffffffffffffffffffffffffffffffffffffffff16637a9e5e4b826040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050600060405180830381600087803b1580156107f657600080fd5b505af115801561080a573d6000803e3d6000fd5b505050508073ffffffffffffffffffffffffffffffffffffffff1663cbeea68c848460405180807f6578656375746528616464726573732c62797465732900000000000000000000815250601601905060405180910390206040518463ffffffff1660e01b8152600401808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff191681526020019350505050600060405180830381600087803b15801561091d57600080fd5b505af1158015610931573d6000803e3d6000fd5b505050508273ffffffffffffffffffffffffffffffffffffffff16634db4f98186866040518363ffffffff1660e01b81526004018083815260200182815260200192505050600060405180830381600087803b15801561099057600080fd5b505af11580156109a4573d6000803e3d6000fd5b505050505050505050565b73448a5065aebb8e423f0896e6c5d525c040f59af38156fea165627a7a7230582029502beccdedae5e6afc7b5e2be3b62bb12167bcbb5d176f057000620215b6680029"
}