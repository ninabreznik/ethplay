{
  "address": "0xb87304fbd18e669b932695d77cefdee0e8e7a6f1",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "ExpectedRate",
  "compilerVersion": "v0.4.18+commit.9cf6e910",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2019-05-23\n*/\n\npragma solidity 0.4.18;\n\n// File: contracts/ERC20Interface.sol\n\n// https://github.com/ethereum/EIPs/issues/20\ninterface ERC20 {\n    function totalSupply() public view returns (uint supply);\n    function balanceOf(address _owner) public view returns (uint balance);\n    function transfer(address _to, uint _value) public returns (bool success);\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n    function approve(address _spender, uint _value) public returns (bool success);\n    function allowance(address _owner, address _spender) public view returns (uint remaining);\n    function decimals() public view returns(uint digits);\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\n\n// File: contracts/ExpectedRateInterface.sol\n\ninterface ExpectedRateInterface {\n    function getExpectedRate(ERC20 src, ERC20 dest, uint srcQty, bool usePermissionless) public view\n        returns (uint expectedRate, uint slippageRate);\n}\n\n// File: contracts/FeeBurnerInterface.sol\n\ninterface FeeBurnerInterface {\n    function handleFees (uint tradeWeiAmount, address reserve, address wallet) public returns(bool);\n    function setReserveData(address reserve, uint feesInBps, address kncWallet) public;\n}\n\n// File: contracts/KyberNetworkInterface.sol\n\n/// @title Kyber Network interface\ninterface KyberNetworkInterface {\n    function maxGasPrice() public view returns(uint);\n    function getUserCapInWei(address user) public view returns(uint);\n    function getUserCapInTokenWei(address user, ERC20 token) public view returns(uint);\n    function enabled() public view returns(bool);\n    function info(bytes32 id) public view returns(uint);\n\n    function getExpectedRate(ERC20 src, ERC20 dest, uint srcQty) public view\n        returns (uint expectedRate, uint slippageRate);\n\n    function tradeWithHint(address trader, ERC20 src, uint srcAmount, ERC20 dest, address destAddress,\n        uint maxDestAmount, uint minConversionRate, address walletId, bytes hint) public payable returns(uint);\n}\n\n// File: contracts/KyberReserveInterface.sol\n\n/// @title Kyber Reserve contract\ninterface KyberReserveInterface {\n\n    function trade(\n        ERC20 srcToken,\n        uint srcAmount,\n        ERC20 destToken,\n        address destAddress,\n        uint conversionRate,\n        bool validate\n    )\n        public\n        payable\n        returns(bool);\n\n    function getConversionRate(ERC20 src, ERC20 dest, uint srcQty, uint blockNumber) public view returns(uint);\n}\n\n// File: contracts/Utils.sol\n\n/// @title Kyber constants contract\ncontract Utils {\n\n    ERC20 constant internal ETH_TOKEN_ADDRESS = ERC20(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\n    uint  constant internal PRECISION = (10**18);\n    uint  constant internal MAX_QTY   = (10**28); // 10B tokens\n    uint  constant internal MAX_RATE  = (PRECISION * 10**6); // up to 1M tokens per ETH\n    uint  constant internal MAX_DECIMALS = 18;\n    uint  constant internal ETH_DECIMALS = 18;\n    mapping(address=>uint) internal decimals;\n\n    function setDecimals(ERC20 token) internal {\n        if (token == ETH_TOKEN_ADDRESS) decimals[token] = ETH_DECIMALS;\n        else decimals[token] = token.decimals();\n    }\n\n    function getDecimals(ERC20 token) internal view returns(uint) {\n        if (token == ETH_TOKEN_ADDRESS) return ETH_DECIMALS; // save storage access\n        uint tokenDecimals = decimals[token];\n        // technically, there might be token with decimals 0\n        // moreover, very possible that old tokens have decimals 0\n        // these tokens will just have higher gas fees.\n        if(tokenDecimals == 0) return token.decimals();\n\n        return tokenDecimals;\n    }\n\n    function calcDstQty(uint srcQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\n        require(srcQty <= MAX_QTY);\n        require(rate <= MAX_RATE);\n\n        if (dstDecimals >= srcDecimals) {\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\n            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\n        } else {\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\n            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\n        }\n    }\n\n    function calcSrcQty(uint dstQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\n        require(dstQty <= MAX_QTY);\n        require(rate <= MAX_RATE);\n        \n        //source quantity is rounded up. to avoid dest quantity being too low.\n        uint numerator;\n        uint denominator;\n        if (srcDecimals >= dstDecimals) {\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\n            numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)));\n            denominator = rate;\n        } else {\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\n            numerator = (PRECISION * dstQty);\n            denominator = (rate * (10**(dstDecimals - srcDecimals)));\n        }\n        return (numerator + denominator - 1) / denominator; //avoid rounding down errors\n    }\n}\n\n// File: contracts/Utils2.sol\n\ncontract Utils2 is Utils {\n\n    /// @dev get the balance of a user.\n    /// @param token The token type\n    /// @return The balance\n    function getBalance(ERC20 token, address user) public view returns(uint) {\n        if (token == ETH_TOKEN_ADDRESS)\n            return user.balance;\n        else\n            return token.balanceOf(user);\n    }\n\n    function getDecimalsSafe(ERC20 token) internal returns(uint) {\n\n        if (decimals[token] == 0) {\n            setDecimals(token);\n        }\n\n        return decimals[token];\n    }\n\n    function calcDestAmount(ERC20 src, ERC20 dest, uint srcAmount, uint rate) internal view returns(uint) {\n        return calcDstQty(srcAmount, getDecimals(src), getDecimals(dest), rate);\n    }\n\n    function calcSrcAmount(ERC20 src, ERC20 dest, uint destAmount, uint rate) internal view returns(uint) {\n        return calcSrcQty(destAmount, getDecimals(src), getDecimals(dest), rate);\n    }\n\n    function calcRateFromQty(uint srcAmount, uint destAmount, uint srcDecimals, uint dstDecimals)\n        internal pure returns(uint)\n    {\n        require(srcAmount <= MAX_QTY);\n        require(destAmount <= MAX_QTY);\n\n        if (dstDecimals >= srcDecimals) {\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\n            return (destAmount * PRECISION / ((10 ** (dstDecimals - srcDecimals)) * srcAmount));\n        } else {\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\n            return (destAmount * PRECISION * (10 ** (srcDecimals - dstDecimals)) / srcAmount);\n        }\n    }\n}\n\n// File: contracts/WhiteListInterface.sol\n\ncontract WhiteListInterface {\n    function getUserCapInWei(address user) external view returns (uint userCapWei);\n}\n\n// File: contracts/PermissionGroups.sol\n\ncontract PermissionGroups {\n\n    address public admin;\n    address public pendingAdmin;\n    mapping(address=>bool) internal operators;\n    mapping(address=>bool) internal alerters;\n    address[] internal operatorsGroup;\n    address[] internal alertersGroup;\n    uint constant internal MAX_GROUP_SIZE = 50;\n\n    function PermissionGroups() public {\n        admin = msg.sender;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin);\n        _;\n    }\n\n    modifier onlyOperator() {\n        require(operators[msg.sender]);\n        _;\n    }\n\n    modifier onlyAlerter() {\n        require(alerters[msg.sender]);\n        _;\n    }\n\n    function getOperators () external view returns(address[]) {\n        return operatorsGroup;\n    }\n\n    function getAlerters () external view returns(address[]) {\n        return alertersGroup;\n    }\n\n    event TransferAdminPending(address pendingAdmin);\n\n    /**\n     * @dev Allows the current admin to set the pendingAdmin address.\n     * @param newAdmin The address to transfer ownership to.\n     */\n    function transferAdmin(address newAdmin) public onlyAdmin {\n        require(newAdmin != address(0));\n        TransferAdminPending(pendingAdmin);\n        pendingAdmin = newAdmin;\n    }\n\n    /**\n     * @dev Allows the current admin to set the admin in one tx. Useful initial deployment.\n     * @param newAdmin The address to transfer ownership to.\n     */\n    function transferAdminQuickly(address newAdmin) public onlyAdmin {\n        require(newAdmin != address(0));\n        TransferAdminPending(newAdmin);\n        AdminClaimed(newAdmin, admin);\n        admin = newAdmin;\n    }\n\n    event AdminClaimed( address newAdmin, address previousAdmin);\n\n    /**\n     * @dev Allows the pendingAdmin address to finalize the change admin process.\n     */\n    function claimAdmin() public {\n        require(pendingAdmin == msg.sender);\n        AdminClaimed(pendingAdmin, admin);\n        admin = pendingAdmin;\n        pendingAdmin = address(0);\n    }\n\n    event AlerterAdded (address newAlerter, bool isAdd);\n\n    function addAlerter(address newAlerter) public onlyAdmin {\n        require(!alerters[newAlerter]); // prevent duplicates.\n        require(alertersGroup.length < MAX_GROUP_SIZE);\n\n        AlerterAdded(newAlerter, true);\n        alerters[newAlerter] = true;\n        alertersGroup.push(newAlerter);\n    }\n\n    function removeAlerter (address alerter) public onlyAdmin {\n        require(alerters[alerter]);\n        alerters[alerter] = false;\n\n        for (uint i = 0; i < alertersGroup.length; ++i) {\n            if (alertersGroup[i] == alerter) {\n                alertersGroup[i] = alertersGroup[alertersGroup.length - 1];\n                alertersGroup.length--;\n                AlerterAdded(alerter, false);\n                break;\n            }\n        }\n    }\n\n    event OperatorAdded(address newOperator, bool isAdd);\n\n    function addOperator(address newOperator) public onlyAdmin {\n        require(!operators[newOperator]); // prevent duplicates.\n        require(operatorsGroup.length < MAX_GROUP_SIZE);\n\n        OperatorAdded(newOperator, true);\n        operators[newOperator] = true;\n        operatorsGroup.push(newOperator);\n    }\n\n    function removeOperator (address operator) public onlyAdmin {\n        require(operators[operator]);\n        operators[operator] = false;\n\n        for (uint i = 0; i < operatorsGroup.length; ++i) {\n            if (operatorsGroup[i] == operator) {\n                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];\n                operatorsGroup.length -= 1;\n                OperatorAdded(operator, false);\n                break;\n            }\n        }\n    }\n}\n\n// File: contracts/Withdrawable.sol\n\n/**\n * @title Contracts that should be able to recover tokens or ethers\n * @author Ilan Doron\n * @dev This allows to recover any tokens or Ethers received in a contract.\n * This will prevent any accidental loss of tokens.\n */\ncontract Withdrawable is PermissionGroups {\n\n    event TokenWithdraw(ERC20 token, uint amount, address sendTo);\n\n    /**\n     * @dev Withdraw all ERC20 compatible tokens\n     * @param token ERC20 The address of the token contract\n     */\n    function withdrawToken(ERC20 token, uint amount, address sendTo) external onlyAdmin {\n        require(token.transfer(sendTo, amount));\n        TokenWithdraw(token, amount, sendTo);\n    }\n\n    event EtherWithdraw(uint amount, address sendTo);\n\n    /**\n     * @dev Withdraw Ethers\n     */\n    function withdrawEther(uint amount, address sendTo) external onlyAdmin {\n        sendTo.transfer(amount);\n        EtherWithdraw(amount, sendTo);\n    }\n}\n\n// File: contracts/KyberNetwork.sol\n\n/**\n * @title Helps contracts guard against reentrancy attacks.\n */\ncontract ReentrancyGuard {\n\n    /// @dev counter to allow mutex lock with only one SSTORE operation\n    uint256 private guardCounter = 1;\n\n    /**\n     * @dev Prevents a function from calling itself, directly or indirectly.\n     * Calling one `nonReentrant` function from\n     * another is not supported. Instead, you can implement a\n     * `private` function doing the actual work, and an `external`\n     * wrapper marked as `nonReentrant`.\n     */\n    modifier nonReentrant() {\n        guardCounter += 1;\n        uint256 localCounter = guardCounter;\n        _;\n        require(localCounter == guardCounter);\n    }\n}\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////\n/// @title Kyber Network main contract\ncontract KyberNetwork is Withdrawable, Utils2, KyberNetworkInterface, ReentrancyGuard {\n\n    bytes public constant PERM_HINT = \"PERM\";\n    uint  public constant PERM_HINT_GET_RATE = 1 << 255; // for get rate. bit mask hint.\n\n    uint public negligibleRateDiff = 10; // basic rate steps will be in 0.01%\n    KyberReserveInterface[] public reserves;\n    mapping(address=>ReserveType) public reserveType;\n    WhiteListInterface public whiteListContract;\n    ExpectedRateInterface public expectedRateContract;\n    FeeBurnerInterface    public feeBurnerContract;\n    address               public kyberNetworkProxyContract;\n    uint                  public maxGasPriceValue = 50 * 1000 * 1000 * 1000; // 50 gwei\n    bool                  public isEnabled = false; // network is enabled\n    mapping(bytes32=>uint) public infoFields; // this is only a UI field for external app.\n\n    mapping(address=>address[]) public reservesPerTokenSrc; //reserves supporting token to eth\n    mapping(address=>address[]) public reservesPerTokenDest;//reserves support eth to token\n\n    enum ReserveType {NONE, PERMISSIONED, PERMISSIONLESS}\n    bytes internal constant EMPTY_HINT = \"\";\n\n    function KyberNetwork(address _admin) public {\n        require(_admin != address(0));\n        admin = _admin;\n    }\n\n    event EtherReceival(address indexed sender, uint amount);\n\n    /* solhint-disable no-complex-fallback */\n    // To avoid users trying to swap tokens using default payable function. We added this short code\n    //  to verify Ethers will be received only from reserves if transferred without a specific function call.\n    function() public payable {\n        require(reserveType[msg.sender] != ReserveType.NONE);\n        EtherReceival(msg.sender, msg.value);\n    }\n    /* solhint-enable no-complex-fallback */\n\n    struct TradeInput {\n        address trader;\n        ERC20 src;\n        uint srcAmount;\n        ERC20 dest;\n        address destAddress;\n        uint maxDestAmount;\n        uint minConversionRate;\n        address walletId;\n        bytes hint;\n    }\n\n    function tradeWithHint(\n        address trader,\n        ERC20 src,\n        uint srcAmount,\n        ERC20 dest,\n        address destAddress,\n        uint maxDestAmount,\n        uint minConversionRate,\n        address walletId,\n        bytes hint\n    )\n        public\n        nonReentrant\n        payable\n        returns(uint)\n    {\n        require(msg.sender == kyberNetworkProxyContract);\n        require((hint.length == 0) || (hint.length == 4));\n\n        TradeInput memory tradeInput;\n\n        tradeInput.trader = trader;\n        tradeInput.src = src;\n        tradeInput.srcAmount = srcAmount;\n        tradeInput.dest = dest;\n        tradeInput.destAddress = destAddress;\n        tradeInput.maxDestAmount = maxDestAmount;\n        tradeInput.minConversionRate = minConversionRate;\n        tradeInput.walletId = walletId;\n        tradeInput.hint = hint;\n\n        return trade(tradeInput);\n    }\n\n    event AddReserveToNetwork(KyberReserveInterface indexed reserve, bool add, bool isPermissionless);\n\n    /// @notice can be called only by operator\n    /// @dev add or deletes a reserve to/from the network.\n    /// @param reserve The reserve address.\n    /// @param isPermissionless is the new reserve from permissionless type.\n    function addReserve(KyberReserveInterface reserve, bool isPermissionless) public onlyOperator\n        returns(bool)\n    {\n        require(reserveType[reserve] == ReserveType.NONE);\n        reserves.push(reserve);\n\n        reserveType[reserve] = isPermissionless ? ReserveType.PERMISSIONLESS : ReserveType.PERMISSIONED;\n\n        AddReserveToNetwork(reserve, true, isPermissionless);\n\n        return true;\n    }\n\n    event RemoveReserveFromNetwork(KyberReserveInterface reserve);\n\n    /// @notice can be called only by operator\n    /// @dev removes a reserve from Kyber network.\n    /// @param reserve The reserve address.\n    /// @param index in reserve array.\n    function removeReserve(KyberReserveInterface reserve, uint index) public onlyOperator\n        returns(bool)\n    {\n\n        require(reserveType[reserve] != ReserveType.NONE);\n        require(reserves[index] == reserve);\n\n        reserveType[reserve] = ReserveType.NONE;\n        reserves[index] = reserves[reserves.length - 1];\n        reserves.length--;\n\n        RemoveReserveFromNetwork(reserve);\n\n        return true;\n    }\n\n    event ListReservePairs(address indexed reserve, ERC20 src, ERC20 dest, bool add);\n\n    /// @notice can be called only by operator\n    /// @dev allow or prevent a specific reserve to trade a pair of tokens\n    /// @param reserve The reserve address.\n    /// @param token token address\n    /// @param ethToToken will it support ether to token trade\n    /// @param tokenToEth will it support token to ether trade\n    /// @param add If true then list this pair, otherwise unlist it.\n    function listPairForReserve(address reserve, ERC20 token, bool ethToToken, bool tokenToEth, bool add)\n        public\n        onlyOperator\n        returns(bool)\n    {\n        require(reserveType[reserve] != ReserveType.NONE);\n\n        if (ethToToken) {\n            listPairs(reserve, token, false, add);\n\n            ListReservePairs(reserve, ETH_TOKEN_ADDRESS, token, add);\n        }\n\n        if (tokenToEth) {\n            listPairs(reserve, token, true, add);\n\n            if (add) {\n                require(token.approve(reserve, 2**255)); // approve infinity\n            } else {\n                require(token.approve(reserve, 0));\n            }\n\n            ListReservePairs(reserve, token, ETH_TOKEN_ADDRESS, add);\n        }\n\n        setDecimals(token);\n\n        return true;\n    }\n\n    event WhiteListContractSet(WhiteListInterface newContract, WhiteListInterface currentContract);\n\n    ///@param whiteList can be empty\n    function setWhiteList(WhiteListInterface whiteList) public onlyAdmin {\n        WhiteListContractSet(whiteList, whiteListContract);\n        whiteListContract = whiteList;\n    }\n\n    event ExpectedRateContractSet(ExpectedRateInterface newContract, ExpectedRateInterface currentContract);\n\n    function setExpectedRate(ExpectedRateInterface expectedRate) public onlyAdmin {\n        require(expectedRate != address(0));\n\n        ExpectedRateContractSet(expectedRate, expectedRateContract);\n        expectedRateContract = expectedRate;\n    }\n\n    event FeeBurnerContractSet(FeeBurnerInterface newContract, FeeBurnerInterface currentContract);\n\n    function setFeeBurner(FeeBurnerInterface feeBurner) public onlyAdmin {\n        require(feeBurner != address(0));\n\n        FeeBurnerContractSet(feeBurner, feeBurnerContract);\n        feeBurnerContract = feeBurner;\n    }\n\n    event KyberNetwrokParamsSet(uint maxGasPrice, uint negligibleRateDiff);\n\n    function setParams(\n        uint                  _maxGasPrice,\n        uint                  _negligibleRateDiff\n    )\n        public\n        onlyAdmin\n    {\n        require(_negligibleRateDiff <= 100 * 100); // at most 100%\n\n        maxGasPriceValue = _maxGasPrice;\n        negligibleRateDiff = _negligibleRateDiff;\n        KyberNetwrokParamsSet(maxGasPriceValue, negligibleRateDiff);\n    }\n\n    event KyberNetworkSetEnable(bool isEnabled);\n\n    function setEnable(bool _enable) public onlyAdmin {\n        if (_enable) {\n            require(feeBurnerContract != address(0));\n            require(expectedRateContract != address(0));\n            require(kyberNetworkProxyContract != address(0));\n        }\n        isEnabled = _enable;\n\n        KyberNetworkSetEnable(isEnabled);\n    }\n\n    function setInfo(bytes32 field, uint value) public onlyOperator {\n        infoFields[field] = value;\n    }\n\n    event KyberProxySet(address proxy, address sender);\n\n    function setKyberProxy(address networkProxy) public onlyAdmin {\n        require(networkProxy != address(0));\n        kyberNetworkProxyContract = networkProxy;\n        KyberProxySet(kyberNetworkProxyContract, msg.sender);\n    }\n\n    /// @dev returns number of reserves\n    /// @return number of reserves\n    function getNumReserves() public view returns(uint) {\n        return reserves.length;\n    }\n\n    /// @notice should be called off chain\n    /// @dev get an array of all reserves\n    /// @return An array of all reserves\n    function getReserves() public view returns(KyberReserveInterface[]) {\n        return reserves;\n    }\n\n    function maxGasPrice() public view returns(uint) {\n        return maxGasPriceValue;\n    }\n\n    function getExpectedRate(ERC20 src, ERC20 dest, uint srcQty)\n        public view\n        returns(uint expectedRate, uint slippageRate)\n    {\n        require(expectedRateContract != address(0));\n        bool includePermissionless = true;\n\n        if (srcQty & PERM_HINT_GET_RATE > 0) {\n            includePermissionless = false;\n            srcQty = srcQty & ~PERM_HINT_GET_RATE;\n        }\n\n        return expectedRateContract.getExpectedRate(src, dest, srcQty, includePermissionless);\n    }\n\n    function getExpectedRateOnlyPermission(ERC20 src, ERC20 dest, uint srcQty)\n        public view\n        returns(uint expectedRate, uint slippageRate)\n    {\n        require(expectedRateContract != address(0));\n        return expectedRateContract.getExpectedRate(src, dest, srcQty, false);\n    }\n\n    function getUserCapInWei(address user) public view returns(uint) {\n        if (whiteListContract == address(0)) return (2 ** 255);\n        return whiteListContract.getUserCapInWei(user);\n    }\n\n    function getUserCapInTokenWei(address user, ERC20 token) public view returns(uint) {\n        //future feature\n        user;\n        token;\n        require(false);\n    }\n\n    struct BestRateResult {\n        uint rate;\n        address reserve1;\n        address reserve2;\n        uint weiAmount;\n        uint rateSrcToEth;\n        uint rateEthToDest;\n        uint destAmount;\n    }\n\n    /// @notice use token address ETH_TOKEN_ADDRESS for ether\n    /// @dev best conversion rate for a pair of tokens, if number of reserves have small differences. randomize\n    /// @param src Src token\n    /// @param dest Destination token\n    /// @return obsolete - used to return best reserve index. not relevant anymore for this API.\n    function findBestRate(ERC20 src, ERC20 dest, uint srcAmount) public view returns(uint obsolete, uint rate) {\n        BestRateResult memory result = findBestRateTokenToToken(src, dest, srcAmount, EMPTY_HINT);\n        return(0, result.rate);\n    }\n\n    function findBestRateOnlyPermission(ERC20 src, ERC20 dest, uint srcAmount)\n        public\n        view\n        returns(uint obsolete, uint rate)\n    {\n        BestRateResult memory result = findBestRateTokenToToken(src, dest, srcAmount, PERM_HINT);\n        return(0, result.rate);\n    }\n\n    function enabled() public view returns(bool) {\n        return isEnabled;\n    }\n\n    function info(bytes32 field) public view returns(uint) {\n        return infoFields[field];\n    }\n\n    /* solhint-disable code-complexity */\n    // Regarding complexity. Below code follows the required algorithm for choosing a reserve.\n    //  It has been tested, reviewed and found to be clear enough.\n    //@dev this function always src or dest are ether. can't do token to token\n    function searchBestRate(ERC20 src, ERC20 dest, uint srcAmount, bool usePermissionless)\n        public\n        view\n        returns(address, uint)\n    {\n        uint bestRate = 0;\n        uint bestReserve = 0;\n        uint numRelevantReserves = 0;\n\n        //return 1 for ether to ether\n        if (src == dest) return (reserves[bestReserve], PRECISION);\n\n        address[] memory reserveArr;\n\n        reserveArr = src == ETH_TOKEN_ADDRESS ? reservesPerTokenDest[dest] : reservesPerTokenSrc[src];\n\n        if (reserveArr.length == 0) return (reserves[bestReserve], bestRate);\n\n        uint[] memory rates = new uint[](reserveArr.length);\n        uint[] memory reserveCandidates = new uint[](reserveArr.length);\n\n        for (uint i = 0; i < reserveArr.length; i++) {\n            //list all reserves that have this token.\n            if (!usePermissionless && reserveType[reserveArr[i]] == ReserveType.PERMISSIONLESS) {\n                continue;\n            }\n\n            rates[i] = (KyberReserveInterface(reserveArr[i])).getConversionRate(src, dest, srcAmount, block.number);\n\n            if (rates[i] > bestRate) {\n                //best rate is highest rate\n                bestRate = rates[i];\n            }\n        }\n\n        if (bestRate > 0) {\n            uint smallestRelevantRate = (bestRate * 10000) / (10000 + negligibleRateDiff);\n\n            for (i = 0; i < reserveArr.length; i++) {\n                if (rates[i] >= smallestRelevantRate) {\n                    reserveCandidates[numRelevantReserves++] = i;\n                }\n            }\n\n            if (numRelevantReserves > 1) {\n                //when encountering small rate diff from bestRate. draw from relevant reserves\n                bestReserve = reserveCandidates[uint(block.blockhash(block.number-1)) % numRelevantReserves];\n            } else {\n                bestReserve = reserveCandidates[0];\n            }\n\n            bestRate = rates[bestReserve];\n        }\n\n        return (reserveArr[bestReserve], bestRate);\n    }\n    /* solhint-enable code-complexity */\n\n    function findBestRateTokenToToken(ERC20 src, ERC20 dest, uint srcAmount, bytes hint) internal view\n        returns(BestRateResult result)\n    {\n        //by default we use permission less reserves\n        bool usePermissionless = true;\n\n        // if hint in first 4 bytes == 'PERM' only permissioned reserves will be used.\n        if ((hint.length >= 4) && (keccak256(hint[0], hint[1], hint[2], hint[3]) == keccak256(PERM_HINT))) {\n            usePermissionless = false;\n        }\n\n        (result.reserve1, result.rateSrcToEth) =\n            searchBestRate(src, ETH_TOKEN_ADDRESS, srcAmount, usePermissionless);\n\n        result.weiAmount = calcDestAmount(src, ETH_TOKEN_ADDRESS, srcAmount, result.rateSrcToEth);\n\n        (result.reserve2, result.rateEthToDest) =\n            searchBestRate(ETH_TOKEN_ADDRESS, dest, result.weiAmount, usePermissionless);\n\n        result.destAmount = calcDestAmount(ETH_TOKEN_ADDRESS, dest, result.weiAmount, result.rateEthToDest);\n\n        result.rate = calcRateFromQty(srcAmount, result.destAmount, getDecimals(src), getDecimals(dest));\n    }\n\n    function listPairs(address reserve, ERC20 token, bool isTokenToEth, bool add) internal {\n        uint i;\n        address[] storage reserveArr = reservesPerTokenDest[token];\n\n        if (isTokenToEth) {\n            reserveArr = reservesPerTokenSrc[token];\n        }\n\n        for (i = 0; i < reserveArr.length; i++) {\n            if (reserve == reserveArr[i]) {\n                if (add) {\n                    break; //already added\n                } else {\n                    //remove\n                    reserveArr[i] = reserveArr[reserveArr.length - 1];\n                    reserveArr.length--;\n                    break;\n                }\n            }\n        }\n\n        if (add && i == reserveArr.length) {\n            //if reserve wasn't found add it\n            reserveArr.push(reserve);\n        }\n    }\n\n    event KyberTrade(address indexed trader, ERC20 src, ERC20 dest, uint srcAmount, uint dstAmount,\n        address destAddress, uint ethWeiValue, address reserve1, address reserve2, bytes hint);\n\n    /* solhint-disable function-max-lines */\n    //  Most of the lines here are functions calls spread over multiple lines. We find this function readable enough\n    /// @notice use token address ETH_TOKEN_ADDRESS for ether\n    /// @dev trade api for kyber network.\n    /// @param tradeInput structure of trade inputs\n    function trade(TradeInput tradeInput) internal returns(uint) {\n        require(isEnabled);\n        require(tx.gasprice <= maxGasPriceValue);\n        require(validateTradeInput(tradeInput.src, tradeInput.srcAmount, tradeInput.dest, tradeInput.destAddress));\n\n        BestRateResult memory rateResult =\n            findBestRateTokenToToken(tradeInput.src, tradeInput.dest, tradeInput.srcAmount, tradeInput.hint);\n\n        require(rateResult.rate > 0);\n        require(rateResult.rate < MAX_RATE);\n        require(rateResult.rate >= tradeInput.minConversionRate);\n\n        uint actualDestAmount;\n        uint weiAmount;\n        uint actualSrcAmount;\n\n        (actualSrcAmount, weiAmount, actualDestAmount) = calcActualAmounts(tradeInput.src,\n            tradeInput.dest,\n            tradeInput.srcAmount,\n            tradeInput.maxDestAmount,\n            rateResult);\n\n        require(getUserCapInWei(tradeInput.trader) >= weiAmount);\n        require(handleChange(tradeInput.src, tradeInput.srcAmount, actualSrcAmount, tradeInput.trader));\n\n        require(doReserveTrade(     //src to ETH\n                tradeInput.src,\n                actualSrcAmount,\n                ETH_TOKEN_ADDRESS,\n                this,\n                weiAmount,\n                KyberReserveInterface(rateResult.reserve1),\n                rateResult.rateSrcToEth,\n                true));\n\n        require(doReserveTrade(     //Eth to dest\n                ETH_TOKEN_ADDRESS,\n                weiAmount,\n                tradeInput.dest,\n                tradeInput.destAddress,\n                actualDestAmount,\n                KyberReserveInterface(rateResult.reserve2),\n                rateResult.rateEthToDest,\n                true));\n\n        if (tradeInput.src != ETH_TOKEN_ADDRESS) //\"fake\" trade. (ether to ether) - don't burn.\n            require(feeBurnerContract.handleFees(weiAmount, rateResult.reserve1, tradeInput.walletId));\n        if (tradeInput.dest != ETH_TOKEN_ADDRESS) //\"fake\" trade. (ether to ether) - don't burn.\n            require(feeBurnerContract.handleFees(weiAmount, rateResult.reserve2, tradeInput.walletId));\n\n        KyberTrade({\n            trader: tradeInput.trader,\n            src: tradeInput.src,\n            dest: tradeInput.dest,\n            srcAmount: actualSrcAmount,\n            dstAmount: actualDestAmount,\n            destAddress: tradeInput.destAddress,\n            ethWeiValue: weiAmount,\n            reserve1: (tradeInput.src == ETH_TOKEN_ADDRESS) ? address(0) : rateResult.reserve1,\n            reserve2:  (tradeInput.dest == ETH_TOKEN_ADDRESS) ? address(0) : rateResult.reserve2,\n            hint: tradeInput.hint\n        });\n\n        return actualDestAmount;\n    }\n    /* solhint-enable function-max-lines */\n\n    function calcActualAmounts (ERC20 src, ERC20 dest, uint srcAmount, uint maxDestAmount, BestRateResult rateResult)\n        internal view returns(uint actualSrcAmount, uint weiAmount, uint actualDestAmount)\n    {\n        if (rateResult.destAmount > maxDestAmount) {\n            actualDestAmount = maxDestAmount;\n            weiAmount = calcSrcAmount(ETH_TOKEN_ADDRESS, dest, actualDestAmount, rateResult.rateEthToDest);\n            actualSrcAmount = calcSrcAmount(src, ETH_TOKEN_ADDRESS, weiAmount, rateResult.rateSrcToEth);\n            require(actualSrcAmount <= srcAmount);\n        } else {\n            actualDestAmount = rateResult.destAmount;\n            actualSrcAmount = srcAmount;\n            weiAmount = rateResult.weiAmount;\n        }\n    }\n\n    /// @notice use token address ETH_TOKEN_ADDRESS for ether\n    /// @dev do one trade with a reserve\n    /// @param src Src token\n    /// @param amount amount of src tokens\n    /// @param dest   Destination token\n    /// @param destAddress Address to send tokens to\n    /// @param reserve Reserve to use\n    /// @param validate If true, additional validations are applicable\n    /// @return true if trade is successful\n    function doReserveTrade(\n        ERC20 src,\n        uint amount,\n        ERC20 dest,\n        address destAddress,\n        uint expectedDestAmount,\n        KyberReserveInterface reserve,\n        uint conversionRate,\n        bool validate\n    )\n        internal\n        returns(bool)\n    {\n        uint callValue = 0;\n\n        if (src == dest) {\n            //this is for a \"fake\" trade when both src and dest are ethers.\n            if (destAddress != (address(this)))\n                destAddress.transfer(amount);\n            return true;\n        }\n\n        if (src == ETH_TOKEN_ADDRESS) {\n            callValue = amount;\n        }\n\n        // reserve sends tokens/eth to network. network sends it to destination\n        require(reserve.trade.value(callValue)(src, amount, dest, this, conversionRate, validate));\n\n        if (destAddress != address(this)) {\n            //for token to token dest address is network. and Ether / token already here...\n            if (dest == ETH_TOKEN_ADDRESS) {\n                destAddress.transfer(expectedDestAmount);\n            } else {\n                require(dest.transfer(destAddress, expectedDestAmount));\n            }\n        }\n\n        return true;\n    }\n\n    /// when user sets max dest amount we could have too many source tokens == change. so we send it back to user.\n    function handleChange (ERC20 src, uint srcAmount, uint requiredSrcAmount, address trader) internal returns (bool) {\n\n        if (requiredSrcAmount < srcAmount) {\n            //if there is \"change\" send back to trader\n            if (src == ETH_TOKEN_ADDRESS) {\n                trader.transfer(srcAmount - requiredSrcAmount);\n            } else {\n                require(src.transfer(trader, (srcAmount - requiredSrcAmount)));\n            }\n        }\n\n        return true;\n    }\n\n    /// @notice use token address ETH_TOKEN_ADDRESS for ether\n    /// @dev checks that user sent ether/tokens to contract before trade\n    /// @param src Src token\n    /// @param srcAmount amount of src tokens\n    /// @return true if tradeInput is valid\n    function validateTradeInput(ERC20 src, uint srcAmount, ERC20 dest, address destAddress)\n        internal\n        view\n        returns(bool)\n    {\n        require(srcAmount <= MAX_QTY);\n        require(srcAmount != 0);\n        require(destAddress != address(0));\n        require(src != dest);\n\n        if (src == ETH_TOKEN_ADDRESS) {\n            require(msg.value == srcAmount);\n        } else {\n            require(msg.value == 0);\n            //funds should have been moved to this contract already.\n            require(src.balanceOf(this) >= srcAmount);\n        }\n\n        return true;\n    }\n}\n\n// File: contracts/ExpectedRate.sol\n\ncontract ExpectedRate is Withdrawable, ExpectedRateInterface, Utils2 {\n\n    KyberNetwork public kyberNetwork;\n    uint public quantityFactor = 2;\n    uint public worstCaseRateFactorInBps = 50;\n    uint constant UNIT_QTY_FOR_FEE_BURNER = 10 ** 18;\n    ERC20 public knc;\n\n    function ExpectedRate(KyberNetwork _kyberNetwork, ERC20 _knc, address _admin) public {\n        require(_admin != address(0));\n        require(_knc != address(0));\n        require(_kyberNetwork != address(0));\n        kyberNetwork = _kyberNetwork;\n        admin = _admin;\n        knc = _knc;\n    }\n\n    event QuantityFactorSet (uint newFactor, uint oldFactor, address sender);\n\n    function setQuantityFactor(uint newFactor) public onlyOperator {\n        require(newFactor <= 100);\n\n        QuantityFactorSet(newFactor, quantityFactor, msg.sender);\n        quantityFactor = newFactor;\n    }\n\n    event MinSlippageFactorSet (uint newMin, uint oldMin, address sender);\n\n    function setWorstCaseRateFactor(uint bps) public onlyOperator {\n        require(bps <= 100 * 100);\n\n        MinSlippageFactorSet(bps, worstCaseRateFactorInBps, msg.sender);\n        worstCaseRateFactorInBps = bps;\n    }\n\n    //@dev when srcQty too small or 0 the expected rate will be calculated without quantity,\n    // will enable rate reference before committing to any quantity\n    //@dev when srcQty too small (no actual dest qty) slippage rate will be 0.\n    function getExpectedRate(ERC20 src, ERC20 dest, uint srcQty, bool usePermissionless)\n        public view\n        returns (uint expectedRate, uint slippageRate)\n    {\n        require(quantityFactor != 0);\n        require(srcQty <= MAX_QTY);\n        require(srcQty * quantityFactor <= MAX_QTY);\n\n        if (srcQty == 0) srcQty = 1;\n\n        bool didRevert = false;\n\n        (didRevert, expectedRate, slippageRate) = safeFindBestRate(src, dest, srcQty, usePermissionless);\n        if (didRevert) return (0, 0);\n\n        if (expectedRate == 0) {\n            expectedRate = expectedRateSmallQty(src, dest, srcQty, usePermissionless);\n        }\n\n        if (src == knc &&\n            dest == ETH_TOKEN_ADDRESS &&\n            srcQty == UNIT_QTY_FOR_FEE_BURNER )\n        {\n            if (checkKncArbitrageRate(expectedRate)) expectedRate = 0;\n        }\n\n        if (expectedRate > MAX_RATE) return (0, 0);\n\n        uint worstCaseSlippageRate = ((10000 - worstCaseRateFactorInBps) * expectedRate) / 10000;\n        if (slippageRate >= worstCaseSlippageRate) {\n            slippageRate = worstCaseSlippageRate;\n        }\n\n        return (expectedRate, slippageRate);\n    }\n\n    function checkKncArbitrageRate(uint currentKncToEthRate) public view returns(bool) {\n        uint converseRate;\n        uint slippage;\n    \t(converseRate, slippage) = getExpectedRate(ETH_TOKEN_ADDRESS, knc, UNIT_QTY_FOR_FEE_BURNER, true);\n\n        // if returned rate is 0, can't trust this arb test. assume we have arb\n        if(converseRate == 0) return true;\n\n        require(converseRate <= MAX_RATE && currentKncToEthRate <= MAX_RATE);\n        return ((converseRate * currentKncToEthRate) > (PRECISION ** 2));\n    }\n\n    //@dev for small src quantities dest qty might be 0, then returned rate is zero.\n    //@dev for backward compatibility we would like to return non zero rate (correct one) for small src qty\n    function expectedRateSmallQty(ERC20 src, ERC20 dest, uint srcQty, bool usePermissionless)\n        internal view returns(uint)\n    {\n        address reserve;\n        uint rateSrcToEth;\n        uint rateEthToDest;\n        (reserve, rateSrcToEth) = kyberNetwork.searchBestRate(src, ETH_TOKEN_ADDRESS, srcQty, usePermissionless);\n\n        uint ethQty = calcDestAmount(src, ETH_TOKEN_ADDRESS, srcQty, rateSrcToEth);\n\n        (reserve, rateEthToDest) = kyberNetwork.searchBestRate(ETH_TOKEN_ADDRESS, dest, ethQty, usePermissionless);\n        return rateSrcToEth * rateEthToDest / PRECISION;\n    }\n\n    function safeFindBestRate(ERC20 src, ERC20 dest, uint srcQty, bool usePermissionless)\n        internal view\n        returns (bool didRevert, uint expectedRate, uint slippageRate)\n    {\n        bytes4 sig = usePermissionless ?\n            bytes4(keccak256(\"findBestRate(address,address,uint256)\")) :\n            bytes4(keccak256(\"findBestRateOnlyPermission(address,address,uint256)\")); //Function signatures\n\n        (didRevert, expectedRate) = assemblyFindBestRate(src, dest, srcQty, sig);\n\n        if (didRevert) return (true, 0, 0);\n\n        if (quantityFactor != 1) {\n            (didRevert, slippageRate) = assemblyFindBestRate(src, dest, (srcQty * quantityFactor), sig);\n        } else {\n            slippageRate = expectedRate;\n        }\n    }\n\n    function assemblyFindBestRate(ERC20 src, ERC20 dest, uint srcQty, bytes4 sig)\n        internal view\n        returns (bool didRevert, uint rate)\n    {\n        address addr = address(kyberNetwork);  // kyber address\n        uint success;\n\n        assembly {\n            let x := mload(0x40)        // \"free memory pointer\"\n            mstore(x,sig)               // function signature\n            mstore(add(x,0x04),src)     // src address padded to 32 bytes\n            mstore(add(x,0x24),dest)    // dest padded to 32 bytes\n            mstore(add(x,0x44),srcQty)  // uint 32 bytes\n            mstore(0x40,add(x,0xa4))    // set free storage pointer to empty space after output\n\n            // input size = sig + ERC20 (address) + ERC20 + uint\n            // = 4 + 32 + 32 + 32 = 100 = 0x64\n            success := staticcall(\n                gas,  // gas\n                addr, // Kyber addr\n                x,    // Inputs at location x\n                0x64, // Inputs size bytes\n                add(x, 0x64),    // output storage after input\n                0x40) // Output size are (uint, uint) = 64 bytes\n\n            rate := mload(add(x,0x84))  //Assign 2nd output to rate, first output not used,\n            mstore(0x40,x)    // Set empty storage pointer back to start position\n        }\n\n        if (success != 1) didRevert = true;\n    }\n}",
  "bytecode": "606060405260026008556032600955341561001957600080fd5b60405160608061170d83398101604052808051919060200180519190602001805160008054600160a060020a03191633600160a060020a039081169190911790915590925082161515905061006d57600080fd5b600160a060020a038216151561008257600080fd5b600160a060020a038316151561009757600080fd5b60078054600160a060020a03948516600160a060020a0319918216179091556000805492851692821692909217909155600a805492909316911617905561162a806100e36000396000f30060606040526004361061010e5763ffffffff60e060020a60003504166301a12fd38114610113578063267822471461013457806327a099d8146101635780633ccdbb28146101c9578063408ee7fe146101f257806375829def146102115780637658c5741461023057806377f50f97146102465780637acc8678146102595780637c423f54146102785780639870d7fe1461028b5780639bc72d5f146102aa578063a7de9c63146102cf578063ac8a584a146102e2578063b78b842d14610301578063ce56c45414610314578063d38d2bea14610336578063d4fac45d1461037b578063dcb46e38146103a0578063e61387e0146103b6578063e853cda3146103c9578063f851a440146103f3575b600080fd5b341561011e57600080fd5b610132600160a060020a0360043516610406565b005b341561013f57600080fd5b610147610576565b604051600160a060020a03909116815260200160405180910390f35b341561016e57600080fd5b610176610585565b60405160208082528190810183818151815260200191508051906020019060200280838360005b838110156101b557808201518382015260200161019d565b505050509050019250505060405180910390f35b34156101d457600080fd5b610132600160a060020a0360043581169060243590604435166105ee565b34156101fd57600080fd5b610132600160a060020a03600435166106e5565b341561021c57600080fd5b610132600160a060020a03600435166107e1565b341561023b57600080fd5b61013260043561087c565b341561025157600080fd5b610132610908565b341561026457600080fd5b610132600160a060020a03600435166109a2565b341561028357600080fd5b610176610a84565b341561029657600080fd5b610132600160a060020a0360043516610aea565b34156102b557600080fd5b6102bd610bba565b60405190815260200160405180910390f35b34156102da57600080fd5b6102bd610bc0565b34156102ed57600080fd5b610132600160a060020a0360043516610bc6565b341561030c57600080fd5b610147610d32565b341561031f57600080fd5b610132600435600160a060020a0360243516610d41565b341561034157600080fd5b610363600160a060020a03600435811690602435166044356064351515610dd4565b60405191825260208201526040908101905180910390f35b341561038657600080fd5b6102bd600160a060020a0360043581169060243516610f13565b34156103ab57600080fd5b610132600435610fc5565b34156103c157600080fd5b610147611052565b34156103d457600080fd5b6103df600435611061565b604051901515815260200160405180910390f35b34156103fe57600080fd5b610147611100565b6000805433600160a060020a0390811691161461042257600080fd5b600160a060020a03821660009081526003602052604090205460ff16151561044957600080fd5b50600160a060020a0381166000908152600360205260408120805460ff191690555b6005548110156105725781600160a060020a031660058281548110151561048e57fe5b600091825260209091200154600160a060020a0316141561056a576005805460001981019081106104bb57fe5b60009182526020909120015460058054600160a060020a0390921691839081106104e157fe5b60009182526020909120018054600160a060020a031916600160a060020a0392909216919091179055600580549061051d9060001983016115a5565b507f5611bf3e417d124f97bf2c788843ea8bb502b66079fbee02158ef30b172cb762826000604051600160a060020a039092168252151560208201526040908101905180910390a1610572565b60010161046b565b5050565b600154600160a060020a031681565b61058d6115ce565b60048054806020026020016040519081016040528092919081815260200182805480156105e357602002820191906000526020600020905b8154600160a060020a031681526001909101906020018083116105c5575b505050505090505b90565b60005433600160a060020a0390811691161461060957600080fd5b82600160a060020a031663a9059cbb828460006040516020015260405160e060020a63ffffffff8516028152600160a060020a0390921660048301526024820152604401602060405180830381600087803b151561066657600080fd5b6102c65a03f1151561067757600080fd5b50505060405180519050151561068c57600080fd5b7f72cb8a894ddb372ceec3d2a7648d86f17d5a15caae0e986c53109b8a9a9385e6838383604051600160a060020a03938416815260208101929092529091166040808301919091526060909101905180910390a1505050565b60005433600160a060020a0390811691161461070057600080fd5b600160a060020a03811660009081526003602052604090205460ff161561072657600080fd5b6005546032901061073657600080fd5b7f5611bf3e417d124f97bf2c788843ea8bb502b66079fbee02158ef30b172cb762816001604051600160a060020a039092168252151560208201526040908101905180910390a1600160a060020a0381166000908152600360205260409020805460ff1916600190811790915560058054909181016107b583826115a5565b5060009182526020909120018054600160a060020a031916600160a060020a0392909216919091179055565b60005433600160a060020a039081169116146107fc57600080fd5b600160a060020a038116151561081157600080fd5b6001547f3b81caf78fa51ecbc8acb482fd7012a277b428d9b80f9d156e8a54107496cc4090600160a060020a0316604051600160a060020a03909116815260200160405180910390a160018054600160a060020a031916600160a060020a0392909216919091179055565b600160a060020a03331660009081526002602052604090205460ff1615156108a357600080fd5b60648111156108b157600080fd5b7fd0f6fc40d497232b5aab1b7a34ea00ea45886e52d2fed39ad62af798a870fae381600854336040519283526020830191909152600160a060020a03166040808301919091526060909101905180910390a1600855565b60015433600160a060020a0390811691161461092357600080fd5b6001546000547f65da1cfc2c2e81576ad96afb24a581f8e109b7a403b35cbd3243a1c99efdb9ed91600160a060020a039081169116604051600160a060020a039283168152911660208201526040908101905180910390a16001805460008054600160a060020a0319908116600160a060020a03841617909155169055565b60005433600160a060020a039081169116146109bd57600080fd5b600160a060020a03811615156109d257600080fd5b7f3b81caf78fa51ecbc8acb482fd7012a277b428d9b80f9d156e8a54107496cc4081604051600160a060020a03909116815260200160405180910390a16000547f65da1cfc2c2e81576ad96afb24a581f8e109b7a403b35cbd3243a1c99efdb9ed908290600160a060020a0316604051600160a060020a039283168152911660208201526040908101905180910390a160008054600160a060020a031916600160a060020a0392909216919091179055565b610a8c6115ce565b60058054806020026020016040519081016040528092919081815260200182805480156105e357602002820191906000526020600020908154600160a060020a031681526001909101906020018083116105c5575050505050905090565b60005433600160a060020a03908116911614610b0557600080fd5b600160a060020a03811660009081526002602052604090205460ff1615610b2b57600080fd5b60045460329010610b3b57600080fd5b7f091a7a4b85135fdd7e8dbc18b12fabe5cc191ea867aa3c2e1a24a102af61d58b816001604051600160a060020a039092168252151560208201526040908101905180910390a1600160a060020a0381166000908152600260205260409020805460ff1916600190811790915560048054909181016107b583826115a5565b60095481565b60085481565b6000805433600160a060020a03908116911614610be257600080fd5b600160a060020a03821660009081526002602052604090205460ff161515610c0957600080fd5b50600160a060020a0381166000908152600260205260408120805460ff191690555b6004548110156105725781600160a060020a0316600482815481101515610c4e57fe5b600091825260209091200154600160a060020a03161415610d2a57600480546000198101908110610c7b57fe5b60009182526020909120015460048054600160a060020a039092169183908110610ca157fe5b60009182526020909120018054600160a060020a031916600160a060020a0392909216919091179055600480546000190190610cdd90826115a5565b507f091a7a4b85135fdd7e8dbc18b12fabe5cc191ea867aa3c2e1a24a102af61d58b826000604051600160a060020a039092168252151560208201526040908101905180910390a1610572565b600101610c2b565b600754600160a060020a031681565b60005433600160a060020a03908116911614610d5c57600080fd5b600160a060020a03811682156108fc0283604051600060405180830381858888f193505050501515610d8d57600080fd5b7fec47e7ed86c86774d1a72c19f35c639911393fe7c1a34031fdbd260890da90de8282604051918252600160a060020a031660208201526040908101905180910390a15050565b600080600080600854600014151515610dec57600080fd5b6b204fce5e3e25026110000000861115610e0557600080fd5b6008546b204fce5e3e250261100000009087021115610e2357600080fd5b851515610e2f57600195505b60009150610e3f8888888861110f565b909550935091508115610e585760009350839250610f08565b831515610e6e57610e6b8888888861122a565b93505b600a54600160a060020a038981169116148015610ea75750600160a060020a03871673eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee145b8015610eba5750670de0b6b3a764000086145b15610ed257610ec884611061565b15610ed257600093505b69d3c21bcecceda1000000841115610ef05760009350839250610f08565b50600954612710908103840204808310610f08578092505b505094509492505050565b6000600160a060020a03831673eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee1415610f4b5750600160a060020a03811631610fbf565b82600160a060020a03166370a082318360006040516020015260405160e060020a63ffffffff8416028152600160a060020a039091166004820152602401602060405180830381600087803b1515610fa257600080fd5b6102c65a03f11515610fb357600080fd5b50505060405180519150505b92915050565b600160a060020a03331660009081526002602052604090205460ff161515610fec57600080fd5b612710811115610ffb57600080fd5b7f4357e20f1241d972328c5b3239d9ef4ac96f0f4fce8e10fd3bf9053690dad0ac81600954336040519283526020830191909152600160a060020a03166040808301919091526060909101905180910390a1600955565b600a54600160a060020a031681565b600a546000908190819061109e9073eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee90600160a060020a0316670de0b6b3a76400006001610dd4565b90925090508115156110b357600192506110f9565b69d3c21bcecceda100000082118015906110d7575069d3c21bcecceda10000008411155b15156110e257600080fd5b6ec097ce7bc90715b34b9f10000000008285021192505b5050919050565b600054600160a060020a031681565b60008060008084611176576040517f66696e6442657374526174654f6e6c795065726d697373696f6e28616464726581527f73732c616464726573732c75696e743235362900000000000000000000000000602082015260330160405180910390206111ce565b6040517f66696e64426573745261746528616464726573732c616464726573732c75696e81527f7432353629000000000000000000000000000000000000000000000000000000602082015260250160405180910390205b90506111dc888888846113c4565b909450925083156111f757600193506000925082915061121f565b60085460011461121b5761121188886008548902846113c4565b909450915061121f565b8291505b509450945094915050565b6007546000908190819081908190600160a060020a0316630c235d968a73eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee8a8a866040516040015260405160e060020a63ffffffff8716028152600160a060020a039485166004820152929093166024830152604482015290151560648201526084016040805180830381600087803b15156112b957600080fd5b6102c65a03f115156112ca57600080fd5b505050604051805190602001805191955090935061130090508973eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee8986611427565b600754909150600160a060020a0316630c235d9673eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee8a848a60006040516040015260405160e060020a63ffffffff8716028152600160a060020a039485166004820152929093166024830152604482015290151560648201526084016040805180830381600087803b151561138857600080fd5b6102c65a03f1151561139957600080fd5b5050506040518051906020018051670de0b6b3a76400009502949094049a9950505050505050505050565b6007546000908190600160a060020a03168160405185815288600482015287602482015286604482015260a48101604052604060648201606483865afa91506084810151604091909152925060018114610f085760019350505094509492505050565b60006114458361143687611450565b61143f87611450565b85611514565b90505b949350505050565b600080600160a060020a03831673eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee1415611481576012915061150e565b50600160a060020a03821660009081526006602052604090205480151561150a5782600160a060020a031663313ce5676000604051602001526040518163ffffffff1660e060020a028152600401602060405180830381600087803b15156114e857600080fd5b6102c65a03f115156114f957600080fd5b50505060405180519050915061150e565b8091505b50919050565b60006b204fce5e3e2502611000000085111561152f57600080fd5b69d3c21bcecceda100000082111561154657600080fd5b838310611579576012848403111561155d57600080fd5b670de0b6b3a7640000858302858503600a0a025b049050611448565b6012838503111561158957600080fd5b828403600a0a670de0b6b3a76400000282860281151561157157fe5b8154818355818115116115c9576000838152602090206115c99181019083016115e0565b505050565b60206040519081016040526000815290565b6105eb91905b808211156115fa57600081556001016115e6565b50905600a165627a7a7230582054d549c95ab5c4af45bae32debdd4053be0e7c978ce2427acf20e9eb9d0266b300290000000000000000000000009ae49c0d7f8f9ef4b864e004fe86ac8294e20950000000000000000000000000dd974d5c2e2928dea5f71b9825b8b646686bd2000000000000000000000000009b4ed4871113b7474dcca5ba9e2cbd9cc2031534",
  "constructorArguments": "0000000000000000000000009ae49c0d7f8f9ef4b864e004fe86ac8294e20950000000000000000000000000dd974d5c2e2928dea5f71b9825b8b646686bd2000000000000000000000000009b4ed4871113b7474dcca5ba9e2cbd9cc2031534"
}