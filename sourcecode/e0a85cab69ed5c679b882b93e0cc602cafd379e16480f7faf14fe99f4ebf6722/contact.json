{
  "address": "0x1f03a2dec4aa3a491b5c27c5a3383aa484a152aa",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "BetContract",
  "compilerVersion": "v0.4.23-nightly.2018.4.19+commit.ae834e3d",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2018-11-26\n*/\n\npragma solidity ^0.4.20;\n/* import \"github.com/oraclize/ethereum-api/oraclizeAPI.sol\"; */\n\n\ncontract OraclizeI {\n    address public cbAddress;\n    function query(uint _timestamp, string _datasource, string _arg) external payable returns (bytes32 _id);\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) external payable returns (bytes32 _id);\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) public payable returns (bytes32 _id);\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) external payable returns (bytes32 _id);\n    function queryN(uint _timestamp, string _datasource, bytes _argN) public payable returns (bytes32 _id);\n    function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) external payable returns (bytes32 _id);\n    function getPrice(string _datasource) public returns (uint _dsprice);\n    function getPrice(string _datasource, uint gaslimit) public returns (uint _dsprice);\n    function setProofType(byte _proofType) external;\n    function setCustomGasPrice(uint _gasPrice) external;\n    function randomDS_getSessionPubKeyHash() external constant returns(bytes32);\n}\ncontract OraclizeAddrResolverI {\n    function getAddress() public returns (address _addr);\n}\ncontract usingOraclize {\n    uint constant day = 60*60*24;\n    uint constant week = 60*60*24*7;\n    uint constant month = 60*60*24*30;\n    byte constant proofType_NONE = 0x00;\n    byte constant proofType_TLSNotary = 0x10;\n    byte constant proofType_Android = 0x20;\n    byte constant proofType_Ledger = 0x30;\n    byte constant proofType_Native = 0xF0;\n    byte constant proofStorage_IPFS = 0x01;\n    uint8 constant networkID_auto = 0;\n    uint8 constant networkID_mainnet = 1;\n    uint8 constant networkID_testnet = 2;\n    uint8 constant networkID_morden = 2;\n    uint8 constant networkID_consensys = 161;\n\n    OraclizeAddrResolverI OAR;\n\n    OraclizeI oraclize;\n    modifier oraclizeAPI {\n        if((address(OAR)==0)||(getCodeSize(address(OAR))==0))\n            oraclize_setNetwork(networkID_auto);\n\n        if(address(oraclize) != OAR.getAddress())\n            oraclize = OraclizeI(OAR.getAddress());\n\n        _;\n    }\n    modifier coupon(string code){\n        oraclize = OraclizeI(OAR.getAddress());\n        _;\n    }\n\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n      return oraclize_setNetwork();\n      networkID; // silence the warning and remain backwards compatible\n    }\n    function oraclize_setNetwork() internal returns(bool){\n        if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){ //mainnet\n            OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\n            oraclize_setNetworkName(\"eth_mainnet\");\n            return true;\n        }\n        if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){ //ropsten testnet\n            OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\n            oraclize_setNetworkName(\"eth_ropsten3\");\n            return true;\n        }\n        if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){ //kovan testnet\n            OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\n            oraclize_setNetworkName(\"eth_kovan\");\n            return true;\n        }\n        if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){ //rinkeby testnet\n            OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\n            oraclize_setNetworkName(\"eth_rinkeby\");\n            return true;\n        }\n        if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){ //ethereum-bridge\n            OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\n            return true;\n        }\n        if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){ //ether.camp ide\n            OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\n            return true;\n        }\n        if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){ //browser-solidity\n            OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\n            return true;\n        }\n        return false;\n    }\n\n    function __callback(bytes32 myid, string result) public {\n        __callback(myid, result, new bytes(0));\n    }\n    function __callback(bytes32 myid, string result, bytes proof) public {\n      return;\n      myid; result; proof; // Silence compiler warnings\n    }\n\n    function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\n        return oraclize.getPrice(datasource);\n    }\n\n    function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\n        return oraclize.getPrice(datasource, gaslimit);\n    }\n\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(0, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(timestamp, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        bytes memory args = stra2cbor(argN);\n        return oraclize.queryN.value(price)(0, datasource, args);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        bytes memory args = stra2cbor(argN);\n        return oraclize.queryN.value(price)(timestamp, datasource, args);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        bytes memory args = stra2cbor(argN);\n        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n    }\n    function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        bytes memory args = stra2cbor(argN);\n        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n    }\n    function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](1);\n        dynargs[0] = args[0];\n        return oraclize_query(datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](1);\n        dynargs[0] = args[0];\n        return oraclize_query(timestamp, datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](1);\n        dynargs[0] = args[0];\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](1);\n        dynargs[0] = args[0];\n        return oraclize_query(datasource, dynargs, gaslimit);\n    }\n\n    function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](2);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        return oraclize_query(datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](2);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        return oraclize_query(timestamp, datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](2);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](2);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        return oraclize_query(datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](3);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        return oraclize_query(datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](3);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        return oraclize_query(timestamp, datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](3);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](3);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        return oraclize_query(datasource, dynargs, gaslimit);\n    }\n\n    function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](4);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        return oraclize_query(datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](4);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        return oraclize_query(timestamp, datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](4);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](4);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        return oraclize_query(datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](5);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        dynargs[4] = args[4];\n        return oraclize_query(datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](5);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        dynargs[4] = args[4];\n        return oraclize_query(timestamp, datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](5);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        dynargs[4] = args[4];\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](5);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        dynargs[4] = args[4];\n        return oraclize_query(datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        bytes memory args = ba2cbor(argN);\n        return oraclize.queryN.value(price)(0, datasource, args);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        bytes memory args = ba2cbor(argN);\n        return oraclize.queryN.value(price)(timestamp, datasource, args);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        bytes memory args = ba2cbor(argN);\n        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n    }\n    function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        bytes memory args = ba2cbor(argN);\n        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n    }\n    function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](1);\n        dynargs[0] = args[0];\n        return oraclize_query(datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](1);\n        dynargs[0] = args[0];\n        return oraclize_query(timestamp, datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](1);\n        dynargs[0] = args[0];\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](1);\n        dynargs[0] = args[0];\n        return oraclize_query(datasource, dynargs, gaslimit);\n    }\n\n    function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](2);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        return oraclize_query(datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](2);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        return oraclize_query(timestamp, datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](2);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](2);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        return oraclize_query(datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](3);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        return oraclize_query(datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](3);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        return oraclize_query(timestamp, datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](3);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](3);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        return oraclize_query(datasource, dynargs, gaslimit);\n    }\n\n    function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](4);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        return oraclize_query(datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](4);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        return oraclize_query(timestamp, datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](4);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](4);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        return oraclize_query(datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](5);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        dynargs[4] = args[4];\n        return oraclize_query(datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](5);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        dynargs[4] = args[4];\n        return oraclize_query(timestamp, datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](5);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        dynargs[4] = args[4];\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](5);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        dynargs[4] = args[4];\n        return oraclize_query(datasource, dynargs, gaslimit);\n    }\n\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\n        return oraclize.cbAddress();\n    }\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\n        return oraclize.setProofType(proofP);\n    }\n    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\n        return oraclize.setCustomGasPrice(gasPrice);\n    }\n\n    function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){\n        return oraclize.randomDS_getSessionPubKeyHash();\n    }\n\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\n        assembly {\n            _size := extcodesize(_addr)\n        }\n    }\n\n    function parseAddr(string _a) internal pure returns (address){\n        bytes memory tmp = bytes(_a);\n        uint160 iaddr = 0;\n        uint160 b1;\n        uint160 b2;\n        for (uint i=2; i<2+2*20; i+=2){\n            iaddr *= 256;\n            b1 = uint160(tmp[i]);\n            b2 = uint160(tmp[i+1]);\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n            else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n            else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n            iaddr += (b1*16+b2);\n        }\n        return address(iaddr);\n    }\n\n    function strCompare(string _a, string _b) internal pure returns (int) {\n        bytes memory a = bytes(_a);\n        bytes memory b = bytes(_b);\n        uint minLength = a.length;\n        if (b.length < minLength) minLength = b.length;\n        for (uint i = 0; i < minLength; i ++)\n            if (a[i] < b[i])\n                return -1;\n            else if (a[i] > b[i])\n                return 1;\n        if (a.length < b.length)\n            return -1;\n        else if (a.length > b.length)\n            return 1;\n        else\n            return 0;\n    }\n\n    function indexOf(string _haystack, string _needle) internal pure returns (int) {\n        bytes memory h = bytes(_haystack);\n        bytes memory n = bytes(_needle);\n        if(h.length < 1 || n.length < 1 || (n.length > h.length))\n            return -1;\n        else if(h.length > (2**128 -1))\n            return -1;\n        else\n        {\n            uint subindex = 0;\n            for (uint i = 0; i < h.length; i ++)\n            {\n                if (h[i] == n[0])\n                {\n                    subindex = 1;\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n                    {\n                        subindex++;\n                    }\n                    if(subindex == n.length)\n                        return int(i);\n                }\n            }\n            return -1;\n        }\n    }\n\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n        bytes memory _ba = bytes(_a);\n        bytes memory _bb = bytes(_b);\n        bytes memory _bc = bytes(_c);\n        bytes memory _bd = bytes(_d);\n        bytes memory _be = bytes(_e);\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n        bytes memory babcde = bytes(abcde);\n        uint k = 0;\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n        return string(babcde);\n    }\n\n    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n        return strConcat(_a, _b, _c, _d, \"\");\n    }\n\n    function strConcat(string _a, string _b, string _c) internal pure returns (string) {\n        return strConcat(_a, _b, _c, \"\", \"\");\n    }\n\n    function strConcat(string _a, string _b) internal pure returns (string) {\n        return strConcat(_a, _b, \"\", \"\", \"\");\n    }\n\n    // parseInt\n    function parseInt(string _a) internal pure returns (uint) {\n        return parseInt(_a, 0);\n    }\n\n    // parseInt(parseFloat*10^_b)\n    function parseInt(string _a, uint _b) internal pure returns (uint) {\n        bytes memory bresult = bytes(_a);\n        uint mint = 0;\n        bool decimals = false;\n        for (uint i=0; i<bresult.length; i++){\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n                if (decimals){\n                   if (_b == 0) break;\n                    else _b--;\n                }\n                mint *= 10;\n                mint += uint(bresult[i]) - 48;\n            } else if (bresult[i] == 46) decimals = true;\n        }\n        if (_b > 0) mint *= 10**_b;\n        return mint;\n    }\n\n    function uint2str(uint i) internal pure returns (string){\n        if (i == 0) return \"0\";\n        uint j = i;\n        uint len;\n        while (j != 0){\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint k = len - 1;\n        while (i != 0){\n            bstr[k--] = byte(48 + i % 10);\n            i /= 10;\n        }\n        return string(bstr);\n    }\n\n    function stra2cbor(string[] arr) internal pure returns (bytes) {\n            uint arrlen = arr.length;\n\n            // get correct cbor output length\n            uint outputlen = 0;\n            bytes[] memory elemArray = new bytes[](arrlen);\n            for (uint i = 0; i < arrlen; i++) {\n                elemArray[i] = (bytes(arr[i]));\n                outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3; //+3 accounts for paired identifier types\n            }\n            uint ctr = 0;\n            uint cborlen = arrlen + 0x80;\n            outputlen += byte(cborlen).length;\n            bytes memory res = new bytes(outputlen);\n\n            while (byte(cborlen).length > ctr) {\n                res[ctr] = byte(cborlen)[ctr];\n                ctr++;\n            }\n            for (i = 0; i < arrlen; i++) {\n                res[ctr] = 0x5F;\n                ctr++;\n                for (uint x = 0; x < elemArray[i].length; x++) {\n                    // if there's a bug with larger strings, this may be the culprit\n                    if (x % 23 == 0) {\n                        uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\n                        elemcborlen += 0x40;\n                        uint lctr = ctr;\n                        while (byte(elemcborlen).length > ctr - lctr) {\n                            res[ctr] = byte(elemcborlen)[ctr - lctr];\n                            ctr++;\n                        }\n                    }\n                    res[ctr] = elemArray[i][x];\n                    ctr++;\n                }\n                res[ctr] = 0xFF;\n                ctr++;\n            }\n            return res;\n        }\n\n    function ba2cbor(bytes[] arr) internal pure returns (bytes) {\n            uint arrlen = arr.length;\n\n            // get correct cbor output length\n            uint outputlen = 0;\n            bytes[] memory elemArray = new bytes[](arrlen);\n            for (uint i = 0; i < arrlen; i++) {\n                elemArray[i] = (bytes(arr[i]));\n                outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3; //+3 accounts for paired identifier types\n            }\n            uint ctr = 0;\n            uint cborlen = arrlen + 0x80;\n            outputlen += byte(cborlen).length;\n            bytes memory res = new bytes(outputlen);\n\n            while (byte(cborlen).length > ctr) {\n                res[ctr] = byte(cborlen)[ctr];\n                ctr++;\n            }\n            for (i = 0; i < arrlen; i++) {\n                res[ctr] = 0x5F;\n                ctr++;\n                for (uint x = 0; x < elemArray[i].length; x++) {\n                    // if there's a bug with larger strings, this may be the culprit\n                    if (x % 23 == 0) {\n                        uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\n                        elemcborlen += 0x40;\n                        uint lctr = ctr;\n                        while (byte(elemcborlen).length > ctr - lctr) {\n                            res[ctr] = byte(elemcborlen)[ctr - lctr];\n                            ctr++;\n                        }\n                    }\n                    res[ctr] = elemArray[i][x];\n                    ctr++;\n                }\n                res[ctr] = 0xFF;\n                ctr++;\n            }\n            return res;\n        }\n\n\n    string oraclize_network_name;\n    function oraclize_setNetworkName(string _network_name) internal {\n        oraclize_network_name = _network_name;\n    }\n\n    function oraclize_getNetworkName() internal view returns (string) {\n        return oraclize_network_name;\n    }\n\n    function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\n        require((_nbytes > 0) && (_nbytes <= 32));\n        // Convert from seconds to ledger timer ticks\n        _delay *= 10;\n        bytes memory nbytes = new bytes(1);\n        nbytes[0] = byte(_nbytes);\n        bytes memory unonce = new bytes(32);\n        bytes memory sessionKeyHash = new bytes(32);\n        bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();\n        assembly {\n            mstore(unonce, 0x20)\n            mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\n            mstore(sessionKeyHash, 0x20)\n            mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\n        }\n        bytes memory delay = new bytes(32);\n        assembly {\n            mstore(add(delay, 0x20), _delay)\n        }\n\n        bytes memory delay_bytes8 = new bytes(8);\n        copyBytes(delay, 24, 8, delay_bytes8, 0);\n\n        bytes[4] memory args = [unonce, nbytes, sessionKeyHash, delay];\n        bytes32 queryId = oraclize_query(\"random\", args, _customGasLimit);\n\n        bytes memory delay_bytes8_left = new bytes(8);\n\n        assembly {\n            let x := mload(add(delay_bytes8, 0x20))\n            mstore8(add(delay_bytes8_left, 0x27), div(x, 0x100000000000000000000000000000000000000000000000000000000000000))\n            mstore8(add(delay_bytes8_left, 0x26), div(x, 0x1000000000000000000000000000000000000000000000000000000000000))\n            mstore8(add(delay_bytes8_left, 0x25), div(x, 0x10000000000000000000000000000000000000000000000000000000000))\n            mstore8(add(delay_bytes8_left, 0x24), div(x, 0x100000000000000000000000000000000000000000000000000000000))\n            mstore8(add(delay_bytes8_left, 0x23), div(x, 0x1000000000000000000000000000000000000000000000000000000))\n            mstore8(add(delay_bytes8_left, 0x22), div(x, 0x10000000000000000000000000000000000000000000000000000))\n            mstore8(add(delay_bytes8_left, 0x21), div(x, 0x100000000000000000000000000000000000000000000000000))\n            mstore8(add(delay_bytes8_left, 0x20), div(x, 0x1000000000000000000000000000000000000000000000000))\n\n        }\n\n        oraclize_randomDS_setCommitment(queryId, keccak256(delay_bytes8_left, args[1], sha256(args[0]), args[2]));\n        return queryId;\n    }\n\n    function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {\n        oraclize_randomDS_args[queryId] = commitment;\n    }\n\n    mapping(bytes32=>bytes32) oraclize_randomDS_args;\n    mapping(bytes32=>bool) oraclize_randomDS_sessionKeysHashVerified;\n\n    function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){\n        bool sigok;\n        address signer;\n\n        bytes32 sigr;\n        bytes32 sigs;\n\n        bytes memory sigr_ = new bytes(32);\n        uint offset = 4+(uint(dersig[3]) - 0x20);\n        sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);\n        bytes memory sigs_ = new bytes(32);\n        offset += 32 + 2;\n        sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);\n\n        assembly {\n            sigr := mload(add(sigr_, 32))\n            sigs := mload(add(sigs_, 32))\n        }\n\n\n        (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);\n        if (address(keccak256(pubkey)) == signer) return true;\n        else {\n            (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);\n            return (address(keccak256(pubkey)) == signer);\n        }\n    }\n\n    function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {\n        bool sigok;\n\n        // Step 6: verify the attestation signature, APPKEY1 must sign the sessionKey from the correct ledger app (CODEHASH)\n        bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);\n        copyBytes(proof, sig2offset, sig2.length, sig2, 0);\n\n        bytes memory appkey1_pubkey = new bytes(64);\n        copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);\n\n        bytes memory tosign2 = new bytes(1+65+32);\n        tosign2[0] = byte(1); //role\n        copyBytes(proof, sig2offset-65, 65, tosign2, 1);\n        bytes memory CODEHASH = hex\"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c\";\n        copyBytes(CODEHASH, 0, 32, tosign2, 1+65);\n        sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);\n\n        if (sigok == false) return false;\n\n\n        // Step 7: verify the APPKEY1 provenance (must be signed by Ledger)\n        bytes memory LEDGERKEY = hex\"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4\";\n\n        bytes memory tosign3 = new bytes(1+65);\n        tosign3[0] = 0xFE;\n        copyBytes(proof, 3, 65, tosign3, 1);\n\n        bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);\n        copyBytes(proof, 3+65, sig3.length, sig3, 0);\n\n        sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);\n\n        return sigok;\n    }\n\n    modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {\n        // Step 1: the prefix has to match 'LP\\x01' (Ledger Proof version 1)\n        require((_proof[0] == \"L\") && (_proof[1] == \"P\") && (_proof[2] == 1));\n\n        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n        require(proofVerified);\n\n        _;\n    }\n\n    function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){\n        // Step 1: the prefix has to match 'LP\\x01' (Ledger Proof version 1)\n        if ((_proof[0] != \"L\")||(_proof[1] != \"P\")||(_proof[2] != 1)) return 1;\n\n        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n        if (proofVerified == false) return 2;\n\n        return 0;\n    }\n\n    function matchBytes32Prefix(bytes32 content, bytes prefix, uint n_random_bytes) internal pure returns (bool){\n        bool match_ = true;\n\n        require(prefix.length == n_random_bytes);\n\n        for (uint256 i=0; i< n_random_bytes; i++) {\n            if (content[i] != prefix[i]) match_ = false;\n        }\n\n        return match_;\n    }\n\n    function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\n\n        // Step 2: the unique keyhash has to match with the sha256 of (context name + queryId)\n        uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32;\n        bytes memory keyhash = new bytes(32);\n        copyBytes(proof, ledgerProofLength, 32, keyhash, 0);\n        if (!(keccak256(keyhash) == keccak256(sha256(context_name, queryId)))) return false;\n\n        bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2);\n        copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0);\n\n        // Step 3: we assume sig1 is valid (it will be verified during step 5) and we verify if 'result' is the prefix of sha256(sig1)\n        if (!matchBytes32Prefix(sha256(sig1), result, uint(proof[ledgerProofLength+32+8]))) return false;\n\n        // Step 4: commitment match verification, keccak256(delay, nbytes, unonce, sessionKeyHash) == commitment in storage.\n        // This is to verify that the computed args match with the ones specified in the query.\n        bytes memory commitmentSlice1 = new bytes(8+1+32);\n        copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0);\n\n        bytes memory sessionPubkey = new bytes(64);\n        uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65;\n        copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0);\n\n        bytes32 sessionPubkeyHash = sha256(sessionPubkey);\n        if (oraclize_randomDS_args[queryId] == keccak256(commitmentSlice1, sessionPubkeyHash)){ //unonce, nbytes and sessionKeyHash match\n            delete oraclize_randomDS_args[queryId];\n        } else return false;\n\n\n        // Step 5: validity verification for sig1 (keyhash and args signed with the sessionKey)\n        bytes memory tosign1 = new bytes(32+8+1+32);\n        copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0);\n        if (!verifySig(sha256(tosign1), sig1, sessionPubkey)) return false;\n\n        // verify if sessionPubkeyHash was verified already, if not.. let's do it!\n        if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){\n            oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);\n        }\n\n        return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];\n    }\n\n    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\n    function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal pure returns (bytes) {\n        uint minLength = length + toOffset;\n\n        // Buffer too small\n        require(to.length >= minLength); // Should be a better way?\n\n        // NOTE: the offset 32 is added to skip the `size` field of both bytes variables\n        uint i = 32 + fromOffset;\n        uint j = 32 + toOffset;\n\n        while (i < (32 + fromOffset + length)) {\n            assembly {\n                let tmp := mload(add(from, i))\n                mstore(add(to, j), tmp)\n            }\n            i += 32;\n            j += 32;\n        }\n\n        return to;\n    }\n\n    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\n    // Duplicate Solidity's ecrecover, but catching the CALL return value\n    function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\n        // We do our own memory management here. Solidity uses memory offset\n        // 0x40 to store the current end of memory. We write past it (as\n        // writes are memory extensions), but don't update the offset so\n        // Solidity will reuse it. The memory used here is only needed for\n        // this context.\n\n        // FIXME: inline assembly can't access return values\n        bool ret;\n        address addr;\n\n        assembly {\n            let size := mload(0x40)\n            mstore(size, hash)\n            mstore(add(size, 32), v)\n            mstore(add(size, 64), r)\n            mstore(add(size, 96), s)\n\n            // NOTE: we can reuse the request memory because we deal with\n            //       the return code\n            ret := call(3000, 1, 0, size, 128, size, 32)\n            addr := mload(size)\n        }\n\n        return (ret, addr);\n    }\n\n    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\n    function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        if (sig.length != 65)\n          return (false, 0);\n\n        // The signature format is a compact form of:\n        //   {bytes32 r}{bytes32 s}{uint8 v}\n        // Compact means, uint8 is not padded to 32 bytes.\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n\n            // Here we are loading the last 32 bytes. We exploit the fact that\n            // 'mload' will pad with zeroes if we overread.\n            // There is no 'mload8' to do this, but that would be nicer.\n            v := byte(0, mload(add(sig, 96)))\n\n            // Alternative solution:\n            // 'byte' is not working due to the Solidity parser, so lets\n            // use the second best option, 'and'\n            // v := and(mload(add(sig, 65)), 255)\n        }\n\n        // albeit non-transactional signatures are not specified by the YP, one would expect it\n        // to match the YP range of [27, 28]\n        //\n        // geth uses [0, 1] and some clients have followed. This might change, see:\n        //  https://github.com/ethereum/go-ethereum/issues/2053\n        if (v < 27)\n          v += 27;\n\n        if (v != 27 && v != 28)\n            return (false, 0);\n\n        return safer_ecrecover(hash, v, r, s);\n    }\n\n}\n\ncontract BetContract is usingOraclize{\n  uint  maxProfit;//最高奖池\n  uint  maxmoneypercent;\n  uint public contractBalance;\n  uint minBet;\n  uint onoff;//游戏启用或关闭\n  address private owner;\n  uint private orderId;\n  uint private randonce;\n\n  event LogNewOraclizeQuery(string description,bytes32 queryId);\n  event LogNewRandomNumber(string result,bytes32 queryId);\n  event LogSendBonus(uint id,bytes32 lableId,uint playId,uint content,uint singleMoney,uint mutilple,address user,uint betTime,uint status,uint winMoney);\n\n  mapping (address => bytes32[]) playerLableList;//玩家下注批次\n  mapping (bytes32 => mapping (uint => uint[7])) betList;//批次，注单映射\n  mapping (bytes32 => uint) lableCount;//批次，注单数\n  mapping (bytes32 => uint) lableTime;//批次，投注时间\n  mapping (bytes32 => uint) lableStatus;//批次，状态 0 未结算，1 已撤单，2 已结算 3 已派奖\n  mapping (bytes32 => uint[3]) openNumberList;//批次开奖号码映射\n  mapping (bytes32 => string) openNumberStr;//批次开奖号码映射\n  mapping (bytes32 => address) lableUser;\n\n  function BetContract() public {\n    owner = msg.sender;\n    orderId = 0;\n\n    onoff=1;\n    minBet=1500000000000000;//最小金额要比手续费大\n    maxmoneypercent=80;\n    contractBalance = this.balance;\n    maxProfit=(this.balance * maxmoneypercent)/100;\n    randonce = 0;\n  }\n\n  /*\n    * uintToString\n    */\n   function uintToString(uint i) internal  returns (string){\n       if (i == 0) return \"0\";\n       uint j = i;\n       uint len;\n       while (j != 0){\n           len++;\n           j /= 10;\n       }\n       bytes memory bstr = new bytes(len);\n       uint k = len - 1;\n       while (i != 0){\n           bstr[k--] = byte(48 + i % 10);\n           i /= 10;\n       }\n       return string(bstr);\n   }\n\n\n  modifier onlyAdmin() {\n      require(msg.sender == owner);\n      _;\n  }\n\n  function setGameOnoff(uint _on0ff) public onlyAdmin{\n    onoff=_on0ff;\n  }\n\n  function getPlayRate(uint playId,uint level) internal pure returns (uint){\n      uint result = 0;\n      if(playId == 1 || playId == 2){\n        //大小单双，赔率放大了10倍\n        result = 19;\n      }else if(playId == 3){\n        //二同号复选\n        result = 11;\n      }else if(playId == 4){\n        //三同号单选\n        result = 156;\n      }else if(playId == 5){\n        //三同号通选\n        result = 26;\n      }else if(playId == 6){\n        //和值\n        if(level == 4 || level == 17){\n          result = 53;\n        }else if(level == 5 || level == 16){\n          result = 21;\n        }else if(level == 6 || level == 15){\n          result = 17;\n        }else if(level == 7 || level == 14){\n          result = 13;\n        }else if(level == 8 || level == 13){\n          result = 9;\n        }else if(level == 9 || level == 12){\n          result = 8;\n        }else if(level == 10 || level == 11){\n          result = 7;\n        }\n      }else if(playId == 7){\n        //二不同号\n        result = 6;\n      }else if(playId == 8){\n        //猜1个号，赔率放大了10倍\n        if(level == 1){\n          result = 19;//单色子\n        }else if(level == 2){\n          result = 28;//对子\n        }else if(level == 3){\n          result = 37;//豹子\n        }\n      }\n      return result;\n    }\n\n    function doBet(uint[] playid,uint[] betMoney,uint[] betContent,uint mutiply) public payable returns (bytes32) {\n      require(onoff==1);\n      require(playid.length > 0);\n      require(mutiply > 0);\n      require(msg.value >= minBet);\n\n      /* checkBet(playid,betMoney,betContent,mutiply,msg.value); */\n\n      /* uint total = 0; */\n      bytes32 queryId;\n      queryId = keccak256(block.blockhash(block.number-1),now,randonce);\n\n       uint[7] tmp ;\n       uint totalspand = 0;\n      for(uint i=0;i<playid.length;i++){\n        orderId++;\n        tmp[0] =orderId;\n        tmp[1] =playid[i];\n        tmp[2] =betContent[i];\n        tmp[3] =betMoney[i]*mutiply;\n        totalspand +=betMoney[i]*mutiply;\n        tmp[4] =now;\n        tmp[5] =0;\n        tmp[6] =0;\n        betList[queryId][i] =tmp;\n      }\n      require(msg.value >= totalspand);\n\n      lableTime[queryId] = now;\n      lableCount[queryId] = playid.length;\n      lableUser[queryId] = msg.sender;\n      uint[3] memory codes = [uint(0),0,0];//开奖号码\n      openNumberList[queryId] = codes;\n      openNumberStr[queryId] =\"0,0,0\";\n      lableStatus[queryId] = 0;\n\n      uint index=playerLableList[msg.sender].length++;\n      playerLableList[msg.sender][index]=queryId;//index:id\n      opencode(queryId);\n      return queryId;\n    }\n\n    function checkBet(uint[] playid,uint[] betMoney,uint[] betContent,uint mutiply,uint betTotal) internal{\n        uint totalMoney = 0;\n      uint totalWin1 = 0;//三个开奖号码不同时的盈利\n      uint totalWin2 = 0;//两个开奖号码相同时的盈利\n      uint totalWin3 = 0;//三个号码相同时的盈利\n      uint rate;\n      uint i;\n      for(i=0;i<playid.length;i++){\n        if(playid[i] >=1 && playid[i]<= 8){\n          totalMoney += betMoney[i] * mutiply;\n        }else{\n          throw;\n        }\n        if(playid[i] ==1 || playid[i] ==2){\n          rate = getPlayRate(playid[i],0)-10;\n          totalWin1+=betMoney[i] * mutiply *rate/10;\n          totalWin2+=betMoney[i] * mutiply *rate/10;\n        }else if(playid[i] ==3){\n          rate = getPlayRate(playid[i],0)-1;\n          totalWin2+=betMoney[i] * mutiply *rate;\n          totalWin3+=betMoney[i] * mutiply *rate;\n        }else if(playid[i] ==4 || playid[i] ==5){\n          rate = getPlayRate(playid[i],0)-1;\n          totalWin3+=betMoney[i] * mutiply *rate;\n        }else if(playid[i] ==6){\n          rate = getPlayRate(playid[i],betContent[i])-1;\n          totalWin1+=betMoney[i] * mutiply *rate;\n          totalWin2+=betMoney[i] * mutiply *rate;\n        }else if(playid[i] ==7){\n          rate = getPlayRate(playid[i],0)-1;\n          totalWin1+=betMoney[i] * mutiply *rate;\n          totalWin2+=betMoney[i] * mutiply *rate;\n        }else if(playid[i] ==8){\n          totalWin1+=betMoney[i] * mutiply *9/10;\n          totalWin2+=betMoney[i] * mutiply *18/10;\n          totalWin3+=betMoney[i] * mutiply *27/10;\n        }\n      }\n      uint maxWin=totalWin1;\n      if(totalWin2 > maxWin){\n        maxWin=totalWin2;\n      }\n      if(totalWin3 > maxWin){\n        maxWin=totalWin3;\n      }\n      require(betTotal >= totalMoney);\n\n      require(maxWin < maxProfit);\n    }\n    \n    function opencode(bytes32 queryId) private {\n      if (lableCount[queryId] < 1) revert();\n      uint[3] memory codes = [uint(0),0,0];//开奖号码\n\n      bytes32 code0hash = keccak256(abi.encodePacked(block.blockhash(block.number-1), now,msg.sender,randonce));\n      randonce  = randonce + uint(code0hash)%10;\n      uint code0int = uint(code0hash) % 6 + 1;\n      bytes32 code1hash = keccak256(abi.encodePacked(block.blockhash(block.number-1), now,msg.sender,randonce));\n      randonce  = randonce + uint(code1hash)%10;\n      uint code1int = uint(code1hash) % 6 + 1;\n      bytes32 code2hash = keccak256(abi.encodePacked(block.blockhash(block.number-1), now,msg.sender,randonce));\n      randonce  = randonce + uint(code2hash)%10;\n      uint code2int = uint(code2hash) % 6 + 1;\n      var code0=uintToString(code0int);\n      var code1=uintToString(code1int);\n      var code2=uintToString(code2int);\n      codes[0] = code0int;\n      codes[1] = code1int;\n      codes[2] = code2int;\n      openNumberList[queryId] = codes;\n      openNumberStr[queryId] = strConcat(code0,\",\",code1,\",\",code2);\n\n      //结算，派奖\n      doCheckBounds(queryId);\n    }\n\n    function doCancel(bytes32 queryId) internal {\n      uint sta = lableStatus[queryId];\n      require(sta == 0);\n      uint[3] memory codes = openNumberList[queryId];\n      require(codes[0] == 0 || codes[1] == 0 ||codes[2] == 0);\n\n      uint totalBet = 0;\n      uint len = lableCount[queryId];\n\n      address to = lableUser[queryId];\n      for(uint aa = 0 ; aa<len; aa++){\n        //未结算\n        if(betList[queryId][aa][5] == 0){\n          totalBet+=betList[queryId][aa][3];\n        }\n      }\n\n      if(totalBet > 0){\n        to.transfer(totalBet);\n      }\n      contractBalance=this.balance;\n      maxProfit=(this.balance * maxmoneypercent)/100;\n      lableStatus[queryId] = 1;\n    }\n\n    function doSendBounds(bytes32 queryId) public payable {\n      uint sta = lableStatus[queryId];\n      require(sta == 2);\n\n      uint totalWin = 0;\n      uint len = lableCount[queryId];\n\n      address to = lableUser[queryId];\n      for(uint aa = 0 ; aa<len; aa++){\n        //中奖\n        if(betList[queryId][aa][5] == 2){\n          totalWin+=betList[queryId][aa][6];\n        }\n      }\n\n      if(totalWin > 0){\n          to.transfer(totalWin);//转账\n      }\n      lableStatus[queryId] = 3;\n      contractBalance=this.balance;\n      maxProfit=(this.balance * maxmoneypercent)/100;\n    }\n\n    //中奖判断\n    function checkWinMoney(uint[7] storage betinfo,uint[3] codes) internal {\n      uint rates;\n      if(betinfo[1] ==1){\n          //大小 豹子不中奖\n          if(codes[0] == codes[1] && codes[1] == codes[2]){\n            betinfo[5]=1;//未中奖\n          }else{\n            uint sum = codes[0]+codes[1]+codes[2];\n            if(sum >= 4 && sum < 11){\n              sum = 4;//小\n            }else if(sum >= 11 && sum < 18){\n              sum = 17;//大\n            }else{\n              sum = 0;\n            }\n            betinfo[5]=1;\n            if(sum >0 && betinfo[2] == sum){\n                betinfo[5]=2;\n                rates = getPlayRate(betinfo[1],0);\n                betinfo[6]=betinfo[3]*rates/10;\n            }\n\n          }\n      }else if(betinfo[1] == 2){\n          //单双 豹子不中奖\n          if(codes[0] == codes[1] && codes[1] == codes[2]){\n            betinfo[5]=1;//未中奖\n          }else{\n            uint sums = codes[0]+codes[1]+codes[2];\n            if(sums % 2 == 0){\n              sums = 2;//双\n            }else{\n              sums = 3;//单\n            }\n            betinfo[5]=1;\n            if(sums == betinfo[2]){\n              betinfo[5]=2;\n              rates = getPlayRate(betinfo[1],0);\n              betinfo[6]=betinfo[3]*rates/10;\n            }\n\n          }\n\n        }else if(betinfo[1] == 3){\n          //二同号复选\n          betinfo[5]=1;//不中奖\n          if(codes[0] == codes[1] || codes[1] == codes[2] ){\n            uint tmp = 0;\n            if(codes[0] == codes[1] ){\n              tmp = codes[0];\n            }else if(codes[1] == codes[2]){\n              tmp = codes[1];\n            }\n            if(tmp == betinfo[2]){\n              betinfo[5]=2;\n              rates = getPlayRate(betinfo[1],0);\n              betinfo[6]=betinfo[3]*rates;\n            }\n\n          }\n        }else if(betinfo[1] == 4){\n          //三同号单选\n          betinfo[5]=1;//不中奖\n          if(codes[0] == codes[1] && codes[1] == codes[2] ){\n            if(codes[0] == betinfo[2]){\n              betinfo[5]=2;\n              rates = getPlayRate(betinfo[1],0);\n              betinfo[6]=betinfo[3]*rates;\n            }\n          }\n        }else if(betinfo[1] == 5){\n          //三同号通选\n          betinfo[5]=1;//不中奖\n          if(codes[0] == codes[1] && codes[1] == codes[2] ){\n              betinfo[5]=2;\n              rates = getPlayRate(betinfo[1],0);\n              betinfo[6]=betinfo[3]*rates;\n          }\n        }else if(betinfo[1] == 6){\n          //和值 豹子不中奖\n          if(codes[0] == codes[1] && codes[1] == codes[2]){\n            betinfo[5]=1;//不中奖\n          }else{\n            betinfo[5]=1;//不中奖\n            uint sum6 = codes[0]+codes[1]+codes[2];\n            if(sum6 == betinfo[2]){\n              betinfo[5]=2;\n              rates = getPlayRate(betinfo[1],sum6);\n              betinfo[6]=betinfo[3]*rates;\n            }\n          }\n        }else if(betinfo[1] == 7){\n          //二不同号 豹子不中奖\n          if(codes[0] == codes[1] && codes[1] == codes[2]){\n            betinfo[5]=1;//不中奖\n          }else{\n            uint[2] memory haoma = getErbutongHao(betinfo[2]);\n            bool atmp=false;\n            bool btmp=false;\n            for(uint ai=0;ai<codes.length;ai++){\n              if(codes[ai] == haoma[0]){\n                atmp = true;\n                continue;\n              }\n              if(codes[ai] == haoma[1]){\n                btmp = true;\n                continue;\n              }\n            }\n            betinfo[5]=1;\n            if(atmp && btmp){\n              betinfo[5]=2;\n              rates = getPlayRate(betinfo[1],0);\n              betinfo[6]=betinfo[3]*rates;\n            }\n          }\n        }else if(betinfo[1] == 8){\n          //猜1个号，赔率放大了10倍\n          uint tmpp = 0;\n          betinfo[5]=1;//不中奖\n          if(codes[0] == betinfo[2]){\n            tmpp++;\n          }\n          if(codes[1] == betinfo[2]){\n            tmpp++;\n          }\n          if(codes[2] == betinfo[2]){\n            tmpp++;\n          }\n          if(tmpp > 0){\n            betinfo[5]=2;\n            rates = getPlayRate(betinfo[1],tmpp);\n            betinfo[6]=betinfo[3]*rates/10;\n          }\n        }\n\n    }\n\n    function getErbutongHao(uint sss) internal view returns(uint[2]){\n      uint[2] memory result ;\n      if(sss == 12){\n        result = [uint(1),2];\n      }else if(sss == 13){\n         result = [uint(1),3];\n      }else if(sss == 14){\n         result = [uint(1),4];\n      }else if(sss == 15){\n         result = [uint(1),5];\n      }else if(sss == 16){\n         result = [uint(1),6];\n      }else if(sss == 23){\n         result = [uint(2),3];\n      }else if(sss == 24){\n         result = [uint(2),4];\n      }else if(sss == 25){\n         result = [uint(2),5];\n      }else if(sss == 26){\n         result = [uint(2),6];\n      }else if(sss == 34){\n         result = [uint(3),4];\n      }else if(sss == 35){\n         result = [uint(3),5];\n      }else if(sss == 36){\n         result = [uint(3),6];\n      }else if(sss == 45){\n         result = [uint(4),5];\n      }else if(sss == 46){\n         result = [uint(4),6];\n      }else if(sss == 56){\n         result = [uint(5),6];\n      }\n      return (result);\n    }\n\n    function getLastBet() public view returns(string,uint[7][]){\n      uint len=playerLableList[msg.sender].length;\n      require(len>0);\n\n      uint i=len-1;\n      bytes32 lastLable = playerLableList[msg.sender][i];\n      uint max = lableCount[lastLable];\n      if(max > 50){\n          max = 50;\n      }\n      uint[7][] memory result = new uint[7][](max) ;\n      var opennum = \"\";\n      for(uint a=0;a<max;a++){\n         var ttmp =openNumberStr[lastLable];\n         if(a==0){\n           opennum =ttmp;\n         }else{\n           opennum = strConcat(opennum,\";\",ttmp);\n         }\n\n         result[a] = betList[lastLable][a];\n         if(lableStatus[lastLable] == 1){\n           result[a][5]=3;\n         }\n\n      }\n\n      return (opennum,result);\n    }\n\n    function getLableRecords(bytes32 lable) public view returns(string,uint[7][]){\n      uint max = lableCount[lable];\n      if(max > 50){\n          max = 50;\n      }\n      uint[7][] memory result = new uint[7][](max) ;\n      var opennum=\"\";\n\n      for(uint a=0;a<max;a++){\n         result[a] = betList[lable][a];\n         if(lableStatus[lable] == 1){\n           result[a][5]=3;\n         }\n         var ttmp =openNumberStr[lable];\n         if(a==0){\n           opennum =ttmp;\n         }else{\n           opennum = strConcat(opennum,\";\",ttmp);\n         }\n      }\n\n      return (opennum,result);\n    }\n\n    function getAllRecords() public view returns(string,uint[7][]){\n        uint len=playerLableList[msg.sender].length;\n        require(len>0);\n\n        uint max;\n        bytes32 lastLable ;\n        uint ss;\n\n        for(uint i1=0;i1<len;i1++){\n            ss = len-i1-1;\n            lastLable = playerLableList[msg.sender][ss];\n            max += lableCount[lastLable];\n            if(100 < max){\n              max = 100;\n              break;\n            }\n        }\n\n        uint[7][] memory result = new uint[7][](max) ;\n        bytes32[] memory resultlable = new bytes32[](max) ;\n        var opennum=\"\";\n\n        bool flag=false;\n        uint betnums;\n        uint j=0;\n\n        for(uint ii=0;ii<len;ii++){\n            ss = len-ii-1;\n            lastLable = playerLableList[msg.sender][ss];\n            betnums = lableCount[lastLable];\n            for(uint k= 0; k<betnums; k++){\n              if(j<max){\n                  resultlable[j] = lastLable;\n              \t var ttmp =openNumberStr[lastLable];\n                 if(j==0){\n                   opennum =ttmp;\n                 }else{\n                   opennum = strConcat(opennum,\";\",ttmp);\n                 }\n                  result[j] = betList[lastLable][k];\n                  if(lableStatus[lastLable] == 1){\n                    result[j][5]=3;\n                  }else if(lableStatus[lastLable] == 2){\n                    if(result[j][5]==2){\n                      result[j][5]=4;\n                    }\n                  }else if(lableStatus[lastLable] == 3){\n                    if(result[j][5]==2){\n                      result[j][5]=5;\n                    }\n                  }\n                  j++;\n              }else{\n                flag = true;\n                break;\n              }\n            }\n            if(flag){\n                break;\n            }\n        }\n        return (opennum,result);\n    }\n\n  function senttest() public payable onlyAdmin{\n      contractBalance=this.balance;\n      maxProfit=(this.balance*maxmoneypercent)/100;\n  }\n\n  function setRandomSeed(uint _randomSeed) public payable onlyAdmin{\n      randonce = _randomSeed;\n  }\n\n  function getRandomSeed() public view onlyAdmin returns(uint _randonce) {\n      _randonce = randonce;\n  }\n\n  function withdraw(uint _amount , address desaccount) public onlyAdmin{\n      desaccount.transfer(_amount);\n      contractBalance=this.balance;\n      maxProfit=(this.balance * maxmoneypercent)/100;\n  }\n\n  function getDatas() public view returns(\n    uint _maxProfit,\n    uint _minBet,\n    uint _contractbalance,\n    uint _onoff,\n    address _owner\n    //uint _oraclizeFee\n    ){\n        _maxProfit=maxProfit;\n        _minBet=minBet;\n        _contractbalance=contractBalance;\n        _onoff=onoff;\n        _owner=owner;\n    }\n\n    function getLableList() public view returns(string,bytes32[],uint[],uint[],uint){\n      uint len=playerLableList[msg.sender].length;\n      require(len>0);\n\n      uint max=50;\n      if(len < 50){\n          max = len;\n      }\n\n      bytes32[] memory lablelist = new bytes32[](max) ;\n      uint[] memory labletime = new uint[](max) ;\n      uint[] memory lablestatus = new uint[](max) ;\n      var opennum=\"\";\n\n      bytes32 lastLable ;\n      for(uint i=0;i<max;i++){\n          lastLable = playerLableList[msg.sender][max-i-1];\n          lablelist[i]=lastLable;\n          labletime[i]=lableTime[lastLable];\n          lablestatus[i]=lableStatus[lastLable];\n          var ttmp =openNumberStr[lastLable];\n         if(i==0){\n           opennum =ttmp;\n         }else{\n           opennum = strConcat(opennum,\";\",ttmp);\n         }\n      }\n\n      return (opennum,lablelist,labletime,lablestatus,now);\n    }\n\n    function doCheckBounds(bytes32 queryId) internal{\n        uint sta = lableStatus[queryId];\n        require(sta == 0 || sta == 2);\n        uint[3] memory codes = openNumberList[queryId];\n        require(codes[0] > 0);\n        //结算\n        uint len = lableCount[queryId];\n\n        uint totalWin;\n        address to = lableUser[queryId];\n        for(uint aa = 0 ; aa<len; aa++){\n          //未结算\n          if(sta == 0){\n           if(betList[queryId][aa][5] == 0){\n             checkWinMoney(betList[queryId][aa],codes);\n             totalWin+=betList[queryId][aa][6];\n           }\n          }else if(sta == 2){\n              totalWin+=betList[queryId][aa][6];\n          }\n        }\n\n        lableStatus[queryId] = 2;\n        //派奖\n        if(totalWin > 0){\n          if(totalWin < this.balance){\n            to.transfer(totalWin);//转账\n            lableStatus[queryId] = 3;\n          }else{\n              LogNewOraclizeQuery(\"sent bouns fail.\",queryId);\n          }\n        }else{\n          lableStatus[queryId] = 3;\n        }\n        contractBalance=this.balance;\n        maxProfit=(this.balance * maxmoneypercent)/100;\n    }\n\n    function getOpenNum(bytes32 queryId) public view returns(string){\n        return openNumberStr[queryId];\n    }\n\n    function doCheckSendBounds() public payable{\n        uint len=playerLableList[msg.sender].length;\n\n      uint max=50;\n      if(len < 50){\n          max = len;\n      }\n\n      uint sta;\n      bytes32 lastLable ;\n      for(uint i=0;i<max;i++){\n          lastLable = playerLableList[msg.sender][max-i-1];\n          sta = lableStatus[lastLable];\n          if(sta == 0 || sta==2){\n            doCheckBounds(lastLable);\n          }\n      }\n    }\n\n    function doCancelAll() public payable{\n        uint len=playerLableList[msg.sender].length;\n\n      uint max=50;\n      if(len < 50){\n          max = len;\n      }\n\n      uint sta;\n      uint bettime;\n      bytes32 lastLable ;\n      for(uint i=0;i<max;i++){\n          lastLable = playerLableList[msg.sender][max-i-1];\n          sta = lableStatus[lastLable];\n          bettime = lableTime[lastLable];\n          if(sta == 0 && (now - bettime)>600){\n            doCancel(lastLable);\n          }\n      }\n    }\n}",
  "bytecode": "608060405234801561001057600080fd5b50600a8054600160a060020a03191633600160a060020a03908116919091179091556000600b5560016009556605543df729c00060085560506006819055309091168031600755606491903102046005556000600c55613164806100756000396000f3006080604052600436106100fa5763ffffffff7c0100000000000000000000000000000000000000000000000000000000600035041662f714ce81146100ff578063039c9d841461012557806303dc0532146101b257806327dc297e146102a357806338bbfa50146103015780635b945c0e1461039d57806366fea1d4146104fc5780636c0a1117146105075780636d34a7751461050f578063749ca1f3146105585780638b7afe2e1461057057806393b3cc6b146105975780639536c05f146105ac578063a7f9fe72146105b4578063ae817dd11461068f578063bbce3fc21461069a578063fc22341014610775578063fca2d9f514610831575b600080fd5b34801561010b57600080fd5b50610123600435600160a060020a0360243516610839565b005b34801561013157600080fd5b5061013d6004356108aa565b6040805160208082528351818301528351919283929083019185019080838360005b8381101561017757818101518382015260200161015f565b50505050905090810190601f1680156101a45780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b3480156101be57600080fd5b506101ca60043561094b565b604051808060200180602001838103835285818151815260200191508051906020019080838360005b8381101561020b5781810151838201526020016101f3565b50505050905090810190601f1680156102385780820380516001836020036101000a031916815260200191505b5083810382528451815284516000918691906020015b818410156102905760208085028401015160e080838360005b8381101561027f578181015183820152602001610267565b50505050905001926001019261024e565b9250505094505050505060405180910390f35b3480156102af57600080fd5b5060408051602060046024803582810135601f8101859004850286018501909652858552610123958335953695604494919390910191908190840183828082843750949750610beb9650505050505050565b34801561030d57600080fd5b5060408051602060046024803582810135601f810185900485028601850190965285855261012395833595369560449491939091019190819084018382808284375050604080516020601f89358b018035918201839004830284018301909452808352979a999881019791965091820194509250829150840183828082843750949750610c0b9650505050505050565b3480156103a957600080fd5b506103b2610c10565b604051808060200180602001806020018060200186815260200185810385528a818151815260200191508051906020019080838360005b838110156104015781810151838201526020016103e9565b50505050905090810190601f16801561042e5780820380516001836020036101000a031916815260200191505b508581038452895181528951602091820191808c01910280838360005b8381101561046357818101518382015260200161044b565b50505050905001858103835288818151815260200191508051906020019060200280838360005b838110156104a257818101518382015260200161048a565b50505050905001858103825287818151815260200191508051906020019060200280838360005b838110156104e15781810151838201526020016104c9565b50505050905001995050505050505050505060405180910390f35b610123600435610f02565b610123610f22565b34801561051b57600080fd5b50610524610fde565b604080519586526020860194909452848401929092526060840152600160a060020a03166080830152519081900360a00190f35b34801561056457600080fd5b50610123600435611001565b34801561057c57600080fd5b50610585611021565b60408051918252519081900360200190f35b3480156105a357600080fd5b50610585611027565b61012361104c565b3480156105c057600080fd5b506105c96110f7565b604051808060200180602001838103835285818151815260200191508051906020019080838360005b8381101561060a5781810151838201526020016105f2565b50505050905090810190601f1680156106375780820380516001836020036101000a031916815260200191505b5083810382528451815284516000918691906020015b818410156102905760208085028401015160e080838360005b8381101561067e578181015183820152602001610666565b50505050905001926001019261064d565b61012360043561159b565b3480156106a657600080fd5b506106af6116b3565b604051808060200180602001838103835285818151815260200191508051906020019080838360005b838110156106f05781810151838201526020016106d8565b50505050905090810190601f16801561071d5780820380516001836020036101000a031916815260200191505b5083810382528451815284516000918691906020015b818410156102905760208085028401015160e080838360005b8381101561076457818101518382015260200161074c565b505050509050019260010192610733565b6040805160206004803580820135838102808601850190965280855261058595369593946024949385019291829185019084908082843750506040805187358901803560208181028481018201909552818452989b9a998901989297509082019550935083925085019084908082843750506040805187358901803560208181028481018201909552818452989b9a99890198929750908201955093508392508501908490808284375094975050933594506119839350505050565b610123611c33565b600a5433600160a060020a0390811691161461085457600080fd5b604051600160a060020a0382169083156108fc029084906000818181858888f1935050505015801561088a573d6000803e3d6000fd5b50600160a060020a03301680316007556006546064913102046005555050565b60008181526013602090815260409182902080548351601f600261010060018516150260001901909316929092049182018490048402810184019094528084526060939283018282801561093f5780601f106109145761010080835404028352916020019161093f565b820191906000526020600020905b81548152906001019060200180831161092257829003601f168201915b50505050509050919050565b6000818152600f60205260408120546060918291908290819080603285111561097357603294505b846040519080825280602002602001820160405280156109ad57816020015b61099a612fc8565b8152602001906001900390816109925790505b50935060206040519081016040528060008152509250600091505b84821015610bdd576000888152600e6020908152604080832085845290915290819020815160e08101928390529160079082845b8154815260200190600101908083116109fc5750505050508483815181101515610a2257fe5b602090810290910181019190915260008981526011909152604090205460011415610a675760038483815181101515610a5757fe5b602090810291909101015160a001525b506000878152601360205260409020811515610b0f578054604080516020601f60026000196101006001881615020190951694909404938401819004810282018101909252828152918391830182828015610b035780601f10610ad857610100808354040283529160200191610b03565b820191906000526020600020905b815481529060010190602001808311610ae657829003601f168201915b50505050509250610bd2565b610bcf8360408051908101604052806001815260200160f860020a603b02815250838054600181600116156101000203166002900480601f016020809104026020016040519081016040528092919081815260200182805460018160011615610100020316600290048015610bc55780601f10610b9a57610100808354040283529160200191610bc5565b820191906000526020600020905b815481529060010190602001808311610ba857829003601f168201915b5050505050611c6b565b92505b6001909101906109c8565b509096919550909350505050565b604080516000815260208101909152610c079083908390610c0b565b5050565b505050565b600160a060020a0333166000908152600d60205260408120546060918291829182918183808080848080808911610c4657600080fd5b603297506032891015610c57578897505b87604051908082528060200260200182016040528015610c81578160200160208202803883390190505b50965087604051908082528060200260200182016040528015610cae578160200160208202803883390190505b50955087604051908082528060200260200182016040528015610cdb578160200160208202803883390190505b50945060206040519081016040528060008152509350600091505b87821015610eea57600160a060020a0333166000908152600d602052604090208054600019848b0301908110610d2857fe5b90600052602060002001549250828783815181101515610d4457fe5b60209081029091018101919091526000848152601090915260409020548651879084908110610d6f57fe5b60209081029091018101919091526000848152601190915260409020548551869084908110610d9a57fe5b602090810290910181019190915260008481526013909152604090209050811515610e51578054604080516020601f60026000196101006001881615020190951694909404938401819004810282018101909252828152918391830182828015610e455780601f10610e1a57610100808354040283529160200191610e45565b820191906000526020600020905b815481529060010190602001808311610e2857829003601f168201915b50505050509350610edf565b610edc8460408051908101604052806001815260200160f860020a603b02815250838054600181600116156101000203166002900480601f016020809104026020016040519081016040528092919081815260200182805460018160011615610100020316600290048015610bc55780601f10610b9a57610100808354040283529160200191610bc5565b93505b600190910190610cf6565b50919c949b5092995090975042965091945050505050565b600a5433600160a060020a03908116911614610f1d57600080fd5b600c55565b600160a060020a0333166000908152600d60205260408120549060329080808084861015610f4e578594505b5060005b84811015610fd657600160a060020a0333166000908152600d60205260409020805460001983880301908110610f8457fe5b6000918252602080832090910154808352601182526040808420546010909352909220549095509350915083158015610fc05750610258834203115b15610fce57610fce82611ca2565b600101610f52565b505050505050565b600554600854600754600954600a549394929391929091600160a060020a031690565b600a5433600160a060020a0390811691161461101c57600080fd5b600955565b60075481565b600a5460009033600160a060020a0390811691161461104557600080fd5b50600c5490565b600160a060020a0333166000908152600d602052604081205490603290808083851015611077578493505b5060005b838110156110f057600160a060020a0333166000908152600d602052604090208054600019838703019081106110ad57fe5b60009182526020808320909101548083526011909152604090912054935091508215806110da5750826002145b156110e8576110e882611e34565b60010161107b565b5050505050565b600160a060020a0333166000908152600d6020526040812054606091829190808080858080838080808080808e1161112e57600080fd5b600099505b8d8a10156111b55760018a8f03039a50600d600033600160a060020a0316600160a060020a031681526020019081526020016000208b81548110151561117557fe5b6000918252602080832090910154808352600f9091526040909120549d909d019c9b5060648d11156111aa5760649c506111b5565b600190990198611133565b8c6040519080825280602002602001820160405280156111ef57816020015b6111dc612fc8565b8152602001906001900390816111d45790505b5098508c60405190808252806020026020018201604052801561121c578160200160208202803883390190505b509750602060405190810160405280600081525096506000955060009350600092505b8d831015611585576001838f03039a50600d600033600160a060020a0316600160a060020a031681526020019081526020016000208b81548110151561128157fe5b6000918252602080832090910154808352600f9091526040822054909d50955091505b8482101561156f578c84101561155b578b88858151811015156112c357fe5b602090810290910181019190915260008d8152601390915260409020905083151561137a578054604080516020601f6002600019610100600188161502019095169490940493840181900481028201810190925282815291839183018282801561136e5780601f106113435761010080835404028352916020019161136e565b820191906000526020600020905b81548152906001019060200180831161135157829003601f168201915b50505050509650611408565b6114058760408051908101604052806001815260200160f860020a603b02815250838054600181600116156101000203166002900480601f016020809104026020016040519081016040528092919081815260200182805460018160011615610100020316600290048015610bc55780601f10610b9a57610100808354040283529160200191610bc5565b96505b60008c8152600e6020908152604080832085845290915290819020815160e08101928390529160079082845b815481526020019060010190808311611434575050505050898581518110151561145a57fe5b602090810290910181019190915260008d815260119091526040902054600114156114a3576003898581518110151561148f57fe5b602090810291909101015160a00152611550565b60008c815260116020526040902054600214156114f45788848151811015156114c857fe5b602090810291909101015160a00151600214156114ef576004898581518110151561148f57fe5b611550565b60008c8152601160205260409020546003141561155057888481518110151561151957fe5b602090810291909101015160a0015160021415611550576005898581518110151561154057fe5b602090810291909101015160a001525b600190930192611564565b6001955061156f565b6001909101906112a4565b851561157a57611585565b60019092019161123f565b50949e969d50959b505050505050505050505050565b60008181526011602052604081205490808080600285146115bb57600080fd5b5050506000838152600f6020908152604080832054601490925282205491925090600160a060020a0316825b8281101561163e576000868152600e6020908152604080832084845290915290206005015460021415611636576000868152600e60209081526040808320848452909152902060060154840193505b6001016115e7565b600084111561167f57604051600160a060020a0383169085156108fc029086906000818181858888f1935050505015801561167d573d6000803e3d6000fd5b505b505050600092835250506011602052604090206003905530600160a060020a03168031600755600654606491310204600555565b600160a060020a0333166000908152600d60205260408120546060918291908080848082808088116116e457600080fd5b600160a060020a0333166000908152600d6020526040902080546000198a0198508890811061170f57fe5b6000918252602080832090910154808352600f9091526040909120549096509450603285111561173e57603294505b8460405190808252806020026020018201604052801561177857816020015b611765612fc8565b81526020019060019003908161175d5790505b50935060206040519081016040528060008152509250600091505b8482101561197357506000858152601360205260409020811515611843578054604080516020601f600260001961010060018816150201909516949094049384018190048102820181019092528281529183918301828280156118375780601f1061180c57610100808354040283529160200191611837565b820191906000526020600020905b81548152906001019060200180831161181a57829003601f168201915b505050505092506118d1565b6118ce8360408051908101604052806001815260200160f860020a603b02815250838054600181600116156101000203166002900480601f016020809104026020016040519081016040528092919081815260200182805460018160011615610100020316600290048015610bc55780601f10610b9a57610100808354040283529160200191610bc5565b92505b6000868152600e6020908152604080832085845290915290819020815160e08101928390529160079082845b8154815260200190600101908083116118fd575050505050848381518110151561192357fe5b602090810290910181019190915260008781526011909152604090205460011415611968576003848381518110151561195857fe5b602090810291909101015160a001525b600190910190611793565b5090989197509095505050505050565b6000806000806000611993612fe7565b6009546000906001146119a557600080fd5b8a516000106119b357600080fd5b600088116119c057600080fd5b6008543410156119cf57600080fd5b600c5460408051600019430140815242602082015280820192909252519081900360600190209550600093508392505b8a51831015611ad457600b80546001019081905585558a518b9084908110611a2357fe5b6020908102909101015185600101558851899084908110611a4057fe5b602090810290910101518560020155895188908b9085908110611a5f57fe5b60209081029091010151028560030155895188908b9085908110611a7f57fe5b6020908102909101015102939093019242856004015560008560050155600085600601556000868152600e602090815260408083208684529091529020611ac890866007613006565b506001909201916119ff565b34841115611ae157600080fd5b60008681526010602090815260408083204290558d51600f83528184205560148252808320805473ffffffffffffffffffffffffffffffffffffffff191633600160a060020a031617905580516060810182528381528083018490528082018490528984526012909252909120909250611b5d90836003613041565b50604080518082018252600581527f302c302c30000000000000000000000000000000000000000000000000000000602080830191825260008a81526013909152929092209051611bae929061306f565b506000868152601160209081526040808320839055600160a060020a0333168352600d9091529020805490611be690600183016130dc565b600160a060020a0333166000908152600d602052604090208054919250879183908110611c0f57fe5b600091825260209091200155611c24866120ba565b50939998505050505050505050565b600a5433600160a060020a03908116911614611c4e57600080fd5b600160a060020a0330168031600755600654606491310204600555565b6060611c9a84848460206040519081016040528060008152506020604051908101604052806000815250612476565b949350505050565b6000611cac612fe7565b60008381526011602052604081205492508080808515611ccb57600080fd5b60008781526012602052604090819020815160608101928390529160039082845b815481526020019060010190808311611cec575093985088935060009250611d12915050565b60200201511580611d2557506020850151155b80611d3257506040850151155b1515611d3d57600080fd5b5050506000848152600f6020908152604080832054601490925282205491925090600160a060020a0316825b82811015611dbe576000878152600e602090815260408083208484529091529020600501541515611db6576000878152600e60209081526040808320848452909152902060030154840193505b600101611d69565b6000841115611dff57604051600160a060020a0383169085156108fc029086906000818181858888f19350505050158015611dfd573d6000803e3d6000fd5b505b600160a060020a0330168031600755600654606491310204600555505050600093845250506011602052506040902060019055565b6000611e3e612fe7565b6000838152601160205260408120549250808080851580611e5f5750856002145b1515611e6a57600080fd5b60008781526012602052604090819020815160608101928390529160039082845b815481526020019060010190808311611e8b57505050505094506000856000600381101515611eb657fe5b602002015111611ec557600080fd5b50506000858152600f60209081526040808320546014909252822054909350600160a060020a0316905b83811015611f9e57851515611f6b576000878152600e602090815260408083208484529091529020600501541515611f66576000878152600e602090815260408083208484529091529020611f4490866126d7565b6000878152600e60209081526040808320848452909152902060060154830192505b611f96565b8560021415611f96576000878152600e60209081526040808320848452909152902060060154830192505b600101611eef565b6000878152601160205260408120600290558311156120835730600160a060020a03163183101561201757604051600160a060020a0383169084156108fc029085906000818181858888f19350505050158015611fff573d6000803e3d6000fd5b5060008781526011602052604090206003905561207e565b60408051602081018990528181526010818301527f73656e7420626f756e73206661696c2e00000000000000000000000000000000606082015290517fd236fd58fd44deb7eda9b265c67a35dbe57eb585b61cd9b657cda55ce2dd74849181900360800190a15b612096565b6000878152601160205260409020600390555b600160a060020a033016803160075560065460649131020460055550505050505050565b6120c2612fe7565b6000828152600f60205260408120548190819081908190819060609081908190600111156120ef57600080fd5b60408051606081810183526000808352602080840182905283850191909152600c5484516000194301408184015242818701526c01000000000000000000000000600160a060020a0333160293810193909352607480840191909152845180840390910181526094909201938490528151929d5090929182918401908083835b6020831061218e5780518252601f19909201916020918201910161216f565b5181516020939093036101000a600019018019909116921691909117905260405192018290039091209b50600a92508b91506121c79050565b600c805492909106909101908190556040805160001943014060208083019190915242828401526c01000000000000000000000000600160a060020a03331602606083015260748083019490945282518083039094018452609490910191829052825160068d066001019b5082918401908083835b6020831061225b5780518252601f19909201916020918201910161223c565b5181516020939093036101000a600019018019909116921691909117905260405192018290039091209950600a92508991506122949050565b600c805492909106909101908190556040805160001943014060208083019190915242828401526c01000000000000000000000000600160a060020a03331602606083015260748083019490945282518083039094018452609490910191829052825160068b06600101995082918401908083835b602083106123285780518252601f199092019160209182019101612309565b5181516020939093036101000a600019018019909116921691909117905260405192018290039091209750600a92508791506123619050565b600c805492909106909101905560068506600101935061238088612b37565b925061238b86612b37565b915061239684612b37565b888b526020808c018890526040808d0187905260008e8152601290925290209091506123c4908b6003613041565b5061243c836040805190810160405280600181526020017f2c00000000000000000000000000000000000000000000000000000000000000815250846040805190810160405280600181526020017f2c0000000000000000000000000000000000000000000000000000000000000081525085612476565b60008c8152601360209081526040909120825161245f939192919091019061306f565b506124698b611e34565b5050505050505050505050565b6060806060806060806060806000808e98508d97508c96508b95508a94508451865188518a518c51010101016040519080825280601f01601f1916602001820160405280156124cf578160200160208202803883390190505b50935083925060009150600090505b885181101561253c5788818151811015156124f557fe5b90602001015160f860020a900460f860020a02838380600101945081518110151561251c57fe5b906020010190600160f860020a031916908160001a9053506001016124de565b5060005b875181101561259e57878181518110151561255757fe5b90602001015160f860020a900460f860020a02838380600101945081518110151561257e57fe5b906020010190600160f860020a031916908160001a905350600101612540565b5060005b86518110156126005786818151811015156125b957fe5b90602001015160f860020a900460f860020a0283838060010194508151811015156125e057fe5b906020010190600160f860020a031916908160001a9053506001016125a2565b5060005b855181101561266257858181518110151561261b57fe5b90602001015160f860020a900460f860020a02838380600101945081518110151561264257fe5b906020010190600160f860020a031916908160001a905350600101612604565b5060005b84518110156126c457848181518110151561267d57fe5b90602001015160f860020a900460f860020a0283838060010194508151811015156126a457fe5b906020010190600160f860020a031916908160001a905350600101612666565b50909d9c50505050505050505050505050565b60008060008060006126e7613100565b60008080808b60010154600114156127ca5760208b01518b51148015612714575060408b015160208c0151145b156127265760018c60055b01556127c5565b60408b015160208c01518c5101019850600489108015906127475750600b89105b156127555760049850612779565b600b89101580156127665750601289105b156127745760119850612779565b600098505b60018c600501556000891180156127935750888c60020154145b156127c55760028c60055b01556127b08c60015b01546000612c2a565b60038d0154909a50600a908b02048c60065b01555b612b29565b8b60010154600214156128465760208b01518b511480156127f2575060408b015160208c0151145b156128015760018c600561271f565b60408b015160208c01518c51010197506001881615156128245760029750612829565b600397505b60018c600501558b600201548814156127c55760028c600561279e565b8b60010154600314156128db57600160058d015560208b01518b511480612874575060408b015160208c0151145b156127c55760208b01518b51600098501415612893578a5196506128ab565b60408b015160208c015114156128ab5760208b015196505b8b600201548714156127c55760028c60055b01556128ca8c60016127a7565b9950898c60030154028c60066127c2565b8b600101546004141561292d57600160058d015560208b01518b5114801561290a575060408b015160208c0151145b156127c5578b600201548b60005b602002015114156127c55760028c60056128bd565b8b600101546005141561296c57600160058d015560208b01518b5114801561295d575060408b01518b6001612918565b156127c55760028c60056128bd565b8b60010154600614156129de5760208b01518b51148015612994575060408b015160208c0151145b156129a35760018c600561271f565b600160058d015560408b015160208c01518c5160028f0154910190910196508614156127c55760028c600501556128ca8c6001015487612c2a565b8b6001015460071415612aa75760208b01518b51148015612a06575060408b015160208c0151145b15612a155760018c600561271f565b612a228c60020154612d9a565b94506000935060009250600091505b6003821015612a885784518b8360038110612a4857fe5b60200201511415612a5c5760019350612a7d565b60208501518b8360038110612a6d57fe5b60200201511415612a7d57600192505b600190910190612a31565b60018c6005015583801561295d575082156127c55760028c60056128bd565b8b6001015460081415612b295750600160058c015560028b01548a516000911415612ad0576001015b60028c015460208c01511415612ae4576001015b60028c015460408c01511415612af8576001015b6000811115612b295760028c60050155612b168c6001015482612c2a565b60038d0154600a9082020460068e015599505b505050505050505050505050565b60606000808281851515612b805760408051808201909152600181527f300000000000000000000000000000000000000000000000000000000000000060208201529450612c21565b8593505b8315612b9b57600190920191600a84049350612b84565b826040519080825280601f01601f191660200182016040528015612bc9578160200160208202803883390190505b5091505060001982015b8515612c1d57815160001982019160f860020a6030600a8a060102918491908110612bfa57fe5b906020010190600160f860020a031916908160001a905350600a86049550612bd3565b8194505b50505050919050565b6000806001841480612c3c5750836002145b15612c4957506013612d93565b8360031415612c5a5750600b612d93565b8360041415612c6b5750609c612d93565b8360051415612c7c5750601a612d93565b8360061415612d4a578260041480612c945750826011145b15612ca157506035612d45565b8260051480612cb05750826010145b15612cbd57506015612d45565b8260061480612ccc575082600f145b15612cd957506011612d45565b8260071480612ce8575082600e145b15612cf55750600d612d45565b8260081480612d04575082600d145b15612d1157506009612d45565b8260091480612d20575082600c145b15612d2d57506008612d45565b82600a1480612d3c575082600b145b15612d45575060075b612d93565b8360071415612d5b57506006612d93565b8360081415612d93578260011415612d7557506013612d93565b8260021415612d865750601c612d93565b8260031415612d93575060255b9392505050565b612da2613100565b612daa613100565b82600c1415612dce5750604080518082019091526001815260026020820152612fc2565b82600d1415612df25750604080518082019091526001815260036020820152612fc2565b82600e1415612e165750604080518082019091526001815260046020820152612fc2565b82600f1415612e3a5750604080518082019091526001815260056020820152612fc2565b8260101415612e5e5750604080518082019091526001815260066020820152612fc2565b8260171415612e825750604080518082019091526002815260036020820152612fc2565b8260181415612ea65750604080518082019091526002815260046020820152612fc2565b8260191415612eca5750604080518082019091526002815260056020820152612fc2565b82601a1415612eee5750604080518082019091526002815260066020820152612fc2565b8260221415612f125750604080518082019091526003815260046020820152612fc2565b8260231415612f365750604080518082019091526003815260056020820152612fc2565b8260241415612f5a5750604080518082019091526003815260066020820152612fc2565b82602d1415612f7e5750604080518082019091526004815260056020820152612fc2565b82602e1415612fa25750604080518082019091526004815260066020820152612fc2565b8260381415612fc257506040805180820190915260058152600660208201525b92915050565b60e0604051908101604052806007906020820280388339509192915050565b6060604051908101604052806003906020820280388339509192915050565b8260078101928215613031579182015b82811115613031578254825591600101919060010190613016565b5061303d92915061311b565b5090565b8260038101928215613031579160200282015b82811115613031578251825591602001919060010190613054565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f106130b057805160ff1916838001178555613031565b828001600101855582156130315791820182811115613031578251825591602001919060010190613054565b815481835581811115610c0b57600083815260209020610c0b91810190830161311b565b60408051808201825290600290829080388339509192915050565b61313591905b8082111561303d5760008155600101613121565b905600a165627a7a72305820aa14271f965593b58f59f582a2d3c4b1e7991e881778885d6693f435e10890f40029"
}