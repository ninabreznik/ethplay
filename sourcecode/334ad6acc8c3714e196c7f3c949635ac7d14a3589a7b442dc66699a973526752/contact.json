{
  "address": "0xcc862f25b2f725c0666d67774c47c63c9a3af150",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "CryptoSaga: Card Swap Ver2",
  "contractName": "CryptoSagaCardSwapVer2",
  "compilerVersion": "v0.4.18+commit.9cf6e910",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2018-08-04\n*/\n\npragma solidity ^0.4.18;\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  /**\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n\n/**\n * @title Claimable\n * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\n * This allows the new owner to accept the transfer.\n */\ncontract Claimable is Ownable {\n  address public pendingOwner;\n\n  /**\n   * @dev Modifier throws if called by any account other than the pendingOwner.\n   */\n  modifier onlyPendingOwner() {\n    require(msg.sender == pendingOwner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to set the pendingOwner address.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) onlyOwner public {\n    pendingOwner = newOwner;\n  }\n\n  /**\n   * @dev Allows the pendingOwner address to finalize the transfer.\n   */\n  function claimOwnership() onlyPendingOwner public {\n    OwnershipTransferred(owner, pendingOwner);\n    owner = pendingOwner;\n    pendingOwner = address(0);\n  }\n}\n\n\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    Unpause();\n  }\n}\n\n\n/**\n * @title ERC721 interface\n * @dev see https://github.com/ethereum/eips/issues/721\n */\ncontract ERC721 {\n  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n\n  function balanceOf(address _owner) public view returns (uint256 _balance);\n  function ownerOf(uint256 _tokenId) public view returns (address _owner);\n  function transfer(address _to, uint256 _tokenId) public;\n  function approve(address _to, uint256 _tokenId) public;\n  function takeOwnership(uint256 _tokenId) public;\n}\n\n\n/**\n * @title ERC721Token\n * Generic implementation for the required functionality of the ERC721 standard\n */\ncontract ERC721Token is ERC721 {\n  using SafeMath for uint256;\n\n  // Total amount of tokens\n  uint256 private totalTokens;\n\n  // Mapping from token ID to owner\n  mapping (uint256 => address) private tokenOwner;\n\n  // Mapping from token ID to approved address\n  mapping (uint256 => address) private tokenApprovals;\n\n  // Mapping from owner to list of owned token IDs\n  mapping (address => uint256[]) private ownedTokens;\n\n  // Mapping from token ID to index of the owner tokens list\n  mapping(uint256 => uint256) private ownedTokensIndex;\n\n  /**\n  * @dev Guarantees msg.sender is owner of the given token\n  * @param _tokenId uint256 ID of the token to validate its ownership belongs to msg.sender\n  */\n  modifier onlyOwnerOf(uint256 _tokenId) {\n    require(ownerOf(_tokenId) == msg.sender);\n    _;\n  }\n\n  /**\n  * @dev Gets the total amount of tokens stored by the contract\n  * @return uint256 representing the total amount of tokens\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalTokens;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address\n  * @param _owner address to query the balance of\n  * @return uint256 representing the amount owned by the passed address\n  */\n  function balanceOf(address _owner) public view returns (uint256) {\n    return ownedTokens[_owner].length;\n  }\n\n  /**\n  * @dev Gets the list of tokens owned by a given address\n  * @param _owner address to query the tokens of\n  * @return uint256[] representing the list of tokens owned by the passed address\n  */\n  function tokensOf(address _owner) public view returns (uint256[]) {\n    return ownedTokens[_owner];\n  }\n\n  /**\n  * @dev Gets the owner of the specified token ID\n  * @param _tokenId uint256 ID of the token to query the owner of\n  * @return owner address currently marked as the owner of the given token ID\n  */\n  function ownerOf(uint256 _tokenId) public view returns (address) {\n    address owner = tokenOwner[_tokenId];\n    require(owner != address(0));\n    return owner;\n  }\n\n  /**\n   * @dev Gets the approved address to take ownership of a given token ID\n   * @param _tokenId uint256 ID of the token to query the approval of\n   * @return address currently approved to take ownership of the given token ID\n   */\n  function approvedFor(uint256 _tokenId) public view returns (address) {\n    return tokenApprovals[_tokenId];\n  }\n\n  /**\n  * @dev Transfers the ownership of a given token ID to another address\n  * @param _to address to receive the ownership of the given token ID\n  * @param _tokenId uint256 ID of the token to be transferred\n  */\n  function transfer(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) {\n    clearApprovalAndTransfer(msg.sender, _to, _tokenId);\n  }\n\n  /**\n  * @dev Approves another address to claim for the ownership of the given token ID\n  * @param _to address to be approved for the given token ID\n  * @param _tokenId uint256 ID of the token to be approved\n  */\n  function approve(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) {\n    address owner = ownerOf(_tokenId);\n    require(_to != owner);\n    if (approvedFor(_tokenId) != 0 || _to != 0) {\n      tokenApprovals[_tokenId] = _to;\n      Approval(owner, _to, _tokenId);\n    }\n  }\n\n  /**\n  * @dev Claims the ownership of a given token ID\n  * @param _tokenId uint256 ID of the token being claimed by the msg.sender\n  */\n  function takeOwnership(uint256 _tokenId) public {\n    require(isApprovedFor(msg.sender, _tokenId));\n    clearApprovalAndTransfer(ownerOf(_tokenId), msg.sender, _tokenId);\n  }\n\n  /**\n  * @dev Mint token function\n  * @param _to The address that will own the minted token\n  * @param _tokenId uint256 ID of the token to be minted by the msg.sender\n  */\n  function _mint(address _to, uint256 _tokenId) internal {\n    require(_to != address(0));\n    addToken(_to, _tokenId);\n    Transfer(0x0, _to, _tokenId);\n  }\n\n  /**\n  * @dev Burns a specific token\n  * @param _tokenId uint256 ID of the token being burned by the msg.sender\n  */\n  function _burn(uint256 _tokenId) onlyOwnerOf(_tokenId) internal {\n    if (approvedFor(_tokenId) != 0) {\n      clearApproval(msg.sender, _tokenId);\n    }\n    removeToken(msg.sender, _tokenId);\n    Transfer(msg.sender, 0x0, _tokenId);\n  }\n\n  /**\n   * @dev Tells whether the msg.sender is approved for the given token ID or not\n   * This function is not private so it can be extended in further implementations like the operatable ERC721\n   * @param _owner address of the owner to query the approval of\n   * @param _tokenId uint256 ID of the token to query the approval of\n   * @return bool whether the msg.sender is approved for the given token ID or not\n   */\n  function isApprovedFor(address _owner, uint256 _tokenId) internal view returns (bool) {\n    return approvedFor(_tokenId) == _owner;\n  }\n\n  /**\n  * @dev Internal function to clear current approval and transfer the ownership of a given token ID\n  * @param _from address which you want to send tokens from\n  * @param _to address which you want to transfer the token to\n  * @param _tokenId uint256 ID of the token to be transferred\n  */\n  function clearApprovalAndTransfer(address _from, address _to, uint256 _tokenId) internal {\n    require(_to != address(0));\n    require(_to != ownerOf(_tokenId));\n    require(ownerOf(_tokenId) == _from);\n\n    clearApproval(_from, _tokenId);\n    removeToken(_from, _tokenId);\n    addToken(_to, _tokenId);\n    Transfer(_from, _to, _tokenId);\n  }\n\n  /**\n  * @dev Internal function to clear current approval of a given token ID\n  * @param _tokenId uint256 ID of the token to be transferred\n  */\n  function clearApproval(address _owner, uint256 _tokenId) private {\n    require(ownerOf(_tokenId) == _owner);\n    tokenApprovals[_tokenId] = 0;\n    Approval(_owner, 0, _tokenId);\n  }\n\n  /**\n  * @dev Internal function to add a token ID to the list of a given address\n  * @param _to address representing the new owner of the given token ID\n  * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\n  */\n  function addToken(address _to, uint256 _tokenId) private {\n    require(tokenOwner[_tokenId] == address(0));\n    tokenOwner[_tokenId] = _to;\n    uint256 length = balanceOf(_to);\n    ownedTokens[_to].push(_tokenId);\n    ownedTokensIndex[_tokenId] = length;\n    totalTokens = totalTokens.add(1);\n  }\n\n  /**\n  * @dev Internal function to remove a token ID from the list of a given address\n  * @param _from address representing the previous owner of the given token ID\n  * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\n  */\n  function removeToken(address _from, uint256 _tokenId) private {\n    require(ownerOf(_tokenId) == _from);\n\n    uint256 tokenIndex = ownedTokensIndex[_tokenId];\n    uint256 lastTokenIndex = balanceOf(_from).sub(1);\n    uint256 lastToken = ownedTokens[_from][lastTokenIndex];\n\n    tokenOwner[_tokenId] = 0;\n    ownedTokens[_from][tokenIndex] = lastToken;\n    ownedTokens[_from][lastTokenIndex] = 0;\n    // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to\n    // be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping\n    // the lastToken to the first position, and then dropping the element placed in the last position of the list\n\n    ownedTokens[_from].length--;\n    ownedTokensIndex[_tokenId] = 0;\n    ownedTokensIndex[lastToken] = tokenIndex;\n    totalTokens = totalTokens.sub(1);\n  }\n}\n\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}\n\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n\n/**\n * @title AccessDeposit\n * @dev Adds grant/revoke functions to the contract.\n */\ncontract AccessDeposit is Claimable {\n\n  // Access for adding deposit.\n  mapping(address => bool) private depositAccess;\n\n  // Modifier for accessibility to add deposit.\n  modifier onlyAccessDeposit {\n    require(msg.sender == owner || depositAccess[msg.sender] == true);\n    _;\n  }\n\n  // @dev Grant acess to deposit heroes.\n  function grantAccessDeposit(address _address)\n    onlyOwner\n    public\n  {\n    depositAccess[_address] = true;\n  }\n\n  // @dev Revoke acess to deposit heroes.\n  function revokeAccessDeposit(address _address)\n    onlyOwner\n    public\n  {\n    depositAccess[_address] = false;\n  }\n\n}\n\n\n/**\n * @title AccessDeploy\n * @dev Adds grant/revoke functions to the contract.\n */\ncontract AccessDeploy is Claimable {\n\n  // Access for deploying heroes.\n  mapping(address => bool) private deployAccess;\n\n  // Modifier for accessibility to deploy a hero on a location.\n  modifier onlyAccessDeploy {\n    require(msg.sender == owner || deployAccess[msg.sender] == true);\n    _;\n  }\n\n  // @dev Grant acess to deploy heroes.\n  function grantAccessDeploy(address _address)\n    onlyOwner\n    public\n  {\n    deployAccess[_address] = true;\n  }\n\n  // @dev Revoke acess to deploy heroes.\n  function revokeAccessDeploy(address _address)\n    onlyOwner\n    public\n  {\n    deployAccess[_address] = false;\n  }\n\n}\n\n/**\n * @title AccessMint\n * @dev Adds grant/revoke functions to the contract.\n */\ncontract AccessMint is Claimable {\n\n  // Access for minting new tokens.\n  mapping(address => bool) private mintAccess;\n\n  // Modifier for accessibility to define new hero types.\n  modifier onlyAccessMint {\n    require(msg.sender == owner || mintAccess[msg.sender] == true);\n    _;\n  }\n\n  // @dev Grant acess to mint heroes.\n  function grantAccessMint(address _address)\n    onlyOwner\n    public\n  {\n    mintAccess[_address] = true;\n  }\n\n  // @dev Revoke acess to mint heroes.\n  function revokeAccessMint(address _address)\n    onlyOwner\n    public\n  {\n    mintAccess[_address] = false;\n  }\n\n}\n\n\n/**\n * @title Gold\n * @dev ERC20 Token that can be minted.\n */\ncontract Gold is StandardToken, Claimable, AccessMint {\n\n  string public constant name = \"Gold\";\n  string public constant symbol = \"G\";\n  uint8 public constant decimals = 18;\n\n  // Event that is fired when minted.\n  event Mint(\n    address indexed _to,\n    uint256 indexed _tokenId\n  );\n\n  // @dev Mint tokens with _amount to the address.\n  function mint(address _to, uint256 _amount) \n    onlyAccessMint\n    public \n    returns (bool) \n  {\n    totalSupply_ = totalSupply_.add(_amount);\n    balances[_to] = balances[_to].add(_amount);\n    Mint(_to, _amount);\n    Transfer(address(0), _to, _amount);\n    return true;\n  }\n\n}\n\n\n/**\n * @title CryptoSaga Card\n * @dev ERC721 Token that repesents CryptoSaga's cards.\n *  Buy consuming a card, players of CryptoSaga can get a heroe.\n */\ncontract CryptoSagaCard is ERC721Token, Claimable, AccessMint {\n\n  string public constant name = \"CryptoSaga Card\";\n  string public constant symbol = \"CARD\";\n\n  // Rank of the token.\n  mapping(uint256 => uint8) public tokenIdToRank;\n\n  // The number of tokens ever minted.\n  uint256 public numberOfTokenId;\n\n  // The converter contract.\n  CryptoSagaCardSwap private swapContract;\n\n  // Event that should be fired when card is converted.\n  event CardSwap(address indexed _by, uint256 _tokenId, uint256 _rewardId);\n\n  // @dev Set the address of the contract that represents CryptoSaga Cards.\n  function setCryptoSagaCardSwapContract(address _contractAddress)\n    public\n    onlyOwner\n  {\n    swapContract = CryptoSagaCardSwap(_contractAddress);\n  }\n\n  function rankOf(uint256 _tokenId) \n    public view\n    returns (uint8)\n  {\n    return tokenIdToRank[_tokenId];\n  }\n\n  // @dev Mint a new card.\n  function mint(address _beneficiary, uint256 _amount, uint8 _rank)\n    onlyAccessMint\n    public\n  {\n    for (uint256 i = 0; i < _amount; i++) {\n      _mint(_beneficiary, numberOfTokenId);\n      tokenIdToRank[numberOfTokenId] = _rank;\n      numberOfTokenId ++;\n    }\n  }\n\n  // @dev Swap this card for reward.\n  //  The card will be burnt.\n  function swap(uint256 _tokenId)\n    onlyOwnerOf(_tokenId)\n    public\n    returns (uint256)\n  {\n    require(address(swapContract) != address(0));\n\n    var _rank = tokenIdToRank[_tokenId];\n    var _rewardId = swapContract.swapCardForReward(this, _rank);\n    CardSwap(ownerOf(_tokenId), _tokenId, _rewardId);\n    _burn(_tokenId);\n    return _rewardId;\n  }\n\n}\n\n\n/**\n * @title The interface contract for Card-For-Hero swap functionality.\n * @dev With this contract, a card holder can swap his/her CryptoSagaCard for reward.\n *  This contract is intended to be inherited by CryptoSagaCardSwap implementation contracts.\n */\ncontract CryptoSagaCardSwap is Ownable {\n\n  // Card contract.\n  address internal cardAddess;\n\n  // Modifier for accessibility to define new hero types.\n  modifier onlyCard {\n    require(msg.sender == cardAddess);\n    _;\n  }\n  \n  // @dev Set the address of the contract that represents ERC721 Card.\n  function setCardContract(address _contractAddress)\n    public\n    onlyOwner\n  {\n    cardAddess = _contractAddress;\n  }\n\n  // @dev Convert card into reward.\n  //  This should be implemented by CryptoSagaCore later.\n  function swapCardForReward(address _by, uint8 _rank)\n    onlyCard\n    public \n    returns (uint256);\n\n}\n\n\n/**\n * @title CryptoSagaHero\n * @dev The token contract for the hero.\n *  Also a superset of the ERC721 standard that allows for the minting\n *  of the non-fungible tokens.\n */\ncontract CryptoSagaHero is ERC721Token, Claimable, Pausable, AccessMint, AccessDeploy, AccessDeposit {\n\n  string public constant name = \"CryptoSaga Hero\";\n  string public constant symbol = \"HERO\";\n  \n  struct HeroClass {\n    // ex) Soldier, Knight, Fighter...\n    string className;\n    // 0: Common, 1: Uncommon, 2: Rare, 3: Heroic, 4: Legendary.\n    uint8 classRank;\n    // 0: Human, 1: Celestial, 2: Demon, 3: Elf, 4: Dark Elf, 5: Yogoe, 6: Furry, 7: Dragonborn, 8: Undead, 9: Goblin, 10: Troll, 11: Slime, and more to come.\n    uint8 classRace;\n    // How old is this hero class? \n    uint32 classAge;\n    // 0: Fighter, 1: Rogue, 2: Mage.\n    uint8 classType;\n\n    // Possible max level of this class.\n    uint32 maxLevel; \n    // 0: Water, 1: Fire, 2: Nature, 3: Light, 4: Darkness.\n    uint8 aura; \n\n    // Base stats of this hero type. \n    // 0: ATK\t1: DEF 2: AGL\t3: LUK 4: HP.\n    uint32[5] baseStats;\n    // Minimum IVs for stats. \n    // 0: ATK\t1: DEF 2: AGL\t3: LUK 4: HP.\n    uint32[5] minIVForStats;\n    // Maximum IVs for stats.\n    // 0: ATK\t1: DEF 2: AGL\t3: LUK 4: HP.\n    uint32[5] maxIVForStats;\n    \n    // Number of currently instanced heroes.\n    uint32 currentNumberOfInstancedHeroes;\n  }\n    \n  struct HeroInstance {\n    // What is this hero's type? ex) John, Sally, Mark...\n    uint32 heroClassId;\n    \n    // Individual hero's name.\n    string heroName;\n    \n    // Current level of this hero.\n    uint32 currentLevel;\n    // Current exp of this hero.\n    uint32 currentExp;\n\n    // Where has this hero been deployed? (0: Never depolyed ever.) ex) Dungeon Floor #1, Arena #5...\n    uint32 lastLocationId;\n    // When a hero is deployed, it takes time for the hero to return to the base. This is in Unix epoch.\n    uint256 availableAt;\n\n    // Current stats of this hero. \n    // 0: ATK\t1: DEF 2: AGL\t3: LUK 4: HP.\n    uint32[5] currentStats;\n    // The individual value for this hero's stats. \n    // This will affect the current stats of heroes.\n    // 0: ATK\t1: DEF 2: AGL\t3: LUK 4: HP.\n    uint32[5] ivForStats;\n  }\n\n  // Required exp for level up will increase when heroes level up.\n  // This defines how the value will increase.\n  uint32 public requiredExpIncreaseFactor = 100;\n\n  // Required Gold for level up will increase when heroes level up.\n  // This defines how the value will increase.\n  uint256 public requiredGoldIncreaseFactor = 1000000000000000000;\n\n  // Existing hero classes.\n  mapping(uint32 => HeroClass) public heroClasses;\n  // The number of hero classes ever defined.\n  uint32 public numberOfHeroClasses;\n\n  // Existing hero instances.\n  // The key is _tokenId.\n  mapping(uint256 => HeroInstance) public tokenIdToHeroInstance;\n  // The number of tokens ever minted. This works as the serial number.\n  uint256 public numberOfTokenIds;\n\n  // Gold contract.\n  Gold public goldContract;\n\n  // Deposit of players (in Gold).\n  mapping(address => uint256) public addressToGoldDeposit;\n\n  // Random seed.\n  uint32 private seed = 0;\n\n  // Event that is fired when a hero type defined.\n  event DefineType(\n    address indexed _by,\n    uint32 indexed _typeId,\n    string _className\n  );\n\n  // Event that is fired when a hero is upgraded.\n  event LevelUp(\n    address indexed _by,\n    uint256 indexed _tokenId,\n    uint32 _newLevel\n  );\n\n  // Event that is fired when a hero is deployed.\n  event Deploy(\n    address indexed _by,\n    uint256 indexed _tokenId,\n    uint32 _locationId,\n    uint256 _duration\n  );\n\n  // @dev Get the class's entire infomation.\n  function getClassInfo(uint32 _classId)\n    external view\n    returns (string className, uint8 classRank, uint8 classRace, uint32 classAge, uint8 classType, uint32 maxLevel, uint8 aura, uint32[5] baseStats, uint32[5] minIVs, uint32[5] maxIVs) \n  {\n    var _cl = heroClasses[_classId];\n    return (_cl.className, _cl.classRank, _cl.classRace, _cl.classAge, _cl.classType, _cl.maxLevel, _cl.aura, _cl.baseStats, _cl.minIVForStats, _cl.maxIVForStats);\n  }\n\n  // @dev Get the class's name.\n  function getClassName(uint32 _classId)\n    external view\n    returns (string)\n  {\n    return heroClasses[_classId].className;\n  }\n\n  // @dev Get the class's rank.\n  function getClassRank(uint32 _classId)\n    external view\n    returns (uint8)\n  {\n    return heroClasses[_classId].classRank;\n  }\n\n  // @dev Get the heroes ever minted for the class.\n  function getClassMintCount(uint32 _classId)\n    external view\n    returns (uint32)\n  {\n    return heroClasses[_classId].currentNumberOfInstancedHeroes;\n  }\n\n  // @dev Get the hero's entire infomation.\n  function getHeroInfo(uint256 _tokenId)\n    external view\n    returns (uint32 classId, string heroName, uint32 currentLevel, uint32 currentExp, uint32 lastLocationId, uint256 availableAt, uint32[5] currentStats, uint32[5] ivs, uint32 bp)\n  {\n    HeroInstance memory _h = tokenIdToHeroInstance[_tokenId];\n    var _bp = _h.currentStats[0] + _h.currentStats[1] + _h.currentStats[2] + _h.currentStats[3] + _h.currentStats[4];\n    return (_h.heroClassId, _h.heroName, _h.currentLevel, _h.currentExp, _h.lastLocationId, _h.availableAt, _h.currentStats, _h.ivForStats, _bp);\n  }\n\n  // @dev Get the hero's class id.\n  function getHeroClassId(uint256 _tokenId)\n    external view\n    returns (uint32)\n  {\n    return tokenIdToHeroInstance[_tokenId].heroClassId;\n  }\n\n  // @dev Get the hero's name.\n  function getHeroName(uint256 _tokenId)\n    external view\n    returns (string)\n  {\n    return tokenIdToHeroInstance[_tokenId].heroName;\n  }\n\n  // @dev Get the hero's level.\n  function getHeroLevel(uint256 _tokenId)\n    external view\n    returns (uint32)\n  {\n    return tokenIdToHeroInstance[_tokenId].currentLevel;\n  }\n  \n  // @dev Get the hero's location.\n  function getHeroLocation(uint256 _tokenId)\n    external view\n    returns (uint32)\n  {\n    return tokenIdToHeroInstance[_tokenId].lastLocationId;\n  }\n\n  // @dev Get the time when the hero become available.\n  function getHeroAvailableAt(uint256 _tokenId)\n    external view\n    returns (uint256)\n  {\n    return tokenIdToHeroInstance[_tokenId].availableAt;\n  }\n\n  // @dev Get the hero's BP.\n  function getHeroBP(uint256 _tokenId)\n    public view\n    returns (uint32)\n  {\n    var _tmp = tokenIdToHeroInstance[_tokenId].currentStats;\n    return (_tmp[0] + _tmp[1] + _tmp[2] + _tmp[3] + _tmp[4]);\n  }\n\n  // @dev Get the hero's required gold for level up.\n  function getHeroRequiredGoldForLevelUp(uint256 _tokenId)\n    public view\n    returns (uint256)\n  {\n    return (uint256(2) ** (tokenIdToHeroInstance[_tokenId].currentLevel / 10)) * requiredGoldIncreaseFactor;\n  }\n\n  // @dev Get the hero's required exp for level up.\n  function getHeroRequiredExpForLevelUp(uint256 _tokenId)\n    public view\n    returns (uint32)\n  {\n    return ((tokenIdToHeroInstance[_tokenId].currentLevel + 2) * requiredExpIncreaseFactor);\n  }\n\n  // @dev Get the deposit of gold of the player.\n  function getGoldDepositOfAddress(address _address)\n    external view\n    returns (uint256)\n  {\n    return addressToGoldDeposit[_address];\n  }\n\n  // @dev Get the token id of the player's #th token.\n  function getTokenIdOfAddressAndIndex(address _address, uint256 _index)\n    external view\n    returns (uint256)\n  {\n    return tokensOf(_address)[_index];\n  }\n\n  // @dev Get the total BP of the player.\n  function getTotalBPOfAddress(address _address)\n    external view\n    returns (uint32)\n  {\n    var _tokens = tokensOf(_address);\n    uint32 _totalBP = 0;\n    for (uint256 i = 0; i < _tokens.length; i ++) {\n      _totalBP += getHeroBP(_tokens[i]);\n    }\n    return _totalBP;\n  }\n\n  // @dev Set the hero's name.\n  function setHeroName(uint256 _tokenId, string _name)\n    onlyOwnerOf(_tokenId)\n    public\n  {\n    tokenIdToHeroInstance[_tokenId].heroName = _name;\n  }\n\n  // @dev Set the address of the contract that represents ERC20 Gold.\n  function setGoldContract(address _contractAddress)\n    onlyOwner\n    public\n  {\n    goldContract = Gold(_contractAddress);\n  }\n\n  // @dev Set the required golds to level up a hero.\n  function setRequiredExpIncreaseFactor(uint32 _value)\n    onlyOwner\n    public\n  {\n    requiredExpIncreaseFactor = _value;\n  }\n\n  // @dev Set the required golds to level up a hero.\n  function setRequiredGoldIncreaseFactor(uint256 _value)\n    onlyOwner\n    public\n  {\n    requiredGoldIncreaseFactor = _value;\n  }\n\n  // @dev Contructor.\n  function CryptoSagaHero(address _goldAddress)\n    public\n  {\n    require(_goldAddress != address(0));\n\n    // Assign Gold contract.\n    setGoldContract(_goldAddress);\n\n    // Initial heroes.\n    // Name, Rank, Race, Age, Type, Max Level, Aura, Stats.\n    defineType(\"Archangel\", 4, 1, 13540, 0, 99, 3, [uint32(74), 75, 57, 99, 95], [uint32(8), 6, 8, 5, 5], [uint32(8), 10, 10, 6, 6]);\n    defineType(\"Shadowalker\", 3, 4, 134, 1, 75, 4, [uint32(45), 35, 60, 80, 40], [uint32(3), 2, 10, 4, 5], [uint32(5), 5, 10, 7, 5]);\n    defineType(\"Pyromancer\", 2, 0, 14, 2, 50, 1, [uint32(50), 28, 17, 40, 35], [uint32(5), 3, 2, 3, 3], [uint32(8), 4, 3, 4, 5]);\n    defineType(\"Magician\", 1, 3, 224, 2, 30, 0, [uint32(35), 15, 25, 25, 30], [uint32(3), 1, 2, 2, 2], [uint32(5), 2, 3, 3, 3]);\n    defineType(\"Farmer\", 0, 0, 59, 0, 15, 2, [uint32(10), 22, 8, 15, 25], [uint32(1), 2, 1, 1, 2], [uint32(1), 3, 1, 2, 3]);\n  }\n\n  // @dev Define a new hero type (class).\n  function defineType(string _className, uint8 _classRank, uint8 _classRace, uint32 _classAge, uint8 _classType, uint32 _maxLevel, uint8 _aura, uint32[5] _baseStats, uint32[5] _minIVForStats, uint32[5] _maxIVForStats)\n    onlyOwner\n    public\n  {\n    require(_classRank < 5);\n    require(_classType < 3);\n    require(_aura < 5);\n    require(_minIVForStats[0] <= _maxIVForStats[0] && _minIVForStats[1] <= _maxIVForStats[1] && _minIVForStats[2] <= _maxIVForStats[2] && _minIVForStats[3] <= _maxIVForStats[3] && _minIVForStats[4] <= _maxIVForStats[4]);\n\n    HeroClass memory _heroType = HeroClass({\n      className: _className,\n      classRank: _classRank,\n      classRace: _classRace,\n      classAge: _classAge,\n      classType: _classType,\n      maxLevel: _maxLevel,\n      aura: _aura,\n      baseStats: _baseStats,\n      minIVForStats: _minIVForStats,\n      maxIVForStats: _maxIVForStats,\n      currentNumberOfInstancedHeroes: 0\n    });\n\n    // Save the hero class.\n    heroClasses[numberOfHeroClasses] = _heroType;\n\n    // Fire event.\n    DefineType(msg.sender, numberOfHeroClasses, _heroType.className);\n\n    // Increment number of hero classes.\n    numberOfHeroClasses ++;\n\n  }\n\n  // @dev Mint a new hero, with _heroClassId.\n  function mint(address _owner, uint32 _heroClassId)\n    onlyAccessMint\n    public\n    returns (uint256)\n  {\n    require(_owner != address(0));\n    require(_heroClassId < numberOfHeroClasses);\n\n    // The information of the hero's class.\n    var _heroClassInfo = heroClasses[_heroClassId];\n\n    // Mint ERC721 token.\n    _mint(_owner, numberOfTokenIds);\n\n    // Build random IVs for this hero instance.\n    uint32[5] memory _ivForStats;\n    uint32[5] memory _initialStats;\n    for (uint8 i = 0; i < 5; i++) {\n      _ivForStats[i] = (random(_heroClassInfo.maxIVForStats[i] + 1, _heroClassInfo.minIVForStats[i]));\n      _initialStats[i] = _heroClassInfo.baseStats[i] + _ivForStats[i];\n    }\n\n    // Temporary hero instance.\n    HeroInstance memory _heroInstance = HeroInstance({\n      heroClassId: _heroClassId,\n      heroName: \"\",\n      currentLevel: 1,\n      currentExp: 0,\n      lastLocationId: 0,\n      availableAt: now,\n      currentStats: _initialStats,\n      ivForStats: _ivForStats\n    });\n\n    // Save the hero instance.\n    tokenIdToHeroInstance[numberOfTokenIds] = _heroInstance;\n\n    // Increment number of token ids.\n    // This will only increment when new token is minted, and will never be decemented when the token is burned.\n    numberOfTokenIds ++;\n\n     // Increment instanced number of heroes.\n    _heroClassInfo.currentNumberOfInstancedHeroes ++;\n\n    return numberOfTokenIds - 1;\n  }\n\n  // @dev Set where the heroes are deployed, and when they will return.\n  //  This is intended to be called by Dungeon, Arena, Guild contracts.\n  function deploy(uint256 _tokenId, uint32 _locationId, uint256 _duration)\n    onlyAccessDeploy\n    public\n    returns (bool)\n  {\n    // The hero should be possessed by anybody.\n    require(ownerOf(_tokenId) != address(0));\n\n    var _heroInstance = tokenIdToHeroInstance[_tokenId];\n\n    // The character should be avaiable. \n    require(_heroInstance.availableAt <= now);\n\n    _heroInstance.lastLocationId = _locationId;\n    _heroInstance.availableAt = now + _duration;\n\n    // As the hero has been deployed to another place, fire event.\n    Deploy(msg.sender, _tokenId, _locationId, _duration);\n  }\n\n  // @dev Add exp.\n  //  This is intended to be called by Dungeon, Arena, Guild contracts.\n  function addExp(uint256 _tokenId, uint32 _exp)\n    onlyAccessDeploy\n    public\n    returns (bool)\n  {\n    // The hero should be possessed by anybody.\n    require(ownerOf(_tokenId) != address(0));\n\n    var _heroInstance = tokenIdToHeroInstance[_tokenId];\n\n    var _newExp = _heroInstance.currentExp + _exp;\n\n    // Sanity check to ensure we don't overflow.\n    require(_newExp == uint256(uint128(_newExp)));\n\n    _heroInstance.currentExp += _newExp;\n\n  }\n\n  // @dev Add deposit.\n  //  This is intended to be called by Dungeon, Arena, Guild contracts.\n  function addDeposit(address _to, uint256 _amount)\n    onlyAccessDeposit\n    public\n  {\n    // Increment deposit.\n    addressToGoldDeposit[_to] += _amount;\n  }\n\n  // @dev Level up the hero with _tokenId.\n  //  This function is called by the owner of the hero.\n  function levelUp(uint256 _tokenId)\n    onlyOwnerOf(_tokenId) whenNotPaused\n    public\n  {\n\n    // Hero instance.\n    var _heroInstance = tokenIdToHeroInstance[_tokenId];\n\n    // The character should be avaiable. (Should have already returned from the dungeons, arenas, etc.)\n    require(_heroInstance.availableAt <= now);\n\n    // The information of the hero's class.\n    var _heroClassInfo = heroClasses[_heroInstance.heroClassId];\n\n    // Hero shouldn't level up exceed its max level.\n    require(_heroInstance.currentLevel < _heroClassInfo.maxLevel);\n\n    // Required Exp.\n    var requiredExp = getHeroRequiredExpForLevelUp(_tokenId);\n\n    // Need to have enough exp.\n    require(_heroInstance.currentExp >= requiredExp);\n\n    // Required Gold.\n    var requiredGold = getHeroRequiredGoldForLevelUp(_tokenId);\n\n    // Owner of token.\n    var _ownerOfToken = ownerOf(_tokenId);\n\n    // Need to have enough Gold balance.\n    require(addressToGoldDeposit[_ownerOfToken] >= requiredGold);\n\n    // Increase Level.\n    _heroInstance.currentLevel += 1;\n\n    // Increase Stats.\n    for (uint8 i = 0; i < 5; i++) {\n      _heroInstance.currentStats[i] = _heroClassInfo.baseStats[i] + (_heroInstance.currentLevel - 1) * _heroInstance.ivForStats[i];\n    }\n    \n    // Deduct exp.\n    _heroInstance.currentExp -= requiredExp;\n\n    // Deduct gold.\n    addressToGoldDeposit[_ownerOfToken] -= requiredGold;\n\n    // Fire event.\n    LevelUp(msg.sender, _tokenId, _heroInstance.currentLevel);\n  }\n\n  // @dev Transfer deposit (with the allowance pattern.)\n  function transferDeposit(uint256 _amount)\n    whenNotPaused\n    public\n  {\n    require(goldContract.allowance(msg.sender, this) >= _amount);\n\n    // Send msg.sender's Gold to this contract.\n    if (goldContract.transferFrom(msg.sender, this, _amount)) {\n       // Increment deposit.\n      addressToGoldDeposit[msg.sender] += _amount;\n    }\n  }\n\n  // @dev Withdraw deposit.\n  function withdrawDeposit(uint256 _amount)\n    public\n  {\n    require(addressToGoldDeposit[msg.sender] >= _amount);\n\n    // Send deposit of Golds to msg.sender. (Rather minting...)\n    if (goldContract.transfer(msg.sender, _amount)) {\n      // Decrement deposit.\n      addressToGoldDeposit[msg.sender] -= _amount;\n    }\n  }\n\n  // @dev return a pseudo random number between lower and upper bounds\n  function random(uint32 _upper, uint32 _lower)\n    private\n    returns (uint32)\n  {\n    require(_upper > _lower);\n\n    seed = uint32(keccak256(keccak256(block.blockhash(block.number), seed), now));\n    return seed % (_upper - _lower) + _lower;\n  }\n\n}\n\n\n\n/**\n * @title CryptoSagaCardSwapVer2\n * @dev This directly summons hero.\n */\ncontract CryptoSagaCardSwapVer2 is CryptoSagaCardSwap, Pausable{\n\n  // Eth will be sent to this wallet.\n  address public wallet;\n\n  // The hero contract.\n  CryptoSagaHero public heroContract;\n\n  // Gold contract.\n  Gold public goldContract;\n\n  // Eth-Summon price.\n  uint256 public ethPrice = 20000000000000000; // 0.02 eth.\n\n  // Gold-Summon price.\n  uint256 public goldPrice = 100000000000000000000; // 100 G. Should worth around 0.00004 eth at launch.\n\n  // Mileage Point Summon price.\n  uint256 public mileagePointPrice = 100;\n\n  // Blacklisted heroes.\n  // This is needed in order to protect players, in case there exists any hero with critical issues.\n  // We promise we will use this function carefully, and this won't be used for balancing the OP heroes.\n  mapping(uint32 => bool) public blackList;\n\n  // Mileage points of each player.\n  mapping(address => uint256) public addressToMileagePoint;\n\n  // Last timestamp of summoning a free hero.\n  mapping(address => uint256) public addressToFreeSummonTimestamp;\n\n  // Random seed.\n  uint32 private seed = 0;\n\n  // @dev Get the mileage points of given address.\n  function getMileagePoint(address _address)\n    public view\n    returns (uint256)\n  {\n    return addressToMileagePoint[_address];\n  }\n\n  // @dev Get the summon timestamp of given address.\n  function getFreeSummonTimestamp(address _address)\n    public view\n    returns (uint256)\n  {\n    return addressToFreeSummonTimestamp[_address];\n  }\n\n  // @dev Set the price of summoning a hero with Eth.\n  function setEthPrice(uint256 _value)\n    onlyOwner\n    public\n  {\n    ethPrice = _value;\n  }\n\n  // @dev Set the price of summoning a hero with Gold.\n  function setGoldPrice(uint256 _value)\n    onlyOwner\n    public\n  {\n    goldPrice = _value;\n  }\n\n  // @dev Set the price of summong a hero with Mileage Points.\n  function setMileagePointPrice(uint256 _value)\n    onlyOwner\n    public\n  {\n    mileagePointPrice = _value;\n  }\n\n  // @dev Set blacklist.\n  function setBlacklist(uint32 _classId, bool _value)\n    onlyOwner\n    public\n  {\n    blackList[_classId] = _value;\n  }\n\n  // @dev Increment mileage points.\n  function addMileagePoint(address _beneficiary, uint256 _point)\n    onlyOwner\n    public\n  {\n    require(_beneficiary != address(0));\n\n    addressToMileagePoint[_beneficiary] += _point;\n  }\n\n  // @dev Contructor.\n  function CryptoSagaCardSwapVer2(address _heroAddress, address _goldAddress, address _cardAddress, address _walletAddress)\n    public\n  {\n    require(_heroAddress != address(0));\n    require(_goldAddress != address(0));\n    require(_cardAddress != address(0));\n    require(_walletAddress != address(0));\n    \n    wallet = _walletAddress;\n\n    heroContract = CryptoSagaHero(_heroAddress);\n    goldContract = Gold(_goldAddress);\n    setCardContract(_cardAddress);\n  }\n\n  // @dev Swap a card for a hero.\n  function swapCardForReward(address _by, uint8 _rank)\n    onlyCard\n    whenNotPaused\n    public\n    returns (uint256)\n  {\n    // This is becaue we need to use tx.origin here.\n    // _by should be the beneficiary, but due to the bug that is already exist with CryptoSagaCard.sol,\n    // tx.origin is used instead of _by.\n    require(tx.origin != _by && tx.origin != msg.sender);\n\n    // Get value 0 ~ 9999.\n    var _randomValue = random(10000, 0);\n\n    // We hard-code this in order to give credential to the players. \n    uint8 _heroRankToMint = 0; \n\n    if (_rank == 0) { // Origin Card. 85% Heroic, 15% Legendary.\n      if (_randomValue < 8500) {\n        _heroRankToMint = 3;\n      } else {\n        _heroRankToMint = 4;\n      }\n    } else if (_rank == 3) { // Dungeon Chest card.\n      if (_randomValue < 6500) {\n        _heroRankToMint = 1;\n      } else if (_randomValue < 9945) {\n        _heroRankToMint = 2;\n      }  else if (_randomValue < 9995) {\n        _heroRankToMint = 3;\n      } else {\n        _heroRankToMint = 4;\n      }\n    } else { // Do nothing here.\n      _heroRankToMint = 0;\n    }\n    \n    // Summon the hero.\n    return summonHero(tx.origin, _heroRankToMint);\n\n  }\n\n  // @dev Pay with Eth.\n  function payWithEth(uint256 _amount, address _referralAddress)\n    whenNotPaused\n    public\n    payable\n  {\n    require(msg.sender != address(0));\n    // Referral address shouldn't be the same address.\n    require(msg.sender != _referralAddress);\n    // Up to 5 purchases at once.\n    require(_amount >= 1 && _amount <= 5);\n\n    var _priceOfBundle = ethPrice * _amount;\n\n    require(msg.value >= _priceOfBundle);\n\n    // Send the raised eth to the wallet.\n    wallet.transfer(_priceOfBundle);\n\n    for (uint i = 0; i < _amount; i ++) {\n      // Get value 0 ~ 9999.\n      var _randomValue = random(10000, 0);\n      \n      // We hard-code this in order to give credential to the players. \n      uint8 _heroRankToMint = 0; \n\n      if (_randomValue < 5000) {\n        _heroRankToMint = 1;\n      } else if (_randomValue < 9550) {\n        _heroRankToMint = 2;\n      }  else if (_randomValue < 9950) {\n        _heroRankToMint = 3;\n      } else {\n        _heroRankToMint = 4;\n      }\n\n      // Summon the hero.\n      summonHero(msg.sender, _heroRankToMint);\n\n      // In case there exists referral address...\n      if (_referralAddress != address(0)) {\n        // Add mileage to the referral address.\n        addressToMileagePoint[_referralAddress] += 5;\n        addressToMileagePoint[msg.sender] += 3;\n      }\n    }\n  }\n\n  // @dev Pay with Gold.\n  function payWithGold(uint256 _amount)\n    whenNotPaused\n    public\n  {\n    require(msg.sender != address(0));\n    // Up to 5 purchases at once.\n    require(_amount >= 1 && _amount <= 5);\n\n    var _priceOfBundle = goldPrice * _amount;\n\n    require(goldContract.allowance(msg.sender, this) >= _priceOfBundle);\n\n    if (goldContract.transferFrom(msg.sender, this, _priceOfBundle)) {\n      for (uint i = 0; i < _amount; i ++) {\n        // Get value 0 ~ 9999.\n        var _randomValue = random(10000, 0);\n        \n        // We hard-code this in order to give credential to the players. \n        uint8 _heroRankToMint = 0; \n\n        if (_randomValue < 3000) {\n          _heroRankToMint = 0;\n        } else if (_randomValue < 7500) {\n          _heroRankToMint = 1;\n        } else if (_randomValue < 9945) {\n          _heroRankToMint = 2;\n        } else if (_randomValue < 9995) {\n          _heroRankToMint = 3;\n        } else {\n          _heroRankToMint = 4;\n        }\n\n        // Summon the hero.\n        summonHero(msg.sender, _heroRankToMint);\n      }\n    }\n  }\n\n  // @dev Pay with Mileage.\n  function payWithMileagePoint(uint256 _amount)\n    whenNotPaused\n    public\n  {\n    require(msg.sender != address(0));\n    // Up to 5 purchases at once.\n    require(_amount >= 1 && _amount <= 5);\n\n    var _priceOfBundle = mileagePointPrice * _amount;\n\n    require(addressToMileagePoint[msg.sender] >= _priceOfBundle);\n\n    // Decrement mileage point.\n    addressToMileagePoint[msg.sender] -= _priceOfBundle;\n\n    for (uint i = 0; i < _amount; i ++) {\n      // Get value 0 ~ 9999.\n      var _randomValue = random(10000, 0);\n      \n      // We hard-code this in order to give credential to the players. \n      uint8 _heroRankToMint = 0; \n\n      if (_randomValue < 5000) {\n        _heroRankToMint = 1;\n      } else if (_randomValue < 9050) {\n        _heroRankToMint = 2;\n      }  else if (_randomValue < 9950) {\n        _heroRankToMint = 3;\n      } else {\n        _heroRankToMint = 4;\n      }\n\n      // Summon the hero.\n      summonHero(msg.sender, _heroRankToMint);\n    }\n  }\n\n  // @dev Free daily summon.\n  function payWithDailyFreePoint()\n    whenNotPaused\n    public\n  {\n    require(msg.sender != address(0));\n    // Only once a day.\n    require(now > addressToFreeSummonTimestamp[msg.sender] + 1 days);\n    addressToFreeSummonTimestamp[msg.sender] = now;\n\n    // Get value 0 ~ 9999.\n    var _randomValue = random(10000, 0);\n    \n    // We hard-code this in order to give credential to the players. \n    uint8 _heroRankToMint = 0; \n\n    if (_randomValue < 5500) {\n      _heroRankToMint = 0;\n    } else if (_randomValue < 9850) {\n      _heroRankToMint = 1;\n    } else {\n      _heroRankToMint = 2;\n    }\n\n    // Summon the hero.\n    summonHero(msg.sender, _heroRankToMint);\n\n  }\n\n  // @dev Summon a hero.\n  // 0: Common, 1: Uncommon, 2: Rare, 3: Heroic, 4: Legendary\n  function summonHero(address _to, uint8 _heroRankToMint)\n    private\n    returns (uint256)\n  {\n\n    // Get the list of hero classes.\n    uint32 _numberOfClasses = heroContract.numberOfHeroClasses();\n    uint32[] memory _candidates = new uint32[](_numberOfClasses);\n    uint32 _count = 0;\n    for (uint32 i = 0; i < _numberOfClasses; i ++) {\n      if (heroContract.getClassRank(i) == _heroRankToMint && blackList[i] != true) {\n        _candidates[_count] = i;\n        _count++;\n      }\n    }\n\n    require(_count != 0);\n    \n    return heroContract.mint(_to, _candidates[random(_count, 0)]);\n  }\n\n  // @dev return a pseudo random number between lower and upper bounds\n  function random(uint32 _upper, uint32 _lower)\n    private\n    returns (uint32)\n  {\n    require(_upper > _lower);\n\n    seed = uint32(keccak256(keccak256(block.blockhash(block.number - 1), seed), now));\n    return seed % (_upper - _lower) + _lower;\n  }\n\n}",
  "bytecode": "60606040526001805460a060020a60ff021916905566470de4df82000060055568056bc75e2d631000006006556064600755600b805463ffffffff19169055341561004957600080fd5b6040516080806113198339810160405280805191906020018051919060200180519190602001805160008054600160a060020a03191633600160a060020a03908116919091179091559092508516151590506100a457600080fd5b600160a060020a03831615156100b957600080fd5b600160a060020a03821615156100ce57600080fd5b600160a060020a03811615156100e357600080fd5b60028054600160a060020a03808416600160a060020a0319928316179092556003805487841690831617905560048054928616929091169190911790556101368264010000000061096b61013f82021704565b5050505061017c565b60005433600160a060020a0390811691161461015a57600080fd5b60018054600160a060020a031916600160a060020a0392909216919091179055565b61118e8061018b6000396000f3006060604052600436106101445763ffffffff60e060020a6000350416629f92628114610149578063015b08331461016157806303c4d93a1461019257806305ff711b146101a85780630daf999a146101d85780631e653f69146102075780632d02a5b2146102265780633292cd371461023c578063391a79ec1461024f5780633f4ba83a1461026e5780634450140414610281578063521eb273146102945780635c975abb146102a757806362d7a74d146102ba5780638456cb59146102dc5780638da5cb5b146102ef578063a72f514014610302578063a7c25c5a14610321578063ad317c2314610337578063c030d8b81461034a578063c69f448114610369578063d6f327cc1461038a578063e3f5009f146103af578063e8b49df2146103c5578063f2fde38b146103dc578063fc996557146103fb578063ff186b2e1461040e575b600080fd5b341561015457600080fd5b61015f600435610421565b005b341561016c57600080fd5b610180600160a060020a0360043516610441565b60405190815260200160405180910390f35b341561019d57600080fd5b61015f600435610453565b34156101b357600080fd5b6101c463ffffffff60043516610665565b604051901515815260200160405180910390f35b34156101e357600080fd5b6101eb61067a565b604051600160a060020a03909116815260200160405180910390f35b341561021257600080fd5b610180600160a060020a0360043516610689565b341561023157600080fd5b61015f6004356106a4565b341561024757600080fd5b61015f6106c4565b341561025a57600080fd5b610180600160a060020a036004351661078f565b341561027957600080fd5b61015f6107a1565b341561028c57600080fd5b610180610820565b341561029f57600080fd5b6101eb610826565b34156102b257600080fd5b6101c4610835565b34156102c557600080fd5b61015f600160a060020a0360043516602435610845565b34156102e757600080fd5b61015f610897565b34156102fa57600080fd5b6101eb61091b565b341561030d57600080fd5b610180600160a060020a036004351661092a565b341561032c57600080fd5b61015f600435610945565b341561034257600080fd5b610180610965565b341561035557600080fd5b61015f600160a060020a036004351661096b565b341561037457600080fd5b61015f63ffffffff6004351660243515156109b5565b341561039557600080fd5b610180600160a060020a036004351660ff602435166109f8565b34156103ba57600080fd5b61015f600435610b19565b61015f600435600160a060020a0360243516610c38565b34156103e757600080fd5b61015f600160a060020a0360043516610dbc565b341561040657600080fd5b6101eb610e57565b341561041957600080fd5b610180610e66565b60005433600160a060020a0390811691161461043c57600080fd5b600555565b600a6020526000908152604090205481565b60015460009081908190819060a060020a900460ff161561047357600080fd5b33600160a060020a0316151561048857600080fd5b6001851015801561049a575060058511155b15156104a557600080fd5b60065460045490860294508490600160a060020a031663dd62ed3e333060006040516020015260405160e060020a63ffffffff8516028152600160a060020a03928316600482015291166024820152604401602060405180830381600087803b151561051057600080fd5b6102c65a03f1151561052157600080fd5b505050604051805190501015151561053857600080fd5b600454600160a060020a03166323b872dd33308760006040516020015260405160e060020a63ffffffff8616028152600160a060020a0393841660048201529190921660248201526044810191909152606401602060405180830381600087803b15156105a457600080fd5b6102c65a03f115156105b557600080fd5b505050604051805190501561065e57600092505b8483101561065e576105de6127106000610e6c565b915060009050610bb88263ffffffff1610156105fc57506000610648565b611d4c8263ffffffff16101561061457506001610648565b6126d98263ffffffff16101561062c57506002610648565b61270b8263ffffffff16101561064457506003610648565b5060045b6106523382610f01565b506001909201916105c9565b5050505050565b60086020526000908152604090205460ff1681565b600354600160a060020a031681565b600160a060020a03166000908152600a602052604090205490565b60005433600160a060020a039081169116146106bf57600080fd5b600655565b600154600090819060a060020a900460ff16156106e057600080fd5b33600160a060020a031615156106f557600080fd5b600160a060020a0333166000908152600a60205260409020546201518001421161071e57600080fd5b600160a060020a0333166000908152600a602052604081204290556107469061271090610e6c565b91506000905061157c8263ffffffff16101561076457506000610780565b61267a8263ffffffff16101561077c57506001610780565b5060025b61078a3382610f01565b505050565b60096020526000908152604090205481565b60005433600160a060020a039081169116146107bc57600080fd5b60015460a060020a900460ff1615156107d457600080fd5b6001805474ff0000000000000000000000000000000000000000191690557f7805862f689e2f13df9f062ff482ad3ad112aca9e0847911ed832e158c525b3360405160405180910390a1565b60065481565b600254600160a060020a031681565b60015460a060020a900460ff1681565b60005433600160a060020a0390811691161461086057600080fd5b600160a060020a038216151561087557600080fd5b600160a060020a03909116600090815260096020526040902080549091019055565b60005433600160a060020a039081169116146108b257600080fd5b60015460a060020a900460ff16156108c957600080fd5b6001805474ff0000000000000000000000000000000000000000191660a060020a1790557f6985a02210a168e66602d3235cb6db0e70f92b3ba4d376a33c0f3d9434bff62560405160405180910390a1565b600054600160a060020a031681565b600160a060020a031660009081526009602052604090205490565b60005433600160a060020a0390811691161461096057600080fd5b600755565b60075481565b60005433600160a060020a0390811691161461098657600080fd5b6001805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b60005433600160a060020a039081169116146109d057600080fd5b63ffffffff919091166000908152600860205260409020805460ff1916911515919091179055565b6001546000908190819033600160a060020a03908116911614610a1a57600080fd5b60015460a060020a900460ff1615610a3157600080fd5b84600160a060020a031632600160a060020a031614158015610a65575033600160a060020a031632600160a060020a031614155b1515610a7057600080fd5b610a7d6127106000610e6c565b91506000905060ff84161515610aae576121348263ffffffff161015610aa557506003610aa9565b5060045b610b06565b8360ff1660031415610b02576119648263ffffffff161015610ad257506001610aa9565b6126d98263ffffffff161015610aea57506002610aa9565b61270b8263ffffffff161015610aa557506003610aa9565b5060005b610b103282610f01565b95945050505050565b60015460009081908190819060a060020a900460ff1615610b3957600080fd5b33600160a060020a03161515610b4e57600080fd5b60018510158015610b60575060058511155b1515610b6b57600080fd5b600754600160a060020a033316600090815260096020526040902054908602945084901015610b9957600080fd5b600160a060020a03331660009081526009602052604081208054869003905592505b8483101561065e57610bd06127106000610e6c565b9150600090506113888263ffffffff161015610bee57506001610c22565b61235a8263ffffffff161015610c0657506002610c22565b6126de8263ffffffff161015610c1e57506003610c22565b5060045b610c2c3382610f01565b50600190920191610bbb565b60015460009081908190819060a060020a900460ff1615610c5857600080fd5b33600160a060020a03161515610c6d57600080fd5b84600160a060020a031633600160a060020a031614151515610c8e57600080fd5b60018610158015610ca0575060058611155b1515610cab57600080fd5b600554860293503484901015610cc057600080fd5b600254600160a060020a031684156108fc0285604051600060405180830381858888f193505050501515610cf357600080fd5b600092505b85831015610db457610d0d6127106000610e6c565b9150600090506113888263ffffffff161015610d2b57506001610d5f565b61254e8263ffffffff161015610d4357506002610d5f565b6126de8263ffffffff161015610d5b57506003610d5f565b5060045b610d693382610f01565b50600160a060020a03851615610da957600160a060020a038086166000908152600960205260408082208054600501905533909216815220805460030190555b600190920191610cf8565b505050505050565b60005433600160a060020a03908116911614610dd757600080fd5b600160a060020a0381161515610dec57600080fd5b600054600160a060020a0380831691167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a36000805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b600454600160a060020a031681565b60055481565b600063ffffffff80831690841611610e8357600080fd5b600b546000194301409063ffffffff1660405191825263ffffffff1660e060020a026020820152602401604051809103902042604051918252602082015260409081019051908190039020600b805463ffffffff191663ffffffff9283161790819055839182860381169116811515610ef857fe5b06019392505050565b600080610f0c611150565b6003546000908190600160a060020a031663c3bf32e382604051602001526040518163ffffffff1660e060020a028152600401602060405180830381600087803b1515610f5857600080fd5b6102c65a03f11515610f6957600080fd5b505050604051805194505063ffffffff8416604051805910610f885750595b9080825280602002602001820160405250925060009150600090505b8363ffffffff168163ffffffff1610156110915760035460ff871690600160a060020a0316631749bdf18360006040516020015260405163ffffffff83811660e060020a028252919091166004820152602401602060405180830381600087803b151561101057600080fd5b6102c65a03f1151561102157600080fd5b5050506040518051905060ff16148015611056575063ffffffff811660009081526008602052604090205460ff161515600114155b156110895780838363ffffffff168151811061106e57fe5b63ffffffff9092166020928302909101909101526001909101905b600101610fa4565b63ffffffff821615156110a357600080fd5b600354600160a060020a031663d35e29d788856110c1866000610e6c565b63ffffffff16815181106110d157fe5b9060200190602002015160006040516020015260405163ffffffff84811660e060020a028252600160a060020a0393909316600482015291166024820152604401602060405180830381600087803b151561112b57600080fd5b6102c65a03f1151561113c57600080fd5b505050604051805198975050505050505050565b602060405190810160405260008152905600a165627a7a723058209446a30a4774bb65279220146eaad7b9624dd69cbbf9dae8cbf9c7916b7096160029000000000000000000000000abc7e6c01237e8eef355bba2bf925a730b714d5f00000000000000000000000059bcded9c87ce46ec97c13640bfc0390ceb00e990000000000000000000000001b5242794288b45831ce069c9934a29b89af01970000000000000000000000006ea5f3284ccb1a1878167c640a42b3c9b6e5930b",
  "constructorArguments": "000000000000000000000000abc7e6c01237e8eef355bba2bf925a730b714d5f00000000000000000000000059bcded9c87ce46ec97c13640bfc0390ceb00e990000000000000000000000001b5242794288b45831ce069c9934a29b89af01970000000000000000000000006ea5f3284ccb1a1878167c640a42b3c9b6e5930b"
}