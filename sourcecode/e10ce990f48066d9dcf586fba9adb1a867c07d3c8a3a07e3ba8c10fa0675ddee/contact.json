{
  "address": "0x9cb22d847750eaa06de1fb64cc87ce10a9d41b48",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "ICUCrowdsale",
  "compilerVersion": "v0.4.25+commit.59dbf8f1",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2018-11-26\n*/\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n    require(token.transfer(to, value));\n  }\n\n  function safeTransferFrom(\n    ERC20 token,\n    address from,\n    address to,\n    uint256 value\n  )\n    internal\n  {\n    require(token.transferFrom(from, to, value));\n  }\n\n  function safeApprove(ERC20 token, address spender, uint256 value) internal {\n    require(token.approve(spender, value));\n  }\n}\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * See https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender)\n    public view returns (uint256);\n\n  function transferFrom(address from, address to, uint256 value)\n    public returns (bool);\n\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev Total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev Transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    emit Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256) {\n    return balances[_owner];\n  }\n\n}\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * https://github.com/ethereum/EIPs/issues/20\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  )\n    public\n    returns (bool)\n  {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    emit Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    emit Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(\n    address _owner,\n    address _spender\n   )\n    public\n    view\n    returns (uint256)\n  {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(\n    address _spender,\n    uint256 _addedValue\n  )\n    public\n    returns (bool)\n  {\n    allowed[msg.sender][_spender] = (\n      allowed[msg.sender][_spender].add(_addedValue));\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(\n    address _spender,\n    uint256 _subtractedValue\n  )\n    public\n    returns (bool)\n  {\n    uint256 oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of 'user permissions'.\n */\n\n/// @title Ownable\n/// @author Applicature\n/// @notice helper mixed to other contracts to link contract on an owner\n/// @dev Base class\ncontract Ownable {\n    //Variables\n    address public owner;\n    address public newOwner;\n\n    //    Modifiers\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param _newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address _newOwner) public onlyOwner {\n        require(_newOwner != address(0));\n        newOwner = _newOwner;\n\n    }\n\n    function acceptOwnership() public {\n        if (msg.sender == newOwner) {\n            owner = newOwner;\n        }\n    }\n}\n/**\n * @title TokenVesting\n * @dev A token holder contract that can release its token balance gradually like a\n * typical vesting scheme, with a cliff and vesting period. Optionally revocable by the\n * owner.\n */\ncontract TokenVesting is Ownable {\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20Basic;\n\n  event Released(uint256 amount);\n  event Revoked();\n\n  // beneficiary of tokens after they are released\n  address public beneficiary;\n\n  uint256 public cliff;\n  uint256 public start;\n  uint256 public duration;\n\n  bool public revocable;\n\n  mapping (address => uint256) public released;\n  mapping (address => bool) public revoked;\n\n  /**\n   * @dev Creates a vesting contract that vests its balance of any ERC20 token to the\n   * _beneficiary, gradually in a linear fashion until _start + _duration. By then all\n   * of the balance will have vested.\n   * @param _beneficiary address of the beneficiary to whom vested tokens are transferred\n   * @param _cliff duration in seconds of the cliff in which tokens will begin to vest\n   * @param _start the time (as Unix time) at which point vesting starts \n   * @param _duration duration in seconds of the period in which the tokens will vest\n   * @param _revocable whether the vesting is revocable or not\n   */\n  constructor(\n    address _beneficiary,\n    uint256 _start,\n    uint256 _cliff,\n    uint256 _duration,\n    bool _revocable\n  )\n    public\n  {\n    require(_beneficiary != address(0));\n    require(_cliff <= _duration);\n\n    beneficiary = _beneficiary;\n    revocable = _revocable;\n    duration = _duration;\n    cliff = _start.add(_cliff);\n    start = _start;\n  }\n\n  /**\n   * @notice Transfers vested tokens to beneficiary.\n   * @param token ERC20 token which is being vested\n   */\n  function release(ERC20Basic token) public {\n    uint256 unreleased = releasableAmount(token);\n\n    require(unreleased > 0);\n\n    released[token] = released[token].add(unreleased);\n\n    token.safeTransfer(beneficiary, unreleased);\n\n    emit Released(unreleased);\n  }\n\n  /**\n   * @notice Allows the owner to revoke the vesting. Tokens already vested\n   * remain in the contract, the rest are returned to the owner.\n   * @param token ERC20 token which is being vested\n   */\n  function revoke(ERC20Basic token) public onlyOwner {\n    require(revocable);\n    require(!revoked[token]);\n\n    uint256 balance = token.balanceOf(this);\n\n    uint256 unreleased = releasableAmount(token);\n    uint256 refund = balance.sub(unreleased);\n\n    revoked[token] = true;\n\n    token.safeTransfer(owner, refund);\n\n    emit Revoked();\n  }\n\n  /**\n   * @dev Calculates the amount that has already vested but hasn't been released yet.\n   * @param token ERC20 token which is being vested\n   */\n  function releasableAmount(ERC20Basic token) public view returns (uint256) {\n    return vestedAmount(token).sub(released[token]);\n  }\n\n  /**\n   * @dev Calculates the amount that has already vested.\n   * @param token ERC20 token which is being vested\n   */\n  function vestedAmount(ERC20Basic token) public view returns (uint256) {\n    uint256 currentBalance = token.balanceOf(this);\n    uint256 totalBalance = currentBalance.add(released[token]);\n\n    if (block.timestamp < cliff) {\n      return 0;\n    } else if (block.timestamp >= start.add(duration) || revoked[token]) {\n      return totalBalance;\n    } else {\n      return totalBalance.mul(block.timestamp.sub(start)).div(duration);\n    }\n  }\n}\n/// @title OpenZeppelinERC20\n/// @author Applicature\n/// @notice Open Zeppelin implementation of standart ERC20\n/// @dev Base class\ncontract OpenZeppelinERC20 is StandardToken, Ownable {\n    using SafeMath for uint256;\n\n    uint8 public decimals;\n    string public name;\n    string public symbol;\n    string public standard;\n\n    constructor(\n        uint256 _totalSupply,\n        string _tokenName,\n        uint8 _decimals,\n        string _tokenSymbol,\n        bool _transferAllSupplyToOwner\n    ) public {\n        standard = 'ERC20 0.1';\n        totalSupply_ = _totalSupply;\n\n        if (_transferAllSupplyToOwner) {\n            balances[msg.sender] = _totalSupply;\n        } else {\n            balances[this] = _totalSupply;\n        }\n\n        name = _tokenName;\n        // Set the name for display purposes\n        symbol = _tokenSymbol;\n        // Set the symbol for display purposes\n        decimals = _decimals;\n    }\n\n}\n/// @title MintableToken\n/// @author Applicature\n/// @notice allow to mint tokens\n/// @dev Base class\ncontract MintableToken is BasicToken, Ownable {\n\n    using SafeMath for uint256;\n\n    uint256 public maxSupply;\n    bool public allowedMinting;\n    mapping(address => bool) public mintingAgents;\n    mapping(address => bool) public stateChangeAgents;\n\n    event Mint(address indexed holder, uint256 tokens);\n\n    modifier onlyMintingAgents () {\n        require(mintingAgents[msg.sender]);\n        _;\n    }\n\n    modifier onlyStateChangeAgents () {\n        require(stateChangeAgents[msg.sender]);\n        _;\n    }\n\n    constructor(uint256 _maxSupply, uint256 _mintedSupply, bool _allowedMinting) public {\n        maxSupply = _maxSupply;\n        totalSupply_ = totalSupply_.add(_mintedSupply);\n        allowedMinting = _allowedMinting;\n        mintingAgents[msg.sender] = true;\n    }\n\n    /// @notice allow to mint tokens\n    function mint(address _holder, uint256 _tokens) public onlyMintingAgents() {\n        require(allowedMinting == true && totalSupply_.add(_tokens) <= maxSupply);\n\n        totalSupply_ = totalSupply_.add(_tokens);\n\n        balances[_holder] = balances[_holder].add(_tokens);\n\n        if (totalSupply_ == maxSupply) {\n            allowedMinting = false;\n        }\n        emit Transfer(address(0), _holder, _tokens);\n        emit Mint(_holder, _tokens);\n    }\n\n    /// @notice update allowedMinting flat\n    function disableMinting() public onlyStateChangeAgents() {\n        allowedMinting = false;\n    }\n\n    /// @notice update minting agent\n    function updateMintingAgent(address _agent, bool _status) public onlyOwner {\n        mintingAgents[_agent] = _status;\n    }\n\n    /// @notice update state change agent\n    function updateStateChangeAgent(address _agent, bool _status) public onlyOwner {\n        stateChangeAgents[_agent] = _status;\n    }\n\n    /// @return available tokens\n    function availableTokens() public view returns (uint256 tokens) {\n        return maxSupply.sub(totalSupply_);\n    }\n}\n/**\n * @title Burnable Token\n * @dev Token that can be irreversibly burned (destroyed).\n */\ncontract BurnableToken is BasicToken {\n\n  event Burn(address indexed burner, uint256 value);\n\n  /**\n   * @dev Burns a specific amount of tokens.\n   * @param _value The amount of token to be burned.\n   */\n  function burn(uint256 _value) public {\n    _burn(msg.sender, _value);\n  }\n\n  function _burn(address _who, uint256 _value) internal {\n    require(_value <= balances[_who]);\n    // no need to require value <= totalSupply, since that would imply the\n    // sender's balance is greater than the totalSupply, which *should* be an assertion failure\n\n    balances[_who] = balances[_who].sub(_value);\n    totalSupply_ = totalSupply_.sub(_value);\n    emit Burn(_who, _value);\n    emit Transfer(_who, address(0), _value);\n  }\n}\n/// @title MintableBurnableToken\n/// @author Applicature\n/// @notice helper mixed to other contracts to burn tokens\n/// @dev implementation\ncontract MintableBurnableToken is MintableToken, BurnableToken {\n\n    mapping (address => bool) public burnAgents;\n\n    modifier onlyBurnAgents () {\n        require(burnAgents[msg.sender]);\n        _;\n    }\n\n    constructor(\n        uint256 _maxSupply,\n        uint256 _mintedSupply,\n        bool _allowedMinting\n    ) public MintableToken(\n        _maxSupply,\n        _mintedSupply,\n        _allowedMinting\n    ) {\n\n    }\n\n    /// @notice update burn agent\n    function updateBurnAgent(address _agent, bool _status) public onlyOwner {\n        burnAgents[_agent] = _status;\n    }\n\n    function burnByAgent(address _holder, uint256 _tokensToBurn) public onlyBurnAgents() returns (uint256) {\n        if (_tokensToBurn == 0) {\n            _tokensToBurn = balances[_holder];\n        }\n        _burn(_holder, _tokensToBurn);\n\n        return _tokensToBurn;\n    }\n\n    function _burn(address _who, uint256 _value) internal {\n        super._burn(_who, _value);\n        maxSupply = maxSupply.sub(_value);\n    }\n}\n/// @title TimeLocked\n/// @author Applicature\n/// @notice helper mixed to other contracts to lock contract on a timestamp\n/// @dev Base class\ncontract TimeLocked {\n    uint256 public time;\n    mapping(address => bool) public excludedAddresses;\n\n    modifier isTimeLocked(address _holder, bool _timeLocked) {\n        bool locked = (block.timestamp < time);\n        require(excludedAddresses[_holder] == true || locked == _timeLocked);\n        _;\n    }\n\n    constructor(uint256 _time) public {\n        time = _time;\n    }\n\n    function updateExcludedAddress(address _address, bool _status) public;\n}\n/// @title TimeLockedToken\n/// @author Applicature\n/// @notice helper mixed to other contracts to lock contract on a timestamp\n/// @dev Base class\ncontract TimeLockedToken is TimeLocked, StandardToken {\n\n    constructor(uint256 _time) public TimeLocked(_time) {}\n\n    function transfer(address _to, uint256 _tokens) public isTimeLocked(msg.sender, false) returns (bool) {\n        return super.transfer(_to, _tokens);\n    }\n\n    function transferFrom(address _holder, address _to, uint256 _tokens)\n        public\n        isTimeLocked(_holder, false)\n        returns (bool)\n    {\n        return super.transferFrom(_holder, _to, _tokens);\n    }\n}\ncontract ICUToken is OpenZeppelinERC20, MintableBurnableToken, TimeLockedToken {\n\n    ICUCrowdsale public crowdsale;\n\n    bool public isSoftCapAchieved;\n\n    constructor(uint256 _unlockTokensTime)\n        public\n        OpenZeppelinERC20(0, 'iCumulate', 18, 'ICU', false)\n        MintableBurnableToken(4700000000e18, 0, true)\n        TimeLockedToken(_unlockTokensTime)\n    {}\n\n    function setUnlockTime(uint256 _unlockTokensTime) public onlyStateChangeAgents {\n        time = _unlockTokensTime;\n    }\n\n    function setIsSoftCapAchieved() public onlyStateChangeAgents {\n        isSoftCapAchieved = true;\n    }\n\n    function setCrowdSale(address _crowdsale) public onlyOwner {\n        require(_crowdsale != address(0));\n        crowdsale = ICUCrowdsale(_crowdsale);\n    }\n\n    function updateExcludedAddress(address _address, bool _status) public onlyOwner {\n        excludedAddresses[_address] = _status;\n    }\n\n    function transfer(address _to, uint256 _tokens) public returns (bool) {\n        require(true == isTransferAllowed(msg.sender));\n        return super.transfer(_to, _tokens);\n    }\n\n    function transferFrom(address _holder, address _to, uint256 _tokens) public returns (bool) {\n        require(true == isTransferAllowed(_holder));\n        return super.transferFrom(_holder, _to, _tokens);\n    }\n\n    function isTransferAllowed(address _address) public view returns (bool) {\n        if (excludedAddresses[_address] == true) {\n            return true;\n        }\n\n        if (!isSoftCapAchieved && (address(crowdsale) == address(0) || false == crowdsale.isSoftCapAchieved(0))) {\n            return false;\n        }\n\n        return true;\n    }\n\n    function burnUnsoldTokens(uint256 _tokensToBurn) public onlyBurnAgents() returns (uint256) {\n        require(maxSupply.sub(_tokensToBurn) >= totalSupply_);\n\n        maxSupply = maxSupply.sub(_tokensToBurn);\n\n        emit Burn(address(0), _tokensToBurn);\n\n        return _tokensToBurn;\n    }\n\n}\n/// @title Agent\n/// @author Applicature\n/// @notice Contract which takes actions on state change and contribution\n/// @dev Base class\ncontract Agent {\n    using SafeMath for uint256;\n\n    function isInitialized() public view returns (bool) {\n        return false;\n    }\n}\n/// @title CrowdsaleAgent\n/// @author Applicature\n/// @notice Contract which takes actions on state change and contribution\n/// @dev Base class\ncontract CrowdsaleAgent is Agent {\n\n    Crowdsale public crowdsale;\n    bool public _isInitialized;\n\n    modifier onlyCrowdsale() {\n        require(msg.sender == address(crowdsale));\n        _;\n    }\n\n    constructor(Crowdsale _crowdsale) public {\n        crowdsale = _crowdsale;\n\n        if (address(0) != address(_crowdsale)) {\n            _isInitialized = true;\n        } else {\n            _isInitialized = false;\n        }\n    }\n\n    function isInitialized() public view returns (bool) {\n        return _isInitialized;\n    }\n\n    function onContribution(address _contributor, uint256 _weiAmount, uint256 _tokens, uint256 _bonus)\n        public onlyCrowdsale();\n\n    function onStateChange(Crowdsale.State _state) public onlyCrowdsale();\n\n    function onRefund(address _contributor, uint256 _tokens) public onlyCrowdsale() returns (uint256 burned);\n}\n/// @title MintableCrowdsaleOnSuccessAgent\n/// @author Applicature\n/// @notice Contract which takes actions on state change and contribution\n/// un-pause tokens and disable minting on Crowdsale success\n/// @dev implementation\ncontract MintableCrowdsaleOnSuccessAgent is CrowdsaleAgent {\n\n    MintableToken public token;\n    bool public _isInitialized;\n\n    constructor(Crowdsale _crowdsale, MintableToken _token) public CrowdsaleAgent(_crowdsale) {\n        token = _token;\n\n        if (address(0) != address(_token) && address(0) != address(_crowdsale)) {\n            _isInitialized = true;\n        } else {\n            _isInitialized = false;\n        }\n    }\n\n    /// @notice Check whether contract is initialised\n    /// @return true if initialized\n    function isInitialized() public view returns (bool) {\n        return _isInitialized;\n    }\n\n    /// @notice Takes actions on contribution\n    function onContribution(address _contributor, uint256 _weiAmount, uint256 _tokens, uint256 _bonus) public onlyCrowdsale;\n\n    /// @notice Takes actions on state change,\n    /// un-pause tokens and disable minting on Crowdsale success\n    /// @param _state Crowdsale.State\n    function onStateChange(Crowdsale.State _state) public onlyCrowdsale;\n}\ncontract ICUAgent is MintableCrowdsaleOnSuccessAgent {\n\n    ICUStrategy public strategy;\n    ICUCrowdsale public crowdsale;\n\n    bool public burnStatus;\n\n    constructor(\n        ICUCrowdsale _crowdsale,\n        ICUToken _token,\n        ICUStrategy _strategy\n    ) public MintableCrowdsaleOnSuccessAgent(_crowdsale, _token) {\n        require(address(_strategy) != address(0) && address(_crowdsale) != address(0));\n        strategy = _strategy;\n        crowdsale = _crowdsale;\n    }\n\n    /// @notice Takes actions on contribution\n    function onContribution(\n        address,\n        uint256 _tierIndex,\n        uint256 _tokens,\n        uint256 _bonus\n    ) public onlyCrowdsale() {\n        strategy.updateTierState(_tierIndex, _tokens, _bonus);\n    }\n\n    function onStateChange(Crowdsale.State _state) public onlyCrowdsale() {\n        ICUToken icuToken = ICUToken(token);\n        if (\n            icuToken.isSoftCapAchieved() == false\n            && (_state == Crowdsale.State.Success || _state == Crowdsale.State.Finalized)\n            && crowdsale.isSoftCapAchieved(0)\n        ) {\n            icuToken.setIsSoftCapAchieved();\n        }\n\n        if (_state > Crowdsale.State.InCrowdsale && burnStatus == false) {\n            uint256 unsoldTokensAmount = strategy.getUnsoldTokens();\n\n            burnStatus = true;\n\n            icuToken.burnUnsoldTokens(unsoldTokensAmount);\n        }\n\n    }\n\n    function onRefund(address _contributor, uint256 _tokens) public onlyCrowdsale() returns (uint256 burned) {\n        burned = ICUToken(token).burnByAgent(_contributor, _tokens);\n    }\n\n    function updateLockPeriod(uint256 _time) public {\n        require(msg.sender == address(strategy));\n        ICUToken(token).setUnlockTime(_time);\n    }\n\n}\n/// @title TokenAllocator\n/// @author Applicature\n/// @notice Contract responsible for defining distribution logic of tokens.\n/// @dev Base class\ncontract TokenAllocator is Ownable {\n\n\n    mapping(address => bool) public crowdsales;\n\n    modifier onlyCrowdsale() {\n        require(crowdsales[msg.sender]);\n        _;\n    }\n\n    function addCrowdsales(address _address) public onlyOwner {\n        crowdsales[_address] = true;\n    }\n\n    function removeCrowdsales(address _address) public onlyOwner {\n        crowdsales[_address] = false;\n    }\n\n    function isInitialized() public view returns (bool) {\n        return false;\n    }\n\n    function allocate(address _holder, uint256 _tokens) public onlyCrowdsale() {\n        internalAllocate(_holder, _tokens);\n    }\n\n    function tokensAvailable() public view returns (uint256);\n\n    function internalAllocate(address _holder, uint256 _tokens) internal onlyCrowdsale();\n}\n/// @title MintableTokenAllocator\n/// @author Applicature\n/// @notice Contract responsible for defining distribution logic of tokens.\n/// @dev implementation\ncontract MintableTokenAllocator is TokenAllocator {\n\n    using SafeMath for uint256;\n\n    MintableToken public token;\n\n    constructor(MintableToken _token) public {\n        require(address(0) != address(_token));\n        token = _token;\n    }\n\n    /// @notice update instance of MintableToken\n    function setToken(MintableToken _token) public onlyOwner {\n        token = _token;\n    }\n\n    function internalAllocate(address _holder, uint256 _tokens) internal {\n        token.mint(_holder, _tokens);\n    }\n\n    /// @notice Check whether contract is initialised\n    /// @return true if initialized\n    function isInitialized() public view returns (bool) {\n        return token.mintingAgents(this);\n    }\n\n    /// @return available tokens\n    function tokensAvailable() public view returns (uint256) {\n        return token.availableTokens();\n    }\n\n}\n/// @title ContributionForwarder\n/// @author Applicature\n/// @notice Contract is responsible for distributing collected ethers, that are received from CrowdSale.\n/// @dev Base class\ncontract ContributionForwarder {\n\n    using SafeMath for uint256;\n\n    uint256 public weiCollected;\n    uint256 public weiForwarded;\n\n    event ContributionForwarded(address receiver, uint256 weiAmount);\n\n    function isInitialized() public view returns (bool) {\n        return false;\n    }\n\n    /// @notice transfer wei to receiver\n    function forward() public payable {\n        require(msg.value > 0);\n\n        weiCollected += msg.value;\n\n        internalForward();\n    }\n\n    function internalForward() internal;\n}\n/// @title DistributedDirectContributionForwarder\n/// @author Applicature\n/// @notice Contract is responsible for distributing collected ethers, that are received from CrowdSale.\n/// @dev implementation\ncontract DistributedDirectContributionForwarder is ContributionForwarder {\n    Receiver[] public receivers;\n    uint256 public proportionAbsMax;\n    bool public isInitialized_;\n\n    struct Receiver {\n        address receiver;\n        uint256 proportion; // abslolute value in range of 0 - proportionAbsMax\n        uint256 forwardedWei;\n    }\n\n    constructor(uint256 _proportionAbsMax, address[] _receivers, uint256[] _proportions) public {\n        proportionAbsMax = _proportionAbsMax;\n\n        require(_receivers.length == _proportions.length);\n\n        require(_receivers.length > 0);\n\n        uint256 totalProportion;\n\n        for (uint256 i = 0; i < _receivers.length; i++) {\n            uint256 proportion = _proportions[i];\n\n            totalProportion = totalProportion.add(proportion);\n\n            receivers.push(Receiver(_receivers[i], proportion, 0));\n        }\n\n        require(totalProportion == proportionAbsMax);\n        isInitialized_ = true;\n    }\n\n    /// @notice Check whether contract is initialised\n    /// @return true if initialized\n    function isInitialized() public view returns (bool) {\n        return isInitialized_;\n    }\n\n    function internalForward() internal {\n        uint256 transferred;\n\n        for (uint256 i = 0; i < receivers.length; i++) {\n            Receiver storage receiver = receivers[i];\n\n            uint256 value = msg.value.mul(receiver.proportion).div(proportionAbsMax);\n\n            if (i == receivers.length - 1) {\n                value = msg.value.sub(transferred);\n            }\n\n            transferred = transferred.add(value);\n\n            receiver.receiver.transfer(value);\n\n            emit ContributionForwarded(receiver.receiver, value);\n        }\n\n        weiForwarded = weiForwarded.add(transferred);\n    }\n}\ncontract Crowdsale {\n\n    uint256 public tokensSold;\n\n    enum State {Unknown, Initializing, BeforeCrowdsale, InCrowdsale, Success, Finalized, Refunding}\n\n    function externalContribution(address _contributor, uint256 _wei) public payable;\n\n    function contribute(uint8 _v, bytes32 _r, bytes32 _s) public payable;\n\n    function getState() public view returns (State);\n\n    function updateState() public;\n\n    function internalContribution(address _contributor, uint256 _wei) internal;\n\n}\n/// @title Crowdsale\n/// @author Applicature\n/// @notice Contract is responsible for collecting, refunding, allocating tokens during different stages of Crowdsale.\ncontract CrowdsaleImpl is Crowdsale, Ownable {\n\n    using SafeMath for uint256;\n\n    State public currentState;\n    TokenAllocator public allocator;\n    ContributionForwarder public contributionForwarder;\n    PricingStrategy public pricingStrategy;\n    CrowdsaleAgent public crowdsaleAgent;\n    bool public finalized;\n    uint256 public startDate;\n    uint256 public endDate;\n    bool public allowWhitelisted;\n    bool public allowSigned;\n    bool public allowAnonymous;\n    mapping(address => bool) public whitelisted;\n    mapping(address => bool) public signers;\n    mapping(address => bool) public externalContributionAgents;\n\n    event Contribution(address _contributor, uint256 _wei, uint256 _tokensExcludingBonus, uint256 _bonus);\n\n    constructor(\n        TokenAllocator _allocator,\n        ContributionForwarder _contributionForwarder,\n        PricingStrategy _pricingStrategy,\n        uint256 _startDate,\n        uint256 _endDate,\n        bool _allowWhitelisted,\n        bool _allowSigned,\n        bool _allowAnonymous\n    ) public {\n        allocator = _allocator;\n        contributionForwarder = _contributionForwarder;\n        pricingStrategy = _pricingStrategy;\n\n        startDate = _startDate;\n        endDate = _endDate;\n\n        allowWhitelisted = _allowWhitelisted;\n        allowSigned = _allowSigned;\n        allowAnonymous = _allowAnonymous;\n\n        currentState = State.Unknown;\n    }\n\n    /// @notice default payable function\n    function() public payable {\n        require(allowWhitelisted || allowAnonymous);\n\n        if (!allowAnonymous) {\n            if (allowWhitelisted) {\n                require(whitelisted[msg.sender]);\n            }\n        }\n\n        internalContribution(msg.sender, msg.value);\n    }\n\n    /// @notice update crowdsale agent\n    function setCrowdsaleAgent(CrowdsaleAgent _crowdsaleAgent) public onlyOwner {\n        require(address(_crowdsaleAgent) != address(0));\n        crowdsaleAgent = _crowdsaleAgent;\n    }\n\n    /// @notice allows external user to do contribution\n    function externalContribution(address _contributor, uint256 _wei) public payable {\n        require(externalContributionAgents[msg.sender]);\n        internalContribution(_contributor, _wei);\n    }\n\n    /// @notice update external contributor\n    function addExternalContributor(address _contributor) public onlyOwner {\n        externalContributionAgents[_contributor] = true;\n    }\n\n    /// @notice update external contributor\n    function removeExternalContributor(address _contributor) public onlyOwner {\n        externalContributionAgents[_contributor] = false;\n    }\n\n    /// @notice update whitelisting address\n    function updateWhitelist(address _address, bool _status) public onlyOwner {\n        whitelisted[_address] = _status;\n    }\n\n    /// @notice update signer\n    function addSigner(address _signer) public onlyOwner {\n        signers[_signer] = true;\n    }\n\n    /// @notice update signer\n    function removeSigner(address _signer) public onlyOwner {\n        signers[_signer] = false;\n    }\n\n    /// @notice allows to do signed contributions\n    function contribute(uint8 _v, bytes32 _r, bytes32 _s) public payable {\n        address recoveredAddress = verify(msg.sender, _v, _r, _s);\n        require(signers[recoveredAddress]);\n        internalContribution(msg.sender, msg.value);\n    }\n\n    /// @notice check sign\n    function verify(address _sender, uint8 _v, bytes32 _r, bytes32 _s) public view returns (address) {\n        bytes32 hash = keccak256(abi.encodePacked(this, _sender));\n\n        bytes memory prefix = '\\x19Ethereum Signed Message:\\n32';\n\n        return ecrecover(keccak256(abi.encodePacked(prefix, hash)), _v, _r, _s);\n    }\n\n    /// @return Crowdsale state\n    function getState() public view returns (State) {\n        if (finalized) {\n            return State.Finalized;\n        } else if (allocator.isInitialized() == false) {\n            return State.Initializing;\n        } else if (contributionForwarder.isInitialized() == false) {\n            return State.Initializing;\n        } else if (pricingStrategy.isInitialized() == false) {\n            return State.Initializing;\n        } else if (block.timestamp < startDate) {\n            return State.BeforeCrowdsale;\n        } else if (block.timestamp >= startDate && block.timestamp <= endDate) {\n            return State.InCrowdsale;\n        } else if (block.timestamp > endDate) {\n            return State.Success;\n        }\n\n        return State.Unknown;\n    }\n\n    /// @notice Crowdsale state\n    function updateState() public {\n        State state = getState();\n\n        if (currentState != state) {\n            if (crowdsaleAgent != address(0)) {\n                crowdsaleAgent.onStateChange(state);\n            }\n\n            currentState = state;\n        }\n    }\n\n    function internalContribution(address _contributor, uint256 _wei) internal {\n        require(getState() == State.InCrowdsale);\n\n        uint256 tokensAvailable = allocator.tokensAvailable();\n        uint256 collectedWei = contributionForwarder.weiCollected();\n\n        uint256 tokens;\n        uint256 tokensExcludingBonus;\n        uint256 bonus;\n\n        (tokens, tokensExcludingBonus, bonus) = pricingStrategy.getTokens(\n            _contributor, tokensAvailable, tokensSold, _wei, collectedWei);\n\n        require(tokens > 0 && tokens <= tokensAvailable);\n        tokensSold = tokensSold.add(tokens);\n\n        allocator.allocate(_contributor, tokens);\n\n        if (msg.value > 0) {\n            contributionForwarder.forward.value(msg.value)();\n        }\n\n        emit Contribution(_contributor, _wei, tokensExcludingBonus, bonus);\n    }\n\n}\n/// @title HardCappedCrowdsale\n/// @author Applicature\n/// @notice Contract is responsible for collecting, refunding, allocating tokens during different stages of Crowdsale.\n/// with hard limit\ncontract HardCappedCrowdsale is CrowdsaleImpl {\n\n    using SafeMath for uint256;\n\n    uint256 public hardCap;\n\n    constructor(\n        TokenAllocator _allocator,\n        ContributionForwarder _contributionForwarder,\n        PricingStrategy _pricingStrategy,\n        uint256 _startDate,\n        uint256 _endDate,\n        bool _allowWhitelisted,\n        bool _allowSigned,\n        bool _allowAnonymous,\n        uint256 _hardCap\n    ) public CrowdsaleImpl(\n        _allocator,\n        _contributionForwarder,\n        _pricingStrategy,\n        _startDate,\n        _endDate,\n        _allowWhitelisted,\n        _allowSigned,\n        _allowAnonymous\n    ) {\n        hardCap = _hardCap;\n    }\n\n    /// @return Crowdsale state\n    function getState() public view returns (State) {\n        State state = super.getState();\n\n        if (state == State.InCrowdsale) {\n            if (isHardCapAchieved(0)) {\n                return State.Success;\n            }\n        }\n\n        return state;\n    }\n\n    function isHardCapAchieved(uint256 _value) public view returns (bool) {\n        if (hardCap <= tokensSold.add(_value)) {\n            return true;\n        }\n        return false;\n    }\n\n    function internalContribution(address _contributor, uint256 _wei) internal {\n        require(getState() == State.InCrowdsale);\n\n        uint256 tokensAvailable = allocator.tokensAvailable();\n        uint256 collectedWei = contributionForwarder.weiCollected();\n\n        uint256 tokens;\n        uint256 tokensExcludingBonus;\n        uint256 bonus;\n\n        (tokens, tokensExcludingBonus, bonus) = pricingStrategy.getTokens(\n            _contributor, tokensAvailable, tokensSold, _wei, collectedWei);\n\n        require(tokens <= tokensAvailable && tokens > 0 && false == isHardCapAchieved(tokens.sub(1)));\n\n        tokensSold = tokensSold.add(tokens);\n\n        allocator.allocate(_contributor, tokens);\n\n        if (msg.value > 0) {\n            contributionForwarder.forward.value(msg.value)();\n        }\n        crowdsaleAgent.onContribution(_contributor, _wei, tokensExcludingBonus, bonus);\n        emit Contribution(_contributor, _wei, tokensExcludingBonus, bonus);\n    }\n}\n/// @title RefundableCrowdsale\n/// @author Applicature\n/// @notice Contract is responsible for collecting, refunding, allocating tokens during different stages of Crowdsale.\n/// with hard and soft limits\ncontract RefundableCrowdsale is HardCappedCrowdsale {\n\n    using SafeMath for uint256;\n\n    uint256 public softCap;\n    mapping(address => uint256) public contributorsWei;\n    address[] public contributors;\n\n    event Refund(address _holder, uint256 _wei, uint256 _tokens);\n\n    constructor(\n        TokenAllocator _allocator,\n        ContributionForwarder _contributionForwarder,\n        PricingStrategy _pricingStrategy,\n        uint256 _startDate,\n        uint256 _endDate,\n        bool _allowWhitelisted,\n        bool _allowSigned,\n        bool _allowAnonymous,\n        uint256 _softCap,\n        uint256 _hardCap\n\n    ) public HardCappedCrowdsale(\n        _allocator, _contributionForwarder, _pricingStrategy,\n        _startDate, _endDate,\n        _allowWhitelisted, _allowSigned, _allowAnonymous, _hardCap\n    ) {\n        softCap = _softCap;\n    }\n\n    /// @return Crowdsale state\n    function getState() public view returns (State) {\n        State state = super.getState();\n\n        if (state == State.Success) {\n            if (!isSoftCapAchieved(0)) {\n                return State.Refunding;\n            }\n        }\n\n        return state;\n    }\n\n    function isSoftCapAchieved(uint256 _value) public view returns (bool) {\n        if (softCap <= tokensSold.add(_value)) {\n            return true;\n        }\n        return false;\n    }\n\n    /// @notice refund ethers to contributor\n    function refund() public {\n        internalRefund(msg.sender);\n    }\n\n    /// @notice refund ethers to delegate\n    function delegatedRefund(address _address) public {\n        internalRefund(_address);\n    }\n\n    function internalContribution(address _contributor, uint256 _wei) internal {\n        require(block.timestamp >= startDate && block.timestamp <= endDate);\n\n        uint256 tokensAvailable = allocator.tokensAvailable();\n        uint256 collectedWei = contributionForwarder.weiCollected();\n\n        uint256 tokens;\n        uint256 tokensExcludingBonus;\n        uint256 bonus;\n\n        (tokens, tokensExcludingBonus, bonus) = pricingStrategy.getTokens(\n            _contributor, tokensAvailable, tokensSold, _wei, collectedWei);\n\n        require(tokens <= tokensAvailable && tokens > 0 && hardCap > tokensSold.add(tokens));\n\n        tokensSold = tokensSold.add(tokens);\n\n        allocator.allocate(_contributor, tokens);\n\n        // transfer only if softcap is reached\n        if (isSoftCapAchieved(0)) {\n            if (msg.value > 0) {\n                contributionForwarder.forward.value(address(this).balance)();\n            }\n        } else {\n            // store contributor if it is not stored before\n            if (contributorsWei[_contributor] == 0) {\n                contributors.push(_contributor);\n            }\n            contributorsWei[_contributor] = contributorsWei[_contributor].add(msg.value);\n        }\n        crowdsaleAgent.onContribution(_contributor, _wei, tokensExcludingBonus, bonus);\n        emit Contribution(_contributor, _wei, tokensExcludingBonus, bonus);\n    }\n\n    function internalRefund(address _holder) internal {\n        updateState();\n        require(block.timestamp > endDate);\n        require(!isSoftCapAchieved(0));\n        require(crowdsaleAgent != address(0));\n\n        uint256 value = contributorsWei[_holder];\n\n        require(value > 0);\n\n        contributorsWei[_holder] = 0;\n        uint256 burnedTokens = crowdsaleAgent.onRefund(_holder, 0);\n\n        _holder.transfer(value);\n\n        emit Refund(_holder, value, burnedTokens);\n    }\n}\ncontract ICUCrowdsale is RefundableCrowdsale {\n\n    uint256 public maxSaleSupply = 2350000000e18;\n\n    uint256 public availableBonusAmount = 447500000e18;\n\n    uint256 public usdCollected;\n\n    mapping(address => uint256) public contributorBonuses;\n\n    constructor(\n        MintableTokenAllocator _allocator,\n        DistributedDirectContributionForwarder _contributionForwarder,\n        ICUStrategy _pricingStrategy,\n        uint256 _startTime,\n        uint256 _endTime\n    ) public RefundableCrowdsale(\n        _allocator,\n        _contributionForwarder,\n        _pricingStrategy,\n        _startTime,\n        _endTime,\n        true,\n        true,\n        false,\n        2500000e5, //softCap\n        23500000e5//hardCap\n    ) {}\n\n    function updateState() public {\n        (startDate, endDate) = ICUStrategy(pricingStrategy).getActualDates();\n        super.updateState();\n    }\n\n    function claimBonuses() public {\n        require(isSoftCapAchieved(0) && contributorBonuses[msg.sender] > 0);\n\n        uint256 bonus = contributorBonuses[msg.sender];\n        contributorBonuses[msg.sender] = 0;\n        allocator.allocate(msg.sender, bonus);\n    }\n\n    function addExternalContributor(address) public onlyOwner {\n        require(false);\n    }\n\n    function isHardCapAchieved(uint256 _value) public view returns (bool) {\n        if (hardCap <= usdCollected.add(_value)) {\n            return true;\n        }\n        return false;\n    }\n\n    function isSoftCapAchieved(uint256 _value) public view returns (bool) {\n        if (softCap <= usdCollected.add(_value)) {\n            return true;\n        }\n        return false;\n    }\n\n    function internalContribution(address _contributor, uint256 _wei) internal {\n        updateState();\n        require(currentState == State.InCrowdsale);\n\n        ICUStrategy pricing = ICUStrategy(pricingStrategy);\n        uint256 usdAmount = pricing.getUSDAmount(_wei);\n        require(!isHardCapAchieved(usdAmount.sub(1)));\n\n        uint256 tokensAvailable = allocator.tokensAvailable();\n        uint256 collectedWei = contributionForwarder.weiCollected();\n        uint256 tierIndex = pricing.getTierIndex();\n        uint256 tokens;\n        uint256 tokensExcludingBonus;\n        uint256 bonus;\n\n        (tokens, tokensExcludingBonus, bonus) = pricing.getTokens(\n            _contributor, tokensAvailable, tokensSold, _wei, collectedWei\n        );\n\n        require(tokens > 0);\n        tokensSold = tokensSold.add(tokens);\n        allocator.allocate(_contributor, tokensExcludingBonus);\n\n        if (isSoftCapAchieved(usdAmount)) {\n            if (msg.value > 0) {\n                contributionForwarder.forward.value(address(this).balance)();\n            }\n        } else {\n            // store contributor if it is not stored before\n            if (contributorsWei[_contributor] == 0) {\n                contributors.push(_contributor);\n            }\n            contributorsWei[_contributor] = contributorsWei[_contributor].add(msg.value);\n        }\n\n        usdCollected = usdCollected.add(usdAmount);\n\n        if (availableBonusAmount > 0) {\n            if (availableBonusAmount >= bonus) {\n                availableBonusAmount -= bonus;\n            } else {\n                bonus = availableBonusAmount;\n                availableBonusAmount = 0;\n            }\n            contributorBonuses[_contributor] = contributorBonuses[_contributor].add(bonus);\n        } else {\n            bonus = 0;\n        }\n\n        crowdsaleAgent.onContribution(pricing, tierIndex, tokensExcludingBonus, bonus);\n        emit Contribution(_contributor, _wei, tokensExcludingBonus, bonus);\n    }\n\n}\n/// @title PricingStrategy\n/// @author Applicature\n/// @notice Contract is responsible for calculating tokens amount depending on different criterias\n/// @dev Base class\ncontract PricingStrategy {\n\n    function isInitialized() public view returns (bool);\n\n    function getTokens(\n        address _contributor,\n        uint256 _tokensAvailable,\n        uint256 _tokensSold,\n        uint256 _weiAmount,\n        uint256 _collectedWei\n    )\n        public\n        view\n        returns (uint256 tokens, uint256 tokensExludingBonus, uint256 bonus);\n\n    function getWeis(\n        uint256 _collectedWei,\n        uint256 _tokensSold,\n        uint256 _tokens\n    )\n        public\n        view\n        returns (uint256 weiAmount, uint256 tokensBonus);\n}\n/// @title TokenDateCappedTiersPricingStrategy\n/// @author Applicature\n/// @notice Contract is responsible for calculating tokens amount depending on price in USD\n/// @dev implementation\ncontract TokenDateCappedTiersPricingStrategy is PricingStrategy, Ownable {\n\n    using SafeMath for uint256;\n\n    uint256 public etherPriceInUSD;\n\n    uint256 public capsAmount;\n\n    struct Tier {\n        uint256 tokenInUSD;\n        uint256 maxTokensCollected;\n        uint256 soldTierTokens;\n        uint256 bonusTierTokens;\n        uint256 discountPercents;\n        uint256 minInvestInUSD;\n        uint256 startDate;\n        uint256 endDate;\n        bool unsoldProcessed;\n        uint256[] capsData;\n    }\n\n    Tier[] public tiers;\n    uint256 public decimals;\n\n    constructor(\n        uint256[] _tiers,\n        uint256[] _capsData,\n        uint256 _decimals,\n        uint256 _etherPriceInUSD\n    )\n        public\n    {\n        decimals = _decimals;\n        require(_etherPriceInUSD > 0);\n        etherPriceInUSD = _etherPriceInUSD;\n\n        require(_tiers.length % 6 == 0);\n        uint256 length = _tiers.length / 6;\n\n        require(_capsData.length % 2 == 0);\n        uint256 lengthCaps = _capsData.length / 2;\n\n        uint256[] memory emptyArray;\n\n        for (uint256 i = 0; i < length; i++) {\n            tiers.push(\n                Tier(\n                    _tiers[i * 6],//tokenInUSD\n                    _tiers[i * 6 + 1],//maxTokensCollected\n                    0,//soldTierTokens\n                    0,//bonusTierTokens\n                    _tiers[i * 6 + 2],//discountPercents\n                    _tiers[i * 6 + 3],//minInvestInUSD\n                    _tiers[i * 6 + 4],//startDate\n                    _tiers[i * 6 + 5],//endDate\n                    false,\n                    emptyArray//capsData\n                )\n            );\n\n            for (uint256 j = 0; j < lengthCaps; j++) {\n                tiers[i].capsData.push(_capsData[i * lengthCaps + j]);\n            }\n        }\n    }\n\n    /// @return tier index\n    function getTierIndex() public view returns (uint256) {\n        for (uint256 i = 0; i < tiers.length; i++) {\n            if (\n                block.timestamp >= tiers[i].startDate &&\n                block.timestamp < tiers[i].endDate &&\n                tiers[i].maxTokensCollected > tiers[i].soldTierTokens\n            ) {\n                return i;\n            }\n        }\n\n        return tiers.length;\n    }\n\n    function getActualTierIndex() public view returns (uint256) {\n        for (uint256 i = 0; i < tiers.length; i++) {\n            if (\n                block.timestamp >= tiers[i].startDate\n                && block.timestamp < tiers[i].endDate\n                && tiers[i].maxTokensCollected > tiers[i].soldTierTokens\n                || block.timestamp < tiers[i].startDate\n            ) {\n                return i;\n            }\n        }\n\n        return tiers.length.sub(1);\n    }\n\n    /// @return actual dates\n    function getActualDates() public view returns (uint256 startDate, uint256 endDate) {\n        uint256 tierIndex = getActualTierIndex();\n        startDate = tiers[tierIndex].startDate;\n        endDate = tiers[tierIndex].endDate;\n    }\n\n    function getTokensWithoutRestrictions(uint256 _weiAmount) public view returns (\n        uint256 tokens,\n        uint256 tokensExcludingBonus,\n        uint256 bonus\n    ) {\n        if (_weiAmount == 0) {\n            return (0, 0, 0);\n        }\n\n        uint256 tierIndex = getActualTierIndex();\n\n        tokensExcludingBonus = _weiAmount.mul(etherPriceInUSD).div(getTokensInUSD(tierIndex));\n        bonus = calculateBonusAmount(tierIndex, tokensExcludingBonus);\n        tokens = tokensExcludingBonus.add(bonus);\n    }\n\n    /// @return tokens based on sold tokens and wei amount\n    function getTokens(\n        address,\n        uint256 _tokensAvailable,\n        uint256,\n        uint256 _weiAmount,\n        uint256\n    ) public view returns (uint256 tokens, uint256 tokensExcludingBonus, uint256 bonus) {\n        if (_weiAmount == 0) {\n            return (0, 0, 0);\n        }\n\n        uint256 tierIndex = getTierIndex();\n        if (tierIndex == tiers.length || _weiAmount.mul(etherPriceInUSD).div(1e18) < tiers[tierIndex].minInvestInUSD) {\n            return (0, 0, 0);\n        }\n\n        tokensExcludingBonus = _weiAmount.mul(etherPriceInUSD).div(getTokensInUSD(tierIndex));\n\n        if (tiers[tierIndex].maxTokensCollected < tiers[tierIndex].soldTierTokens.add(tokensExcludingBonus)) {\n            return (0, 0, 0);\n        }\n\n        bonus = calculateBonusAmount(tierIndex, tokensExcludingBonus);\n        tokens = tokensExcludingBonus.add(bonus);\n\n        if (tokens > _tokensAvailable) {\n            return (0, 0, 0);\n        }\n    }\n\n    /// @return weis based on sold and required tokens\n    function getWeis(\n        uint256,\n        uint256,\n        uint256 _tokens\n    ) public view returns (uint256 totalWeiAmount, uint256 tokensBonus) {\n        if (_tokens == 0) {\n            return (0, 0);\n        }\n\n        uint256 tierIndex = getTierIndex();\n        if (tierIndex == tiers.length) {\n            return (0, 0);\n        }\n        if (tiers[tierIndex].maxTokensCollected < tiers[tierIndex].soldTierTokens.add(_tokens)) {\n            return (0, 0);\n        }\n        uint256 usdAmount = _tokens.mul(getTokensInUSD(tierIndex)).div(1e18);\n        totalWeiAmount = usdAmount.mul(1e18).div(etherPriceInUSD);\n\n        if (totalWeiAmount < uint256(1 ether).mul(tiers[tierIndex].minInvestInUSD).div(etherPriceInUSD)) {\n            return (0, 0);\n        }\n\n        tokensBonus = calculateBonusAmount(tierIndex, _tokens);\n    }\n\n    function calculateBonusAmount(uint256 _tierIndex, uint256 _tokens) public view returns (uint256 bonus) {\n        uint256 length = tiers[_tierIndex].capsData.length.div(2);\n\n        uint256 remainingTokens = _tokens;\n        uint256 newSoldTokens = tiers[_tierIndex].soldTierTokens;\n\n        for (uint256 i = 0; i < length; i++) {\n            if (tiers[_tierIndex].capsData[i.mul(2)] == 0) {\n                break;\n            }\n            if (newSoldTokens.add(remainingTokens) <= tiers[_tierIndex].capsData[i.mul(2)]) {\n                bonus += remainingTokens.mul(tiers[_tierIndex].capsData[i.mul(2).add(1)]).div(100);\n                break;\n            } else {\n                uint256 diff = tiers[_tierIndex].capsData[i.mul(2)].sub(newSoldTokens);\n                remainingTokens -= diff;\n                newSoldTokens += diff;\n                bonus += diff.mul(tiers[_tierIndex].capsData[i.mul(2).add(1)]).div(100);\n            }\n        }\n    }\n\n    function getTokensInUSD(uint256 _tierIndex) public view returns (uint256) {\n        if (_tierIndex < uint256(tiers.length)) {\n            return tiers[_tierIndex].tokenInUSD;\n        }\n    }\n\n    function getDiscount(uint256 _tierIndex) public view returns (uint256) {\n        if (_tierIndex < uint256(tiers.length)) {\n            return tiers[_tierIndex].discountPercents;\n        }\n    }\n\n    function getMinEtherInvest(uint256 _tierIndex) public view returns (uint256) {\n        if (_tierIndex < uint256(tiers.length)) {\n            return tiers[_tierIndex].minInvestInUSD.mul(1 ether).div(etherPriceInUSD);\n        }\n    }\n\n    function getUSDAmount(uint256 _weiAmount) public view returns (uint256) {\n        return _weiAmount.mul(etherPriceInUSD).div(1 ether);\n    }\n\n    /// @notice Check whether contract is initialised\n    /// @return true if initialized\n    function isInitialized() public view returns (bool) {\n        return true;\n    }\n\n    /// @notice updates tier start/end dates by id\n    function updateDates(uint8 _tierId, uint256 _start, uint256 _end) public onlyOwner() {\n        if (_start != 0 && _start < _end && _tierId < tiers.length) {\n            Tier storage tier = tiers[_tierId];\n            tier.startDate = _start;\n            tier.endDate = _end;\n        }\n    }\n}\ncontract ICUStrategy is TokenDateCappedTiersPricingStrategy {\n\n    ICUAgent public agent;\n\n    event UnsoldTokensProcessed(uint256 fromTier, uint256 toTier, uint256 tokensAmount);\n\n    constructor(\n        uint256[] _emptyArray,\n        uint256 _etherPriceInUSD\n    ) public TokenDateCappedTiersPricingStrategy(\n        _emptyArray,\n        _emptyArray,\n        18,\n        _etherPriceInUSD\n    ) {\n        //Pre-ICO\n        tiers.push(\n            Tier(\n                0.01e5,//tokenInUSD\n                1000000000e18,//maxTokensCollected\n                0,//soldTierTokens\n                0,//bonusTierTokens\n                0,//discountPercents\n                uint256(20).mul(_etherPriceInUSD),//minInvestInUSD | 20 ethers\n                1543579200,//startDate | 2018/11/30 12:00:00 PM UTC\n                1544184000,//endDate | 2018/12/07 12:00:00 PM UTC\n                false,\n                _emptyArray\n            )\n        );\n        //ICO\n        tiers.push(\n            Tier(\n                0.01e5,//tokenInUSD\n                1350000000e18,//maxTokensCollected\n                0,//soldTierTokens\n                0,//bonusTierTokens\n                0,//discountPercents\n                uint256(_etherPriceInUSD).div(10),//minInvestInUSD | 0.1 ether\n                1544443200,//startDate | 2018/12/10\t12:00:00 PM UTC\n                1546257600,//endDate | 2018/12/31 12:00:00 PM UTC\n                false,\n                _emptyArray\n            )\n        );\n\n        //Pre-ICO caps data\n        tiers[0].capsData.push(1000000000e18);//cap $10,000,000 in tokens\n        tiers[0].capsData.push(30);//bonus percents\n\n        //ICO caps data\n        tiers[1].capsData.push(400000000e18);//cap $4,000,000 in tokens\n        tiers[1].capsData.push(20);//bonus percents\n\n        tiers[1].capsData.push(800000000e18);//cap $4,000,000 in tokens\n        tiers[1].capsData.push(10);//bonus percents\n\n        tiers[1].capsData.push(1350000000e18);//cap $5,500,000 in tokens\n        tiers[1].capsData.push(5);//bonus percents\n\n    }\n\n    function getArrayOfTiers() public view returns (uint256[14] tiersData) {\n        uint256 j = 0;\n        for (uint256 i = 0; i < tiers.length; i++) {\n            tiersData[j++] = uint256(tiers[i].tokenInUSD);\n            tiersData[j++] = uint256(tiers[i].maxTokensCollected);\n            tiersData[j++] = uint256(tiers[i].soldTierTokens);\n            tiersData[j++] = uint256(tiers[i].discountPercents);\n            tiersData[j++] = uint256(tiers[i].minInvestInUSD);\n            tiersData[j++] = uint256(tiers[i].startDate);\n            tiersData[j++] = uint256(tiers[i].endDate);\n        }\n    }\n\n    function updateTier(\n        uint256 _tierId,\n        uint256 _start,\n        uint256 _end,\n        uint256 _minInvest,\n        uint256 _price,\n        uint256 _discount,\n        uint256[] _capsData,\n        bool updateLockNeeded\n    ) public onlyOwner() {\n        require(\n            _start != 0 &&\n            _price != 0 &&\n            _start < _end &&\n            _tierId < tiers.length &&\n            _capsData.length > 0 &&\n            _capsData.length % 2 == 0\n        );\n\n        if (updateLockNeeded) {\n            agent.updateLockPeriod(_end);\n        }\n\n        Tier storage tier = tiers[_tierId];\n        tier.tokenInUSD = _price;\n        tier.discountPercents = _discount;\n        tier.minInvestInUSD = _minInvest;\n        tier.startDate = _start;\n        tier.endDate = _end;\n        tier.capsData = _capsData;\n    }\n\n    function setCrowdsaleAgent(ICUAgent _crowdsaleAgent) public onlyOwner {\n        agent = _crowdsaleAgent;\n    }\n\n    function updateTierState(uint256 _tierId, uint256 _soldTokens, uint256 _bonusTokens) public {\n        require(\n            msg.sender == address(agent) &&\n            _tierId < tiers.length &&\n            _soldTokens > 0\n        );\n\n        Tier storage tier = tiers[_tierId];\n\n        if (_tierId > 0 && !tiers[_tierId.sub(1)].unsoldProcessed) {\n            Tier storage prevTier = tiers[_tierId.sub(1)];\n            prevTier.unsoldProcessed = true;\n\n            uint256 unsold = prevTier.maxTokensCollected.sub(prevTier.soldTierTokens);\n            tier.maxTokensCollected = tier.maxTokensCollected.add(unsold);\n            tier.capsData[0] = tier.capsData[0].add(unsold);\n\n            emit UnsoldTokensProcessed(_tierId.sub(1), _tierId, unsold);\n        }\n\n        tier.soldTierTokens = tier.soldTierTokens.add(_soldTokens);\n        tier.bonusTierTokens = tier.bonusTierTokens.add(_bonusTokens);\n    }\n\n    function getTierUnsoldTokens(uint256 _tierId) public view returns (uint256) {\n        if (_tierId >= tiers.length || tiers[_tierId].unsoldProcessed) {\n            return 0;\n        }\n\n        return tiers[_tierId].maxTokensCollected.sub(tiers[_tierId].soldTierTokens);\n    }\n\n    function getUnsoldTokens() public view returns (uint256 unsoldTokens) {\n        for (uint256 i = 0; i < tiers.length; i++) {\n            unsoldTokens += getTierUnsoldTokens(i);\n        }\n    }\n\n    function getCapsData(uint256 _tierId) public view returns (uint256[]) {\n        if (_tierId < tiers.length) {\n            return tiers[_tierId].capsData;\n        }\n    }\n\n}\ncontract Referral is Ownable {\n\n    using SafeMath for uint256;\n\n    MintableTokenAllocator public allocator;\n    CrowdsaleImpl public crowdsale;\n\n    uint256 public constant DECIMALS = 18;\n\n    uint256 public totalSupply;\n    bool public unLimited;\n    bool public sentOnce;\n\n    mapping(address => bool) public claimed;\n    mapping(address => uint256) public claimedBalances;\n\n    constructor(\n        uint256 _totalSupply,\n        address _allocator,\n        address _crowdsale,\n        bool _sentOnce\n    ) public {\n        require(_allocator != address(0) && _crowdsale != address(0));\n        totalSupply = _totalSupply;\n        if (totalSupply == 0) {\n            unLimited = true;\n        }\n        allocator = MintableTokenAllocator(_allocator);\n        crowdsale = CrowdsaleImpl(_crowdsale);\n        sentOnce = _sentOnce;\n    }\n\n    function setAllocator(address _allocator) public onlyOwner {\n        require(_allocator != address(0));\n        allocator = MintableTokenAllocator(_allocator);\n    }\n\n    function setCrowdsale(address _crowdsale) public onlyOwner {\n        require(_crowdsale != address(0));\n        crowdsale = CrowdsaleImpl(_crowdsale);\n    }\n\n    function multivestMint(\n        address _address,\n        uint256 _amount,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) public {\n        require(true == crowdsale.signers(verify(msg.sender, _amount, _v, _r, _s)));\n        if (true == sentOnce) {\n            require(claimed[_address] == false);\n            claimed[_address] = true;\n        }\n        require(\n            _address == msg.sender &&\n            _amount > 0 &&\n            (true == unLimited || _amount <= totalSupply)\n        );\n        claimedBalances[_address] = claimedBalances[_address].add(_amount);\n        if (false == unLimited) {\n            totalSupply = totalSupply.sub(_amount);\n        }\n        allocator.allocate(_address, _amount);\n    }\n\n    /// @notice check sign\n    function verify(address _sender, uint256 _amount, uint8 _v, bytes32 _r, bytes32 _s) public pure returns (address) {\n        bytes32 hash = keccak256(abi.encodePacked(_sender, _amount));\n\n        bytes memory prefix = '\\x19Ethereum Signed Message:\\n32';\n\n        return ecrecover(keccak256(abi.encodePacked(prefix, hash)), _v, _r, _s);\n    }\n}\ncontract ICUReferral is Referral {\n\n    constructor(\n        address _allocator,\n        address _crowdsale\n    ) public Referral(35000000e18, _allocator, _crowdsale, true) {}\n\n    function multivestMint(\n        address _address,\n        uint256 _amount,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) public {\n        ICUCrowdsale icuCrowdsale = ICUCrowdsale(crowdsale);\n        icuCrowdsale.updateState();\n        require(icuCrowdsale.isSoftCapAchieved(0) && block.timestamp > icuCrowdsale.endDate());\n        super.multivestMint(_address, _amount, _v, _r, _s);\n    }\n}\ncontract Stats {\n\n    using SafeMath for uint256;\n\n    MintableToken public token;\n    MintableTokenAllocator public allocator;\n    ICUCrowdsale public crowdsale;\n    ICUStrategy public pricing;\n\n    constructor(\n        MintableToken _token,\n        MintableTokenAllocator _allocator,\n        ICUCrowdsale _crowdsale,\n        ICUStrategy _pricing\n    ) public {\n        token = _token;\n        allocator = _allocator;\n        crowdsale = _crowdsale;\n        pricing = _pricing;\n    }\n\n    function getTokens(\n        uint256,\n        uint256 _weiAmount\n    ) public view returns (uint256 tokens, uint256 tokensExcludingBonus, uint256 bonus) {\n        return pricing.getTokensWithoutRestrictions(_weiAmount);\n    }\n\n    function getWeis(\n        uint256,\n        uint256 _tokenAmount\n    ) public view returns (uint256 totalWeiAmount, uint256 tokensBonus) {\n        return pricing.getWeis(0, 0, _tokenAmount);\n    }\n\n    function getStats(uint256 _userType, uint256[7] _ethPerCurrency) public view returns (\n        uint256[8] stats,\n        uint256[26] tiersData,\n        uint256[21] currencyContr //tokensPerEachCurrency,\n    ) {\n        stats = getStatsData(_userType);\n        tiersData = getTiersData(_userType);\n        currencyContr = getCurrencyContrData(_userType, _ethPerCurrency);\n    }\n\n    function getTiersData(uint256) public view returns (\n        uint256[26] tiersData\n    ) {\n        uint256[14] memory tiers = pricing.getArrayOfTiers();\n        uint256 tierElements = tiers.length.div(2);\n        uint256 j = 0;\n        for (uint256 i = 0; i <= tierElements; i += tierElements) {\n            tiersData[j++] = uint256(1e23).div(tiers[i]);// tokenInUSD;\n            tiersData[j++] = 0;// tokenInWei;\n            tiersData[j++] = uint256(tiers[i.add(1)]);// maxTokensCollected;\n            tiersData[j++] = uint256(tiers[i.add(2)]);// soldTierTokens;\n            tiersData[j++] = 0;// discountPercents;\n            tiersData[j++] = 0;// bonusPercents;\n            tiersData[j++] = uint256(tiers[i.add(4)]);// minInvestInUSD;\n            tiersData[j++] = 0;// minInvestInWei;\n            tiersData[j++] = 0;// maxInvestInUSD;\n            tiersData[j++] = 0;// maxInvestInWei;\n            tiersData[j++] = uint256(tiers[i.add(5)]);// startDate;\n            tiersData[j++] = uint256(tiers[i.add(6)]);// endDate;\n            tiersData[j++] = 1;\n        }\n\n        tiersData[25] = 2;\n    }\n\n    function getStatsData(uint256 _type) public view returns (\n        uint256[8] stats\n    ) {\n        _type = _type;\n        stats[0] = token.maxSupply();\n        stats[1] = token.totalSupply();\n        stats[2] = crowdsale.maxSaleSupply();\n        stats[3] = crowdsale.tokensSold();\n        stats[4] = uint256(crowdsale.currentState());\n        stats[5] = pricing.getActualTierIndex();\n        stats[6] = pricing.getTierUnsoldTokens(stats[5]);\n        stats[7] = pricing.getMinEtherInvest(stats[5]);\n    }\n\n    function getCurrencyContrData(uint256 _type, uint256[7] _ethPerCurrency) public view returns (\n        uint256[21] currencyContr\n    ) {\n        _type = _type;\n        uint256 j = 0;\n        for (uint256 i = 0; i < _ethPerCurrency.length; i++) {\n            (currencyContr[j++], currencyContr[j++], currencyContr[j++]) = pricing.getTokensWithoutRestrictions(\n                _ethPerCurrency[i]\n            );\n        }\n    }\n\n}\ncontract PeriodicTokenVesting is TokenVesting {\n    address public unreleasedHolder;\n    uint256 public periods;\n\n    constructor(\n        address _beneficiary,\n        uint256 _start,\n        uint256 _cliff,\n        uint256 _duration,\n        uint256 _periods,\n        bool _revocable,\n        address _unreleasedHolder\n    )\n        public TokenVesting(_beneficiary, _start, _cliff, _duration, _revocable)\n    {\n        require(_revocable == false || _unreleasedHolder != address(0));\n        periods = _periods;\n        unreleasedHolder = _unreleasedHolder;\n    }\n\n    /**\n    * @dev Calculates the amount that has already vested.\n    * @param token ERC20 token which is being vested\n    */\n    function vestedAmount(ERC20Basic token) public view returns (uint256) {\n        uint256 currentBalance = token.balanceOf(this);\n        uint256 totalBalance = currentBalance.add(released[token]);\n\n        if (now < cliff) {\n            return 0;\n        } else if (now >= start.add(duration * periods) || revoked[token]) {\n            return totalBalance;\n        } else {\n\n            uint256 periodTokens = totalBalance.div(periods);\n\n            uint256 periodsOver = now.sub(start).div(duration);\n\n            if (periodsOver >= periods) {\n                return totalBalance;\n            }\n\n            return periodTokens.mul(periodsOver);\n        }\n    }\n\n    /**\n * @notice Allows the owner to revoke the vesting. Tokens already vested\n * remain in the contract, the rest are returned to the owner.\n * @param token ERC20 token which is being vested\n */\n    function revoke(ERC20Basic token) public onlyOwner {\n        require(revocable);\n        require(!revoked[token]);\n\n        uint256 balance = token.balanceOf(this);\n\n        uint256 unreleased = releasableAmount(token);\n        uint256 refund = balance.sub(unreleased);\n\n        revoked[token] = true;\n\n        token.safeTransfer(unreleasedHolder, refund);\n\n        emit Revoked();\n    }\n}\ncontract ICUAllocation is Ownable {\n\n    using SafeERC20 for ERC20Basic;\n    using SafeMath for uint256;\n\n    uint256 public constant BOUNTY_TOKENS = 47000000e18;\n    uint256 public constant MAX_TREASURY_TOKENS = 2350000000e18;\n\n    uint256 public icoEndTime;\n\n    address[] public vestings;\n\n    address public bountyAddress;\n\n    address public treasuryAddress;\n\n    bool public isBountySent;\n\n    bool public isTeamSent;\n\n    event VestingCreated(\n        address _vesting,\n        address _beneficiary,\n        uint256 _start,\n        uint256 _cliff,\n        uint256 _duration,\n        uint256 _periods,\n        bool _revocable\n    );\n\n    event VestingRevoked(address _vesting);\n\n    constructor(address _bountyAddress, address _treasuryAddress) public {\n        require(_bountyAddress != address(0) && _treasuryAddress != address(0));\n        bountyAddress = _bountyAddress;\n        treasuryAddress = _treasuryAddress;\n    }\n\n    function setICOEndTime(uint256 _icoEndTime) public onlyOwner {\n        icoEndTime = _icoEndTime;\n    }\n\n    function allocateBounty(MintableTokenAllocator _allocator, ICUCrowdsale _crowdsale) public onlyOwner {\n        require(!isBountySent && icoEndTime < block.timestamp && _crowdsale.isSoftCapAchieved(0));\n\n        isBountySent = true;\n        _allocator.allocate(bountyAddress, BOUNTY_TOKENS);\n    }\n\n    function allocateTreasury(MintableTokenAllocator _allocator) public onlyOwner {\n        require(icoEndTime < block.timestamp, 'ICO is not ended');\n        require(isBountySent, 'Bounty is not sent');\n        require(isTeamSent, 'Team vesting is not created');\n        require(MAX_TREASURY_TOKENS >= _allocator.tokensAvailable(), 'Unsold tokens are not burned');\n\n        _allocator.allocate(treasuryAddress, _allocator.tokensAvailable());\n    }\n\n    function createVesting(\n        address _beneficiary,\n        uint256 _start,\n        uint256 _cliff,\n        uint256 _duration,\n        uint256 _periods,\n        bool _revocable,\n        address _unreleasedHolder,\n        MintableTokenAllocator _allocator,\n        uint256 _amount\n    ) public onlyOwner returns (PeriodicTokenVesting) {\n        require(icoEndTime > 0 && _amount > 0);\n\n        isTeamSent = true;\n\n        PeriodicTokenVesting vesting = new PeriodicTokenVesting(\n            _beneficiary, _start, _cliff, _duration, _periods, _revocable, _unreleasedHolder\n        );\n\n        vestings.push(vesting);\n\n        emit VestingCreated(vesting, _beneficiary, _start, _cliff, _duration, _periods, _revocable);\n\n        _allocator.allocate(address(vesting), _amount);\n\n        return vesting;\n    }\n\n    function revokeVesting(PeriodicTokenVesting _vesting, ERC20Basic token) public onlyOwner() {\n        _vesting.revoke(token);\n\n        emit VestingRevoked(_vesting);\n    }\n}",
  "abi": "[{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleAgent\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"updateWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_signer\",\"type\":\"address\"}],\"name\":\"removeSigner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateState\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allowWhitelisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"contributorBonuses\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"isSoftCapAchieved\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_crowdsaleAgent\",\"type\":\"address\"}],\"name\":\"setCrowdsaleAgent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"contributors\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"availableBonusAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"usdCollected\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"contributorsWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"addExternalContributor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"isHardCapAchieved\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"signers\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allowSigned\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pricingStrategy\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"softCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"verify\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allowAnonymous\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allocator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"externalContributionAgents\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxSaleSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimBonuses\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contributor\",\"type\":\"address\"},{\"name\":\"_wei\",\"type\":\"uint256\"}],\"name\":\"externalContribution\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contributor\",\"type\":\"address\"}],\"name\":\"removeExternalContributor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_signer\",\"type\":\"address\"}],\"name\":\"addSigner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contributionForwarder\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"contribute\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"delegatedRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_allocator\",\"type\":\"address\"},{\"name\":\"_contributionForwarder\",\"type\":\"address\"},{\"name\":\"_pricingStrategy\",\"type\":\"address\"},{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_endTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_holder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_wei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_contributor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_wei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_tokensExcludingBonus\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_bonus\",\"type\":\"uint256\"}],\"name\":\"Contribution\",\"type\":\"event\"}]",
  "bytecode": "60806040526b0797dfdb445d2d5bee0000006011556b017229cf9bff3962ef80000060125534801561003057600080fd5b5060405160a080611c0d833981016040908152815160208301519183015160608401516080909401516001805433600160a060020a0319918216178255600380548216600160a060020a03968716179055600480548216968616969096179095556005805490951693909216929092179092556007929092556008919091556009805461010060ff1990911690921761ff0019169190911762ff0000191690556002805460a060020a60ff021916905565022326ea4c00600d55643a35294400600e55611b0b806101026000396000f3006080604052600436106101f55763ffffffff60e060020a6000350416630b7d632081146102605780630b97bc86146102915780630c3f6acf146102b85780630d392cd9146102f15780630e316ab7146103175780631865c57d146103385780631d8557d71461034d57806328febac6146103625780632d0e830d1461038b5780633158c52b146103ac57806334103ee4146103c45780633cb5d100146103e5578063443c1ec4146103fd57806347a1a2d614610412578063518ab2a814610427578063590e1ae31461043c5780635ac030361461045157806366d0c6031461047257806372e7a69c14610493578063736c0d5b146104ab5780637570ac98146104cc57806378b99c24146104e157806379ba5097146104f65780638da5cb5b1461050b578063906a26e01461052057806396fc225614610535578063aa4bdf9514610562578063aa5dcecc14610577578063ace9325c1461058c578063b29418d5146105ad578063b3f05b97146105c2578063c24a0f8b146105d7578063d4ee1d90146105ec578063d936547e14610601578063d9d72c1914610622578063e13c6b3914610637578063ea5213e11461064e578063eb12d61e1461066f578063ec7d269514610690578063ef4445b8146106a5578063f2fde38b146106b9578063fb86a404146106da578063fbcebd02146106ef575b60095460ff168061020e575060095462010000900460ff165b151561021957600080fd5b60095462010000900460ff1615156102545760095460ff161561025457336000908152600a602052604090205460ff16151561025457600080fd5b61025e3334610710565b005b34801561026c57600080fd5b50610275610dda565b60408051600160a060020a039092168252519081900360200190f35b34801561029d57600080fd5b506102a6610de9565b60408051918252519081900360200190f35b3480156102c457600080fd5b506102cd610def565b604051808260068111156102dd57fe5b60ff16815260200191505060405180910390f35b3480156102fd57600080fd5b5061025e600160a060020a03600435166024351515610dff565b34801561032357600080fd5b5061025e600160a060020a0360043516610e41565b34801561034457600080fd5b506102cd610e79565b34801561035957600080fd5b5061025e610ebb565b34801561036e57600080fd5b50610377610f5b565b604080519115158252519081900360200190f35b34801561039757600080fd5b506102a6600160a060020a0360043516610f64565b3480156103b857600080fd5b50610377600435610f76565b3480156103d057600080fd5b5061025e600160a060020a0360043516610fa5565b3480156103f157600080fd5b50610275600435611000565b34801561040957600080fd5b506102a6611028565b34801561041e57600080fd5b506102a661102e565b34801561043357600080fd5b506102a6611034565b34801561044857600080fd5b5061025e61103a565b34801561045d57600080fd5b506102a6600160a060020a0360043516611043565b34801561047e57600080fd5b5061025e600160a060020a0360043516611055565b34801561049f57600080fd5b50610377600435611074565b3480156104b757600080fd5b50610377600160a060020a036004351661109a565b3480156104d857600080fd5b506103776110af565b3480156104ed57600080fd5b506102756110bd565b34801561050257600080fd5b5061025e6110cc565b34801561051757600080fd5b50610275611110565b34801561052c57600080fd5b506102a661111f565b34801561054157600080fd5b50610275600160a060020a036004351660ff60243516604435606435611125565b34801561056e57600080fd5b50610377611320565b34801561058357600080fd5b5061027561132f565b34801561059857600080fd5b50610377600160a060020a036004351661133e565b3480156105b957600080fd5b506102a6611353565b3480156105ce57600080fd5b50610377611359565b3480156105e357600080fd5b506102a6611369565b3480156105f857600080fd5b5061027561136f565b34801561060d57600080fd5b50610377600160a060020a036004351661137e565b34801561062e57600080fd5b5061025e611393565b61025e600160a060020a036004351660243561145e565b34801561065a57600080fd5b5061025e600160a060020a036004351661148a565b34801561067b57600080fd5b5061025e600160a060020a03600435166114c2565b34801561069c57600080fd5b506102756114fd565b61025e60ff6004351660243560443561150c565b3480156106c557600080fd5b5061025e600160a060020a0360043516611554565b3480156106e657600080fd5b506102a66115af565b3480156106fb57600080fd5b5061025e600160a060020a03600435166115b5565b600080600080600080600080610724610ebb565b600360025460a060020a900460ff16600681111561073e57fe5b1461074857600080fd5b600554604080517f9541bc41000000000000000000000000000000000000000000000000000000008152600481018c90529051600160a060020a0390921699508991639541bc41916024808201926020929091908290030181600087803b1580156107b257600080fd5b505af11580156107c6573d6000803e3d6000fd5b505050506040513d60208110156107dc57600080fd5b505196506107f96107f488600163ffffffff6115be16565b611074565b1561080357600080fd5b600360009054906101000a9004600160a060020a0316600160a060020a03166360659a926040518163ffffffff1660e060020a028152600401602060405180830381600087803b15801561085657600080fd5b505af115801561086a573d6000803e3d6000fd5b505050506040513d602081101561088057600080fd5b505160048054604080517f39b8ce980000000000000000000000000000000000000000000000000000000081529051939950600160a060020a03909116926339b8ce98928281019260209291908290030181600087803b1580156108e357600080fd5b505af11580156108f7573d6000803e3d6000fd5b505050506040513d602081101561090d57600080fd5b5051604080517f1aeca5150000000000000000000000000000000000000000000000000000000081529051919650600160a060020a038a1691631aeca515916004808201926020929091908290030181600087803b15801561096e57600080fd5b505af1158015610982573d6000803e3d6000fd5b505050506040513d602081101561099857600080fd5b505160008054604080517f5127ad4c000000000000000000000000000000000000000000000000000000008152600160a060020a038f81166004830152602482018c90526044820193909352606481018e9052608481018a90529051939750908b1692635127ad4c9260a480840193606093929083900390910190829087803b158015610a2457600080fd5b505af1158015610a38573d6000803e3d6000fd5b505050506040513d6060811015610a4e57600080fd5b5080516020820151604090920151909450909250905060008311610a7157600080fd5b600054610a84908463ffffffff6115d016565b6000908155600354604080517fb78b52df000000000000000000000000000000000000000000000000000000008152600160a060020a038e81166004830152602482018790529151919092169263b78b52df926044808201939182900301818387803b158015610af357600080fd5b505af1158015610b07573d6000803e3d6000fd5b50505050610b1487610f76565b15610ba0576000341115610b9b5760048054604080517fd264e05e0000000000000000000000000000000000000000000000000000000081529051600160a060020a039092169263d264e05e92303192808301926000929182900301818588803b158015610b8157600080fd5b505af1158015610b95573d6000803e3d6000fd5b50505050505b610c5b565b600160a060020a038a166000908152600f60205260409020541515610c1857601080546001810182556000919091527f1b6847dc741a1b0cd08d278845f9d819d87b734759afb55fe2de5cb82a9ae67201805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a038c161790555b600160a060020a038a166000908152600f6020526040902054610c41903463ffffffff6115d016565b600160a060020a038b166000908152600f60205260409020555b601354610c6e908863ffffffff6115d016565b60135560125460001015610ce5576012548111610c9357601280548290039055610c9e565b506012805460009091555b600160a060020a038a16600090815260146020526040902054610cc7908263ffffffff6115d016565b600160a060020a038b16600090815260146020526040902055610ce9565b5060005b600654604080517f84e84506000000000000000000000000000000000000000000000000000000008152600160a060020a038b81166004830152602482018890526044820186905260648201859052915191909216916384e8450691608480830192600092919082900301818387803b158015610d6557600080fd5b505af1158015610d79573d6000803e3d6000fd5b505060408051600160a060020a038e168152602081018d90528082018690526060810185905290517f460eb5f4fd2327fac159ebd2dfcf744a60eed1a83dd95367e1811f166396748e9350908190036080019150a150505050505050505050565b600654600160a060020a031681565b60075481565b60025460a060020a900460ff1681565b600154600160a060020a03163314610e1657600080fd5b600160a060020a03919091166000908152600a60205260409020805460ff1916911515919091179055565b600154600160a060020a03163314610e5857600080fd5b600160a060020a03166000908152600b60205260409020805460ff19169055565b600080610e846115e3565b90506004816006811115610e9457fe5b1415610eb357610ea46000610f76565b1515610eb35760069150610eb7565b8091505b5090565b600554604080517f1b3389050000000000000000000000000000000000000000000000000000000081528151600160a060020a0390931692631b338905926004808401939192918290030181600087803b158015610f1857600080fd5b505af1158015610f2c573d6000803e3d6000fd5b505050506040513d6040811015610f4257600080fd5b508051602090910151600855600755610f5961161c565b565b60095460ff1681565b60146020526000908152604090205481565b601354600090610f8c908363ffffffff6115d016565b600e5411610f9c57506001610fa0565b5060005b919050565b600154600160a060020a03163314610fbc57600080fd5b600160a060020a0381161515610fd157600080fd5b6006805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b601080548290811061100e57fe5b600091825260209091200154600160a060020a0316905081565b60125481565b60135481565b60005481565b610f5933611729565b600f6020526000908152604090205481565b600154600160a060020a0316331461106c57600080fd5b600080fd5b50565b60135460009061108a908363ffffffff6115d016565b600d5411610f9c57506001610fa0565b600b6020526000908152604090205460ff1681565b600954610100900460ff1681565b600554600160a060020a031681565b600254600160a060020a0316331415610f59576002546001805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a03909216919091179055565b600154600160a060020a031681565b600e5481565b604080516c01000000000000000000000000308102602080840191909152600160a060020a03881690910260348301528251602881840301815260489092019283905281516000938493606093909282918401908083835b6020831061119c5780518252601f19909201916020918201910161117d565b51815160209384036101000a6000190180199092169116179052604080519290940182900382208285018552601c8084527f19457468657265756d205369676e6564204d6573736167653a0a33320000000084840190815295519199509297506001965087955088949101925082918083835b6020831061122e5780518252601f19909201916020918201910161120f565b51815160209384036101000a600019018019909216911617905292019384525060408051808503815293820190819052835193945092839250908401908083835b6020831061128e5780518252601f19909201916020918201910161126f565b51815160209384036101000a60001901801990921691161790526040805192909401829003822060008084528383018087529190915260ff8e1683860152606083018d9052608083018c9052935160a08084019750919550601f1981019492819003909101925090865af115801561130a573d6000803e3d6000fd5b5050604051601f19015198975050505050505050565b60095462010000900460ff1681565b600354600160a060020a031681565b600c6020526000908152604090205460ff1681565b60115481565b60065460a060020a900460ff1681565b60085481565b600254600160a060020a031681565b600a6020526000908152604090205460ff1681565b600061139f6000610f76565b80156113b8575033600090815260146020526040812054115b15156113c357600080fd5b503360008181526014602052604080822080549083905560035482517fb78b52df00000000000000000000000000000000000000000000000000000000815260048101959095526024850182905291519093600160a060020a039092169263b78b52df926044808201939182900301818387803b15801561144357600080fd5b505af1158015611457573d6000803e3d6000fd5b5050505050565b336000908152600c602052604090205460ff16151561147c57600080fd5b6114868282610710565b5050565b600154600160a060020a031633146114a157600080fd5b600160a060020a03166000908152600c60205260409020805460ff19169055565b600154600160a060020a031633146114d957600080fd5b600160a060020a03166000908152600b60205260409020805460ff19166001179055565b600454600160a060020a031681565b600061151a33858585611125565b600160a060020a0381166000908152600b602052604090205490915060ff16151561154457600080fd5b61154e3334610710565b50505050565b600154600160a060020a0316331461156b57600080fd5b600160a060020a038116151561158057600080fd5b6002805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b600d5481565b61107181611729565b6000828211156115ca57fe5b50900390565b818101828110156115dd57fe5b92915050565b6000806115ee6118c5565b905060038160068111156115fe57fe5b1415610eb35761160e6000611074565b15610eb35760049150610eb7565b6000611626610e79565b905080600681111561163457fe5b60025460a060020a900460ff16600681111561164c57fe5b1461107157600654600160a060020a0316156116f157600680546040517fe7221785000000000000000000000000000000000000000000000000000000008152600160a060020a039091169163e7221785918491600490910190819083908111156116b357fe5b60ff168152602001915050600060405180830381600087803b1580156116d857600080fd5b505af11580156116ec573d6000803e3d6000fd5b505050505b6002805482919074ff0000000000000000000000000000000000000000191660a060020a83600681111561172157fe5b021790555050565b600080611734610ebb565b600854421161174257600080fd5b61174c6000610f76565b1561175657600080fd5b600654600160a060020a0316151561176d57600080fd5b600160a060020a0383166000908152600f60205260408120549250821161179357600080fd5b600160a060020a038084166000818152600f6020908152604080832083905560065481517f99ff024600000000000000000000000000000000000000000000000000000000815260048101959095526024850184905290519416936399ff024693604480820194918390030190829087803b15801561181157600080fd5b505af1158015611825573d6000803e3d6000fd5b505050506040513d602081101561183b57600080fd5b5051604051909150600160a060020a0384169083156108fc029084906000818181858888f19350505050158015611876573d6000803e3d6000fd5b5060408051600160a060020a03851681526020810184905280820183905290517f73f04af9dcc582a923ec15d3eea990fe34adabfff2879e28d44572e01a54abb69181900360600190a1505050565b60065460009060a060020a900460ff16156118e257506005611adc565b600360009054906101000a9004600160a060020a0316600160a060020a031663392e53cd6040518163ffffffff1660e060020a028152600401602060405180830381600087803b15801561193557600080fd5b505af1158015611949573d6000803e3d6000fd5b505050506040513d602081101561195f57600080fd5b5051151561196f57506001611adc565b60048054604080517f392e53cd0000000000000000000000000000000000000000000000000000000081529051600160a060020a039092169263392e53cd9282820192602092908290030181600087803b1580156119cc57600080fd5b505af11580156119e0573d6000803e3d6000fd5b505050506040513d60208110156119f657600080fd5b50511515611a0657506001611adc565b600560009054906101000a9004600160a060020a0316600160a060020a031663392e53cd6040518163ffffffff1660e060020a028152600401602060405180830381600087803b158015611a5957600080fd5b505af1158015611a6d573d6000803e3d6000fd5b505050506040513d6020811015611a8357600080fd5b50511515611a9357506001611adc565b600754421015611aa557506002611adc565b6007544210158015611ab957506008544211155b15611ac657506003611adc565b600854421115611ad857506004611adc565b5060005b905600a165627a7a72305820c0c62b08e19bfac8c8719d1e8a04fc69e9cf6afdc996332949398cb2a8d6143f0029000000000000000000000000d7c59c2b66ae330e41eafefd60c427c6ac2d36580000000000000000000000000cdf4173f67d205354a6325def8f4d4122495cf200000000000000000000000095fc99b18eff2ab26679e069437ef3b600fe8bd8000000000000000000000000000000000000000000000000000000005c012640000000000000000000000000000000000000000000000000000000005c0a60c0",
  "constructorArguments": "000000000000000000000000d7c59c2b66ae330e41eafefd60c427c6ac2d36580000000000000000000000000cdf4173f67d205354a6325def8f4d4122495cf200000000000000000000000095fc99b18eff2ab26679e069437ef3b600fe8bd8000000000000000000000000000000000000000000000000000000005c012640000000000000000000000000000000000000000000000000000000005c0a60c0"
}