{
  "address": "0x4a627b324189014fa757ed7cc730b180879232d7",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "MCH: Land Pool",
  "contractName": "MCHLandPool",
  "compilerVersion": "v0.5.4+commit.9549d8ff",
  "optimization": false,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2019-02-22\n*/\n\npragma solidity ^0.5.0;\n\n// File: contracts/lib/github.com/OpenZeppelin/openzeppelin-solidity-2.1.2/contracts/utils/ReentrancyGuard.sol\n\n/**\n * @title Helps contracts guard against reentrancy attacks.\n * @author Remco Bloemen <[email protected]π.com>, Eenae <[email protected]>\n * @dev If you mark a function `nonReentrant`, you should also\n * mark it `external`.\n */\ncontract ReentrancyGuard {\n    /// @dev counter to allow mutex lock with only one SSTORE operation\n    uint256 private _guardCounter;\n\n    constructor () internal {\n        // The counter starts at one to prevent changing it from zero to a non-zero\n        // value, which is a more expensive operation.\n        _guardCounter = 1;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _guardCounter += 1;\n        uint256 localCounter = _guardCounter;\n        _;\n        require(localCounter == _guardCounter);\n    }\n}\n\n// File: contracts/lib/github.com/OpenZeppelin/openzeppelin-solidity-2.1.2/contracts/math/SafeMath.sol\n\n/**\n * @title SafeMath\n * @dev Unsigned math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    /**\n    * @dev Multiplies two unsigned integers, reverts on overflow.\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n    * @dev Adds two unsigned integers, reverts on overflow.\n    */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n    * reverts when dividing by zero.\n    */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n\n// File: contracts/lib/github.com/OpenZeppelin/openzeppelin-solidity-2.1.2/contracts/access/Roles.sol\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    /**\n     * @dev give an account access to this role\n     */\n    function add(Role storage role, address account) internal {\n        require(account != address(0));\n        require(!has(role, account));\n\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev remove an account's access to this role\n     */\n    function remove(Role storage role, address account) internal {\n        require(account != address(0));\n        require(has(role, account));\n\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev check if an account has this role\n     * @return bool\n     */\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0));\n        return role.bearer[account];\n    }\n}\n\n// File: contracts/lib/github.com/OpenZeppelin/openzeppelin-solidity-2.1.2/contracts/access/roles/PauserRole.sol\n\ncontract PauserRole {\n    using Roles for Roles.Role;\n\n    event PauserAdded(address indexed account);\n    event PauserRemoved(address indexed account);\n\n    Roles.Role private _pausers;\n\n    constructor () internal {\n        _addPauser(msg.sender);\n    }\n\n    modifier onlyPauser() {\n        require(isPauser(msg.sender));\n        _;\n    }\n\n    function isPauser(address account) public view returns (bool) {\n        return _pausers.has(account);\n    }\n\n    function addPauser(address account) public onlyPauser {\n        _addPauser(account);\n    }\n\n    function renouncePauser() public {\n        _removePauser(msg.sender);\n    }\n\n    function _addPauser(address account) internal {\n        _pausers.add(account);\n        emit PauserAdded(account);\n    }\n\n    function _removePauser(address account) internal {\n        _pausers.remove(account);\n        emit PauserRemoved(account);\n    }\n}\n\n// File: contracts/lib/github.com/OpenZeppelin/openzeppelin-solidity-2.1.2/contracts/lifecycle/Pausable.sol\n\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is PauserRole {\n    event Paused(address account);\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    constructor () internal {\n        _paused = false;\n    }\n\n    /**\n     * @return true if the contract is paused, false otherwise.\n     */\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     */\n    modifier whenNotPaused() {\n        require(!_paused);\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     */\n    modifier whenPaused() {\n        require(_paused);\n        _;\n    }\n\n    /**\n     * @dev called by the owner to pause, triggers stopped state\n     */\n    function pause() public onlyPauser whenNotPaused {\n        _paused = true;\n        emit Paused(msg.sender);\n    }\n\n    /**\n     * @dev called by the owner to unpause, returns to normal state\n     */\n    function unpause() public onlyPauser whenPaused {\n        _paused = false;\n        emit Unpaused(msg.sender);\n    }\n}\n\n// File: contracts/lib/github.com/OpenZeppelin/openzeppelin-solidity-2.1.2/contracts/ownership/Ownable.sol\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @return the address of the owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner());\n        _;\n    }\n\n    /**\n     * @return true if `msg.sender` is the owner of the contract.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Allows the current owner to relinquish control of the contract.\n     * @notice Renouncing to ownership will leave the contract without an owner.\n     * It will not be possible to call the functions with the `onlyOwner`\n     * modifier anymore.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n// File: contracts/lib/github.com/OpenZeppelin/openzeppelin-solidity-2.1.2/contracts/introspection/IERC165.sol\n\n/**\n * @title IERC165\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\n */\ninterface IERC165 {\n    /**\n     * @notice Query if a contract implements an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @dev Interface identification is specified in ERC-165. This function\n     * uses less than 30,000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// File: contracts/lib/github.com/OpenZeppelin/openzeppelin-solidity-2.1.2/contracts/token/ERC721/IERC721.sol\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic interface\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract IERC721 is IERC165 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    function balanceOf(address owner) public view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) public view returns (address owner);\n\n    function approve(address to, uint256 tokenId) public;\n    function getApproved(uint256 tokenId) public view returns (address operator);\n\n    function setApprovalForAll(address operator, bool _approved) public;\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\n\n    function transferFrom(address from, address to, uint256 tokenId) public;\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\n}\n\n// File: contracts/lib/github.com/OpenZeppelin/openzeppelin-solidity-2.1.2/contracts/token/ERC721/IERC721Receiver.sol\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ncontract IERC721Receiver {\n    /**\n     * @notice Handle the receipt of an NFT\n     * @dev The ERC721 smart contract calls this function on the recipient\n     * after a `safeTransfer`. This function MUST return the function selector,\n     * otherwise the caller will revert the transaction. The selector to be\n     * returned can be obtained as `this.onERC721Received.selector`. This\n     * function MAY throw to revert and reject the transfer.\n     * Note: the ERC721 contract address is always the message sender.\n     * @param operator The address which called `safeTransferFrom` function\n     * @param from The address which previously owned the token\n     * @param tokenId The NFT identifier which is being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\n    public returns (bytes4);\n}\n\n// File: contracts/lib/github.com/OpenZeppelin/openzeppelin-solidity-2.1.2/contracts/utils/Address.sol\n\n/**\n * Utility library of inline functions on addresses\n */\nlibrary Address {\n    /**\n     * Returns whether the target address is a contract\n     * @dev This function will return false if invoked during the constructor of a contract,\n     * as the code is not actually created until after the constructor finishes.\n     * @param account address of the account to check\n     * @return whether the target address is a contract\n     */\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        // XXX Currently there is no better way to check if there is a contract in an address\n        // than to check the size of the code at that address.\n        // See https://ethereum.stackexchange.com/a/14016/36603\n        // for more details about how this works.\n        // TODO Check this again before the Serenity release, because all addresses will be\n        // contracts then.\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n}\n\n// File: contracts/lib/github.com/OpenZeppelin/openzeppelin-solidity-2.1.2/contracts/introspection/ERC165.sol\n\n/**\n * @title ERC165\n * @author Matt Condon (@shrugs)\n * @dev Implements ERC165 using a lookup table.\n */\ncontract ERC165 is IERC165 {\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n    /**\n     * 0x01ffc9a7 ===\n     *     bytes4(keccak256('supportsInterface(bytes4)'))\n     */\n\n    /**\n     * @dev a mapping of interface id to whether or not it's supported\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    /**\n     * @dev A contract implementing SupportsInterfaceWithLookup\n     * implement ERC165 itself\n     */\n    constructor () internal {\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev implement supportsInterface(bytes4) using a lookup table\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev internal method for registering an interface\n     */\n    function _registerInterface(bytes4 interfaceId) internal {\n        require(interfaceId != 0xffffffff);\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n\n// File: contracts/lib/github.com/OpenZeppelin/openzeppelin-solidity-2.1.2/contracts/token/ERC721/ERC721.sol\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract ERC721 is ERC165, IERC721 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n    // Mapping from token ID to owner\n    mapping (uint256 => address) private _tokenOwner;\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to number of owned token\n    mapping (address => uint256) private _ownedTokensCount;\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n    /*\n     * 0x80ac58cd ===\n     *     bytes4(keccak256('balanceOf(address)')) ^\n     *     bytes4(keccak256('ownerOf(uint256)')) ^\n     *     bytes4(keccak256('approve(address,uint256)')) ^\n     *     bytes4(keccak256('getApproved(uint256)')) ^\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) ^\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) ^\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) ^\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\n     */\n\n    constructor () public {\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721);\n    }\n\n    /**\n     * @dev Gets the balance of the specified address\n     * @param owner address to query the balance of\n     * @return uint256 representing the amount owned by the passed address\n     */\n    function balanceOf(address owner) public view returns (uint256) {\n        require(owner != address(0));\n        return _ownedTokensCount[owner];\n    }\n\n    /**\n     * @dev Gets the owner of the specified token ID\n     * @param tokenId uint256 ID of the token to query the owner of\n     * @return owner address currently marked as the owner of the given token ID\n     */\n    function ownerOf(uint256 tokenId) public view returns (address) {\n        address owner = _tokenOwner[tokenId];\n        require(owner != address(0));\n        return owner;\n    }\n\n    /**\n     * @dev Approves another address to transfer the given token ID\n     * The zero address indicates there is no approved address.\n     * There can only be one approved address per token at a given time.\n     * Can only be called by the token owner or an approved operator.\n     * @param to address to be approved for the given token ID\n     * @param tokenId uint256 ID of the token to be approved\n     */\n    function approve(address to, uint256 tokenId) public {\n        address owner = ownerOf(tokenId);\n        require(to != owner);\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\n\n        _tokenApprovals[tokenId] = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    /**\n     * @dev Gets the approved address for a token ID, or zero if no address set\n     * Reverts if the token ID does not exist.\n     * @param tokenId uint256 ID of the token to query the approval of\n     * @return address currently approved for the given token ID\n     */\n    function getApproved(uint256 tokenId) public view returns (address) {\n        require(_exists(tokenId));\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev Sets or unsets the approval of a given operator\n     * An operator is allowed to transfer all tokens of the sender on their behalf\n     * @param to operator address to set the approval\n     * @param approved representing the status of the approval to be set\n     */\n    function setApprovalForAll(address to, bool approved) public {\n        require(to != msg.sender);\n        _operatorApprovals[msg.sender][to] = approved;\n        emit ApprovalForAll(msg.sender, to, approved);\n    }\n\n    /**\n     * @dev Tells whether an operator is approved by a given owner\n     * @param owner owner address which you want to query the approval of\n     * @param operator operator address which you want to query the approval of\n     * @return bool whether the given operator is approved by the given owner\n     */\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev Transfers the ownership of a given token ID to another address\n     * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\n     * Requires the msg sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n    */\n    function transferFrom(address from, address to, uint256 tokenId) public {\n        require(_isApprovedOrOwner(msg.sender, tokenId));\n\n        _transferFrom(from, to, tokenId);\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement `onERC721Received`,\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     *\n     * Requires the msg sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n    */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement `onERC721Received`,\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * Requires the msg sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes data to send along with a safe transfer check\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\n        transferFrom(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data));\n    }\n\n    /**\n     * @dev Returns whether the specified token exists\n     * @param tokenId uint256 ID of the token to query the existence of\n     * @return whether the token exists\n     */\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        address owner = _tokenOwner[tokenId];\n        return owner != address(0);\n    }\n\n    /**\n     * @dev Returns whether the given spender can transfer a given token ID\n     * @param spender address of the spender to query\n     * @param tokenId uint256 ID of the token to be transferred\n     * @return bool whether the msg.sender is approved for the given token ID,\n     *    is an operator of the owner, or is the owner of the token\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n        address owner = ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Internal function to mint a new token\n     * Reverts if the given token ID already exists\n     * @param to The address that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     */\n    function _mint(address to, uint256 tokenId) internal {\n        require(to != address(0));\n        require(!_exists(tokenId));\n\n        _tokenOwner[tokenId] = to;\n        _ownedTokensCount[to] = _ownedTokensCount[to].add(1);\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to burn a specific token\n     * Reverts if the token does not exist\n     * Deprecated, use _burn(uint256) instead.\n     * @param owner owner of the token to burn\n     * @param tokenId uint256 ID of the token being burned\n     */\n    function _burn(address owner, uint256 tokenId) internal {\n        require(ownerOf(tokenId) == owner);\n\n        _clearApproval(tokenId);\n\n        _ownedTokensCount[owner] = _ownedTokensCount[owner].sub(1);\n        _tokenOwner[tokenId] = address(0);\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Internal function to burn a specific token\n     * Reverts if the token does not exist\n     * @param tokenId uint256 ID of the token being burned\n     */\n    function _burn(uint256 tokenId) internal {\n        _burn(ownerOf(tokenId), tokenId);\n    }\n\n    /**\n     * @dev Internal function to transfer ownership of a given token ID to another address.\n     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n    */\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\n        require(ownerOf(tokenId) == from);\n        require(to != address(0));\n\n        _clearApproval(tokenId);\n\n        _ownedTokensCount[from] = _ownedTokensCount[from].sub(1);\n        _ownedTokensCount[to] = _ownedTokensCount[to].add(1);\n\n        _tokenOwner[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke `onERC721Received` on a target address\n     * The call is not executed if the target address is not a contract\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        internal returns (bool)\n    {\n        if (!to.isContract()) {\n            return true;\n        }\n\n        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);\n        return (retval == _ERC721_RECEIVED);\n    }\n\n    /**\n     * @dev Private function to clear current approval of a given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function _clearApproval(uint256 tokenId) private {\n        if (_tokenApprovals[tokenId] != address(0)) {\n            _tokenApprovals[tokenId] = address(0);\n        }\n    }\n}\n\n// File: contracts/lib/github.com/OpenZeppelin/openzeppelin-solidity-2.1.2/contracts/access/roles/MinterRole.sol\n\ncontract MinterRole {\n    using Roles for Roles.Role;\n\n    event MinterAdded(address indexed account);\n    event MinterRemoved(address indexed account);\n\n    Roles.Role private _minters;\n\n    constructor () internal {\n        _addMinter(msg.sender);\n    }\n\n    modifier onlyMinter() {\n        require(isMinter(msg.sender));\n        _;\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return _minters.has(account);\n    }\n\n    function addMinter(address account) public onlyMinter {\n        _addMinter(account);\n    }\n\n    function renounceMinter() public {\n        _removeMinter(msg.sender);\n    }\n\n    function _addMinter(address account) internal {\n        _minters.add(account);\n        emit MinterAdded(account);\n    }\n\n    function _removeMinter(address account) internal {\n        _minters.remove(account);\n        emit MinterRemoved(account);\n    }\n}\n\n// File: contracts/lib/github.com/OpenZeppelin/openzeppelin-solidity-2.1.2/contracts/token/ERC721/ERC721Mintable.sol\n\n/**\n * @title ERC721Mintable\n * @dev ERC721 minting logic\n */\ncontract ERC721Mintable is ERC721, MinterRole {\n    /**\n     * @dev Function to mint tokens\n     * @param to The address that will receive the minted tokens.\n     * @param tokenId The token id to mint.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function mint(address to, uint256 tokenId) public onlyMinter returns (bool) {\n        _mint(to, tokenId);\n        return true;\n    }\n}\n\n// File: contracts/lib/github.com/OpenZeppelin/openzeppelin-solidity-2.1.2/contracts/token/ERC721/ERC721Pausable.sol\n\n/**\n * @title ERC721 Non-Fungible Pausable token\n * @dev ERC721 modified with pausable transfers.\n **/\ncontract ERC721Pausable is ERC721, Pausable {\n    function approve(address to, uint256 tokenId) public whenNotPaused {\n        super.approve(to, tokenId);\n    }\n\n    function setApprovalForAll(address to, bool approved) public whenNotPaused {\n        super.setApprovalForAll(to, approved);\n    }\n\n    function transferFrom(address from, address to, uint256 tokenId) public whenNotPaused {\n        super.transferFrom(from, to, tokenId);\n    }\n}\n\n// File: contracts/lib/github.com/OpenZeppelin/openzeppelin-solidity-2.1.2/contracts/token/ERC721/IERC721Enumerable.sol\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract IERC721Enumerable is IERC721 {\n    function totalSupply() public view returns (uint256);\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256 tokenId);\n\n    function tokenByIndex(uint256 index) public view returns (uint256);\n}\n\n// File: contracts/lib/github.com/OpenZeppelin/openzeppelin-solidity-2.1.2/contracts/token/ERC721/ERC721Enumerable.sol\n\n/**\n * @title ERC-721 Non-Fungible Token with optional enumeration extension logic\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract ERC721Enumerable is ERC165, ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => uint256[]) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n    /**\n     * 0x780e9d63 ===\n     *     bytes4(keccak256('totalSupply()')) ^\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^\n     *     bytes4(keccak256('tokenByIndex(uint256)'))\n     */\n\n    /**\n     * @dev Constructor function\n     */\n    constructor () public {\n        // register the supported interface to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\n    }\n\n    /**\n     * @dev Gets the token ID at a given index of the tokens list of the requested owner\n     * @param owner address owning the tokens list to be accessed\n     * @param index uint256 representing the index to be accessed of the requested tokens list\n     * @return uint256 token ID at the given index of the tokens list owned by the requested address\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {\n        require(index < balanceOf(owner));\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev Gets the total amount of tokens stored by the contract\n     * @return uint256 representing the total amount of tokens\n     */\n    function totalSupply() public view returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev Gets the token ID at a given index of all the tokens in this contract\n     * Reverts if the index is greater or equal to the total number of tokens\n     * @param index uint256 representing the index to be accessed of the tokens list\n     * @return uint256 token ID at the given index of the tokens list\n     */\n    function tokenByIndex(uint256 index) public view returns (uint256) {\n        require(index < totalSupply());\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Internal function to transfer ownership of a given token ID to another address.\n     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n    */\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\n        super._transferFrom(from, to, tokenId);\n\n        _removeTokenFromOwnerEnumeration(from, tokenId);\n\n        _addTokenToOwnerEnumeration(to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to mint a new token\n     * Reverts if the given token ID already exists\n     * @param to address the beneficiary that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     */\n    function _mint(address to, uint256 tokenId) internal {\n        super._mint(to, tokenId);\n\n        _addTokenToOwnerEnumeration(to, tokenId);\n\n        _addTokenToAllTokensEnumeration(tokenId);\n    }\n\n    /**\n     * @dev Internal function to burn a specific token\n     * Reverts if the token does not exist\n     * Deprecated, use _burn(uint256) instead\n     * @param owner owner of the token to burn\n     * @param tokenId uint256 ID of the token being burned\n     */\n    function _burn(address owner, uint256 tokenId) internal {\n        super._burn(owner, tokenId);\n\n        _removeTokenFromOwnerEnumeration(owner, tokenId);\n        // Since tokenId will be deleted, we can clear its slot in _ownedTokensIndex to trigger a gas refund\n        _ownedTokensIndex[tokenId] = 0;\n\n        _removeTokenFromAllTokensEnumeration(tokenId);\n    }\n\n    /**\n     * @dev Gets the list of token IDs of the requested owner\n     * @param owner address owning the tokens\n     * @return uint256[] List of token IDs owned by the requested address\n     */\n    function _tokensOfOwner(address owner) internal view returns (uint256[] storage) {\n        return _ownedTokens[owner];\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        _ownedTokensIndex[tokenId] = _ownedTokens[to].length;\n        _ownedTokens[to].push(tokenId);\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the _ownedTokensIndex mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _ownedTokens[from].length.sub(1);\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        _ownedTokens[from].length--;\n\n        // Note that _ownedTokensIndex[tokenId] hasn't been cleared: it still points to the old slot (now occcupied by\n        // lasTokenId, or just over the end of the array if the token was the last one).\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length.sub(1);\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        _allTokens.length--;\n        _allTokensIndex[tokenId] = 0;\n    }\n}\n\n// File: contracts/lib/github.com/OpenZeppelin/openzeppelin-solidity-2.1.2/contracts/token/ERC721/IERC721Metadata.sol\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract IERC721Metadata is IERC721 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\n// File: contracts/lib/github.com/OpenZeppelin/openzeppelin-solidity-2.1.2/contracts/token/ERC721/ERC721Metadata.sol\n\ncontract ERC721Metadata is ERC165, ERC721, IERC721Metadata {\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Optional mapping for token URIs\n    mapping(uint256 => string) private _tokenURIs;\n\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n    /**\n     * 0x5b5e139f ===\n     *     bytes4(keccak256('name()')) ^\n     *     bytes4(keccak256('symbol()')) ^\n     *     bytes4(keccak256('tokenURI(uint256)'))\n     */\n\n    /**\n     * @dev Constructor function\n     */\n    constructor (string memory name, string memory symbol) public {\n        _name = name;\n        _symbol = symbol;\n\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n    }\n\n    /**\n     * @dev Gets the token name\n     * @return string representing the token name\n     */\n    function name() external view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Gets the token symbol\n     * @return string representing the token symbol\n     */\n    function symbol() external view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns an URI for a given token ID\n     * Throws if the token ID does not exist. May return an empty string.\n     * @param tokenId uint256 ID of the token to query\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory) {\n        require(_exists(tokenId));\n        return _tokenURIs[tokenId];\n    }\n\n    /**\n     * @dev Internal function to set the token URI for a given token\n     * Reverts if the token ID does not exist\n     * @param tokenId uint256 ID of the token to set its URI\n     * @param uri string URI to assign\n     */\n    function _setTokenURI(uint256 tokenId, string memory uri) internal {\n        require(_exists(tokenId));\n        _tokenURIs[tokenId] = uri;\n    }\n\n    /**\n     * @dev Internal function to burn a specific token\n     * Reverts if the token does not exist\n     * Deprecated, use _burn(uint256) instead\n     * @param owner owner of the token to burn\n     * @param tokenId uint256 ID of the token being burned by the msg.sender\n     */\n    function _burn(address owner, uint256 tokenId) internal {\n        super._burn(owner, tokenId);\n\n        // Clear metadata (if any)\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n}\n\n// File: contracts/lib/github.com/OpenZeppelin/openzeppelin-solidity-2.1.2/contracts/token/ERC721/ERC721FUll.sol\n\n/**\n * @title Full ERC721 Token\n * This implementation includes all the required and some optional functionality of the ERC721 standard\n * Moreover, it includes approve all functionality using operator terminology\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract ERC721Full is ERC721, ERC721Enumerable, ERC721Metadata {\n    constructor (string memory name, string memory symbol) public ERC721Metadata(name, symbol) {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n}\n\n// File: contracts/LandSectorAsset.sol\n\n/* solhint-disable indent*/\npragma solidity 0.5.4;\n\n\n\n\n\ncontract LandSectorAsset is ERC721Full, ERC721Mintable, ERC721Pausable {\n\n\n  uint256 public constant SHARE_RATE_DECIMAL = 10**18;\n\n  uint16 public constant LEGENDARY_RARITY = 5;\n  uint16 public constant EPIC_RARITY = 4;\n  uint16 public constant RARE_RARITY = 3;\n  uint16 public constant UNCOMMON_RARITY = 2;\n  uint16 public constant COMMON_RARITY = 1;\n\n  uint16 public constant NO_LAND = 0;\n\n  string public tokenURIPrefix = \"https://www.mycryptoheroes.net/metadata/land/\";\n\n  mapping(uint16 => uint256) private landTypeToTotalVolume;\n  mapping(uint16 => uint256) private landTypeToSectorSupplyLimit;\n  mapping(uint16 => mapping(uint16 => uint256)) private landTypeAndRarityToSectorSupply;\n  mapping(uint16 => uint256[]) private landTypeToLandSectorList;\n  mapping(uint16 => uint256) private landTypeToLandSectorIndex;\n  mapping(uint16 => mapping(uint16 => uint256)) private landTypeAndRarityToLandSectorCount;\n  mapping(uint16 => uint256) private rarityToSectorVolume;\n\n  event MintEvent(\n    address indexed assetOwner,\n    uint256 tokenId,\n    uint256 at,\n    bytes32 indexed eventHash\n  );\n\n  constructor() public ERC721Full(\"MyCryptoHeroes:Land\", \"MCHL\") {\n    rarityToSectorVolume[5] = 100;\n    rarityToSectorVolume[4] = 20;\n    rarityToSectorVolume[3] = 5;\n    rarityToSectorVolume[2] = 2;\n    rarityToSectorVolume[1] = 1;\n    landTypeToTotalVolume[NO_LAND] = 0;\n  }\n\n  function setSupplyAndSector(\n    uint16 _landType,\n    uint256 _totalVolume,\n    uint256 _sectorSupplyLimit,\n    uint256 legendarySupply,\n    uint256 epicSupply,\n    uint256 rareSupply,\n    uint256 uncommonSupply,\n    uint256 commonSupply\n  ) external onlyMinter {\n    require(_landType != 0, \"landType 0 is noland\");\n    require(_totalVolume != 0, \"totalVolume must not be 0\");\n    require(getMintedSectorCount(_landType) == 0, \"This LandType already exists\");\n    require(\n      legendarySupply.mul(rarityToSectorVolume[LEGENDARY_RARITY])\n      .add(epicSupply.mul(rarityToSectorVolume[EPIC_RARITY]))\n      .add(rareSupply.mul(rarityToSectorVolume[RARE_RARITY]))\n      .add(uncommonSupply.mul(rarityToSectorVolume[UNCOMMON_RARITY]))\n      .add(commonSupply.mul(rarityToSectorVolume[COMMON_RARITY]))\n      == _totalVolume\n    );\n    require(\n      legendarySupply\n      .add(epicSupply)\n      .add(rareSupply)\n      .add(uncommonSupply)\n      .add(commonSupply)\n      == _sectorSupplyLimit\n    );\n    landTypeToTotalVolume[_landType] = _totalVolume;\n    landTypeToSectorSupplyLimit[_landType] = _sectorSupplyLimit;\n    landTypeAndRarityToSectorSupply[_landType][LEGENDARY_RARITY] = legendarySupply;\n    landTypeAndRarityToSectorSupply[_landType][EPIC_RARITY] = epicSupply;\n    landTypeAndRarityToSectorSupply[_landType][RARE_RARITY] = rareSupply;\n    landTypeAndRarityToSectorSupply[_landType][UNCOMMON_RARITY] = uncommonSupply;\n    landTypeAndRarityToSectorSupply[_landType][COMMON_RARITY] = commonSupply;\n  }\n\n  function setTokenURIPrefix(string calldata _tokenURIPrefix) external onlyMinter {\n    tokenURIPrefix = _tokenURIPrefix;\n  }\n\n  function isAlreadyMinted(uint256 _tokenId) public view returns (bool) {\n    return _exists(_tokenId);\n  }\n\n  function isValidLandSector(uint256 _tokenId) public view returns (bool) {\n    uint16 rarity = getRarity(_tokenId);\n    if (!(rarityToSectorVolume[rarity] > 0)) {\n      return false;\n    }\n    uint16 landType = getLandType(_tokenId);\n    if (!(landTypeToTotalVolume[landType] > 0)) {\n      return false;\n    }\n    uint256 serial = _tokenId % 10000;\n    if (serial > landTypeAndRarityToSectorSupply[landType][rarity]) {\n      return false;\n    }\n    return true;\n  }\n\n  function getTotalVolume(uint16 _landType) public view returns (uint256) {\n    return landTypeToTotalVolume[_landType];\n  }\n\n  function getSectorSupplyLimit(uint16 _landType) public view returns (uint256) {\n    return landTypeToSectorSupplyLimit[_landType];\n  }\n\n  function getLandType(uint256 _landSector) public view returns (uint16) {\n    uint16 _landType = uint16((_landSector.div(10000)) % 1000);\n    return _landType;\n  }\n\n  function getRarity(uint256 _landSector) public view returns (uint16) {\n    return uint16(_landSector.div(10**7));\n  }\n\n  function getMintedSectorCount(uint16 _landType) public view returns (uint256) {\n    return landTypeToLandSectorIndex[_landType];\n  }\n\n  function getMintedSectorCountByRarity(uint16 _landType, uint16 _rarity) public view returns (uint256) {\n    return landTypeAndRarityToLandSectorCount[_landType][_rarity];\n  }\n\n  function getSectorSupplyByRarity(uint16 _landType, uint16 _rarity) public view returns (uint256) {\n    return landTypeAndRarityToSectorSupply[_landType][_rarity];\n  }\n\n  function getMintedSectorList(uint16 _landType) public view returns (uint256[] memory) {\n    return landTypeToLandSectorList[_landType];\n  }\n\n  function getSectorVolumeByRarity(uint16 _rarity) public view returns (uint256) {\n    return rarityToSectorVolume[_rarity];\n  }\n\n  function getShareRateWithDecimal(uint256 _landSector) public view returns (uint256, uint256) {\n    return (\n      getSectorVolumeByRarity(getRarity(_landSector))\n        .mul(SHARE_RATE_DECIMAL)\n        .div(getTotalVolume(getLandType(_landSector))),\n      SHARE_RATE_DECIMAL\n    );\n  }\n\n  function mintLandSector(address _owner, uint256 _landSector, bytes32 _eventHash) public onlyMinter {\n    require(!isAlreadyMinted(_landSector));\n    require(isValidLandSector(_landSector));\n    uint16 _landType = getLandType(_landSector);\n    require(landTypeToLandSectorIndex[_landType] < landTypeToSectorSupplyLimit[_landType]);\n    uint16 rarity = getRarity(_landSector);\n    require(landTypeAndRarityToLandSectorCount[_landType][rarity] < landTypeAndRarityToSectorSupply[_landType][rarity], \"supply over\");\n    _mint(_owner, _landSector);\n    landTypeToLandSectorList[_landType].push(_landSector);\n    landTypeToLandSectorIndex[_landType]++;\n    landTypeAndRarityToLandSectorCount[_landType][rarity]++;\n\n    emit MintEvent(\n      _owner,\n      _landSector,\n      block.timestamp,\n      _eventHash\n    );\n  }\n\n  function tokenURI(uint256 tokenId) public view returns (string memory) {\n    bytes32 tokenIdBytes;\n    if (tokenId == 0) {\n      tokenIdBytes = \"0\";\n    } else {\n      uint256 value = tokenId;\n      while (value > 0) {\n        tokenIdBytes = bytes32(uint256(tokenIdBytes) / (2 ** 8));\n        tokenIdBytes |= bytes32(((value % 10) + 48) * 2 ** (8 * 31));\n        value /= 10;\n      }\n    }\n\n    bytes memory prefixBytes = bytes(tokenURIPrefix);\n    bytes memory tokenURIBytes = new bytes(prefixBytes.length + tokenIdBytes.length);\n\n    uint8 i;\n    uint8 index = 0;\n\n    for (i = 0; i < prefixBytes.length; i++) {\n      tokenURIBytes[index] = prefixBytes[i];\n      index++;\n    }\n\n    for (i = 0; i < tokenIdBytes.length; i++) {\n      tokenURIBytes[index] = tokenIdBytes[i];\n      index++;\n    }\n\n    return string(tokenURIBytes);\n  }\n}\n/* solhint-enable indent*/\n\n// File: contracts/MCHLandPool.sol\n\n/* solhint-disable indent*/\npragma solidity 0.5.4;\n\n\n\n\n\n\n\ncontract MCHLandPool is Ownable, Pausable, ReentrancyGuard {\n  using SafeMath for uint256;\n\n\n  LandSectorAsset public landSectorAsset;\n\n  mapping(uint16 => uint256) private landTypeToTotalAmount;\n  mapping(uint256 => uint256) private landSectorToWithdrawnAmount;\n  mapping(address => bool) private allowedAddresses;\n\n  event EthAddedToPool(\n    uint16 indexed landType,\n    address txSender,\n    address indexed purchaseBy,\n    uint256 value,\n    uint256 at\n  );\n\n  event WithdrawEther(\n    uint256 indexed landSector,\n    address indexed lord,\n    uint256 value,\n    uint256 at\n  );\n\n  event AllowedAddressSet(\n    address allowedAddress,\n    bool allowedStatus\n  );\n\n  constructor(address _landSectorAssetAddress) public {\n    landSectorAsset = LandSectorAsset(_landSectorAssetAddress);\n  }\n\n  function setLandSectorAssetAddress(address _landSectorAssetAddress) external onlyOwner() {\n    landSectorAsset = LandSectorAsset(_landSectorAssetAddress);\n  }\n\n  function setAllowedAddress(address _address, bool desired) external onlyOwner() {\n    allowedAddresses[_address] = desired;\n    emit AllowedAddressSet(\n      _address,\n      desired\n    );\n  }\n\n  function addEthToLandPool(uint16 _landType, address _purchaseBy) external payable whenNotPaused() nonReentrant() {\n    require(landSectorAsset.getTotalVolume(_landType) > 0);\n    require(allowedAddresses[msg.sender]);\n    landTypeToTotalAmount[_landType] += msg.value;\n\n    emit EthAddedToPool(\n      _landType,\n      msg.sender,\n      _purchaseBy,\n      msg.value,\n      block.timestamp\n    );\n  }\n\n  function withdrawMyAllRewards() external whenNotPaused() nonReentrant() {\n    require(getWithdrawableBalance(msg.sender) > 0);\n\n    uint256 withdrawValue;\n    uint256 balance = landSectorAsset.balanceOf(msg.sender);\n    \n    for (uint256 i=balance; i > 0; i--) {\n      uint256 landSector = landSectorAsset.tokenOfOwnerByIndex(msg.sender, i-1);\n      uint256 tmpAmount = getLandSectorWithdrawableBalance(landSector);\n      withdrawValue += tmpAmount;\n      landSectorToWithdrawnAmount[landSector] += tmpAmount;\n\n      emit WithdrawEther(\n        landSector,\n        msg.sender,\n        tmpAmount,\n        block.timestamp\n      );\n    }\n    msg.sender.transfer(withdrawValue);\n  }\n\n  function withdrawMyReward(uint256 _landSector) external whenNotPaused() nonReentrant() {\n    require(landSectorAsset.ownerOf(_landSector) == msg.sender);\n    uint256 withdrawableAmount = getLandSectorWithdrawableBalance(_landSector);\n    require(withdrawableAmount > 0);\n\n    landSectorToWithdrawnAmount[_landSector] += withdrawableAmount;\n    msg.sender.transfer(withdrawableAmount);\n\n    emit WithdrawEther(\n      _landSector,\n      msg.sender,\n      withdrawableAmount,\n      block.timestamp\n    );\n  }\n\n  function getAllowedAddress(address _address) public view returns (bool) {\n    return allowedAddresses[_address];\n  }\n\n  function getTotalEthBackAmountPerLandType(uint16 _landType) public view returns (uint256) {\n    return landTypeToTotalAmount[_landType];\n  }\n\n  function getLandSectorWithdrawnAmount(uint256 _landSector) public view returns (uint256) {\n    return landSectorToWithdrawnAmount[_landSector];\n  }\n\n  function getLandSectorWithdrawableBalance(uint256 _landSector) public view returns (uint256) {\n    require(landSectorAsset.isValidLandSector(_landSector));\n    uint16 _landType = landSectorAsset.getLandType(_landSector);\n    (uint256 shareRate, uint256 decimal) = landSectorAsset.getShareRateWithDecimal(_landSector);\n    uint256 maxAmount = landTypeToTotalAmount[_landType]\n      .mul(shareRate)\n      .div(decimal);\n    return maxAmount.sub(landSectorToWithdrawnAmount[_landSector]);\n  }\n\n  function getWithdrawableBalance(address _lordAddress) public view returns (uint256) {\n    uint256 balance = landSectorAsset.balanceOf(_lordAddress);\n    uint256 withdrawableAmount;\n\n    for (uint256 i=balance; i > 0; i--) {\n      uint256 landSector = landSectorAsset.tokenOfOwnerByIndex(_lordAddress, i-1);\n      withdrawableAmount += getLandSectorWithdrawableBalance(landSector);\n    }\n\n    return withdrawableAmount;\n  }\n}\n/* solhint-enable indent*/",
  "abi": "[{\"constant\":true,\"inputs\":[{\"name\":\"_landSector\",\"type\":\"uint256\"}],\"name\":\"getLandSectorWithdrawableBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_landSectorAssetAddress\",\"type\":\"address\"}],\"name\":\"setLandSectorAssetAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_landSector\",\"type\":\"uint256\"}],\"name\":\"withdrawMyReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawMyAllRewards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_lordAddress\",\"type\":\"address\"}],\"name\":\"getWithdrawableBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_landSector\",\"type\":\"uint256\"}],\"name\":\"getLandSectorWithdrawnAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getAllowedAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_landType\",\"type\":\"uint16\"}],\"name\":\"getTotalEthBackAmountPerLandType\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"landSectorAsset\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_landType\",\"type\":\"uint16\"},{\"name\":\"_purchaseBy\",\"type\":\"address\"}],\"name\":\"addEthToLandPool\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"desired\",\"type\":\"bool\"}],\"name\":\"setAllowedAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_landSectorAssetAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"landType\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"txSender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"purchaseBy\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"at\",\"type\":\"uint256\"}],\"name\":\"EthAddedToPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"landSector\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"lord\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"at\",\"type\":\"uint256\"}],\"name\":\"WithdrawEther\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"allowedAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"allowedStatus\",\"type\":\"bool\"}],\"name\":\"AllowedAddressSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]",
  "bytecode": "60806040523480156200001157600080fd5b506040516020806200207b833981018060405260208110156200003357600080fd5b8101908080519060200190929190505050336000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16600073ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a36200011a3362000185640100000000026401000000009004565b6000600260006101000a81548160ff021916908315150217905550600160038190555080600460006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505062000347565b620001a9816001620001ef6401000000000262001c48179091906401000000009004565b8073ffffffffffffffffffffffffffffffffffffffff167f6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f860405160405180910390a250565b600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16141515156200022c57600080fd5b620002478282620002b2640100000000026401000000009004565b1515156200025457600080fd5b60018260000160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff0219169083151502179055505050565b60008073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff1614151515620002f057600080fd5b8260000160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff16905092915050565b611d2480620003576000396000f3fe608060405260043610610147576000357c010000000000000000000000000000000000000000000000000000000090048063843592d3116100c8578063ced7ed2c1161008c578063ced7ed2c146104bd578063d239da8414610526578063dba8f3f614610579578063e274e18e146105d0578063f2fde38b14610622578063fae369861461067357610147565b8063843592d31461036c5780638456cb59146103d157806387bc742b146103e85780638da5cb5b146104375780638f32d59b1461048e57610147565b80635c975abb1161010f5780635c975abb146102a75780636ef8d66d146102d6578063715018a6146102ed578063760b8cc21461030457806382dc1ec41461031b57610147565b806321bcf3c01461014c5780632d09986f1461019b5780633f4ba83a146101ec57806346fbf68e1461020357806356990e651461026c575b600080fd5b34801561015857600080fd5b506101856004803603602081101561016f57600080fd5b81019080803590602001909291905050506106d0565b6040518082815260200191505060405180910390f35b3480156101a757600080fd5b506101ea600480360360208110156101be57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506109c4565b005b3480156101f857600080fd5b50610201610a1b565b005b34801561020f57600080fd5b506102526004803603602081101561022657600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610aca565b604051808215151515815260200191505060405180910390f35b34801561027857600080fd5b506102a56004803603602081101561028f57600080fd5b8101908080359060200190929190505050610ae7565b005b3480156102b357600080fd5b506102bc610d0e565b604051808215151515815260200191505060405180910390f35b3480156102e257600080fd5b506102eb610d25565b005b3480156102f957600080fd5b50610302610d30565b005b34801561031057600080fd5b50610319610e02565b005b34801561032757600080fd5b5061036a6004803603602081101561033e57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611153565b005b34801561037857600080fd5b506103bb6004803603602081101561038f57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611173565b6040518082815260200191505060405180910390f35b3480156103dd57600080fd5b506103e66113aa565b005b3480156103f457600080fd5b506104216004803603602081101561040b57600080fd5b810190808035906020019092919050505061145a565b6040518082815260200191505060405180910390f35b34801561044357600080fd5b5061044c611477565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b34801561049a57600080fd5b506104a36114a0565b604051808215151515815260200191505060405180910390f35b3480156104c957600080fd5b5061050c600480360360208110156104e057600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506114f7565b604051808215151515815260200191505060405180910390f35b34801561053257600080fd5b506105636004803603602081101561054957600080fd5b81019080803561ffff16906020019092919050505061154d565b6040518082815260200191505060405180910390f35b34801561058557600080fd5b5061058e611572565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b610620600480360360408110156105e657600080fd5b81019080803561ffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611598565b005b34801561062e57600080fd5b506106716004803603602081101561064557600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506117d1565b005b34801561067f57600080fd5b506106ce6004803603604081101561069657600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291908035151590602001909291905050506117f0565b005b6000600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16639989948f836040518263ffffffff167c01000000000000000000000000000000000000000000000000000000000281526004018082815260200191505060206040518083038186803b15801561076157600080fd5b505afa158015610775573d6000803e3d6000fd5b505050506040513d602081101561078b57600080fd5b810190808051906020019092919050505015156107a757600080fd5b6000600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663410cb3f8846040518263ffffffff167c01000000000000000000000000000000000000000000000000000000000281526004018082815260200191505060206040518083038186803b15801561083857600080fd5b505afa15801561084c573d6000803e3d6000fd5b505050506040513d602081101561086257600080fd5b81019080805190602001909291905050509050600080600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16631ee2ec93866040518263ffffffff167c010000000000000000000000000000000000000000000000000000000002815260040180828152602001915050604080518083038186803b15801561090657600080fd5b505afa15801561091a573d6000803e3d6000fd5b505050506040513d604081101561093057600080fd5b8101908080519060200190929190805190602001909291905050509150915060006109918261098385600560008961ffff1661ffff168152602001908152602001600020546118cd90919063ffffffff16565b61190b90919063ffffffff16565b90506109b960066000888152602001908152602001600020548261193590919063ffffffff16565b945050505050919050565b6109cc6114a0565b15156109d757600080fd5b80600460006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b610a2433610aca565b1515610a2f57600080fd5b600260009054906101000a900460ff161515610a4a57600080fd5b6000600260006101000a81548160ff0219169083151502179055507f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa33604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390a1565b6000610ae082600161195790919063ffffffff16565b9050919050565b600260009054906101000a900460ff16151515610b0357600080fd5b6001600360008282540192505081905550600060035490503373ffffffffffffffffffffffffffffffffffffffff16600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16636352211e846040518263ffffffff167c01000000000000000000000000000000000000000000000000000000000281526004018082815260200191505060206040518083038186803b158015610bc157600080fd5b505afa158015610bd5573d6000803e3d6000fd5b505050506040513d6020811015610beb57600080fd5b810190808051906020019092919050505073ffffffffffffffffffffffffffffffffffffffff16141515610c1e57600080fd5b6000610c29836106d0565b9050600081111515610c3a57600080fd5b8060066000858152602001908152602001600020600082825401925050819055503373ffffffffffffffffffffffffffffffffffffffff166108fc829081150290604051600060405180830381858888f19350505050158015610ca1573d6000803e3d6000fd5b503373ffffffffffffffffffffffffffffffffffffffff16837fa2af676ed4f1045c96ac2b367997d51c256e9d758a41490190108d260e9634f78342604051808381526020018281526020019250505060405180910390a35060035481141515610d0a57600080fd5b5050565b6000600260009054906101000a900460ff16905090565b610d2e336119eb565b565b610d386114a0565b1515610d4357600080fd5b600073ffffffffffffffffffffffffffffffffffffffff166000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a360008060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550565b600260009054906101000a900460ff16151515610e1e57600080fd5b6001600360008282540192505081905550600060035490506000610e4133611173565b111515610e4d57600080fd5b600080600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166370a08231336040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b158015610f0b57600080fd5b505afa158015610f1f573d6000803e3d6000fd5b505050506040513d6020811015610f3557600080fd5b8101908080519060200190929190505050905060008190505b60008111156110f6576000600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16632f745c5933600185036040518363ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018281526020019250505060206040518083038186803b15801561101f57600080fd5b505afa158015611033573d6000803e3d6000fd5b505050506040513d602081101561104957600080fd5b810190808051906020019092919050505090506000611067826106d0565b905080850194508060066000848152602001908152602001600020600082825401925050819055503373ffffffffffffffffffffffffffffffffffffffff16827fa2af676ed4f1045c96ac2b367997d51c256e9d758a41490190108d260e9634f78342604051808381526020018281526020019250505060405180910390a35050808060019003915050610f4e565b503373ffffffffffffffffffffffffffffffffffffffff166108fc839081150290604051600060405180830381858888f1935050505015801561113d573d6000803e3d6000fd5b5050506003548114151561115057600080fd5b50565b61115c33610aca565b151561116757600080fd5b61117081611a45565b50565b600080600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166370a08231846040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b15801561123157600080fd5b505afa158015611245573d6000803e3d6000fd5b505050506040513d602081101561125b57600080fd5b810190808051906020019092919050505090506000808290505b600081111561139f576000600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16632f745c5987600185036040518363ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018281526020019250505060206040518083038186803b15801561134657600080fd5b505afa15801561135a573d6000803e3d6000fd5b505050506040513d602081101561137057600080fd5b8101908080519060200190929190505050905061138c816106d0565b8301925050808060019003915050611275565b508092505050919050565b6113b333610aca565b15156113be57600080fd5b600260009054906101000a900460ff161515156113da57600080fd5b6001600260006101000a81548160ff0219169083151502179055507f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a25833604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390a1565b600060066000838152602001908152602001600020549050919050565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614905090565b6000600760008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff169050919050565b6000600560008361ffff1661ffff168152602001908152602001600020549050919050565b600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b600260009054906101000a900460ff161515156115b457600080fd5b6001600360008282540192505081905550600060035490506000600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663fbba7b62856040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808261ffff1661ffff16815260200191505060206040518083038186803b15801561166557600080fd5b505afa158015611679573d6000803e3d6000fd5b505050506040513d602081101561168f57600080fd5b81019080805190602001909291905050501115156116ac57600080fd5b600760003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff16151561170457600080fd5b34600560008561ffff1661ffff168152602001908152602001600020600082825401925050819055508173ffffffffffffffffffffffffffffffffffffffff168361ffff167f47fc953414cd61a5494c179efb796283502f867ea6d50a54853a0281f1b7c3fc333442604051808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001838152602001828152602001935050505060405180910390a3600354811415156117cc57600080fd5b505050565b6117d96114a0565b15156117e457600080fd5b6117ed81611a9f565b50565b6117f86114a0565b151561180357600080fd5b80600760008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff0219169083151502179055507f46c9694d3c1e0c41a8202a712e5b1295ec8c263892e58a3866e30e8ee44141e78282604051808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001821515151581526020019250505060405180910390a15050565b6000808314156118e05760009050611905565b600082840290508284828115156118f357fe5b0414151561190057600080fd5b809150505b92915050565b6000808211151561191b57600080fd5b6000828481151561192857fe5b0490508091505092915050565b600082821115151561194657600080fd5b600082840390508091505092915050565b60008073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff161415151561199457600080fd5b8260000160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff16905092915050565b6119ff816001611b9990919063ffffffff16565b8073ffffffffffffffffffffffffffffffffffffffff167fcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e60405160405180910390a250565b611a59816001611c4890919063ffffffff16565b8073ffffffffffffffffffffffffffffffffffffffff167f6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f860405160405180910390a250565b600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614151515611adb57600080fd5b8073ffffffffffffffffffffffffffffffffffffffff166000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a3806000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614151515611bd557600080fd5b611bdf8282611957565b1515611bea57600080fd5b60008260000160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff0219169083151502179055505050565b600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614151515611c8457600080fd5b611c8e8282611957565b151515611c9a57600080fd5b60018260000160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff021916908315150217905550505056fea165627a7a72305820ed578d491686832c37fbabcb20acb75adaef32d83d203e8e53c917e3f9f9ba93002900000000000000000000000075a640661b78021e4b1a58577e4831c7edb571af",
  "constructorArguments": "00000000000000000000000075a640661b78021e4b1a58577e4831c7edb571af"
}