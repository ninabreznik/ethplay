{
  "address": "0x1234567896326230a28ee368825d11fe6571be4a",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "Counter.Market: Proxy",
  "contractName": "Proxy",
  "compilerVersion": "v0.5.3+commit.10d17f24",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2019-03-20\n*/\n\npragma solidity ^0.5.3;\n\n// counter.market smart contracts:\n//  1) Proxy (this one) - delegatecalls into current exchange code, maintains storage of exchange state\n//  2) Registry - stores information on the latest exchange contract version and user approvals\n//  3) Treasury - takes custody of funds, moves them between token accounts, authorizing exchange code via Registry\n\n// Getting current code address is the only thing Proxy needs from Registry.\ninterface RegistryInterface {\n    function getExchangeContract() external view returns (address);\n}\n\n// Counter contracts are deployed at predefined addresses which can be hardcoded.\ncontract FixedAddress {\n    address constant ProxyAddress = 0x1234567896326230a28ee368825D11fE6571Be4a;\n    address constant TreasuryAddress = 0x12345678979f29eBc99E00bdc5693ddEa564cA80;\n    address constant RegistryAddress = 0x12345678982cB986Dd291B50239295E3Cb10Cdf6;\n\n    function getRegistry() internal pure returns (RegistryInterface) {\n        return RegistryInterface(RegistryAddress);\n    }\n}\n\ncontract Proxy is FixedAddress {\n\n  function () external payable {\n      // Query current code version from Registry.\n      address _impl = getRegistry().getExchangeContract();\n\n      // Typical implementation of proxied delegatecall with RETURNDATASIZE/RETURNDATACOPY.\n      // Quick refresher:\n      //     delegatecall uses code from other contract, yet operates on Proxy storage,\n      //     which means the latter is preserved between code upgrades.\n      assembly {\n          let ptr := mload(0x40)\n          calldatacopy(ptr, 0, calldatasize)\n          let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\n          let size := returndatasize\n          returndatacopy(ptr, 0, size)\n\n          switch result\n          case 0 { revert(ptr, size) }\n          default { return(ptr, size) }\n      }\n  }\n\n}",
  "abi": "[{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]",
  "bytecode": "608060405234801561001057600080fd5b50610101806100206000396000f3fe60806040526000600c60bd565b73ffffffffffffffffffffffffffffffffffffffff16636e7c1c466040518163ffffffff167c010000000000000000000000000000000000000000000000000000000002815260040160206040518083038186803b158015606c57600080fd5b505afa158015607f573d6000803e3d6000fd5b505050506040513d6020811015609457600080fd5b505160405190915036600082376000803683855af43d806000843e81801560b9578184f35b8184fd5b7312345678982cb986dd291b50239295e3cb10cdf69056fea165627a7a72305820ed0fefd58579a2c87df0c279dbdd758bb6cd9284f1092857719c9869586ab5410029"
}