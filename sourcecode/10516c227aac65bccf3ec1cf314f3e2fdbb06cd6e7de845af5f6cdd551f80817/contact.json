{
  "address": "0x4c0fbe1bb46612915e7967d2c3213cd4d87257ad",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "ApisToken",
  "compilerVersion": "v0.4.18+commit.9cf6e910",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2018-03-29\n*/\n\npragma solidity ^0.4.18;\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  uint256 public totalSupply;\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}\n\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n    address public owner;\n    address public newOwner;\n\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    function Ownable() public {\n        owner = msg.sender;\n    }\n\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param _newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address _newOwner) public onlyOwner {\n        require(_newOwner != address(0));\n        OwnershipTransferred(owner, _newOwner);\n        newOwner = _newOwner;\n    }\n\n    /**\n     * @dev 새로운 관리자가 승인해야만 소유권이 이전된다\n     */\n    function acceptOwnership() public {\n        require(msg.sender == newOwner);\n        \n        OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n        newOwner = address(0);\n    }\n}\n\n\n/**\n * @title APIS Token\n * @dev APIS 토큰을 생성한다\n */\ncontract ApisToken is StandardToken, Ownable {\n    // 토큰의 이름\n    string public constant name = \"APIS\";\n    \n    // 토큰의 단위\n    string public constant symbol = \"APIS\";\n    \n    // 소수점 자리수. ETH 18자리에 맞춘다\n    uint8 public constant decimals = 18;\n    \n    // 지갑별로 송금/수금 기능의 잠긴 여부를 저장\n    mapping (address => LockedInfo) public lockedWalletInfo;\n    \n    /**\n     * @dev 플랫폼에서 운영하는 마스터노드 스마트 컨트렉트 주소\n     */\n    mapping (address => bool) public manoContracts;\n    \n    \n    /**\n     * @dev 토큰 지갑의 잠김 속성을 정의\n     * \n     * @param timeLockUpEnd timeLockUpEnd 시간까지 송/수금에 대한 제한이 적용된다. 이후에는 제한이 풀린다\n     * @param sendLock 출금 잠김 여부(true : 잠김, false : 풀림)\n     * @param receiveLock 입금 잠김 여부 (true : 잠김, false : 풀림)\n     */\n    struct LockedInfo {\n        uint timeLockUpEnd;\n        bool sendLock;\n        bool receiveLock;\n    } \n    \n    \n    /**\n     * @dev 토큰이 송금됐을 때 발생하는 이벤트\n     * @param from 토큰을 보내는 지갑 주소\n     * @param to 토큰을 받는 지갑 주소\n     * @param value 전달되는 토큰의 양 (Satoshi)\n     */\n    event Transfer (address indexed from, address indexed to, uint256 value);\n    \n    /**\n     * @dev 토큰 지갑의 송금/입금 기능이 제한되었을 때 발생하는 이벤트\n     * @param target 제한 대상 지갑 주소\n     * @param timeLockUpEnd 제한이 종료되는 시간(UnixTimestamp)\n     * @param sendLock 지갑에서의 송금을 제한하는지 여부(true : 제한, false : 해제)\n     * @param receiveLock 지갑으로의 입금을 제한하는지 여부 (true : 제한, false : 해제)\n     */\n    event Locked (address indexed target, uint timeLockUpEnd, bool sendLock, bool receiveLock);\n    \n    /**\n     * @dev 지갑에 대한 송금/입금 제한을 해제했을 때 발생하는 이벤트\n     * @param target 해제 대상 지갑 주소\n     */\n    event Unlocked (address indexed target);\n    \n    /**\n     * @dev 송금 받는 지갑의 입금이 제한되어있어서 송금이 거절되었을 때 발생하는 이벤트\n     * @param from 토큰을 보내는 지갑 주소\n     * @param to (입금이 제한된) 토큰을 받는 지갑 주소\n     * @param value 전송하려고 한 토큰의 양(Satoshi)\n     */\n    event RejectedPaymentToLockedUpWallet (address indexed from, address indexed to, uint256 value);\n    \n    /**\n     * @dev 송금하는 지갑의 출금이 제한되어있어서 송금이 거절되었을 때 발생하는 이벤트\n     * @param from (출금이 제한된) 토큰을 보내는 지갑 주소\n     * @param to 토큰을 받는 지갑 주소\n     * @param value 전송하려고 한 토큰의 양(Satoshi)\n     */\n    event RejectedPaymentFromLockedUpWallet (address indexed from, address indexed to, uint256 value);\n    \n    /**\n     * @dev 토큰을 소각한다. \n     * @param burner 토큰을 소각하는 지갑 주소\n     * @param value 소각하는 토큰의 양(Satoshi)\n     */\n    event Burn (address indexed burner, uint256 value);\n    \n    /**\n     * @dev 아피스 플랫폼에 마스터노드 스마트 컨트렉트가 등록되거나 해제될 때 발생하는 이벤트\n     */\n    event ManoContractRegistered (address manoContract, bool registered);\n    \n    /**\n     * @dev 컨트랙트가 생성될 때 실행. 컨트렉트 소유자 지갑에 모든 토큰을 할당한다.\n     * 발행량이나 이름은 소스코드에서 확인할 수 있도록 변경하였음\n     */\n    function ApisToken() public {\n        // 총 APIS 발행량 (95억 2천만)\n        uint256 supplyApis = 9520000000;\n        \n        // wei 단위로 토큰 총량을 생성한다.\n        totalSupply = supplyApis * 10 ** uint256(decimals);\n        \n        balances[msg.sender] = totalSupply;\n        \n        Transfer(0x0, msg.sender, totalSupply);\n    }\n    \n    \n    /**\n     * @dev 지갑을 지정된 시간까지 제한시키거나 해제시킨다. 제한 시간이 경과하면 모든 제한이 해제된다.\n     * @param _targetWallet 제한을 적용할 지갑 주소\n     * @param _timeLockEnd 제한이 종료되는 시간(UnixTimestamp)\n     * @param _sendLock (true : 지갑에서 토큰을 출금하는 기능을 제한한다.) (false : 제한을 해제한다)\n     * @param _receiveLock (true : 지갑으로 토큰을 입금받는 기능을 제한한다.) (false : 제한을 해제한다)\n     */\n    function walletLock(address _targetWallet, uint _timeLockEnd, bool _sendLock, bool _receiveLock) onlyOwner public {\n        require(_targetWallet != 0x0);\n        \n        // If all locks are unlocked, set the _timeLockEnd to zero.\n        if(_sendLock == false && _receiveLock == false) {\n            _timeLockEnd = 0;\n        }\n        \n        lockedWalletInfo[_targetWallet].timeLockUpEnd = _timeLockEnd;\n        lockedWalletInfo[_targetWallet].sendLock = _sendLock;\n        lockedWalletInfo[_targetWallet].receiveLock = _receiveLock;\n        \n        if(_timeLockEnd > 0) {\n            Locked(_targetWallet, _timeLockEnd, _sendLock, _receiveLock);\n        } else {\n            Unlocked(_targetWallet);\n        }\n    }\n    \n    /**\n     * @dev 지갑의 입급/출금을 지정된 시간까지 제한시킨다. 제한 시간이 경과하면 모든 제한이 해제된다.\n     * @param _targetWallet 제한을 적용할 지갑 주소\n     * @param _timeLockUpEnd 제한이 종료되는 시간(UnixTimestamp)\n     */\n    function walletLockBoth(address _targetWallet, uint _timeLockUpEnd) onlyOwner public {\n        walletLock(_targetWallet, _timeLockUpEnd, true, true);\n    }\n    \n    /**\n     * @dev 지갑의 입급/출금을 영원히(33658-9-27 01:46:39+00) 제한시킨다.\n     * @param _targetWallet 제한을 적용할 지갑 주소\n     */\n    function walletLockBothForever(address _targetWallet) onlyOwner public {\n        walletLock(_targetWallet, 999999999999, true, true);\n    }\n    \n    \n    /**\n     * @dev 지갑에 설정된 입출금 제한을 해제한다\n     * @param _targetWallet 제한을 해제하고자 하는 지갑 주소\n     */\n    function walletUnlock(address _targetWallet) onlyOwner public {\n        walletLock(_targetWallet, 0, false, false);\n    }\n    \n    /**\n     * @dev 지갑의 송금 기능이 제한되어있는지 확인한다.\n     * @param _addr 송금 제한 여부를 확인하려는 지갑의 주소\n     * @return isSendLocked (true : 제한되어 있음, 토큰을 보낼 수 없음) (false : 제한 없음, 토큰을 보낼 수 있음)\n     * @return until 잠겨있는 시간, UnixTimestamp\n     */\n    function isWalletLocked_Send(address _addr) public constant returns (bool isSendLocked, uint until) {\n        require(_addr != 0x0);\n        \n        isSendLocked = (lockedWalletInfo[_addr].timeLockUpEnd > now && lockedWalletInfo[_addr].sendLock == true);\n        \n        if(isSendLocked) {\n            until = lockedWalletInfo[_addr].timeLockUpEnd;\n        } else {\n            until = 0;\n        }\n    }\n    \n    /**\n     * @dev 지갑의 입금 기능이 제한되어있는지 확인한다.\n     * @param _addr 입금 제한 여부를 확인하려는 지갑의 주소\n     * @return (true : 제한되어 있음, 토큰을 받을 수 없음) (false : 제한 없음, 토큰을 받을 수 있음)\n     */\n    function isWalletLocked_Receive(address _addr) public constant returns (bool isReceiveLocked, uint until) {\n        require(_addr != 0x0);\n        \n        isReceiveLocked = (lockedWalletInfo[_addr].timeLockUpEnd > now && lockedWalletInfo[_addr].receiveLock == true);\n        \n        if(isReceiveLocked) {\n            until = lockedWalletInfo[_addr].timeLockUpEnd;\n        } else {\n            until = 0;\n        }\n    }\n    \n    /**\n     * @dev 요청자의 지갑에 송금 기능이 제한되어있는지 확인한다.\n     * @return (true : 제한되어 있음, 토큰을 보낼 수 없음) (false : 제한 없음, 토큰을 보낼 수 있음)\n     */\n    function isMyWalletLocked_Send() public constant returns (bool isSendLocked, uint until) {\n        return isWalletLocked_Send(msg.sender);\n    }\n    \n    /**\n     * @dev 요청자의 지갑에 입금 기능이 제한되어있는지 확인한다.\n     * @return (true : 제한되어 있음, 토큰을 보낼 수 없음) (false : 제한 없음, 토큰을 보낼 수 있음)\n     */\n    function isMyWalletLocked_Receive() public constant returns (bool isReceiveLocked, uint until) {\n        return isWalletLocked_Receive(msg.sender);\n    }\n    \n    \n    /**\n     * @dev 아피스 플랫폼에서 운영하는 스마트 컨트렉트 주소를 등록하거나 해제한다.\n     * @param manoAddr 마스터노드 스마트 컨트렉컨트렉트\n     * @param registered true : 등록, false : 해제\n     */\n    function registerManoContract(address manoAddr, bool registered) onlyOwner public {\n        manoContracts[manoAddr] = registered;\n        \n        ManoContractRegistered(manoAddr, registered);\n    }\n    \n    \n    /**\n     * @dev _to 지갑으로 _apisWei 만큼의 토큰을 송금한다.\n     * @param _to 토큰을 받는 지갑 주소\n     * @param _apisWei 전송되는 토큰의 양\n     */\n    function transfer(address _to, uint256 _apisWei) public returns (bool) {\n        // 자신에게 송금하는 것을 방지한다\n        require(_to != address(this));\n        \n        // 마스터노드 컨트렉트일 경우, APIS 송수신에 제한을 두지 않는다\n        if(manoContracts[msg.sender] || manoContracts[_to]) {\n            return super.transfer(_to, _apisWei);\n        }\n        \n        // 송금 기능이 잠긴 지갑인지 확인한다.\n        if(lockedWalletInfo[msg.sender].timeLockUpEnd > now && lockedWalletInfo[msg.sender].sendLock == true) {\n            RejectedPaymentFromLockedUpWallet(msg.sender, _to, _apisWei);\n            return false;\n        } \n        // 입금 받는 기능이 잠긴 지갑인지 확인한다\n        else if(lockedWalletInfo[_to].timeLockUpEnd > now && lockedWalletInfo[_to].receiveLock == true) {\n            RejectedPaymentToLockedUpWallet(msg.sender, _to, _apisWei);\n            return false;\n        } \n        // 제한이 없는 경우, 송금을 진행한다.\n        else {\n            return super.transfer(_to, _apisWei);\n        }\n    }\n    \n    /**\n     * @dev _to 지갑으로 _apisWei 만큼의 APIS를 송금하고 _timeLockUpEnd 시간만큼 지갑을 잠근다\n     * @param _to 토큰을 받는 지갑 주소\n     * @param _apisWei 전송되는 토큰의 양(wei)\n     * @param _timeLockUpEnd 잠금이 해제되는 시간\n     */\n    function transferAndLockUntil(address _to, uint256 _apisWei, uint _timeLockUpEnd) onlyOwner public {\n        require(transfer(_to, _apisWei));\n        \n        walletLockBoth(_to, _timeLockUpEnd);\n    }\n    \n    /**\n     * @dev _to 지갑으로 _apisWei 만큼의 APIS를 송금하고영원히 지갑을 잠근다\n     * @param _to 토큰을 받는 지갑 주소\n     * @param _apisWei 전송되는 토큰의 양(wei)\n     */\n    function transferAndLockForever(address _to, uint256 _apisWei) onlyOwner public {\n        require(transfer(_to, _apisWei));\n        \n        walletLockBothForever(_to);\n    }\n    \n    \n    /**\n     * @dev 함수를 호출하는 지갑의 토큰을 소각한다.\n     * \n     * zeppelin-solidity/contracts/token/BurnableToken.sol 참조\n     * @param _value 소각하려는 토큰의 양(Satoshi)\n     */\n    function burn(uint256 _value) public {\n        require(_value <= balances[msg.sender]);\n        require(_value <= totalSupply);\n        \n        address burner = msg.sender;\n        balances[burner] -= _value;\n        totalSupply -= _value;\n        \n        Burn(burner, _value);\n    }\n    \n    \n    /**\n     * @dev Eth은 받을 수 없도록 한다.\n     */\n    function () public payable {\n        revert();\n    }\n}\n\n\n\n\n\n\n\n\n/**\n * @title WhiteList\n * @dev ICO 참여가 가능한 화이트 리스트를 관리한다\n */\ncontract WhiteList is Ownable {\n    \n    mapping (address => uint8) internal list;\n    \n    /**\n     * @dev 화이트리스트에 변동이 발생했을 때 이벤트\n     * @param backer 화이트리스트에 등재하려는 지갑 주소\n     * @param allowed (true : 화이트리스트에 추가) (false : 제거)\n     */\n    event WhiteBacker(address indexed backer, bool allowed);\n    \n    \n    /**\n     * @dev 화이트리스트에 등록하거나 해제한다.\n     * @param _target 화이트리스트에 등재하려는 지갑 주소\n     * @param _allowed (true : 화이트리스트에 추가) (false : 제거) \n     */\n    function setWhiteBacker(address _target, bool _allowed) onlyOwner public {\n        require(_target != 0x0);\n        \n        if(_allowed == true) {\n            list[_target] = 1;\n        } else {\n            list[_target] = 0;\n        }\n        \n        WhiteBacker(_target, _allowed);\n    }\n    \n    /**\n     * @dev 화이트 리스트에 등록(추가)한다\n     * @param _target 추가할 지갑 주소\n     */\n    function addWhiteBacker(address _target) onlyOwner public {\n        setWhiteBacker(_target, true);\n    }\n    \n    /**\n     * @dev 화이트리스트에 여러 지갑 주소를 동시에 등재하거나 제거한다.\n     * \n     * 가스 소모를 줄여보기 위함\n     * @param _backers 대상이 되는 지갑들의 리스트\n     * @param _allows 대상이 되는 지갑들의 추가 여부 리스트 (true : 추가) (false : 제거)\n     */\n    function setWhiteBackersByList(address[] _backers, bool[] _allows) onlyOwner public {\n        require(_backers.length > 0);\n        require(_backers.length == _allows.length);\n        \n        for(uint backerIndex = 0; backerIndex < _backers.length; backerIndex++) {\n            setWhiteBacker(_backers[backerIndex], _allows[backerIndex]);\n        }\n    }\n    \n    /**\n     * @dev 화이트리스트에 여러 지갑 주소를 등재한다.\n     * \n     * 모든 주소들은 화이트리스트에 추가된다.\n     * @param _backers 대상이 되는 지갑들의 리스트\n     */\n    function addWhiteBackersByList(address[] _backers) onlyOwner public {\n        for(uint backerIndex = 0; backerIndex < _backers.length; backerIndex++) {\n            setWhiteBacker(_backers[backerIndex], true);\n        }\n    }\n    \n    \n    /**\n     * @dev 해당 지갑 주소가 화이트 리스트에 등록되어있는지 확인한다\n     * @param _addr 등재 여부를 확인하려는 지갑의 주소\n     * @return (true : 등록되어있음) (false : 등록되어있지 않음)\n     */\n    function isInWhiteList(address _addr) public constant returns (bool) {\n        require(_addr != 0x0);\n        return list[_addr] > 0;\n    }\n    \n    /**\n     * @dev 요청하는 지갑이 화이트리스트에 등록되어있는지 확인한다.\n     * @return (true : 등록되어있음) (false : 등록되어있지 않음)\n     */\n    function isMeInWhiteList() public constant returns (bool isWhiteBacker) {\n        return list[msg.sender] > 0;\n    }\n}\n\n\n\n/**\n * @title APIS Crowd Pre-Sale\n * @dev 토큰의 프리세일을 수행하기 위한 컨트랙트\n */\ncontract ApisCrowdSale is Ownable {\n    \n    // 소수점 자리수. Eth 18자리에 맞춘다\n    uint8 public constant decimals = 18;\n    \n    \n    // 크라우드 세일의 판매 목표량(APIS)\n    uint256 public fundingGoal;\n    \n    // 현재 진행하는 판매 목표량 \n    // QTUM과 공동으로 판매가 진행되기 때문에,  QTUM 쪽 컨트렉트와 합산한 판매량이 총 판매목표를 넘지 않도록 하기 위함\n    uint256 public fundingGoalCurrent;\n    \n    // 1 ETH으로 살 수 있는 APIS의 갯수\n    uint256 public priceOfApisPerFund;\n    \n\n    // 발급된 Apis 갯수 (예약 + 발행)\n    //uint256 public totalSoldApis;\n    \n    // 발행 대기중인 APIS 갯수\n    //uint256 public totalReservedApis;\n    \n    // 발행되서 출금된 APIS 갯수\n    //uint256 public totalWithdrawedApis;\n    \n    \n    // 입금된 투자금의 총액 (예약 + 발행)\n    //uint256 public totalReceivedFunds;\n    \n    // 구매 확정 전 투자금의 총액\n    //uint256 public totalReservedFunds;\n    \n    // 구매 확정된 투자금의 총액\n    //uint256 public totalPaidFunds;\n\n    \n    // 판매가 시작되는 시간\n    uint public startTime;\n    \n    // 판매가 종료되는 시간\n    uint public endTime;\n\n    // 판매가 조기에 종료될 경우를 대비하기 위함\n    bool closed = false;\n    \n\tSaleStatus public saleStatus;\n    \n    // APIS 토큰 컨트렉트\n    ApisToken internal tokenReward;\n    \n    // 화이트리스트 컨트렉트\n    WhiteList internal whiteList;\n\n    \n    \n    mapping (address => Property) public fundersProperty;\n    \n    /**\n     * @dev APIS 토큰 구매자의 자산 현황을 정리하기 위한 구조체\n     */\n    struct Property {\n        uint256 reservedFunds;   // 입금했지만 아직 APIS로 변환되지 않은 Eth (환불 가능)\n        uint256 paidFunds;    \t// APIS로 변환된 Eth (환불 불가)\n        uint256 reservedApis;   // 받을 예정인 토큰\n        uint256 withdrawedApis; // 이미 받은 토큰\n        uint purchaseTime;      // 구입한 시간\n    }\n\t\n\t\n\t/**\n\t * @dev 현재 세일의 진행 현황을 확인할 수 있다.\n\t * totalSoldApis 발급된 Apis 갯수 (예약 + 발행)\n\t * totalReservedApis 발행 대기 중인 Apis\n\t * totalWithdrawedApis 발행되서 출금된 APIS 갯수\n\t * \n\t * totalReceivedFunds 입금된 투자금의 총액 (예약 + 발행)\n\t * totalReservedFunds 구매 확정 전 투자금의 총액\n\t * ttotalPaidFunds 구매 확정된 투자금의 총액\n\t */\n\tstruct SaleStatus {\n\t\tuint256 totalReservedFunds;\n\t\tuint256 totalPaidFunds;\n\t\tuint256 totalReceivedFunds;\n\t\t\n\t\tuint256 totalReservedApis;\n\t\tuint256 totalWithdrawedApis;\n\t\tuint256 totalSoldApis;\n\t}\n    \n    \n    \n    /**\n     * @dev APIS를 구입하기 위한 Eth을 입금했을 때 발생하는 이벤트\n     * @param beneficiary APIS를 구매하고자 하는 지갑의 주소\n     * @param amountOfFunds 입금한 Eth의 양 (wei)\n     * @param amountOfApis 투자금에 상응하는 APIS 토큰의 양 (wei)\n     */\n    event ReservedApis(address beneficiary, uint256 amountOfFunds, uint256 amountOfApis);\n    \n    /**\n     * @dev 크라우드 세일 컨트렉트에서 Eth이 인출되었을 때 발생하는 이벤트\n     * @param addr 받는 지갑의 주소\n     * @param amount 송금되는 양(wei)\n     */\n    event WithdrawalFunds(address addr, uint256 amount);\n    \n    /**\n     * @dev 구매자에게 토큰이 발급되었을 때 발생하는 이벤트\n     * @param funder 토큰을 받는 지갑의 주소\n     * @param amountOfFunds 입금한 투자금의 양 (wei)\n     * @param amountOfApis 발급 받는 토큰의 양 (wei)\n     */\n    event WithdrawalApis(address funder, uint256 amountOfFunds, uint256 amountOfApis);\n    \n    \n    /**\n     * @dev 투자금 입금 후, 아직 토큰을 발급받지 않은 상태에서, 환불 처리를 했을 때 발생하는 이벤트\n     * @param _backer 환불 처리를 진행하는 지갑의 주소\n     * @param _amountFunds 환불하는 투자금의 양\n     * @param _amountApis 취소되는 APIS 양\n     */\n    event Refund(address _backer, uint256 _amountFunds, uint256 _amountApis);\n    \n    \n    /**\n     * @dev 크라우드 세일 진행 중에만 동작하도록 제한하고, APIS의 가격도 설정되어야만 한다.\n     */\n    modifier onSale() {\n        require(now >= startTime);\n        require(now < endTime);\n        require(closed == false);\n        require(priceOfApisPerFund > 0);\n        require(fundingGoalCurrent > 0);\n        _;\n    }\n    \n    /**\n     * @dev 크라우드 세일 종료 후에만 동작하도록 제한\n     */\n    modifier onFinished() {\n        require(now >= endTime || closed == true);\n        _;\n    }\n    \n    /**\n     * @dev 화이트리스트에 등록되어있어야하고 아직 구매완료 되지 않은 투자금이 있어야만 한다.\n     */\n    modifier claimable() {\n        require(whiteList.isInWhiteList(msg.sender) == true);\n        require(fundersProperty[msg.sender].reservedFunds > 0);\n        _;\n    }\n    \n    \n    /**\n     * @dev 크라우드 세일 컨트렉트를 생성한다.\n     * @param _fundingGoalApis 판매하는 토큰의 양 (APIS 단위)\n     * @param _startTime 크라우드 세일을 시작하는 시간\n     * @param _endTime 크라우드 세일을 종료하는 시간\n     * @param _addressOfApisTokenUsedAsReward APIS 토큰의 컨트렉트 주소\n     * @param _addressOfWhiteList WhiteList 컨트렉트 주소\n     */\n    function ApisCrowdSale (\n        uint256 _fundingGoalApis,\n        uint _startTime,\n        uint _endTime,\n        address _addressOfApisTokenUsedAsReward,\n        address _addressOfWhiteList\n    ) public {\n        require (_fundingGoalApis > 0);\n        require (_startTime > now);\n        require (_endTime > _startTime);\n        require (_addressOfApisTokenUsedAsReward != 0x0);\n        require (_addressOfWhiteList != 0x0);\n        \n        fundingGoal = _fundingGoalApis * 10 ** uint256(decimals);\n        \n        startTime = _startTime;\n        endTime = _endTime;\n        \n        // 토큰 스마트컨트렉트를 불러온다\n        tokenReward = ApisToken(_addressOfApisTokenUsedAsReward);\n        \n        // 화이트 리스트를 가져온다\n        whiteList = WhiteList(_addressOfWhiteList);\n    }\n    \n    /**\n     * @dev 판매 종료는 1회만 가능하도록 제약한다. 종료 후 다시 판매 중으로 변경할 수 없다\n     */\n    function closeSale(bool _closed) onlyOwner public {\n        require (closed == false);\n        \n        closed = _closed;\n    }\n    \n    /**\n     * @dev 크라우드 세일 시작 전에 1Eth에 해당하는 APIS 량을 설정한다.\n     */\n    function setPriceOfApis(uint256 price) onlyOwner public {\n        require(priceOfApisPerFund == 0);\n        \n        priceOfApisPerFund = price;\n    }\n    \n    /**\n     * @dev 현 시점에서 판매 가능한 목표량을 수정한다.\n     * @param _currentFundingGoalAPIS 현 시점의 판매 목표량은 총 판매된 양 이상이어야만 한다.\n     */\n    function setCurrentFundingGoal(uint256 _currentFundingGoalAPIS) onlyOwner public {\n        uint256 fundingGoalCurrentWei = _currentFundingGoalAPIS * 10 ** uint256(decimals);\n        require(fundingGoalCurrentWei >= saleStatus.totalSoldApis);\n        \n        fundingGoalCurrent = fundingGoalCurrentWei;\n    }\n    \n    \n    /**\n     * @dev APIS 잔고를 확인한다\n     * @param _addr 잔고를 확인하려는 지갑의 주소\n     * @return balance 지갑에 들은 APIS 잔고 (wei)\n     */\n    function balanceOf(address _addr) public view returns (uint256 balance) {\n        return tokenReward.balanceOf(_addr);\n    }\n    \n    /**\n     * @dev 화이트리스트 등록 여부를 확인한다\n     * @param _addr 등록 여부를 확인하려는 주소\n     * @return addrIsInWhiteList true : 등록되있음, false : 등록되어있지 않음\n     */\n    function whiteListOf(address _addr) public view returns (string message) {\n        if(whiteList.isInWhiteList(_addr) == true) {\n            return \"The address is in whitelist.\";\n        } else {\n            return \"The address is *NOT* in whitelist.\";\n        }\n    }\n    \n    \n    /**\n     * @dev 전달받은 지갑이 APIS 지급 요청이 가능한지 확인한다.\n     * @param _addr 확인하는 주소\n     * @return message 결과 메시지\n     */\n    function isClaimable(address _addr) public view returns (string message) {\n        if(fundersProperty[_addr].reservedFunds == 0) {\n            return \"The address has no claimable balance.\";\n        }\n        \n        if(whiteList.isInWhiteList(_addr) == false) {\n            return \"The address must be registered with KYC and Whitelist\";\n        }\n        \n        else {\n            return \"The address can claim APIS!\";\n        }\n    }\n    \n    \n    /**\n     * @dev 크라우드 세일 컨트렉트로 바로 투자금을 송금하는 경우, buyToken으로 연결한다\n     */\n    function () onSale public payable {\n        buyToken(msg.sender);\n    }\n    \n    /**\n     * @dev 토큰을 구입하기 위해 Qtum을 입금받는다.\n     * @param _beneficiary 토큰을 받게 될 지갑의 주소\n     */\n    function buyToken(address _beneficiary) onSale public payable {\n        // 주소 확인\n        require(_beneficiary != 0x0);\n        \n        // 크라우드 세일 컨트렉트의 토큰 송금 기능이 정지되어있으면 판매하지 않는다\n        bool isLocked = false;\n        uint timeLock = 0;\n        (isLocked, timeLock) = tokenReward.isWalletLocked_Send(this);\n        \n        require(isLocked == false);\n        \n        \n        uint256 amountFunds = msg.value;\n        uint256 reservedApis = amountFunds * priceOfApisPerFund;\n        \n        \n        // 목표 금액을 넘어서지 못하도록 한다\n        require(saleStatus.totalSoldApis + reservedApis <= fundingGoalCurrent);\n        require(saleStatus.totalSoldApis + reservedApis <= fundingGoal);\n        \n        // 투자자의 자산을 업데이트한다\n        fundersProperty[_beneficiary].reservedFunds += amountFunds;\n        fundersProperty[_beneficiary].reservedApis += reservedApis;\n        fundersProperty[_beneficiary].purchaseTime = now;\n        \n        // 총액들을 업데이트한다\n        saleStatus.totalReceivedFunds += amountFunds;\n        saleStatus.totalReservedFunds += amountFunds;\n        \n        saleStatus.totalSoldApis += reservedApis;\n        saleStatus.totalReservedApis += reservedApis;\n        \n        \n        // 화이트리스트에 등록되어있으면 바로 출금한다\n        if(whiteList.isInWhiteList(_beneficiary) == true) {\n            withdrawal(_beneficiary);\n        }\n        else {\n            // 토큰 발행 예약 이벤트 발생\n            ReservedApis(_beneficiary, amountFunds, reservedApis);\n        }\n    }\n    \n    \n    \n    /**\n     * @dev 관리자에 의해서 토큰을 발급한다. 하지만 기본 요건은 갖춰야만 가능하다\n     * \n     * @param _target 토큰 발급을 청구하려는 지갑 주소\n     */\n    function claimApis(address _target) public {\n        // 화이트 리스트에 있어야만 하고\n        require(whiteList.isInWhiteList(_target) == true);\n        // 예약된 투자금이 있어야만 한다.\n        require(fundersProperty[_target].reservedFunds > 0);\n        \n        withdrawal(_target);\n    }\n    \n    /**\n     * @dev 예약한 토큰의 실제 지급을 요청하도록 한다.\n     * \n     * APIS를 구매하기 위해 Qtum을 입금할 경우, 관리자의 검토를 위한 7일의 유예기간이 존재한다.\n     * 유예기간이 지나면 토큰 지급을 요구할 수 있다.\n     */\n    function claimMyApis() claimable public {\n        withdrawal(msg.sender);\n    }\n    \n    \n    /**\n     * @dev 구매자에게 토큰을 지급한다.\n     * @param funder 토큰을 지급할 지갑의 주소\n     */\n    function withdrawal(address funder) internal {\n        // 구매자 지갑으로 토큰을 전달한다\n        assert(tokenReward.transferFrom(owner, funder, fundersProperty[funder].reservedApis));\n        \n        fundersProperty[funder].withdrawedApis += fundersProperty[funder].reservedApis;\n        fundersProperty[funder].paidFunds += fundersProperty[funder].reservedFunds;\n        \n        // 총액에 반영\n        saleStatus.totalReservedFunds -= fundersProperty[funder].reservedFunds;\n        saleStatus.totalPaidFunds += fundersProperty[funder].reservedFunds;\n        \n        saleStatus.totalReservedApis -= fundersProperty[funder].reservedApis;\n        saleStatus.totalWithdrawedApis += fundersProperty[funder].reservedApis;\n        \n        // APIS가 출금 되었음을 알리는 이벤트\n        WithdrawalApis(funder, fundersProperty[funder].reservedFunds, fundersProperty[funder].reservedApis);\n        \n        // 인출하지 않은 APIS 잔고를 0으로 변경해서, Qtum 재입금 시 이미 출금한 토큰이 다시 출금되지 않게 한다.\n        fundersProperty[funder].reservedFunds = 0;\n        fundersProperty[funder].reservedApis = 0;\n    }\n    \n    \n    /**\n     * @dev 아직 토큰을 발급받지 않은 지갑을 대상으로, 환불을 진행할 수 있다.\n     * @param _funder 환불을 진행하려는 지갑의 주소\n     */\n    function refundByOwner(address _funder) onlyOwner public {\n        require(fundersProperty[_funder].reservedFunds > 0);\n        \n        uint256 amountFunds = fundersProperty[_funder].reservedFunds;\n        uint256 amountApis = fundersProperty[_funder].reservedApis;\n        \n        // Eth을 환불한다\n        _funder.transfer(amountFunds);\n        \n        saleStatus.totalReceivedFunds -= amountFunds;\n        saleStatus.totalReservedFunds -= amountFunds;\n        \n        saleStatus.totalSoldApis -= amountApis;\n        saleStatus.totalReservedApis -= amountApis;\n        \n        fundersProperty[_funder].reservedFunds = 0;\n        fundersProperty[_funder].reservedApis = 0;\n        \n        Refund(_funder, amountFunds, amountApis);\n    }\n    \n    \n    /**\n     * @dev 펀딩이 종료된 이후면, 적립된 투자금을 반환한다.\n     * @param remainRefundable true : 환불할 수 있는 금액은 남기고 반환한다. false : 모두 반환한다\n     */\n    function withdrawalFunds(bool remainRefundable) onlyOwner public {\n        require(now > endTime || closed == true);\n        \n        uint256 amount = 0;\n        if(remainRefundable) {\n            amount = this.balance - saleStatus.totalReservedFunds;\n        } else {\n            amount = this.balance;\n        }\n        \n        if(amount > 0) {\n            msg.sender.transfer(amount);\n            \n            WithdrawalFunds(msg.sender, amount);\n        }\n    }\n    \n    /**\n\t * @dev 크라우드 세일이 진행 중인지 여부를 반환한다.\n\t * @return isOpened true: 진행 중 false : 진행 중이 아님(참여 불가)\n\t */\n    function isOpened() public view returns (bool isOpend) {\n        if(now < startTime) return false;\n        if(now >= endTime) return false;\n        if(closed == true) return false;\n        \n        return true;\n    }\n}",
  "abi": "[{\"constant\":false,\"inputs\":[{\"name\":\"_targetWallet\",\"type\":\"address\"},{\"name\":\"_timeLockUpEnd\",\"type\":\"uint256\"}],\"name\":\"walletLockBoth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_targetWallet\",\"type\":\"address\"}],\"name\":\"walletLockBothForever\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"manoContracts\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_apisWei\",\"type\":\"uint256\"}],\"name\":\"transferAndLockForever\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_targetWallet\",\"type\":\"address\"},{\"name\":\"_timeLockEnd\",\"type\":\"uint256\"},{\"name\":\"_sendLock\",\"type\":\"bool\"},{\"name\":\"_receiveLock\",\"type\":\"bool\"}],\"name\":\"walletLock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isWalletLocked_Receive\",\"outputs\":[{\"name\":\"isReceiveLocked\",\"type\":\"bool\"},{\"name\":\"until\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"manoAddr\",\"type\":\"address\"},{\"name\":\"registered\",\"type\":\"bool\"}],\"name\":\"registerManoContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_apisWei\",\"type\":\"uint256\"},{\"name\":\"_timeLockUpEnd\",\"type\":\"uint256\"}],\"name\":\"transferAndLockUntil\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_apisWei\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_targetWallet\",\"type\":\"address\"}],\"name\":\"walletUnlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lockedWalletInfo\",\"outputs\":[{\"name\":\"timeLockUpEnd\",\"type\":\"uint256\"},{\"name\":\"sendLock\",\"type\":\"bool\"},{\"name\":\"receiveLock\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isMyWalletLocked_Receive\",\"outputs\":[{\"name\":\"isReceiveLocked\",\"type\":\"bool\"},{\"name\":\"until\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isWalletLocked_Send\",\"outputs\":[{\"name\":\"isSendLocked\",\"type\":\"bool\"},{\"name\":\"until\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isMyWalletLocked_Send\",\"outputs\":[{\"name\":\"isSendLocked\",\"type\":\"bool\"},{\"name\":\"until\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"timeLockUpEnd\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sendLock\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"receiveLock\",\"type\":\"bool\"}],\"name\":\"Locked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"target\",\"type\":\"address\"}],\"name\":\"Unlocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"RejectedPaymentToLockedUpWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"RejectedPaymentFromLockedUpWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"burner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"manoContract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"registered\",\"type\":\"bool\"}],\"name\":\"ManoContractRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]",
  "bytecode": "6060604052341561000f57600080fd5b60038054600160a060020a03191633600160a060020a03169081179091556b1ec2c26a1a64c4d3300000006000818155828152600160205260408082208390556402376fac0093927fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef915190815260200160405180910390a3506112d4806100986000396000f3006060604052600436106101745763ffffffff7c010000000000000000000000000000000000000000000000000000000060003504166303a1bdc3811461017957806306fdde031461019d578063095ea7b31461022757806318160ddd1461025d57806323b872dd146102825780632823fbe5146102aa578063313ce567146102c9578063385ec577146102f257806342966c681461031157806366188463146103275780636a59d0a41461034957806370a082311461036b57806374ccd7cc1461038a578063788c4023146103b657806379ba5097146103ef5780637cf846c91461040257806385d544be146104265780638da5cb5b1461044b57806395d89b411461019d578063a9059cbb1461047a578063af87c3661461049c578063d48b38b7146104bb578063d4ee1d9014610500578063d73dd62314610513578063dd62ed3e14610535578063e374e8d41461055a578063f1f62f101461056d578063f2fde38b1461058c578063fbcc3775146105ab575b600080fd5b341561018457600080fd5b61019b600160a060020a03600435166024356105be565b005b34156101a857600080fd5b6101b06105ea565b60405160208082528190810183818151815260200191508051906020019080838360005b838110156101ec5780820151838201526020016101d4565b50505050905090810190601f1680156102195780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b341561023257600080fd5b610249600160a060020a0360043516602435610621565b604051901515815260200160405180910390f35b341561026857600080fd5b61027061068e565b60405190815260200160405180910390f35b341561028d57600080fd5b610249600160a060020a0360043581169060243516604435610694565b34156102b557600080fd5b61019b600160a060020a0360043516610816565b34156102d457600080fd5b6102dc610846565b60405160ff909116815260200160405180910390f35b34156102fd57600080fd5b610249600160a060020a036004351661084b565b341561031c57600080fd5b61019b600435610860565b341561033257600080fd5b610249600160a060020a03600435166024356108f5565b341561035457600080fd5b61019b600160a060020a03600435166024356109ef565b341561037657600080fd5b610270600160a060020a0360043516610a28565b341561039557600080fd5b61019b600160a060020a036004351660243560443515156064351515610a43565b34156103c157600080fd5b6103d5600160a060020a0360043516610b5c565b604051911515825260208201526040908101905180910390f35b34156103fa57600080fd5b61019b610bf1565b341561040d57600080fd5b61019b600160a060020a03600435166024351515610c7f565b341561043157600080fd5b61019b600160a060020a0360043516602435604435610d0b565b341561045657600080fd5b61045e610d4a565b604051600160a060020a03909116815260200160405180910390f35b341561048557600080fd5b610249600160a060020a0360043516602435610d59565b34156104a757600080fd5b61019b600160a060020a0360043516610f18565b34156104c657600080fd5b6104da600160a060020a0360043516610f41565b604051928352901515602083015215156040808301919091526060909101905180910390f35b341561050b57600080fd5b61045e610f66565b341561051e57600080fd5b610249600160a060020a0360043516602435610f75565b341561054057600080fd5b610270600160a060020a0360043581169060243516611019565b341561056557600080fd5b6103d5611044565b341561057857600080fd5b6103d5600160a060020a0360043516611058565b341561059757600080fd5b61019b600160a060020a03600435166110de565b34156105b657600080fd5b6103d5611179565b60035433600160a060020a039081169116146105d957600080fd5b6105e68282600180610a43565b5050565b60408051908101604052600481527f4150495300000000000000000000000000000000000000000000000000000000602082015281565b600160a060020a03338116600081815260026020908152604080832094871680845294909152808220859055909291907f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b9259085905190815260200160405180910390a35060015b92915050565b60005481565b6000600160a060020a03831615156106ab57600080fd5b600160a060020a0384166000908152600160205260409020548211156106d057600080fd5b600160a060020a038085166000908152600260209081526040808320339094168352929052205482111561070357600080fd5b600160a060020a03841660009081526001602052604090205461072c908363ffffffff61118516565b600160a060020a038086166000908152600160205260408082209390935590851681522054610761908363ffffffff61119716565b600160a060020a038085166000908152600160209081526040808320949094558783168252600281528382203390931682529190915220546107a9908363ffffffff61118516565b600160a060020a03808616600081815260026020908152604080832033861684529091529081902093909355908516917fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef9085905190815260200160405180910390a35060019392505050565b60035433600160a060020a0390811691161461083157600080fd5b6108438164e8d4a50fff600180610a43565b50565b601281565b60066020526000908152604090205460ff1681565b600160a060020a03331660009081526001602052604081205482111561088557600080fd5b60005482111561089457600080fd5b5033600160a060020a0381166000818152600160205260408082208054869003905581548590039091557fcc16f5dbb4873280815c1ee09dbd06736cffcc184412cf7a71a0fdb75d397ca59084905190815260200160405180910390a25050565b600160a060020a0333811660009081526002602090815260408083209386168352929052908120548083111561095257600160a060020a033381166000908152600260209081526040808320938816835292905290812055610989565b610962818463ffffffff61118516565b600160a060020a033381166000908152600260209081526040808320938916835292905220555b600160a060020a0333811660008181526002602090815260408083209489168084529490915290819020547f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925915190815260200160405180910390a35060019392505050565b60035433600160a060020a03908116911614610a0a57600080fd5b610a148282610d59565b1515610a1f57600080fd5b6105e682610816565b600160a060020a031660009081526001602052604090205490565b60035433600160a060020a03908116911614610a5e57600080fd5b600160a060020a0384161515610a7357600080fd5b81158015610a7f575080155b15610a8957600092505b600160a060020a0384166000908152600560205260408120848155600101805460ff19168415151761ff00191661010084151502179055831115610b1f5783600160a060020a03167f9a26d7aa8d0b0885c3a5cce1b95072a26bc415306c652f20e7b507c07a3914d5848484604051928352901515602083015215156040808301919091526060909101905180910390a2610b56565b83600160a060020a03167f7e6adfec7e3f286831a0200a754127c171a2da564078722cb97704741bbdb0ea60405160405180910390a25b50505050565b600080600160a060020a0383161515610b7457600080fd5b600160a060020a0383166000908152600560205260409020544290118015610bc15750600160a060020a0383166000908152600560205260409020600190810154610100900460ff161515145b91508115610be85750600160a060020a038216600090815260056020526040902054610bec565b5060005b915091565b60045433600160a060020a03908116911614610c0c57600080fd5b600454600354600160a060020a0391821691167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a3600480546003805473ffffffffffffffffffffffffffffffffffffffff19908116600160a060020a03841617909155169055565b60035433600160a060020a03908116911614610c9a57600080fd5b600160a060020a03821660009081526006602052604090819020805460ff19168315151790557f1419fc91a0d31d7042ea1fc0fb24c255e2c68a9eda9e83715ad768761433a89e908390839051600160a060020a039092168252151560208201526040908101905180910390a15050565b60035433600160a060020a03908116911614610d2657600080fd5b610d308383610d59565b1515610d3b57600080fd5b610d4583826105be565b505050565b600354600160a060020a031681565b600030600160a060020a031683600160a060020a031614151515610d7c57600080fd5b600160a060020a03331660009081526006602052604090205460ff1680610dbb5750600160a060020a03831660009081526006602052604090205460ff165b15610dd157610dca83836111ad565b9050610688565b600160a060020a0333166000908152600560205260409020544290118015610e195750600160a060020a033316600090815260056020526040902060019081015460ff161515145b15610e6d5782600160a060020a031633600160a060020a03167f77c483e4ff749a73be4f6404c2ecea502a159772ef1cd46e475516a4cdf0eb0d8460405190815260200160405180910390a3506000610688565b600160a060020a0383166000908152600560205260409020544290118015610eba5750600160a060020a0383166000908152600560205260409020600190810154610100900460ff161515145b15610f0e5782600160a060020a031633600160a060020a03167f9afa4bbee84237d6edfd62a23e6fe062ff3073a421c564307d695b24b5e50d738460405190815260200160405180910390a3506000610688565b610dca83836111ad565b60035433600160a060020a03908116911614610f3357600080fd5b610843816000806000610a43565b6005602052600090815260409020805460019091015460ff8082169161010090041683565b600454600160a060020a031681565b600160a060020a033381166000908152600260209081526040808320938616835292905290812054610fad908363ffffffff61119716565b600160a060020a0333811660008181526002602090815260408083209489168084529490915290819020849055919290917f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92591905190815260200160405180910390a350600192915050565b600160a060020a03918216600090815260026020908152604080832093909416825291909152205490565b60008061105033610b5c565b915091509091565b600080600160a060020a038316151561107057600080fd5b600160a060020a0383166000908152600560205260409020544290118015610bc15750600160a060020a038316600090815260056020526040902060019081015460ff1615151491508115610be85750600160a060020a038216600090815260056020526040902054610bec565b60035433600160a060020a039081169116146110f957600080fd5b600160a060020a038116151561110e57600080fd5b600354600160a060020a0380831691167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a36004805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b60008061105033611058565b60008282111561119157fe5b50900390565b6000828201838110156111a657fe5b9392505050565b6000600160a060020a03831615156111c457600080fd5b600160a060020a0333166000908152600160205260409020548211156111e957600080fd5b600160a060020a033316600090815260016020526040902054611212908363ffffffff61118516565b600160a060020a033381166000908152600160205260408082209390935590851681522054611247908363ffffffff61119716565b600160a060020a0380851660008181526001602052604090819020939093559133909116907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef9085905190815260200160405180910390a3506001929150505600a165627a7a723058208e915161962b5078452450b2ab04ad981e0f25dfa77687187c263eb550f3f5990029"
}