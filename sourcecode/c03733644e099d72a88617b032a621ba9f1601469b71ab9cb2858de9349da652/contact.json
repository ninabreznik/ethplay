{
  "address": "0xd1285c5d340f07d1d897f96c6e149dd652fd1a73",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "MatchingMarket",
  "compilerVersion": "v0.4.24+commit.e67f0147",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2019-01-05\n*/\n\npragma solidity ^0.4.18;\n\ncontract DSAuthority {\n    function canCall(\n        address src, address dst, bytes4 sig\n    ) public view returns (bool);\n}\n\ncontract DSAuthEvents {\n    event LogSetAuthority (address indexed authority);\n    event LogSetOwner     (address indexed owner);\n}\n\ncontract DSAuth is DSAuthEvents {\n    DSAuthority  public  authority;\n    address      public  owner;\n\n    function DSAuth() public {\n        owner = msg.sender;\n        LogSetOwner(msg.sender);\n    }\n\n    function setOwner(address owner_)\n        public\n        auth\n    {\n        owner = owner_;\n        LogSetOwner(owner);\n    }\n\n    function setAuthority(DSAuthority authority_)\n        public\n        auth\n    {\n        authority = authority_;\n        LogSetAuthority(authority);\n    }\n\n    modifier auth {\n        require(isAuthorized(msg.sender, msg.sig));\n        _;\n    }\n\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else if (authority == DSAuthority(0)) {\n            return false;\n        } else {\n            return authority.canCall(src, this, sig);\n        }\n    }\n}\n\ncontract DSMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x);\n    }\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x);\n    }\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n\n    function min(uint x, uint y) internal pure returns (uint z) {\n        return x <= y ? x : y;\n    }\n    function max(uint x, uint y) internal pure returns (uint z) {\n        return x >= y ? x : y;\n    }\n    function imin(int x, int y) internal pure returns (int z) {\n        return x <= y ? x : y;\n    }\n    function imax(int x, int y) internal pure returns (int z) {\n        return x >= y ? x : y;\n    }\n\n    uint constant WAD = 10 ** 18;\n    uint constant RAY = 10 ** 27;\n\n    function wmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n    function rmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    // This famous algorithm is called \"exponentiation by squaring\"\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\n    //\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\n    //\n    // These facts are why it works:\n    //\n    //  If n is even, then x^n = (x^2)^(n/2).\n    //  If n is odd,  then x^n = x * x^(n-1),\n    //   and applying the equation for even x gives\n    //    x^n = x * (x^2)^((n-1) / 2).\n    //\n    //  Also, EVM division is flooring and\n    //    floor[(n-1) / 2] = floor[n / 2].\n    //\n    function rpow(uint x, uint n) internal pure returns (uint z) {\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n}\n\ncontract ERC20Events {\n    event Approval(address indexed src, address indexed guy, uint wad);\n    event Transfer(address indexed src, address indexed dst, uint wad);\n}\n\ncontract ERC20 is ERC20Events {\n    function totalSupply() public view returns (uint);\n    function balanceOf(address guy) public view returns (uint);\n    function allowance(address src, address guy) public view returns (uint);\n\n    function approve(address guy, uint wad) public returns (bool);\n    function transfer(address dst, uint wad) public returns (bool);\n    function transferFrom(\n        address src, address dst, uint wad\n    ) public returns (bool);\n}\n\ncontract EventfulMarket {\n    event LogItemUpdate(uint id);\n    event LogTrade(uint pay_amt, address indexed pay_gem,\n                   uint buy_amt, address indexed buy_gem);\n\n    event LogMake(\n        bytes32  indexed  id,\n        bytes32  indexed  pair,\n        address  indexed  maker,\n        ERC20             pay_gem,\n        ERC20             buy_gem,\n        uint128           pay_amt,\n        uint128           buy_amt,\n        uint64            timestamp\n    );\n\n    event LogBump(\n        bytes32  indexed  id,\n        bytes32  indexed  pair,\n        address  indexed  maker,\n        ERC20             pay_gem,\n        ERC20             buy_gem,\n        uint128           pay_amt,\n        uint128           buy_amt,\n        uint64            timestamp\n    );\n\n    event LogTake(\n        bytes32           id,\n        bytes32  indexed  pair,\n        address  indexed  maker,\n        ERC20             pay_gem,\n        ERC20             buy_gem,\n        address  indexed  taker,\n        uint128           take_amt,\n        uint128           give_amt,\n        uint64            timestamp\n    );\n\n    event LogKill(\n        bytes32  indexed  id,\n        bytes32  indexed  pair,\n        address  indexed  maker,\n        ERC20             pay_gem,\n        ERC20             buy_gem,\n        uint128           pay_amt,\n        uint128           buy_amt,\n        uint64            timestamp\n    );\n}\n\ncontract SimpleMarket is EventfulMarket, DSMath {\n\n    uint public last_offer_id;\n\n    mapping (uint => OfferInfo) public offers;\n\n    bool locked;\n\n    struct OfferInfo {\n        uint     pay_amt;\n        ERC20    pay_gem;\n        uint     buy_amt;\n        ERC20    buy_gem;\n        address  owner;\n        uint64   timestamp;\n    }\n\n    modifier can_buy(uint id) {\n        require(isActive(id));\n        _;\n    }\n\n    modifier can_cancel(uint id) {\n        require(isActive(id));\n        require(getOwner(id) == msg.sender);\n        _;\n    }\n\n    modifier can_offer {\n        _;\n    }\n\n    modifier synchronized {\n        require(!locked);\n        locked = true;\n        _;\n        locked = false;\n    }\n\n    function isActive(uint id) public constant returns (bool active) {\n        return offers[id].timestamp > 0;\n    }\n\n    function getOwner(uint id) public constant returns (address owner) {\n        return offers[id].owner;\n    }\n\n    function getOffer(uint id) public constant returns (uint, ERC20, uint, ERC20) {\n      var offer = offers[id];\n      return (offer.pay_amt, offer.pay_gem,\n              offer.buy_amt, offer.buy_gem);\n    }\n\n    // ---- Public entrypoints ---- //\n\n    function bump(bytes32 id_)\n        public\n        can_buy(uint256(id_))\n    {\n        var id = uint256(id_);\n        LogBump(\n            id_,\n            keccak256(offers[id].pay_gem, offers[id].buy_gem),\n            offers[id].owner,\n            offers[id].pay_gem,\n            offers[id].buy_gem,\n            uint128(offers[id].pay_amt),\n            uint128(offers[id].buy_amt),\n            offers[id].timestamp\n        );\n    }\n\n    // Accept given `quantity` of an offer. Transfers funds from caller to\n    // offer maker, and from market to caller.\n    function buy(uint id, uint quantity)\n        public\n        can_buy(id)\n        synchronized\n        returns (bool)\n    {\n        OfferInfo memory offer = offers[id];\n        uint spend = mul(quantity, offer.buy_amt) / offer.pay_amt;\n\n        require(uint128(spend) == spend);\n        require(uint128(quantity) == quantity);\n\n        // For backwards semantic compatibility.\n        if (quantity == 0 || spend == 0 ||\n            quantity > offer.pay_amt || spend > offer.buy_amt)\n        {\n            return false;\n        }\n\n        offers[id].pay_amt = sub(offer.pay_amt, quantity);\n        offers[id].buy_amt = sub(offer.buy_amt, spend);\n        require( offer.buy_gem.transferFrom(msg.sender, offer.owner, spend) );\n        require( offer.pay_gem.transfer(msg.sender, quantity) );\n\n        LogItemUpdate(id);\n        LogTake(\n            bytes32(id),\n            keccak256(offer.pay_gem, offer.buy_gem),\n            offer.owner,\n            offer.pay_gem,\n            offer.buy_gem,\n            msg.sender,\n            uint128(quantity),\n            uint128(spend),\n            uint64(now)\n        );\n        LogTrade(quantity, offer.pay_gem, spend, offer.buy_gem);\n\n        if (offers[id].pay_amt == 0) {\n          delete offers[id];\n        }\n\n        return true;\n    }\n\n    // Cancel an offer. Refunds offer maker.\n    function cancel(uint id)\n        public\n        can_cancel(id)\n        synchronized\n        returns (bool success)\n    {\n        // read-only offer. Modify an offer by directly accessing offers[id]\n        OfferInfo memory offer = offers[id];\n        delete offers[id];\n\n        require( offer.pay_gem.transfer(offer.owner, offer.pay_amt) );\n\n        LogItemUpdate(id);\n        LogKill(\n            bytes32(id),\n            keccak256(offer.pay_gem, offer.buy_gem),\n            offer.owner,\n            offer.pay_gem,\n            offer.buy_gem,\n            uint128(offer.pay_amt),\n            uint128(offer.buy_amt),\n            uint64(now)\n        );\n\n        success = true;\n    }\n\n    function kill(bytes32 id)\n        public\n    {\n        require(cancel(uint256(id)));\n    }\n\n    function make(\n        ERC20    pay_gem,\n        ERC20    buy_gem,\n        uint128  pay_amt,\n        uint128  buy_amt\n    )\n        public\n        returns (bytes32 id)\n    {\n        return bytes32(offer(pay_amt, pay_gem, buy_amt, buy_gem));\n    }\n\n    // Make a new offer. Takes funds from the caller into market escrow.\n    function offer(uint pay_amt, ERC20 pay_gem, uint buy_amt, ERC20 buy_gem)\n        public\n        can_offer\n        synchronized\n        returns (uint id)\n    {\n        require(uint128(pay_amt) == pay_amt);\n        require(uint128(buy_amt) == buy_amt);\n        require(pay_amt > 0);\n        require(pay_gem != ERC20(0x0));\n        require(buy_amt > 0);\n        require(buy_gem != ERC20(0x0));\n        require(pay_gem != buy_gem);\n\n        OfferInfo memory info;\n        info.pay_amt = pay_amt;\n        info.pay_gem = pay_gem;\n        info.buy_amt = buy_amt;\n        info.buy_gem = buy_gem;\n        info.owner = msg.sender;\n        info.timestamp = uint64(now);\n        id = _next_id();\n        offers[id] = info;\n\n        require( pay_gem.transferFrom(msg.sender, this, pay_amt) );\n\n        LogItemUpdate(id);\n        LogMake(\n            bytes32(id),\n            keccak256(pay_gem, buy_gem),\n            msg.sender,\n            pay_gem,\n            buy_gem,\n            uint128(pay_amt),\n            uint128(buy_amt),\n            uint64(now)\n        );\n    }\n\n    function take(bytes32 id, uint128 maxTakeAmount)\n        public\n    {\n        require(buy(uint256(id), maxTakeAmount));\n    }\n\n    function _next_id()\n        internal\n        returns (uint)\n    {\n        last_offer_id++; return last_offer_id;\n    }\n}\n\n// Simple Market with a market lifetime. When the close_time has been reached,\n// offers can only be cancelled (offer and buy will throw).\n\ncontract ExpiringMarket is DSAuth, SimpleMarket {\n    uint64 public close_time;\n    bool public stopped;\n\n    // after close_time has been reached, no new offers are allowed\n    modifier can_offer {\n        require(!isClosed());\n        _;\n    }\n\n    // after close, no new buys are allowed\n    modifier can_buy(uint id) {\n        require(isActive(id));\n        require(!isClosed());\n        _;\n    }\n\n    // after close, anyone can cancel an offer\n    modifier can_cancel(uint id) {\n        require(isActive(id));\n        require(isClosed() || (msg.sender == getOwner(id)));\n        _;\n    }\n\n    function ExpiringMarket(uint64 _close_time)\n        public\n    {\n        close_time = _close_time;\n    }\n\n    function isClosed() public constant returns (bool closed) {\n        return stopped || getTime() > close_time;\n    }\n\n    function getTime() public constant returns (uint64) {\n        return uint64(now);\n    }\n\n    function stop() public auth {\n        stopped = true;\n    }\n}\n\ncontract DSNote {\n    event LogNote(\n        bytes4   indexed  sig,\n        address  indexed  guy,\n        bytes32  indexed  foo,\n        bytes32  indexed  bar,\n        uint              wad,\n        bytes             fax\n    ) anonymous;\n\n    modifier note {\n        bytes32 foo;\n        bytes32 bar;\n\n        assembly {\n            foo := calldataload(4)\n            bar := calldataload(36)\n        }\n\n        LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\n\n        _;\n    }\n}\n\ncontract MatchingEvents {\n    event LogBuyEnabled(bool isEnabled);\n    event LogMinSell(address pay_gem, uint min_amount);\n    event LogMatchingEnabled(bool isEnabled);\n    event LogUnsortedOffer(uint id);\n    event LogSortedOffer(uint id);\n    event LogAddTokenPairWhitelist(ERC20 baseToken, ERC20 quoteToken);\n    event LogRemTokenPairWhitelist(ERC20 baseToken, ERC20 quoteToken);\n    event LogInsert(address keeper, uint id);\n    event LogDelete(address keeper, uint id);\n}\n\ncontract MatchingMarket is MatchingEvents, ExpiringMarket, DSNote {\n    bool public buyEnabled = true;      //buy enabled\n    bool public matchingEnabled = true; //true: enable matching,\n                                         //false: revert to expiring market\n    struct sortInfo {\n        uint next;  //points to id of next higher offer\n        uint prev;  //points to id of previous lower offer\n        uint delb;  //the blocknumber where this entry was marked for delete\n    }\n    mapping(uint => sortInfo) public _rank;                     //doubly linked lists of sorted offer ids\n    mapping(address => mapping(address => uint)) public _best;  //id of the highest offer for a token pair\n    mapping(address => mapping(address => uint)) public _span;  //number of offers stored for token pair in sorted orderbook\n    mapping(address => uint) public _dust;                      //minimum sell amount for a token to avoid dust offers\n    mapping(uint => uint) public _near;         //next unsorted offer id\n    mapping(bytes32 => bool) public _menu;      //whitelist tracking which token pairs can be traded\n    uint _head;                                 //first unsorted offer id\n\n    //check if token pair is enabled\n    modifier isWhitelist(ERC20 buy_gem, ERC20 pay_gem) {\n        require(_menu[keccak256(buy_gem, pay_gem)] || _menu[keccak256(pay_gem, buy_gem)]);\n        _;\n    }\n\n    function MatchingMarket(uint64 close_time) ExpiringMarket(close_time) public {\n    }\n\n    // ---- Public entrypoints ---- //\n\n    function make(\n        ERC20    pay_gem,\n        ERC20    buy_gem,\n        uint128  pay_amt,\n        uint128  buy_amt\n    )\n        public\n        returns (bytes32)\n    {\n        return bytes32(offer(pay_amt, pay_gem, buy_amt, buy_gem));\n    }\n\n    function take(bytes32 id, uint128 maxTakeAmount) public {\n        require(buy(uint256(id), maxTakeAmount));\n    }\n\n    function kill(bytes32 id) public {\n        require(cancel(uint256(id)));\n    }\n\n    // Make a new offer. Takes funds from the caller into market escrow.\n    //\n    // If matching is enabled:\n    //     * creates new offer without putting it in\n    //       the sorted list.\n    //     * available to authorized contracts only!\n    //     * keepers should call insert(id,pos)\n    //       to put offer in the sorted list.\n    //\n    // If matching is disabled:\n    //     * calls expiring market's offer().\n    //     * available to everyone without authorization.\n    //     * no sorting is done.\n    //\n    function offer(\n        uint pay_amt,    //maker (ask) sell how much\n        ERC20 pay_gem,   //maker (ask) sell which token\n        uint buy_amt,    //taker (ask) buy how much\n        ERC20 buy_gem    //taker (ask) buy which token\n    )\n        public\n        isWhitelist(pay_gem, buy_gem)\n        /* NOT synchronized!!! */\n        returns (uint)\n    {\n        var fn = matchingEnabled ? _offeru : super.offer;\n        return fn(pay_amt, pay_gem, buy_amt, buy_gem);\n    }\n\n    // Make a new offer. Takes funds from the caller into market escrow.\n    function offer(\n        uint pay_amt,    //maker (ask) sell how much\n        ERC20 pay_gem,   //maker (ask) sell which token\n        uint buy_amt,    //maker (ask) buy how much\n        ERC20 buy_gem,   //maker (ask) buy which token\n        uint pos         //position to insert offer, 0 should be used if unknown\n    )\n        public\n        isWhitelist(pay_gem, buy_gem)\n        /*NOT synchronized!!! */\n        can_offer\n        returns (uint)\n    {\n        return offer(pay_amt, pay_gem, buy_amt, buy_gem, pos, false);\n    }\n\n    function offer(\n        uint pay_amt,    //maker (ask) sell how much\n        ERC20 pay_gem,   //maker (ask) sell which token\n        uint buy_amt,    //maker (ask) buy how much\n        ERC20 buy_gem,   //maker (ask) buy which token\n        uint pos,        //position to insert offer, 0 should be used if unknown\n        bool rounding    //match \"close enough\" orders?\n    )\n        public\n        isWhitelist(pay_gem, buy_gem)\n        /*NOT synchronized!!! */\n        can_offer\n        returns (uint)\n    {\n        require(_dust[pay_gem] <= pay_amt);\n\n        if (matchingEnabled) {\n          return _matcho(pay_amt, pay_gem, buy_amt, buy_gem, pos, rounding);\n        }\n        return super.offer(pay_amt, pay_gem, buy_amt, buy_gem);\n    }\n\n    //Transfers funds from caller to offer maker, and from market to caller.\n    function buy(uint id, uint amount)\n        public\n        /*NOT synchronized!!! */\n        can_buy(id)\n        returns (bool)\n    {\n        var fn = matchingEnabled ? _buys : super.buy;\n        return fn(id, amount);\n    }\n\n    // Cancel an offer. Refunds offer maker.\n    function cancel(uint id)\n        public\n        /*NOT synchronized!!! */\n        can_cancel(id)\n        returns (bool success)\n    {\n        if (matchingEnabled) {\n            if (isOfferSorted(id)) {\n                require(_unsort(id));\n            } else {\n                require(_hide(id));\n            }\n        }\n        return super.cancel(id);    //delete the offer.\n    }\n\n    //insert offer into the sorted list\n    //keepers need to use this function\n    function insert(\n        uint id,   //maker (ask) id\n        uint pos   //position to insert into\n    )\n        public\n        returns (bool)\n    {\n        require(!isOfferSorted(id));    //make sure offers[id] is not yet sorted\n        require(isActive(id));          //make sure offers[id] is active\n\n        _hide(id);                      //remove offer from unsorted offers list\n        _sort(id, pos);                 //put offer into the sorted offers list\n        LogInsert(msg.sender, id);\n        return true;\n    }\n\n    //deletes _rank [id]\n    //  Function should be called by keepers.\n    function del_rank(uint id)\n        public\n    returns (bool)\n    {\n        require(!isActive(id) && _rank[id].delb != 0 && _rank[id].delb < block.number - 10);\n        delete _rank[id];\n        LogDelete(msg.sender, id);\n        return true;\n    }\n\n    //returns true if token is succesfully added to whitelist\n    //  Function is used to add a token pair to the whitelist\n    //  All incoming offers are checked against the whitelist.\n    function addTokenPairWhitelist(\n        ERC20 baseToken,\n        ERC20 quoteToken\n    )\n        public\n        auth\n        note\n    returns (bool)\n    {\n        require(!isTokenPairWhitelisted(baseToken, quoteToken));\n        require(address(baseToken) != 0x0 && address(quoteToken) != 0x0);\n\n        _menu[keccak256(baseToken, quoteToken)] = true;\n        LogAddTokenPairWhitelist(baseToken, quoteToken);\n        return true;\n    }\n\n    //returns true if token is successfully removed from whitelist\n    //  Function is used to remove a token pair from the whitelist.\n    //  All incoming offers are checked against the whitelist.\n    function remTokenPairWhitelist(\n        ERC20 baseToken,\n        ERC20 quoteToken\n    )\n        public\n        auth\n        note\n    returns (bool)\n    {\n        require(isTokenPairWhitelisted(baseToken, quoteToken));\n\n        delete _menu[keccak256(baseToken, quoteToken)];\n        delete _menu[keccak256(quoteToken, baseToken)];\n        LogRemTokenPairWhitelist(baseToken, quoteToken);\n        return true;\n    }\n\n    function isTokenPairWhitelisted(\n        ERC20 baseToken,\n        ERC20 quoteToken\n    )\n        public\n        constant\n        returns (bool)\n    {\n        return (_menu[keccak256(baseToken, quoteToken)] || _menu[keccak256(quoteToken, baseToken)]);\n    }\n\n    //set the minimum sell amount for a token\n    //    Function is used to avoid \"dust offers\" that have\n    //    very small amount of tokens to sell, and it would\n    //    cost more gas to accept the offer, than the value\n    //    of tokens received.\n    function setMinSell(\n        ERC20 pay_gem,     //token to assign minimum sell amount to\n        uint dust          //maker (ask) minimum sell amount\n    )\n        public\n        auth\n        note\n        returns (bool)\n    {\n        _dust[pay_gem] = dust;\n        LogMinSell(pay_gem, dust);\n        return true;\n    }\n\n    //returns the minimum sell amount for an offer\n    function getMinSell(\n        ERC20 pay_gem      //token for which minimum sell amount is queried\n    )\n        public\n        constant\n        returns (uint)\n    {\n        return _dust[pay_gem];\n    }\n\n    //set buy functionality enabled/disabled\n    function setBuyEnabled(bool buyEnabled_) public auth returns (bool) {\n        buyEnabled = buyEnabled_;\n        LogBuyEnabled(buyEnabled);\n        return true;\n    }\n\n    //set matching enabled/disabled\n    //    If matchingEnabled true(default), then inserted offers are matched.\n    //    Except the ones inserted by contracts, because those end up\n    //    in the unsorted list of offers, that must be later sorted by\n    //    keepers using insert().\n    //    If matchingEnabled is false then MatchingMarket is reverted to ExpiringMarket,\n    //    and matching is not done, and sorted lists are disabled.\n    function setMatchingEnabled(bool matchingEnabled_) public auth returns (bool) {\n        matchingEnabled = matchingEnabled_;\n        LogMatchingEnabled(matchingEnabled);\n        return true;\n    }\n\n    //return the best offer for a token pair\n    //      the best offer is the lowest one if it's an ask,\n    //      and highest one if it's a bid offer\n    function getBestOffer(ERC20 sell_gem, ERC20 buy_gem) public constant returns(uint) {\n        return _best[sell_gem][buy_gem];\n    }\n\n    //return the next worse offer in the sorted list\n    //      the worse offer is the higher one if its an ask,\n    //      a lower one if its a bid offer,\n    //      and in both cases the newer one if they're equal.\n    function getWorseOffer(uint id) public constant returns(uint) {\n        return _rank[id].prev;\n    }\n\n    //return the next better offer in the sorted list\n    //      the better offer is in the lower priced one if its an ask,\n    //      the next higher priced one if its a bid offer\n    //      and in both cases the older one if they're equal.\n    function getBetterOffer(uint id) public constant returns(uint) {\n\n        return _rank[id].next;\n    }\n\n    //return the amount of better offers for a token pair\n    function getOfferCount(ERC20 sell_gem, ERC20 buy_gem) public constant returns(uint) {\n        return _span[sell_gem][buy_gem];\n    }\n\n    //get the first unsorted offer that was inserted by a contract\n    //      Contracts can't calculate the insertion position of their offer because it is not an O(1) operation.\n    //      Their offers get put in the unsorted list of offers.\n    //      Keepers can calculate the insertion position offchain and pass it to the insert() function to insert\n    //      the unsorted offer into the sorted list. Unsorted offers will not be matched, but can be bought with buy().\n    function getFirstUnsortedOffer() public constant returns(uint) {\n        return _head;\n    }\n\n    //get the next unsorted offer\n    //      Can be used to cycle through all the unsorted offers.\n    function getNextUnsortedOffer(uint id) public constant returns(uint) {\n        return _near[id];\n    }\n\n    function isOfferSorted(uint id) public constant returns(bool) {\n        return _rank[id].next != 0\n               || _rank[id].prev != 0\n               || _best[offers[id].pay_gem][offers[id].buy_gem] == id;\n    }\n\n    function sellAllAmount(ERC20 pay_gem, uint pay_amt, ERC20 buy_gem, uint min_fill_amount)\n        public\n        returns (uint fill_amt)\n    {\n        uint offerId;\n        while (pay_amt > 0) {                           //while there is amount to sell\n            offerId = getBestOffer(buy_gem, pay_gem);   //Get the best offer for the token pair\n            require(offerId != 0);                      //Fails if there are not more offers\n\n            // There is a chance that pay_amt is smaller than 1 wei of the other token\n            if (pay_amt * 1 ether < wdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)) {\n                break;                                  //We consider that all amount is sold\n            }\n            if (pay_amt >= offers[offerId].buy_amt) {                       //If amount to sell is higher or equal than current offer amount to buy\n                fill_amt = add(fill_amt, offers[offerId].pay_amt);          //Add amount bought to acumulator\n                pay_amt = sub(pay_amt, offers[offerId].buy_amt);            //Decrease amount to sell\n                take(bytes32(offerId), uint128(offers[offerId].pay_amt));   //We take the whole offer\n            } else { // if lower\n                var baux = rmul(pay_amt * 10 ** 9, rdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)) / 10 ** 9;\n                fill_amt = add(fill_amt, baux);         //Add amount bought to acumulator\n                take(bytes32(offerId), uint128(baux));  //We take the portion of the offer that we need\n                pay_amt = 0;                            //All amount is sold\n            }\n        }\n        require(fill_amt >= min_fill_amount);\n    }\n\n    function buyAllAmount(ERC20 buy_gem, uint buy_amt, ERC20 pay_gem, uint max_fill_amount)\n        public\n        returns (uint fill_amt)\n    {\n        uint offerId;\n        while (buy_amt > 0) {                           //Meanwhile there is amount to buy\n            offerId = getBestOffer(buy_gem, pay_gem);   //Get the best offer for the token pair\n            require(offerId != 0);\n\n            // There is a chance that buy_amt is smaller than 1 wei of the other token\n            if (buy_amt * 1 ether < wdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)) {\n                break;                                  //We consider that all amount is sold\n            }\n            if (buy_amt >= offers[offerId].pay_amt) {                       //If amount to buy is higher or equal than current offer amount to sell\n                fill_amt = add(fill_amt, offers[offerId].buy_amt);          //Add amount sold to acumulator\n                buy_amt = sub(buy_amt, offers[offerId].pay_amt);            //Decrease amount to buy\n                take(bytes32(offerId), uint128(offers[offerId].pay_amt));   //We take the whole offer\n            } else {                                                        //if lower\n                fill_amt = add(fill_amt, rmul(buy_amt * 10 ** 9, rdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)) / 10 ** 9); //Add amount sold to acumulator\n                take(bytes32(offerId), uint128(buy_amt));                   //We take the portion of the offer that we need\n                buy_amt = 0;                                                //All amount is bought\n            }\n        }\n        require(fill_amt <= max_fill_amount);\n    }\n\n    function getBuyAmount(ERC20 buy_gem, ERC20 pay_gem, uint pay_amt) public constant returns (uint fill_amt) {\n        var offerId = getBestOffer(buy_gem, pay_gem);           //Get best offer for the token pair\n        while (pay_amt > offers[offerId].buy_amt) {\n            fill_amt = add(fill_amt, offers[offerId].pay_amt);  //Add amount to buy accumulator\n            pay_amt = sub(pay_amt, offers[offerId].buy_amt);    //Decrease amount to pay\n            if (pay_amt > 0) {                                  //If we still need more offers\n                offerId = getWorseOffer(offerId);               //We look for the next best offer\n                require(offerId != 0);                          //Fails if there are not enough offers to complete\n            }\n        }\n        fill_amt = add(fill_amt, rmul(pay_amt * 10 ** 9, rdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)) / 10 ** 9); //Add proportional amount of last offer to buy accumulator\n    }\n\n    function getPayAmount(ERC20 pay_gem, ERC20 buy_gem, uint buy_amt) public constant returns (uint fill_amt) {\n        var offerId = getBestOffer(buy_gem, pay_gem);           //Get best offer for the token pair\n        while (buy_amt > offers[offerId].pay_amt) {\n            fill_amt = add(fill_amt, offers[offerId].buy_amt);  //Add amount to pay accumulator\n            buy_amt = sub(buy_amt, offers[offerId].pay_amt);    //Decrease amount to buy\n            if (buy_amt > 0) {                                  //If we still need more offers\n                offerId = getWorseOffer(offerId);               //We look for the next best offer\n                require(offerId != 0);                          //Fails if there are not enough offers to complete\n            }\n        }\n        fill_amt = add(fill_amt, rmul(buy_amt * 10 ** 9, rdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)) / 10 ** 9); //Add proportional amount of last offer to pay accumulator\n    }\n\n    // ---- Internal Functions ---- //\n\n    function _buys(uint id, uint amount)\n        internal\n        returns (bool)\n    {\n        require(buyEnabled);\n\n        if (amount == offers[id].pay_amt && isOfferSorted(id)) {\n            //offers[id] must be removed from sorted list because all of it is bought\n            _unsort(id);\n        }\n        require(super.buy(id, amount));\n        return true;\n    }\n\n    //find the id of the next higher offer after offers[id]\n    function _find(uint id)\n        internal\n        view\n        returns (uint)\n    {\n        require( id > 0 );\n\n        address buy_gem = address(offers[id].buy_gem);\n        address pay_gem = address(offers[id].pay_gem);\n        uint top = _best[pay_gem][buy_gem];\n        uint old_top = 0;\n\n        // Find the larger-than-id order whose successor is less-than-id.\n        while (top != 0 && _isPricedLtOrEq(id, top)) {\n            old_top = top;\n            top = _rank[top].prev;\n        }\n        return old_top;\n    }\n\n    //find the id of the next higher offer after offers[id]\n    function _findpos(uint id, uint pos)\n        internal\n        view\n    returns (uint)\n    {\n        require(id > 0);\n\n        // Look for an active order.\n        while (pos != 0 && !isActive(pos)) {\n            pos = _rank[pos].prev;\n        }\n\n        if (pos == 0) {\n            //if we got to the end of list without a single active offer\n            return _find(id);\n\n        } else {\n            // if we did find a nearby active offer\n            // Walk the order book down from there...\n            if(_isPricedLtOrEq(id, pos)) {\n                uint old_pos;\n\n                // Guaranteed to run at least once because of\n                // the prior if statements.\n                while (pos != 0 && _isPricedLtOrEq(id, pos)) {\n                    old_pos = pos;\n                    pos = _rank[pos].prev;\n                }\n                return old_pos;\n\n            // ...or walk it up.\n            } else {\n                while (pos != 0 && !_isPricedLtOrEq(id, pos)) {\n                    pos = _rank[pos].next;\n                }\n                return pos;\n            }\n        }\n    }\n\n    //return true if offers[low] priced less than or equal to offers[high]\n    function _isPricedLtOrEq(\n        uint low,   //lower priced offer's id\n        uint high   //higher priced offer's id\n    )\n        internal\n        view\n        returns (bool)\n    {\n        return mul(offers[low].buy_amt, offers[high].pay_amt)\n          >= mul(offers[high].buy_amt, offers[low].pay_amt);\n    }\n\n    //these variables are global only because of solidity local variable limit\n\n    //match offers with taker offer, and execute token transactions\n    function _matcho(\n        uint t_pay_amt,    //taker sell how much\n        ERC20 t_pay_gem,   //taker sell which token\n        uint t_buy_amt,    //taker buy how much\n        ERC20 t_buy_gem,   //taker buy which token\n        uint pos,          //position id\n        bool rounding      //match \"close enough\" orders?\n    )\n        internal\n        returns (uint id)\n    {\n        uint best_maker_id;    //highest maker id\n        uint t_buy_amt_old;    //taker buy how much saved\n        uint m_buy_amt;        //maker offer wants to buy this much token\n        uint m_pay_amt;        //maker offer wants to sell this much token\n\n        // there is at least one offer stored for token pair\n        while (_best[t_buy_gem][t_pay_gem] > 0) {\n            best_maker_id = _best[t_buy_gem][t_pay_gem];\n            m_buy_amt = offers[best_maker_id].buy_amt;\n            m_pay_amt = offers[best_maker_id].pay_amt;\n\n            // Ugly hack to work around rounding errors. Based on the idea that\n            // the furthest the amounts can stray from their \"true\" values is 1.\n            // Ergo the worst case has t_pay_amt and m_pay_amt at +1 away from\n            // their \"correct\" values and m_buy_amt and t_buy_amt at -1.\n            // Since (c - 1) * (d - 1) > (a + 1) * (b + 1) is equivalent to\n            // c * d > a * b + a + b + c + d, we write...\n            if (mul(m_buy_amt, t_buy_amt) > mul(t_pay_amt, m_pay_amt) +\n                (rounding ? m_buy_amt + t_buy_amt + t_pay_amt + m_pay_amt : 0))\n            {\n                break;\n            }\n            // ^ The `rounding` parameter is a compromise borne of a couple days\n            // of discussion.\n\n            buy(best_maker_id, min(m_pay_amt, t_buy_amt));\n            t_buy_amt_old = t_buy_amt;\n            t_buy_amt = sub(t_buy_amt, min(m_pay_amt, t_buy_amt));\n            t_pay_amt = mul(t_buy_amt, t_pay_amt) / t_buy_amt_old;\n\n            if (t_pay_amt == 0 || t_buy_amt == 0) {\n                break;\n            }\n        }\n\n        if (t_buy_amt > 0 && t_pay_amt > 0) {\n            //new offer should be created\n            id = super.offer(t_pay_amt, t_pay_gem, t_buy_amt, t_buy_gem);\n            //insert offer into the sorted list\n            _sort(id, pos);\n        }\n    }\n\n    // Make a new offer without putting it in the sorted list.\n    // Takes funds from the caller into market escrow.\n    // ****Available to authorized contracts only!**********\n    // Keepers should call insert(id,pos) to put offer in the sorted list.\n    function _offeru(\n        uint pay_amt,      //maker (ask) sell how much\n        ERC20 pay_gem,     //maker (ask) sell which token\n        uint buy_amt,      //maker (ask) buy how much\n        ERC20 buy_gem      //maker (ask) buy which token\n    )\n        internal\n        /*NOT synchronized!!! */\n        returns (uint id)\n    {\n        require(_dust[pay_gem] <= pay_amt);\n        id = super.offer(pay_amt, pay_gem, buy_amt, buy_gem);\n        _near[id] = _head;\n        _head = id;\n        LogUnsortedOffer(id);\n    }\n\n    //put offer into the sorted list\n    function _sort(\n        uint id,    //maker (ask) id\n        uint pos    //position to insert into\n    )\n        internal\n    {\n        require(isActive(id));\n\n        address buy_gem = address(offers[id].buy_gem);\n        address pay_gem = address(offers[id].pay_gem);\n        uint prev_id;                                      //maker (ask) id\n\n        if (pos == 0 || !isOfferSorted(pos)) {\n            pos = _find(id);\n        } else {\n            pos = _findpos(id, pos);\n\n            //if user has entered a `pos` that belongs to another currency pair\n            //we start from scratch\n            if(pos != 0 && (offers[pos].pay_gem != offers[id].pay_gem\n                      || offers[pos].buy_gem != offers[id].buy_gem))\n            {\n                pos = 0;\n                pos=_find(id);\n            }\n        }\n\n\n        //requirement below is satisfied by statements above\n        //require(pos == 0 || isOfferSorted(pos));\n\n\n        if (pos != 0) {                                    //offers[id] is not the highest offer\n            //requirement below is satisfied by statements above\n            //require(_isPricedLtOrEq(id, pos));\n            prev_id = _rank[pos].prev;\n            _rank[pos].prev = id;\n            _rank[id].next = pos;\n        } else {                                           //offers[id] is the highest offer\n            prev_id = _best[pay_gem][buy_gem];\n            _best[pay_gem][buy_gem] = id;\n        }\n\n        if (prev_id != 0) {                               //if lower offer does exist\n            //requirement below is satisfied by statements above\n            //require(!_isPricedLtOrEq(id, prev_id));\n            _rank[prev_id].next = id;\n            _rank[id].prev = prev_id;\n        }\n\n        _span[pay_gem][buy_gem]++;\n        LogSortedOffer(id);\n    }\n\n    // Remove offer from the sorted list (does not cancel offer)\n    function _unsort(\n        uint id    //id of maker (ask) offer to remove from sorted list\n    )\n        internal\n        returns (bool)\n    {\n        address buy_gem = address(offers[id].buy_gem);\n        address pay_gem = address(offers[id].pay_gem);\n        require(_span[pay_gem][buy_gem] > 0);\n\n        require(_rank[id].delb == 0 &&                    //assert id is in the sorted list\n                 isOfferSorted(id));\n\n        if (id != _best[pay_gem][buy_gem]) {              // offers[id] is not the highest offer\n            require(_rank[_rank[id].next].prev == id);\n            _rank[_rank[id].next].prev = _rank[id].prev;\n        } else {                                          //offers[id] is the highest offer\n            _best[pay_gem][buy_gem] = _rank[id].prev;\n        }\n\n        if (_rank[id].prev != 0) {                        //offers[id] is not the lowest offer\n            require(_rank[_rank[id].prev].next == id);\n            _rank[_rank[id].prev].next = _rank[id].next;\n        }\n\n        _span[pay_gem][buy_gem]--;\n        _rank[id].delb = block.number;                    //mark _rank[id] for deletion\n        return true;\n    }\n\n    //Hide offer from the unsorted order book (does not cancel offer)\n    function _hide(\n        uint id     //id of maker offer to remove from unsorted list\n    )\n        internal\n        returns (bool)\n    {\n        uint uid = _head;               //id of an offer in unsorted offers list\n        uint pre = uid;                 //id of previous offer in unsorted offers list\n\n        require(!isOfferSorted(id));    //make sure offer id is not in sorted offers list\n\n        if (_head == id) {              //check if offer is first offer in unsorted offers list\n            _head = _near[id];          //set head to new first unsorted offer\n            _near[id] = 0;              //delete order from unsorted order list\n            return true;\n        }\n        while (uid > 0 && uid != id) {  //find offer in unsorted order list\n            pre = uid;\n            uid = _near[uid];\n        }\n        if (uid != id) {                //did not find offer id in unsorted offers list\n            return false;\n        }\n        _near[pre] = _near[id];         //set previous unsorted offer to point to offer after offer id\n        _near[id] = 0;                  //delete order from unsorted order list\n        return true;\n    }\n}",
  "bytecode": "608060405260048054605860020a60ff0219605060020a60ff02199091166a010000000000000000000017166b01000000000000000000000017905534801561004757600080fd5b50604051602080613407833981016040819052905160018054600160a060020a0319163390811790915590918291907fce241d7ca1f669fee44b6fc00b8eba2df3bb514eed0f6f668f8f89096e81ed9490600090a26004805467ffffffffffffffff9092166101000268ffffffffffffffff001990921691909117905550613333806100d46000396000f3006080604052600436106102665763ffffffff7c010000000000000000000000000000000000000000000000000000000060003504166301492a0b811461026b5780630374fc6f146102945780630621b4f6146102cd57806307da68f5146102fb578063093f51981461031257806313af40351461034b578063144a27521461036c57806315e28700146103965780631aa859d0146103bd5780631b33d412146103e45780631d834a1b14610415578063232cae0b146104305780632aed19051461044557806340e58ee51461045f5780634579268a14610477578063467f0b7b146104c057806349606455146104d8578063511fa487146104fc578063557ed1ba1461051d57806361f54a791461054f5780636377ebca14610567578063677170e11461057c57806374c1d7d3146105a357806375f12b21146105ca578063779997c3146105df5780637a9e5e4b146105f75780637ca9429a146106185780638185402b1461063f57806382afd23b1461066d5780638a72ea6a146106855780638af82a2e146106e75780638d7daf95146106fc5780638da5cb5b14610723578063911550f41461075457806391be90c81461076c578063943911bc1461078d57806396d7a9ed146107a5578063a78d4316146107bd578063b4f9b6c8146107d5578063bf7c734e146107ed578063bf7e214f14610811578063c2b6b58c14610826578063c2d526aa1461083b578063c41a360a14610871578063d2b420ce14610889578063d6f15469146108a1578063d6febde8146108bb578063e1a6f014146108d6578063f09ea2a61461090c578063f582d2931461093a578063ff1fd9741461094f575b600080fd5b34801561027757600080fd5b50610280610979565b604080519115158252519081900360200190f35b3480156102a057600080fd5b506102bb600160a060020a0360043581169060243516610991565b60408051918252519081900360200190f35b3480156102d957600080fd5b506102bb600160a060020a0360043581169060243590604435166064356109be565b34801561030757600080fd5b50610310610b03565b005b34801561031e57600080fd5b506102bb600160a060020a03600435811690602435166001608060020a0360443581169060643516610b45565b34801561035757600080fd5b50610310600160a060020a0360043516610b6e565b34801561037857600080fd5b506102bb600160a060020a0360043581169060243516604435610bec565b3480156103a257600080fd5b50610280600160a060020a0360043581169060243516610cb8565b3480156103c957600080fd5b50610280600160a060020a0360043581169060243516610df3565b3480156103f057600080fd5b506102bb600435600160a060020a036024358116906044359060643516608435610f2d565b34801561042157600080fd5b50610280600435602435610fe6565b34801561043c57600080fd5b506102bb611067565b34801561045157600080fd5b50610280600435151561106d565b34801561046b57600080fd5b50610280600435611103565b34801561048357600080fd5b5061048f6004356111b6565b60408051948552600160a060020a039384166020860152848101929092529091166060830152519081900360800190f35b3480156104cc57600080fd5b506102806004356111ec565b3480156104e457600080fd5b506103106004356001608060020a03602435166112a1565b34801561050857600080fd5b506102bb600160a060020a03600435166112c3565b34801561052957600080fd5b506105326112de565b6040805167ffffffffffffffff9092168252519081900360200190f35b34801561055b57600080fd5b506102bb6004356112e2565b34801561057357600080fd5b506105326112f4565b34801561058857600080fd5b506102bb600160a060020a0360043581169060243516611309565b3480156105af57600080fd5b506102bb600160a060020a0360043581169060243516611326565b3480156105d657600080fd5b50610280611343565b3480156105eb57600080fd5b50610310600435611359565b34801561060357600080fd5b50610310600160a060020a0360043516611450565b34801561062457600080fd5b506102bb600160a060020a03600435811690602435166114ca565b34801561064b57600080fd5b506102bb600160a060020a0360043581169060243590604435166064356114f5565b34801561067957600080fd5b5061028060043561161f565b34801561069157600080fd5b5061069d600435611646565b60408051968752600160a060020a039586166020880152868101949094529184166060860152909216608084015267ffffffffffffffff90911660a0830152519081900360c00190f35b3480156106f357600080fd5b506102bb611698565b34801561070857600080fd5b50610280600160a060020a036004358116906024351661169e565b34801561072f57600080fd5b50610738611721565b60408051600160a060020a039092168252519081900360200190f35b34801561076057600080fd5b506102bb600435611730565b34801561077857600080fd5b506102bb600160a060020a0360043516611742565b34801561079957600080fd5b506102bb600435611754565b3480156107b157600080fd5b50610280600435611769565b3480156107c957600080fd5b506102bb60043561177e565b3480156107e157600080fd5b50610310600435611790565b3480156107f957600080fd5b50610280600160a060020a03600435166024356117a7565b34801561081d57600080fd5b5061073861187b565b34801561083257600080fd5b5061028061188a565b34801561084757600080fd5b506108536004356118d1565b60408051938452602084019290925282820152519081900360600190f35b34801561087d57600080fd5b506107386004356118f2565b34801561089557600080fd5b50610280600435611910565b3480156108ad57600080fd5b506102806004351515611981565b3480156108c757600080fd5b50610280600435602435611a15565b3480156108e257600080fd5b506102bb600435600160a060020a03602435811690604435906064351660843560a4351515611a76565b34801561091857600080fd5b506102bb600435600160a060020a036024358116906044359060643516611b83565b34801561094657600080fd5b50610280611c4a565b34801561095b57600080fd5b506102bb600160a060020a0360043581169060243516604435611c61565b6004546b010000000000000000000000900460ff1681565b600160a060020a038083166000908152600660209081526040808320938516835292905220545b92915050565b60008060005b6000861115610aec576109d78588610991565b91508115156109e557600080fd5b600082815260036020526040902060028101549054610a049190611d1a565b86670de0b6b3a7640000021015610a1a57610aec565b6000828152600360205260409020600201548610610a8e57600082815260036020526040902054610a4c908490611d4b565b600083815260036020526040902060020154909350610a6c908790611d5b565b600083815260036020526040902054909650610a899083906112a1565b610ae7565b60008281526003602052604090208054600290910154633b9aca0091610ac09189840291610abb91611d6b565b611d87565b811515610ac957fe5b049050610ad68382611d4b565b9250610ae282826112a1565b600095505b6109c4565b83831015610af957600080fd5b5050949350505050565b610b1933600035600160e060020a031916611db7565b1515610b2457600080fd5b6004805469ff00000000000000000019166901000000000000000000179055565b6000610b65836001608060020a031686846001608060020a031687611b83565b95945050505050565b610b8433600035600160e060020a031916611db7565b1515610b8f57600080fd5b6001805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0383811691909117918290556040519116907fce241d7ca1f669fee44b6fc00b8eba2df3bb514eed0f6f668f8f89096e81ed9490600090a250565b600080610bf98585610991565b90505b600081815260036020526040902060020154831115610c7657600081815260036020526040902054610c2f908390611d4b565b600082815260036020526040902060020154909250610c4f908490611d5b565b92506000831115610c7157610c6381611754565b9050801515610c7157600080fd5b610bfc565b60008181526003602052604090208054600290910154610b65918491633b9aca0091610ca99188840291610abb91611d6b565b811515610cb257fe5b04611d4b565b6000610cd033600035600160e060020a031916611db7565b1515610cdb57600080fd5b60408051348082526020820183815236938301849052600435936024359384938693339360008035600160e060020a031916949092606082018484808284376040519201829003965090945050505050a4610d36858561169e565b15610d4057600080fd5b600160a060020a03851615801590610d605750600160a060020a03841615155b1515610d6b57600080fd5b60408051606060020a600160a060020a038089168281028452908816918202601484015283519283900360280183206000908152600a602090815290859020805460ff1916600117905590835282015281517f4b84ee81b11f5c5a33aaf2f3bdc5a35f23156c1b3cbefdbd00ba84846c19044b929181900390910190a1506001949350505050565b6000610e0b33600035600160e060020a031916611db7565b1515610e1657600080fd5b60408051348082526020820183815236938301849052600435936024359384938693339360008035600160e060020a031916949092606082018484808284376040519201829003965090945050505050a4610e71858561169e565b1515610e7c57600080fd5b60408051606060020a600160a060020a038089168281028085529189169283026014808601829052865195869003602890810187206000908152600a60208181528a8320805460ff19908116909155958a5293890196909652885197889003909101872081529381529286902080549091169055835282015281517f80eb6b7f03b2ffa03a2dda3ce0c7db2b44d4bda32c071d3508a817321cd327d6929181900390910190a1506001949350505050565b60408051606060020a600160a060020a0380881682028352851602601482015281519081900360280190206000908152600a602052908120548590849060ff1680610fae575060408051606060020a600160a060020a0380851682028352851602601482015281519081900360280190206000908152600a602052205460ff165b1515610fb957600080fd5b610fc161188a565b15610fcb57600080fd5b610fda88888888886000611a76565b98975050505050505050565b6000610ff183611910565b15610ffb57600080fd5b6110048361161f565b151561100f57600080fd5b61101883611ebe565b506110238383611f66565b604080513381526020810185905281517f6d5c16212bdea16850dce4d9fa2314c446bd30ce84700d9c36c7677c6d283940929181900390910190a150600192915050565b60025481565b600061108533600035600160e060020a031916611db7565b151561109057600080fd5b600480548315156b0100000000000000000000009081026bff0000000000000000000000199092169190911791829055604080519190920460ff161515815290517fea11e00ec1642be9b494019b756440e2c57dbe9e59242c4f9c64ce33fb4f41d99181900360200190a1506001919050565b60008161110f8161161f565b151561111a57600080fd5b61112261188a565b806111465750611131816118f2565b600160a060020a031633600160a060020a0316145b151561115157600080fd5b6004546b010000000000000000000000900460ff16156111a65761117483611910565b156111925761118283612141565b151561118d57600080fd5b6111a6565b61119b83611ebe565b15156111a657600080fd5b6111af83612301565b9392505050565b600090815260036020819052604090912080546001820154600283015492909301549093600160a060020a039384169390911690565b60006111f78261161f565b158015611214575060008281526005602052604090206002015415155b801561123457506000828152600560205260409020600201546009194301115b151561123f57600080fd5b60008281526005602090815260408083208381556001810184905560020192909255815133815290810184905281517fcb9d6176c6aac6478ebb9a2754cdce22a944de29ed1f2642f8613884eba4b40c929181900390910190a1506001919050565b6112b4826001608060020a038316611a15565b15156112bf57600080fd5b5050565b600160a060020a031660009081526008602052604090205490565b4290565b60009081526009602052604090205490565b600454610100900467ffffffffffffffff1681565b600760209081526000928352604080842090915290825290205481565b600660209081526000928352604080842090915290825290205481565b6004546901000000000000000000900460ff1681565b6000816113658161161f565b151561137057600080fd5b61137861188a565b1561138257600080fd5b600083815260036020818152604080842060048101546001820154828601548451606060020a600160a060020a03938416818102835292841690810260148301528651918290036028018220998d90529787528454600290950154918152958601969096526001608060020a039283168585015291909416606084015267ffffffffffffffff60a060020a850416608084015290518796509216929185917f70a14c213064359ede031fd2a1645a11ce2ec825ffe6ab5cfb5b160c3ef4d0a2919081900360a00190a4505050565b61146633600035600160e060020a031916611db7565b151561147157600080fd5b6000805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a03838116919091178083556040519116917f1abebea81bfa2637f28358c371278fb15ede7ea8dd28d2e03b112ff6d936ada491a250565b600160a060020a03918216600090815260076020908152604080832093909416825291909152205490565b6000805b60008511156116095761150c8685610991565b905080151561151a57600080fd5b6000818152600360205260409020805460029091015461153a9190611d1a565b85670de0b6b3a764000002101561155057611609565b60008181526003602052604090205485106115c157600081815260036020526040902060020154611582908390611d4b565b60008281526003602052604090205490925061159f908690611d5b565b6000828152600360205260409020549095506115bc9082906112a1565b611604565b6000818152600360205260409020600281015490546115f3918491633b9aca0091610ca9918a840291610abb91611d6b565b91506115ff81866112a1565b600094505b6114f9565b8282111561161657600080fd5b50949350505050565b60009081526003602052604081206004015460a060020a900467ffffffffffffffff161190565b6003602081905260009182526040909120805460018201546002830154938301546004909301549193600160a060020a039182169390929082169181169060a060020a900467ffffffffffffffff1686565b600b5490565b60408051606060020a600160a060020a0380861682028352841602601482015281519081900360280190206000908152600a6020529081205460ff16806111af575060408051606060020a600160a060020a0380861682028352861602601482015281519081900360280190206000908152600a602052205460ff169392505050565b600154600160a060020a031681565b60009081526005602052604090205490565b60086020526000908152604090205481565b60009081526005602052604090206001015490565b600a6020526000908152604090205460ff1681565b60096020526000908152604090205481565b61179981611103565b15156117a457600080fd5b50565b60006117bf33600035600160e060020a031916611db7565b15156117ca57600080fd5b60408051348082526020820183815236938301849052600435936024359384938693339360008035600160e060020a031916949092606082018484808284376040519201829003965090945050505050a4600160a060020a0385166000818152600860209081526040918290208790558151928352820186905280517fc28d56449b0bb31e64ee7487e061f57a2e72aea8019d810832f26dda099823d09281900390910190a1506001949350505050565b600054600160a060020a031681565b6004546000906901000000000000000000900460ff16806118cc5750600454610100900467ffffffffffffffff166118c06112de565b67ffffffffffffffff16115b905090565b60056020526000908152604090208054600182015460029092015490919083565b600090815260036020526040902060040154600160a060020a031690565b60008181526005602052604081205415158061193c575060008281526005602052604090206001015415155b806109b857505060008181526003602081815260408084206001810154600160a060020a03908116865260068452828620919094015490931684529190529020541490565b600061199933600035600160e060020a031916611db7565b15156119a457600080fd5b600480548315156a01000000000000000000009081026aff00000000000000000000199092169190911791829055604080519190920460ff161515815290517f7089e4f0bcc948f9f723a361590c32d9c2284da7ab1981b1249ad2edb9f953c19181900360200190a1506001919050565b60006132d083611a248161161f565b1515611a2f57600080fd5b611a3761188a565b15611a4157600080fd5b6004546b010000000000000000000000900460ff16611a62576126c5611a66565b612b5f5b9150610b6585858463ffffffff16565b60408051606060020a600160a060020a0380891682028352861602601482015281519081900360280190206000908152600a602052908120548690859060ff1680611af7575060408051606060020a600160a060020a0380851682028352851602601482015281519081900360280190206000908152600a602052205460ff165b1515611b0257600080fd5b611b0a61188a565b15611b1457600080fd5b600160a060020a038816600090815260086020526040902054891015611b3957600080fd5b6004546b010000000000000000000000900460ff1615611b6857611b61898989898989612bd0565b9250611b77565b611b7489898989612d13565b92505b50509695505050505050565b60408051606060020a600160a060020a0380871682028352841602601482015281519081900360280190206000908152600a602052908120546132d0908590849060ff1680611c08575060408051606060020a600160a060020a0380851682028352851602601482015281519081900360280190206000908152600a602052205460ff165b1515611c1357600080fd5b6004546b010000000000000000000000900460ff16611c3457612d13611c38565b6130415b9250610fda888888888763ffffffff16565b6004546a0100000000000000000000900460ff1681565b600080611c6e8486610991565b90505b600081815260036020526040902054831115611ce857600081815260036020526040902060020154611ca4908390611d4b565b600082815260036020526040902054909250611cc1908490611d5b565b92506000831115611ce357611cd581611754565b9050801515611ce357600080fd5b611c71565b600081815260036020526040902060028101549054610b65918491633b9aca0091610ca99188840291610abb91611d6b565b600081611d3a611d3285670de0b6b3a76400006130cb565b600285610cb2565b811515611d4357fe5b049392505050565b808201828110156109b857600080fd5b808203828111156109b857600080fd5b600081611d3a611d32856b033b2e3c9fd0803ce80000006130cb565b60006b033b2e3c9fd0803ce8000000611d3a611da385856130cb565b60026b033b2e3c9fd0803ce8000000610cb2565b6000600160a060020a038316301415611dd2575060016109b8565b600154600160a060020a0384811691161415611df0575060016109b8565b600054600160a060020a03161515611e0a575060006109b8565b60008054604080517fb7009613000000000000000000000000000000000000000000000000000000008152600160a060020a038781166004830152306024830152600160e060020a0319871660448301529151919092169263b700961392606480820193602093909283900390910190829087803b158015611e8b57600080fd5b505af1158015611e9f573d6000803e3d6000fd5b505050506040513d6020811015611eb557600080fd5b505190506109b8565b600b5460009080611ece84611910565b15611ed857600080fd5b83600b541415611eff5760008481526009602052604081208054600b555560019250611f5f565b5b600082118015611f105750838214155b15611f2b575060008181526009602052604090205490611f00565b818414611f3b5760009250611f5f565b60008481526009602052604080822080548484529183209190915585825255600192505b5050919050565b6000806000611f748561161f565b1515611f7f57600080fd5b600085815260036020819052604090912090810154600190910154600160a060020a039182169450169150831580611fbd5750611fbb84611910565b155b15611fd257611fcb856130f3565b935061205d565b611fdc858561317c565b9350831580159061204857506000858152600360205260408082206001908101548784529190922090910154600160a060020a0390811691161415806120485750600085815260036020819052604080832082015487845292200154600160a060020a03908116911614155b1561205d576000935061205a856130f3565b93505b8315612089575060008381526005602052604080822060010180549087905586835291208490556120b6565b50600160a060020a0381811660009081526006602090815260408083209386168352929052208054908590555b80156120da5760008181526005602052604080822087905586825290206001018190555b600160a060020a03808316600090815260076020908152604080832093871683529281529082902080546001019055815187815291517f20fb9bad86c18f7e22e8065258790d9416a7d2df8ff05f80f82c46d38b925acd9281900390910190a15050505050565b600081815260036020818152604080842092830154600190930154600160a060020a0390811680865260078452828620919094168086529252832054909190831061218b57600080fd5b6000848152600560205260409020600201541580156121ae57506121ae84611910565b15156121b957600080fd5b600160a060020a03808216600090815260066020908152604080832093861683529290522054841461222c57600084815260056020526040808220548252902060010154841461220857600080fd5b60008481526005602052604080822060018082015491548452919092200155612262565b600084815260056020908152604080832060010154600160a060020a038086168552600684528285209087168552909252909120555b600084815260056020526040902060010154156122b957600084815260056020526040808220600101548252902054841461229c57600080fd5b600084815260056020526040808220805460019091015483529120555b600160a060020a039081166000908152600760209081526040808320949093168252928352818120805460001901905593845260059091529091204360029091015550600190565b600061230b6132d2565b826123158161161f565b151561232057600080fd5b61232861188a565b8061234c5750612337816118f2565b600160a060020a031633600160a060020a0316145b151561235757600080fd5b60045460ff161561236757600080fd5b6001600460006101000a81548160ff0219169083151502179055506003600085815260200190815260200160002060c06040519081016040529081600082015481526020016001820160009054906101000a9004600160a060020a0316600160a060020a0316600160a060020a03168152602001600282015481526020016003820160009054906101000a9004600160a060020a0316600160a060020a0316600160a060020a031681526020016004820160009054906101000a9004600160a060020a0316600160a060020a0316600160a060020a031681526020016004820160149054906101000a900467ffffffffffffffff1667ffffffffffffffff1667ffffffffffffffff16815250509150600360008581526020019081526020016000206000808201600090556001820160006101000a815490600160a060020a03021916905560028201600090556003820160006101000a815490600160a060020a0302191690556004820160006101000a815490600160a060020a0302191690556004820160146101000a81549067ffffffffffffffff021916905550508160200151600160a060020a031663a9059cbb836080015184600001516040518363ffffffff167c01000000000000000000000000000000000000000000000000000000000281526004018083600160a060020a0316600160a060020a0316815260200182815260200192505050602060405180830381600087803b15801561258d57600080fd5b505af11580156125a1573d6000803e3d6000fd5b505050506040513d60208110156125b757600080fd5b505115156125c457600080fd5b6040805185815290517fa2c251311b1a7a475913900a2a73dc9789a21b04bc737e050bbc506dd4eb34889181900360200190a1608080830151602080850180516060808801805160408051606060020a600160a060020a039687168102825292861690920260148301528051918290036028018220955192518b51828d01519487168452908616978301979097526001608060020a0396871682820152959091169181019190915267ffffffffffffffff4216958101959095529151919092169287917f9577941d28fff863bfbee4694a6a4a56fb09e169619189d2eaa750b5b48199959181900360a00190a450506004805460ff19169055506001919050565b60006126cf6132d2565b6000846126db8161161f565b15156126e657600080fd5b6126ee61188a565b156126f857600080fd5b60045460ff161561270857600080fd5b60048054600160ff1990911681178255600088815260036020818152604092839020835160c081018552815480825295820154600160a060020a03908116938201939093526002820154948101859052928101548216606084015290940154938416608082015260a060020a90930467ffffffffffffffff1660a0840152919450906127959087906130cb565b81151561279e57fe5b0491506001608060020a03821682146127b657600080fd5b6001608060020a03851685146127cb57600080fd5b8415806127d6575081155b806127e15750825185115b806127ef5750826040015182115b156127fd5760009350612b4c565b82516128099086611d5b565b600087815260036020526040908190209190915583015161282a9083611d5b565b6000878152600360209081526040808320600201939093556060860151608087015184517f23b872dd000000000000000000000000000000000000000000000000000000008152336004820152600160a060020a0391821660248201526044810188905294519116936323b872dd9360648083019493928390030190829087803b1580156128b757600080fd5b505af11580156128cb573d6000803e3d6000fd5b505050506040513d60208110156128e157600080fd5b505115156128ee57600080fd5b602080840151604080517fa9059cbb000000000000000000000000000000000000000000000000000000008152336004820152602481018990529051600160a060020a039092169263a9059cbb926044808401938290030181600087803b15801561295857600080fd5b505af115801561296c573d6000803e3d6000fd5b505050506040513d602081101561298257600080fd5b5051151561298f57600080fd5b6040805187815290517fa2c251311b1a7a475913900a2a73dc9789a21b04bc737e050bbc506dd4eb34889181900360200190a1608080840151602080860180516060808901805160408051606060020a600160a060020a039687168102825292861690920260148301528051918290036028018220955192518f835292851696820196909652908316818601526001608060020a03808d16928201929092529088169581019590955267ffffffffffffffff421660a086015291513394939092169290917f3383e3357c77fd2e3a4b30deea81179bc70a795d053d14d5b7f2f01d0fd4596f9181900360c00190a48260600151600160a060020a03168360200151600160a060020a03167f819e390338feffe95e2de57172d6faf337853dfd15c7a09a32d76f7fd24438758785604051808381526020018281526020019250505060405180910390a36000868152600360205260409020541515612b47576000868152600360208190526040822082815560018101805473ffffffffffffffffffffffffffffffffffffffff19908116909155600282019390935590810180549092169091556004018054600160e060020a03191690555b600193505b50506004805460ff191690555092915050565b6004546000906a0100000000000000000000900460ff161515612b8157600080fd5b60008381526003602052604090205482148015612ba25750612ba283611910565b15612bb257612bb083612141565b505b612bbc83836126c5565b1515612bc757600080fd5b50600192915050565b60008060008060005b600160a060020a038089166000908152600660209081526040808320938e168352929052908120541115612cd8575050600160a060020a038087166000908152600660209081526040808320938c168352928152828220548083526003909152919020600281015490549193509085612c53576000612c5b565b808b8a840101015b612c658c836130cb565b01612c70838b6130cb565b1115612c7b57612cd8565b612c8e84612c89838c61325b565b611a15565b50889250612ca589612ca0838c61325b565b611d5b565b985082612cb28a8d6130cb565b811515612cbb57fe5b049a508a1580612cc9575088155b15612cd357612cd8565b612bd9565b600089118015612ce8575060008b115b15612d0557612cf98b8b8b8b612d13565b9450612d058588611f66565b505050509695505050505050565b6000612d1d6132d2565b612d2561188a565b15612d2f57600080fd5b60045460ff1615612d3f57600080fd5b6004805460ff191660011790556001608060020a0386168614612d6157600080fd5b6001608060020a0384168414612d7657600080fd5b60008611612d8357600080fd5b600160a060020a0385161515612d9857600080fd5b60008411612da557600080fd5b600160a060020a0383161515612dba57600080fd5b600160a060020a038581169084161415612dd357600080fd5b858152600160a060020a038086166020830152604082018590528316606082015233608082015267ffffffffffffffff421660a0820152612e12613272565b60008181526003602081815260408084208651815582870151600182018054600160a060020a0392831673ffffffffffffffffffffffffffffffffffffffff1991821617909155838901516002840155606089015195830180549683169682169690961790955560808801516004928301805460a08b015167ffffffffffffffff1660a060020a027fffffffff0000000000000000ffffffffffffffffffffffffffffffffffffffff9385169190981617919091169590951790945581517f23b872dd0000000000000000000000000000000000000000000000000000000081523391810191909152306024820152604481018c90529051949650918916936323b872dd936064808501948390030190829087803b158015612f3357600080fd5b505af1158015612f47573d6000803e3d6000fd5b505050506040513d6020811015612f5d57600080fd5b50511515612f6a57600080fd5b6040805183815290517fa2c251311b1a7a475913900a2a73dc9789a21b04bc737e050bbc506dd4eb34889181900360200190a160408051606060020a600160a060020a0388811682810284529087169182026014840152835192839003602801832090835260208301919091526001608060020a03808a16838501528716606083015267ffffffffffffffff42166080830152915133929185917f773ff502687307abfa024ac9f62f9752a0d210dac2ffd9a29e38e12e2ea82c829181900360a00190a4506004805460ff19169055949350505050565b600160a060020a03831660009081526008602052604081205485101561306657600080fd5b61307285858585612d13565b600b80546000838152600960209081526040918290209290925591839055815183815291519293507f8173832a493e0a3989e521458e55bfe9feac9f9b675a94e100b9d5a85f81486292918290030190a1949350505050565b60008115806130e85750508082028282828115156130e557fe5b04145b15156109b857600080fd5b60008080808080861161310557600080fd5b505050600083815260036020818152604080842092830154600190930154600160a060020a039081168086526006845282862091909416808652925283205490935090915b811580159061315e575061315e8683613280565b15610b6557506000818152600560205260409020600101549061314a565b60008080841161318b57600080fd5b82158015906131a0575061319e8361161f565b155b156131be57600092835260056020526040909220600101549161318b565b8215156131d5576131ce846130f3565b9150613254565b6131df8484613280565b1561321f575b82158015906131f957506131f98484613280565b156132175750600082815260056020526040902060010154916131e5565b809150613254565b821580159061323557506132338484613280565b155b1561325057600092835260056020526040909220549161321f565b8291505b5092915050565b60008183111561326b57816111af565b5090919050565b600280546001019081905590565b60008181526003602052604080822060020154848352908220546132a491906130cb565b600084815260036020526040808220600201548583529120546132c791906130cb565b10159392505050565bfe5b6040805160c081018252600080825260208201819052918101829052606081018290526080810182905260a0810191909152905600a165627a7a723058201505b7abc4869912db64323d88d2d960bbd7f45f75c258cc5a1300697869efff0029000000000000000000000000000000000000000000000000000000023906a6d4",
  "constructorArguments": "000000000000000000000000000000000000000000000000000000023906a6d4"
}