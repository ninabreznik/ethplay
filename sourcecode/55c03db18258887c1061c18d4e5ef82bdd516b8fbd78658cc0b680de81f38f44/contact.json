{
  "address": "0x8b8e088c7ad40d70d0a8183a399c8f9c24b5c8d8",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "CHLToken",
  "compilerVersion": "v0.4.24+commit.e67f0147",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2019-02-14\n*/\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n    require(token.transfer(to, value));\n  }\n\n  function safeTransferFrom(\n    ERC20 token,\n    address from,\n    address to,\n    uint256 value\n  )\n    internal\n  {\n    require(token.transferFrom(from, to, value));\n  }\n\n  function safeApprove(ERC20 token, address spender, uint256 value) internal {\n    require(token.approve(spender, value));\n  }\n}\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    emit Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256) {\n    return balances[_owner];\n  }\n\n}\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender)\n    public view returns (uint256);\n\n  function transferFrom(address from, address to, uint256 value)\n    public returns (bool);\n\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  )\n    public\n    returns (bool)\n  {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    emit Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    emit Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(\n    address _owner,\n    address _spender\n   )\n    public\n    view\n    returns (uint256)\n  {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(\n    address _spender,\n    uint _addedValue\n  )\n    public\n    returns (bool)\n  {\n    allowed[msg.sender][_spender] = (\n      allowed[msg.sender][_spender].add(_addedValue));\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(\n    address _spender,\n    uint _subtractedValue\n  )\n    public\n    returns (bool)\n  {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n/// @title Ownable\n/// @author Applicature\n/// @notice helper mixed to other contracts to link contract on an owner\n/// @dev Base class\ncontract Ownable {\n    //Variables\n    address public owner;\n    address public newOwner;\n\n    //    Modifiers\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param _newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address _newOwner) public onlyOwner {\n        require(_newOwner != address(0));\n        newOwner = _newOwner;\n\n    }\n\n    function acceptOwnership() public {\n        if (msg.sender == newOwner) {\n            owner = newOwner;\n        }\n    }\n}\n/// @title OpenZeppelinERC20\n/// @author Applicature\n/// @notice Open Zeppelin implementation of standart ERC20\n/// @dev Base class\ncontract OpenZeppelinERC20 is StandardToken, Ownable {\n    using SafeMath for uint256;\n\n    uint8 public decimals;\n    string public name;\n    string public symbol;\n    string public standard;\n\n    constructor(\n        uint256 _totalSupply,\n        string _tokenName,\n        uint8 _decimals,\n        string _tokenSymbol,\n        bool _transferAllSupplyToOwner\n    ) public {\n        standard = 'ERC20 0.1';\n        totalSupply_ = _totalSupply;\n\n        if (_transferAllSupplyToOwner) {\n            balances[msg.sender] = _totalSupply;\n        } else {\n            balances[this] = _totalSupply;\n        }\n\n        name = _tokenName;\n        // Set the name for display purposes\n        symbol = _tokenSymbol;\n        // Set the symbol for display purposes\n        decimals = _decimals;\n    }\n\n}\n/**\n * @title Burnable Token\n * @dev Token that can be irreversibly burned (destroyed).\n */\ncontract BurnableToken is BasicToken {\n\n  event Burn(address indexed burner, uint256 value);\n\n  /**\n   * @dev Burns a specific amount of tokens.\n   * @param _value The amount of token to be burned.\n   */\n  function burn(uint256 _value) public {\n    _burn(msg.sender, _value);\n  }\n\n  function _burn(address _who, uint256 _value) internal {\n    require(_value <= balances[_who]);\n    // no need to require value <= totalSupply, since that would imply the\n    // sender's balance is greater than the totalSupply, which *should* be an assertion failure\n\n    balances[_who] = balances[_who].sub(_value);\n    totalSupply_ = totalSupply_.sub(_value);\n    emit Burn(_who, _value);\n    emit Transfer(_who, address(0), _value);\n  }\n}\n/// @title MintableToken\n/// @author Applicature\n/// @notice allow to mint tokens\n/// @dev Base class\ncontract MintableToken is BasicToken, Ownable {\n\n    using SafeMath for uint256;\n\n    uint256 public maxSupply;\n    bool public allowedMinting;\n    mapping(address => bool) public mintingAgents;\n    mapping(address => bool) public stateChangeAgents;\n\n    event Mint(address indexed holder, uint256 tokens);\n\n    modifier onlyMintingAgents () {\n        require(mintingAgents[msg.sender]);\n        _;\n    }\n\n    modifier onlyStateChangeAgents () {\n        require(stateChangeAgents[msg.sender]);\n        _;\n    }\n\n    constructor(uint256 _maxSupply, uint256 _mintedSupply, bool _allowedMinting) public {\n        maxSupply = _maxSupply;\n        totalSupply_ = totalSupply_.add(_mintedSupply);\n        allowedMinting = _allowedMinting;\n        mintingAgents[msg.sender] = true;\n    }\n\n    /// @notice allow to mint tokens\n    function mint(address _holder, uint256 _tokens) public onlyMintingAgents() {\n        require(allowedMinting == true && totalSupply_.add(_tokens) <= maxSupply);\n\n        totalSupply_ = totalSupply_.add(_tokens);\n\n        balances[_holder] = balanceOf(_holder).add(_tokens);\n\n        if (totalSupply_ == maxSupply) {\n            allowedMinting = false;\n        }\n        emit Transfer(address(0), _holder, _tokens);\n        emit Mint(_holder, _tokens);\n    }\n\n    /// @notice update allowedMinting flat\n    function disableMinting() public onlyStateChangeAgents() {\n        allowedMinting = false;\n    }\n\n    /// @notice update minting agent\n    function updateMintingAgent(address _agent, bool _status) public onlyOwner {\n        mintingAgents[_agent] = _status;\n    }\n\n    /// @notice update state change agent\n    function updateStateChangeAgent(address _agent, bool _status) public onlyOwner {\n        stateChangeAgents[_agent] = _status;\n    }\n\n    /// @return available tokens\n    function availableTokens() public view returns (uint256 tokens) {\n        return maxSupply.sub(totalSupply_);\n    }\n}\n/// @title MintableBurnableToken\n/// @author Applicature\n/// @notice helper mixed to other contracts to burn tokens\n/// @dev implementation\ncontract MintableBurnableToken is MintableToken, BurnableToken {\n\n    mapping (address => bool) public burnAgents;\n\n    modifier onlyBurnAgents () {\n        require(burnAgents[msg.sender]);\n        _;\n    }\n\n    event Burn(address indexed burner, uint256 value);\n\n    constructor(\n        uint256 _maxSupply,\n        uint256 _mintedSupply,\n        bool _allowedMinting\n    ) public MintableToken(\n        _maxSupply,\n        _mintedSupply,\n        _allowedMinting\n    ) {\n\n    }\n\n    /// @notice update minting agent\n    function updateBurnAgent(address _agent, bool _status) public onlyOwner {\n        burnAgents[_agent] = _status;\n    }\n\n    function burnByAgent(address _holder, uint256 _tokensToBurn) public onlyBurnAgents() returns (uint256) {\n        if (_tokensToBurn == 0) {\n            _tokensToBurn = balanceOf(_holder);\n        }\n        _burn(_holder, _tokensToBurn);\n\n        return _tokensToBurn;\n    }\n\n    function _burn(address _who, uint256 _value) internal {\n        require(_value <= balances[_who]);\n        // no need to require value <= totalSupply, since that would imply the\n        // sender's balance is greater than the totalSupply, which *should* be an assertion failure\n\n        balances[_who] = balances[_who].sub(_value);\n        totalSupply_ = totalSupply_.sub(_value);\n        maxSupply = maxSupply.sub(_value);\n        emit Burn(_who, _value);\n        emit Transfer(_who, address(0), _value);\n    }\n}\n/// @title TimeLocked\n/// @author Applicature\n/// @notice helper mixed to other contracts to lock contract on a timestamp\n/// @dev Base class\ncontract TimeLocked {\n    uint256 public time;\n    mapping(address => bool) public excludedAddresses;\n\n    modifier isTimeLocked(address _holder, bool _timeLocked) {\n        bool locked = (block.timestamp < time);\n        require(excludedAddresses[_holder] == true || locked == _timeLocked);\n        _;\n    }\n\n    constructor(uint256 _time) public {\n        time = _time;\n    }\n\n    function updateExcludedAddress(address _address, bool _status) public;\n}\n/// @title TimeLockedToken\n/// @author Applicature\n/// @notice helper mixed to other contracts to lock contract on a timestamp\n/// @dev Base class\ncontract TimeLockedToken is TimeLocked, StandardToken {\n\n    constructor(uint256 _time) public TimeLocked(_time) {}\n\n    function transfer(address _to, uint256 _tokens) public isTimeLocked(msg.sender, false) returns (bool) {\n        return super.transfer(_to, _tokens);\n    }\n\n    function transferFrom(\n        address _holder,\n        address _to,\n        uint256 _tokens\n    ) public isTimeLocked(_holder, false) returns (bool) {\n        return super.transferFrom(_holder, _to, _tokens);\n    }\n}\ncontract CHLToken is OpenZeppelinERC20, MintableBurnableToken, TimeLockedToken {\n\n    CHLCrowdsale public crowdsale;\n\n    bool public isSoftCapAchieved;\n\n    //_unlockTokensTime - Lockup 3 months after end of the ICO\n    constructor(uint256 _unlockTokensTime) public\n    OpenZeppelinERC20(0, 'ChelleCoin', 18, 'CHL', false)\n    MintableBurnableToken(59500000e18, 0, true)\n    TimeLockedToken(_unlockTokensTime) {\n\n    }\n\n    function updateMaxSupply(uint256 _newMaxSupply) public onlyOwner {\n        require(_newMaxSupply > 0);\n        maxSupply = _newMaxSupply;\n    }\n\n    function updateExcludedAddress(address _address, bool _status) public onlyOwner {\n        excludedAddresses[_address] = _status;\n    }\n\n    function setCrowdSale(address _crowdsale) public onlyOwner {\n        require(_crowdsale != address(0));\n        crowdsale = CHLCrowdsale(_crowdsale);\n    }\n\n    function setUnlockTime(uint256 _unlockTokensTime) public onlyStateChangeAgents {\n        time = _unlockTokensTime;\n    }\n\n    function setIsSoftCapAchieved() public onlyStateChangeAgents {\n        isSoftCapAchieved = true;\n    }\n\n    function transfer(address _to, uint256 _tokens) public returns (bool) {\n        require(true == isTransferAllowed(msg.sender, _tokens));\n        return super.transfer(_to, _tokens);\n    }\n\n    function transferFrom(address _holder, address _to, uint256 _tokens) public returns (bool) {\n        require(true == isTransferAllowed(_holder, _tokens));\n        return super.transferFrom(_holder, _to, _tokens);\n    }\n\n    function isTransferAllowed(address _address, uint256 _value) public view returns (bool) {\n        if (excludedAddresses[_address] == true) {\n            return true;\n        }\n\n        if (!isSoftCapAchieved && (address(crowdsale) == address(0) || false == crowdsale.isSoftCapAchieved(0))) {\n            return false;\n        }\n\n        return true;\n    }\n\n    function burnUnsoldTokens(uint256 _tokensToBurn) public onlyBurnAgents() returns (uint256) {\n        require(totalSupply_.add(_tokensToBurn) <= maxSupply);\n\n        maxSupply = maxSupply.sub(_tokensToBurn);\n\n        emit Burn(address(0), _tokensToBurn);\n\n        return _tokensToBurn;\n    }\n\n}\n/// @title Agent\n/// @author Applicature\n/// @notice Contract which takes actions on state change and contribution\n/// @dev Base class\ncontract Agent {\n    using SafeMath for uint256;\n\n    function isInitialized() public constant returns (bool) {\n        return false;\n    }\n}\n/// @title CrowdsaleAgent\n/// @author Applicature\n/// @notice Contract which takes actions on state change and contribution\n/// @dev Base class\ncontract CrowdsaleAgent is Agent {\n\n\n    Crowdsale public crowdsale;\n    bool public _isInitialized;\n\n    modifier onlyCrowdsale() {\n        require(msg.sender == address(crowdsale));\n        _;\n    }\n\n    constructor(Crowdsale _crowdsale) public {\n        crowdsale = _crowdsale;\n\n        if (address(0) != address(_crowdsale)) {\n            _isInitialized = true;\n        } else {\n            _isInitialized = false;\n        }\n    }\n\n    function isInitialized() public constant returns (bool) {\n        return _isInitialized;\n    }\n\n    function onContribution(address _contributor, uint256 _weiAmount, uint256 _tokens, uint256 _bonus)\n        public onlyCrowdsale();\n\n    function onStateChange(Crowdsale.State _state) public onlyCrowdsale();\n\n    function onRefund(address _contributor, uint256 _tokens) public onlyCrowdsale() returns (uint256 burned);\n}\n/// @title MintableCrowdsaleOnSuccessAgent\n/// @author Applicature\n/// @notice Contract which takes actions on state change and contribution\n/// un-pause tokens and disable minting on Crowdsale success\n/// @dev implementation\ncontract MintableCrowdsaleOnSuccessAgent is CrowdsaleAgent {\n\n    Crowdsale public crowdsale;\n    MintableToken public token;\n    bool public _isInitialized;\n\n    constructor(Crowdsale _crowdsale, MintableToken _token) public CrowdsaleAgent(_crowdsale) {\n        crowdsale = _crowdsale;\n        token = _token;\n\n        if (address(0) != address(_token) &&\n        address(0) != address(_crowdsale)) {\n            _isInitialized = true;\n        } else {\n            _isInitialized = false;\n        }\n    }\n\n    /// @notice Check whether contract is initialised\n    /// @return true if initialized\n    function isInitialized() public constant returns (bool) {\n        return _isInitialized;\n    }\n\n    /// @notice Takes actions on contribution\n    function onContribution(address _contributor, uint256 _weiAmount, uint256 _tokens, uint256 _bonus)\n    public onlyCrowdsale() {\n        _contributor = _contributor;\n        _weiAmount = _weiAmount;\n        _tokens = _tokens;\n        _bonus = _bonus;\n        // TODO: add impl\n    }\n\n    /// @notice Takes actions on state change,\n    /// un-pause tokens and disable minting on Crowdsale success\n    /// @param _state Crowdsale.State\n    function onStateChange(Crowdsale.State _state) public onlyCrowdsale() {\n        if (_state == Crowdsale.State.Success) {\n            token.disableMinting();\n        }\n    }\n\n    function onRefund(address _contributor, uint256 _tokens) public onlyCrowdsale() returns (uint256 burned) {\n        _contributor = _contributor;\n        _tokens = _tokens;\n    }\n}\ncontract CHLAgent is MintableCrowdsaleOnSuccessAgent, Ownable {\n\n    CHLPricingStrategy public strategy;\n    CHLCrowdsale public crowdsale;\n    CHLAllocation public allocation;\n\n    bool public isEndProcessed;\n\n    constructor(\n        CHLCrowdsale _crowdsale,\n        CHLToken _token,\n        CHLPricingStrategy _strategy,\n        CHLAllocation _allocation\n    ) public MintableCrowdsaleOnSuccessAgent(_crowdsale, _token) {\n        strategy = _strategy;\n        crowdsale = _crowdsale;\n        allocation = _allocation;\n    }\n\n    /// @notice update pricing strategy\n    function setPricingStrategy(CHLPricingStrategy _strategy) public onlyOwner {\n        strategy = _strategy;\n    }\n\n    /// @notice update allocation\n    function setAllocation(CHLAllocation _allocation) public onlyOwner {\n        allocation = _allocation;\n    }\n\n    function burnUnsoldTokens(uint256 _tierId) public onlyOwner {\n        uint256 tierUnsoldTokensAmount = strategy.getTierUnsoldTokens(_tierId);\n        require(tierUnsoldTokensAmount > 0);\n\n        CHLToken(token).burnUnsoldTokens(tierUnsoldTokensAmount);\n    }\n\n    /// @notice Takes actions on contribution\n    function onContribution(\n        address,\n        uint256 _tierId,\n        uint256 _tokens,\n        uint256 _bonus\n    ) public onlyCrowdsale() {\n        strategy.updateTierTokens(_tierId, _tokens, _bonus);\n    }\n\n    function onStateChange(Crowdsale.State _state) public onlyCrowdsale() {\n        CHLToken chlToken = CHLToken(token);\n        if (\n            chlToken.isSoftCapAchieved() == false\n            && (_state == Crowdsale.State.Success || _state == Crowdsale.State.Finalized)\n            && crowdsale.isSoftCapAchieved(0)\n        ) {\n            chlToken.setIsSoftCapAchieved();\n        }\n\n        if (_state > Crowdsale.State.InCrowdsale && isEndProcessed == false) {\n            allocation.allocateFoundersTokens(strategy.getSaleEndDate());\n        }\n    }\n\n    function onRefund(address _contributor, uint256 _tokens) public onlyCrowdsale() returns (uint256 burned) {\n        burned = CHLToken(token).burnByAgent(_contributor, _tokens);\n    }\n\n    function updateStateWithPrivateSale(\n        uint256 _tierId,\n        uint256 _tokensAmount,\n        uint256 _usdAmount\n    ) public {\n        require(msg.sender == address(allocation));\n\n        strategy.updateMaxTokensCollected(_tierId, _tokensAmount);\n        crowdsale.updateStatsVars(_usdAmount, _tokensAmount);\n    }\n\n    function updateLockPeriod(uint256 _time) public {\n        require(msg.sender == address(strategy));\n        CHLToken(token).setUnlockTime(_time.add(12 weeks));\n    }\n\n}\n/// @title TokenAllocator\n/// @author Applicature\n/// @notice Contract responsible for defining distribution logic of tokens.\n/// @dev Base class\ncontract TokenAllocator is Ownable {\n\n\n    mapping(address => bool) public crowdsales;\n\n    modifier onlyCrowdsale() {\n        require(crowdsales[msg.sender]);\n        _;\n    }\n\n    function addCrowdsales(address _address) public onlyOwner {\n        crowdsales[_address] = true;\n    }\n\n    function removeCrowdsales(address _address) public onlyOwner {\n        crowdsales[_address] = false;\n    }\n\n    function isInitialized() public constant returns (bool) {\n        return false;\n    }\n\n    function allocate(address _holder, uint256 _tokens) public onlyCrowdsale() {\n        internalAllocate(_holder, _tokens);\n    }\n\n    function tokensAvailable() public constant returns (uint256);\n\n    function internalAllocate(address _holder, uint256 _tokens) internal onlyCrowdsale();\n}\n/// @title MintableTokenAllocator\n/// @author Applicature\n/// @notice Contract responsible for defining distribution logic of tokens.\n/// @dev implementation\ncontract MintableTokenAllocator is TokenAllocator {\n\n    using SafeMath for uint256;\n\n    MintableToken public token;\n\n    constructor(MintableToken _token) public {\n        require(address(0) != address(_token));\n        token = _token;\n    }\n\n    /// @return available tokens\n    function tokensAvailable() public constant returns (uint256) {\n        return token.availableTokens();\n    }\n\n    /// @notice transfer tokens on holder account\n    function allocate(address _holder, uint256 _tokens) public onlyCrowdsale() {\n        internalAllocate(_holder, _tokens);\n    }\n\n    /// @notice Check whether contract is initialised\n    /// @return true if initialized\n    function isInitialized() public constant returns (bool) {\n        return token.mintingAgents(this);\n    }\n\n    /// @notice update instance of MintableToken\n    function setToken(MintableToken _token) public onlyOwner {\n        token = _token;\n    }\n\n    function internalAllocate(address _holder, uint256 _tokens) internal {\n        token.mint(_holder, _tokens);\n    }\n\n}\n/// @title ContributionForwarder\n/// @author Applicature\n/// @notice Contract is responsible for distributing collected ethers, that are received from CrowdSale.\n/// @dev Base class\ncontract ContributionForwarder {\n\n    using SafeMath for uint256;\n\n    uint256 public weiCollected;\n    uint256 public weiForwarded;\n\n    event ContributionForwarded(address receiver, uint256 weiAmount);\n\n    function isInitialized() public constant returns (bool) {\n        return false;\n    }\n\n    /// @notice transfer wei to receiver\n    function forward() public payable {\n        require(msg.value > 0);\n\n        weiCollected += msg.value;\n\n        internalForward();\n    }\n\n    function internalForward() internal;\n}\n/// @title DistributedDirectContributionForwarder\n/// @author Applicature\n/// @notice Contract is responsible for distributing collected ethers, that are received from CrowdSale.\n/// @dev implementation\ncontract DistributedDirectContributionForwarder is ContributionForwarder {\n    Receiver[] public receivers;\n    uint256 public proportionAbsMax;\n    bool public isInitialized_;\n\n    struct Receiver {\n        address receiver;\n        uint256 proportion; // abslolute value in range of 0 - proportionAbsMax\n        uint256 forwardedWei;\n    }\n\n    // @TODO: should we use uint256 [] for receivers & proportions?\n    constructor(uint256 _proportionAbsMax, address[] _receivers, uint256[] _proportions) public {\n        proportionAbsMax = _proportionAbsMax;\n\n        require(_receivers.length == _proportions.length);\n\n        require(_receivers.length > 0);\n\n        uint256 totalProportion;\n\n        for (uint256 i = 0; i < _receivers.length; i++) {\n            uint256 proportion = _proportions[i];\n\n            totalProportion = totalProportion.add(proportion);\n\n            receivers.push(Receiver(_receivers[i], proportion, 0));\n        }\n\n        require(totalProportion == proportionAbsMax);\n        isInitialized_ = true;\n    }\n\n    /// @notice Check whether contract is initialised\n    /// @return true if initialized\n    function isInitialized() public constant returns (bool) {\n        return isInitialized_;\n    }\n\n    function internalForward() internal {\n        uint256 transferred;\n\n        for (uint256 i = 0; i < receivers.length; i++) {\n            Receiver storage receiver = receivers[i];\n\n            uint256 value = msg.value.mul(receiver.proportion).div(proportionAbsMax);\n\n            if (i == receivers.length - 1) {\n                value = msg.value.sub(transferred);\n            }\n\n            transferred = transferred.add(value);\n\n            receiver.receiver.transfer(value);\n\n            emit ContributionForwarded(receiver.receiver, value);\n        }\n\n        weiForwarded = weiForwarded.add(transferred);\n    }\n}\ncontract Crowdsale {\n\n    uint256 public tokensSold;\n\n    enum State {Unknown, Initializing, BeforeCrowdsale, InCrowdsale, Success, Finalized, Refunding}\n\n    function externalContribution(address _contributor, uint256 _wei) public payable;\n\n    function contribute(uint8 _v, bytes32 _r, bytes32 _s) public payable;\n\n    function updateState() public;\n\n    function internalContribution(address _contributor, uint256 _wei) internal;\n\n    function getState() public view returns (State);\n\n}\n/// @title Crowdsale\n/// @author Applicature\n/// @notice Contract is responsible for collecting, refunding, allocating tokens during different stages of Crowdsale.\ncontract CrowdsaleImpl is Crowdsale, Ownable {\n\n    using SafeMath for uint256;\n\n    State public currentState;\n    TokenAllocator public allocator;\n    ContributionForwarder public contributionForwarder;\n    PricingStrategy public pricingStrategy;\n    CrowdsaleAgent public crowdsaleAgent;\n    bool public finalized;\n    uint256 public startDate;\n    uint256 public endDate;\n    bool public allowWhitelisted;\n    bool public allowSigned;\n    bool public allowAnonymous;\n    mapping(address => bool) public whitelisted;\n    mapping(address => bool) public signers;\n    mapping(address => bool) public externalContributionAgents;\n\n    event Contribution(address _contributor, uint256 _wei, uint256 _tokensExcludingBonus, uint256 _bonus);\n\n    constructor(\n        TokenAllocator _allocator,\n        ContributionForwarder _contributionForwarder,\n        PricingStrategy _pricingStrategy,\n        uint256 _startDate,\n        uint256 _endDate,\n        bool _allowWhitelisted,\n        bool _allowSigned,\n        bool _allowAnonymous\n    ) public {\n        allocator = _allocator;\n        contributionForwarder = _contributionForwarder;\n        pricingStrategy = _pricingStrategy;\n\n        startDate = _startDate;\n        endDate = _endDate;\n\n        allowWhitelisted = _allowWhitelisted;\n        allowSigned = _allowSigned;\n        allowAnonymous = _allowAnonymous;\n\n        currentState = State.Unknown;\n    }\n\n    /// @notice default payable function\n    function() public payable {\n        require(allowWhitelisted || allowAnonymous);\n\n        if (!allowAnonymous) {\n            if (allowWhitelisted) {\n                require(whitelisted[msg.sender]);\n            }\n        }\n\n        internalContribution(msg.sender, msg.value);\n    }\n\n    /// @notice update crowdsale agent\n    function setCrowdsaleAgent(CrowdsaleAgent _crowdsaleAgent) public onlyOwner {\n        crowdsaleAgent = _crowdsaleAgent;\n    }\n\n    /// @notice allows external user to do contribution\n    function externalContribution(address _contributor, uint256 _wei) public payable {\n        require(externalContributionAgents[msg.sender]);\n        internalContribution(_contributor, _wei);\n    }\n\n    /// @notice update external contributor\n    function addExternalContributor(address _contributor) public onlyOwner {\n        externalContributionAgents[_contributor] = true;\n    }\n\n    /// @notice update external contributor\n    function removeExternalContributor(address _contributor) public onlyOwner {\n        externalContributionAgents[_contributor] = false;\n    }\n\n    /// @notice update whitelisting address\n    function updateWhitelist(address _address, bool _status) public onlyOwner {\n        whitelisted[_address] = _status;\n    }\n\n    /// @notice update signer\n    function addSigner(address _signer) public onlyOwner {\n        signers[_signer] = true;\n    }\n\n    /// @notice update signer\n    function removeSigner(address _signer) public onlyOwner {\n        signers[_signer] = false;\n    }\n\n    /// @notice allows to do signed contributions\n    function contribute(uint8 _v, bytes32 _r, bytes32 _s) public payable {\n        address recoveredAddress = verify(msg.sender, _v, _r, _s);\n        require(signers[recoveredAddress]);\n        internalContribution(msg.sender, msg.value);\n    }\n\n    /// @notice Crowdsale state\n    function updateState() public {\n        State state = getState();\n\n        if (currentState != state) {\n            if (crowdsaleAgent != address(0)) {\n                crowdsaleAgent.onStateChange(state);\n            }\n\n            currentState = state;\n        }\n    }\n\n    function internalContribution(address _contributor, uint256 _wei) internal {\n        require(getState() == State.InCrowdsale);\n\n        uint256 tokensAvailable = allocator.tokensAvailable();\n        uint256 collectedWei = contributionForwarder.weiCollected();\n\n        uint256 tokens;\n        uint256 tokensExcludingBonus;\n        uint256 bonus;\n\n        (tokens, tokensExcludingBonus, bonus) = pricingStrategy.getTokens(\n            _contributor, tokensAvailable, tokensSold, _wei, collectedWei);\n\n        require(tokens > 0 && tokens <= tokensAvailable);\n        tokensSold = tokensSold.add(tokens);\n\n        allocator.allocate(_contributor, tokens);\n\n        if (msg.value > 0) {\n            contributionForwarder.forward.value(msg.value)();\n        }\n\n        emit Contribution(_contributor, _wei, tokensExcludingBonus, bonus);\n    }\n\n    /// @notice check sign\n    function verify(address _sender, uint8 _v, bytes32 _r, bytes32 _s) public view returns (address) {\n        bytes32 hash = keccak256(abi.encodePacked(this, _sender));\n\n        bytes memory prefix = '\\x19Ethereum Signed Message:\\n32';\n\n        return ecrecover(keccak256(abi.encodePacked(prefix, hash)), _v, _r, _s);\n    }\n\n    /// @return Crowdsale state\n    function getState() public view returns (State) {\n        if (finalized) {\n            return State.Finalized;\n        } else if (allocator.isInitialized() == false) {\n            return State.Initializing;\n        } else if (contributionForwarder.isInitialized() == false) {\n            return State.Initializing;\n        } else if (pricingStrategy.isInitialized() == false) {\n            return State.Initializing;\n        } else if (block.timestamp < startDate) {\n            return State.BeforeCrowdsale;\n        } else if (block.timestamp >= startDate && block.timestamp <= endDate) {\n            return State.InCrowdsale;\n        } else if (block.timestamp > endDate) {\n            return State.Success;\n        }\n\n        return State.Unknown;\n    }\n}\n/// @title HardCappedCrowdsale\n/// @author Applicature\n/// @notice Contract is responsible for collecting, refunding, allocating tokens during different stages of Crowdsale.\n/// with hard limit\ncontract HardCappedCrowdsale is CrowdsaleImpl {\n\n    using SafeMath for uint256;\n\n    uint256 public hardCap;\n\n    constructor(\n        TokenAllocator _allocator,\n        ContributionForwarder _contributionForwarder,\n        PricingStrategy _pricingStrategy,\n        uint256 _startDate,\n        uint256 _endDate,\n        bool _allowWhitelisted,\n        bool _allowSigned,\n        bool _allowAnonymous,\n        uint256 _hardCap\n    ) public CrowdsaleImpl(\n        _allocator,\n        _contributionForwarder,\n        _pricingStrategy,\n        _startDate,\n        _endDate,\n        _allowWhitelisted,\n        _allowSigned,\n        _allowAnonymous\n    ) {\n        hardCap = _hardCap;\n    }\n\n    /// @return Crowdsale state\n    function getState() public view returns (State) {\n        State state = super.getState();\n\n        if (state == State.InCrowdsale) {\n            if (isHardCapAchieved(0)) {\n                return State.Success;\n            }\n        }\n\n        return state;\n    }\n\n    function isHardCapAchieved(uint256 _value) public view returns (bool) {\n        if (hardCap <= tokensSold.add(_value)) {\n            return true;\n        }\n        return false;\n    }\n\n    function internalContribution(address _contributor, uint256 _wei) internal {\n        require(getState() == State.InCrowdsale);\n\n        uint256 tokensAvailable = allocator.tokensAvailable();\n        uint256 collectedWei = contributionForwarder.weiCollected();\n\n        uint256 tokens;\n        uint256 tokensExcludingBonus;\n        uint256 bonus;\n\n        (tokens, tokensExcludingBonus, bonus) = pricingStrategy.getTokens(\n            _contributor, tokensAvailable, tokensSold, _wei, collectedWei);\n\n        require(tokens <= tokensAvailable && tokens > 0 && false == isHardCapAchieved(tokens.sub(1)));\n\n        tokensSold = tokensSold.add(tokens);\n\n        allocator.allocate(_contributor, tokens);\n\n        if (msg.value > 0) {\n            contributionForwarder.forward.value(msg.value)();\n        }\n        crowdsaleAgent.onContribution(_contributor, _wei, tokensExcludingBonus, bonus);\n        emit Contribution(_contributor, _wei, tokensExcludingBonus, bonus);\n    }\n}\n/// @title RefundableCrowdsale\n/// @author Applicature\n/// @notice Contract is responsible for collecting, refunding, allocating tokens during different stages of Crowdsale.\n/// with hard and soft limits\ncontract RefundableCrowdsale is HardCappedCrowdsale {\n\n    using SafeMath for uint256;\n\n    uint256 public softCap;\n    mapping(address => uint256) public contributorsWei;\n    address[] public contributors;\n\n    event Refund(address _holder, uint256 _wei, uint256 _tokens);\n\n    constructor(\n        TokenAllocator _allocator,\n        ContributionForwarder _contributionForwarder,\n        PricingStrategy _pricingStrategy,\n        uint256 _startDate,\n        uint256 _endDate,\n        bool _allowWhitelisted,\n        bool _allowSigned,\n        bool _allowAnonymous,\n        uint256 _softCap,\n        uint256 _hardCap\n\n    ) public HardCappedCrowdsale(\n        _allocator, _contributionForwarder, _pricingStrategy,\n        _startDate, _endDate,\n        _allowWhitelisted, _allowSigned, _allowAnonymous, _hardCap\n    ) {\n        softCap = _softCap;\n    }\n\n    /// @notice refund ethers to contributor\n    function refund() public {\n        internalRefund(msg.sender);\n    }\n\n    /// @notice refund ethers to delegate\n    function delegatedRefund(address _address) public {\n        internalRefund(_address);\n    }\n\n    function internalContribution(address _contributor, uint256 _wei) internal {\n        require(block.timestamp >= startDate && block.timestamp <= endDate);\n\n        uint256 tokensAvailable = allocator.tokensAvailable();\n        uint256 collectedWei = contributionForwarder.weiCollected();\n\n        uint256 tokens;\n        uint256 tokensExcludingBonus;\n        uint256 bonus;\n\n        (tokens, tokensExcludingBonus, bonus) = pricingStrategy.getTokens(\n            _contributor, tokensAvailable, tokensSold, _wei, collectedWei);\n\n        require(tokens <= tokensAvailable && tokens > 0 && hardCap > tokensSold.add(tokens));\n\n        tokensSold = tokensSold.add(tokens);\n\n        allocator.allocate(_contributor, tokens);\n\n        // transfer only if softcap is reached\n        if (isSoftCapAchieved(0)) {\n            if (msg.value > 0) {\n                contributionForwarder.forward.value(address(this).balance)();\n            }\n        } else {\n            // store contributor if it is not stored before\n            if (contributorsWei[_contributor] == 0) {\n                contributors.push(_contributor);\n            }\n            contributorsWei[_contributor] = contributorsWei[_contributor].add(msg.value);\n        }\n        crowdsaleAgent.onContribution(_contributor, _wei, tokensExcludingBonus, bonus);\n        emit Contribution(_contributor, _wei, tokensExcludingBonus, bonus);\n    }\n\n    function internalRefund(address _holder) internal {\n        updateState();\n        require(block.timestamp > endDate);\n        require(!isSoftCapAchieved(0));\n        require(crowdsaleAgent != address(0));\n\n        uint256 value = contributorsWei[_holder];\n\n        require(value > 0);\n\n        contributorsWei[_holder] = 0;\n        uint256 burnedTokens = crowdsaleAgent.onRefund(_holder, 0);\n\n        _holder.transfer(value);\n\n        emit Refund(_holder, value, burnedTokens);\n    }\n\n    /// @return Crowdsale state\n    function getState() public view returns (State) {\n        State state = super.getState();\n\n        if (state == State.Success) {\n            if (!isSoftCapAchieved(0)) {\n                return State.Refunding;\n            }\n        }\n\n        return state;\n    }\n\n    function isSoftCapAchieved(uint256 _value) public view returns (bool) {\n        if (softCap <= tokensSold.add(_value)) {\n            return true;\n        }\n        return false;\n    }\n}\ncontract CHLCrowdsale is RefundableCrowdsale {\n\n    uint256 public maxSaleSupply = 38972500e18;\n\n    uint256 public usdCollected;\n\n    address public processingFeeAddress;\n    uint256 public percentageAbsMax = 1000;\n    uint256 public processingFeePercentage = 25;\n\n    event ProcessingFeeAllocation(address _contributor, uint256 _feeAmount);\n\n    event Contribution(address _contributor, uint256 _usdAmount, uint256 _tokensExcludingBonus, uint256 _bonus);\n\n    constructor(\n        MintableTokenAllocator _allocator,\n        DistributedDirectContributionForwarder _contributionForwarder,\n        CHLPricingStrategy _pricingStrategy,\n        uint256 _startTime,\n        uint256 _endTime,\n        address _processingFeeAddress\n    ) public RefundableCrowdsale(\n        _allocator,\n        _contributionForwarder,\n        _pricingStrategy,\n        _startTime,\n        _endTime,\n        true,\n        true,\n        false,\n        10000000e5,//softCap\n        102860625e5//hardCap\n    ) {\n        require(_processingFeeAddress != address(0));\n        processingFeeAddress = _processingFeeAddress;\n    }\n\n    function() public payable {\n        require(allowWhitelisted || allowAnonymous);\n\n        if (!allowAnonymous) {\n            if (allowWhitelisted) {\n                require(whitelisted[msg.sender]);\n            }\n        }\n\n        internalContribution(\n            msg.sender,\n            CHLPricingStrategy(pricingStrategy).getUSDAmountByWeis(msg.value)\n        );\n    }\n\n    /// @notice allows to do signed contributions\n    function contribute(uint8 _v, bytes32 _r, bytes32 _s) public payable {\n        address recoveredAddress = verify(msg.sender, _v, _r, _s);\n        require(signers[recoveredAddress]);\n        internalContribution(\n            msg.sender,\n            CHLPricingStrategy(pricingStrategy).getUSDAmountByWeis(msg.value)\n        );\n    }\n\n    /// @notice allows external user to do contribution\n    function externalContribution(address _contributor, uint256 _usdAmount) public payable {\n        require(externalContributionAgents[msg.sender]);\n        internalContribution(_contributor, _usdAmount);\n    }\n\n    function updateState() public {\n        (startDate, endDate) = CHLPricingStrategy(pricingStrategy).getActualDates();\n        super.updateState();\n    }\n\n    function isHardCapAchieved(uint256 _value) public view returns (bool) {\n        if (hardCap <= usdCollected.add(_value)) {\n            return true;\n        }\n        return false;\n    }\n\n    function isSoftCapAchieved(uint256 _value) public view returns (bool) {\n        if (softCap <= usdCollected.add(_value)) {\n            return true;\n        }\n        return false;\n    }\n\n    function getUnsoldTokensAmount() public view returns (uint256) {\n        return maxSaleSupply.sub(tokensSold);\n    }\n\n    function updateStatsVars(uint256 _usdAmount, uint256 _tokensAmount) public {\n        require(msg.sender == address(crowdsaleAgent) && _tokensAmount > 0);\n\n        tokensSold = tokensSold.add(_tokensAmount);\n        usdCollected = usdCollected.add(_usdAmount);\n    }\n\n    function internalContribution(address _contributor, uint256 _usdAmount) internal {\n        updateState();\n\n        require(currentState == State.InCrowdsale);\n\n        CHLPricingStrategy pricing = CHLPricingStrategy(pricingStrategy);\n\n        require(!isHardCapAchieved(_usdAmount.sub(1)));\n\n        uint256 tokensAvailable = allocator.tokensAvailable();\n        uint256 collectedWei = contributionForwarder.weiCollected();\n        uint256 tierIndex = pricing.getTierIndex();\n        uint256 tokens;\n        uint256 tokensExcludingBonus;\n        uint256 bonus;\n\n        (tokens, tokensExcludingBonus, bonus) = pricing.getTokens(\n            _contributor, tokensAvailable, tokensSold, _usdAmount, collectedWei);\n\n        require(tokens > 0);\n\n        tokensSold = tokensSold.add(tokens);\n\n        allocator.allocate(_contributor, tokens);\n\n        //allocate Processing fee\n        uint256 processingFeeAmount = tokens.mul(processingFeePercentage).div(percentageAbsMax);\n        allocator.allocate(processingFeeAddress, processingFeeAmount);\n\n        if (isSoftCapAchieved(_usdAmount)) {\n            if (msg.value > 0) {\n                contributionForwarder.forward.value(address(this).balance)();\n            }\n        } else {\n            // store contributor if it is not stored before\n            if (contributorsWei[_contributor] == 0) {\n                contributors.push(_contributor);\n            }\n            if (msg.value > 0) {\n                contributorsWei[_contributor] = contributorsWei[_contributor].add(msg.value);\n            }\n        }\n\n        usdCollected = usdCollected.add(_usdAmount);\n\n        crowdsaleAgent.onContribution(_contributor, tierIndex, tokensExcludingBonus, bonus);\n\n        emit Contribution(_contributor, _usdAmount, tokensExcludingBonus, bonus);\n        emit ProcessingFeeAllocation(_contributor, processingFeeAmount);\n    }\n\n}\ncontract USDExchange is Ownable {\n\n    using SafeMath for uint256;\n\n    uint256 public etherPriceInUSD;\n    uint256 public priceUpdateAt;\n    mapping(address => bool) public trustedAddresses;\n\n    event NewPriceTicker(string _price);\n\n    modifier onlyTursted() {\n        require(trustedAddresses[msg.sender] == true);\n        _;\n    }\n\n    constructor(uint256 _etherPriceInUSD) public {\n        etherPriceInUSD = _etherPriceInUSD;\n        priceUpdateAt = block.timestamp;\n        trustedAddresses[msg.sender] = true;\n    }\n\n    function setTrustedAddress(address _address, bool _status) public onlyOwner {\n        trustedAddresses[_address] = _status;\n    }\n\n    // set ether price in USD with 5 digits after the decimal point\n    //ex. 308.75000\n    //for updating the price through  multivest\n    function setEtherInUSD(string _price) public onlyTursted {\n        bytes memory bytePrice = bytes(_price);\n        uint256 dot = bytePrice.length.sub(uint256(6));\n\n        // check if dot is in 6 position  from  the last\n        require(0x2e == uint(bytePrice[dot]));\n\n        uint256 newPrice = uint256(10 ** 23).div(parseInt(_price, 5));\n\n        require(newPrice > 0);\n\n        etherPriceInUSD = parseInt(_price, 5);\n\n        priceUpdateAt = block.timestamp;\n\n        emit NewPriceTicker(_price);\n    }\n\n    function parseInt(string _a, uint _b) internal pure returns (uint) {\n        bytes memory bresult = bytes(_a);\n        uint res = 0;\n        bool decimals = false;\n        for (uint i = 0; i < bresult.length; i++) {\n            if ((bresult[i] >= 48) && (bresult[i] <= 57)) {\n                if (decimals) {\n                    if (_b == 0) break;\n                    else _b--;\n                }\n                res *= 10;\n                res += uint(bresult[i]) - 48;\n            } else if (bresult[i] == 46) decimals = true;\n        }\n        if (_b > 0) res *= 10 ** _b;\n        return res;\n    }\n}\n/// @title PricingStrategy\n/// @author Applicature\n/// @notice Contract is responsible for calculating tokens amount depending on different criterias\n/// @dev Base class\ncontract PricingStrategy {\n\n    function isInitialized() public view returns (bool);\n\n    function getTokens(\n        address _contributor,\n        uint256 _tokensAvailable,\n        uint256 _tokensSold,\n        uint256 _weiAmount,\n        uint256 _collectedWei\n    )\n        public\n        view\n        returns (uint256 tokens, uint256 tokensExcludingBonus, uint256 bonus);\n\n    function getWeis(\n        uint256 _collectedWei,\n        uint256 _tokensSold,\n        uint256 _tokens\n    )\n        public\n        view\n        returns (uint256 weiAmount, uint256 tokensBonus);\n\n}\n/// @title USDDateTiersPricingStrategy\n/// @author Applicature\n/// @notice Contract is responsible for calculating tokens amount depending on price in USD\n/// @dev implementation\ncontract USDDateTiersPricingStrategy is PricingStrategy, USDExchange {\n\n    using SafeMath for uint256;\n\n    //tokenInUSD token price in usd * 10 ^ 5\n    //maxTokensCollected max tokens amount that can be distributed\n    //bonusCap tokens amount cap; while sold tokens < bonus cap - contributors will receive bonus % tokens\n    //soldTierTokens tokens that already been sold\n    //bonusTierTokens bonus tokens that already been allocated\n    //bonusPercents bonus percentage\n    //minInvestInUSD min investment in usd * 10 * 5\n    //startDate tier start time\n    //endDate tier end time\n    struct Tier {\n        uint256 tokenInUSD;\n        uint256 maxTokensCollected;\n        uint256 bonusCap;\n        uint256 soldTierTokens;\n        uint256 bonusTierTokens;\n        uint256 bonusPercents;\n        uint256 minInvestInUSD;\n        uint256 startDate;\n        uint256 endDate;\n    }\n\n    Tier[] public tiers;\n    uint256 public decimals;\n\n    constructor(uint256[] _tiers, uint256 _decimals, uint256 _etherPriceInUSD) public USDExchange(_etherPriceInUSD) {\n        decimals = _decimals;\n        trustedAddresses[msg.sender] = true;\n        require(_tiers.length % 9 == 0);\n\n        uint256 length = _tiers.length / 9;\n\n        for (uint256 i = 0; i < length; i++) {\n            tiers.push(\n                Tier(\n                    _tiers[i * 9],\n                    _tiers[i * 9 + 1],\n                    _tiers[i * 9 + 2],\n                    _tiers[i * 9 + 3],\n                    _tiers[i * 9 + 4],\n                    _tiers[i * 9 + 5],\n                    _tiers[i * 9 + 6],\n                    _tiers[i * 9 + 7],\n                    _tiers[i * 9 + 8]\n                )\n            );\n        }\n    }\n\n    /// @return tier index\n    function getTierIndex() public view returns (uint256) {\n        for (uint256 i = 0; i < tiers.length; i++) {\n            if (\n                block.timestamp >= tiers[i].startDate &&\n                block.timestamp < tiers[i].endDate &&\n                tiers[i].maxTokensCollected > tiers[i].soldTierTokens\n            ) {\n                return i;\n            }\n        }\n\n        return tiers.length;\n    }\n\n    function getActualTierIndex() public view returns (uint256) {\n        for (uint256 i = 0; i < tiers.length; i++) {\n            if (\n                block.timestamp >= tiers[i].startDate\n                && block.timestamp < tiers[i].endDate\n                && tiers[i].maxTokensCollected > tiers[i].soldTierTokens\n                || block.timestamp < tiers[i].startDate\n            ) {\n                return i;\n            }\n        }\n\n        return tiers.length.sub(1);\n    }\n\n    /// @return actual dates\n    function getActualDates() public view returns (uint256 startDate, uint256 endDate) {\n        uint256 tierIndex = getActualTierIndex();\n        startDate = tiers[tierIndex].startDate;\n        endDate = tiers[tierIndex].endDate;\n    }\n\n    /// @return tokens based on sold tokens and wei amount\n    function getTokens(\n        address,\n        uint256 _tokensAvailable,\n        uint256,\n        uint256 _usdAmount,\n        uint256\n    ) public view returns (uint256 tokens, uint256 tokensExcludingBonus, uint256 bonus) {\n        if (_usdAmount == 0) {\n            return (0, 0, 0);\n        }\n\n        uint256 tierIndex = getTierIndex();\n\n        if (tierIndex < tiers.length && _usdAmount < tiers[tierIndex].minInvestInUSD) {\n            return (0, 0, 0);\n        }\n        if (tierIndex == tiers.length) {\n            return (0, 0, 0);\n        }\n        tokensExcludingBonus = _usdAmount.mul(1e18).div(getTokensInUSD(tierIndex));\n        if (tiers[tierIndex].maxTokensCollected < tiers[tierIndex].soldTierTokens.add(tokensExcludingBonus)) {\n            return (0, 0, 0);\n        }\n\n        bonus = calculateBonusAmount(tierIndex, tokensExcludingBonus);\n\n        tokens = tokensExcludingBonus.add(bonus);\n\n        if (tokens > _tokensAvailable) {\n            return (0, 0, 0);\n        }\n    }\n\n    /// @return usd amount based on required tokens\n    function getUSDAmountByTokens(\n        uint256 _tokens\n    ) public view returns (uint256 totalUSDAmount, uint256 tokensBonus) {\n        if (_tokens == 0) {\n            return (0, 0);\n        }\n\n        uint256 tierIndex = getTierIndex();\n        if (tierIndex == tiers.length) {\n            return (0, 0);\n        }\n        if (tiers[tierIndex].maxTokensCollected < tiers[tierIndex].soldTierTokens.add(_tokens)) {\n            return (0, 0);\n        }\n\n        totalUSDAmount = _tokens.mul(getTokensInUSD(tierIndex)).div(1e18);\n\n        if (totalUSDAmount < tiers[tierIndex].minInvestInUSD) {\n            return (0, 0);\n        }\n\n        tokensBonus = calculateBonusAmount(tierIndex, _tokens);\n    }\n\n    /// @return weis based on sold and required tokens\n    function getWeis(\n        uint256,\n        uint256,\n        uint256 _tokens\n    ) public view returns (uint256 totalWeiAmount, uint256 tokensBonus) {\n        uint256 usdAmount;\n        (usdAmount, tokensBonus) = getUSDAmountByTokens(_tokens);\n\n        if (usdAmount == 0) {\n            return (0, 0);\n        }\n\n        totalWeiAmount = usdAmount.mul(1e18).div(etherPriceInUSD);\n    }\n\n    /// calculates bonus tokens amount by bonusPercents in case if bonusCap is not reached;\n    /// if reached returns 0\n    /// @return bonus tokens amount\n    function calculateBonusAmount(uint256 _tierIndex, uint256 _tokens) public view returns (uint256 bonus) {\n        if (tiers[_tierIndex].soldTierTokens < tiers[_tierIndex].bonusCap) {\n            if (tiers[_tierIndex].soldTierTokens.add(_tokens) <= tiers[_tierIndex].bonusCap) {\n                bonus = _tokens.mul(tiers[_tierIndex].bonusPercents).div(100);\n            } else {\n                bonus = (tiers[_tierIndex].bonusCap.sub(tiers[_tierIndex].soldTierTokens))\n                    .mul(tiers[_tierIndex].bonusPercents).div(100);\n            }\n        }\n    }\n\n    function getTokensInUSD(uint256 _tierIndex) public view returns (uint256) {\n        if (_tierIndex < uint256(tiers.length)) {\n            return tiers[_tierIndex].tokenInUSD;\n        }\n    }\n\n    function getMinEtherInvest(uint256 _tierIndex) public view returns (uint256) {\n        if (_tierIndex < uint256(tiers.length)) {\n            return tiers[_tierIndex].minInvestInUSD.mul(1 ether).div(etherPriceInUSD);\n        }\n    }\n\n    function getUSDAmountByWeis(uint256 _weiAmount) public view returns (uint256) {\n        return _weiAmount.mul(etherPriceInUSD).div(1 ether);\n    }\n\n    /// @notice Check whether contract is initialised\n    /// @return true if initialized\n    function isInitialized() public view returns (bool) {\n        return true;\n    }\n\n    /// @notice updates tier start/end dates by id\n    function updateDates(uint8 _tierId, uint256 _start, uint256 _end) public onlyOwner() {\n        if (_start != 0 && _start < _end && _tierId < tiers.length) {\n            Tier storage tier = tiers[_tierId];\n            tier.startDate = _start;\n            tier.endDate = _end;\n        }\n    }\n}\ncontract CHLPricingStrategy is USDDateTiersPricingStrategy {\n\n    CHLAgent public agent;\n\n    modifier onlyAgent() {\n        require(msg.sender == address(agent));\n        _;\n    }\n\n    event MaxTokensCollectedDecreased(uint256 tierId, uint256 oldValue, uint256 amount);\n\n    constructor(\n        uint256[] _emptyArray,\n        uint256[4] _periods,\n        uint256 _etherPriceInUSD\n    ) public USDDateTiersPricingStrategy(_emptyArray, 18, _etherPriceInUSD) {\n        //pre-ico\n        tiers.push(Tier(0.75e5, 6247500e18, 0, 0, 0, 0, 100e5, _periods[0], _periods[1]));\n        //public ico\n        tiers.push(Tier(3e5, 32725000e18, 0, 0, 0, 0, 100e5, _periods[2], _periods[3]));\n    }\n\n    function getArrayOfTiers() public view returns (uint256[12] tiersData) {\n        uint256 j = 0;\n        for (uint256 i = 0; i < tiers.length; i++) {\n            tiersData[j++] = uint256(tiers[i].tokenInUSD);\n            tiersData[j++] = uint256(tiers[i].maxTokensCollected);\n            tiersData[j++] = uint256(tiers[i].soldTierTokens);\n            tiersData[j++] = uint256(tiers[i].minInvestInUSD);\n            tiersData[j++] = uint256(tiers[i].startDate);\n            tiersData[j++] = uint256(tiers[i].endDate);\n        }\n    }\n\n    function updateTier(\n        uint256 _tierId,\n        uint256 _start,\n        uint256 _end,\n        uint256 _minInvest,\n        uint256 _price,\n        uint256 _bonusCap,\n        uint256 _bonus,\n        bool _updateLockNeeded\n    ) public onlyOwner() {\n        require(\n            _start != 0 &&\n            _price != 0 &&\n            _start < _end &&\n            _tierId < tiers.length\n        );\n\n        if (_updateLockNeeded) {\n            agent.updateLockPeriod(_end);\n        }\n\n        Tier storage tier = tiers[_tierId];\n        tier.tokenInUSD = _price;\n        tier.minInvestInUSD = _minInvest;\n        tier.startDate = _start;\n        tier.endDate = _end;\n        tier.bonusCap = _bonusCap;\n        tier.bonusPercents = _bonus;\n    }\n\n    function setCrowdsaleAgent(CHLAgent _crowdsaleAgent) public onlyOwner {\n        agent = _crowdsaleAgent;\n    }\n\n    function updateTierTokens(uint256 _tierId, uint256 _soldTokens, uint256 _bonusTokens) public onlyAgent {\n        require(_tierId < tiers.length && _soldTokens > 0);\n\n        Tier storage tier = tiers[_tierId];\n        tier.soldTierTokens = tier.soldTierTokens.add(_soldTokens);\n        tier.bonusTierTokens = tier.bonusTierTokens.add(_bonusTokens);\n    }\n\n    function updateMaxTokensCollected(uint256 _tierId, uint256 _amount) public onlyAgent {\n        require(_tierId < tiers.length && _amount > 0);\n\n        Tier storage tier = tiers[_tierId];\n\n        require(tier.maxTokensCollected.sub(_amount) >= tier.soldTierTokens.add(tier.bonusTierTokens));\n\n        emit MaxTokensCollectedDecreased(_tierId, tier.maxTokensCollected, _amount);\n\n        tier.maxTokensCollected = tier.maxTokensCollected.sub(_amount);\n    }\n\n    function getTokensWithoutRestrictions(uint256 _usdAmount) public view returns (\n        uint256 tokens,\n        uint256 tokensExcludingBonus,\n        uint256 bonus\n    ) {\n        if (_usdAmount == 0) {\n            return (0, 0, 0);\n        }\n\n        uint256 tierIndex = getActualTierIndex();\n\n        tokensExcludingBonus = _usdAmount.mul(1e18).div(getTokensInUSD(tierIndex));\n        bonus = calculateBonusAmount(tierIndex, tokensExcludingBonus);\n        tokens = tokensExcludingBonus.add(bonus);\n    }\n\n    function getTierUnsoldTokens(uint256 _tierId) public view returns (uint256) {\n        if (_tierId >= tiers.length) {\n            return 0;\n        }\n\n        return tiers[_tierId].maxTokensCollected.sub(tiers[_tierId].soldTierTokens);\n    }\n\n    function getSaleEndDate() public view returns (uint256) {\n        return tiers[tiers.length.sub(1)].endDate;\n    }\n\n}\ncontract Referral is Ownable {\n\n    using SafeMath for uint256;\n\n    MintableTokenAllocator public allocator;\n    CrowdsaleImpl public crowdsale;\n\n    uint256 public constant DECIMALS = 18;\n\n    uint256 public totalSupply;\n    bool public unLimited;\n    bool public sentOnce;\n\n    mapping(address => bool) public claimed;\n    mapping(address => uint256) public claimedBalances;\n\n    constructor(\n        uint256 _totalSupply,\n        address _allocator,\n        address _crowdsale,\n        bool _sentOnce\n    ) public {\n        require(_allocator != address(0) && _crowdsale != address(0));\n        totalSupply = _totalSupply;\n        if (totalSupply == 0) {\n            unLimited = true;\n        }\n        allocator = MintableTokenAllocator(_allocator);\n        crowdsale = CrowdsaleImpl(_crowdsale);\n        sentOnce = _sentOnce;\n    }\n\n    function setAllocator(address _allocator) public onlyOwner {\n        if (_allocator != address(0)) {\n            allocator = MintableTokenAllocator(_allocator);\n        }\n    }\n\n    function setCrowdsale(address _crowdsale) public onlyOwner {\n        require(_crowdsale != address(0));\n        crowdsale = CrowdsaleImpl(_crowdsale);\n    }\n\n    function multivestMint(\n        address _address,\n        uint256 _amount,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) public {\n        require(true == crowdsale.signers(verify(msg.sender, _amount, _v, _r, _s)));\n        if (true == sentOnce) {\n            require(claimed[_address] == false);\n            claimed[_address] = true;\n        }\n        require(\n            _address == msg.sender &&\n            _amount > 0 &&\n            (true == unLimited || _amount <= totalSupply)\n        );\n        claimedBalances[_address] = claimedBalances[_address].add(_amount);\n        if (false == unLimited) {\n            totalSupply = totalSupply.sub(_amount);\n        }\n        allocator.allocate(_address, _amount);\n    }\n\n    /// @notice check sign\n    function verify(address _sender, uint256 _amount, uint8 _v, bytes32 _r, bytes32 _s) public pure returns (address) {\n        bytes32 hash = keccak256(abi.encodePacked(_sender, _amount));\n\n        bytes memory prefix = '\\x19Ethereum Signed Message:\\n32';\n\n        return ecrecover(keccak256(abi.encodePacked(prefix, hash)), _v, _r, _s);\n    }\n\n}\ncontract CHLReferral is Referral {\n\n    CHLPricingStrategy public pricingStrategy;\n\n    constructor(\n        address _allocator,\n        address _crowdsale,\n        CHLPricingStrategy _strategy\n    ) public Referral(1190000e18, _allocator, _crowdsale, true) {\n        require(_strategy != address(0));\n        pricingStrategy = _strategy;\n    }\n\n    function multivestMint(\n        address _address,\n        uint256 _amount,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) public {\n        require(pricingStrategy.getSaleEndDate() <= block.timestamp);\n        super.multivestMint(_address, _amount, _v, _r, _s);\n    }\n}\ncontract CHLAllocation is Ownable {\n\n    using SafeMath for uint256;\n\n    MintableTokenAllocator public allocator;\n\n    CHLAgent public agent;\n    //manualMintingSupply = Advisors 2975000 + Bounty 1785000 + LWL (Non Profit Initiative) 1190000\n    uint256 public manualMintingSupply = 5950000e18;\n\n    uint256 public foundersVestingAmountPeriodOne = 7140000e18;\n    uint256 public foundersVestingAmountPeriodTwo = 2975000e18;\n    uint256 public foundersVestingAmountPeriodThree = 1785000e18;\n\n    address[] public vestings;\n\n    address public foundersAddress;\n\n    bool public isFoundersTokensSent;\n\n    event VestingCreated(\n        address _vesting,\n        address _beneficiary,\n        uint256 _start,\n        uint256 _cliff,\n        uint256 _duration,\n        uint256 _periods,\n        bool _revocable\n    );\n\n    event VestingRevoked(address _vesting);\n\n    constructor(MintableTokenAllocator _allocator, address _foundersAddress) public {\n        require(_foundersAddress != address(0));\n        foundersAddress = _foundersAddress;\n        allocator = _allocator;\n    }\n\n    function setAllocator(MintableTokenAllocator _allocator) public onlyOwner {\n        require(_allocator != address(0));\n        allocator = _allocator;\n    }\n\n    function setAgent(CHLAgent _agent) public onlyOwner {\n        require(_agent != address(0));\n        agent = _agent;\n    }\n\n    function allocateManualMintingTokens(address[] _addresses, uint256[] _tokens) public onlyOwner {\n        require(_addresses.length == _tokens.length);\n        for (uint256 i = 0; i < _addresses.length; i++) {\n            require(_addresses[i] != address(0) && _tokens[i] > 0 && _tokens[i] <= manualMintingSupply);\n            manualMintingSupply -= _tokens[i];\n\n            allocator.allocate(_addresses[i], _tokens[i]);\n        }\n    }\n\n    function allocatePrivateSaleTokens(\n        uint256 _tierId,\n        uint256 _totalTokensSupply,\n        uint256 _tokenPriceInUsd,\n        address[] _addresses,\n        uint256[] _tokens\n    ) public onlyOwner {\n        require(\n            _addresses.length == _tokens.length &&\n            _totalTokensSupply > 0\n        );\n\n        agent.updateStateWithPrivateSale(_tierId, _totalTokensSupply, _totalTokensSupply.mul(_tokenPriceInUsd).div(1e18));\n\n        for (uint256 i = 0; i < _addresses.length; i++) {\n            require(_addresses[i] != address(0) && _tokens[i] > 0 && _tokens[i] <= _totalTokensSupply);\n            _totalTokensSupply = _totalTokensSupply.sub(_tokens[i]);\n\n            allocator.allocate(_addresses[i], _tokens[i]);\n        }\n\n        require(_totalTokensSupply == 0);\n    }\n\n    function allocateFoundersTokens(uint256 _start) public {\n        require(!isFoundersTokensSent && msg.sender == address(agent));\n\n        isFoundersTokensSent = true;\n\n        allocator.allocate(foundersAddress, foundersVestingAmountPeriodOne);\n\n        createVestingInternal(\n            foundersAddress,\n            _start,\n            0,\n            365 days,\n            1,\n            true,\n            owner,\n            foundersVestingAmountPeriodTwo\n        );\n\n        createVestingInternal(\n            foundersAddress,\n            _start,\n            0,\n            730 days,\n            1,\n            true,\n            owner,\n            foundersVestingAmountPeriodThree\n        );\n    }\n\n    function createVesting(\n        address _beneficiary,\n        uint256 _start,\n        uint256 _cliff,\n        uint256 _duration,\n        uint256 _periods,\n        bool _revocable,\n        address _unreleasedHolder,\n        uint256 _amount\n    ) public onlyOwner returns (PeriodicTokenVesting vesting) {\n\n        vesting = createVestingInternal(\n            _beneficiary,\n            _start,\n            _cliff,\n            _duration,\n            _periods,\n            _revocable,\n            _unreleasedHolder,\n            _amount\n        );\n    }\n\n    function revokeVesting(PeriodicTokenVesting _vesting, ERC20Basic token) public onlyOwner() {\n        _vesting.revoke(token);\n\n        emit VestingRevoked(_vesting);\n    }\n\n    function createVestingInternal(\n        address _beneficiary,\n        uint256 _start,\n        uint256 _cliff,\n        uint256 _duration,\n        uint256 _periods,\n        bool _revocable,\n        address _unreleasedHolder,\n        uint256 _amount\n    ) internal returns (PeriodicTokenVesting) {\n        PeriodicTokenVesting vesting = new PeriodicTokenVesting(\n            _beneficiary, _start, _cliff, _duration, _periods, _revocable, _unreleasedHolder\n        );\n\n        vestings.push(vesting);\n\n        emit VestingCreated(vesting, _beneficiary, _start, _cliff, _duration, _periods, _revocable);\n\n        allocator.allocate(address(vesting), _amount);\n\n        return vesting;\n    }\n\n}\n/**\n * @title TokenVesting\n * @dev A token holder contract that can release its token balance gradually like a\n * typical vesting scheme, with a cliff and vesting period. Optionally revocable by the\n * owner.\n */\ncontract TokenVesting is Ownable {\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20Basic;\n\n  event Released(uint256 amount);\n  event Revoked();\n\n  // beneficiary of tokens after they are released\n  address public beneficiary;\n\n  uint256 public cliff;\n  uint256 public start;\n  uint256 public duration;\n\n  bool public revocable;\n\n  mapping (address => uint256) public released;\n  mapping (address => bool) public revoked;\n\n  /**\n   * @dev Creates a vesting contract that vests its balance of any ERC20 token to the\n   * _beneficiary, gradually in a linear fashion until _start + _duration. By then all\n   * of the balance will have vested.\n   * @param _beneficiary address of the beneficiary to whom vested tokens are transferred\n   * @param _cliff duration in seconds of the cliff in which tokens will begin to vest\n   * @param _start the time (as Unix time) at which point vesting starts \n   * @param _duration duration in seconds of the period in which the tokens will vest\n   * @param _revocable whether the vesting is revocable or not\n   */\n  constructor(\n    address _beneficiary,\n    uint256 _start,\n    uint256 _cliff,\n    uint256 _duration,\n    bool _revocable\n  )\n    public\n  {\n    require(_beneficiary != address(0));\n    require(_cliff <= _duration);\n\n    beneficiary = _beneficiary;\n    revocable = _revocable;\n    duration = _duration;\n    cliff = _start.add(_cliff);\n    start = _start;\n  }\n\n  /**\n   * @notice Transfers vested tokens to beneficiary.\n   * @param token ERC20 token which is being vested\n   */\n  function release(ERC20Basic token) public {\n    uint256 unreleased = releasableAmount(token);\n\n    require(unreleased > 0);\n\n    released[token] = released[token].add(unreleased);\n\n    token.safeTransfer(beneficiary, unreleased);\n\n    emit Released(unreleased);\n  }\n\n  /**\n   * @notice Allows the owner to revoke the vesting. Tokens already vested\n   * remain in the contract, the rest are returned to the owner.\n   * @param token ERC20 token which is being vested\n   */\n  function revoke(ERC20Basic token) public onlyOwner {\n    require(revocable);\n    require(!revoked[token]);\n\n    uint256 balance = token.balanceOf(this);\n\n    uint256 unreleased = releasableAmount(token);\n    uint256 refund = balance.sub(unreleased);\n\n    revoked[token] = true;\n\n    token.safeTransfer(owner, refund);\n\n    emit Revoked();\n  }\n\n  /**\n   * @dev Calculates the amount that has already vested but hasn't been released yet.\n   * @param token ERC20 token which is being vested\n   */\n  function releasableAmount(ERC20Basic token) public view returns (uint256) {\n    return vestedAmount(token).sub(released[token]);\n  }\n\n  /**\n   * @dev Calculates the amount that has already vested.\n   * @param token ERC20 token which is being vested\n   */\n  function vestedAmount(ERC20Basic token) public view returns (uint256) {\n    uint256 currentBalance = token.balanceOf(this);\n    uint256 totalBalance = currentBalance.add(released[token]);\n\n    if (block.timestamp < cliff) {\n      return 0;\n    } else if (block.timestamp >= start.add(duration) || revoked[token]) {\n      return totalBalance;\n    } else {\n      return totalBalance.mul(block.timestamp.sub(start)).div(duration);\n    }\n  }\n}\ncontract PeriodicTokenVesting is TokenVesting {\n    address public unreleasedHolder;\n    uint256 public periods;\n\n    constructor(\n        address _beneficiary,\n        uint256 _start,\n        uint256 _cliff,\n        uint256 _periodDuration,\n        uint256 _periods,\n        bool _revocable,\n        address _unreleasedHolder\n    ) public TokenVesting(_beneficiary, _start, _cliff, _periodDuration, _revocable) {\n        require(_revocable == false || _unreleasedHolder != address(0));\n        periods = _periods;\n        unreleasedHolder = _unreleasedHolder;\n    }\n\n    /**\n    * @dev Calculates the amount that has already vested.\n    * @param token ERC20 token which is being vested\n    */\n    function vestedAmount(ERC20Basic token) public view returns (uint256) {\n        uint256 currentBalance = token.balanceOf(this);\n        uint256 totalBalance = currentBalance.add(released[token]);\n\n        if (now < cliff) {\n            return 0;\n        } else if (now >= start.add(duration * periods) || revoked[token]) {\n            return totalBalance;\n        } else {\n\n            uint256 periodTokens = totalBalance.div(periods);\n\n            uint256 periodsOver = now.sub(start).div(duration);\n\n            if (periodsOver >= periods) {\n                return totalBalance;\n            }\n\n            return periodTokens.mul(periodsOver);\n        }\n    }\n\n    /**\n * @notice Allows the owner to revoke the vesting. Tokens already vested\n * remain in the contract, the rest are returned to the owner.\n * @param token ERC20 token which is being vested\n */\n    function revoke(ERC20Basic token) public onlyOwner {\n        require(revocable);\n        require(!revoked[token]);\n\n        uint256 balance = token.balanceOf(this);\n\n        uint256 unreleased = releasableAmount(token);\n        uint256 refund = balance.sub(unreleased);\n\n        revoked[token] = true;\n\n        token.safeTransfer(unreleasedHolder, refund);\n\n        emit Revoked();\n    }\n}\ncontract Stats {\n\n    using SafeMath for uint256;\n\n    MintableToken public token;\n    MintableTokenAllocator public allocator;\n    CHLCrowdsale public crowdsale;\n    CHLPricingStrategy public pricing;\n\n    constructor(\n        MintableToken _token,\n        MintableTokenAllocator _allocator,\n        CHLCrowdsale _crowdsale,\n        CHLPricingStrategy _pricing\n    ) public {\n        token = _token;\n        allocator = _allocator;\n        crowdsale = _crowdsale;\n        pricing = _pricing;\n    }\n\n    function getTokens(\n        uint256 _type,\n        uint256 _usdAmount\n    ) public view returns (uint256 tokens, uint256 tokensExcludingBonus, uint256 bonus) {\n        _type = _type;\n\n        return pricing.getTokensWithoutRestrictions(_usdAmount);\n    }\n\n    function getWeis(\n        uint256 _type,\n        uint256 _tokenAmount\n    ) public view returns (uint256 totalWeiAmount, uint256 tokensBonus) {\n        _type = _type;\n\n        return pricing.getWeis(0, 0, _tokenAmount);\n    }\n\n    function getUSDAmount(\n        uint256 _type,\n        uint256 _tokenAmount\n    ) public view returns (uint256 totalUSDAmount, uint256 tokensBonus) {\n        _type = _type;\n\n        return pricing.getUSDAmountByTokens(_tokenAmount);\n    }\n\n    function getStats(uint256 _userType, uint256[7] _ethPerCurrency) public view returns (\n        uint256[8] stats,\n        uint256[26] tiersData,\n        uint256[21] currencyContr //tokensPerEachCurrency,\n    ) {\n        stats = getStatsData(_userType);\n        tiersData = getTiersData(_userType);\n        currencyContr = getCurrencyContrData(_userType, _ethPerCurrency);\n    }\n\n    function getTiersData(uint256 _type) public view returns (\n        uint256[26] tiersData\n    ) {\n        _type = _type;\n        uint256[12] memory tiers = pricing.getArrayOfTiers();\n        uint256 length = tiers.length / 6;\n\n        uint256 j = 0;\n        for (uint256 i = 0; i < length; i++) {\n            tiersData[j++] = uint256(1e23).div(tiers[i.mul(6)]);// tokenInUSD;\n            tiersData[j++] = 0;// tokenInWei;\n            tiersData[j++] = uint256(tiers[i.mul(6).add(1)]);// maxTokensCollected;\n            tiersData[j++] = uint256(tiers[i.mul(6).add(2)]);// soldTierTokens;\n            tiersData[j++] = 0;// discountPercents;\n            tiersData[j++] = 0;// bonusPercents;\n            tiersData[j++] = uint256(tiers[i.mul(6).add(3)]);// minInvestInUSD;\n            tiersData[j++] = 0;// minInvestInWei;\n            tiersData[j++] = 0;// maxInvestInUSD;\n            tiersData[j++] = 0;// maxInvestInWei;\n            tiersData[j++] = uint256(tiers[i.mul(6).add(4)]); // startDate;\n            tiersData[j++] = uint256(tiers[i.mul(6).add(5)]); // endDate;\n            tiersData[j++] = 1;\n        }\n\n        tiersData[25] = 2;\n\n    }\n\n    function getStatsData(uint256 _type) public view returns (\n        uint256[8] stats\n    ) {\n        _type = _type;\n        stats[0] = token.maxSupply();\n        stats[1] = token.totalSupply();\n        stats[2] = crowdsale.maxSaleSupply();\n        stats[3] = crowdsale.tokensSold();\n        stats[4] = uint256(crowdsale.currentState());\n        stats[5] = pricing.getActualTierIndex();\n        stats[6] = pricing.getTierUnsoldTokens(stats[5]);\n        stats[7] = pricing.getMinEtherInvest(stats[5]);\n    }\n\n    function getCurrencyContrData(uint256 _type, uint256[7] _usdPerCurrency) public view returns (\n        uint256[21] currencyContr\n    ) {\n        _type = _type;\n        uint256 j = 0;\n        for (uint256 i = 0; i < _usdPerCurrency.length; i++) {\n            (currencyContr[j++], currencyContr[j++], currencyContr[j++]) = pricing.getTokensWithoutRestrictions(\n                _usdPerCurrency[i]\n            );\n        }\n    }\n}",
  "abi": "[{\"constant\":false,\"inputs\":[{\"name\":\"_agent\",\"type\":\"address\"},{\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"updateBurnAgent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"updateExcludedAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"time\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_holder\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"burnAgents\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allowedMinting\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_holder\",\"type\":\"address\"},{\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isSoftCapAchieved\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_holder\",\"type\":\"address\"},{\"name\":\"_tokensToBurn\",\"type\":\"uint256\"}],\"name\":\"burnByAgent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"standard\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"isTransferAllowed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"availableTokens\",\"outputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_agent\",\"type\":\"address\"},{\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"updateStateChangeAgent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableMinting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setIsSoftCapAchieved\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsale\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"mintingAgents\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"stateChangeAgents\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_agent\",\"type\":\"address\"},{\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"updateMintingAgent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"excludedAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokensToBurn\",\"type\":\"uint256\"}],\"name\":\"burnUnsoldTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_unlockTokensTime\",\"type\":\"uint256\"}],\"name\":\"setUnlockTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newMaxSupply\",\"type\":\"uint256\"}],\"name\":\"updateMaxSupply\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_crowdsale\",\"type\":\"address\"}],\"name\":\"setCrowdSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_unlockTokensTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"burner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]",
  "bytecode": "60806040523480156200001157600080fd5b506040516020806200190f83398101604081815291518282018352600a82527f4368656c6c65436f696e0000000000000000000000000000000000000000000060208084019190915283518085018552600381527f43484c000000000000000000000000000000000000000000000000000000000081830152600083815560058054600160a060020a03191633179055855180870190965260098087527f455243323020302e31000000000000000000000000000000000000000000000096909301958652929485946a31379d7690a13aeb8000009493600193869386938693859391926012929185916200010891908162000213565b50600385905580156200012d5733600090815260026020526040902085905562000140565b3060009081526002602052604090208590555b83516200015590600790602087019062000213565b5081516200016b90600890602085019062000213565b50506006805460ff909316740100000000000000000000000000000000000000000260a060020a60ff021990931692909217909155505050600a839055600354620001c590836401000000006200124c620001ff82021704565b600355600b805491151560ff19928316179055336000908152600c602052604090208054909116600117905550620002b895505050505050565b818101828110156200020d57fe5b92915050565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f106200025657805160ff191683800117855562000286565b8280016001018555821562000286579182015b828111156200028657825182559160200191906001019062000269565b506200029492915062000298565b5090565b620002b591905b808211156200029457600081556001016200029f565b90565b61164780620002c86000396000f3006080604052600436106101ed5763ffffffff7c010000000000000000000000000000000000000000000000000000000060003504166305f6ee2181146101f257806306fdde031461021a5780630764ebd9146102a4578063095ea7b3146102ca57806316ada5471461030257806318160ddd1461032957806323b872dd1461033e5780632d0d0c0914610368578063313ce5671461038957806335b7588f146103b457806340c10f19146103c957806342966c68146103ed57806345bcdbab14610405578063569e9c821461041a5780635a3b7e421461043e5780635eae177c14610453578063661884631461047757806369bb4dc21461049b57806370a08231146104b0578063757f7302146104d157806379ba5097146104f75780637e5cd5c11461050c5780638da5cb5b146105215780639250d59f1461055257806395d89b41146105675780639c1e03a01461057c5780639c7beb8a14610591578063a9059cbb146105b2578063abe2a18d146105d6578063cd8f8b3c146105f7578063cf011b261461061d578063d0479abc1461063e578063d4ee1d9014610656578063d5abeb011461066b578063d73dd62314610680578063dace4557146106a4578063dd62ed3e146106bc578063f103b433146106e3578063f2fde38b146106fb578063f4b5cbc41461071c575b600080fd5b3480156101fe57600080fd5b50610218600160a060020a0360043516602435151561073d565b005b34801561022657600080fd5b5061022f61077f565b6040805160208082528351818301528351919283929083019185019080838360005b83811015610269578181015183820152602001610251565b50505050905090810190601f1680156102965780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b3480156102b057600080fd5b50610218600160a060020a0360043516602435151561080d565b3480156102d657600080fd5b506102ee600160a060020a036004351660243561084f565b604080519115158252519081900360200190f35b34801561030e57600080fd5b506103176108b6565b60408051918252519081900360200190f35b34801561033557600080fd5b506103176108bc565b34801561034a57600080fd5b506102ee600160a060020a03600435811690602435166044356108c2565b34801561037457600080fd5b506102ee600160a060020a03600435166108ef565b34801561039557600080fd5b5061039e610904565b6040805160ff9092168252519081900360200190f35b3480156103c057600080fd5b506102ee610925565b3480156103d557600080fd5b50610218600160a060020a036004351660243561092e565b3480156103f957600080fd5b50610218600435610a53565b34801561041157600080fd5b506102ee610a60565b34801561042657600080fd5b50610317600160a060020a0360043516602435610a81565b34801561044a57600080fd5b5061022f610ac2565b34801561045f57600080fd5b506102ee600160a060020a0360043516602435610b1d565b34801561048357600080fd5b506102ee600160a060020a0360043516602435610c32565b3480156104a757600080fd5b50610317610d22565b3480156104bc57600080fd5b50610317600160a060020a0360043516610d40565b3480156104dd57600080fd5b50610218600160a060020a03600435166024351515610d5b565b34801561050357600080fd5b50610218610d9d565b34801561051857600080fd5b50610218610de2565b34801561052d57600080fd5b50610536610e0c565b60408051600160a060020a039092168252519081900360200190f35b34801561055e57600080fd5b50610218610e1b565b34801561057357600080fd5b5061022f610e70565b34801561058857600080fd5b50610536610ecb565b34801561059d57600080fd5b506102ee600160a060020a0360043516610eda565b3480156105be57600080fd5b506102ee600160a060020a0360043516602435610eef565b3480156105e257600080fd5b506102ee600160a060020a0360043516610f1a565b34801561060357600080fd5b50610218600160a060020a03600435166024351515610f2f565b34801561062957600080fd5b506102ee600160a060020a0360043516610f71565b34801561064a57600080fd5b50610317600435610f86565b34801561066257600080fd5b50610536611016565b34801561067757600080fd5b50610317611025565b34801561068c57600080fd5b506102ee600160a060020a036004351660243561102b565b3480156106b057600080fd5b506102186004356110c4565b3480156106c857600080fd5b50610317600160a060020a03600435811690602435166110e7565b3480156106ef57600080fd5b50610218600435611112565b34801561070757600080fd5b50610218600160a060020a036004351661113b565b34801561072857600080fd5b50610218600160a060020a0360043516611196565b600554600160a060020a0316331461075457600080fd5b600160a060020a03919091166000908152600e60205260409020805460ff1916911515919091179055565b6007805460408051602060026001851615610100026000190190941693909304601f810184900484028201840190925281815292918301828280156108055780601f106107da57610100808354040283529160200191610805565b820191906000526020600020905b8154815290600101906020018083116107e857829003601f168201915b505050505081565b600554600160a060020a0316331461082457600080fd5b600160a060020a03919091166000908152600160205260409020805460ff1916911515919091179055565b336000818152600460209081526040808320600160a060020a038716808552908352818420869055815186815291519394909390927f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925928290030190a35060015b92915050565b60005481565b60035490565b60006108ce8483610b1d565b15156001146108dc57600080fd5b6108e78484846111f1565b949350505050565b600e6020526000908152604090205460ff1681565b60065474010000000000000000000000000000000000000000900460ff1681565b600b5460ff1681565b336000908152600c602052604090205460ff16151561094c57600080fd5b600b5460ff16151560011480156109775750600a54600354610974908363ffffffff61124c16565b11155b151561098257600080fd5b600354610995908263ffffffff61124c16565b6003556109b1816109a584610d40565b9063ffffffff61124c16565b600160a060020a038316600090815260026020526040902055600a5460035414156109e157600b805460ff191690555b604080518281529051600160a060020a038416916000916000805160206115fc8339815191529181900360200190a3604080518281529051600160a060020a038416917f0f6798a560793a54c3bcfe86a93cde1e73087d944c0ea20544137d4121396885919081900360200190a25050565b610a5d3382611259565b50565b600f5474010000000000000000000000000000000000000000900460ff1681565b336000908152600e602052604081205460ff161515610a9f57600080fd5b811515610ab257610aaf83610d40565b91505b610abc8383611259565b50919050565b6009805460408051602060026001851615610100026000190190941693909304601f810184900484028201840190925281815292918301828280156108055780601f106107da57610100808354040283529160200191610805565b600160a060020a038216600090815260016020819052604082205460ff1615151415610b4b575060016108b0565b600f5474010000000000000000000000000000000000000000900460ff16158015610c1c5750600f54600160a060020a03161580610c1c5750600f54604080517f3158c52b0000000000000000000000000000000000000000000000000000000081526000600482018190529151600160a060020a0390931692633158c52b92602480840193602093929083900390910190829087803b158015610bee57600080fd5b505af1158015610c02573d6000803e3d6000fd5b505050506040513d6020811015610c1857600080fd5b5051155b15610c29575060006108b0565b50600192915050565b336000908152600460209081526040808320600160a060020a038616845290915281205480831115610c8757336000908152600460209081526040808320600160a060020a0388168452909152812055610cbc565b610c97818463ffffffff61135e16565b336000908152600460209081526040808320600160a060020a03891684529091529020555b336000818152600460209081526040808320600160a060020a0389168085529083529281902054815190815290519293927f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925929181900390910190a35060019392505050565b6000610d3b600354600a5461135e90919063ffffffff16565b905090565b600160a060020a031660009081526002602052604090205490565b600554600160a060020a03163314610d7257600080fd5b600160a060020a03919091166000908152600d60205260409020805460ff1916911515919091179055565b600654600160a060020a0316331415610de0576006546005805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a039092169190911790555b565b336000908152600d602052604090205460ff161515610e0057600080fd5b600b805460ff19169055565b600554600160a060020a031681565b336000908152600d602052604090205460ff161515610e3957600080fd5b600f805474ff0000000000000000000000000000000000000000191674010000000000000000000000000000000000000000179055565b6008805460408051602060026001851615610100026000190190941693909304601f810184900484028201840190925281815292918301828280156108055780601f106107da57610100808354040283529160200191610805565b600f54600160a060020a031681565b600c6020526000908152604090205460ff1681565b6000610efb3383610b1d565b1515600114610f0957600080fd5b610f138383611370565b9392505050565b600d6020526000908152604090205460ff1681565b600554600160a060020a03163314610f4657600080fd5b600160a060020a03919091166000908152600c60205260409020805460ff1916911515919091179055565b60016020526000908152604090205460ff1681565b336000908152600e602052604081205460ff161515610fa457600080fd5b600a54600354610fba908463ffffffff61124c16565b1115610fc557600080fd5b600a54610fd8908363ffffffff61135e16565b600a556040805183815290516000917fcc16f5dbb4873280815c1ee09dbd06736cffcc184412cf7a71a0fdb75d397ca5919081900360200190a25090565b600654600160a060020a031681565b600a5481565b336000908152600460209081526040808320600160a060020a038616845290915281205461105f908363ffffffff61124c16565b336000818152600460209081526040808320600160a060020a0389168085529083529281902085905580519485525191937f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925929081900390910190a350600192915050565b336000908152600d602052604090205460ff1615156110e257600080fd5b600055565b600160a060020a03918216600090815260046020908152604080832093909416825291909152205490565b600554600160a060020a0316331461112957600080fd5b6000811161113657600080fd5b600a55565b600554600160a060020a0316331461115257600080fd5b600160a060020a038116151561116757600080fd5b6006805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b600554600160a060020a031633146111ad57600080fd5b600160a060020a03811615156111c257600080fd5b600f805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b60008054600160a060020a03851682526001602081905260408320548692849242919091109160ff161515148061122b5750811515811515145b151561123657600080fd5b6112418787876113c3565b979650505050505050565b818101828110156108b057fe5b600160a060020a03821660009081526002602052604090205481111561127e57600080fd5b600160a060020a0382166000908152600260205260409020546112a7908263ffffffff61135e16565b600160a060020a0383166000908152600260205260409020556003546112d3908263ffffffff61135e16565b600355600a546112e9908263ffffffff61135e16565b600a55604080518281529051600160a060020a038416917fcc16f5dbb4873280815c1ee09dbd06736cffcc184412cf7a71a0fdb75d397ca5919081900360200190a2604080518281529051600091600160a060020a038516916000805160206115fc8339815191529181900360200190a35050565b60008282111561136a57fe5b50900390565b60008054338083526001602081905260408420549192849242919091109160ff909116151514806113a45750811515811515145b15156113af57600080fd5b6113b9868661152a565b9695505050505050565b6000600160a060020a03831615156113da57600080fd5b600160a060020a0384166000908152600260205260409020548211156113ff57600080fd5b600160a060020a038416600090815260046020908152604080832033845290915290205482111561142f57600080fd5b600160a060020a038416600090815260026020526040902054611458908363ffffffff61135e16565b600160a060020a03808616600090815260026020526040808220939093559085168152205461148d908363ffffffff61124c16565b600160a060020a0380851660009081526002602090815260408083209490945591871681526004825282812033825290915220546114d1908363ffffffff61135e16565b600160a060020a03808616600081815260046020908152604080832033845282529182902094909455805186815290519287169391926000805160206115fc833981519152929181900390910190a35060019392505050565b6000600160a060020a038316151561154157600080fd5b3360009081526002602052604090205482111561155d57600080fd5b3360009081526002602052604090205461157d908363ffffffff61135e16565b3360009081526002602052604080822092909255600160a060020a038516815220546115af908363ffffffff61124c16565b600160a060020a0384166000818152600260209081526040918290209390935580518581529051919233926000805160206115fc8339815191529281900390910190a3506001929150505600ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa165627a7a723058200bd746049343df967f9095ecc2c40370e3d129a91f26e7eb9617a3d34c1719310029000000000000000000000000000000000000000000000000000000005cf04450",
  "constructorArguments": "000000000000000000000000000000000000000000000000000000005cf04450"
}