{
  "address": "0xaa652d53909b01c5a6b8e7cd814f9adea18c08f7",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "TCRSale",
  "compilerVersion": "v0.4.18+commit.9cf6e910",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2018-01-26\n*/\n\npragma solidity ^0.4.18;\n\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  uint256 public totalSupply;\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n\n\n\n\n\n\n\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    Unpause();\n  }\n}\n\n\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}\n\n\n\n\n\n\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n\n\n\n\n/**\n * @title Burnable Token\n * @dev Token that can be irreversibly burned (destroyed).\n */\ncontract BurnableToken is BasicToken {\n\n    event Burn(address indexed burner, uint256 value);\n\n    /**\n     * @dev Burns a specific amount of tokens.\n     * @param _value The amount of token to be burned.\n     */\n    function burn(uint256 _value) public {\n        require(_value <= balances[msg.sender]);\n        // no need to require value <= totalSupply, since that would imply the\n        // sender's balance is greater than the totalSupply, which *should* be an assertion failure\n\n        address burner = msg.sender;\n        balances[burner] = balances[burner].sub(_value);\n        totalSupply = totalSupply.sub(_value);\n        Burn(burner, _value);\n    }\n}\n\n\n\n\n/**\n * The Transboundary Credit Rating token (TCR - TCRToken) has a fixed supply and restricts the ability\n * to transfer tokens until the owner has called the enableTransfer()\n * function.\n *\n * The owner can associate the token with a token sale contract. In that\n * case, the token balance is moved to the token sale contract, which\n * in turn can transfer its tokens to contributors to the sale.\n */\ncontract TCRToken is StandardToken, BurnableToken, Ownable {\n\n    // Constants\n    string  public constant name = \"Transboundary Credit Rating\";\n    string  public constant symbol = \"TCR\";\n    uint8   public constant decimals = 18;\n    string  public constant website = \"www.tcr.legal\"; \n    uint256 public constant INITIAL_SUPPLY      =  280000000 * (10 ** uint256(decimals));\n    uint256 public constant CROWDSALE_ALLOWANCE =  218400000 * (10 ** uint256(decimals));\n    uint256 public constant ADMIN_ALLOWANCE     =   61600000 * (10 ** uint256(decimals));\n\n    // Properties\n    uint256 public crowdSaleAllowance;      // the number of tokens available for crowdsales\n    uint256 public adminAllowance;          // the number of tokens available for the administrator\n    address public crowdSaleAddr;           // the address of a crowdsale currently selling this token\n    address public adminAddr;               // the address of a crowdsale currently selling this token\n    //bool    public transferEnabled = false; // indicates if transferring tokens is enabled or not\n    bool    public transferEnabled = true;  // Enables everyone to transfer tokens \n\n    // Modifiers\n    modifier onlyWhenTransferEnabled() {\n        if (!transferEnabled) {\n            require(msg.sender == adminAddr || msg.sender == crowdSaleAddr);\n        }\n        _;\n    }\n\n    /**\n     * The listed addresses are not valid recipients of tokens.\n     *\n     * 0x0           - the zero address is not valid\n     * this          - the contract itself should not receive tokens\n     * owner         - the owner has all the initial tokens, but cannot receive any back\n     * adminAddr     - the admin has an allowance of tokens to transfer, but does not receive any\n     * crowdSaleAddr - the crowdsale has an allowance of tokens to transfer, but does not receive any\n     */\n    modifier validDestination(address _to) {\n        require(_to != address(0x0));\n        require(_to != address(this));\n        require(_to != owner);\n        require(_to != address(adminAddr));\n        require(_to != address(crowdSaleAddr));\n        _;\n    }\n\n    /**\n     * Constructor - instantiates token supply and allocates balanace of\n     * to the owner (msg.sender).\n     */\n    function TCRToken(address _admin) public {\n        // the owner is a custodian of tokens that can\n        // give an allowance of tokens for crowdsales\n        // or to the admin, but cannot itself transfer\n        // tokens; hence, this requirement\n        require(msg.sender != _admin);\n\n        totalSupply = INITIAL_SUPPLY;\n        crowdSaleAllowance = CROWDSALE_ALLOWANCE;\n        adminAllowance = ADMIN_ALLOWANCE;\n\n        // mint all tokens\n        balances[msg.sender] = totalSupply.sub(adminAllowance);\n        Transfer(address(0x0), msg.sender, totalSupply.sub(adminAllowance));\n\n        balances[_admin] = adminAllowance;\n        Transfer(address(0x0), _admin, adminAllowance);\n\n        adminAddr = _admin;\n        approve(adminAddr, adminAllowance);\n    }\n\n    /**\n     * Associates this token with a current crowdsale, giving the crowdsale\n     * an allowance of tokens from the crowdsale supply. This gives the\n     * crowdsale the ability to call transferFrom to transfer tokens to\n     * whomever has purchased them.\n     *\n     * Note that if _amountForSale is 0, then it is assumed that the full\n     * remaining crowdsale supply is made available to the crowdsale.\n     *\n     * @param _crowdSaleAddr The address of a crowdsale contract that will sell this token\n     * @param _amountForSale The supply of tokens provided to the crowdsale\n     */\n    function setCrowdsale(address _crowdSaleAddr, uint256 _amountForSale) external onlyOwner {\n        //require(!transferEnabled);\n        require(_amountForSale <= crowdSaleAllowance);\n\n        // if 0, then full available crowdsale supply is assumed\n        uint amount = (_amountForSale == 0) ? crowdSaleAllowance : _amountForSale;\n\n        // Clear allowance of old, and set allowance of new\n        approve(crowdSaleAddr, 0);\n        approve(_crowdSaleAddr, amount);\n\n        crowdSaleAddr = _crowdSaleAddr;\n    }\n\n    /**\n     * Enables the ability of anyone to transfer their tokens. This can\n     * only be called by the token owner. Once enabled, it is not\n     * possible to disable transfers.\n     */\n    /*function enableTransfer() external onlyOwner {\n        transferEnabled = true;\n        approve(crowdSaleAddr, 0);\n        approve(adminAddr, 0);\n        crowdSaleAllowance = 0;\n        adminAllowance = 0;\n    }*/\n\n    /**\n     * Overrides ERC20 transfer function with modifier that prevents the\n     * ability to transfer tokens until after transfers have been enabled.\n     */\n    function transfer(address _to, uint256 _value) public onlyWhenTransferEnabled validDestination(_to) returns (bool) {\n        return super.transfer(_to, _value);\n    }\n\n    /**\n     * Overrides ERC20 transferFrom function with modifier that prevents the\n     * ability to transfer tokens until after transfers have been enabled.\n     */\n    function transferFrom(address _from, address _to, uint256 _value) public onlyWhenTransferEnabled validDestination(_to) returns (bool) {\n        bool result = super.transferFrom(_from, _to, _value);\n        if (result) {\n            if (msg.sender == crowdSaleAddr)\n                crowdSaleAllowance = crowdSaleAllowance.sub(_value);\n            if (msg.sender == adminAddr)\n                adminAllowance = adminAllowance.sub(_value);\n        }\n        return result;\n    }\n\n    /**\n     * Overrides the burn function so that it cannot be called until after\n     * transfers have been enabled.\n     *\n     * @param _value    The amount of tokens to burn in wei-TCR\n     */\n    function burn(uint256 _value) public {\n        require(transferEnabled || msg.sender == owner);\n        super.burn(_value);\n        Transfer(msg.sender, address(0x0), _value);\n    }\n}\n\n\n/**\n * The TCRSale smart contract is used for selling TCR tokens (TCR).\n * It does so by converting ETH received into a quantity of\n * tokens that are transferred to the contributor via the ERC20-compatible\n * transferFrom() function.\n */\ncontract TCRSale is Pausable {\n\n    using SafeMath for uint256;\n\n    // The beneficiary is the future recipient of the funds\n    address public beneficiary;\n\n    // The crowdsale has a funding goal, cap, deadline, and minimum contribution\n    uint public fundingGoal;\n    uint public fundingCap;\n    uint public minContribution;\n    bool public fundingGoalReached = false;\n    bool public fundingCapReached = false;\n    bool public saleClosed = false;\n\n    // Time period of sale (UNIX timestamps)\n    uint public startTime;\n    uint public endTime;\n\n    // Keeps track of the amount of wei raised\n    uint public amountRaised;\n\n    // Refund amount, should it be required\n    uint public refundAmount;\n\n    // The ratio of TCR to Ether\n    uint public rate = 10000;\n    uint public constant LOW_RANGE_RATE = 500;\n    uint public constant HIGH_RANGE_RATE = 20000;\n\n    // prevent certain functions from being recursively called\n    bool private rentrancy_lock = false;\n\n    // The token being sold\n    TCRToken public tokenReward;\n\n    // A map that tracks the amount of wei contributed by address\n    mapping(address => uint256) public balanceOf;\n\n    // Events\n    event GoalReached(address _beneficiary, uint _amountRaised);\n    event CapReached(address _beneficiary, uint _amountRaised);\n    event FundTransfer(address _backer, uint _amount, bool _isContribution);\n\n    // Modifiers\n    modifier beforeDeadline()   { require (currentTime() < endTime); _; }\n    modifier afterDeadline()    { require (currentTime() >= endTime); _; }\n    modifier afterStartTime()    { require (currentTime() >= startTime); _; }\n\n    modifier saleNotClosed()    { require (!saleClosed); _; }\n\n    modifier nonReentrant() {\n        require(!rentrancy_lock);\n        rentrancy_lock = true;\n        _;\n        rentrancy_lock = false;\n    }\n\n    /**\n     * Constructor for a crowdsale of QuantstampToken tokens.\n     *\n     * @param ifSuccessfulSendTo            the beneficiary of the fund\n     * @param fundingGoalInEthers           the minimum goal to be reached\n     * @param fundingCapInEthers            the cap (maximum) size of the fund\n     * @param minimumContributionInWei      minimum contribution (in wei)\n     * @param start                         the start time (UNIX timestamp)\n     * @param end                           the end time (UNIX timestamp)\n     * @param rateTcrToEther                the conversion rate from TCR to Ether\n     * @param addressOfTokenUsedAsReward    address of the token being sold\n     */\n    function TCRSale(\n        address ifSuccessfulSendTo,\n        uint fundingGoalInEthers,\n        uint fundingCapInEthers,\n        uint minimumContributionInWei,\n        uint start,\n        uint end,\n        uint rateTcrToEther,\n        address addressOfTokenUsedAsReward\n    ) public {\n        require(ifSuccessfulSendTo != address(0) && ifSuccessfulSendTo != address(this));\n        require(addressOfTokenUsedAsReward != address(0) && addressOfTokenUsedAsReward != address(this));\n        require(fundingGoalInEthers <= fundingCapInEthers);\n        require(end > 0);\n        beneficiary = ifSuccessfulSendTo;\n        fundingGoal = fundingGoalInEthers * 1 ether;\n        fundingCap = fundingCapInEthers * 1 ether;\n        minContribution = minimumContributionInWei;\n        startTime = start;\n        endTime = end; // TODO double check\n        setRate(rateTcrToEther);\n        tokenReward = TCRToken(addressOfTokenUsedAsReward);\n    }\n\n    /**\n     * This fallback function is called whenever Ether is sent to the\n     * smart contract. It can only be executed when the crowdsale is\n     * not paused, not closed, and before the deadline has been reached.\n     *\n     * This function will update state variables for whether or not the\n     * funding goal or cap have been reached. It also ensures that the\n     * tokens are transferred to the sender, and that the correct\n     * number of tokens are sent according to the current rate.\n     */\n    function () public payable whenNotPaused beforeDeadline afterStartTime saleNotClosed nonReentrant {\n        require(msg.value >= minContribution);\n\n        // Update the sender's balance of wei contributed and the amount raised\n        uint amount = msg.value;\n        uint currentBalance = balanceOf[msg.sender];\n        balanceOf[msg.sender] = currentBalance.add(amount);\n        amountRaised = amountRaised.add(amount);\n\n        // Compute the number of tokens to be rewarded to the sender\n        // Note: it's important for this calculation that both wei\n        // and TCR have the same number of decimal places (18)\n        uint numTokens = amount.mul(rate);\n\n        // Transfer the tokens from the crowdsale supply to the sender\n        if (tokenReward.transferFrom(tokenReward.owner(), msg.sender, numTokens)) {\n            FundTransfer(msg.sender, amount, true);\n            // Check if the funding goal or cap have been reached\n            // TODO check impact on gas cost\n            checkFundingGoal();\n            checkFundingCap();\n        }\n        else {\n            revert();\n        }\n    }\n\n    /**\n     * The owner can terminate the crowdsale at any time.\n     */\n    function terminate() external onlyOwner {\n        saleClosed = true;\n    }\n\n    /**\n     * The owner can update the rate (TCR to ETH).\n     *\n     * @param _rate  the new rate for converting TCR to ETH\n     */\n    function setRate(uint _rate) public onlyOwner {\n        require(_rate >= LOW_RANGE_RATE && _rate <= HIGH_RANGE_RATE);\n        rate = _rate;\n    }\n\n    /**\n     * The owner can allocate the specified amount of tokens from the\n     * crowdsale allowance to the recipient (_to).\n     *\n     * NOTE: be extremely careful to get the amounts correct, which\n     * are in units of wei and mini-TCR. Every digit counts.\n     *\n     * @param _to            the recipient of the tokens\n     * @param amountWei     the amount contributed in wei\n     * @param amountMiniTcr the amount of tokens transferred in mini-TCR (18 decimals)\n     */\n    function ownerAllocateTokens(address _to, uint amountWei, uint amountMiniTcr) external\n            onlyOwner nonReentrant\n    {\n        if (!tokenReward.transferFrom(tokenReward.owner(), _to, amountMiniTcr)) {\n            revert();\n        }\n        balanceOf[_to] = balanceOf[_to].add(amountWei);\n        amountRaised = amountRaised.add(amountWei);\n        FundTransfer(_to, amountWei, true);\n        checkFundingGoal();\n        checkFundingCap();\n    }\n\n    /**\n     * The owner can call this function to withdraw the funds that\n     * have been sent to this contract for the crowdsale subject to\n     * the funding goal having been reached. The funds will be sent\n     * to the beneficiary specified when the crowdsale was created.\n     */\n    function ownerSafeWithdrawal() external onlyOwner nonReentrant {\n        require(fundingGoalReached);\n        uint balanceToSend = this.balance;\n        beneficiary.transfer(balanceToSend);\n        FundTransfer(beneficiary, balanceToSend, false);\n    }\n\n    /**\n     * The owner can unlock the fund with this function. The use-\n     * case for this is when the owner decides after the deadline\n     * to allow contributors to be refunded their contributions.\n     * Note that the fund would be automatically unlocked if the\n     * minimum funding goal were not reached.\n     */\n    function ownerUnlockFund() external afterDeadline onlyOwner {\n        fundingGoalReached = false;\n    }\n\n    /**\n     * This function permits anybody to withdraw the funds they have\n     * contributed if and only if the deadline has passed and the\n     * funding goal was not reached.\n     */\n    function safeWithdrawal() external afterDeadline nonReentrant {\n        if (!fundingGoalReached) {\n            uint amount = balanceOf[msg.sender];\n            balanceOf[msg.sender] = 0;\n            if (amount > 0) {\n                msg.sender.transfer(amount);\n                FundTransfer(msg.sender, amount, false);\n                refundAmount = refundAmount.add(amount);\n            }\n        }\n    }\n\n    /**\n     * Checks if the funding goal has been reached. If it has, then\n     * the GoalReached event is triggered.\n     */\n    function checkFundingGoal() internal {\n        if (!fundingGoalReached) {\n            if (amountRaised >= fundingGoal) {\n                fundingGoalReached = true;\n                GoalReached(beneficiary, amountRaised);\n            }\n        }\n    }\n\n    /**\n     * Checks if the funding cap has been reached. If it has, then\n     * the CapReached event is triggered.\n     */\n    function checkFundingCap() internal {\n        if (!fundingCapReached) {\n            if (amountRaised >= fundingCap) {\n                fundingCapReached = true;\n                saleClosed = true;\n                CapReached(beneficiary, amountRaised);\n            }\n        }\n    }\n\n    /**\n     * Returns the current time.\n     * Useful to abstract calls to \"now\" for tests.\n    */\n    function currentTime() public constant returns (uint _currentTime) {\n        return now;\n    }\n\n\n    /**\n     * Given an amount in TCR, this method returns the equivalent amount\n     * in mini-TCR.\n     *\n     * @param amount    an amount expressed in units of TCR\n     */\n    function convertToMiniTcr(uint amount) internal constant returns (uint) {\n        return amount * (10 ** uint(tokenReward.decimals()));\n    }\n\n    /**\n     * These helper functions are exposed for changing the start and end time dynamically   \n     */\n    function changeStartTime(uint256 _startTime) external onlyOwner {startTime = _startTime;}\n    function changeEndTime(uint256 _endTime) external onlyOwner {endTime = _endTime;}\n}",
  "bytecode": "60606040526000805460a060020a60ff02191690556005805462ffffff19169055612710600a55600b805460ff19169055341561003b57600080fd5b604051610100806110f4833981016040528080519190602001805191906020018051919060200180519190602001805191906020018051919060200180519190602001805160008054600160a060020a03191633600160a060020a0390811691909117909155909250891615801591506100c7575030600160a060020a031688600160a060020a031614155b15156100d257600080fd5b600160a060020a038116158015906100fc575030600160a060020a031681600160a060020a031614155b151561010757600080fd5b8587111561011457600080fd5b6000831161012157600080fd5b60018054600160a060020a031916600160a060020a038a16179055670de0b6b3a76400008781026002558602600355600485905560068490556007839055610175826401000000006101a88102610a2e1704565b600b8054600160a060020a039092166101000261010060a860020a0319909216919091179055506101e795505050505050565b60005433600160a060020a039081169116146101c357600080fd5b6101f481101580156101d75750614e208111155b15156101e257600080fd5b600a55565b610efe806101f66000396000f3006060604052600436106101665763ffffffff60e060020a6000350416630c08bf8881146103b657806323ec8f62146103cb57806328e08186146103de5780632c4e722e146104035780633052b75e146104285780633197cbb61461043e57806334fcf4371461045157806338af3eed146104675780633f4ba83a146104965780635c975abb146104a95780636e66f6e9146104d057806370a08231146104e3578063782e34c91461050257806378e97925146105155780637a3a0e84146105285780637b3e5e7b1461053b5780638456cb591461054e578063848b3821146105615780638aa5b2c3146105745780638da5cb5b1461058a578063aaffadf31461059d578063ad33513f146105b0578063b8c766b8146105c3578063d18e81b3146105d6578063d424f628146105e9578063e3b2594f146105fc578063ea8712461461060f578063ef35fc1614610622578063f2fde38b14610635578063fd6b7ef814610654575b600080548190819060a060020a900460ff161561018257600080fd5b60075461018d610667565b1061019757600080fd5b6006546101a2610667565b10156101ad57600080fd5b60055462010000900460ff16156101c357600080fd5b600b5460ff16156101d357600080fd5b600b805460ff191660011790556004543410156101ef57600080fd5b600160a060020a0333166000908152600c6020526040902054349350915061021d828463ffffffff61066b16565b600160a060020a0333166000908152600c6020526040902055600854610249908463ffffffff61066b16565b600855600a5461026090849063ffffffff61068516565b600b549091506101009004600160a060020a03166323b872dd81638da5cb5b6000604051602001526040518163ffffffff1660e060020a028152600401602060405180830381600087803b15156102b657600080fd5b6102c65a03f115156102c757600080fd5b50505060405180519050338460006040516020015260405160e060020a63ffffffff8616028152600160a060020a0393841660048201529190921660248201526044810191909152606401602060405180830381600087803b151561032b57600080fd5b6102c65a03f1151561033c57600080fd5b50505060405180519050156103a257600080516020610eb383398151915233846001604051600160a060020a039093168352602083019190915215156040808301919091526060909101905180910390a16103956106b0565b61039d61072b565b6103a7565b600080fd5b5050600b805460ff1916905550005b34156103c157600080fd5b6103c96107b8565b005b34156103d657600080fd5b6103c96107e6565b34156103e957600080fd5b6103c9600160a060020a0360043516602435604435610823565b341561040e57600080fd5b610416610a02565b60405190815260200160405180910390f35b341561043357600080fd5b6103c9600435610a08565b341561044957600080fd5b610416610a28565b341561045c57600080fd5b6103c9600435610a2e565b341561047257600080fd5b61047a610a6d565b604051600160a060020a03909116815260200160405180910390f35b34156104a157600080fd5b6103c9610a7c565b34156104b457600080fd5b6104bc610afb565b604051901515815260200160405180910390f35b34156104db57600080fd5b61047a610b0b565b34156104ee57600080fd5b610416600160a060020a0360043516610b1f565b341561050d57600080fd5b6103c9610b31565b341561052057600080fd5b610416610c0f565b341561053357600080fd5b610416610c15565b341561054657600080fd5b610416610c1b565b341561055957600080fd5b6103c9610c21565b341561056c57600080fd5b6104bc610ca5565b341561057f57600080fd5b6103c9600435610cb3565b341561059557600080fd5b61047a610cd3565b34156105a857600080fd5b610416610ce2565b34156105bb57600080fd5b610416610ce8565b34156105ce57600080fd5b6104bc610cee565b34156105e157600080fd5b610416610667565b34156105f457600080fd5b6104bc610cfd565b341561060757600080fd5b610416610d06565b341561061a57600080fd5b610416610d0c565b341561062d57600080fd5b610416610d12565b341561064057600080fd5b6103c9600160a060020a0360043516610d18565b341561065f57600080fd5b6103c9610db3565b4290565b60008282018381101561067a57fe5b8091505b5092915050565b600080831515610698576000915061067e565b508282028284828115156106a857fe5b041461067a57fe5b60055460ff1615156107295760025460085410610729576005805460ff19166001908117909155546008547fec3f991caf7857d61663fd1bba1739e04abd4781238508cde554bb849d790c8591600160a060020a031690604051600160a060020a03909216825260208201526040908101905180910390a15b565b600554610100900460ff1615156107295760035460085410610729576005805462ff00001961ff00199091166101001716620100001790556001546008547f195de8a1ebf5a1244af169b7e0bd0f735307a2626a73abce88f9b488628c6c2491600160a060020a031690604051600160a060020a03909216825260208201526040908101905180910390a1565b60005433600160a060020a039081169116146107d357600080fd5b6005805462ff0000191662010000179055565b6007546107f1610667565b10156107fc57600080fd5b60005433600160a060020a0390811691161461081757600080fd5b6005805460ff19169055565b60005433600160a060020a0390811691161461083e57600080fd5b600b5460ff161561084e57600080fd5b600b805460ff191660011790819055600160a060020a03610100909104166323b872dd81638da5cb5b6000604051602001526040518163ffffffff1660e060020a028152600401602060405180830381600087803b15156108ae57600080fd5b6102c65a03f115156108bf57600080fd5b50505060405180519050858460006040516020015260405160e060020a63ffffffff8616028152600160a060020a0393841660048201529190921660248201526044810191909152606401602060405180830381600087803b151561092357600080fd5b6102c65a03f1151561093457600080fd5b50505060405180519050151561094957600080fd5b600160a060020a0383166000908152600c6020526040902054610972908363ffffffff61066b16565b600160a060020a0384166000908152600c602052604090205560085461099e908363ffffffff61066b16565b600855600080516020610eb383398151915283836001604051600160a060020a039093168352602083019190915215156040808301919091526060909101905180910390a16109eb6106b0565b6109f361072b565b5050600b805460ff1916905550565b600a5481565b60005433600160a060020a03908116911614610a2357600080fd5b600755565b60075481565b60005433600160a060020a03908116911614610a4957600080fd5b6101f48110158015610a5d5750614e208111155b1515610a6857600080fd5b600a55565b600154600160a060020a031681565b60005433600160a060020a03908116911614610a9757600080fd5b60005460a060020a900460ff161515610aaf57600080fd5b6000805474ff0000000000000000000000000000000000000000191690557f7805862f689e2f13df9f062ff482ad3ad112aca9e0847911ed832e158c525b3360405160405180910390a1565b60005460a060020a900460ff1681565b600b546101009004600160a060020a031681565b600c6020526000908152604090205481565b6000805433600160a060020a03908116911614610b4d57600080fd5b600b5460ff1615610b5d57600080fd5b600b805460ff1916600117905560055460ff161515610b7b57600080fd5b50600154600160a060020a0330811631911681156108fc0282604051600060405180830381858888f193505050501515610bb457600080fd5b600154600080516020610eb383398151915290600160a060020a0316826000604051600160a060020a039093168352602083019190915215156040808301919091526060909101905180910390a150600b805460ff19169055565b60065481565b60025481565b60085481565b60005433600160a060020a03908116911614610c3c57600080fd5b60005460a060020a900460ff1615610c5357600080fd5b6000805474ff0000000000000000000000000000000000000000191660a060020a1790557f6985a02210a168e66602d3235cb6db0e70f92b3ba4d376a33c0f3d9434bff62560405160405180910390a1565b600554610100900460ff1681565b60005433600160a060020a03908116911614610cce57600080fd5b600655565b600054600160a060020a031681565b60045481565b60095481565b60055462010000900460ff1681565b60055460ff1681565b60035481565b6101f481565b614e2081565b60005433600160a060020a03908116911614610d3357600080fd5b600160a060020a0381161515610d4857600080fd5b600054600160a060020a0380831691167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a36000805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b6000600754610dc0610667565b1015610dcb57600080fd5b600b5460ff1615610ddb57600080fd5b600b805460ff1916600117905560055460ff161515610ea55750600160a060020a0333166000908152600c6020526040812080549082905590811115610ea557600160a060020a03331681156108fc0282604051600060405180830381858888f193505050501515610e4c57600080fd5b600080516020610eb383398151915233826000604051600160a060020a039093168352602083019190915215156040808301919091526060909101905180910390a1600954610ea1908263ffffffff61066b16565b6009555b50600b805460ff191690555600e842aea7a5f1b01049d752008c53c52890b1a6daf660cf39e8eec506112bbdf6a165627a7a7230582059de499f4f0b06c073df5db5dc82c701b5e9c65ae92fa3c6746c294a513939990029000000000000000000000000655f881881498a89dabf2bc72e1d9758285c4f6d00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000002710000000000000000000000000000000000000000000000000002386f26fc10000000000000000000000000000000000000000000000000000000000005abadb00000000000000000000000000000000000000000000000000000000005bad6f0000000000000000000000000000000000000000000000000000000000000027100000000000000000000000009beb657c8ae6c75e1260e231ac1b290620d24272",
  "constructorArguments": "000000000000000000000000655f881881498a89dabf2bc72e1d9758285c4f6d00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000002710000000000000000000000000000000000000000000000000002386f26fc10000000000000000000000000000000000000000000000000000000000005abadb00000000000000000000000000000000000000000000000000000000005bad6f0000000000000000000000000000000000000000000000000000000000000027100000000000000000000000009beb657c8ae6c75e1260e231ac1b290620d24272"
}