{
  "address": "0x801dbbb2fcbf9f4c3865c6ba5c5012ee19ec283a",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "IdentityFactory",
  "compilerVersion": "v0.5.6+commit.b259423e",
  "optimization": false,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2019-05-09\n*/\n\npragma solidity ^0.5.6;\npragma experimental ABIEncoderV2;\n\ninterface GeneralERC20 {\n\tfunction transfer(address to, uint256 value) external;\n\tfunction transferFrom(address from, address to, uint256 value) external;\n\tfunction approve(address spender, uint256 value) external;\n\tfunction balanceOf(address spender) external view returns (uint);\n}\n\nlibrary SafeERC20 {\n\tfunction checkSuccess()\n\t\tprivate\n\t\tpure\n\t\treturns (bool)\n\t{\n\t\tuint256 returnValue = 0;\n\n\t\tassembly {\n\t\t\t// check number of bytes returned from last function call\n\t\t\tswitch returndatasize\n\n\t\t\t// no bytes returned: assume success\n\t\t\tcase 0x0 {\n\t\t\t\treturnValue := 1\n\t\t\t}\n\n\t\t\t// 32 bytes returned: check if non-zero\n\t\t\tcase 0x20 {\n\t\t\t\t// copy 32 bytes into scratch space\n\t\t\t\treturndatacopy(0x0, 0x0, 0x20)\n\n\t\t\t\t// load those bytes into returnValue\n\t\t\t\treturnValue := mload(0x0)\n\t\t\t}\n\n\t\t\t// not sure what was returned: don't mark as success\n\t\t\tdefault { }\n\t\t}\n\n\t\treturn returnValue != 0;\n\t}\n\n\tfunction transfer(address token, address to, uint256 amount) internal {\n\t\tGeneralERC20(token).transfer(to, amount);\n\t\trequire(checkSuccess());\n\t}\n\n\tfunction transferFrom(address token, address from, address to, uint256 amount) internal {\n\t\tGeneralERC20(token).transferFrom(from, to, amount);\n\t\trequire(checkSuccess());\n\t}\n\n\tfunction approve(address token, address spender, uint256 amount) internal {\n\t\tGeneralERC20(token).approve(spender, amount);\n\t\trequire(checkSuccess());\n\t}\n}\n\nlibrary SafeMath {\n\n    function mul(uint a, uint b) internal pure returns (uint) {\n        uint c = a * b;\n        require(a == 0 || c / a == b);\n        return c;\n    }\n\n    function div(uint a, uint b) internal pure returns (uint) {\n        require(b > 0);\n        uint c = a / b;\n        require(a == b * c + a % b);\n        return c;\n    }\n\n    function sub(uint a, uint b) internal pure returns (uint) {\n        require(b <= a);\n        return a - b;\n    }\n\n    function add(uint a, uint b) internal pure returns (uint) {\n        uint c = a + b;\n        require(c >= a);\n        return c;\n    }\n\n    function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n        return a >= b ? a : b;\n    }\n\n    function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n        return a < b ? a : b;\n    }\n\n    function max256(uint a, uint b) internal pure returns (uint) {\n        return a >= b ? a : b;\n    }\n\n    function min256(uint a, uint b) internal pure returns (uint) {\n        return a < b ? a : b;\n    }\n}\n\nlibrary SignatureValidator {\n\tenum SignatureMode {\n\t\tNO_SIG,\n\t\tEIP712,\n\t\tGETH,\n\t\tTREZOR,\n\t\tADEX\n\t}\n\n\tfunction recoverAddr(bytes32 hash, bytes32[3] memory signature) internal pure returns (address) {\n\t\tSignatureMode mode = SignatureMode(uint8(signature[0][0]));\n\n\t\tif (mode == SignatureMode.NO_SIG) {\n\t\t\treturn address(0x0);\n\t\t}\n\n\t\tuint8 v = uint8(signature[0][1]);\n\n\t\tif (mode == SignatureMode.GETH) {\n\t\t\thash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n\t\t} else if (mode == SignatureMode.TREZOR) {\n\t\t\thash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\\x20\", hash));\n\t\t} else if (mode == SignatureMode.ADEX) {\n\t\t\thash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n108By signing this message, you acknowledge signing an AdEx bid with the hash:\\n\", hash));\n\t\t}\n\n\t\treturn ecrecover(hash, v, signature[1], signature[2]);\n\t}\n\n\t/// @dev Validates that a hash was signed by a specified signer.\n\t/// @param hash Hash which was signed.\n\t/// @param signer Address of the signer.\n\t/// @param signature ECDSA signature along with the mode [{mode}{v}, {r}, {s}]\n\t/// @return Returns whether signature is from a specified user.\n\tfunction isValidSignature(bytes32 hash, address signer, bytes32[3] memory signature) internal pure returns (bool) {\n\t\treturn recoverAddr(hash, signature) == signer;\n\t}\n}\n\n\nlibrary ChannelLibrary {\n\tuint constant MAX_VALIDITY = 365 days;\n\n\t// Both numbers are inclusive\n\tuint constant MIN_VALIDATOR_COUNT = 2;\n\t// This is an arbitrary number, but we impose this limit to restrict on-chain load; also to ensure the *3 operation is safe\n\tuint constant MAX_VALIDATOR_COUNT = 25;\n\n\tenum State {\n\t\tUnknown,\n\t\tActive,\n\t\tExpired\n\t}\n\n\tstruct Channel {\n\t\taddress creator;\n\n\t\taddress tokenAddr;\n\t\tuint tokenAmount;\n\n\t\tuint validUntil;\n\n\t\taddress[] validators;\n\n\t\t// finally, arbitrary bytes32 that allows to... @TODO document that this acts as a nonce\n\t\tbytes32 spec;\n\t}\n\n\tfunction hash(Channel memory channel)\n\t\tinternal\n\t\tview\n\t\treturns (bytes32)\n\t{\n\t\t// In this version of solidity, we can no longer keccak256() directly\n\t\treturn keccak256(abi.encode(\n\t\t\taddress(this),\n\t\t\tchannel.creator,\n\t\t\tchannel.tokenAddr,\n\t\t\tchannel.tokenAmount,\n\t\t\tchannel.validUntil,\n\t\t\tchannel.validators,\n\t\t\tchannel.spec\n\t\t));\n\t}\n\n\tfunction isValid(Channel memory channel, uint currentTime)\n\t\tinternal\n\t\tpure\n\t\treturns (bool)\n\t{\n\t\t// NOTE: validators[] can be sybil'd by passing the same addr a few times\n\t\t// this does not matter since you can sybil validators[] anyway, and that is mitigated off-chain\n\t\tif (channel.validators.length < MIN_VALIDATOR_COUNT) {\n\t\t\treturn false;\n\t\t}\n\t\tif (channel.validators.length > MAX_VALIDATOR_COUNT) {\n\t\t\treturn false;\n\t\t}\n\t\tif (channel.validUntil < currentTime) {\n\t\t\treturn false;\n\t\t}\n\t\tif (channel.validUntil > (currentTime + MAX_VALIDITY)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfunction isSignedBySupermajority(Channel memory channel, bytes32 toSign, bytes32[3][] memory signatures) \n\t\tinternal\n\t\tpure\n\t\treturns (bool)\n\t{\n\t\t// NOTE: each element of signatures[] must signed by the elem with the same index in validators[]\n\t\t// In case someone didn't sign, pass SignatureMode.NO_SIG\n\t\tif (signatures.length != channel.validators.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\tuint signs = 0;\n\t\tuint sigLen = signatures.length;\n\t\tfor (uint i=0; i<sigLen; i++) {\n\t\t\t// NOTE: if a validator has not signed, you can just use SignatureMode.NO_SIG\n\t\t\tif (SignatureValidator.isValidSignature(toSign, channel.validators[i], signatures[i])) {\n\t\t\t\tsigns++;\n\t\t\t}\n\t\t}\n\t\treturn signs*3 >= channel.validators.length*2;\n\t}\n}\n\ncontract ValidatorRegistry {\n\t// The contract will probably just use a mapping, but this is a generic interface\n\tfunction whitelisted(address) view external returns (bool);\n}\n\ncontract Identity {\n\tusing SafeMath for uint;\n\n\t// Storage\n\t// WARNING: be careful when modifying this\n\t// privileges and routineAuthorizations must always be 0th and 1th thing in storage\n\tmapping (address => uint8) public privileges;\n\t// Routine authorizations\n\tmapping (bytes32 => bool) public routineAuthorizations;\n\t// The next allowed nonce\n\tuint public nonce = 0;\n\t// Routine operations are authorized at once for a period, fee is paid once\n\tmapping (bytes32 => uint256) public routinePaidFees;\n\n\t// Constants\n\tbytes4 private constant CHANNEL_WITHDRAW_SELECTOR = bytes4(keccak256('channelWithdraw((address,address,uint256,uint256,address[],bytes32),bytes32,bytes32[3][],bytes32[],uint256)'));\n\tbytes4 private constant CHANNEL_WITHDRAW_EXPIRED_SELECTOR = bytes4(keccak256('channelWithdrawExpired((address,address,uint256,uint256,address[],bytes32))'));\n\tbytes4 private constant CHANNEL_OPEN_SELECTOR = bytes4(keccak256('channelOpen((address,address,uint256,uint256,address[],bytes32))'));\n\tuint256 private constant CHANNEL_MAX_VALIDITY = 90 days;\n\n\tenum PrivilegeLevel {\n\t\tNone,\n\t\tRoutines,\n\t\tTransactions,\n\t\tWithdrawTo\n\t}\n\tenum RoutineOp {\n\t\tChannelWithdraw,\n\t\tChannelWithdrawExpired,\n\t\tChannelOpen,\n\t\tWithdraw\n\t}\n\n\t// Events\n\tevent LogPrivilegeChanged(address indexed addr, uint8 privLevel);\n\tevent LogRoutineAuth(bytes32 hash, bool authorized);\n\n\t// Transaction structure\n\t// Those can be executed by keys with >= PrivilegeLevel.Transactions\n\t// Even though the contract cannot receive ETH, we are able to send ETH (.value), cause ETH might've been sent to the contract address before it's deployed\n\tstruct Transaction {\n\t\t// replay protection\n\t\taddress identityContract;\n\t\tuint nonce;\n\t\t// tx fee, in tokens\n\t\taddress feeTokenAddr;\n\t\tuint feeAmount;\n\t\t// all the regular txn data\n\t\taddress to;\n\t\tuint value;\n\t\tbytes data;\n\t}\n\n\t// RoutineAuthorizations allow the user to authorize (via keys >= PrivilegeLevel.Routines) a particular relayer to do any number of routines\n\t// those routines are safe: e.g. withdrawing channels to the identity, or from the identity to the pre-approved withdraw (>= PrivilegeLevel.Withdraw) address\n\t// while the fee will be paid only ONCE per auth, the authorization can be used until validUntil\n\t// while the routines are safe, there is some level of implied trust as the relayer may run executeRoutines without any routines to claim the fee\n\tstruct RoutineAuthorization {\n\t\taddress relayer;\n\t\taddress outpace;\n\t\taddress registry;\n\t\tuint validUntil;\n\t\taddress feeTokenAddr;\n\t\tuint weeklyFeeAmount;\n\t}\n\tstruct RoutineOperation {\n\t\tRoutineOp mode;\n\t\tbytes data;\n\t}\n\n\tconstructor(address[] memory addrs, uint8[] memory privLevels)\n\t\tpublic\n\t{\n\t\tuint len = privLevels.length;\n\t\tfor (uint i=0; i<len; i++) {\n\t\t\tprivileges[addrs[i]] = privLevels[i];\n\t\t\temit LogPrivilegeChanged(addrs[i], privLevels[i]);\n\t\t}\n\t}\n\n\tfunction setAddrPrivilege(address addr, uint8 privLevel)\n\t\texternal\n\t{\n\t\trequire(msg.sender == address(this), 'ONLY_IDENTITY_CAN_CALL');\n\t\tprivileges[addr] = privLevel;\n\t\temit LogPrivilegeChanged(addr, privLevel);\n\t}\n\n\tfunction setRoutineAuth(bytes32 hash, bool authorized)\n\t\texternal\n\t{\n\t\trequire(msg.sender == address(this), 'ONLY_IDENTITY_CAN_CALL');\n\t\troutineAuthorizations[hash] = authorized;\n\t\temit LogRoutineAuth(hash, authorized);\n\t}\n\n\tfunction execute(Transaction[] memory txns, bytes32[3][] memory signatures)\n\t\tpublic\n\t{\n\t\taddress feeTokenAddr = txns[0].feeTokenAddr;\n\t\tuint feeAmount = 0;\n\t\tuint len = txns.length;\n\t\tfor (uint i=0; i<len; i++) {\n\t\t\tTransaction memory txn = txns[i];\n\t\t\trequire(txn.identityContract == address(this), 'TRANSACTION_NOT_FOR_CONTRACT');\n\t\t\trequire(txn.feeTokenAddr == feeTokenAddr, 'EXECUTE_NEEDS_SINGLE_TOKEN');\n\t\t\trequire(txn.nonce == nonce, 'WRONG_NONCE');\n\n\t\t\t// If we use the naive abi.encode(txn) and have a field of type `bytes`,\n\t\t\t// there is a discrepancy between ethereumjs-abi and solidity\n\t\t\t// if we enter every field individually, in order, there is no discrepancy\n\t\t\t//bytes32 hash = keccak256(abi.encode(txn));\n\t\t\tbytes32 hash = keccak256(abi.encode(txn.identityContract, txn.nonce, txn.feeTokenAddr, txn.feeAmount, txn.to, txn.value, txn.data));\n\t\t\taddress signer = SignatureValidator.recoverAddr(hash, signatures[i]);\n\n\t\t\trequire(privileges[signer] >= uint8(PrivilegeLevel.Transactions), 'INSUFFICIENT_PRIVILEGE_TRANSACTION');\n\n\t\t\tnonce = nonce.add(1);\n\t\t\tfeeAmount = feeAmount.add(txn.feeAmount);\n\n\t\t\texecuteCall(txn.to, txn.value, txn.data);\n\t\t\t// The actual anti-bricking mechanism - do not allow a signer to drop his own priviledges\n\t\t\trequire(privileges[signer] >= uint8(PrivilegeLevel.Transactions), 'PRIVILEGE_NOT_DOWNGRADED');\n\t\t}\n\t\tif (feeAmount > 0) {\n\t\t\tSafeERC20.transfer(feeTokenAddr, msg.sender, feeAmount);\n\t\t}\n\t}\n\n\tfunction executeBySender(Transaction[] memory txns)\n\t\tpublic\n\t{\n\t\trequire(privileges[msg.sender] >= uint8(PrivilegeLevel.Transactions), 'INSUFFICIENT_PRIVILEGE_SENDER');\n\t\tuint len = txns.length;\n\t\tfor (uint i=0; i<len; i++) {\n\t\t\tTransaction memory txn = txns[i];\n\t\t\trequire(txn.nonce == nonce, 'WRONG_NONCE');\n\n\t\t\tnonce = nonce.add(1);\n\n\t\t\texecuteCall(txn.to, txn.value, txn.data);\n\t\t}\n\t\t// The actual anti-bricking mechanism - do not allow the sender to drop his own priviledges\n\t\trequire(privileges[msg.sender] >= uint8(PrivilegeLevel.Transactions), 'PRIVILEGE_NOT_DOWNGRADED');\n\t}\n\n\tfunction executeRoutines(RoutineAuthorization memory auth, RoutineOperation[] memory operations)\n\t\tpublic\n\t{\n\t\trequire(auth.relayer == msg.sender, 'ONLY_RELAYER_CAN_CALL');\n\t\trequire(auth.validUntil >= now, 'AUTHORIZATION_EXPIRED');\n\t\tbytes32 hash = keccak256(abi.encode(auth));\n\t\trequire(routineAuthorizations[hash], 'NOT_AUTHORIZED');\n\t\tuint len = operations.length;\n\t\tfor (uint i=0; i<len; i++) {\n\t\t\tRoutineOperation memory op = operations[i];\n\t\t\tif (op.mode == RoutineOp.ChannelWithdraw) {\n\t\t\t\t// Channel: Withdraw\n\t\t\t\texecuteCall(auth.outpace, 0, abi.encodePacked(CHANNEL_WITHDRAW_SELECTOR, op.data));\n\t\t\t} else if (op.mode == RoutineOp.ChannelWithdrawExpired) {\n\t\t\t\t// Channel: Withdraw Expired\n\t\t\t\texecuteCall(auth.outpace, 0, abi.encodePacked(CHANNEL_WITHDRAW_EXPIRED_SELECTOR, op.data));\n\t\t\t} else if (op.mode == RoutineOp.ChannelOpen) {\n\t\t\t\t// Channel: open\n\t\t\t\t(ChannelLibrary.Channel memory channel) = abi.decode(op.data, (ChannelLibrary.Channel));\n\t\t\t\t// Ensure validity is sane\n\t\t\t\trequire(channel.validUntil <= (now + CHANNEL_MAX_VALIDITY), 'CHANNEL_EXCEEDED_MAX_VALID');\n\t\t\t\t// Ensure all validators are whitelisted\n\t\t\t\tuint validatorsLen = channel.validators.length;\n\t\t\t\tfor (uint j=0; j<validatorsLen; j++) {\n\t\t\t\t\trequire(\n\t\t\t\t\t\tValidatorRegistry(auth.registry).whitelisted(channel.validators[j]),\n\t\t\t\t\t\t\"VALIDATOR_NOT_WHITELISTED\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tSafeERC20.approve(channel.tokenAddr, auth.outpace, 0);\n\t\t\t\tSafeERC20.approve(channel.tokenAddr, auth.outpace, channel.tokenAmount);\n\t\t\t\texecuteCall(auth.outpace, 0, abi.encodePacked(CHANNEL_OPEN_SELECTOR, op.data));\n\t\t\t} else if (op.mode == RoutineOp.Withdraw) {\n\t\t\t\t// Withdraw from identity\n\t\t\t\t(address tokenAddr, address to, uint amount) = abi.decode(op.data, (address, address, uint));\n\t\t\t\trequire(privileges[to] >= uint8(PrivilegeLevel.WithdrawTo), 'INSUFFICIENT_PRIVILEGE_WITHDRAW');\n\t\t\t\tSafeERC20.transfer(tokenAddr, to, amount);\n\t\t\t} else {\n\t\t\t\trevert('INVALID_MODE');\n\t\t\t}\n\t\t}\n\t\tif (auth.weeklyFeeAmount > 0 && (now - routinePaidFees[hash]) >= 7 days) {\n\t\t\troutinePaidFees[hash] = now;\n\t\t\tSafeERC20.transfer(auth.feeTokenAddr, msg.sender, auth.weeklyFeeAmount);\n\t\t}\n\t}\n\n\t// we shouldn't use address.call(), cause: https://github.com/ethereum/solidity/issues/2884\n\t// copied from https://github.com/uport-project/uport-identity/blob/develop/contracts/Proxy.sol\n\t// there's also\n\t// https://github.com/gnosis/MultiSigWallet/commit/e1b25e8632ca28e9e9e09c81bd20bf33fdb405ce\n\t// https://github.com/austintgriffith/bouncer-proxy/blob/master/BouncerProxy/BouncerProxy.sol\n\t// https://github.com/gnosis/safe-contracts/blob/7e2eeb3328bb2ae85c36bc11ea6afc14baeb663c/contracts/base/Executor.sol\n\tfunction executeCall(address to, uint256 value, bytes memory data)\n\t\tinternal\n\t{\n\t\tassembly {\n\t\t\tlet result := call(gas, to, value, add(data, 0x20), mload(data), 0, 0)\n\n\t\t\tswitch result case 0 {\n\t\t\t\tlet size := returndatasize\n\t\t\t\tlet ptr := mload(0x40)\n\t\t\t\treturndatacopy(ptr, 0, size)\n\t\t\t\trevert(ptr, size)\n\t\t\t}\n\t\t\tdefault {}\n\t\t}\n\t}\n}\n\ncontract IdentityFactory {\n\tevent LogDeployed(address addr, uint256 salt);\n\n\taddress public relayer;\n\tconstructor(address relayerAddr) public {\n\t\trelayer = relayerAddr;\n\t}\n\n\tfunction deploy(bytes memory code, uint256 salt) public {\n\t\taddress addr;\n\t\tassembly { addr := create2(0, add(code, 0x20), mload(code), salt) }\n\t\trequire(addr != address(0), \"FAILED_DEPLOYING\");\n\t\temit LogDeployed(addr, salt);\n\t}\n\n\tfunction deployAndFund(bytes memory code, uint256 salt, address tokenAddr, uint256 tokenAmount) public {\n\t\trequire(msg.sender == relayer, \"ONLY_RELAYER\");\n\t\taddress addr;\n\t\tassembly { addr := create2(0, add(code, 0x20), mload(code), salt) }\n\t\trequire(addr != address(0), \"FAILED_DEPLOYING\");\n\t\tSafeERC20.transfer(tokenAddr, addr, tokenAmount);\n\t\temit LogDeployed(addr, salt);\n\t}\n\n\tfunction deployAndExecute(bytes memory code, uint256 salt, Identity.Transaction[] memory txns, bytes32[3][] memory signatures) public {\n\t\taddress addr;\n\t\tassembly { addr := create2(0, add(code, 0x20), mload(code), salt) }\n\t\trequire(addr != address(0), \"FAILED_DEPLOYING\");\n\t\tIdentity(addr).execute(txns, signatures);\n\t\temit LogDeployed(addr, salt);\n\t}\n\n\tfunction withdraw(address tokenAddr, address to, uint256 tokenAmount) public {\n\t\trequire(msg.sender == relayer, \"ONLY_RELAYER\");\n\t\tSafeERC20.transfer(tokenAddr, to, tokenAmount);\n\t}\n}",
  "bytecode": "608060405234801561001057600080fd5b50604051602080611214833981018060405261002f9190810190610089565b806000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550506100e4565b600061008182516100b2565b905092915050565b60006020828403121561009b57600080fd5b60006100a984828501610075565b91505092915050565b60006100bd826100c4565b9050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b611121806100f36000396000f3fe608060405234801561001057600080fd5b50600436106100575760003560e01c80634b7028f91461005c5780638406c079146100785780638a976282146100965780639c4ae2d0146100b2578063d9caed12146100ce575b600080fd5b610076600480360361007191908101906109e3565b6100ea565b005b610080610215565b60405161008d9190610d90565b60405180910390f35b6100b060048036036100ab9190810190610968565b61023a565b005b6100cc60048036036100c79190810190610914565b610392565b005b6100e860048036036100e391908101906108c5565b61044e565b005b6000838551602087016000f59050600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff161415610168576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161015f90610e2b565b60405180910390fd5b8073ffffffffffffffffffffffffffffffffffffffff1663951a02af84846040518363ffffffff1660e01b81526004016101a3929190610dd4565b600060405180830381600087803b1580156101bd57600080fd5b505af11580156101d1573d6000803e3d6000fd5b505050507fecef66cbb4d4c8dd18157def75d46290ddc298395ea46f7ff64321c1a912cbad8185604051610206929190610dab565b60405180910390a15050505050565b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146102c9576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016102c090610e0b565b60405180910390fd5b6000838551602087016000f59050600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff161415610347576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161033e90610e2b565b60405180910390fd5b6103528382846104ed565b7fecef66cbb4d4c8dd18157def75d46290ddc298395ea46f7ff64321c1a912cbad8185604051610383929190610dab565b60405180910390a15050505050565b6000818351602085016000f59050600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff161415610410576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161040790610e2b565b60405180910390fd5b7fecef66cbb4d4c8dd18157def75d46290ddc298395ea46f7ff64321c1a912cbad8183604051610441929190610dab565b60405180910390a1505050565b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146104dd576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104d490610e0b565b60405180910390fd5b6104e88383836104ed565b505050565b8273ffffffffffffffffffffffffffffffffffffffff1663a9059cbb83836040518363ffffffff1660e01b8152600401610528929190610dab565b600060405180830381600087803b15801561054257600080fd5b505af1158015610556573d6000803e3d6000fd5b50505050610562610570565b61056b57600080fd5b505050565b600080600090503d6000811461058d5760208114610596576105a2565b600191506105a2565b60206000803e60005191505b50600081141591505090565b60006105ba823561104e565b905092915050565b600082601f8301126105d357600080fd5b81356105e66105e182610e78565b610e4b565b9150818183526020840193506020810190508385606084028201111561060b57600080fd5b60005b8381101561063b57816106218882610645565b84526020840193506060830192505060018101905061060e565b5050505092915050565b600082601f83011261065657600080fd5b600361066961066482610ea0565b610e4b565b9150818385602084028201111561067f57600080fd5b60005b838110156106af5781610695888261072d565b845260208401935060208301925050600181019050610682565b5050505092915050565b600082601f8301126106ca57600080fd5b81356106dd6106d882610ec2565b610e4b565b9150818183526020840193506020810190508360005b83811015610723578135860161070988826107e9565b8452602084019350602083019250506001810190506106f3565b5050505092915050565b60006107398235611060565b905092915050565b600082601f83011261075257600080fd5b813561076561076082610eea565b610e4b565b9150808252602083016020830185838301111561078157600080fd5b61078c838284611094565b50505092915050565b600082601f8301126107a657600080fd5b81356107b96107b482610f16565b610e4b565b915080825260208301602083018583830111156107d557600080fd5b6107e0838284611094565b50505092915050565b600060e082840312156107fb57600080fd5b61080560e0610e4b565b90506000610815848285016105ae565b6000830152506020610829848285016108b1565b602083015250604061083d848285016105ae565b6040830152506060610851848285016108b1565b6060830152506080610865848285016105ae565b60808301525060a0610879848285016108b1565b60a08301525060c082013567ffffffffffffffff81111561089957600080fd5b6108a584828501610741565b60c08301525092915050565b60006108bd823561108a565b905092915050565b6000806000606084860312156108da57600080fd5b60006108e8868287016105ae565b93505060206108f9868287016105ae565b925050604061090a868287016108b1565b9150509250925092565b6000806040838503121561092757600080fd5b600083013567ffffffffffffffff81111561094157600080fd5b61094d85828601610795565b925050602061095e858286016108b1565b9150509250929050565b6000806000806080858703121561097e57600080fd5b600085013567ffffffffffffffff81111561099857600080fd5b6109a487828801610795565b94505060206109b5878288016108b1565b93505060406109c6878288016105ae565b92505060606109d7878288016108b1565b91505092959194509250565b600080600080608085870312156109f957600080fd5b600085013567ffffffffffffffff811115610a1357600080fd5b610a1f87828801610795565b9450506020610a30878288016108b1565b935050604085013567ffffffffffffffff811115610a4d57600080fd5b610a59878288016106b9565b925050606085013567ffffffffffffffff811115610a7657600080fd5b610a82878288016105c2565b91505092959194509250565b6000610a9a8383610b4a565b60608301905092915050565b6000610ab28383610c0e565b60208301905092915050565b6000610aca8383610cd6565b905092915050565b610adb81611008565b82525050565b610aea81611008565b82525050565b6000610afb82610f66565b610b058185610fb9565b9350610b1083610f42565b60005b82811015610b3e57610b26868351610a8e565b9550610b3182610f92565b9150600181019050610b13565b50849250505092915050565b610b5381610f71565b610b5d8184610fca565b9250610b6882610f4f565b60005b82811015610b9657610b7e858351610aa6565b9450610b8982610f9f565b9150600181019050610b6b565b5050505050565b6000610ba882610f7c565b610bb28185610fd5565b935083602082028501610bc485610f59565b60005b84811015610bfd578383038852610bdf838351610abe565b9250610bea82610fac565b9150602088019750600181019050610bc7565b508196508694505050505092915050565b610c178161101a565b82525050565b6000610c2882610f87565b610c328185610fe6565b9350610c428185602086016110a3565b610c4b816110d6565b840191505092915050565b6000610c63600c83610ff7565b91507f4f4e4c595f52454c4159455200000000000000000000000000000000000000006000830152602082019050919050565b6000610ca3601083610ff7565b91507f4641494c45445f4445504c4f59494e47000000000000000000000000000000006000830152602082019050919050565b600060e083016000830151610cee6000860182610ad2565b506020830151610d016020860182610d72565b506040830151610d146040860182610ad2565b506060830151610d276060860182610d72565b506080830151610d3a6080860182610ad2565b5060a0830151610d4d60a0860182610d72565b5060c083015184820360c0860152610d658282610c1d565b9150508091505092915050565b610d7b81611044565b82525050565b610d8a81611044565b82525050565b6000602082019050610da56000830184610ae1565b92915050565b6000604082019050610dc06000830185610ae1565b610dcd6020830184610d81565b9392505050565b60006040820190508181036000830152610dee8185610b9d565b90508181036020830152610e028184610af0565b90509392505050565b60006020820190508181036000830152610e2481610c56565b9050919050565b60006020820190508181036000830152610e4481610c96565b9050919050565b6000604051905081810181811067ffffffffffffffff82111715610e6e57600080fd5b8060405250919050565b600067ffffffffffffffff821115610e8f57600080fd5b602082029050602081019050919050565b600067ffffffffffffffff821115610eb757600080fd5b602082029050919050565b600067ffffffffffffffff821115610ed957600080fd5b602082029050602081019050919050565b600067ffffffffffffffff821115610f0157600080fd5b601f19601f8301169050602081019050919050565b600067ffffffffffffffff821115610f2d57600080fd5b601f19601f8301169050602081019050919050565b6000602082019050919050565b6000819050919050565b6000602082019050919050565b600081519050919050565b600060039050919050565b600081519050919050565b600081519050919050565b6000602082019050919050565b6000602082019050919050565b6000602082019050919050565b600082825260208201905092915050565b600081905092915050565b600082825260208201905092915050565b600082825260208201905092915050565b600082825260208201905092915050565b600061101382611024565b9050919050565b6000819050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b60006110598261106a565b9050919050565b6000819050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b82818337600083830152505050565b60005b838110156110c15780820151818401526020810190506110a6565b838111156110d0576000848401525b50505050565b6000601f19601f830116905091905056fea265627a7a72305820bf80654414cf95f454c4a8a32a197b9da79abe4a33293e351ddf669c3c270a106c6578706572696d656e74616cf50037000000000000000000000000942f9ce5d9a33a82f88d233aeb3292e680230348",
  "constructorArguments": "000000000000000000000000942f9ce5d9a33a82f88d233aeb3292e680230348"
}