{
  "address": "0xfa3445a89f72454909203d602c152b36c2b3f0aa",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "EscrowMaintainContract",
  "compilerVersion": "v0.4.25+commit.59dbf8f1",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2018-11-26\n*/\n\npragma solidity 0.4.25;\n\n\n/**\n * @title SafeCompare\n */\nlibrary SafeCompare {\n  function stringCompare(string str1, string str2) internal pure returns(bool) {\n    return keccak256(abi.encodePacked(str1)) == keccak256(abi.encodePacked(str2));\n  }\n}\n\n\n\n\nlibrary SafeMath {\n\n  /**\n   * @dev Multiplies two numbers, throws on overflow.\n   */\n  function mul(uint256 a, uint256 b) internal pure returns(uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n   * @dev Integer division of two numbers, truncating the quotient.\n   */\n  function div(uint256 a, uint256 b) internal pure returns(uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  /**\n   * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n   */\n  function sub(uint256 a, uint256 b) internal pure returns(uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n   * @dev Adds two numbers, throws on overflow.\n   */\n  function add(uint256 a, uint256 b) internal pure returns(uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract UsdtERC20Basic {\n    uint public _totalSupply;\n    function totalSupply() public constant returns (uint);\n    function balanceOf(address who) public constant returns (uint);\n    function transfer(address to, uint value) public;\n    event Transfer(address indexed from, address indexed to, uint value);\n}\n\n\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns(uint256);\n\n  function balanceOf(address who) public view returns(uint256);\n\n  function transfer(address to, uint256 value) public returns(bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n\n\n/**\n * @title Roles\n * @author Francisco Giordano (@frangio)\n * @dev Library for managing addresses assigned to a Role.\n * See RBAC.sol for example usage.\n */\nlibrary Roles {\n  struct Role {\n    mapping(address => bool) bearer;\n  }\n\n  /**\n   * @dev give an address access to this role\n   */\n  function add(Role storage _role, address _addr)\n  internal {\n    _role.bearer[_addr] = true;\n  }\n\n  /**\n   * @dev remove an address' access to this role\n   */\n  function remove(Role storage _role, address _addr)\n  internal {\n    _role.bearer[_addr] = false;\n  }\n\n  /**\n   * @dev check if an address has this role\n   * // reverts\n   */\n  function check(Role storage _role, address _addr)\n  internal\n  view {\n    require(has(_role, _addr));\n  }\n\n  /**\n   * @dev check if an address has this role\n   * @return bool\n   */\n  function has(Role storage _role, address _addr)\n  internal\n  view\n  returns(bool) {\n    return _role.bearer[_addr];\n  }\n}\n\n\n/**\n * Utility library of inline functions on addresses\n */\nlibrary AddressUtils {\n\n  /**\n   * Returns whether there is code in the target address\n   * @dev This function will return false if invoked during the constructor of a contract,\n   *  as the code is not actually created until after the constructor finishes.\n   * @param addr address address to check\n   * @return whether there is code in the target address\n   */\n  function isContract(address addr) internal view returns(bool) {\n    uint256 size;\n    assembly {\n      size: = extcodesize(addr)\n    }\n    return size > 0;\n  }\n\n}\n\n\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipRenounced(address indexed previousOwner);\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to relinquish control of the contract.\n   * @notice Renouncing to ownership will leave the contract without an owner.\n   * It will not be possible to call the functions with the `onlyOwner`\n   * modifier anymore.\n   */\n  function renounceOwnership() public onlyOwner {\n    emit OwnershipRenounced(owner);\n    owner = address(0);\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address _newOwner) public onlyOwner {\n    _transferOwnership(_newOwner);\n  }\n\n  /**\n   * @dev Transfers control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function _transferOwnership(address _newOwner) internal {\n    require(_newOwner != address(0));\n    emit OwnershipTransferred(owner, _newOwner);\n    owner = _newOwner;\n  }\n}\n\n\n\n\n\n/**\n * @title RBAC (Role-Based Access Control)\n * @author Matt Condon (@Shrugs)\n * @dev Stores and provides setters and getters for roles and addresses.\n * Supports unlimited numbers of roles and addresses.\n * See //contracts/mocks/RBACMock.sol for an example of usage.\n * This RBAC method uses strings to key roles. It may be beneficial\n * for you to write your own implementation of this interface using Enums or similar.\n */\ncontract RBAC {\n  using Roles\n  for Roles.Role;\n\n  mapping(string => Roles.Role) private roles;\n\n  event RoleAdded(address indexed operator, string role);\n  event RoleRemoved(address indexed operator, string role);\n\n  /**\n   * @dev reverts if addr does not have role\n   * @param _operator address\n   * @param _role the name of the role\n   * // reverts\n   */\n  function checkRole(address _operator, string _role)\n  public\n  view {\n    roles[_role].check(_operator);\n  }\n\n  /**\n   * @dev determine if addr has role\n   * @param _operator address\n   * @param _role the name of the role\n   * @return bool\n   */\n  function hasRole(address _operator, string _role)\n  public\n  view\n  returns(bool) {\n    return roles[_role].has(_operator);\n  }\n\n  /**\n   * @dev add a role to an address\n   * @param _operator address\n   * @param _role the name of the role\n   */\n  function addRole(address _operator, string _role)\n  internal {\n    roles[_role].add(_operator);\n    emit RoleAdded(_operator, _role);\n  }\n\n  /**\n   * @dev remove a role from an address\n   * @param _operator address\n   * @param _role the name of the role\n   */\n  function removeRole(address _operator, string _role)\n  internal {\n    roles[_role].remove(_operator);\n    emit RoleRemoved(_operator, _role);\n  }\n\n  /**\n   * @dev modifier to scope access to a single role (uses msg.sender as addr)\n   * @param _role the name of the role\n   * // reverts\n   */\n  modifier onlyRole(string _role) {\n    checkRole(msg.sender, _role);\n    _;\n  }\n\n  /**\n   * @dev modifier to scope access to a set of roles (uses msg.sender as addr)\n   * @param _roles the names of the roles to scope access to\n   * // reverts\n   *\n   * @TODO - when solidity supports dynamic arrays as arguments to modifiers, provide this\n   *  see: https://github.com/ethereum/solidity/issues/2467\n   */\n  // modifier onlyRoles(string[] _roles) {\n  //     bool hasAnyRole = false;\n  //     for (uint8 i = 0; i < _roles.length; i++) {\n  //         if (hasRole(msg.sender, _roles[i])) {\n  //             hasAnyRole = true;\n  //             break;\n  //         }\n  //     }\n\n  //     require(hasAnyRole);\n\n  //     _;\n  // }\n}\n\n\n\n\ncontract PartnerAuthority is Ownable {\n\n\n  address public partner;\n  /**\n   * Event for setPartner logging\n   * @param oldPartner the old  Partner\n   * @param newPartner the new  Partner\n   */\n  event SetPartner(address oldPartner, address newPartner);\n\n  /**\n   * @dev Throws if called by any account other than the owner or the Partner.\n   */\n  modifier onlyOwnerOrPartner() {\n    require(msg.sender == owner || msg.sender == partner);\n    _;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the Partner.\n   */\n  modifier onlyPartner() {\n    require(msg.sender == partner);\n    _;\n  }\n\n\n  /**\n   * @dev setPartner, set the  partner address.\n   */\n  function setPartner(address _partner) public onlyOwner {\n    require(_partner != address(0));\n    emit SetPartner(partner, _partner);\n    partner = _partner;\n  }\n\n\n\n  /**\n   * @dev removePartner, remove  partner address.\n   */\n  function removePartner() public onlyOwner {\n    delete partner;\n  }\n\n\n}\n\n\n\n\n\n\ncontract RBACOperator is Ownable, RBAC {\n\n  /**\n   * A constant role name for indicating operator.\n   */\n  string public constant ROLE_OPERATOR = \"operator\";\n\n  address public partner;\n  /**\n   * Event for setPartner logging\n   * @param oldPartner the old  Partner\n   * @param newPartner the new  Partner\n   */\n  event SetPartner(address oldPartner, address newPartner);\n\n  /**\n   * @dev Throws if called by any account other than the owner or the Partner.\n   */\n  modifier onlyOwnerOrPartner() {\n    require(msg.sender == owner || msg.sender == partner);\n    _;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the Partner.\n   */\n  modifier onlyPartner() {\n    require(msg.sender == partner);\n    _;\n  }\n\n\n  /**\n   * @dev setPartner, set the  partner address.\n   * @param _partner the new  partner address.\n   */\n  function setPartner(address _partner) public onlyOwner {\n    require(_partner != address(0));\n    emit SetPartner(partner, _partner);\n    partner = _partner;\n  }\n\n\n  /**\n   * @dev removePartner, remove  partner address.\n   */\n  function removePartner() public onlyOwner {\n    delete partner;\n  }\n\n  /**\n   * @dev the modifier to operate\n   */\n  modifier hasOperationPermission() {\n    checkRole(msg.sender, ROLE_OPERATOR);\n    _;\n  }\n\n\n\n  /**\n   * @dev add a operator role to an address\n   * @param _operator address\n   */\n  function addOperater(address _operator) public onlyOwnerOrPartner {\n    addRole(_operator, ROLE_OPERATOR);\n  }\n\n  /**\n   * @dev remove a operator role from an address\n   * @param _operator address\n   */\n  function removeOperater(address _operator) public onlyOwnerOrPartner {\n    removeRole(_operator, ROLE_OPERATOR);\n  }\n}\n\n\n\n\n\n\n\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns(uint256);\n\n  function transferFrom(address from, address to, uint256 value) public returns(bool);\n\n  function approve(address spender, uint256 value) public returns(bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract UsdtERC20 is UsdtERC20Basic {\n    function allowance(address owner, address spender) public constant returns (uint);\n    function transferFrom(address from, address to, uint value) public;\n    function approve(address spender, uint value) public;\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\n\n\n\n\n\n\n\n/**\n * @title pledge pool base\n * @dev a base tokenPool, any tokenPool for a specific token should inherit from this tokenPool.\n */\ncontract PledgePoolBase is RBACOperator {\n  using SafeMath for uint256;\n  using AddressUtils for address;\n\n  // Record pledge details.\n  mapping(uint256 => Escrow) internal escrows;\n\n  /**\n   * @dev Information structure of pledge.\n   */\n  struct Escrow {\n    uint256 pledgeSum;\n    address payerAddress;\n    string tokenName;\n  }\n\n  // -----------------------------------------\n  // TokenPool external interface\n  // -----------------------------------------\n\n  /**\n   * @dev addRecord, interface to add record.\n   * @param _payerAddress Address performing the pleadge.\n   * @param _pledgeSum the value to pleadge.\n   * @param _pledgeId pledge contract index number.\n   * @param _tokenName pledge token name.\n   */\n  function addRecord(address _payerAddress, uint256 _pledgeSum, uint256 _pledgeId, string _tokenName) public hasOperationPermission returns(bool) {\n    _preValidateAddRecord(_payerAddress, _pledgeSum, _pledgeId, _tokenName);\n    _processAddRecord(_payerAddress, _pledgeSum, _pledgeId, _tokenName);\n    return true;\n  }\n\n\n   /**\n    * @dev withdrawToken, withdraw pledge token.\n    * @param _pledgeId pledge contract index number.\n    * @param _maker borrower address.\n    * @param _num withdraw token sum.\n    */\n  function withdrawToken(uint256 _pledgeId, address _maker, uint256 _num) public hasOperationPermission returns(bool) {\n    _preValidateWithdraw(_maker, _num, _pledgeId);\n    _processWithdraw(_maker, _num, _pledgeId);\n    return true;\n  }\n\n\n  /**\n   * @dev refundTokens, interface to refund\n   * @param _pledgeId pledge contract index number.\n   * @param _targetAddress transfer target address.\n   * @param _returnSum return token sum.\n   */\n  function refundTokens(uint256 _pledgeId, uint256 _returnSum, address _targetAddress) public hasOperationPermission returns(bool) {\n    _preValidateRefund(_returnSum, _targetAddress, _pledgeId);\n    _processRefund(_returnSum, _targetAddress, _pledgeId);\n    return true;\n  }\n\n  /**\n   * @dev getLedger, Query the pledge details of the pledge number in the pool.\n   * @param _pledgeId pledge contract index number.\n   */\n  function getLedger(uint256 _pledgeId) public view returns(uint256 num, address payerAddress, string tokenName) {\n    require(_pledgeId > 0);\n    num = escrows[_pledgeId].pledgeSum;\n    payerAddress = escrows[_pledgeId].payerAddress;\n    tokenName = escrows[_pledgeId].tokenName;\n  }\n\n\n\n  // -----------------------------------------\n  // TokenPool internal interface (extensible)\n  // -----------------------------------------\n\n\n\n  /**\n   * @dev _preValidateAddRecord, Validation of an incoming AddRecord. Use require statemens to revert state when conditions are not met.\n   * @param _payerAddress Address performing the pleadge.\n   * @param _pledgeSum the value to pleadge.\n   * @param _pledgeId pledge contract index number.\n   * @param _tokenName pledge token name.\n   */\n  function _preValidateAddRecord(address _payerAddress, uint256 _pledgeSum, uint256 _pledgeId, string _tokenName) view internal {\n    require(_pledgeSum > 0 && _pledgeId > 0\n      && _payerAddress != address(0)\n      && bytes(_tokenName).length > 0\n      && address(msg.sender).isContract()\n      && PledgeContract(msg.sender).getPledgeId()==_pledgeId\n    );\n  }\n\n  /**\n   * @dev _processAddRecord, Executed when a AddRecord has been validated and is ready to be executed. Not necessarily emits/sends tokens.\n   * @param _payerAddress Address performing the pleadge.\n   * @param _pledgeSum the value to pleadge.\n   * @param _pledgeId pledge contract index number.\n   * @param _tokenName pledge token name.\n   */\n  function _processAddRecord(address _payerAddress, uint256 _pledgeSum, uint256 _pledgeId, string _tokenName) internal {\n    Escrow memory escrow = Escrow(_pledgeSum, _payerAddress, _tokenName);\n    escrows[_pledgeId] = escrow;\n  }\n\n\n\n  /**\n   * @dev _preValidateRefund, Validation of an incoming refund. Use require statemens to revert state when conditions are not met.\n   * @param _pledgeId pledge contract index number.\n   * @param _targetAddress transfer target address.\n   * @param _returnSum return token sum.\n   */\n  function _preValidateRefund(uint256 _returnSum, address _targetAddress, uint256 _pledgeId) view internal {\n    require(_returnSum > 0 && _pledgeId > 0\n      && _targetAddress != address(0)\n      && address(msg.sender).isContract()\n      && _returnSum <= escrows[_pledgeId].pledgeSum\n      && PledgeContract(msg.sender).getPledgeId()==_pledgeId\n    );\n  }\n\n\n  /**\n   * @dev _processRefund, Executed when a Refund has been validated and is ready to be executed. Not necessarily emits/sends tokens.\n   * @param _pledgeId pledge contract index number.\n   * @param _targetAddress transfer target address.\n   * @param _returnSum return token sum.\n   */\n  function _processRefund(uint256 _returnSum, address _targetAddress, uint256 _pledgeId) internal {\n    escrows[_pledgeId].pledgeSum = escrows[_pledgeId].pledgeSum.sub(_returnSum);\n  }\n\n\n\n  /**\n   * @dev _preValidateWithdraw, Withdraw initiated parameter validation.\n   * @param _pledgeId pledge contract index number.\n   * @param _maker borrower address.\n   * @param _num withdraw token sum.\n   */\n  function _preValidateWithdraw(address _maker, uint256 _num, uint256 _pledgeId) view internal {\n    require(_num > 0 && _pledgeId > 0\n       && _maker != address(0)\n       && address(msg.sender).isContract()\n       && _num <= escrows[_pledgeId].pledgeSum\n       && PledgeContract(msg.sender).getPledgeId()==_pledgeId\n    );\n  }\n\n\n  /**\n   * @dev _processWithdraw, Withdraw data update.\n   * @param _pledgeId pledge contract index number.\n   * @param _maker borrower address.\n   * @param _num withdraw token sum.\n   */\n  function _processWithdraw(address _maker, uint256 _num, uint256 _pledgeId) internal {\n    escrows[_pledgeId].pledgeSum = escrows[_pledgeId].pledgeSum.sub(_num);\n  }\n\n}\n\n\n\n\n\n\n\n\n\n\n/**\n * @title OrderManageContract\n * @dev Order process management contract.\n */\ncontract OrderManageContract is PartnerAuthority {\n  using SafeMath for uint256;\n  using SafeCompare for string;\n\n  /**\n   * @dev Status of current business execution contract.\n   */\n  enum StatusChoices {\n    NO_LOAN,\n    REPAYMENT_WAITING,\n    REPAYMENT_ALL,\n    CLOSE_POSITION,\n    OVERDUE_STOP\n  }\n\n  string internal constant TOKEN_ETH = \"ETH\";\n  string internal constant TOKEN_USDT = \"USDT\";\n  address public maker;\n  address public taker;\n  address internal token20;\n\n  uint256 public toTime;\n  // the amount of the borrower’s final loan.\n  uint256 public outLoanSum;\n  uint256 public repaymentSum;\n  uint256 public lastRepaymentSum;\n  string public loanTokenName;\n  // Borrower's record of the pledge.\n  StatusChoices internal status;\n\n  // Record the amount of the borrower's offline transfer.\n  mapping(address => uint256) public ethAmount;\n\n  /**\n   * Event for takerOrder logging.\n   * @param taker address of investor.\n   * @param outLoanSum the amount of the borrower’s final loan.\n   */\n  event TakerOrder(address indexed taker, uint256 outLoanSum);\n\n\n  /**\n   * Event for executeOrder logging.\n   * @param maker address of borrower.\n   * @param lastRepaymentSum current order repayment amount.\n   */\n  event ExecuteOrder(address indexed maker, uint256 lastRepaymentSum);\n\n  /**\n   * Event for forceCloseOrder logging.\n   * @param toTime order repayment due date.\n   * @param transferSum balance under current contract.\n   */\n  event ForceCloseOrder(uint256 indexed toTime, uint256 transferSum);\n\n  /**\n   * Event for WithdrawToken logging.\n   * @param taker address of investor.\n   * @param refundSum number of tokens withdrawn.\n   */\n  event WithdrawToken(address indexed taker, uint256 refundSum);\n\n\n\n  function() external payable {\n    // Record basic information about the borrower's REPAYMENT ETH\n    ethAmount[msg.sender] = ethAmount[msg.sender].add(msg.value);\n  }\n\n\n  /**\n   * @dev Constructor initial contract configuration parameters\n   * @param _loanTokenAddress order type supported by the token.\n   */\n  constructor(string _loanTokenName, address _loanTokenAddress, address _maker) public {\n    require(bytes(_loanTokenName).length > 0 && _maker != address(0));\n    if (!_loanTokenName.stringCompare(TOKEN_ETH)) {\n      require(_loanTokenAddress != address(0));\n      token20 = _loanTokenAddress;\n    }\n    toTime = now;\n    maker = _maker;\n    loanTokenName = _loanTokenName;\n    status = StatusChoices.NO_LOAN;\n  }\n\n  /**\n   * @dev Complete an order combination and issue the loan to the borrower.\n   * @param _taker address of investor.\n   * @param _toTime order repayment due date.\n   * @param _repaymentSum total amount of money that the borrower ultimately needs to return.\n   */\n  function takerOrder(address _taker, uint32 _toTime, uint256 _repaymentSum) public onlyOwnerOrPartner {\n    require(_taker != address(0) && _toTime > 0 && now <= _toTime && _repaymentSum > 0 && status == StatusChoices.NO_LOAN);\n    taker = _taker;\n    toTime = _toTime;\n    repaymentSum = _repaymentSum;\n\n    // Transfer the token provided by the investor to the borrower's address\n    if (loanTokenName.stringCompare(TOKEN_ETH)) {\n      require(ethAmount[_taker] > 0 && address(this).balance > 0);\n      outLoanSum = address(this).balance;\n      maker.transfer(outLoanSum);\n    } else {\n      require(token20 != address(0) && ERC20(token20).balanceOf(address(this)) > 0);\n      outLoanSum = ERC20(token20).balanceOf(address(this));\n      require(safeErc20Transfer(maker, outLoanSum));\n    }\n\n    // Update contract business execution status.\n    status = StatusChoices.REPAYMENT_WAITING;\n\n    emit TakerOrder(taker, outLoanSum);\n  }\n\n\n\n\n\n\n  /**\n   * @dev Only the full repayment will execute the contract agreement.\n   */\n  function executeOrder() public onlyOwnerOrPartner {\n    require(now <= toTime && status == StatusChoices.REPAYMENT_WAITING);\n    // The borrower pays off the loan and performs two-way operation.\n    if (loanTokenName.stringCompare(TOKEN_ETH)) {\n      require(ethAmount[maker] >= repaymentSum && address(this).balance >= repaymentSum);\n      lastRepaymentSum = address(this).balance;\n      taker.transfer(repaymentSum);\n    } else {\n      require(ERC20(token20).balanceOf(address(this)) >= repaymentSum);\n      lastRepaymentSum = ERC20(token20).balanceOf(address(this));\n      require(safeErc20Transfer(taker, repaymentSum));\n    }\n\n    PledgeContract(owner)._conclude();\n    status = StatusChoices.REPAYMENT_ALL;\n    emit ExecuteOrder(maker, lastRepaymentSum);\n  }\n\n\n\n  /**\n   * @dev Close position or due repayment operation.\n   */\n  function forceCloseOrder() public onlyOwnerOrPartner {\n    require(status == StatusChoices.REPAYMENT_WAITING);\n    uint256 transferSum = 0;\n\n    if (now <= toTime) {\n      status = StatusChoices.CLOSE_POSITION;\n    } else {\n      status = StatusChoices.OVERDUE_STOP;\n    }\n\n    if(loanTokenName.stringCompare(TOKEN_ETH)){\n        if(ethAmount[maker] > 0 && address(this).balance > 0){\n            transferSum = address(this).balance;\n            maker.transfer(transferSum);\n        }\n    }else{\n        if(ERC20(token20).balanceOf(address(this)) > 0){\n            transferSum = ERC20(token20).balanceOf(address(this));\n            require(safeErc20Transfer(maker, transferSum));\n        }\n    }\n\n    // Return pledge token.\n    PledgeContract(owner)._forceConclude(taker);\n    emit ForceCloseOrder(toTime, transferSum);\n  }\n\n\n\n  /**\n   * @dev Withdrawal of the token invested by the taker.\n   * @param _taker address of investor.\n   * @param _refundSum refundSum number of tokens withdrawn.\n   */\n  function withdrawToken(address _taker, uint256 _refundSum) public onlyOwnerOrPartner {\n    require(status == StatusChoices.NO_LOAN);\n    require(_taker != address(0) && _refundSum > 0);\n    if (loanTokenName.stringCompare(TOKEN_ETH)) {\n      require(address(this).balance >= _refundSum && ethAmount[_taker] >= _refundSum);\n      _taker.transfer(_refundSum);\n      ethAmount[_taker] = ethAmount[_taker].sub(_refundSum);\n    } else {\n      require(ERC20(token20).balanceOf(address(this)) >= _refundSum);\n      require(safeErc20Transfer(_taker, _refundSum));\n    }\n    emit WithdrawToken(_taker, _refundSum);\n  }\n\n\n  /**\n   * @dev Since the implementation of usdt ERC20.sol transfer code does not design the return value,\n   * @dev which is different from most ERC20 token interfaces,most erc20 transfer token agreements return bool.\n   * @dev it is necessary to independently adapt the interface for usdt token in order to transfer successfully\n   * @dev if not, the transfer may fail.\n   */\n  function safeErc20Transfer(address _toAddress,uint256 _transferSum) internal returns (bool) {\n    if(loanTokenName.stringCompare(TOKEN_USDT)){\n      UsdtERC20(token20).transfer(_toAddress, _transferSum);\n    }else{\n      require(ERC20(token20).transfer(_toAddress, _transferSum));\n    }\n    return true;\n  }\n\n\n\n  /**\n   * @dev Get current contract order status.\n   */\n  function getPledgeStatus() public view returns(string pledgeStatus) {\n    if (status == StatusChoices.NO_LOAN) {\n      pledgeStatus = \"NO_LOAN\";\n    } else if (status == StatusChoices.REPAYMENT_WAITING) {\n      pledgeStatus = \"REPAYMENT_WAITING\";\n    } else if (status == StatusChoices.REPAYMENT_ALL) {\n      pledgeStatus = \"REPAYMENT_ALL\";\n    } else if (status == StatusChoices.CLOSE_POSITION) {\n      pledgeStatus = \"CLOSE_POSITION\";\n    } else {\n      pledgeStatus = \"OVERDUE_STOP\";\n    }\n  }\n\n}\n\n\n\n\n\n\n/**\n * @title EscrowMaintainContract\n * @dev Provides configuration and external interfaces.\n */\ncontract EscrowMaintainContract is PartnerAuthority {\n  address public pledgeFactory;\n\n  // map of token name to token pool address;\n  mapping(string => address) internal nameByPool;\n  // map of token name to erc20 token address;\n  mapping(string => address) internal nameByToken;\n\n\n\n  // -----------------------------------------\n  // External interface\n  // -----------------------------------------\n\n  /**\n   * @dev Create a pledge subcontract\n   * @param _pledgeId index number of the pledge contract.\n   */\n  function createPledgeContract(uint256 _pledgeId) public onlyPartner returns(bool) {\n    require(_pledgeId > 0 && pledgeFactory!=address(0));\n    require(PledgeFactory(pledgeFactory).createPledgeContract(_pledgeId,partner));\n    return true;\n  }\n\n\n  /**\n   * @dev Batch create a pledge subcontract\n   * @param _pledgeIds index number of the pledge contract.\n   */\n  function batchCreatePledgeContract(uint256[] _pledgeIds) public onlyPartner {\n    require(_pledgeIds.length > 0);\n    PledgeFactory(pledgeFactory).batchCreatePledgeContract(_pledgeIds,partner);\n  }\n\n\n  /**\n   * @dev Use the index to get the basic information of the corresponding pledge contract.\n   * @param _pledgeId index number of the pledge contract\n   */\n  function getEscrowPledge(uint256 _pledgeId) public view returns(string tokenName, address pledgeContract) {\n    require(_pledgeId > 0);\n    (tokenName,pledgeContract) = PledgeFactory(pledgeFactory).getEscrowPledge(_pledgeId);\n  }\n\n\n  /**\n   * @dev setTokenPool, set the token pool contract address of a token name.\n   * @param _tokenName set token pool name.\n   * @param _address the token pool contract address.\n   */\n  function setTokenPool(string _tokenName, address _address) public onlyOwner {\n    require(_address != address(0) && bytes(_tokenName).length > 0);\n    nameByPool[_tokenName] = _address;\n  }\n\n   /**\n   * @dev setToken, set the token contract address of a token name.\n   * @param _tokenName token name\n   * @param _address the ERC20 token contract address.\n   */\n  function setToken(string _tokenName, address _address) public onlyOwner {\n    require(_address != address(0) && bytes(_tokenName).length > 0);\n    nameByToken[_tokenName] = _address;\n  }\n\n\n  /**\n  * @dev setPledgeFactory, Plant contract for configuration management pledge business.\n  * @param _factory pledge factory contract.\n  */\n  function setPledgeFactory(address _factory) public onlyOwner {\n    require(_factory != address(0));\n    pledgeFactory = _factory;\n  }\n\n  /**\n   * @dev Checks whether the current token pool is supported.\n   * @param _tokenName token name\n   */\n  function includeTokenPool(string _tokenName) view public returns(address) {\n    require(bytes(_tokenName).length > 0);\n    return nameByPool[_tokenName];\n  }\n\n\n  /**\n   * @dev Checks whether the current erc20 token is supported.\n   * @param _tokenName token name\n   */\n  function includeToken(string _tokenName) view public returns(address) {\n    require(bytes(_tokenName).length > 0);\n    return nameByToken[_tokenName];\n  }\n\n}\n\n\n/**\n * @title PledgeContract\n * @dev Pledge process management contract\n */\ncontract PledgeContract is PartnerAuthority {\n\n  using SafeMath for uint256;\n  using SafeCompare for string;\n\n  /**\n   * @dev Type of execution state of the pledge contract（irreversible）\n   */\n  enum StatusChoices {\n    NO_PLEDGE_INFO,\n    PLEDGE_CREATE_MATCHING,\n    PLEDGE_REFUND\n  }\n\n  string public pledgeTokenName;\n  uint256 public pledgeId;\n  address internal maker;\n  address internal token20;\n  address internal factory;\n  address internal escrowContract;\n  uint256 internal pledgeAccountSum;\n  // order contract address\n  address internal orderContract;\n  string internal loanTokenName;\n  StatusChoices internal status;\n  address internal tokenPoolAddress;\n  string internal constant TOKEN_ETH = \"ETH\";\n  string internal constant TOKEN_USDT = \"USDT\";\n  // ETH pledge account\n  mapping(address => uint256) internal verifyEthAccount;\n\n\n  /**\n   * Event for createOrderContract logging.\n   * @param newOrderContract management contract address.\n   */\n  event CreateOrderContract(address newOrderContract);\n\n\n  /**\n   * Event for WithdrawToken logging.\n   * @param maker address of investor.\n   * @param pledgeTokenName token name.\n   * @param refundSum number of tokens withdrawn.\n   */\n  event WithdrawToken(address indexed maker, string pledgeTokenName, uint256 refundSum);\n\n\n  /**\n   * Event for appendEscrow logging.\n   * @param maker address of borrower.\n   * @param appendSum append amount.\n   */\n  event AppendEscrow(address indexed maker, uint256 appendSum);\n\n\n  /**\n   * @dev Constructor initial contract configuration parameters\n   */\n  constructor(uint256 _pledgeId, address _factory , address _escrowContract) public {\n    require(_pledgeId > 0 && _factory != address(0) && _escrowContract != address(0));\n    pledgeId = _pledgeId;\n    factory = _factory;\n    status = StatusChoices.NO_PLEDGE_INFO;\n    escrowContract = _escrowContract;\n  }\n\n\n\n  // -----------------------------------------\n  // external interface\n  // -----------------------------------------\n\n\n\n  function() external payable {\n    require(status != StatusChoices.PLEDGE_REFUND);\n    // Identify the borrower.\n    if (maker != address(0)) {\n      require(address(msg.sender) == maker);\n    }\n    // Record basic information about the borrower's pledge ETH\n    verifyEthAccount[msg.sender] = verifyEthAccount[msg.sender].add(msg.value);\n  }\n\n\n  /**\n   * @dev Add the pledge information and transfer the pledged token into the corresponding currency pool.\n   * @param _pledgeTokenName maker pledge token name.\n   * @param _maker borrower address.\n   * @param _pledgeSum pledge amount.\n   * @param _loanTokenName pledge token type.\n   */\n  function addRecord(string _pledgeTokenName, address _maker, uint256 _pledgeSum, string _loanTokenName) public onlyOwner {\n    require(_maker != address(0) && _pledgeSum > 0 && status != StatusChoices.PLEDGE_REFUND);\n    // Add the pledge information for the first time.\n    if (status == StatusChoices.NO_PLEDGE_INFO) {\n      // public data init.\n      maker = _maker;\n      pledgeTokenName = _pledgeTokenName;\n      tokenPoolAddress = checkedTokenPool(pledgeTokenName);\n      PledgeFactory(factory).updatePledgeType(pledgeId, pledgeTokenName);\n      // Assign rights to the operation of the contract pool\n      PledgeFactory(factory).tokenPoolOperater(tokenPoolAddress, address(this));\n      // Create order management contracts.\n      createOrderContract(_loanTokenName);\n    }\n    // Record information of each pledge.\n    pledgeAccountSum = pledgeAccountSum.add(_pledgeSum);\n    PledgePoolBase(tokenPoolAddress).addRecord(maker, pledgeAccountSum, pledgeId, pledgeTokenName);\n    // Transfer the pledge token to the appropriate token pool.\n    if (pledgeTokenName.stringCompare(TOKEN_ETH)) {\n      require(verifyEthAccount[maker] >= _pledgeSum);\n      tokenPoolAddress.transfer(_pledgeSum);\n    } else {\n      token20 = checkedToken(pledgeTokenName);\n      require(ERC20(token20).balanceOf(address(this)) >= _pledgeSum);\n      require(safeErc20Transfer(token20,tokenPoolAddress, _pledgeSum));\n    }\n  }\n\n  /**\n   * @dev Increase the number of pledged tokens.\n   * @param _appendSum append amount.\n   */\n  function appendEscrow(uint256 _appendSum) public onlyOwner {\n    require(status == StatusChoices.PLEDGE_CREATE_MATCHING);\n    addRecord(pledgeTokenName, maker, _appendSum, loanTokenName);\n    emit AppendEscrow(maker, _appendSum);\n  }\n\n\n  /**\n   * @dev Withdraw pledge behavior.\n   * @param _maker borrower address.\n   */\n  function withdrawToken(address _maker) public onlyOwner {\n    require(status != StatusChoices.PLEDGE_REFUND);\n    uint256 pledgeSum = 0;\n    // there are two types of retractions.\n    if (status == StatusChoices.NO_PLEDGE_INFO) {\n      pledgeSum = classifySquareUp(_maker);\n    } else {\n      status = StatusChoices.PLEDGE_REFUND;\n      require(PledgePoolBase(tokenPoolAddress).withdrawToken(pledgeId, maker, pledgeAccountSum));\n      pledgeSum = pledgeAccountSum;\n    }\n    emit WithdrawToken(_maker, pledgeTokenName, pledgeSum);\n  }\n\n\n  /**\n   * @dev Executed in some extreme unforsee cases, to avoid eth locked.\n   * @param _tokenName recycle token type.\n   * @param _amount Number of eth to recycle.\n   */\n  function recycle(string _tokenName, uint256 _amount) public onlyOwner {\n    require(status != StatusChoices.NO_PLEDGE_INFO && _amount>0);\n    if (_tokenName.stringCompare(TOKEN_ETH)) {\n      require(address(this).balance >= _amount);\n      owner.transfer(_amount);\n    } else {\n      address token = checkedToken(_tokenName);\n      require(ERC20(token).balanceOf(address(this)) >= _amount);\n      require(safeErc20Transfer(token,owner, _amount));\n    }\n  }\n\n\n\n  /**\n   * @dev Since the implementation of usdt ERC20.sol transfer code does not design the return value,\n   * @dev which is different from most ERC20 token interfaces,most erc20 transfer token agreements return bool.\n   * @dev it is necessary to independently adapt the interface for usdt token in order to transfer successfully\n   * @dev if not, the transfer may fail.\n   */\n  function safeErc20Transfer(address _token20,address _toAddress,uint256 _transferSum) internal returns (bool) {\n    if(loanTokenName.stringCompare(TOKEN_USDT)){\n      UsdtERC20(_token20).transfer(_toAddress, _transferSum);\n    }else{\n      require(ERC20(_token20).transfer(_toAddress, _transferSum));\n    }\n    return true;\n  }\n\n\n\n  // -----------------------------------------\n  // internal interface\n  // -----------------------------------------\n\n\n\n  /**\n   * @dev Create an order process management contract for the match and repayment business.\n   * @param _loanTokenName expect loan token type.\n   */\n  function createOrderContract(string _loanTokenName) internal {\n    require(bytes(_loanTokenName).length > 0);\n    status = StatusChoices.PLEDGE_CREATE_MATCHING;\n    address loanToken20 = checkedToken(_loanTokenName);\n    OrderManageContract newOrder = new OrderManageContract(_loanTokenName, loanToken20, maker);\n    setPartner(address(newOrder));\n    newOrder.setPartner(owner);\n    // update contract public data.\n    orderContract = newOrder;\n    loanTokenName = _loanTokenName;\n    emit CreateOrderContract(address(newOrder));\n  }\n\n  /**\n   * @dev classification withdraw.\n   * @dev Execute without changing the current contract data state.\n   * @param _maker borrower address.\n   */\n  function classifySquareUp(address _maker) internal returns(uint256 sum) {\n    if (pledgeTokenName.stringCompare(TOKEN_ETH)) {\n      uint256 pledgeSum = verifyEthAccount[_maker];\n      require(pledgeSum > 0 && address(this).balance >= pledgeSum);\n      _maker.transfer(pledgeSum);\n      verifyEthAccount[_maker] = 0;\n      sum = pledgeSum;\n    } else {\n      uint256 balance = ERC20(token20).balanceOf(address(this));\n      require(balance > 0);\n      require(safeErc20Transfer(token20,_maker, balance));\n      sum = balance;\n    }\n  }\n\n  /**\n   * @dev Check wether the token is included for a token name.\n   * @param _tokenName token name.\n   */\n  function checkedToken(string _tokenName) internal view returns(address) {\n    address tokenAddress = EscrowMaintainContract(escrowContract).includeToken(_tokenName);\n    require(tokenAddress != address(0));\n    return tokenAddress;\n  }\n\n  /**\n   * @dev Check wether the token pool is included for a token name.\n   * @param _tokenName pledge token name.\n   */\n  function checkedTokenPool(string _tokenName) internal view returns(address) {\n    address tokenPool = EscrowMaintainContract(escrowContract).includeTokenPool(_tokenName);\n    require(tokenPool != address(0));\n    return tokenPool;\n  }\n\n\n\n  // -----------------------------------------\n  // business relationship interface\n  // (Only the order contract has authority to operate)\n  // -----------------------------------------\n\n\n\n  /**\n   * @dev Refund of the borrower’s pledge.\n   */\n  function _conclude() public onlyPartner {\n    require(status == StatusChoices.PLEDGE_CREATE_MATCHING);\n    status = StatusChoices.PLEDGE_REFUND;\n    require(PledgePoolBase(tokenPoolAddress).refundTokens(pledgeId, pledgeAccountSum, maker));\n  }\n\n  /**\n   * @dev Expired for repayment or close position.\n   * @param _taker address of investor.\n   */\n  function _forceConclude(address _taker) public onlyPartner {\n    require(_taker != address(0) && status == StatusChoices.PLEDGE_CREATE_MATCHING);\n    status = StatusChoices.PLEDGE_REFUND;\n    require(PledgePoolBase(tokenPoolAddress).refundTokens(pledgeId, pledgeAccountSum, _taker));\n  }\n\n\n\n  // -----------------------------------------\n  // query interface (use no gas)\n  // -----------------------------------------\n\n\n\n  /**\n   * @dev Get current contract order status.\n   * @return pledgeStatus state indicate.\n   */\n  function getPledgeStatus() public view returns(string pledgeStatus) {\n    if (status == StatusChoices.NO_PLEDGE_INFO) {\n      pledgeStatus = \"NO_PLEDGE_INFO\";\n    } else if (status == StatusChoices.PLEDGE_CREATE_MATCHING) {\n      pledgeStatus = \"PLEDGE_CREATE_MATCHING\";\n    } else {\n      pledgeStatus = \"PLEDGE_REFUND\";\n    }\n  }\n\n  /**\n   * @dev get order contract address. use no gas.\n   */\n  function getOrderContract() public view returns(address) {\n    return orderContract;\n  }\n\n  /**\n   * @dev Gets the total number of tokens pledged under the current contract.\n   */\n  function getPledgeAccountSum() public view returns(uint256) {\n    return pledgeAccountSum;\n  }\n\n  /**\n   * @dev get current contract borrower address.\n   */\n  function getMakerAddress() public view returns(address) {\n    return maker;\n  }\n\n  /**\n   * @dev get current contract pledge Id.\n   */\n  function getPledgeId() external view returns(uint256) {\n    return pledgeId;\n  }\n\n}\n\n\n\n\n/**\n * @title PledgeFactory\n * @dev Pledge factory contract.\n * @dev Specially provides the pledge guarantee creation and the statistics function.\n */\ncontract PledgeFactory is RBACOperator {\n  using AddressUtils for address;\n\n  // initial type of pledge contract.\n  string internal constant INIT_TOKEN_NAME = \"UNKNOWN\";\n\n  mapping(uint256 => EscrowPledge) internal pledgeEscrowById;\n  // pledge number unique screening.\n  mapping(uint256 => bool) internal isPledgeId;\n\n  /**\n   * @dev Pledge guarantee statistics.\n   */\n  struct EscrowPledge {\n    address pledgeContract;\n    string tokenName;\n  }\n\n  /**\n   * Event for createOrderContract logging.\n   * @param pledgeId management contract id.\n   * @param newPledgeAddress pledge management contract address.\n   */\n  event CreatePledgeContract(uint256 indexed pledgeId, address newPledgeAddress);\n\n\n  /**\n   * @dev Create a pledge subcontract\n   * @param _pledgeId index number of the pledge contract.\n   */\n  function createPledgeContract(uint256 _pledgeId, address _escrowPartner) public onlyPartner returns(bool) {\n    require(_pledgeId > 0 && !isPledgeId[_pledgeId] && _escrowPartner!=address(0));\n\n    // Give the pledge contract the right to update statistics.\n    PledgeContract pledgeAddress = new PledgeContract(_pledgeId, address(this),partner);\n    pledgeAddress.transferOwnership(_escrowPartner);\n    addOperater(address(pledgeAddress));\n\n    // update pledge contract info\n    isPledgeId[_pledgeId] = true;\n    pledgeEscrowById[_pledgeId] = EscrowPledge(pledgeAddress, INIT_TOKEN_NAME);\n\n    emit CreatePledgeContract(_pledgeId, address(pledgeAddress));\n    return true;\n  }\n\n\n\n  /**\n   * @dev Batch create a pledge subcontract\n   * @param _pledgeIds index number of the pledge contract.\n   */\n  function batchCreatePledgeContract(uint256[] _pledgeIds, address _escrowPartner) public onlyPartner {\n    require(_pledgeIds.length > 0 && _escrowPartner.isContract());\n    for (uint i = 0; i < _pledgeIds.length; i++) {\n      require(createPledgeContract(_pledgeIds[i],_escrowPartner));\n    }\n  }\n\n  /**\n   * @dev Use the index to get the basic information of the corresponding pledge contract.\n   * @param _pledgeId index number of the pledge contract\n   */\n  function getEscrowPledge(uint256 _pledgeId) public view returns(string tokenName, address pledgeContract) {\n    require(_pledgeId > 0);\n    tokenName = pledgeEscrowById[_pledgeId].tokenName;\n    pledgeContract = pledgeEscrowById[_pledgeId].pledgeContract;\n  }\n\n\n\n\n  // -----------------------------------------\n  // Internal interface (Only the pledge contract has authority to operate)\n  // -----------------------------------------\n\n\n  /**\n   * @dev Configure permissions to operate on the token pool.\n   * @param _tokenPool token pool contract address.\n   * @param _pledge pledge contract address.\n   */\n  function tokenPoolOperater(address _tokenPool, address _pledge) public hasOperationPermission {\n    require(_pledge != address(0) && address(msg.sender).isContract() && address(msg.sender) == _pledge);\n    PledgePoolBase(_tokenPool).addOperater(_pledge);\n  }\n\n\n  /**\n   * @dev Update the basic data of the pledge contract.\n   * @param _pledgeId index number of the pledge contract.\n   * @param _tokenName pledge contract supported token type.\n   */\n  function updatePledgeType(uint256 _pledgeId, string _tokenName) public hasOperationPermission {\n    require(_pledgeId > 0 && bytes(_tokenName).length > 0 && address(msg.sender).isContract());\n    pledgeEscrowById[_pledgeId].tokenName = _tokenName;\n  }\n}",
  "bytecode": "608060405260008054600160a060020a03191633179055610bed806100256000396000f3006080604052600436106100da5763ffffffff7c010000000000000000000000000000000000000000000000000000000060003504166302e79aa181146100df57806308ea5c32146101455780632187ea771461019a5780632d24c7ae146101cb5780635921c5eb1461022f578063610703e714610244578063715018a6146102705780637ffa0dbf146102855780638da5cb5b1461032e578063916c1d9414610343578063a16d596014610364578063be10862b14610385578063e4de08c01461039a578063f2fde38b146103f3578063fb91c21214610414575b600080fd5b3480156100eb57600080fd5b506040805160206004803580820135601f810184900484028501840190955284845261014394369492936024939284019190819084018382808284375094975050509235600160a060020a0316935061046d92505050565b005b34801561015157600080fd5b5060408051602060048035808201358381028086018501909652808552610143953695939460249493850192918291850190849080828437509497506105389650505050505050565b3480156101a657600080fd5b506101af610629565b60408051600160a060020a039092168252519081900360200190f35b3480156101d757600080fd5b506040805160206004803580820135601f810184900484028501840190955284845261014394369492936024939284019190819084018382808284375094975050509235600160a060020a0316935061063892505050565b34801561023b57600080fd5b506101436106a5565b34801561025057600080fd5b5061025c6004356106db565b604080519115158252519081900360200190f35b34801561027c57600080fd5b506101436107cb565b34801561029157600080fd5b5061029d600435610837565b604051808060200183600160a060020a0316600160a060020a03168152602001828103825284818151815260200191508051906020019080838360005b838110156102f25781810151838201526020016102da565b50505050905090810190601f16801561031f5780820380516001836020036101000a031916815260200191505b50935050505060405180910390f35b34801561033a57600080fd5b506101af610943565b34801561034f57600080fd5b50610143600160a060020a0360043516610952565b34801561037057600080fd5b50610143600160a060020a03600435166109ad565b34801561039157600080fd5b506101af610a50565b3480156103a657600080fd5b506040805160206004803580820135601f81018490048402850184019095528484526101af943694929360249392840191908190840183828082843750949750610a5f9650505050505050565b3480156103ff57600080fd5b50610143600160a060020a0360043516610adf565b34801561042057600080fd5b506040805160206004803580820135601f81018490048402850184019095528484526101af943694929360249392840191908190840183828082843750949750610b029650505050505050565b600054600160a060020a0316331461048457600080fd5b600160a060020a0381161580159061049d575060008251115b15156104a857600080fd5b806003836040518082805190602001908083835b602083106104db5780518252601f1990920191602091820191016104bc565b51815160209384036101000a60001901801990921691161790529201948552506040519384900301909220805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a03949094169390931790925550505050565b600154600160a060020a0316331461054f57600080fd5b805160001061055d57600080fd5b600254600154604080517fbb412c9d000000000000000000000000000000000000000000000000000000008152600160a060020a039283166024820181905260048201928352855160448301528551939094169363bb412c9d938693919282916064909101906020808701910280838360005b838110156105e85781810151838201526020016105d0565b505050509050019350505050600060405180830381600087803b15801561060e57600080fd5b505af1158015610622573d6000803e3d6000fd5b5050505050565b600254600160a060020a031681565b600054600160a060020a0316331461064f57600080fd5b600160a060020a03811615801590610668575060008251115b151561067357600080fd5b80600483604051808280519060200190808383602083106104db5780518252601f1990920191602091820191016104bc565b600054600160a060020a031633146106bc57600080fd5b6001805473ffffffffffffffffffffffffffffffffffffffff19169055565b600154600090600160a060020a031633146106f557600080fd5b60008211801561070f5750600254600160a060020a031615155b151561071a57600080fd5b600254600154604080517f9b71a2de00000000000000000000000000000000000000000000000000000000815260048101869052600160a060020a03928316602482015290519190921691639b71a2de9160448083019260209291908290030181600087803b15801561078c57600080fd5b505af11580156107a0573d6000803e3d6000fd5b505050506040513d60208110156107b657600080fd5b505115156107c357600080fd5b506001919050565b600054600160a060020a031633146107e257600080fd5b60008054604051600160a060020a03909116917ff8df31144d9c2f0f6b59d69b8b98abd5459d07f2742c4df920b25aae33c6482091a26000805473ffffffffffffffffffffffffffffffffffffffff19169055565b6060600080831161084757600080fd5b600254604080517f7ffa0dbf000000000000000000000000000000000000000000000000000000008152600481018690529051600160a060020a0390921691637ffa0dbf9160248082019260009290919082900301818387803b1580156108ad57600080fd5b505af11580156108c1573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160409081528110156108ea57600080fd5b81019080805164010000000081111561090257600080fd5b8201602081018481111561091557600080fd5b815164010000000081118282018710171561092f57600080fd5b505060209091015190969095509350505050565b600054600160a060020a031681565b600054600160a060020a0316331461096957600080fd5b600160a060020a038116151561097e57600080fd5b6002805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b600054600160a060020a031633146109c457600080fd5b600160a060020a03811615156109d957600080fd5b60015460408051600160a060020a039283168152918316602083015280517f4b74c6905f914d7a5f408442bc16a267312648abfc3909c994cc6c2643ae5c969281900390910190a16001805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b600154600160a060020a031681565b6000808251111515610a7057600080fd5b6003826040518082805190602001908083835b60208310610aa25780518252601f199092019160209182019101610a83565b51815160209384036101000a6000190180199092169116179052920194855250604051938490030190922054600160a060020a0316949350505050565b600054600160a060020a03163314610af657600080fd5b610aff81610b44565b50565b6000808251111515610b1357600080fd5b60048260405180828051906020019080838360208310610aa25780518252601f199092019160209182019101610a83565b600160a060020a0381161515610b5957600080fd5b60008054604051600160a060020a03808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a36000805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a03929092169190911790555600a165627a7a723058202342e0900acd376fb52305619c0a4301d0a5478a6b75b54debdfb5fb9721647b0029"
}