{
  "address": "0x3d277e106fc867cf845000f11aff9f9785e20c1e",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "WarriorSanctuary",
  "compilerVersion": "v0.4.19+commit.c4cbbb05",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2018-04-20\n*/\n\npragma solidity ^0.4.19;\n\ncontract ERC721 {\n    // Required methods\n    function totalSupply() public view returns (uint256 total);\n    function balanceOf(address _owner) public view returns (uint256 balance);\n    function ownerOf(uint256 _tokenId) external view returns (address owner);\n    function approve(address _to, uint256 _tokenId) external;\n    function transfer(address _to, uint256 _tokenId) external;\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\n\n    // Events\n    event Transfer(address from, address to, uint256 tokenId);\n    event Approval(address owner, address approved, uint256 tokenId);\n\n    // Optional\n    // function name() public view returns (string name);\n    // function symbol() public view returns (string symbol);\n    // function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds);\n    // function tokenMetadata(uint256 _tokenId, string _preferredTransport) public view returns (string infoUrl);\n    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool);\n    function getBeneficiary() external view returns(address);\n}\n\ncontract SanctuaryInterface {\n    /// @dev simply a boolean to indicate this is the contract we expect to be\n    function isSanctuary() public pure returns (bool);\n\n    /// @dev generate new warrior genes\n    /// @param _heroGenes Genes of warrior that have completed dungeon\n    /// @param _heroLevel Level of the warrior\n    /// @return the genes that are supposed to be passed down to newly arisen warrior\n    function generateWarrior(uint256 _heroGenes, uint256 _heroLevel, uint256 _targetBlock, uint256 _perkId) public returns (uint256);\n}\n\ncontract PVPInterface {\n    /// @dev simply a boolean to indicate this is the contract we expect to be\n    function isPVPProvider() external pure returns (bool);\n    \n    function addTournamentContender(address _owner, uint256[] _tournamentData) external payable;\n    function getTournamentThresholdFee() public view returns(uint256);\n    \n    function addPVPContender(address _owner, uint256 _packedWarrior) external payable;\n    function getPVPEntranceFee(uint256 _levelPoints) external view returns(uint256);\n}\n\ncontract PVPListenerInterface {\n    /// @dev simply a boolean to indicate this is the contract we expect to be\n    function isPVPListener() public pure returns (bool);\n    function getBeneficiary() external view returns(address);\n    \n    function pvpFinished(uint256[] warriorData, uint256 matchingCount) public;\n    function pvpContenderRemoved(uint256 _warriorId) public;\n    function tournamentFinished(uint256[] packedContenders) public;\n}\n\ncontract PermissionControll {\n    // This facet controls access to contract that implements it. There are four roles managed here:\n    //\n    // - The Admin: The Admin can reassign admin and issuer roles and change the addresses of our dependent smart\n    // contracts. It is also the only role that can unpause the smart contract. It is initially\n    // set to the address that created the smart contract in the CryptoWarriorCore constructor.\n    //\n    // - The Bank: The Bank can withdraw funds from CryptoWarriorCore and its auction and battle contracts, and change admin role.\n    //\n    // - The Issuer: The Issuer can release gen0 warriors to auction.\n    //\n    // / @dev Emited when contract is upgraded\n    event ContractUpgrade(address newContract);\n    \n    // Set in case the core contract is broken and an upgrade is required\n    address public newContractAddress;\n\n    // The addresses of the accounts (or contracts) that can execute actions within each roles.\n    address public adminAddress;\n    address public bankAddress;\n    address public issuerAddress; \n    // @dev Keeps track whether the contract is paused. When that is true, most actions are blocked\n    bool public paused = false;\n    \n\n    // / @dev Access modifier for Admin-only functionality\n    modifier onlyAdmin(){\n        require(msg.sender == adminAddress);\n        _;\n    }\n\n    // / @dev Access modifier for Bank-only functionality\n    modifier onlyBank(){\n        require(msg.sender == bankAddress);\n        _;\n    }\n    \n    /// @dev Access modifier for Issuer-only functionality\n    modifier onlyIssuer(){\n    \t\trequire(msg.sender == issuerAddress);\n        _;\n    }\n    \n    modifier onlyAuthorized(){\n        require(msg.sender == issuerAddress ||\n            msg.sender == adminAddress ||\n            msg.sender == bankAddress);\n        _;\n    }\n\n\n    // / @dev Assigns a new address to act as the Bank. Only available to the current Bank.\n    // / @param _newBank The address of the new Bank\n    function setBank(address _newBank) external onlyBank {\n        require(_newBank != address(0));\n        bankAddress = _newBank;\n    }\n\n    // / @dev Assigns a new address to act as the Admin. Only available to the current Admin.\n    // / @param _newAdmin The address of the new Admin\n    function setAdmin(address _newAdmin) external {\n        require(msg.sender == adminAddress || msg.sender == bankAddress);\n        require(_newAdmin != address(0));\n        adminAddress = _newAdmin;\n    }\n    \n    // / @dev Assigns a new address to act as the Issuer. Only available to the current Issuer.\n    // / @param _newIssuer The address of the new Issuer\n    function setIssuer(address _newIssuer) external onlyAdmin{\n        require(_newIssuer != address(0));\n        issuerAddress = _newIssuer;\n    }\n\n    /*** Pausable functionality adapted from OpenZeppelin ***/\n    // / @dev Modifier to allow actions only when the contract IS NOT paused\n    modifier whenNotPaused(){\n        require(!paused);\n        _;\n    }\n\n    // / @dev Modifier to allow actions only when the contract IS paused\n    modifier whenPaused{\n        require(paused);\n        _;\n    }\n\n    // / @dev Called by any \"Authorized\" role to pause the contract. Used only when\n    // /  a bug or exploit is detected and we need to limit damage.\n    function pause() external onlyAuthorized whenNotPaused{\n        paused = true;\n    }\n\n    // / @dev Unpauses the smart contract. Can only be called by the Admin.\n    // / @notice This is public rather than external so it can be called by\n    // /  derived contracts.\n    function unpause() public onlyAdmin whenPaused{\n        // can't unpause if contract was upgraded\n        paused = false;\n    }\n    \n    \n    /// @dev Used to mark the smart contract as upgraded, in case there is a serious\n    ///  breaking bug. This method does nothing but keep track of the new contract and\n    ///  emit a message indicating that the new address is set. It's up to clients of this\n    ///  contract to update to the new contract address in that case. (This contract will\n    ///  be paused indefinitely if such an upgrade takes place.)\n    /// @param _v2Address new address\n    function setNewAddress(address _v2Address) external onlyAdmin whenPaused {\n        newContractAddress = _v2Address;\n        ContractUpgrade(_v2Address);\n    }\n}\n\ncontract Ownable {\n    address public owner;\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    function Ownable() public{\n        owner = msg.sender;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner(){\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner{\n        if (newOwner != address(0)) {\n            owner = newOwner;\n        }\n    }\n}\n\ncontract PausableBattle is Ownable {\n    event PausePVP(bool paused);\n    event PauseTournament(bool paused);\n    \n    bool public pvpPaused = false;\n    bool public tournamentPaused = false;\n    \n    /** PVP */\n    modifier PVPNotPaused(){\n        require(!pvpPaused);\n        _;\n    }\n\n    modifier PVPPaused{\n        require(pvpPaused);\n        _;\n    }\n\n    function pausePVP() public onlyOwner PVPNotPaused {\n        pvpPaused = true;\n        PausePVP(true);\n    }\n\n    function unpausePVP() public onlyOwner PVPPaused {\n        pvpPaused = false;\n        PausePVP(false);\n    }\n    \n    /** Tournament */\n    modifier TournamentNotPaused(){\n        require(!tournamentPaused);\n        _;\n    }\n\n    modifier TournamentPaused{\n        require(tournamentPaused);\n        _;\n    }\n\n    function pauseTournament() public onlyOwner TournamentNotPaused {\n        tournamentPaused = true;\n        PauseTournament(true);\n    }\n\n    function unpauseTournament() public onlyOwner TournamentPaused {\n        tournamentPaused = false;\n        PauseTournament(false);\n    }\n    \n}\n\ncontract Pausable is Ownable {\n    event Pause();\n\n    event Unpause();\n\n    bool public paused = false;\n\n    /**\n     * @dev modifier to allow actions only when the contract IS paused\n     */\n    modifier whenNotPaused(){\n        require(!paused);\n        _;\n    }\n\n    /**\n     * @dev modifier to allow actions only when the contract IS NOT paused\n     */\n    modifier whenPaused{\n        require(paused);\n        _;\n    }\n\n    /**\n     * @dev called by the owner to pause, triggers stopped state\n     */\n    function pause() public onlyOwner whenNotPaused {\n        paused = true;\n        Pause();\n    }\n\n    /**\n     * @dev called by the owner to unpause, returns to normal state\n     */\n    function unpause() public onlyOwner whenPaused {\n        paused = false;\n        Unpause();\n    }\n}\n\nlibrary CryptoUtils {\n   \n    /* CLASSES */\n    uint256 internal constant WARRIOR = 0;\n    uint256 internal constant ARCHER = 1;\n    uint256 internal constant MAGE = 2;\n    /* RARITIES */\n    uint256 internal constant COMMON = 1;\n    uint256 internal constant UNCOMMON = 2;\n    uint256 internal constant RARE = 3;\n    uint256 internal constant MYTHIC = 4;\n    uint256 internal constant LEGENDARY = 5;\n    uint256 internal constant UNIQUE = 6;\n    /* LIMITS */\n    uint256 internal constant CLASS_MECHANICS_MAX = 3;\n    uint256 internal constant RARITY_MAX = 6;\n    /*@dev range used for rarity chance computation */\n    uint256 internal constant RARITY_CHANCE_RANGE = 10000000;\n    uint256 internal constant POINTS_TO_LEVEL = 10;\n    /* ATTRIBUTE MASKS */\n    /*@dev range 0-9999 */\n    uint256 internal constant UNIQUE_MASK_0 = 1;\n    /*@dev range 0-9 */\n    uint256 internal constant RARITY_MASK_1 = UNIQUE_MASK_0 * 10000;\n    /*@dev range 0-999 */\n    uint256 internal constant CLASS_VIEW_MASK_2 = RARITY_MASK_1 * 10;\n    /*@dev range 0-999 */\n    uint256 internal constant BODY_COLOR_MASK_3 = CLASS_VIEW_MASK_2 * 1000;\n    /*@dev range 0-999 */\n    uint256 internal constant EYES_MASK_4 = BODY_COLOR_MASK_3 * 1000;\n    /*@dev range 0-999 */\n    uint256 internal constant MOUTH_MASK_5 = EYES_MASK_4 * 1000;\n    /*@dev range 0-999 */\n    uint256 internal constant HEIR_MASK_6 = MOUTH_MASK_5 * 1000;\n    /*@dev range 0-999 */\n    uint256 internal constant HEIR_COLOR_MASK_7 = HEIR_MASK_6 * 1000;\n    /*@dev range 0-999 */\n    uint256 internal constant ARMOR_MASK_8 = HEIR_COLOR_MASK_7 * 1000;\n    /*@dev range 0-999 */\n    uint256 internal constant WEAPON_MASK_9 = ARMOR_MASK_8 * 1000;\n    /*@dev range 0-999 */\n    uint256 internal constant HAT_MASK_10 = WEAPON_MASK_9 * 1000;\n    /*@dev range 0-99 */\n    uint256 internal constant RUNES_MASK_11 = HAT_MASK_10 * 1000;\n    /*@dev range 0-99 */\n    uint256 internal constant WINGS_MASK_12 = RUNES_MASK_11 * 100;\n    /*@dev range 0-99 */\n    uint256 internal constant PET_MASK_13 = WINGS_MASK_12 * 100;\n    /*@dev range 0-99 */\n    uint256 internal constant BORDER_MASK_14 = PET_MASK_13 * 100;\n    /*@dev range 0-99 */\n    uint256 internal constant BACKGROUND_MASK_15 = BORDER_MASK_14 * 100;\n    /*@dev range 0-99 */\n    uint256 internal constant INTELLIGENCE_MASK_16 = BACKGROUND_MASK_15 * 100;\n    /*@dev range 0-99 */\n    uint256 internal constant AGILITY_MASK_17 = INTELLIGENCE_MASK_16 * 100;\n    /*@dev range 0-99 */\n    uint256 internal constant STRENGTH_MASK_18 = AGILITY_MASK_17 * 100;\n    /*@dev range 0-9 */\n    uint256 internal constant CLASS_MECH_MASK_19 = STRENGTH_MASK_18 * 100;\n    /*@dev range 0-999 */\n    uint256 internal constant RARITY_BONUS_MASK_20 = CLASS_MECH_MASK_19 * 10;\n    /*@dev range 0-9 */\n    uint256 internal constant SPECIALITY_MASK_21 = RARITY_BONUS_MASK_20 * 1000;\n    /*@dev range 0-99 */\n    uint256 internal constant DAMAGE_MASK_22 = SPECIALITY_MASK_21 * 10;\n    /*@dev range 0-99 */\n    uint256 internal constant AURA_MASK_23 = DAMAGE_MASK_22 * 100;\n    /*@dev 20 decimals left */\n    uint256 internal constant BASE_MASK_24 = AURA_MASK_23 * 100;\n    \n    \n    /* SPECIAL PERKS */\n    uint256 internal constant MINER_PERK = 1;\n    \n    \n    /* PARAM INDEXES */\n    uint256 internal constant BODY_COLOR_MAX_INDEX_0 = 0;\n    uint256 internal constant EYES_MAX_INDEX_1 = 1;\n    uint256 internal constant MOUTH_MAX_2 = 2;\n    uint256 internal constant HAIR_MAX_3 = 3;\n    uint256 internal constant HEIR_COLOR_MAX_4 = 4;\n    uint256 internal constant ARMOR_MAX_5 = 5;\n    uint256 internal constant WEAPON_MAX_6 = 6;\n    uint256 internal constant HAT_MAX_7 = 7;\n    uint256 internal constant RUNES_MAX_8 = 8;\n    uint256 internal constant WINGS_MAX_9 = 9;\n    uint256 internal constant PET_MAX_10 = 10;\n    uint256 internal constant BORDER_MAX_11 = 11;\n    uint256 internal constant BACKGROUND_MAX_12 = 12;\n    uint256 internal constant UNIQUE_INDEX_13 = 13;\n    uint256 internal constant LEGENDARY_INDEX_14 = 14;\n    uint256 internal constant MYTHIC_INDEX_15 = 15;\n    uint256 internal constant RARE_INDEX_16 = 16;\n    uint256 internal constant UNCOMMON_INDEX_17 = 17;\n    uint256 internal constant UNIQUE_TOTAL_INDEX_18 = 18;\n    \n     /* PACK PVP DATA LOGIC */\n    //pvp data\n    uint256 internal constant CLASS_PACK_0 = 1;\n    uint256 internal constant RARITY_BONUS_PACK_1 = CLASS_PACK_0 * 10;\n    uint256 internal constant RARITY_PACK_2 = RARITY_BONUS_PACK_1 * 1000;\n    uint256 internal constant EXPERIENCE_PACK_3 = RARITY_PACK_2 * 10;\n    uint256 internal constant INTELLIGENCE_PACK_4 = EXPERIENCE_PACK_3 * 1000;\n    uint256 internal constant AGILITY_PACK_5 = INTELLIGENCE_PACK_4 * 100;\n    uint256 internal constant STRENGTH_PACK_6 = AGILITY_PACK_5 * 100;\n    uint256 internal constant BASE_DAMAGE_PACK_7 = STRENGTH_PACK_6 * 100;\n    uint256 internal constant PET_PACK_8 = BASE_DAMAGE_PACK_7 * 100;\n    uint256 internal constant AURA_PACK_9 = PET_PACK_8 * 100;\n    uint256 internal constant WARRIOR_ID_PACK_10 = AURA_PACK_9 * 100;\n    uint256 internal constant PVP_CYCLE_PACK_11 = WARRIOR_ID_PACK_10 * 10**10;\n    uint256 internal constant RATING_PACK_12 = PVP_CYCLE_PACK_11 * 10**10;\n    uint256 internal constant PVP_BASE_PACK_13 = RATING_PACK_12 * 10**10;//NB rating must be at the END!\n    \n    //tournament data\n    uint256 internal constant HP_PACK_0 = 1;\n    uint256 internal constant DAMAGE_PACK_1 = HP_PACK_0 * 10**12;\n    uint256 internal constant ARMOR_PACK_2 = DAMAGE_PACK_1 * 10**12;\n    uint256 internal constant DODGE_PACK_3 = ARMOR_PACK_2 * 10**12;\n    uint256 internal constant PENETRATION_PACK_4 = DODGE_PACK_3 * 10**12;\n    uint256 internal constant COMBINE_BASE_PACK_5 = PENETRATION_PACK_4 * 10**12;\n    \n    /* MISC CONSTANTS */\n    uint256 internal constant MAX_ID_SIZE = 10000000000;\n    int256 internal constant PRECISION = 1000000;\n    \n    uint256 internal constant BATTLES_PER_CONTENDER = 10;//10x100\n    uint256 internal constant BATTLES_PER_CONTENDER_SUM = BATTLES_PER_CONTENDER * 100;//10x100\n    \n    uint256 internal constant LEVEL_BONUSES = 98898174676155504541373431282523211917151413121110;\n    \n    //ucommon bonuses\n    uint256 internal constant BONUS_NONE = 0;\n    uint256 internal constant BONUS_HP = 1;\n    uint256 internal constant BONUS_ARMOR = 2;\n    uint256 internal constant BONUS_CRIT_CHANCE = 3;\n    uint256 internal constant BONUS_CRIT_MULT = 4;\n    uint256 internal constant BONUS_PENETRATION = 5;\n    //rare bonuses\n    uint256 internal constant BONUS_STR = 6;\n    uint256 internal constant BONUS_AGI = 7;\n    uint256 internal constant BONUS_INT = 8;\n    uint256 internal constant BONUS_DAMAGE = 9;\n    \n    //bonus value database, \n    uint256 internal constant BONUS_DATA = 16060606140107152000;\n    //pets database\n    uint256 internal constant PETS_DATA = 287164235573728325842459981692000;\n    \n    uint256 internal constant PET_AURA = 2;\n    uint256 internal constant PET_PARAM_1 = 1;\n    uint256 internal constant PET_PARAM_2 = 0;\n\n    /* GETTERS */\n\tfunction getUniqueValue(uint256 identity) internal pure returns(uint256){\n\t\treturn identity % RARITY_MASK_1;\n\t}\n\n    function getRarityValue(uint256 identity) internal pure returns(uint256){\n        return (identity % CLASS_VIEW_MASK_2) / RARITY_MASK_1;\n    }\n\n\tfunction getClassViewValue(uint256 identity) internal pure returns(uint256){\n\t\treturn (identity % BODY_COLOR_MASK_3) / CLASS_VIEW_MASK_2;\n\t}\n\n\tfunction getBodyColorValue(uint256 identity) internal pure returns(uint256){\n        return (identity % EYES_MASK_4) / BODY_COLOR_MASK_3;\n    }\n\n    function getEyesValue(uint256 identity) internal pure returns(uint256){\n        return (identity % MOUTH_MASK_5) / EYES_MASK_4;\n    }\n\n    function getMouthValue(uint256 identity) internal pure returns(uint256){\n        return (identity % HEIR_MASK_6) / MOUTH_MASK_5;\n    }\n\n    function getHairValue(uint256 identity) internal pure returns(uint256){\n        return (identity % HEIR_COLOR_MASK_7) / HEIR_MASK_6;\n    }\n\n    function getHairColorValue(uint256 identity) internal pure returns(uint256){\n        return (identity % ARMOR_MASK_8) / HEIR_COLOR_MASK_7;\n    }\n\n    function getArmorValue(uint256 identity) internal pure returns(uint256){\n        return (identity % WEAPON_MASK_9) / ARMOR_MASK_8;\n    }\n\n    function getWeaponValue(uint256 identity) internal pure returns(uint256){\n        return (identity % HAT_MASK_10) / WEAPON_MASK_9;\n    }\n\n    function getHatValue(uint256 identity) internal pure returns(uint256){\n        return (identity % RUNES_MASK_11) / HAT_MASK_10;\n    }\n\n    function getRunesValue(uint256 identity) internal pure returns(uint256){\n        return (identity % WINGS_MASK_12) / RUNES_MASK_11;\n    }\n\n    function getWingsValue(uint256 identity) internal pure returns(uint256){\n        return (identity % PET_MASK_13) / WINGS_MASK_12;\n    }\n\n    function getPetValue(uint256 identity) internal pure returns(uint256){\n        return (identity % BORDER_MASK_14) / PET_MASK_13;\n    }\n\n\tfunction getBorderValue(uint256 identity) internal pure returns(uint256){\n\t\treturn (identity % BACKGROUND_MASK_15) / BORDER_MASK_14;\n\t}\n\n\tfunction getBackgroundValue(uint256 identity) internal pure returns(uint256){\n\t\treturn (identity % INTELLIGENCE_MASK_16) / BACKGROUND_MASK_15;\n\t}\n\n    function getIntelligenceValue(uint256 identity) internal pure returns(uint256){\n        return (identity % AGILITY_MASK_17) / INTELLIGENCE_MASK_16;\n    }\n\n    function getAgilityValue(uint256 identity) internal pure returns(uint256){\n        return ((identity % STRENGTH_MASK_18) / AGILITY_MASK_17);\n    }\n\n    function getStrengthValue(uint256 identity) internal pure returns(uint256){\n        return ((identity % CLASS_MECH_MASK_19) / STRENGTH_MASK_18);\n    }\n\n    function getClassMechValue(uint256 identity) internal pure returns(uint256){\n        return (identity % RARITY_BONUS_MASK_20) / CLASS_MECH_MASK_19;\n    }\n\n    function getRarityBonusValue(uint256 identity) internal pure returns(uint256){\n        return (identity % SPECIALITY_MASK_21) / RARITY_BONUS_MASK_20;\n    }\n\n    function getSpecialityValue(uint256 identity) internal pure returns(uint256){\n        return (identity % DAMAGE_MASK_22) / SPECIALITY_MASK_21;\n    }\n    \n    function getDamageValue(uint256 identity) internal pure returns(uint256){\n        return (identity % AURA_MASK_23) / DAMAGE_MASK_22;\n    }\n\n    function getAuraValue(uint256 identity) internal pure returns(uint256){\n        return ((identity % BASE_MASK_24) / AURA_MASK_23);\n    }\n\n    /* SETTERS */\n    function _setUniqueValue0(uint256 value) internal pure returns(uint256){\n        require(value < RARITY_MASK_1);\n        return value * UNIQUE_MASK_0;\n    }\n\n    function _setRarityValue1(uint256 value) internal pure returns(uint256){\n        require(value < (CLASS_VIEW_MASK_2 / RARITY_MASK_1));\n        return value * RARITY_MASK_1;\n    }\n\n    function _setClassViewValue2(uint256 value) internal pure returns(uint256){\n        require(value < (BODY_COLOR_MASK_3 / CLASS_VIEW_MASK_2));\n        return value * CLASS_VIEW_MASK_2;\n    }\n\n    function _setBodyColorValue3(uint256 value) internal pure returns(uint256){\n        require(value < (EYES_MASK_4 / BODY_COLOR_MASK_3));\n        return value * BODY_COLOR_MASK_3;\n    }\n\n    function _setEyesValue4(uint256 value) internal pure returns(uint256){\n        require(value < (MOUTH_MASK_5 / EYES_MASK_4));\n        return value * EYES_MASK_4;\n    }\n\n    function _setMouthValue5(uint256 value) internal pure returns(uint256){\n        require(value < (HEIR_MASK_6 / MOUTH_MASK_5));\n        return value * MOUTH_MASK_5;\n    }\n\n    function _setHairValue6(uint256 value) internal pure returns(uint256){\n        require(value < (HEIR_COLOR_MASK_7 / HEIR_MASK_6));\n        return value * HEIR_MASK_6;\n    }\n\n    function _setHairColorValue7(uint256 value) internal pure returns(uint256){\n        require(value < (ARMOR_MASK_8 / HEIR_COLOR_MASK_7));\n        return value * HEIR_COLOR_MASK_7;\n    }\n\n    function _setArmorValue8(uint256 value) internal pure returns(uint256){\n        require(value < (WEAPON_MASK_9 / ARMOR_MASK_8));\n        return value * ARMOR_MASK_8;\n    }\n\n    function _setWeaponValue9(uint256 value) internal pure returns(uint256){\n        require(value < (HAT_MASK_10 / WEAPON_MASK_9));\n        return value * WEAPON_MASK_9;\n    }\n\n    function _setHatValue10(uint256 value) internal pure returns(uint256){\n        require(value < (RUNES_MASK_11 / HAT_MASK_10));\n        return value * HAT_MASK_10;\n    }\n\n    function _setRunesValue11(uint256 value) internal pure returns(uint256){\n        require(value < (WINGS_MASK_12 / RUNES_MASK_11));\n        return value * RUNES_MASK_11;\n    }\n\n    function _setWingsValue12(uint256 value) internal pure returns(uint256){\n        require(value < (PET_MASK_13 / WINGS_MASK_12));\n        return value * WINGS_MASK_12;\n    }\n\n    function _setPetValue13(uint256 value) internal pure returns(uint256){\n        require(value < (BORDER_MASK_14 / PET_MASK_13));\n        return value * PET_MASK_13;\n    }\n\n    function _setBorderValue14(uint256 value) internal pure returns(uint256){\n        require(value < (BACKGROUND_MASK_15 / BORDER_MASK_14));\n        return value * BORDER_MASK_14;\n    }\n\n    function _setBackgroundValue15(uint256 value) internal pure returns(uint256){\n        require(value < (INTELLIGENCE_MASK_16 / BACKGROUND_MASK_15));\n        return value * BACKGROUND_MASK_15;\n    }\n\n    function _setIntelligenceValue16(uint256 value) internal pure returns(uint256){\n        require(value < (AGILITY_MASK_17 / INTELLIGENCE_MASK_16));\n        return value * INTELLIGENCE_MASK_16;\n    }\n\n    function _setAgilityValue17(uint256 value) internal pure returns(uint256){\n        require(value < (STRENGTH_MASK_18 / AGILITY_MASK_17));\n        return value * AGILITY_MASK_17;\n    }\n\n    function _setStrengthValue18(uint256 value) internal pure returns(uint256){\n        require(value < (CLASS_MECH_MASK_19 / STRENGTH_MASK_18));\n        return value * STRENGTH_MASK_18;\n    }\n\n    function _setClassMechValue19(uint256 value) internal pure returns(uint256){\n        require(value < (RARITY_BONUS_MASK_20 / CLASS_MECH_MASK_19));\n        return value * CLASS_MECH_MASK_19;\n    }\n\n    function _setRarityBonusValue20(uint256 value) internal pure returns(uint256){\n        require(value < (SPECIALITY_MASK_21 / RARITY_BONUS_MASK_20));\n        return value * RARITY_BONUS_MASK_20;\n    }\n\n    function _setSpecialityValue21(uint256 value) internal pure returns(uint256){\n        require(value < (DAMAGE_MASK_22 / SPECIALITY_MASK_21));\n        return value * SPECIALITY_MASK_21;\n    }\n    \n    function _setDamgeValue22(uint256 value) internal pure returns(uint256){\n        require(value < (AURA_MASK_23 / DAMAGE_MASK_22));\n        return value * DAMAGE_MASK_22;\n    }\n\n    function _setAuraValue23(uint256 value) internal pure returns(uint256){\n        require(value < (BASE_MASK_24 / AURA_MASK_23));\n        return value * AURA_MASK_23;\n    }\n    \n    /* WARRIOR IDENTITY GENERATION */\n    function _computeRunes(uint256 _rarity) internal pure returns (uint256){\n        return _rarity > UNCOMMON ? _rarity - UNCOMMON : 0;// 1 + _random(0, max, hash, WINGS_MASK_12, RUNES_MASK_11) : 0;\n    }\n\n    function _computeWings(uint256 _rarity, uint256 max, uint256 hash) internal pure returns (uint256){\n        return _rarity > RARE ?  1 + _random(0, max, hash, PET_MASK_13, WINGS_MASK_12) : 0;\n    }\n\n    function _computePet(uint256 _rarity, uint256 max, uint256 hash) internal pure returns (uint256){\n        return _rarity > MYTHIC ? 1 + _random(0, max, hash, BORDER_MASK_14, PET_MASK_13) : 0;\n    }\n\n    function _computeBorder(uint256 _rarity) internal pure returns (uint256){\n        return _rarity >= COMMON ? _rarity - 1 : 0;\n    }\n\n    function _computeBackground(uint256 _rarity) internal pure returns (uint256){\n        return _rarity;\n    }\n    \n    function _unpackPetData(uint256 index) internal pure returns(uint256){\n        return (PETS_DATA % (1000 ** (index + 1)) / (1000 ** index));\n    }\n    \n    function _getPetBonus1(uint256 _pet) internal pure returns(uint256) {\n        return (_pet % (10 ** (PET_PARAM_1 + 1)) / (10 ** PET_PARAM_1));\n    }\n    \n    function _getPetBonus2(uint256 _pet) internal pure returns(uint256) {\n        return (_pet % (10 ** (PET_PARAM_2 + 1)) / (10 ** PET_PARAM_2));\n    }\n    \n    function _getPetAura(uint256 _pet) internal pure returns(uint256) {\n        return (_pet % (10 ** (PET_AURA + 1)) / (10 ** PET_AURA));\n    }\n    \n    function _getBattleBonus(uint256 _setBonusIndex, uint256 _currentBonusIndex, uint256 _petData, uint256 _warriorAuras, uint256 _petAuras) internal pure returns(int256) {\n        int256 bonus = 0;\n        if (_setBonusIndex == _currentBonusIndex) {\n            bonus += int256(BONUS_DATA % (100 ** (_setBonusIndex + 1)) / (100 ** _setBonusIndex)) * PRECISION;\n        }\n        //add pet bonuses\n        if (_setBonusIndex == _getPetBonus1(_petData)) {\n            bonus += int256(BONUS_DATA % (100 ** (_setBonusIndex + 1)) / (100 ** _setBonusIndex)) * PRECISION / 2;\n        }\n        if (_setBonusIndex == _getPetBonus2(_petData)) {\n            bonus += int256(BONUS_DATA % (100 ** (_setBonusIndex + 1)) / (100 ** _setBonusIndex)) * PRECISION / 2;\n        }\n        //add warrior aura bonuses\n        if (isAuraSet(_warriorAuras, uint8(_setBonusIndex))) {//warriors receive half bonuses from auras\n            bonus += int256(BONUS_DATA % (100 ** (_setBonusIndex + 1)) / (100 ** _setBonusIndex)) * PRECISION / 2;\n        }\n        //add pet aura bonuses\n        if (isAuraSet(_petAuras, uint8(_setBonusIndex))) {//pets receive full bonues from auras\n            bonus += int256(BONUS_DATA % (100 ** (_setBonusIndex + 1)) / (100 ** _setBonusIndex)) * PRECISION;\n        }\n        return bonus;\n    }\n    \n    function _computeRarityBonus(uint256 _rarity, uint256 hash) internal pure returns (uint256){\n        if (_rarity == UNCOMMON) {\n            return 1 + _random(0, BONUS_PENETRATION, hash, SPECIALITY_MASK_21, RARITY_BONUS_MASK_20);\n        }\n        if (_rarity == RARE) {\n            return 1 + _random(BONUS_PENETRATION, BONUS_DAMAGE, hash, SPECIALITY_MASK_21, RARITY_BONUS_MASK_20);\n        }\n        if (_rarity >= MYTHIC) {\n            return 1 + _random(0, BONUS_DAMAGE, hash, SPECIALITY_MASK_21, RARITY_BONUS_MASK_20);\n        }\n        return BONUS_NONE;\n    }\n\n    function _computeAura(uint256 _rarity, uint256 hash) internal pure returns (uint256){\n        if (_rarity >= MYTHIC) {\n            return 1 + _random(0, BONUS_DAMAGE, hash, BASE_MASK_24, AURA_MASK_23);\n        }\n        return BONUS_NONE;\n    }\n    \n\tfunction _computeRarity(uint256 _reward, uint256 _unique, uint256 _legendary, \n\t    uint256 _mythic, uint256 _rare, uint256 _uncommon) internal pure returns(uint256){\n\t        \n        uint256 range = _unique + _legendary + _mythic + _rare + _uncommon;\n        if (_reward >= range) return COMMON; // common\n        if (_reward >= (range = (range - _uncommon))) return UNCOMMON;\n        if (_reward >= (range = (range - _rare))) return RARE;\n        if (_reward >= (range = (range - _mythic))) return MYTHIC;\n        if (_reward >= (range = (range - _legendary))) return LEGENDARY;\n        if (_reward < range) return UNIQUE;\n        return COMMON;\n    }\n    \n    function _computeUniqueness(uint256 _rarity, uint256 nextUnique) internal pure returns (uint256){\n        return _rarity == UNIQUE ? nextUnique : 0;\n    }\n    \n    /* identity packing */\n    /* @returns bonus value which depends on speciality value,\n     * if speciality == 1 (miner), then bonus value will be equal 4,\n     * otherwise 1\n     */\n    function _getBonus(uint256 identity) internal pure returns(uint256){\n        return getSpecialityValue(identity) == MINER_PERK ? 4 : 1;\n    }\n    \n\n    function _computeAndSetBaseParameters16_18_22(uint256 _hash) internal pure returns (uint256, uint256){\n        uint256 identity = 0;\n\n        uint256 damage = 35 + _random(0, 21, _hash, AURA_MASK_23, DAMAGE_MASK_22);\n        \n        uint256 strength = 45 + _random(0, 26, _hash, CLASS_MECH_MASK_19, STRENGTH_MASK_18);\n        uint256 agility = 15 + (125 - damage - strength);\n        uint256 intelligence = 155 - strength - agility - damage;\n        (strength, agility, intelligence) = _shuffleParams(strength, agility, intelligence, _hash);\n        \n        identity += _setStrengthValue18(strength);\n        identity += _setAgilityValue17(agility);\n\t\tidentity += _setIntelligenceValue16(intelligence);\n\t\tidentity += _setDamgeValue22(damage);\n        \n        uint256 classMech = strength > agility ? (strength > intelligence ? WARRIOR : MAGE) : (agility > intelligence ? ARCHER : MAGE);\n        return (identity, classMech);\n    }\n    \n    function _shuffleParams(uint256 param1, uint256 param2, uint256 param3, uint256 _hash) internal pure returns(uint256, uint256, uint256) {\n        uint256 temp = param1;\n        if (_hash % 2 == 0) {\n            temp = param1;\n            param1 = param2;\n            param2 = temp;\n        }\n        if ((_hash / 10 % 2) == 0) {\n            temp = param2;\n            param2 = param3;\n            param3 = temp;\n        }\n        if ((_hash / 100 % 2) == 0) {\n            temp = param1;\n            param1 = param2;\n            param2 = temp;\n        }\n        return (param1, param2, param3);\n    }\n    \n    \n    /* RANDOM */\n    function _random(uint256 _min, uint256 _max, uint256 _hash, uint256 _reminder, uint256 _devider) internal pure returns (uint256){\n        return ((_hash % _reminder) / _devider) % (_max - _min) + _min;\n    }\n\n    function _random(uint256 _min, uint256 _max, uint256 _hash) internal pure returns (uint256){\n        return _hash % (_max - _min) + _min;\n    }\n\n    function _getTargetBlock(uint256 _targetBlock) internal view returns(uint256){\n        uint256 currentBlock = block.number;\n        uint256 target = currentBlock - (currentBlock % 256) + (_targetBlock % 256);\n        if (target >= currentBlock) {\n            return (target - 256);\n        }\n        return target;\n    }\n    \n    function _getMaxRarityChance() internal pure returns(uint256){\n        return RARITY_CHANCE_RANGE;\n    }\n    \n    function generateWarrior(uint256 _heroIdentity, uint256 _heroLevel, uint256 _targetBlock, uint256 specialPerc, uint32[19] memory params) internal view returns (uint256) {\n        _targetBlock = _getTargetBlock(_targetBlock);\n        \n        uint256 identity;\n        uint256 hash = uint256(keccak256(block.blockhash(_targetBlock), _heroIdentity, block.coinbase, block.difficulty));\n        //0 _heroLevel produces warriors of COMMON rarity\n        uint256 rarityChance = _heroLevel == 0 ? RARITY_CHANCE_RANGE : \n        \t_random(0, RARITY_CHANCE_RANGE, hash) / (_heroLevel * _getBonus(_heroIdentity)); // 0 - 10 000 000\n        uint256 rarity = _computeRarity(rarityChance, \n            params[UNIQUE_INDEX_13],params[LEGENDARY_INDEX_14], params[MYTHIC_INDEX_15], params[RARE_INDEX_16], params[UNCOMMON_INDEX_17]);\n            \n        uint256 classMech;\n        \n        // start\n        (identity, classMech) = _computeAndSetBaseParameters16_18_22(hash);\n        \n        identity += _setUniqueValue0(_computeUniqueness(rarity, params[UNIQUE_TOTAL_INDEX_18] + 1));\n        identity += _setRarityValue1(rarity);\n        identity += _setClassViewValue2(classMech); // 1 to 1 with classMech\n        \n        identity += _setBodyColorValue3(1 + _random(0, params[BODY_COLOR_MAX_INDEX_0], hash, EYES_MASK_4, BODY_COLOR_MASK_3));\n        identity += _setEyesValue4(1 + _random(0, params[EYES_MAX_INDEX_1], hash, MOUTH_MASK_5, EYES_MASK_4));\n        identity += _setMouthValue5(1 + _random(0, params[MOUTH_MAX_2], hash, HEIR_MASK_6, MOUTH_MASK_5));\n        identity += _setHairValue6(1 + _random(0, params[HAIR_MAX_3], hash, HEIR_COLOR_MASK_7, HEIR_MASK_6));\n        identity += _setHairColorValue7(1 + _random(0, params[HEIR_COLOR_MAX_4], hash, ARMOR_MASK_8, HEIR_COLOR_MASK_7));\n        identity += _setArmorValue8(1 + _random(0, params[ARMOR_MAX_5], hash, WEAPON_MASK_9, ARMOR_MASK_8));\n        identity += _setWeaponValue9(1 + _random(0, params[WEAPON_MAX_6], hash, HAT_MASK_10, WEAPON_MASK_9));\n        identity += _setHatValue10(_random(0, params[HAT_MAX_7], hash, RUNES_MASK_11, HAT_MASK_10));//removed +1\n        \n        identity += _setRunesValue11(_computeRunes(rarity));\n        identity += _setWingsValue12(_computeWings(rarity, params[WINGS_MAX_9], hash));\n        identity += _setPetValue13(_computePet(rarity, params[PET_MAX_10], hash));\n        identity += _setBorderValue14(_computeBorder(rarity)); // 1 to 1 with rarity\n        identity += _setBackgroundValue15(_computeBackground(rarity)); // 1 to 1 with rarity\n        \n        identity += _setClassMechValue19(classMech);\n\n        identity += _setRarityBonusValue20(_computeRarityBonus(rarity, hash));\n        identity += _setSpecialityValue21(specialPerc); // currently only miner (1)\n        \n        identity += _setAuraValue23(_computeAura(rarity, hash));\n        // end\n        return identity;\n    }\n    \n\tfunction _changeParameter(uint256 _paramIndex, uint32 _value, uint32[19] storage parameters) internal {\n\t\t//we can change only view parameters, and unique count in max range <= 100\n\t\trequire(_paramIndex >= BODY_COLOR_MAX_INDEX_0 && _paramIndex <= UNIQUE_INDEX_13);\n\t\t//we can NOT set pet, border and background values,\n\t\t//those values have special logic behind them\n\t\trequire(\n\t\t    _paramIndex != RUNES_MAX_8 && \n\t\t    _paramIndex != PET_MAX_10 && \n\t\t    _paramIndex != BORDER_MAX_11 && \n\t\t    _paramIndex != BACKGROUND_MAX_12\n\t\t);\n\t\t//value of bodyColor, eyes, mouth, hair, hairColor, armor, weapon, hat must be < 1000\n\t\trequire(_paramIndex > HAT_MAX_7 || _value < 1000);\n\t\t//value of wings,  must be < 100\n\t\trequire(_paramIndex > BACKGROUND_MAX_12 || _value < 100);\n\t\t//check that max total number of UNIQUE warriors that we can emit is not > 100\n\t\trequire(_paramIndex != UNIQUE_INDEX_13 || (_value + parameters[UNIQUE_TOTAL_INDEX_18]) <= 100);\n\t\t\n\t\tparameters[_paramIndex] = _value;\n    }\n    \n\tfunction _recordWarriorData(uint256 identity, uint32[19] storage parameters) internal {\n        uint256 rarity = getRarityValue(identity);\n        if (rarity == UNCOMMON) { // uncommon\n            parameters[UNCOMMON_INDEX_17]--;\n            return;\n        }\n        if (rarity == RARE) { // rare\n            parameters[RARE_INDEX_16]--;\n            return;\n        }\n        if (rarity == MYTHIC) { // mythic\n            parameters[MYTHIC_INDEX_15]--;\n            return;\n        }\n        if (rarity == LEGENDARY) { // legendary\n            parameters[LEGENDARY_INDEX_14]--;\n            return;\n        }\n        if (rarity == UNIQUE) { // unique\n            parameters[UNIQUE_INDEX_13]--;\n            parameters[UNIQUE_TOTAL_INDEX_18] ++;\n            return;\n        }\n    }\n    \n    function _validateIdentity(uint256 _identity, uint32[19] memory params) internal pure returns(bool){\n        uint256 rarity = getRarityValue(_identity);\n        require(rarity <= UNIQUE);\n        \n        require(\n            rarity <= COMMON ||//common \n            (rarity == UNCOMMON && params[UNCOMMON_INDEX_17] > 0) ||//uncommon\n            (rarity == RARE && params[RARE_INDEX_16] > 0) ||//rare\n            (rarity == MYTHIC && params[MYTHIC_INDEX_15] > 0) ||//mythic\n            (rarity == LEGENDARY && params[LEGENDARY_INDEX_14] > 0) ||//legendary\n            (rarity == UNIQUE && params[UNIQUE_INDEX_13] > 0)//unique\n        );\n        require(rarity != UNIQUE || getUniqueValue(_identity) > params[UNIQUE_TOTAL_INDEX_18]);\n        \n        //check battle parameters\n        require(\n            getStrengthValue(_identity) < 100 &&\n            getAgilityValue(_identity) < 100 &&\n            getIntelligenceValue(_identity) < 100 &&\n            getDamageValue(_identity) <= 55\n        );\n        require(getClassMechValue(_identity) <= MAGE);\n        require(getClassMechValue(_identity) == getClassViewValue(_identity));\n        require(getSpecialityValue(_identity) <= MINER_PERK);\n        require(getRarityBonusValue(_identity) <= BONUS_DAMAGE);\n        require(getAuraValue(_identity) <= BONUS_DAMAGE);\n        \n        //check view\n        require(getBodyColorValue(_identity) <= params[BODY_COLOR_MAX_INDEX_0]);\n        require(getEyesValue(_identity) <= params[EYES_MAX_INDEX_1]);\n        require(getMouthValue(_identity) <= params[MOUTH_MAX_2]);\n        require(getHairValue(_identity) <= params[HAIR_MAX_3]);\n        require(getHairColorValue(_identity) <= params[HEIR_COLOR_MAX_4]);\n        require(getArmorValue(_identity) <= params[ARMOR_MAX_5]);\n        require(getWeaponValue(_identity) <= params[WEAPON_MAX_6]);\n        require(getHatValue(_identity) <= params[HAT_MAX_7]);\n        require(getRunesValue(_identity) <= params[RUNES_MAX_8]);\n        require(getWingsValue(_identity) <= params[WINGS_MAX_9]);\n        require(getPetValue(_identity) <= params[PET_MAX_10]);\n        require(getBorderValue(_identity) <= params[BORDER_MAX_11]);\n        require(getBackgroundValue(_identity) <= params[BACKGROUND_MAX_12]);\n        \n        return true;\n    }\n    \n    /* UNPACK METHODS */\n    //common\n    function _unpackClassValue(uint256 packedValue) internal pure returns(uint256){\n        return (packedValue % RARITY_PACK_2 / CLASS_PACK_0);\n    }\n    \n    function _unpackRarityBonusValue(uint256 packedValue) internal pure returns(uint256){\n        return (packedValue % RARITY_PACK_2 / RARITY_BONUS_PACK_1);\n    }\n    \n    function _unpackRarityValue(uint256 packedValue) internal pure returns(uint256){\n        return (packedValue % EXPERIENCE_PACK_3 / RARITY_PACK_2);\n    }\n    \n    function _unpackExpValue(uint256 packedValue) internal pure returns(uint256){\n        return (packedValue % INTELLIGENCE_PACK_4 / EXPERIENCE_PACK_3);\n    }\n\n    function _unpackLevelValue(uint256 packedValue) internal pure returns(uint256){\n        return (packedValue % INTELLIGENCE_PACK_4) / (EXPERIENCE_PACK_3 * POINTS_TO_LEVEL);\n    }\n    \n    function _unpackIntelligenceValue(uint256 packedValue) internal pure returns(int256){\n        return int256(packedValue % AGILITY_PACK_5 / INTELLIGENCE_PACK_4);\n    }\n    \n    function _unpackAgilityValue(uint256 packedValue) internal pure returns(int256){\n        return int256(packedValue % STRENGTH_PACK_6 / AGILITY_PACK_5);\n    }\n    \n    function _unpackStrengthValue(uint256 packedValue) internal pure returns(int256){\n        return int256(packedValue % BASE_DAMAGE_PACK_7 / STRENGTH_PACK_6);\n    }\n\n    function _unpackBaseDamageValue(uint256 packedValue) internal pure returns(int256){\n        return int256(packedValue % PET_PACK_8 / BASE_DAMAGE_PACK_7);\n    }\n    \n    function _unpackPetValue(uint256 packedValue) internal pure returns(uint256){\n        return (packedValue % AURA_PACK_9 / PET_PACK_8);\n    }\n    \n    function _unpackAuraValue(uint256 packedValue) internal pure returns(uint256){\n        return (packedValue % WARRIOR_ID_PACK_10 / AURA_PACK_9);\n    }\n    //\n    //pvp unpack\n    function _unpackIdValue(uint256 packedValue) internal pure returns(uint256){\n        return (packedValue % PVP_CYCLE_PACK_11 / WARRIOR_ID_PACK_10);\n    }\n    \n    function _unpackCycleValue(uint256 packedValue) internal pure returns(uint256){\n        return (packedValue % RATING_PACK_12 / PVP_CYCLE_PACK_11);\n    }\n    \n    function _unpackRatingValue(uint256 packedValue) internal pure returns(uint256){\n        return (packedValue % PVP_BASE_PACK_13 / RATING_PACK_12);\n    }\n    \n    //max cycle skip value cant be more than 1000000000\n    function _changeCycleValue(uint256 packedValue, uint256 newValue) internal pure returns(uint256){\n        newValue = newValue > 1000000000 ? 1000000000 : newValue;\n        return packedValue - (_unpackCycleValue(packedValue) * PVP_CYCLE_PACK_11) + newValue * PVP_CYCLE_PACK_11;\n    }\n    \n    function _packWarriorCommonData(uint256 _identity, uint256 _experience) internal pure returns(uint256){\n        uint256 packedData = 0;\n        packedData += getClassMechValue(_identity) * CLASS_PACK_0;\n        packedData += getRarityBonusValue(_identity) * RARITY_BONUS_PACK_1;\n        packedData += getRarityValue(_identity) * RARITY_PACK_2;\n        packedData += _experience * EXPERIENCE_PACK_3;\n        packedData += getIntelligenceValue(_identity) * INTELLIGENCE_PACK_4;\n        packedData += getAgilityValue(_identity) * AGILITY_PACK_5;\n        packedData += getStrengthValue(_identity) * STRENGTH_PACK_6;\n        packedData += getDamageValue(_identity) * BASE_DAMAGE_PACK_7;\n        packedData += getPetValue(_identity) * PET_PACK_8;\n        \n        return packedData;\n    }\n    \n    function _packWarriorPvpData(uint256 _identity, uint256 _rating, uint256 _pvpCycle, uint256 _warriorId, uint256 _experience) internal pure returns(uint256){\n        uint256 packedData = _packWarriorCommonData(_identity, _experience);\n        packedData += _warriorId * WARRIOR_ID_PACK_10;\n        packedData += _pvpCycle * PVP_CYCLE_PACK_11;\n        //rating MUST have most significant value!\n        packedData += _rating * RATING_PACK_12;\n        return packedData;\n    }\n    \n    /* TOURNAMENT BATTLES */\n    \n    \n    function _packWarriorIds(uint256[] memory packedWarriors) internal pure returns(uint256){\n        uint256 packedIds = 0;\n        uint256 length = packedWarriors.length;\n        for(uint256 i = 0; i < length; i ++) {\n            packedIds += (MAX_ID_SIZE ** i) * _unpackIdValue(packedWarriors[i]);\n        }\n        return packedIds;\n    }\n\n    function _unpackWarriorId(uint256 packedIds, uint256 index) internal pure returns(uint256){\n        return (packedIds % (MAX_ID_SIZE ** (index + 1)) / (MAX_ID_SIZE ** index));\n    }\n    \n    function _packCombinedParams(int256 hp, int256 damage, int256 armor, int256 dodge, int256 penetration) internal pure returns(uint256) {\n        uint256 combinedWarrior = 0;\n        combinedWarrior += uint256(hp) * HP_PACK_0;\n        combinedWarrior += uint256(damage) * DAMAGE_PACK_1;\n        combinedWarrior += uint256(armor) * ARMOR_PACK_2;\n        combinedWarrior += uint256(dodge) * DODGE_PACK_3;\n        combinedWarrior += uint256(penetration) * PENETRATION_PACK_4;\n        return combinedWarrior;\n    }\n    \n    function _unpackProtectionParams(uint256 combinedWarrior) internal pure returns \n    (int256 hp, int256 armor, int256 dodge){\n        hp = int256(combinedWarrior % DAMAGE_PACK_1 / HP_PACK_0);\n        armor = int256(combinedWarrior % DODGE_PACK_3 / ARMOR_PACK_2);\n        dodge = int256(combinedWarrior % PENETRATION_PACK_4 / DODGE_PACK_3);\n    }\n    \n    function _unpackAttackParams(uint256 combinedWarrior) internal pure returns(int256 damage, int256 penetration) {\n        damage = int256(combinedWarrior % ARMOR_PACK_2 / DAMAGE_PACK_1);\n        penetration = int256(combinedWarrior % COMBINE_BASE_PACK_5 / PENETRATION_PACK_4);\n    }\n    \n    function _combineWarriors(uint256[] memory packedWarriors) internal pure returns (uint256) {\n        int256 hp;\n        int256 damage;\n\t\tint256 armor;\n\t\tint256 dodge;\n\t\tint256 penetration;\n\t\t\n\t\t(hp, damage, armor, dodge, penetration) = _computeCombinedParams(packedWarriors);\n        return _packCombinedParams(hp, damage, armor, dodge, penetration);\n    }\n    \n    function _computeCombinedParams(uint256[] memory packedWarriors) internal pure returns \n    (int256 totalHp, int256 totalDamage, int256 maxArmor, int256 maxDodge, int256 maxPenetration){\n        uint256 length = packedWarriors.length;\n        \n        int256 hp;\n\t\tint256 armor;\n\t\tint256 dodge;\n\t\tint256 penetration;\n\t\t\n\t\tuint256 warriorAuras;\n\t\tuint256 petAuras;\n\t\t(warriorAuras, petAuras) = _getAurasData(packedWarriors);\n\t\t\n\t\tuint256 packedWarrior;\n        for(uint256 i = 0; i < length; i ++) {\n            packedWarrior = packedWarriors[i];\n            \n            totalDamage += getDamage(packedWarrior, warriorAuras, petAuras);\n            \n            penetration = getPenetration(packedWarrior, warriorAuras, petAuras);\n            maxPenetration = maxPenetration > penetration ? maxPenetration : penetration;\n\t\t\t(hp, armor, dodge) = _getProtectionParams(packedWarrior, warriorAuras, petAuras);\n            totalHp += hp;\n            maxArmor = maxArmor > armor ? maxArmor : armor;\n            maxDodge = maxDodge > dodge ? maxDodge : dodge;\n        }\n    }\n    \n    function _getAurasData(uint256[] memory packedWarriors) internal pure returns(uint256 warriorAuras, uint256 petAuras) {\n        uint256 length = packedWarriors.length;\n        \n        warriorAuras = 0;\n        petAuras = 0;\n        \n        uint256 packedWarrior;\n        for(uint256 i = 0; i < length; i ++) {\n            packedWarrior = packedWarriors[i];\n            warriorAuras = enableAura(warriorAuras, (_unpackAuraValue(packedWarrior)));\n            petAuras = enableAura(petAuras, (_getPetAura(_unpackPetData(_unpackPetValue(packedWarrior)))));\n        }\n        warriorAuras = filterWarriorAuras(warriorAuras, petAuras);\n        return (warriorAuras, petAuras);\n    }\n    \n    // Get bit value at position\n    function isAuraSet(uint256 aura, uint256 auraIndex) internal pure returns (bool) {\n        return aura & (uint256(0x01) << auraIndex) != 0;\n    }\n    \n    // Set bit value at position\n    function enableAura(uint256 a, uint256 n) internal pure returns (uint256) {\n        return a | (uint256(0x01) << n);\n    }\n    \n    //switch off warrior auras that are enabled in pets auras, pet aura have priority\n    function filterWarriorAuras(uint256 _warriorAuras, uint256 _petAuras) internal pure returns(uint256) {\n        return (_warriorAuras & _petAuras) ^ _warriorAuras;\n    }\n  \n    function _getTournamentBattles(uint256 _numberOfContenders) internal pure returns(uint256) {\n        return (_numberOfContenders * BATTLES_PER_CONTENDER / 2);\n    }\n    \n    function getTournamentBattleResults(uint256[] memory combinedWarriors, uint256 _targetBlock) internal view returns (uint32[] memory results){\n        uint256 length = combinedWarriors.length;\n        results = new uint32[](length);\n\t\t\n\t\tint256 damage1;\n\t\tint256 penetration1;\n\t\t\n\t\tuint256 hash;\n\t\t\n\t\tuint256 randomIndex;\n\t\tuint256 exp = 0;\n\t\tuint256 i;\n\t\tuint256 result;\n        for(i = 0; i < length; i ++) {\n            (damage1, penetration1) = _unpackAttackParams(combinedWarriors[i]);\n            while(results[i] < BATTLES_PER_CONTENDER_SUM) {\n                //if we just started generate new random source\n                //or regenerate if we used all data from it\n                if (exp == 0 || exp > 73) {\n                    hash = uint256(keccak256(block.blockhash(_getTargetBlock(_targetBlock - i)), uint256(damage1) + now));\n                    exp = 0;\n                }\n                //we do not fight with self if there are other warriors\n                randomIndex = (_random(i + 1 < length ? i + 1 : i, length, hash, 1000 * 10**exp, 10**exp));\n                result = getTournamentBattleResult(damage1, penetration1, combinedWarriors[i],\n                    combinedWarriors[randomIndex], hash % (1000 * 10**exp) / 10**exp);\n                results[result == 1 ? i : randomIndex] += 101;//icrement battle count 100 and +1 win\n                results[result == 1 ? randomIndex : i] += 100;//increment only battle count 100 for loser\n                if (results[randomIndex] >= BATTLES_PER_CONTENDER_SUM) {\n                    if (randomIndex < length - 1) {\n                        _swapValues(combinedWarriors, results, randomIndex, length - 1);\n                    }\n                    length --;\n                }\n                exp++;\n            }\n        }\n        //filter battle count from results\n        length = combinedWarriors.length;\n        for(i = 0; i < length; i ++) {\n            results[i] = results[i] % 100;\n        }\n        \n        return results;\n    }\n    \n    function _swapValues(uint256[] memory combinedWarriors, uint32[] memory results, uint256 id1, uint256 id2) internal pure {\n        uint256 temp = combinedWarriors[id1];\n        combinedWarriors[id1] = combinedWarriors[id2];\n        combinedWarriors[id2] = temp;\n        temp = results[id1];\n        results[id1] = results[id2];\n        results[id2] = uint32(temp);\n    }\n\n    function getTournamentBattleResult(int256 damage1, int256 penetration1, uint256 combinedWarrior1, \n        uint256 combinedWarrior2, uint256 randomSource) internal pure returns (uint256)\n    {\n        int256 damage2;\n\t\tint256 penetration2;\n        \n\t\t(damage2, penetration2) = _unpackAttackParams(combinedWarrior1);\n\n\t\tint256 totalHp1 = getCombinedTotalHP(combinedWarrior1, penetration2);\n\t\tint256 totalHp2 = getCombinedTotalHP(combinedWarrior2, penetration1);\n        \n        return _getBattleResult(damage1 * getBattleRandom(randomSource, 1) / 100, damage2 * getBattleRandom(randomSource, 10) / 100, totalHp1, totalHp2, randomSource);\n    }\n    /* COMMON BATTLE */\n    \n    function _getBattleResult(int256 damage1, int256 damage2, int256 totalHp1, int256 totalHp2, uint256 randomSource)  internal pure returns (uint256){\n\t\ttotalHp1 = (totalHp1 * (PRECISION * PRECISION) / damage2);\n\t\ttotalHp2 = (totalHp2 * (PRECISION * PRECISION) / damage1);\n\t\t//if draw, let the coin decide who wins\n\t\tif (totalHp1 == totalHp2) return randomSource % 2 + 1;\n\t\treturn totalHp1 > totalHp2 ? 1 : 2;       \n    }\n    \n    function getCombinedTotalHP(uint256 combinedData, int256 enemyPenetration) internal pure returns(int256) {\n        int256 hp;\n\t\tint256 armor;\n\t\tint256 dodge;\n\t\t(hp, armor, dodge) = _unpackProtectionParams(combinedData);\n        \n        return _getTotalHp(hp, armor, dodge, enemyPenetration);\n    }\n    \n    function getTotalHP(uint256 packedData, uint256 warriorAuras, uint256 petAuras, int256 enemyPenetration) internal pure returns(int256) {\n        int256 hp;\n\t\tint256 armor;\n\t\tint256 dodge;\n\t\t(hp, armor, dodge) = _getProtectionParams(packedData, warriorAuras, petAuras);\n        \n        return _getTotalHp(hp, armor, dodge, enemyPenetration);\n    }\n    \n    function _getTotalHp(int256 hp, int256 armor, int256 dodge, int256 enemyPenetration) internal pure returns(int256) {\n        int256 piercingResult = (armor - enemyPenetration) < -(75 * PRECISION) ? -(75 * PRECISION) : (armor - enemyPenetration);\n        int256 mitigation = (PRECISION - piercingResult * PRECISION / (PRECISION + piercingResult / 100) / 100);\n        \n        return (hp * PRECISION / mitigation + (hp * dodge / (100 * PRECISION)));\n    }\n    \n    function _applyLevelBonus(int256 _value, uint256 _level) internal pure returns(int256) {\n        _level -= 1;\n        return int256(uint256(_value) * (LEVEL_BONUSES % (100 ** (_level + 1)) / (100 ** _level)) / 10);\n    }\n    \n    function _getProtectionParams(uint256 packedData, uint256 warriorAuras, uint256 petAuras) internal pure returns(int256 hp, int256 armor, int256 dodge) {\n        uint256 rarityBonus = _unpackRarityBonusValue(packedData);\n        uint256 petData = _unpackPetData(_unpackPetValue(packedData));\n        int256 strength = _unpackStrengthValue(packedData) * PRECISION + _getBattleBonus(BONUS_STR, rarityBonus, petData, warriorAuras, petAuras);\n        int256 agility = _unpackAgilityValue(packedData) * PRECISION + _getBattleBonus(BONUS_AGI, rarityBonus, petData, warriorAuras, petAuras);\n        \n        hp = 100 * PRECISION + strength + 7 * strength / 10 + _getBattleBonus(BONUS_HP, rarityBonus, petData, warriorAuras, petAuras);//add bonus hp\n        hp = _applyLevelBonus(hp, _unpackLevelValue(packedData));\n\t\tarmor = (strength + 8 * strength / 10 + agility + _getBattleBonus(BONUS_ARMOR, rarityBonus, petData, warriorAuras, petAuras));//add bonus armor\n\t\tdodge = (2 * agility / 3);\n    }\n    \n    function getDamage(uint256 packedWarrior, uint256 warriorAuras, uint256 petAuras) internal pure returns(int256) {\n        uint256 rarityBonus = _unpackRarityBonusValue(packedWarrior);\n        uint256 petData = _unpackPetData(_unpackPetValue(packedWarrior));\n        int256 agility = _unpackAgilityValue(packedWarrior) * PRECISION + _getBattleBonus(BONUS_AGI, rarityBonus, petData, warriorAuras, petAuras);\n        int256 intelligence = _unpackIntelligenceValue(packedWarrior) * PRECISION + _getBattleBonus(BONUS_INT, rarityBonus, petData, warriorAuras, petAuras);\n\t\t\n\t\tint256 crit = (agility / 5 + intelligence / 4) + _getBattleBonus(BONUS_CRIT_CHANCE, rarityBonus, petData, warriorAuras, petAuras);\n\t\tint256 critMultiplier = (PRECISION + intelligence / 25) + _getBattleBonus(BONUS_CRIT_MULT, rarityBonus, petData, warriorAuras, petAuras);\n        \n        int256 damage = int256(_unpackBaseDamageValue(packedWarrior) * 3 * PRECISION / 2) + _getBattleBonus(BONUS_DAMAGE, rarityBonus, petData, warriorAuras, petAuras);\n        \n\t\treturn (_applyLevelBonus(damage, _unpackLevelValue(packedWarrior)) * (PRECISION + crit * critMultiplier / (100 * PRECISION))) / PRECISION;\n    }\n\n    function getPenetration(uint256 packedWarrior, uint256 warriorAuras, uint256 petAuras) internal pure returns(int256) {\n        uint256 rarityBonus = _unpackRarityBonusValue(packedWarrior);\n        uint256 petData = _unpackPetData(_unpackPetValue(packedWarrior));\n        int256 agility = _unpackAgilityValue(packedWarrior) * PRECISION + _getBattleBonus(BONUS_AGI, rarityBonus, petData, warriorAuras, petAuras);\n        int256 intelligence = _unpackIntelligenceValue(packedWarrior) * PRECISION + _getBattleBonus(BONUS_INT, rarityBonus, petData, warriorAuras, petAuras);\n\t\t\n\t\treturn (intelligence * 2 + agility + _getBattleBonus(BONUS_PENETRATION, rarityBonus, petData, warriorAuras, petAuras));\n    }\n    \n    /* BATTLE PVP */\n    \n    //@param randomSource must be >= 1000\n    function getBattleRandom(uint256 randmSource, uint256 _step) internal pure returns(int256){\n        return int256(100 + _random(0, 11, randmSource, 100 * _step, _step));\n    }\n    \n    uint256 internal constant NO_AURA = 0;\n    \n    function getPVPBattleResult(uint256 packedData1, uint256 packedData2, uint256 randmSource) internal pure returns (uint256){\n        uint256 petAura1 = _computePVPPetAura(packedData1);\n        uint256 petAura2 = _computePVPPetAura(packedData2);\n        \n        uint256 warriorAura1 = _computePVPWarriorAura(packedData1, petAura1);\n        uint256 warriorAura2 = _computePVPWarriorAura(packedData2, petAura2);\n        \n\t\tint256 damage1 = getDamage(packedData1, warriorAura1, petAura1) * getBattleRandom(randmSource, 1) / 100;\n        int256 damage2 = getDamage(packedData2, warriorAura2, petAura2) * getBattleRandom(randmSource, 10) / 100;\n\n\t\tint256 totalHp1;\n\t\tint256 totalHp2;\n\t\t(totalHp1, totalHp2) = _computeContendersTotalHp(packedData1, warriorAura1, petAura1, packedData2, warriorAura1, petAura1);\n        \n        return _getBattleResult(damage1, damage2, totalHp1, totalHp2, randmSource);\n    }\n    \n    function _computePVPPetAura(uint256 packedData) internal pure returns(uint256) {\n        return enableAura(NO_AURA, _getPetAura(_unpackPetData(_unpackPetValue(packedData))));\n    }\n    \n    function _computePVPWarriorAura(uint256 packedData, uint256 petAuras) internal pure returns(uint256) {\n        return filterWarriorAuras(enableAura(NO_AURA, _unpackAuraValue(packedData)), petAuras);\n    }\n    \n    function _computeContendersTotalHp(uint256 packedData1, uint256 warriorAura1, uint256 petAura1, uint256 packedData2, uint256 warriorAura2, uint256 petAura2) \n    internal pure returns(int256 totalHp1, int256 totalHp2) {\n\t\tint256 enemyPenetration = getPenetration(packedData2, warriorAura2, petAura2);\n\t\ttotalHp1 = getTotalHP(packedData1, warriorAura1, petAura1, enemyPenetration);\n\t\tenemyPenetration = getPenetration(packedData1, warriorAura1, petAura1);\n\t\ttotalHp2 = getTotalHP(packedData2, warriorAura1, petAura1, enemyPenetration);\n    }\n    \n    function getRatingRange(uint256 _pvpCycle, uint256 _pvpInterval, uint256 _expandInterval) internal pure returns (uint256){\n        return 50 + (_pvpCycle * _pvpInterval / _expandInterval * 25);\n    }\n    \n    function isMatching(int256 evenRating, int256 oddRating, int256 ratingGap) internal pure returns(bool) {\n        return evenRating <= (oddRating + ratingGap) && evenRating >= (oddRating - ratingGap);\n    }\n    \n    function sort(uint256[] memory data) internal pure {\n       quickSort(data, int(0), int(data.length - 1));\n    }\n    \n    function quickSort(uint256[] memory arr, int256 left, int256 right) internal pure {\n        int256 i = left;\n        int256 j = right;\n        if(i==j) return;\n        uint256 pivot = arr[uint256(left + (right - left) / 2)];\n        while (i <= j) {\n            while (arr[uint256(i)] < pivot) i++;\n            while (pivot < arr[uint256(j)]) j--;\n            if (i <= j) {\n                (arr[uint256(i)], arr[uint256(j)]) = (arr[uint256(j)], arr[uint256(i)]);\n                i++;\n                j--;\n            }\n        }\n        if (left < j)\n            quickSort(arr, left, j);\n        if (i < right)\n            quickSort(arr, i, right);\n    }\n    \n    function _swapPair(uint256[] memory matchingIds, uint256 id1, uint256 id2, uint256 id3, uint256 id4) internal pure {\n        uint256 temp = matchingIds[id1];\n        matchingIds[id1] = matchingIds[id2];\n        matchingIds[id2] = temp;\n        \n        temp = matchingIds[id3];\n        matchingIds[id3] = matchingIds[id4];\n        matchingIds[id4] = temp;\n    }\n    \n    function _swapValues(uint256[] memory matchingIds, uint256 id1, uint256 id2) internal pure {\n        uint256 temp = matchingIds[id1];\n        matchingIds[id1] = matchingIds[id2];\n        matchingIds[id2] = temp;\n    }\n    \n    function _getMatchingIds(uint256[] memory matchingIds, uint256 _pvpInterval, uint256 _skipCycles, uint256 _expandInterval) \n    internal pure returns(uint256 matchingCount) \n    {\n        matchingCount = matchingIds.length;\n        if (matchingCount == 0) return 0;\n        \n        uint256 warriorId;\n        uint256 index;\n        //sort matching ids\n        quickSort(matchingIds, int256(0), int256(matchingCount - 1));\n        //find pairs\n        int256 rating1;\n        uint256 pairIndex = 0;\n        int256 ratingRange;\n        for(index = 0; index < matchingCount; index++) {\n            //get packed value\n            warriorId = matchingIds[index];\n            //unpack rating 1\n            rating1 = int256(_unpackRatingValue(warriorId));\n            ratingRange = int256(getRatingRange(_unpackCycleValue(warriorId) + _skipCycles, _pvpInterval, _expandInterval));\n            \n            if (index > pairIndex && //check left neighbor\n            isMatching(rating1, int256(_unpackRatingValue(matchingIds[index - 1])), ratingRange)) {\n                //move matched pairs to the left\n                //swap pairs\n                _swapPair(matchingIds, pairIndex, index - 1, pairIndex + 1, index);\n                //mark last pair position\n                pairIndex += 2;\n            } else if (index + 1 < matchingCount && //check right neighbor\n            isMatching(rating1, int256(_unpackRatingValue(matchingIds[index + 1])), ratingRange)) {\n                //move matched pairs to the left\n                //swap pairs\n                _swapPair(matchingIds, pairIndex, index, pairIndex + 1, index + 1);\n                //mark last pair position\n                pairIndex += 2;\n                //skip next iteration\n                index++;\n            }\n        }\n        \n        matchingCount = pairIndex;\n    }\n\n    function _getPVPBattleResults(uint256[] memory matchingIds, uint256 matchingCount, uint256 _targetBlock) internal view {\n        uint256 exp = 0;\n        uint256 hash = 0;\n        uint256 result = 0;\n        for (uint256 even = 0; even < matchingCount; even += 2) {\n            if (exp == 0 || exp > 73) {\n                hash = uint256(keccak256(block.blockhash(_getTargetBlock(_targetBlock)), hash));\n                exp = 0;\n            }\n                \n            //compute battle result 1 = even(left) id won, 2 - odd(right) id won\n            result = getPVPBattleResult(matchingIds[even], matchingIds[even + 1], hash % (1000 * 10**exp) / 10**exp);\n            require(result > 0 && result < 3);\n            exp++;\n            //if odd warrior won, swap his id with even warrior,\n            //otherwise do nothing,\n            //even ids are winning ids! odds suck!\n            if (result == 2) {\n                _swapValues(matchingIds, even, even + 1);\n            }\n        }\n    }\n    \n    function _getLevel(uint256 _levelPoints) internal pure returns(uint256) {\n        return _levelPoints / POINTS_TO_LEVEL;\n    }\n    \n}\n\nlibrary DataTypes {\n     // / @dev The main Warrior struct. Every warrior in CryptoWarriors is represented by a copy\n    // /  of this structure, so great care was taken to ensure that it fits neatly into\n    // /  exactly two 256-bit words. Note that the order of the members in this structure\n    // /  is important because of the byte-packing rules used by Ethereum.\n    // /  Ref: http://solidity.readthedocs.io/en/develop/miscellaneous.html\n    struct Warrior{\n        // The Warrior's identity code is packed into these 256-bits\n        uint256 identity;\n        \n        uint64 cooldownEndBlock;\n        /** every warriors starts from 1 lv (10 level points per level) */\n        uint64 level;\n        /** PVP rating, every warrior starts with 100 rating */\n        int64 rating;\n        // 0 - idle\n        uint32 action;\n        /** Set to the index in the levelRequirements array (see CryptoWarriorBase.levelRequirements) that represents\n         *  the current dungeon level requirement for warrior. This starts at zero. */\n        uint32 dungeonIndex;\n    }\n}\n\ncontract CryptoWarriorBase is PermissionControll, PVPListenerInterface {\n\n    /*** EVENTS ***/\n\n    /// @dev The Arise event is fired whenever a new warrior comes into existence. This obviously\n    ///  includes any time a warrior is created through the ariseWarrior method, but it is also called\n    ///  when a new miner warrior is created.\n    event Arise(address owner, uint256 warriorId, uint256 identity);\n\n    /// @dev Transfer event as defined in current draft of ERC721. Emitted every time a warrior\n    ///  ownership is assigned, including dungeon rewards.\n    event Transfer(address from, address to, uint256 tokenId);\n\n    /*** CONSTANTS ***/\n    \n\tuint256 public constant IDLE = 0;\n    uint256 public constant PVE_BATTLE = 1;\n    uint256 public constant PVP_BATTLE = 2;\n    uint256 public constant TOURNAMENT_BATTLE = 3;\n    \n    //max pve dungeon level\n    uint256 public constant MAX_LEVEL = 25;\n    //how many points is needed to get 1 level\n    uint256 public constant POINTS_TO_LEVEL = 10;\n    \n    /// @dev A lookup table contains PVE dungeon level requirements, each time warrior\n    /// completes dungeon, next level requirement is set, until 25lv (250points) is reached.\n    uint32[6] public dungeonRequirements = [\n        uint32(10),\n        uint32(30),\n        uint32(60),\n        uint32(100),\n        uint32(150),\n        uint32(250)\n    ];\n\n    // An approximation of currently how many seconds are in between blocks.\n    uint256 public secondsPerBlock = 15;\n\n    /*** STORAGE ***/\n\n    /// @dev An array containing the Warrior struct for all Warriors in existence. The ID\n    ///  of each warrior is actually an index of this array.\n    DataTypes.Warrior[] warriors;\n\n    /// @dev A mapping from warrior IDs to the address that owns them. All warriors have\n    ///  some valid owner address, even miner warriors are created with a non-zero owner.\n    mapping (uint256 => address) public warriorToOwner;\n\n    // @dev A mapping from owner address to count of tokens that address owns.\n    //  Used internally inside balanceOf() to resolve ownership count.\n    mapping (address => uint256) ownersTokenCount;\n\n    /// @dev A mapping from warrior IDs to an address that has been approved to call\n    ///  transferFrom(). Each Warrior can only have one approved address for transfer\n    ///  at any time. A zero value means no approval is outstanding.\n    mapping (uint256 => address) public warriorToApproved;\n    \n    // Mapping from owner to list of owned token IDs\n    mapping (address => uint256[]) internal ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) internal ownedTokensIndex;\n\n\n    /// @dev The address of the ClockAuction contract that handles sales of warriors. This\n    ///  same contract handles both peer-to-peer sales as well as the miner sales which are\n    ///  initiated every 15 minutes.\n    SaleClockAuction public saleAuction;\n    \n    \n    /// @dev Assigns ownership of a specific warrior to an address.\n    function _transfer(address _from, address _to, uint256 _tokenId) internal {\n        // When creating new warriors _from is 0x0, but we can't account that address.\n        if (_from != address(0)) {\n            _clearApproval(_tokenId);\n            _removeTokenFrom(_from, _tokenId);\n        }\n        _addTokenTo(_to, _tokenId);\n        \n        // Emit the transfer event.\n        Transfer(_from, _to, _tokenId);\n    }\n    \n    function _addTokenTo(address _to, uint256 _tokenId) internal {\n        // Since the number of warriors is capped to '1 000 000' we can't overflow this\n        ownersTokenCount[_to]++;\n        // transfer ownership\n        warriorToOwner[_tokenId] = _to;\n        \n        uint256 length = ownedTokens[_to].length;\n        ownedTokens[_to].push(_tokenId);\n        ownedTokensIndex[_tokenId] = length;\n    }\n    \n    function _removeTokenFrom(address _from, uint256 _tokenId) internal {\n        //\n        ownersTokenCount[_from]--;\n        \n        warriorToOwner[_tokenId] = address(0);\n        \n        uint256 tokenIndex = ownedTokensIndex[_tokenId];\n        uint256 lastTokenIndex = ownedTokens[_from].length - 1;\n        uint256 lastToken = ownedTokens[_from][lastTokenIndex];\n    \n        ownedTokens[_from][tokenIndex] = lastToken;\n        ownedTokens[_from][lastTokenIndex] = 0;\n        \n        // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to\n        // be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping\n        // the lastToken to the first position, and then dropping the element placed in the last position of the list\n        ownedTokens[_from].length--;\n        ownedTokensIndex[_tokenId] = 0;\n        ownedTokensIndex[lastToken] = tokenIndex;\n    }\n    \n    function _clearApproval(uint256 _tokenId) internal {\n        if (warriorToApproved[_tokenId] != address(0)) {\n            // clear any previously approved ownership exchange\n            warriorToApproved[_tokenId] = address(0);\n        }\n    }\n    \n    function _createWarrior(uint256 _identity, address _owner, uint256 _cooldown, uint256 _level, uint256 _rating, uint256 _dungeonIndex)\n        internal\n        returns (uint256) {\n        \t    \n        DataTypes.Warrior memory _warrior = DataTypes.Warrior({\n            identity : _identity,\n            cooldownEndBlock : uint64(_cooldown),\n            level : uint64(_level),//uint64(10),\n            rating : int64(_rating),//int64(100),\n            action : uint32(IDLE),\n            dungeonIndex : uint32(_dungeonIndex)//uint32(0)\n        });\n        uint256 newWarriorId = warriors.push(_warrior) - 1;\n        \n        // let's just be 100% sure we never let this happen.\n        require(newWarriorId == uint256(uint32(newWarriorId)));\n        \n        // emit the arise event\n        Arise(_owner, newWarriorId, _identity);\n        \n        // This will assign ownership, and also emit the Transfer event as\n        // per ERC721 draft\n        _transfer(0, _owner, newWarriorId);\n\n        return newWarriorId;\n    }\n    \n\n    // Any C-level can fix how many seconds per blocks are currently observed.\n    function setSecondsPerBlock(uint256 secs) external onlyAuthorized {\n        secondsPerBlock = secs;\n    }\n}\n\ncontract WarriorTokenImpl is CryptoWarriorBase, ERC721 {\n\n    /// @notice Name and symbol of the non fungible token, as defined in ERC721.\n    string public constant name = \"CryptoWarriors\";\n    string public constant symbol = \"CW\";\n\n    bytes4 constant InterfaceSignature_ERC165 =\n        bytes4(keccak256('supportsInterface(bytes4)'));\n\n    bytes4 constant InterfaceSignature_ERC721 =\n        bytes4(keccak256('name()')) ^\n        bytes4(keccak256('symbol()')) ^\n        bytes4(keccak256('totalSupply()')) ^\n        bytes4(keccak256('balanceOf(address)')) ^\n        bytes4(keccak256('ownerOf(uint256)')) ^\n        bytes4(keccak256('approve(address,uint256)')) ^\n        bytes4(keccak256('transfer(address,uint256)')) ^\n        bytes4(keccak256('transferFrom(address,address,uint256)')) ^\n        bytes4(keccak256('tokensOfOwner(address)'));\n\n    /// @notice Introspection interface as per ERC-165 (https://github.com/ethereum/EIPs/issues/165).\n    ///  Returns true for any standardized interfaces implemented by this contract. We implement\n    ///  ERC-165 (obviously!) and ERC-721.\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool)\n    {\n        // DEBUG ONLY\n        //require((InterfaceSignature_ERC165 == 0x01ffc9a7) && (InterfaceSignature_ERC721 == 0x9f40b779));\n\n        return ((_interfaceID == InterfaceSignature_ERC165) || (_interfaceID == InterfaceSignature_ERC721));\n    }\n\n    // Internal utility functions: These functions all assume that their input arguments\n    // are valid. We leave it to public methods to sanitize their inputs and follow\n    // the required logic.\n\n    /** @dev Checks if a given address is the current owner of the specified Warrior tokenId.\n     * @param _claimant the address we are validating against.\n     * @param _tokenId warrior id\n     */\n    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\n        return _claimant != address(0) && warriorToOwner[_tokenId] == _claimant;    \n    }\n\n    function _ownerApproved(address _claimant, uint256 _tokenId) internal view returns (bool) {\n        return _claimant != address(0) &&//0 address means token is burned \n        warriorToOwner[_tokenId] == _claimant && warriorToApproved[_tokenId] == address(0);    \n    }\n\n    /// @dev Checks if a given address currently has transferApproval for a particular Warrior.\n    /// @param _claimant the address we are confirming warrior is approved for.\n    /// @param _tokenId warrior id\n    function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {\n        return warriorToApproved[_tokenId] == _claimant;\n    }\n\n    /// @dev Marks an address as being approved for transferFrom(), overwriting any previous\n    ///  approval. Setting _approved to address(0) clears all transfer approval.\n    ///  NOTE: _approve() does NOT send the Approval event. This is intentional because\n    ///  _approve() and transferFrom() are used together for putting Warriors on auction, and\n    ///  there is no value in spamming the log with Approval events in that case.\n    function _approve(uint256 _tokenId, address _approved) internal {\n        warriorToApproved[_tokenId] = _approved;\n    }\n\n    /// @notice Returns the number of Warriors(tokens) owned by a specific address.\n    /// @param _owner The owner address to check.\n    /// @dev Required for ERC-721 compliance\n    function balanceOf(address _owner) public view returns (uint256 count) {\n        return ownersTokenCount[_owner];\n    }\n\n    /// @notice Transfers a Warrior to another address. If transferring to a smart\n    ///  contract be VERY CAREFUL to ensure that it is aware of ERC-721 (or\n    ///  CryptoWarriors specifically) or your Warrior may be lost forever. Seriously.\n    /// @param _to The address of the recipient, can be a user or contract.\n    /// @param _tokenId The ID of the Warrior to transfer.\n    /// @dev Required for ERC-721 compliance.\n    function transfer(address _to, uint256 _tokenId) external whenNotPaused {\n        // Safety check to prevent against an unexpected 0x0 default.\n        require(_to != address(0));\n        // Disallow transfers to this contract to prevent accidental misuse.\n        // The contract should never own any warriors (except very briefly\n        // after a miner warrior is created and before it goes on auction).\n        require(_to != address(this));\n        // Disallow transfers to the auction contracts to prevent accidental\n        // misuse. Auction contracts should only take ownership of warriors\n        // through the allow + transferFrom flow.\n        require(_to != address(saleAuction));\n        // You can only send your own warrior.\n        require(_owns(msg.sender, _tokenId));\n        // Only idle warriors are allowed \n        require(warriors[_tokenId].action == IDLE);\n\n        // Reassign ownership, clear pending approvals, emit Transfer event.\n        _transfer(msg.sender, _to, _tokenId);\n    }\n    \n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256) {\n        require(_index < balanceOf(_owner));\n        return ownedTokens[_owner][_index];\n    }\n\n    /// @notice Grant another address the right to transfer a specific Warrior via\n    ///  transferFrom(). This is the preferred flow for transfering NFTs to contracts.\n    /// @param _to The address to be granted transfer approval. Pass address(0) to\n    ///  clear all approvals.\n    /// @param _tokenId The ID of the Warrior that can be transferred if this call succeeds.\n    /// @dev Required for ERC-721 compliance.\n    function approve(address _to, uint256 _tokenId) external whenNotPaused {\n        // Only an owner can grant transfer approval.\n        require(_owns(msg.sender, _tokenId));\n        // Only idle warriors are allowed \n        require(warriors[_tokenId].action == IDLE);\n\n        // Register the approval (replacing any previous approval).\n        _approve(_tokenId, _to);\n\n        // Emit approval event.\n        Approval(msg.sender, _to, _tokenId);\n    }\n\n    /// @notice Transfer a Warrior owned by another address, for which the calling address\n    ///  has previously been granted transfer approval by the owner.\n    /// @param _from The address that owns the Warrior to be transfered.\n    /// @param _to The address that should take ownership of the Warrior. Can be any address,\n    ///  including the caller.\n    /// @param _tokenId The ID of the Warrior to be transferred.\n    /// @dev Required for ERC-721 compliance.\n    function transferFrom(address _from, address _to, uint256 _tokenId)\n        external\n        whenNotPaused\n    {\n        // Safety check to prevent against an unexpected 0x0 default.\n        require(_to != address(0));\n        // Disallow transfers to this contract to prevent accidental misuse.\n        // The contract should never own any warriors (except very briefly\n        // after a miner warrior is created and before it goes on auction).\n        require(_to != address(this));\n        // Check for approval and valid ownership\n        require(_approvedFor(msg.sender, _tokenId));\n        require(_owns(_from, _tokenId));\n        // Only idle warriors are allowed \n        require(warriors[_tokenId].action == IDLE);\n\n        // Reassign ownership (also clears pending approvals and emits Transfer event).\n        _transfer(_from, _to, _tokenId);\n    }\n\n    /// @notice Returns the total number of Warriors currently in existence.\n    /// @dev Required for ERC-721 compliance.\n    function totalSupply() public view returns (uint256) {\n        return warriors.length;\n    }\n\n    /// @notice Returns the address currently assigned ownership of a given Warrior.\n    /// @dev Required for ERC-721 compliance.\n    function ownerOf(uint256 _tokenId)\n        external\n        view\n        returns (address owner)\n    {\n        require(_tokenId < warriors.length);\n        owner = warriorToOwner[_tokenId];\n    }\n\n    /// @notice Returns a list of all Warrior IDs assigned to an address.\n    /// @param _owner The owner whose Warriors we are interested in.\n    function tokensOfOwner(address _owner) external view returns(uint256[] ownerTokens) {\n        return ownedTokens[_owner];\n    }\n    \n    function tokensOfOwnerFromIndex(address _owner, uint256 _fromIndex, uint256 _count) external view returns(uint256[] memory ownerTokens) {\n        require(_fromIndex < balanceOf(_owner));\n        uint256[] storage tokens = ownedTokens[_owner];\n        //        \n        uint256 ownerBalance = ownersTokenCount[_owner];\n        uint256 lenght = (ownerBalance - _fromIndex >= _count ? _count : ownerBalance - _fromIndex);\n        //\n        ownerTokens = new uint256[](lenght);\n        for(uint256 i = 0; i < lenght; i ++) {\n            ownerTokens[i] = tokens[_fromIndex + i];\n        }\n        \n        return ownerTokens;\n    }\n    \n    /**\n     * @dev Internal function to burn a specific token\n     * @dev Reverts if the token does not exist\n     * @param _owner owner of the token to burn\n     * @param _tokenId uint256 ID of the token being burned by the msg.sender\n     */\n    function _burn(address _owner, uint256 _tokenId) internal {\n        _clearApproval(_tokenId);\n        _removeTokenFrom(_owner, _tokenId);\n        \n        Transfer(_owner, address(0), _tokenId);\n    }\n\n}\n\ncontract CryptoWarriorPVE is WarriorTokenImpl {\n    uint256 internal constant MINER_PERK = 1;\n    uint256 internal constant SUMMONING_SICKENESS = 12;\n    \n    uint256 internal constant PVE_COOLDOWN = 1 hours;\n    uint256 internal constant PVE_DURATION = 15 minutes;\n    \n    \n    /// @notice The payment required to use startPVEBattle().\n    uint256 public pveBattleFee = 10 finney;\n    uint256 public constant PVE_COMPENSATION = 2 finney;\n    \n\t/// @dev The address of the sibling contract that is used to implement warrior generation algorithm.\n    SanctuaryInterface public sanctuary;\n\n    /** @dev PVEStarted event. Emitted every time a warrior enters pve battle\n     *  @param owner Warrior owner\n     *  @param dungeonIndex Started dungeon index \n     *  @param warriorId Warrior ID that started PVE dungeon\n     *  @param battleEndBlock Block number, when started PVE dungeon will be completed\n     */\n    event PVEStarted(address owner, uint256 dungeonIndex, uint256 warriorId, uint256 battleEndBlock);\n\n    /** @dev PVEFinished event. Emitted every time a warrior finishes pve battle\n     *  @param owner Warrior owner\n     *  @param dungeonIndex Finished dungeon index\n     *  @param warriorId Warrior ID that completed dungeon\n     *  @param cooldownEndBlock Block number, when cooldown on PVE battle entrance will be over\n     *  @param rewardId Warrior ID which was granted to the owner as battle reward\n     */\n    event PVEFinished(address owner, uint256 dungeonIndex, uint256 warriorId, uint256 cooldownEndBlock, uint256 rewardId);\n\n\t/// @dev Update the address of the sanctuary contract, can only be called by the Admin.\n    /// @param _address An address of a sanctuary contract instance to be used from this point forward.\n    function setSanctuaryAddress(address _address) external onlyAdmin {\n        SanctuaryInterface candidateContract = SanctuaryInterface(_address);\n\n        // NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117\n        require(candidateContract.isSanctuary());\n\n        // Set the new contract address\n        sanctuary = candidateContract;\n    }\n    \n    function areUnique(uint256[] memory _warriorIds) internal pure returns(bool) {\n   \t    uint256 length = _warriorIds.length;\n   \t    uint256 j;\n        for(uint256 i = 0; i < length; i++) {\n\t        for(j = i + 1; j < length; j++) {\n\t            if (_warriorIds[i] == _warriorIds[j]) return false;\n\t        }\n        }\n        return true; \n   \t}\n\n    /// @dev Updates the minimum payment required for calling startPVE(). Can only\n    ///  be called by the COO address.\n    function setPVEBattleFee(uint256 _pveBattleFee) external onlyAdmin {\n        require(_pveBattleFee > PVE_COMPENSATION);\n        pveBattleFee = _pveBattleFee;\n    }\n    \n    /** @dev Returns PVE cooldown, after each battle, the warrior receives a \n     *  cooldown on the next entrance to the battle, cooldown depends on current warrior level,\n     *  which is multiplied by 1h. Special case: after receiving 25 lv, the cooldwon will be 14 days.\n     *  @param _levelPoints warrior level */\n    function getPVECooldown(uint256 _levelPoints) public pure returns (uint256) {\n        uint256 level = CryptoUtils._getLevel(_levelPoints);\n        if (level >= MAX_LEVEL) return (14 * 24 * PVE_COOLDOWN);//14 days\n        return (PVE_COOLDOWN * level);\n    }\n\n    /** @dev Returns PVE duration, each battle have a duration, which depends on current warrior level,\n     *  which is multiplied by 15 min. At the end of the duration, warrior is becoming eligible to receive\n     *  battle reward (new warrior in shiny armor)\n     *  @param _levelPoints warrior level points \n     */\n    function getPVEDuration(uint256 _levelPoints) public pure returns (uint256) {\n        return CryptoUtils._getLevel(_levelPoints) * PVE_DURATION;\n    }\n    \n    /// @dev Checks that a given warrior can participate in PVE battle. Requires that the\n    ///  current cooldown is finished and also checks that warrior is idle (does not participate in any action)\n    ///  and dungeon level requirement is satisfied\n    function _isReadyToPVE(DataTypes.Warrior _warrior) internal view returns (bool) {\n        return (_warrior.action == IDLE) && //is idle\n        (_warrior.cooldownEndBlock <= uint64(block.number)) && //no cooldown\n        (_warrior.level >= dungeonRequirements[_warrior.dungeonIndex]);//dungeon level requirement is satisfied\n    }\n    \n    /// @dev Internal utility function to initiate pve battle, assumes that all battle\n    ///  requirements have been checked.\n    function _triggerPVEStart(uint256 _warriorId) internal {\n        // Grab a reference to the warrior from storage.\n        DataTypes.Warrior storage warrior = warriors[_warriorId];\n        // Set warrior current action to pve battle\n        warrior.action = uint16(PVE_BATTLE);\n        // Set battle duration\n        warrior.cooldownEndBlock = uint64((getPVEDuration(warrior.level) / secondsPerBlock) + block.number);\n        // Emit the pve battle start event.\n        PVEStarted(msg.sender, warrior.dungeonIndex, _warriorId, warrior.cooldownEndBlock);\n    }\n    \n    /// @dev Starts PVE battle for specified warrior, \n    /// after battle, warrior owner will receive reward (Warrior) \n    /// @param _warriorId A Warrior ready to PVE battle.\n    function startPVE(uint256 _warriorId) external payable whenNotPaused {\n\t\t// Checks for payment.\n        require(msg.value >= pveBattleFee);\n\t\t\n\t\t// Caller must own the warrior.\n        require(_ownerApproved(msg.sender, _warriorId));\n\n        // Grab a reference to the warrior in storage.\n        DataTypes.Warrior storage warrior = warriors[_warriorId];\n\n        // Check that the warrior exists.\n        require(warrior.identity != 0);\n\n        // Check that the warrior is ready to battle\n        require(_isReadyToPVE(warrior));\n        \n        // All checks passed, let the battle begin!\n        _triggerPVEStart(_warriorId);\n        \n        // Calculate any excess funds included in msg.value. If the excess\n        // is anything worth worrying about, transfer it back to message owner.\n        // NOTE: We checked above that the msg.value is greater than or\n        // equal to the price so this cannot underflow.\n        uint256 feeExcess = msg.value - pveBattleFee;\n\n        // Return the funds. This is not susceptible \n        // to a re-entry attack because of _isReadyToPVE check\n        // will fail\n        msg.sender.transfer(feeExcess);\n        //send battle fee to beneficiary\n        bankAddress.transfer(pveBattleFee - PVE_COMPENSATION);\n    }\n    \n    function _ariseWarrior(address _owner, DataTypes.Warrior storage _warrior) internal returns(uint256) {\n        uint256 identity = sanctuary.generateWarrior(_warrior.identity, CryptoUtils._getLevel(_warrior.level), _warrior.cooldownEndBlock - 1, 0);\n        return _createWarrior(identity, _owner, block.number + (PVE_COOLDOWN * SUMMONING_SICKENESS / secondsPerBlock), 10, 100, 0);\n    }\n\n\t/// @dev Internal utility function to finish pve battle, assumes that all battle\n    ///  finish requirements have been checked.\n    function _triggerPVEFinish(uint256 _warriorId) internal {\n        // Grab a reference to the warrior in storage.\n        DataTypes.Warrior storage warrior = warriors[_warriorId];\n        \n        // Set warrior current action to idle\n        warrior.action = uint16(IDLE);\n        \n        // Compute an estimation of the cooldown time in blocks (based on current level).\n        // and miner perc also reduces cooldown time by 4 times\n        warrior.cooldownEndBlock = uint64((getPVECooldown(warrior.level) / \n            CryptoUtils._getBonus(warrior.identity) / secondsPerBlock) + block.number);\n        \n        // cash completed dungeon index before increment\n        uint256 dungeonIndex = warrior.dungeonIndex;\n        // Increment the dungeon index, clamping it at 5, which is the length of the\n        // dungeonRequirements array. We could check the array size dynamically, but hard-coding\n        // this as a constant saves gas.\n        if (dungeonIndex < 5) {\n            warrior.dungeonIndex += 1;\n        }\n        \n        address owner = warriorToOwner[_warriorId];\n        // generate reward\n        uint256 arisenWarriorId = _ariseWarrior(owner, warrior);\n        //Emit event\n        PVEFinished(owner, dungeonIndex, _warriorId, warrior.cooldownEndBlock, arisenWarriorId);\n    }\n    \n    /**\n     * @dev finishPVE can be called after battle time is over,\n     * if checks are passed then battle result is computed,\n     * and new warrior is awarded to owner of specified _warriord ID.\n     * NB anyone can call this method, if they willing to pay the gas price\n     */\n    function finishPVE(uint256 _warriorId) external whenNotPaused {\n        // Grab a reference to the warrior in storage.\n        DataTypes.Warrior storage warrior = warriors[_warriorId];\n        \n        // Check that the warrior exists.\n        require(warrior.identity != 0);\n        \n        // Check that warrior participated in PVE battle action\n        require(warrior.action == PVE_BATTLE);\n        \n        // And the battle time is over\n        require(warrior.cooldownEndBlock <= uint64(block.number));\n        \n        // When the all checks done, calculate actual battle result\n        _triggerPVEFinish(_warriorId);\n        \n        //not susceptible to reetrance attack because of require(warrior.action == PVE_BATTLE)\n        //and require(warrior.cooldownEndBlock <= uint64(block.number));\n        msg.sender.transfer(PVE_COMPENSATION);\n    }\n    \n    /**\n     * @dev finishPVEBatch same as finishPVE but for multiple warrior ids.\n     * NB anyone can call this method, if they willing to pay the gas price\n     */\n    function finishPVEBatch(uint256[] _warriorIds) external whenNotPaused {\n        uint256 length = _warriorIds.length;\n        //check max number of bach finish pve\n        require(length <= 20);\n        uint256 blockNumber = block.number;\n        uint256 index;\n        //all warrior ids must be unique\n        require(areUnique(_warriorIds));\n        //check prerequisites\n        for(index = 0; index < length; index ++) {\n            DataTypes.Warrior storage warrior = warriors[_warriorIds[index]];\n\t\t\trequire(\n\t\t        // Check that the warrior exists.\n\t\t\t    warrior.identity != 0 &&\n\t\t        // Check that warrior participated in PVE battle action\n\t\t\t    warrior.action == PVE_BATTLE &&\n\t\t        // And the battle time is over\n\t\t\t    warrior.cooldownEndBlock <= blockNumber\n\t\t\t);\n        }\n        // When the all checks done, calculate actual battle result\n        for(index = 0; index < length; index ++) {\n            _triggerPVEFinish(_warriorIds[index]);\n        }\n        \n        //not susceptible to reetrance attack because of require(warrior.action == PVE_BATTLE)\n        //and require(warrior.cooldownEndBlock <= uint64(block.number));\n        msg.sender.transfer(PVE_COMPENSATION * length);\n    }\n}\n\ncontract CryptoWarriorSanctuary is CryptoWarriorPVE {\n    \n    uint256 internal constant RARE = 3;\n    \n    function burnWarrior(uint256 _warriorId, address _owner) whenNotPaused external {\n        require(msg.sender == address(sanctuary));\n        \n        // Caller must own the warrior.\n        require(_ownerApproved(_owner, _warriorId));\n\n        // Grab a reference to the warrior in storage.\n        DataTypes.Warrior storage warrior = warriors[_warriorId];\n\n        // Check that the warrior exists.\n        require(warrior.identity != 0);\n\n        // Check that the warrior is ready to battle\n        require(warrior.action == IDLE);//is idle\n        \n        // Rarity of burned warrior must be less or equal RARE (3)\n        require(CryptoUtils.getRarityValue(warrior.identity) <= RARE);\n        // Warriors with MINER perc are not allowed to be berned\n        require(CryptoUtils.getSpecialityValue(warrior.identity) < MINER_PERK);\n        \n        _burn(_owner, _warriorId);\n    }\n    \n    function ariseWarrior(uint256 _identity, address _owner, uint256 _cooldown) whenNotPaused external returns(uint256){\n        require(msg.sender == address(sanctuary));\n        return _createWarrior(_identity, _owner, _cooldown, 10, 100, 0);\n    }\n    \n}\n\ncontract CryptoWarriorPVP is CryptoWarriorSanctuary {\n\t\n\tPVPInterface public battleProvider;\n\t\n\t/// @dev Sets the reference to the sale auction.\n    /// @param _address - Address of sale contract.\n    function setBattleProviderAddress(address _address) external onlyAdmin {\n        PVPInterface candidateContract = PVPInterface(_address);\n\n        // NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117\n        require(candidateContract.isPVPProvider());\n\n        // Set the new contract address\n        battleProvider = candidateContract;\n    }\n    \n    function _packPVPData(uint256 _warriorId, DataTypes.Warrior storage warrior) internal view returns(uint256){\n        return CryptoUtils._packWarriorPvpData(warrior.identity, uint256(warrior.rating), 0, _warriorId, warrior.level);\n    }\n    \n    function _triggerPVPSignUp(uint256 _warriorId, uint256 fee) internal {\n        DataTypes.Warrior storage warrior = warriors[_warriorId];\n    \t\t\n\t\tuint256 packedWarrior = _packPVPData(_warriorId, warrior);\n        \n        // addPVPContender will throw if fee fails.\n        battleProvider.addPVPContender.value(fee)(msg.sender, packedWarrior);\n        \n        warrior.action = uint16(PVP_BATTLE);\n    }\n    \n    /*\n     * @title signUpForPVP enqueues specified warrior to PVP\n     * \n     * @dev When the owner enqueues his warrior for PvP, the warrior enters the waiting room.\n     * Once every 15 minutes, we check the warriors in the room and select pairs. \n     * For those warriors to whom we found couples, fighting is conducted and the results \n     * are recorded in the profile of the warrior. \n     */\n    function signUpForPVP(uint256 _warriorId) public payable whenNotPaused {//done\n\t\t// Caller must own the warrior.\n        require(_ownerApproved(msg.sender, _warriorId));\n        // Grab a reference to the warrior in storage.\n        DataTypes.Warrior storage warrior = warriors[_warriorId];\n        // sanity check\n        require(warrior.identity != 0);\n\n        // Check that the warrior is ready to battle\n        require(warrior.action == IDLE);\n        \n        // Define the current price of the auction.\n        uint256 fee = battleProvider.getPVPEntranceFee(warrior.level);\n        \n        // Checks for payment.\n        require(msg.value >= fee);\n        \n        // All checks passed, put the warrior to the queue!\n        _triggerPVPSignUp(_warriorId, fee);\n        \n        // Calculate any excess funds included in msg.value. If the excess\n        // is anything worth worrying about, transfer it back to message owner.\n        // NOTE: We checked above that the msg.value is greater than or\n        // equal to the price so this cannot underflow.\n        uint256 feeExcess = msg.value - fee;\n\n        // Return the funds. This is not susceptible \n        // to a re-entry attack because of warrior.action == IDLE check\n        // will fail\n        msg.sender.transfer(feeExcess);\n    }\n\n    function _grandPVPWinnerReward(uint256 _warriorId) internal {\n        DataTypes.Warrior storage warrior = warriors[_warriorId];\n        // reward 1 level, add 10 level points\n        uint256 level = warrior.level;\n        if (level < (MAX_LEVEL * POINTS_TO_LEVEL)) {\n            level = level + POINTS_TO_LEVEL;\n\t\t\twarrior.level = uint64(level > (MAX_LEVEL * POINTS_TO_LEVEL) ? (MAX_LEVEL * POINTS_TO_LEVEL) : level);\n        }\n\t\t// give 100 rating for levelUp and 30 for win\n\t\twarrior.rating += 130;\n\t\t// mark warrior idle, so it can participate\n\t\t// in another actions\n\t\twarrior.action = uint16(IDLE);\n    }\n\n    function _grandPVPLoserReward(uint256 _warriorId) internal {\n        DataTypes.Warrior storage warrior = warriors[_warriorId];\n\t\t// reward 0.5 level\n\t\tuint256 oldLevel = warrior.level;\n\t\tuint256 level = oldLevel;\n\t\tif (level < (MAX_LEVEL * POINTS_TO_LEVEL)) {\n            level += (POINTS_TO_LEVEL / 2);\n\t\t\twarrior.level = uint64(level);\n        }\n\t\t// give 100 rating for levelUp if happens and -30 for lose\n\t\tint256 newRating = warrior.rating + (CryptoUtils._getLevel(level) > CryptoUtils._getLevel(oldLevel) ? int256(100 - 30) : int256(-30));\n\t\t// rating can't be less than 0 and more than 1000000000\n\t    warrior.rating = int64((newRating >= 0) ? (newRating > 1000000000 ? 1000000000 : newRating) : 0);\n        // mark warrior idle, so it can participate\n\t\t// in another actions\n\t    warrior.action = uint16(IDLE);\n    }\n    \n    function _grandPVPRewards(uint256[] memory warriorsData, uint256 matchingCount) internal {\n        for(uint256 id = 0; id < matchingCount; id += 2){\n            //\n            // winner, even ids are winners!\n            _grandPVPWinnerReward(CryptoUtils._unpackIdValue(warriorsData[id]));\n            //\n            // loser, they are odd...\n            _grandPVPLoserReward(CryptoUtils._unpackIdValue(warriorsData[id + 1]));\n        }\n\t}\n\n    // @dev Internal utility function to initiate pvp battle, assumes that all battle\n    ///  requirements have been checked.\n    function pvpFinished(uint256[] warriorsData, uint256 matchingCount) public {\n        //this method can be invoked only by battleProvider contract\n        require(msg.sender == address(battleProvider));\n        \n        _grandPVPRewards(warriorsData, matchingCount);\n    }\n    \n    function pvpContenderRemoved(uint256 _warriorId) public {\n        //this method can be invoked only by battleProvider contract\n        require(msg.sender == address(battleProvider));\n        //grab warrior storage reference\n        DataTypes.Warrior storage warrior = warriors[_warriorId];\n        //specified warrior must be in pvp state\n        require(warrior.action == PVP_BATTLE);\n        //all checks done\n        //set warrior state to IDLE\n        warrior.action = uint16(IDLE);\n    }\n}\n\ncontract CryptoWarriorTournament is CryptoWarriorPVP {\n    \n    uint256 internal constant GROUP_SIZE = 5;\n    \n    function _ownsAll(address _claimant, uint256[] memory _warriorIds) internal view returns (bool) {\n        uint256 length = _warriorIds.length;\n        for(uint256 i = 0; i < length; i++) {\n            if (!_ownerApproved(_claimant, _warriorIds[i])) return false;\n        }\n        return true;    \n    }\n    \n    function _isReadyToTournament(DataTypes.Warrior storage _warrior) internal view returns(bool){\n        return _warrior.level >= 50 && _warrior.action == IDLE;//must not participate in any action\n    }\n    \n    function _packTournamentData(uint256[] memory _warriorIds) internal view returns(uint256[] memory tournamentData) {\n        tournamentData = new uint256[](GROUP_SIZE);\n        uint256 warriorId;\n        for(uint256 i = 0; i < GROUP_SIZE; i++) {\n            warriorId = _warriorIds[i];\n            tournamentData[i] = _packPVPData(warriorId, warriors[warriorId]);   \n        }\n        return tournamentData;\n    }\n    \n    \n    // @dev Internal utility function to sign up to tournament, \n    // assumes that all battle requirements have been checked.\n    function _triggerTournamentSignUp(uint256[] memory _warriorIds, uint256 fee) internal {\n        //pack warrior ids into into uint256\n        uint256[] memory tournamentData = _packTournamentData(_warriorIds);\n        \n        for(uint256 i = 0; i < GROUP_SIZE; i++) {\n            // Set warrior current action to tournament battle\n            warriors[_warriorIds[i]].action = uint16(TOURNAMENT_BATTLE);\n        }\n\n        battleProvider.addTournamentContender.value(fee)(msg.sender, tournamentData);\n    }\n    \n    function signUpForTournament(uint256[] _warriorIds) public payable {\n        //\n        //check that there is enough funds to pay entrance fee\n        uint256 fee = battleProvider.getTournamentThresholdFee();\n        require(msg.value >= fee);\n        //\n        //check that warriors group is exactly of allowed size\n        require(_warriorIds.length == GROUP_SIZE);\n        //\n        //message sender must own all the specified warrior IDs\n        require(_ownsAll(msg.sender, _warriorIds));\n        //\n        //check all warriors are unique\n        require(areUnique(_warriorIds));\n        //\n        //check that all warriors are 25 lv and IDLE\n        for(uint256 i = 0; i < GROUP_SIZE; i ++) {\n            // Grab a reference to the warrior in storage.\n            require(_isReadyToTournament(warriors[_warriorIds[i]]));\n        }\n        \n        \n        //all checks passed, trigger sign up\n        _triggerTournamentSignUp(_warriorIds, fee);\n        \n        // Calculate any excess funds included in msg.value. If the excess\n        // is anything worth worrying about, transfer it back to message owner.\n        // NOTE: We checked above that the msg.value is greater than or\n        // equal to the fee so this cannot underflow.\n        uint256 feeExcess = msg.value - fee;\n\n        // Return the funds. This is not susceptible \n        // to a re-entry attack because of _isReadyToTournament check\n        // will fail\n        msg.sender.transfer(feeExcess);\n    }\n    \n    function _setIDLE(uint256 warriorIds) internal {\n        for(uint256 i = 0; i < GROUP_SIZE; i ++) {\n            warriors[CryptoUtils._unpackWarriorId(warriorIds, i)].action = uint16(IDLE);\n        }\n    }\n    \n    function _freeWarriors(uint256[] memory packedContenders) internal {\n        uint256 length = packedContenders.length;\n        for(uint256 i = 0; i < length; i ++) {\n            //set participants action to IDLE\n            _setIDLE(packedContenders[i]);\n        }\n    }\n    \n    function tournamentFinished(uint256[] packedContenders) public {\n        //this method can be invoked only by battleProvider contract\n        require(msg.sender == address(battleProvider));\n        \n        //grad rewards and set IDLE action\n        _freeWarriors(packedContenders);\n    }\n    \n}\n\ncontract CryptoWarriorAuction is CryptoWarriorTournament {\n\n    // @notice The auction contract variables are defined in CryptoWarriorBase to allow\n    //  us to refer to them in WarriorTokenImpl to prevent accidental transfers.\n    // `saleAuction` refers to the auction for miner and p2p sale of warriors.\n\n    /// @dev Sets the reference to the sale auction.\n    /// @param _address - Address of sale contract.\n    function setSaleAuctionAddress(address _address) external onlyAdmin {\n        SaleClockAuction candidateContract = SaleClockAuction(_address);\n\n        // NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117\n        require(candidateContract.isSaleClockAuction());\n\n        // Set the new contract address\n        saleAuction = candidateContract;\n    }\n\n\n    /// @dev Put a warrior up for auction.\n    ///  Does some ownership trickery to create auctions in one tx.\n    function createSaleAuction(\n        uint256 _warriorId,\n        uint256 _startingPrice,\n        uint256 _endingPrice,\n        uint256 _duration\n    )\n        external\n        whenNotPaused\n    {\n        // Auction contract checks input sizes\n        // If warrior is already on any auction, this will throw\n        // because it will be owned by the auction contract.\n        require(_ownerApproved(msg.sender, _warriorId));\n        // Ensure the warrior is not busy to prevent the auction\n        // contract creation while warrior is in any kind of battle (PVE, PVP, TOURNAMENT).\n        require(warriors[_warriorId].action == IDLE);\n        _approve(_warriorId, address(saleAuction));\n        // Sale auction throws if inputs are invalid and clears\n        // transfer approval after escrowing the warrior.\n        saleAuction.createAuction(\n            _warriorId,\n            _startingPrice,\n            _endingPrice,\n            _duration,\n            msg.sender\n        );\n    }\n\n}\n\ncontract CryptoWarriorIssuer is CryptoWarriorAuction {\n    \n    // Limits the number of warriors the contract owner can ever create\n    uint256 public constant MINER_CREATION_LIMIT = 2880;//issue every 15min for one month\n    // Constants for miner auctions.\n    uint256 public constant MINER_STARTING_PRICE = 100 finney;\n    uint256 public constant MINER_END_PRICE = 50 finney;\n    uint256 public constant MINER_AUCTION_DURATION = 1 days;\n\n    uint256 public minerCreatedCount;\n\n    /// @dev Generates a new miner warrior with MINER perk of COMMON rarity\n    ///  creates an auction for it.\n    function createMinerAuction() external onlyIssuer {\n        require(minerCreatedCount < MINER_CREATION_LIMIT);\n\t\t\n        minerCreatedCount++;\n\n        uint256 identity = sanctuary.generateWarrior(minerCreatedCount, 0, block.number - 1, MINER_PERK);\n        uint256 warriorId = _createWarrior(identity, bankAddress, 0, 10, 100, 0);\n        _approve(warriorId, address(saleAuction));\n\n        saleAuction.createAuction(\n            warriorId,\n            _computeNextMinerPrice(),\n            MINER_END_PRICE,\n            MINER_AUCTION_DURATION,\n            bankAddress\n        );\n    }\n\n    /// @dev Computes the next miner auction starting price, given\n    ///  the average of the past 5 prices * 2.\n    function _computeNextMinerPrice() internal view returns (uint256) {\n        uint256 avePrice = saleAuction.averageMinerSalePrice();\n\n        // Sanity check to ensure we don't overflow arithmetic\n        require(avePrice == uint256(uint128(avePrice)));\n\n        uint256 nextPrice = avePrice * 3 / 2;//confirmed\n\n        // We never auction for less than starting price\n        if (nextPrice < MINER_STARTING_PRICE) {\n            nextPrice = MINER_STARTING_PRICE;\n        }\n\n        return nextPrice;\n    }\n\n}\n\ncontract CoreRecovery is CryptoWarriorIssuer {\n    \n    bool public allowRecovery = true;\n    \n    //data model\n    //0 - identity\n    //1 - cooldownEndBlock\n    //2 - level\n    //3 - rating\n    //4 - index\n    function recoverWarriors(uint256[] recoveryData, address[] owners) external onlyAdmin whenPaused {\n        //check that recory action is allowed\n        require(allowRecovery);\n        \n        uint256 length = owners.length;\n        \n        //check that number of owners corresponds to recover data length\n        require(length == recoveryData.length / 5);\n        \n        for(uint256 i = 0; i < length; i++) {\n            _createWarrior(recoveryData[i * 5], owners[i], recoveryData[i * 5 + 1], \n                recoveryData[i * 5 + 2], recoveryData[i * 5 + 3], recoveryData[i * 5 + 4]);\n        }\n    }\n    \n    //recovery is a one time action, once it is done no more recovery actions allowed\n    function recoveryDone() external onlyAdmin {\n        allowRecovery = false;\n    }\n\n}\n\ncontract CryptoWarriorCore is CoreRecovery {\n\n    /// @notice Creates the main CryptoWarrior smart contract instance.\n    function CryptoWarriorCore() public {\n        // Starts paused.\n        paused = true;\n\n        // the creator of the contract is the initial Admin\n        adminAddress = msg.sender;\n\n        // the creator of the contract is also the initial COO\n        issuerAddress = msg.sender;\n        \n        // the creator of the contract is also the initial Bank\n        bankAddress = msg.sender;\n    }\n    \n    /// @notice No tipping!\n    /// @dev Reject all Ether from being sent here\n    /// (Hopefully, we can prevent user accidents.)\n    function() external payable {\n        require(false);\n    }\n    \n    /// @dev Override unpause so it requires all external contract addresses\n    ///  to be set before contract can be unpaused. Also, we can't have\n    ///  newContractAddress set either, because then the contract was upgraded.\n    /// @notice This is public rather than external so we can call super.unpause\n    ///  without using an expensive CALL.\n    function unpause() public onlyAdmin whenPaused {\n        require(address(saleAuction) != address(0));\n        require(address(sanctuary) != address(0));\n        require(address(battleProvider) != address(0));\n        require(newContractAddress == address(0));\n\n        // Actually unpause the contract.\n        super.unpause();\n    }\n    \n    function getBeneficiary() external view returns(address) {\n        return bankAddress;\n    }\n    \n    function isPVPListener() public pure returns (bool) {\n        return true;\n    }\n       \n    /**\n     *@param _warriorIds array of warriorIds, \n     * for those IDs warrior data will be packed into warriorsData array\n     *@return warriorsData packed warrior data\n     *@return stepSize number of fields in single warrior data */\n    function getWarriors(uint256[] _warriorIds) external view returns (uint256[] memory warriorsData, uint256 stepSize) {\n        stepSize = 6;\n        warriorsData = new uint256[](_warriorIds.length * stepSize);\n        for(uint256 i = 0; i < _warriorIds.length; i++) {\n            _setWarriorData(warriorsData, warriors[_warriorIds[i]], i * stepSize);\n        }\n    }\n    \n    /**\n     *@param indexFrom index in global warrior storage (aka warriorId), \n     * from this index(including), warriors data will be gathered\n     *@param count Number of warriors to include in packed data\n     *@return warriorsData packed warrior data\n     *@return stepSize number of fields in single warrior data */\n    function getWarriorsFromIndex(uint256 indexFrom, uint256 count) external view returns (uint256[] memory warriorsData, uint256 stepSize) {\n        stepSize = 6;\n        //check length\n        uint256 lenght = (warriors.length - indexFrom >= count ? count : warriors.length - indexFrom);\n        \n        warriorsData = new uint256[](lenght * stepSize);\n        for(uint256 i = 0; i < lenght; i ++) {\n            _setWarriorData(warriorsData, warriors[indexFrom + i], i * stepSize);\n        }\n    }\n    \n    function getWarriorOwners(uint256[] _warriorIds) external view returns (address[] memory owners) {\n        uint256 lenght = _warriorIds.length;\n        owners = new address[](lenght);\n        \n        for(uint256 i = 0; i < lenght; i ++) {\n            owners[i] = warriorToOwner[_warriorIds[i]];\n        }\n    }\n    \n    \n    function _setWarriorData(uint256[] memory warriorsData, DataTypes.Warrior storage warrior, uint256 id) internal view {\n        warriorsData[id] = uint256(warrior.identity);//0\n        warriorsData[id + 1] = uint256(warrior.cooldownEndBlock);//1\n        warriorsData[id + 2] = uint256(warrior.level);//2\n        warriorsData[id + 3] = uint256(warrior.rating);//3\n        warriorsData[id + 4] = uint256(warrior.action);//4\n        warriorsData[id + 5] = uint256(warrior.dungeonIndex);//5\n    }\n    \n\tfunction getWarrior(uint256 _id) external view returns \n    (\n        uint256 identity, \n        uint256 cooldownEndBlock, \n        uint256 level,\n        uint256 rating, \n        uint256 action,\n        uint256 dungeonIndex\n    ) {\n        DataTypes.Warrior storage warrior = warriors[_id];\n\n        identity = uint256(warrior.identity);\n        cooldownEndBlock = uint256(warrior.cooldownEndBlock);\n        level = uint256(warrior.level);\n\t\trating = uint256(warrior.rating);\n\t\taction = uint256(warrior.action);\n\t\tdungeonIndex = uint256(warrior.dungeonIndex);\n    }\n    \n}\n\n/*  @title Handles creating pvp battles every 15 min.*/\ncontract PVP is PausableBattle, PVPInterface {\n\t/* PVP BATLE */\n\t\n    /** list of packed warrior data that will participate in next PVP session. \n     *  Fixed size arry, to evade constant remove and push operations,\n     *  this approach reduces transaction costs involving queue modification. */\n    uint256[100] public pvpQueue;\n    //\n    //queue size\n    uint256 public pvpQueueSize = 0;\n    \n    // @dev A mapping from owner address to booty in WEI\n    //  booty is acquired in PVP and Tournament battles and can be\n    // withdrawn with grabBooty method by the owner of the loot\n    mapping (address => uint256) public ownerToBooty;\n    \n    // @dev A mapping from warrior id to owners address\n    mapping (uint256 => address) internal warriorToOwner;\n    \n    // An approximation of currently how many seconds are in between blocks.\n    uint256 internal secondsPerBlock = 15;\n    \n    // Cut owner takes from, measured in basis points (1/100 of a percent).\n    // Values 0-10,000 map to 0%-100%\n    uint256 public pvpOwnerCut;\n    \n    // Values 0-10,000 map to 0%-100%\n    //this % of the total bets will be sent as \n    //a reward to address, that triggered finishPVP method\n    uint256 public pvpMaxIncentiveCut;\n    \n    /// @notice The payment base required to use startPVP().\n    // pvpBattleFee * (warrior.level / POINTS_TO_LEVEL)\n    uint256 internal pvpBattleFee = 10 finney;\n    \n    uint256 public constant PVP_INTERVAL = 15 minutes;\n    \n    uint256 public nextPVPBatleBlock = 0;\n    //number of WEI in hands of warrior owners\n    uint256 public totalBooty = 0;\n    \n    /* TOURNAMENT */\n    uint256 public constant FUND_GATHERING_TIME = 24 hours;\n    uint256 public constant ADMISSION_TIME = 12 hours;\n    uint256 public constant RATING_EXPAND_INTERVAL = 1 hours;\n    uint256 internal constant SAFETY_GAP = 5;\n    \n    uint256 internal constant MAX_INCENTIVE_REWARD = 200 finney;\n    \n    //tournamentContenders size\n    uint256 public tournamentQueueSize = 0;\n    \n    // Values 0-10,000 map to 0%-100%\n    uint256 public tournamentBankCut;\n    \n   /** tournamentEndBlock, tournament is eligible to be finished only\n    *  after block.number >= tournamentEndBlock \n    *  it depends on FUND_GATHERING_TIME and ADMISSION_TIME */\n    uint256 public tournamentEndBlock;\n    \n    //number of WEI in tournament bank\n    uint256 public currentTournamentBank = 0;\n    uint256 public nextTournamentBank = 0;\n    \n    PVPListenerInterface internal pvpListener;\n    \n    /* EVENTS */\n    /** @dev TournamentScheduled event. Emitted every time a tournament is scheduled \n     *  @param tournamentEndBlock when block.number > tournamentEndBlock, then tournament \n     *         is eligible to be finished or rescheduled */\n    event TournamentScheduled(uint256 tournamentEndBlock);\n    \n    /** @dev PVPScheduled event. Emitted every time a tournament is scheduled \n     *  @param nextPVPBatleBlock when block.number > nextPVPBatleBlock, then pvp battle \n     *         is eligible to be finished or rescheduled */\n    event PVPScheduled(uint256 nextPVPBatleBlock);\n    \n    /** @dev PVPNewContender event. Emitted every time a warrior enqueues pvp battle\n     *  @param owner Warrior owner\n     *  @param warriorId Warrior ID that entered PVP queue\n     *  @param entranceFee fee in WEI warrior owner payed to enter PVP\n     */\n    event PVPNewContender(address owner, uint256 warriorId, uint256 entranceFee);\n\n    /** @dev PVPFinished event. Emitted every time a pvp battle is finished\n     *  @param warriorsData array of pairs of pvp warriors packed to uint256, even => winners, odd => losers \n     *  @param owners array of warrior owners, 1 to 1 with warriorsData, even => winners, odd => losers \n     *  @param matchingCount total number of warriors that fought in current pvp session and got rewards,\n     *  if matchingCount < participants.length then all IDs that are >= matchingCount will \n     *  remain in waiting room, until they are matched.\n     */\n    event PVPFinished(uint256[] warriorsData, address[] owners, uint256 matchingCount);\n    \n    /** @dev BootySendFailed event. Emitted every time address.send() function failed to transfer Ether to recipient\n     *  in this case recipient Ether is recorded to ownerToBooty mapping, so recipient can withdraw their booty manually\n     *  @param recipient address for whom send failed\n     *  @param amount number of WEI we failed to send\n     */\n    event BootySendFailed(address recipient, uint256 amount);\n    \n    /** @dev BootyGrabbed event\n     *  @param receiver address who grabbed his booty\n     *  @param amount number of WEI\n     */\n    event BootyGrabbed(address receiver, uint256 amount);\n    \n    /** @dev PVPContenderRemoved event. Emitted every time warrior is removed from pvp queue by its owner.\n     *  @param warriorId id of the removed warrior\n     */\n    event PVPContenderRemoved(uint256 warriorId, address owner);\n    \n    function PVP(uint256 _pvpCut, uint256 _tournamentBankCut, uint256 _pvpMaxIncentiveCut) public {\n        require((_tournamentBankCut + _pvpCut + _pvpMaxIncentiveCut) <= 10000);\n\t\tpvpOwnerCut = _pvpCut;\n\t\ttournamentBankCut = _tournamentBankCut;\n\t\tpvpMaxIncentiveCut = _pvpMaxIncentiveCut;\n    }\n    \n    /** @dev grabBooty sends to message sender his booty in WEI\n     */\n    function grabBooty() external {\n        uint256 booty = ownerToBooty[msg.sender];\n        require(booty > 0);\n        require(totalBooty >= booty);\n        \n        ownerToBooty[msg.sender] = 0;\n        totalBooty -= booty;\n        \n        msg.sender.transfer(booty);\n        //emit event\n        BootyGrabbed(msg.sender, booty);\n    }\n    \n    function safeSend(address _recipient, uint256 _amaunt) internal {\n\t\tuint256 failedBooty = sendBooty(_recipient, _amaunt);\n        if (failedBooty > 0) {\n\t\t\ttotalBooty += failedBooty;\n        }\n    }\n    \n    function sendBooty(address _recipient, uint256 _amaunt) internal returns(uint256) {\n        bool success = _recipient.send(_amaunt);\n        if (!success && _amaunt > 0) {\n            ownerToBooty[_recipient] += _amaunt;\n            BootySendFailed(_recipient, _amaunt);\n            return _amaunt;\n        }\n        return 0;\n    }\n    \n    //@returns block number, after this block tournament is opened for admission\n    function getTournamentAdmissionBlock() public view returns(uint256) {\n        uint256 admissionInterval = (ADMISSION_TIME / secondsPerBlock);\n        return tournamentEndBlock < admissionInterval ? 0 : tournamentEndBlock - admissionInterval;\n    }\n    \n    \n    //schedules next turnament time(block)\n    function _scheduleTournament() internal {\n        //we can chedule only if there is nobody in tournament queue and\n        //time of tournament battle have passed\n\t\tif (tournamentQueueSize == 0 && tournamentEndBlock <= block.number) {\n\t\t    tournamentEndBlock = ((FUND_GATHERING_TIME / 2 + ADMISSION_TIME) / secondsPerBlock) + block.number;\n\t\t    TournamentScheduled(tournamentEndBlock);\n\t\t}\n    }\n    \n    /// @dev Updates the minimum payment required for calling startPVP(). Can only\n    ///  be called by the COO address, and only if pvp queue is empty.\n    function setPVPEntranceFee(uint256 value) external onlyOwner {\n        require(pvpQueueSize == 0);\n        pvpBattleFee = value;\n    }\n    \n    //@returns PVP entrance fee for specified warrior level \n    //@param _levelPoints NB!\n    function getPVPEntranceFee(uint256 _levelPoints) external view returns(uint256) {\n        return pvpBattleFee * CryptoUtils._getLevel(_levelPoints);\n    }\n    \n    //level can only be > 0 and <= 25\n    function _getPVPFeeByLevel(uint256 _level) internal view returns(uint256) {\n        return pvpBattleFee * _level;\n    }\n    \n\t// @dev Computes warrior pvp reward\n    // @param _totalBet - total bet from both competitors.\n    function _computePVPReward(uint256 _totalBet, uint256 _contendersCut) internal pure returns (uint256){\n        // NOTE: We don't use SafeMath (or similar) in this function because\n        // _totalBet max value is 1000 finney, and _contendersCut aka\n        // (10000 - pvpOwnerCut - tournamentBankCut - incentiveRewardCut) <= 10000 (see the require()\n        // statement in the BattleProvider constructor). The result of this\n        // function is always guaranteed to be <= _totalBet.\n        return _totalBet * _contendersCut / 10000;\n    }\n    \n    function _getPVPContendersCut(uint256 _incentiveCut) internal view returns (uint256) {\n        // NOTE: We don't use SafeMath (or similar) in this function because\n        // (pvpOwnerCut + tournamentBankCut + pvpMaxIncentiveCut) <= 10000 (see the require()\n        // statement in the BattleProvider constructor). \n        // _incentiveCut is guaranteed to be >= 1 and <=  pvpMaxIncentiveCut\n        return (10000 - pvpOwnerCut - tournamentBankCut - _incentiveCut);\n    }\n\t\n\t// @dev Computes warrior pvp reward\n    // @param _totalSessionLoot - total bets from all competitors.\n    function _computeIncentiveReward(uint256 _totalSessionLoot, uint256 _incentiveCut) internal pure returns (uint256){\n        // NOTE: We don't use SafeMath (or similar) in this function because\n        // _totalSessionLoot max value is 37500 finney, and \n        // (pvpOwnerCut + tournamentBankCut + incentiveRewardCut) <= 10000 (see the require()\n        // statement in the BattleProvider constructor). The result of this\n        // function is always guaranteed to be <= _totalSessionLoot.\n        return _totalSessionLoot * _incentiveCut / 10000;\n    }\n    \n\t///@dev computes incentive cut for specified loot, \n\t/// Values 0-10,000 map to 0%-100%\n\t/// max incentive reward cut is 5%, if it exceeds MAX_INCENTIVE_REWARD,\n\t/// then cut is lowered to be equal to MAX_INCENTIVE_REWARD.\n\t/// minimum cut is 0.01%\n    /// this % of the total bets will be sent as \n    /// a reward to address, that triggered finishPVP method\n    function _computeIncentiveCut(uint256 _totalSessionLoot, uint256 maxIncentiveCut) internal pure returns(uint256) {\n        uint256 result = _totalSessionLoot * maxIncentiveCut / 10000;\n        result = result <= MAX_INCENTIVE_REWARD ? maxIncentiveCut : MAX_INCENTIVE_REWARD * 10000 / _totalSessionLoot;\n        //min cut is 0.01%\n        return result > 0 ? result : 1;\n    }\n    \n    // @dev Computes warrior pvp reward\n    // @param _totalSessionLoot - total bets from all competitors.\n    function _computePVPBeneficiaryFee(uint256 _totalSessionLoot) internal view returns (uint256){\n        // NOTE: We don't use SafeMath (or similar) in this function because\n        // _totalSessionLoot max value is 37500 finney, and \n        // (pvpOwnerCut + tournamentBankCut + incentiveRewardCut) <= 10000 (see the require()\n        // statement in the BattleProvider constructor). The result of this\n        // function is always guaranteed to be <= _totalSessionLoot.\n        return _totalSessionLoot * pvpOwnerCut / 10000;\n    }\n    \n    // @dev Computes tournament bank cut\n    // @param _totalSessionLoot - total session loot.\n    function _computeTournamentCut(uint256 _totalSessionLoot) internal view returns (uint256){\n        // NOTE: We don't use SafeMath (or similar) in this function because\n        // _totalSessionLoot max value is 37500 finney, and \n        // (pvpOwnerCut + tournamentBankCut + incentiveRewardCut) <= 10000 (see the require()\n        // statement in the BattleProvider constructor). The result of this\n        // function is always guaranteed to be <= _totalSessionLoot.\n        return _totalSessionLoot * tournamentBankCut / 10000;\n    }\n\n    function indexOf(uint256 _warriorId) internal view returns(int256) {\n\t    uint256 length = uint256(pvpQueueSize);\n\t    for(uint256 i = 0; i < length; i ++) {\n\t        if(CryptoUtils._unpackIdValue(pvpQueue[i]) == _warriorId) return int256(i);\n\t    }\n\t    return -1;\n\t}\n    \n    function getPVPIncentiveReward(uint256[] memory matchingIds, uint256 matchingCount) internal view returns(uint256) {\n        uint256 sessionLoot = _computeTotalBooty(matchingIds, matchingCount);\n        \n        return _computeIncentiveReward(sessionLoot, _computeIncentiveCut(sessionLoot, pvpMaxIncentiveCut));\n    }\n    \n    function maxPVPContenders() external view returns(uint256){\n        return pvpQueue.length;\n    }\n    \n    function getPVPState() external view returns\n    (uint256 contendersCount, uint256 matchingCount, uint256 endBlock, uint256 incentiveReward)\n    {\n        uint256[] memory pvpData = _packPVPData();\n        \n    \tcontendersCount = pvpQueueSize;\n    \tmatchingCount = CryptoUtils._getMatchingIds(pvpData, PVP_INTERVAL, _computeCycleSkip(), RATING_EXPAND_INTERVAL);\n    \tendBlock = nextPVPBatleBlock;   \n    \tincentiveReward = getPVPIncentiveReward(pvpData, matchingCount);\n    }\n    \n    function canFinishPVP() external view returns(bool) {\n        return nextPVPBatleBlock <= block.number &&\n         CryptoUtils._getMatchingIds(_packPVPData(), PVP_INTERVAL, _computeCycleSkip(), RATING_EXPAND_INTERVAL) > 1;\n    }\n    \n    function _clarifyPVPSchedule() internal {\n        uint256 length = pvpQueueSize;\n\t\tuint256 currentBlock = block.number;\n\t\tuint256 nextBattleBlock = nextPVPBatleBlock;\n\t\t//if battle not scheduled, schedule battle\n\t\tif (nextBattleBlock <= currentBlock) {\n\t\t    //if queue not empty update cycles\n\t\t    if (length > 0) {\n\t\t\t\tuint256 packedWarrior;\n\t\t\t\tuint256 cycleSkip = _computeCycleSkip();\n\t\t        for(uint256 i = 0; i < length; i++) {\n\t\t            packedWarrior = pvpQueue[i];\n\t\t            //increase warrior iteration cycle\n\t\t            pvpQueue[i] = CryptoUtils._changeCycleValue(packedWarrior, CryptoUtils._unpackCycleValue(packedWarrior) + cycleSkip);\n\t\t        }\n\t\t    }\n\t\t    nextBattleBlock = (PVP_INTERVAL / secondsPerBlock) + currentBlock;\n\t\t    nextPVPBatleBlock = nextBattleBlock;\n\t\t    PVPScheduled(nextBattleBlock);\n\t\t//if pvp queue will be full and there is still too much time left, then let the battle begin! \n\t\t} else if (length + 1 == pvpQueue.length && (currentBlock + SAFETY_GAP * 2) < nextBattleBlock) {\n\t\t    nextBattleBlock = currentBlock + SAFETY_GAP;\n\t\t    nextPVPBatleBlock = nextBattleBlock;\n\t\t    PVPScheduled(nextBattleBlock);\n\t\t}\n    }\n    \n    /// @dev Internal utility function to initiate pvp battle, assumes that all battle\n    ///  requirements have been checked.\n    function _triggerNewPVPContender(address _owner, uint256 _packedWarrior, uint256 fee) internal {\n\n\t\t_clarifyPVPSchedule();\n        //number of pvp cycles the warrior is waiting for suitable enemy match\n        //increment every time when finishPVP is called and no suitable enemy match was found\n        _packedWarrior = CryptoUtils._changeCycleValue(_packedWarrior, 0);\n\t\t\n\t\t//record contender data\n\t\tpvpQueue[pvpQueueSize++] = _packedWarrior;\n\t\twarriorToOwner[CryptoUtils._unpackIdValue(_packedWarrior)] = _owner;\n\t\t\n\t\t//Emit event\n\t\tPVPNewContender(_owner, CryptoUtils._unpackIdValue(_packedWarrior), fee);\n    }\n    \n    function _noMatchingPairs() internal view returns(bool) {\n        uint256 matchingCount = CryptoUtils._getMatchingIds(_packPVPData(), uint64(PVP_INTERVAL), _computeCycleSkip(), uint64(RATING_EXPAND_INTERVAL));\n        return matchingCount == 0;\n    }\n    \n    /*\n     * @title startPVP enqueues specified warrior to PVP\n     * \n     * @dev When the owner enqueues his warrior for PvP, the warrior enters the waiting room.\n     * Once every 15 minutes, we check the warriors in the room and select pairs. \n     * For those warriors to whom we found couples, fighting is conducted and the results \n     * are recorded in the profile of the warrior. \n     */\n    function addPVPContender(address _owner, uint256 _packedWarrior) external payable PVPNotPaused {\n\t\t// Caller must be pvpListener contract\n        require(msg.sender == address(pvpListener));\n\n        require(_owner != address(0));\n        //contender can be added only while PVP is scheduled in future\n        //or no matching warrior pairs found\n        require(nextPVPBatleBlock > block.number || _noMatchingPairs());\n        // Check that the warrior exists.\n        require(_packedWarrior != 0);\n        //owner must withdraw all loot before contending pvp\n        require(ownerToBooty[_owner] == 0);\n        //check that there is enough room for new participants\n        require(pvpQueueSize < pvpQueue.length);\n        // Checks for payment.\n        uint256 fee = _getPVPFeeByLevel(CryptoUtils._unpackLevelValue(_packedWarrior));\n        require(msg.value >= fee);\n        //\n        // All checks passed, put the warrior to the queue!\n        _triggerNewPVPContender(_owner, _packedWarrior, fee);\n    }\n    \n    function _packPVPData() internal view returns(uint256[] memory matchingIds) {\n        uint256 length = pvpQueueSize;\n        matchingIds = new uint256[](length);\n        for(uint256 i = 0; i < length; i++) {\n            matchingIds[i] = pvpQueue[i];\n        }\n        return matchingIds;\n    }\n    \n    function _computeTotalBooty(uint256[] memory _packedWarriors, uint256 matchingCount) internal view returns(uint256) {\n        //compute session booty\n        uint256 sessionLoot = 0;\n        for(uint256 i = 0; i < matchingCount; i++) {\n            sessionLoot += _getPVPFeeByLevel(CryptoUtils._unpackLevelValue(_packedWarriors[i]));\n        }\n        return sessionLoot;\n    }\n    \n    function _grandPVPRewards(uint256[] memory _packedWarriors, uint256 matchingCount) \n    internal returns(uint256)\n    {\n        uint256 booty = 0;\n        uint256 packedWarrior;\n        uint256 failedBooty = 0;\n        \n        uint256 sessionBooty = _computeTotalBooty(_packedWarriors, matchingCount);\n        uint256 incentiveCut = _computeIncentiveCut(sessionBooty, pvpMaxIncentiveCut);\n        uint256 contendersCut = _getPVPContendersCut(incentiveCut);\n        \n        for(uint256 id = 0; id < matchingCount; id++) {\n            //give reward to warriors that fought hard\n\t\t\t//winner, even ids are winners!\n\t\t\tpackedWarrior = _packedWarriors[id];\n\t\t\t//\n\t\t\t//give winner deserved booty 80% from both bets\n\t\t\t//must be computed before level reward!\n\t\t\tbooty = _getPVPFeeByLevel(CryptoUtils._unpackLevelValue(packedWarrior)) + \n\t\t\t\t_getPVPFeeByLevel(CryptoUtils._unpackLevelValue(_packedWarriors[id + 1]));\n\t\t\t\n\t\t\t//\n\t\t\t//send reward to warrior owner\n\t\t\tfailedBooty += sendBooty(warriorToOwner[CryptoUtils._unpackIdValue(packedWarrior)], _computePVPReward(booty, contendersCut));\n\t\t\t//loser, they are odd...\n\t\t\t//skip them, as they deserve none!\n\t\t\tid ++;\n        }\n        failedBooty += sendBooty(pvpListener.getBeneficiary(), _computePVPBeneficiaryFee(sessionBooty));\n        \n        if (failedBooty > 0) {\n            totalBooty += failedBooty;\n        }\n        //if tournament admission start time not passed\n        //add tournament cut to current tournament bank,\n        //otherwise to next tournament bank\n        if (getTournamentAdmissionBlock() > block.number) {\n            currentTournamentBank += _computeTournamentCut(sessionBooty);\n        } else {\n            nextTournamentBank += _computeTournamentCut(sessionBooty);\n        }\n        \n        //compute incentive reward\n        return _computeIncentiveReward(sessionBooty, incentiveCut);\n    }\n    \n    function _increaseCycleAndTrimQueue(uint256[] memory matchingIds, uint256 matchingCount) internal {\n        uint32 length = uint32(matchingIds.length - matchingCount);  \n\t\tuint256 packedWarrior;\n\t\tuint256 skipCycles = _computeCycleSkip();\n        for(uint256 i = 0; i < length; i++) {\n            packedWarrior = matchingIds[matchingCount + i];\n            //increase warrior iteration cycle\n            pvpQueue[i] = CryptoUtils._changeCycleValue(packedWarrior, CryptoUtils._unpackCycleValue(packedWarrior) + skipCycles);\n        }\n        //trim queue\t\n        pvpQueueSize = length;\n    }\n    \n    function _computeCycleSkip() internal view returns(uint256) {\n        uint256 number = block.number;\n        return nextPVPBatleBlock > number ? 0 : (number - nextPVPBatleBlock) * secondsPerBlock / PVP_INTERVAL + 1;\n    }\n    \n    function _getWarriorOwners(uint256[] memory pvpData) internal view returns (address[] memory owners){\n        uint256 length = pvpData.length;\n        owners = new address[](length);\n        for(uint256 i = 0; i < length; i ++) {\n            owners[i] = warriorToOwner[CryptoUtils._unpackIdValue(pvpData[i])];\n        }\n    }\n    \n    // @dev Internal utility function to initiate pvp battle, assumes that all battle\n    ///  requirements have been checked.\n    function _triggerPVPFinish(uint256[] memory pvpData, uint256 matchingCount) internal returns(uint256){\n        //\n\t\t//compute battle results        \n        CryptoUtils._getPVPBattleResults(pvpData, matchingCount, nextPVPBatleBlock);\n        //\n        //mark not fought warriors and trim queue \n        _increaseCycleAndTrimQueue(pvpData, matchingCount);\n        //\n        //schedule next battle time\n        nextPVPBatleBlock = (PVP_INTERVAL / secondsPerBlock) + block.number;\n        \n        //\n        //schedule tournament\n        //if contendersCount is 0 and tournament not scheduled, schedule tournament\n        //NB MUST be before _grandPVPRewards()\n        _scheduleTournament();\n        // compute and grand rewards to warriors,\n        // put tournament cut to bank, not susceptible to reentry attack because of require(nextPVPBatleBlock <= block.number);\n        // and require(number of pairs > 1);\n        uint256 incentiveReward = _grandPVPRewards(pvpData, matchingCount);\n        //\n        //notify pvp listener contract\n        pvpListener.pvpFinished(pvpData, matchingCount);\n        \n        //\n        //fire event\n\t\tPVPFinished(pvpData, _getWarriorOwners(pvpData), matchingCount);\n        PVPScheduled(nextPVPBatleBlock);\n\t\t\n\t\treturn incentiveReward;\n    }\n    \n    \n    /**\n     * @dev finishPVP this method finds matches of warrior pairs\n     * in waiting room and computes result of their fights.\n     * \n     * The winner gets +1 level, the loser gets +0.5 level\n     * The winning player gets +130 rating\n\t * The losing player gets -30 or 70 rating (if warrior levelUps after battle) .\n     * can be called once in 15min.\n     * NB If the warrior is not picked up in an hour, then we expand the range \n     * of selection by 25 rating each hour.\n     */\n    function finishPVP() public PVPNotPaused {\n        // battle interval is over\n        require(nextPVPBatleBlock <= block.number);\n        //\n\t    //match warriors\n        uint256[] memory pvpData = _packPVPData();\n        //match ids and sort them according to matching\n        uint256 matchingCount = CryptoUtils._getMatchingIds(pvpData, uint64(PVP_INTERVAL), _computeCycleSkip(), uint64(RATING_EXPAND_INTERVAL));\n\t\t// we have at least 1 matching battle pair\n        require(matchingCount > 1);\n        \n        // When the all checks done, calculate actual battle result\n        uint256 incentiveReward = _triggerPVPFinish(pvpData, matchingCount);\n        \n        //give reward for incentive\n        safeSend(msg.sender, incentiveReward);\n    }\n\n    // @dev Removes specified warrior from PVP queue\n    //  sets warrior free (IDLE) and returns pvp entrance fee to owner\n    // @notice This is a state-modifying function that can\n    //  be called while the contract is paused.\n    // @param _warriorId - ID of warrior in PVP queue\n    function removePVPContender(uint256 _warriorId) external{\n        uint256 queueSize = pvpQueueSize;\n        require(queueSize > 0);\n        // Caller must be owner of the specified warrior\n        require(warriorToOwner[_warriorId] == msg.sender);\n        //warrior must be in pvp queue\n        int256 warriorIndex = indexOf(_warriorId);\n        require(warriorIndex >= 0);\n        //grab warrior data\n        uint256 warriorData = pvpQueue[uint32(warriorIndex)];\n        //warrior cycle must be >= 4 (> than 1 hour)\n        require((CryptoUtils._unpackCycleValue(warriorData) + _computeCycleSkip()) >= 4);\n        \n        //remove from queue\n        if (uint256(warriorIndex) < queueSize - 1) {\n\t        pvpQueue[uint32(warriorIndex)] = pvpQueue[pvpQueueSize - 1];\n        }\n        pvpQueueSize --;\n        //notify battle listener\n        pvpListener.pvpContenderRemoved(_warriorId);\n        //return pvp bet\n        msg.sender.transfer(_getPVPFeeByLevel(CryptoUtils._unpackLevelValue(warriorData)));\n        //Emit event\n        PVPContenderRemoved(_warriorId, msg.sender);\n    }\n    \n    function getPVPCycles(uint32[] warriorIds) external view returns(uint32[]){\n        uint256 length = warriorIds.length;\n        uint32[] memory cycles = new uint32[](length);\n        int256 index;\n        uint256 skipCycles = _computeCycleSkip();\n\t    for(uint256 i = 0; i < length; i ++) {\n\t        index = indexOf(warriorIds[i]);\n\t        cycles[i] = index >= 0 ? uint32(CryptoUtils._unpackCycleValue(pvpQueue[uint32(index)]) + skipCycles) : 0;\n\t    }\n\t    return cycles;\n    }\n    \n    // @dev Remove all PVP contenders from PVP queue \n    //  and return all bets to warrior owners.\n    //  NB: this is emergency method, used only in f%#^@up situation\n    function removeAllPVPContenders() external onlyOwner PVPPaused {\n        //remove all pvp contenders\n        uint256 length = pvpQueueSize;\n        \n        uint256 warriorData;\n        uint256 warriorId;\n        uint256 failedBooty;\n        address owner;\n        \n        pvpQueueSize = 0;\n        \n        for(uint256 i = 0; i < length; i++) {\n\t        //grab warrior data\n\t        warriorData = pvpQueue[i];\n\t        warriorId = CryptoUtils._unpackIdValue(warriorData);\n\t        //notify battle listener\n\t        pvpListener.pvpContenderRemoved(uint32(warriorId));\n\t        \n\t        owner = warriorToOwner[warriorId];\n\t        //return pvp bet\n\t        failedBooty += sendBooty(owner, _getPVPFeeByLevel(CryptoUtils._unpackLevelValue(warriorData)));\n        }\n        totalBooty += failedBooty;\n    }\n}\n\n\ncontract Tournament is PVP {\n\n    uint256 internal constant GROUP_SIZE = 5;\n    uint256 internal constant DATA_SIZE = 2;\n    uint256 internal constant THRESHOLD = 300;\n    \n  /** list of warrior IDs that will participate in next tournament. \n    *  Fixed size arry, to evade constant remove and push operations,\n    *  this approach reduces transaction costs involving array modification. */\n    uint256[160] public tournamentQueue;\n    \n    /**The cost of participation in the tournament is 1% of its current prize fund, \n     * money is added to the prize fund. measured in basis points (1/100 of a percent).\n     * Values 0-10,000 map to 0%-100% */\n    uint256 internal tournamentEntranceFeeCut = 100;\n    \n    // Values 0-10,000 map to 0%-100% => 20%\n    uint256 public tournamentOwnersCut;\n    uint256 public tournamentIncentiveCut;\n    \n     /** @dev TournamentNewContender event. Emitted every time a warrior enters tournament\n     *  @param owner Warrior owner\n     *  @param warriorIds 5 Warrior IDs that entered tournament, packed into one uint256\n     *  see CryptoUtils._packWarriorIds\n     */\n    event TournamentNewContender(address owner, uint256 warriorIds, uint256 entranceFee);\n    \n    /** @dev TournamentFinished event. Emitted every time a tournament is finished\n     *  @param owners array of warrior group owners packed to uint256\n     *  @param results number of wins for each group\n     *  @param tournamentBank current tournament bank\n     *  see CryptoUtils._packWarriorIds\n     */\n    event TournamentFinished(uint256[] owners, uint32[] results, uint256 tournamentBank);\n    \n    function Tournament(uint256 _pvpCut, uint256 _tournamentBankCut, \n    uint256 _pvpMaxIncentiveCut, uint256 _tournamentOwnersCut, uint256 _tournamentIncentiveCut) public\n    PVP(_pvpCut, _tournamentBankCut, _pvpMaxIncentiveCut) \n    {\n        require((_tournamentOwnersCut + _tournamentIncentiveCut) <= 10000);\n\t\t\n\t\ttournamentOwnersCut = _tournamentOwnersCut;\n\t\ttournamentIncentiveCut = _tournamentIncentiveCut;\n    }\n    \n    \n    \n    // @dev Computes incentive reward for launching tournament finishTournament()\n    // @param _tournamentBank\n    function _computeTournamentIncentiveReward(uint256 _currentBank, uint256 _incentiveCut) internal pure returns (uint256){\n        // NOTE: We don't use SafeMath (or similar) in this function because _currentBank max is equal ~ 20000000 finney,\n        // and (tournamentOwnersCut + tournamentIncentiveCut) <= 10000 (see the require()\n        // statement in the Tournament constructor). The result of this\n        // function is always guaranteed to be <= _currentBank.\n        return _currentBank * _incentiveCut / 10000;\n    }\n    \n    function _computeTournamentContenderCut(uint256 _incentiveCut) internal view returns (uint256) {\n        // NOTE: (tournamentOwnersCut + tournamentIncentiveCut) <= 10000 (see the require()\n        // statement in the Tournament constructor). The result of this\n        // function is always guaranteed to be <= _reward.\n        return 10000 - tournamentOwnersCut - _incentiveCut;\n    }\n    \n    function _computeTournamentBeneficiaryFee(uint256 _currentBank) internal view returns (uint256){\n        // NOTE: We don't use SafeMath (or similar) in this function because _currentBank max is equal ~ 20000000 finney,\n        // and (tournamentOwnersCut + tournamentIncentiveCut) <= 10000 (see the require()\n        // statement in the Tournament constructor). The result of this\n        // function is always guaranteed to be <= _currentBank.\n        return _currentBank * tournamentOwnersCut / 10000;\n    }\n    \n    // @dev set tournament entrance fee cut, can be set only if\n    // tournament queue is empty\n    // @param _cut range from 0 - 10000, mapped to 0-100%\n    function setTournamentEntranceFeeCut(uint256 _cut) external onlyOwner {\n        //cut must be less or equal 100&\n        require(_cut <= 10000);\n        //tournament queue must be empty\n        require(tournamentQueueSize == 0);\n        //checks passed, set cut\n\t\ttournamentEntranceFeeCut = _cut;\n    }\n    \n    function getTournamentEntranceFee() external view returns(uint256) {\n        return currentTournamentBank * tournamentEntranceFeeCut / 10000;\n    }\n    \n    //@dev returns tournament entrance fee - 3% threshold\n    function getTournamentThresholdFee() public view returns(uint256) {\n        return currentTournamentBank * tournamentEntranceFeeCut * (10000 - THRESHOLD) / 10000 / 10000;\n    }\n    \n    //@dev returns max allowed tournament contenders, public because of internal use\n    function maxTournamentContenders() public view returns(uint256){\n        return tournamentQueue.length / DATA_SIZE;\n    }\n    \n    function canFinishTournament() external view returns(bool) {\n        return tournamentEndBlock <= block.number && tournamentQueueSize > 0;\n    }\n    \n    // @dev Internal utility function to sigin up to tournament, \n    // assumes that all battle requirements have been checked.\n    function _triggerNewTournamentContender(address _owner, uint256[] memory _tournamentData, uint256 _fee) internal {\n        //pack warrior ids into uint256\n        \n        currentTournamentBank += _fee;\n        \n        uint256 packedWarriorIds = CryptoUtils._packWarriorIds(_tournamentData);\n        //make composite warrior out of 5 warriors \n        uint256 combinedWarrior = CryptoUtils._combineWarriors(_tournamentData);\n        \n        //add to queue\n        //icrement tournament queue\n        uint256 size = tournamentQueueSize++ * DATA_SIZE;\n        //record tournament data\n\t\ttournamentQueue[size++] = packedWarriorIds;\n\t\ttournamentQueue[size++] = combinedWarrior;\n\t\twarriorToOwner[CryptoUtils._unpackWarriorId(packedWarriorIds, 0)] = _owner;\n\t\t//\n\t\t//Emit event\n\t\tTournamentNewContender(_owner, packedWarriorIds, _fee);\n    }\n    \n    function addTournamentContender(address _owner, uint256[] _tournamentData) external payable TournamentNotPaused{\n        // Caller must be pvpListener contract\n        require(msg.sender == address(pvpListener));\n        \n        require(_owner != address(0));\n        //\n        //check current tournament bank > 0\n        require(pvpBattleFee == 0 || currentTournamentBank > 0);\n        //\n        //check that there is enough funds to pay entrance fee\n        uint256 fee = getTournamentThresholdFee();\n        require(msg.value >= fee);\n        //owner must withdraw all booty before contending pvp\n        require(ownerToBooty[_owner] == 0);\n        //\n        //check that warriors group is exactly of allowed size\n        require(_tournamentData.length == GROUP_SIZE);\n        //\n        //check that there is enough room for new participants\n        require(tournamentQueueSize < maxTournamentContenders());\n        //\n        //check that admission started\n        require(block.number >= getTournamentAdmissionBlock());\n        //check that admission not ended\n        require(block.number <= tournamentEndBlock);\n        \n        //all checks passed, trigger sign up\n        _triggerNewTournamentContender(_owner, _tournamentData, fee);\n    }\n    \n    //@dev collect all combined warriors data\n    function getCombinedWarriors() internal view returns(uint256[] memory warriorsData) {\n        uint256 length = tournamentQueueSize;\n        warriorsData = new uint256[](length);\n        \n        for(uint256 i = 0; i < length; i ++) {\n            // Grab the combined warrior data in storage.\n            warriorsData[i] = tournamentQueue[i * DATA_SIZE + 1];\n        }\n        return warriorsData;\n    }\n    \n    function getTournamentState() external view returns\n    (uint256 contendersCount, uint256 bank, uint256 admissionStartBlock, uint256 endBlock, uint256 incentiveReward)\n    {\n    \tcontendersCount = tournamentQueueSize;\n    \tbank = currentTournamentBank;\n    \tadmissionStartBlock = getTournamentAdmissionBlock();   \n    \tendBlock = tournamentEndBlock;\n    \tincentiveReward = _computeTournamentIncentiveReward(bank, _computeIncentiveCut(bank, tournamentIncentiveCut));\n    }\n    \n    function _repackToCombinedIds(uint256[] memory _warriorsData) internal view {\n        uint256 length = _warriorsData.length;\n        for(uint256 i = 0; i < length; i ++) {\n            _warriorsData[i] = tournamentQueue[i * DATA_SIZE];\n        }\n    }\n    \n    // @dev Computes warrior pvp reward\n    // @param _totalBet - total bet from both competitors.\n    function _computeTournamentBooty(uint256 _currentBank, uint256 _contenderResult, uint256 _totalBattles) internal pure returns (uint256){\n        // NOTE: We don't use SafeMath (or similar) in this function because _currentBank max is equal ~ 20000000 finney,\n        // _totalBattles is guaranteed to be > 0 and <= 400, and (tournamentOwnersCut + tournamentIncentiveCut) <= 10000 (see the require()\n        // statement in the Tournament constructor). The result of this\n        // function is always guaranteed to be <= _reward.\n        // return _currentBank * (10000 - tournamentOwnersCut - _incentiveCut) * _result / 10000 / _totalBattles;\n        return _currentBank * _contenderResult / _totalBattles;\n        \n    }\n    \n    function _grandTournamentBooty(uint256 _warriorIds, uint256 _currentBank, uint256 _contenderResult, uint256 _totalBattles)\n    internal returns (uint256)\n    {\n        uint256 warriorId = CryptoUtils._unpackWarriorId(_warriorIds, 0);\n        address owner = warriorToOwner[warriorId];\n        uint256 booty = _computeTournamentBooty(_currentBank, _contenderResult, _totalBattles);\n        return sendBooty(owner, booty);\n    }\n    \n    function _grandTournamentRewards(uint256 _currentBank, uint256[] memory _warriorsData, uint32[] memory _results) internal returns (uint256){\n        uint256 length = _warriorsData.length;\n        uint256 totalBattles = CryptoUtils._getTournamentBattles(length) * 10000;//*10000 required for booty computation\n        uint256 incentiveCut = _computeIncentiveCut(_currentBank, tournamentIncentiveCut);\n        uint256 contenderCut = _computeTournamentContenderCut(incentiveCut);\n        \n        uint256 failedBooty = 0;\n        for(uint256 i = 0; i < length; i ++) {\n            //grand rewards\n            failedBooty += _grandTournamentBooty(_warriorsData[i], _currentBank, _results[i] * contenderCut, totalBattles);\n        }\n        //send beneficiary fee\n        failedBooty += sendBooty(pvpListener.getBeneficiary(), _computeTournamentBeneficiaryFee(_currentBank));\n        if (failedBooty > 0) {\n            totalBooty += failedBooty;\n        }\n        return _computeTournamentIncentiveReward(_currentBank, incentiveCut);\n    }\n    \n    function _repackToWarriorOwners(uint256[] memory warriorsData) internal view {\n        uint256 length = warriorsData.length;\n        for (uint256 i = 0; i < length; i ++) {\n            warriorsData[i] = uint256(warriorToOwner[CryptoUtils._unpackWarriorId(warriorsData[i], 0)]);\n        }\n    }\n    \n    function _triggerFinishTournament() internal returns(uint256){\n        //hold 10 random battles for each composite warrior\n        uint256[] memory warriorsData = getCombinedWarriors();\n        uint32[] memory results = CryptoUtils.getTournamentBattleResults(warriorsData, tournamentEndBlock - 1);\n        //repack combined warriors id\n        _repackToCombinedIds(warriorsData);\n        //notify pvp listener\n        pvpListener.tournamentFinished(warriorsData);\n        //reschedule\n        //clear tournament\n        tournamentQueueSize = 0;\n        //schedule new tournament\n        _scheduleTournament();\n        \n        uint256 currentBank = currentTournamentBank;\n        currentTournamentBank = 0;//nullify before sending to users\n        //grand rewards, not susceptible to reentry attack\n        //because of require(tournamentEndBlock <= block.number)\n        //and require(tournamentQueueSize > 0) and currentTournamentBank == 0\n        uint256 incentiveReward = _grandTournamentRewards(currentBank, warriorsData, results);\n        \n        currentTournamentBank = nextTournamentBank;\n        nextTournamentBank = 0;\n        \n        _repackToWarriorOwners(warriorsData);\n        \n        //emit event\n        TournamentFinished(warriorsData, results, currentBank);\n\n        return incentiveReward;\n    }\n    \n    function finishTournament() external TournamentNotPaused {\n        //make all the checks\n        // tournament is ready to be executed\n        require(tournamentEndBlock <= block.number);\n        // we have participants\n        require(tournamentQueueSize > 0);\n        \n        uint256 incentiveReward = _triggerFinishTournament();\n        \n        //give reward for incentive\n        safeSend(msg.sender, incentiveReward);\n    }\n    \n    \n    // @dev Remove all PVP contenders from PVP queue \n    //  and return all entrance fees to warrior owners.\n    //  NB: this is emergency method, used only in f%#^@up situation\n    function removeAllTournamentContenders() external onlyOwner TournamentPaused {\n        //remove all pvp contenders\n        uint256 length = tournamentQueueSize;\n        \n        uint256 warriorId;\n        uint256 failedBooty;\n        uint256 i;\n\n        uint256 fee;\n        uint256 bank = currentTournamentBank;\n        \n        uint256[] memory warriorsData = new uint256[](length);\n        //get tournament warriors\n        for(i = 0; i < length; i ++) {\n            warriorsData[i] = tournamentQueue[i * DATA_SIZE];\n        }\n        //notify pvp listener\n        pvpListener.tournamentFinished(warriorsData);\n        //return entrance fee to warrior owners\n     \tcurrentTournamentBank = 0;\n        tournamentQueueSize = 0;\n\n        for(i = length - 1; i >= 0; i --) {\n            //return entrance fee\n            warriorId = CryptoUtils._unpackWarriorId(warriorsData[i], 0);\n            //compute contender entrance fee\n\t\t\tfee = bank - (bank * 10000 / (tournamentEntranceFeeCut * (10000 - THRESHOLD) / 10000 + 10000));\n\t\t\t//return entrance fee to owner\n\t        failedBooty += sendBooty(warriorToOwner[warriorId], fee);\n\t        //subtract fee from bank, for next use\n\t        bank -= fee;\n        }\n        currentTournamentBank = bank;\n        totalBooty += failedBooty;\n    }\n}\n\ncontract BattleProvider is Tournament {\n    \n    function BattleProvider(address _pvpListener, uint256 _pvpCut, uint256 _tournamentCut, uint256 _incentiveCut, \n    uint256 _tournamentOwnersCut, uint256 _tournamentIncentiveCut) public \n    Tournament(_pvpCut, _tournamentCut, _incentiveCut, _tournamentOwnersCut, _tournamentIncentiveCut) \n    {\n        PVPListenerInterface candidateContract = PVPListenerInterface(_pvpListener);\n        // NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117\n        require(candidateContract.isPVPListener());\n        // Set the new contract address\n        pvpListener = candidateContract;\n        \n        // the creator of the contract is the initial owner\n        owner = msg.sender;\n    }\n    \n    \n    // @dev Sanity check that allows us to ensure that we are pointing to the\n    // right BattleProvider in our setBattleProviderAddress() call.\n    function isPVPProvider() external pure returns (bool) {\n        return true;\n    }\n    \n    function setSecondsPerBlock(uint256 secs) external onlyOwner {\n        secondsPerBlock = secs;\n    }\n}\n\n\n/* warrior identity generator*/\ncontract WarriorGenerator is Pausable, SanctuaryInterface {\n    \n    CryptoWarriorCore public coreContract;\n    \n    /* LIMITS */\n    uint32[19] public parameters;/*  = [\n        uint32(10),//0_bodyColorMax3\n        uint32(10),//1_eyeshMax4\n        uint32(10),//2_mouthMax5\n        uint32(20),//3_heirMax6\n        uint32(10),//4_heirColorMax7\n        uint32(3),//5_armorMax8\n        uint32(3),//6_weaponMax9\n        uint32(3),//7_hatMax10\n        uint32(4),//8_runesMax11\n        uint32(1),//9_wingsMax12\n        uint32(10),//10_petMax13\n        uint32(6),//11_borderMax14\n        uint32(6),//12_backgroundMax15\n        uint32(10),//13_unique\n        uint32(900),//14_legendary\n        uint32(9000),//15_mythic\n        uint32(90000),//16_rare\n        uint32(900000),//17_uncommon\n        uint32(0)//18_uniqueTotal\n    ];*/\n    \n\n    function changeParameter(uint32 _paramIndex, uint32 _value) external onlyOwner {\n        CryptoUtils._changeParameter(_paramIndex, _value, parameters);\n    }\n\n    // / @dev simply a boolean to indicate this is the contract we expect to be\n    function isSanctuary() public pure returns (bool){\n        return true;\n    }\n\n    // / @dev generate new warrior identity\n    // / @param _heroIdentity Genes of warrior that invoked resurrection, if 0 => Demigod gene that signals to generate unique warrior\n    // / @param _heroLevel Level of the warrior\n    // / @_targetBlock block number from which hash will be taken\n    // / @_perkId special perk id, like MINER(1)\n    // / @return the identity that are supposed to be passed down to newly arisen warrior\n    function generateWarrior(uint256 _heroIdentity, uint256 _heroLevel, uint256 _targetBlock, uint256 _perkId) \n    public returns (uint256) \n    {\n        //only core contract can call this method\n        require(msg.sender == address(coreContract));\n        \n        return _generateIdentity(_heroIdentity, _heroLevel, _targetBlock, _perkId);\n    }\n    \n    function _generateIdentity(uint256 _heroIdentity, uint256 _heroLevel, uint256 _targetBlock, uint256 _perkId) internal returns(uint256){\n        \n        //get memory copy, to reduce storage read requests\n        uint32[19] memory memoryParams = parameters;\n        //generate warrior identity\n        uint256 identity = CryptoUtils.generateWarrior(_heroIdentity, _heroLevel, _targetBlock, _perkId, memoryParams);\n        \n        //validate before pushing changes to storage\n        CryptoUtils._validateIdentity(identity, memoryParams);\n        //push changes to storage\n        CryptoUtils._recordWarriorData(identity, parameters);\n        \n        return identity;\n    }\n}\n\ncontract WarriorSanctuary is WarriorGenerator {\n    uint256 internal constant SUMMONING_SICKENESS = 12 hours;\n    uint256 internal constant RITUAL_DURATION = 15 minutes;\n    /// @notice The payment required to use startRitual().\n    uint256 public ritualFee = 10 finney;\n    \n    uint256 public constant RITUAL_COMPENSATION = 2 finney;\n    \n    mapping(address => uint256) public soulCounter;\n    //\n    mapping(address => uint256) public ritualTimeBlock;\n    \n    bool public recoveryAllowed = true;\n    \n    event WarriorBurned(uint256 warriorId, address owner);\n    event RitualStarted(address owner, uint256 numberOfSouls);\n    event RitualFinished(address owner, uint256 numberOfSouls, uint256 newWarriorId);\n    \n    \n    function WarriorSanctuary(address _coreContract, uint32[] _settings) public {\n        uint256 length = _settings.length;\n        require(length == 18);\n        require(_settings[8] == 4);//check runes max\n        require(_settings[10] == 10);//check pets max\n        require(_settings[11] == 5);//check border max\n        require(_settings[12] == 6);//check background max\n        //setup parameters\n        for(uint256 i = 0; i < length; i ++) {\n            parameters[i] = _settings[i];\n        }\t\n        \n        //set core\n        CryptoWarriorCore coreCondidat = CryptoWarriorCore(_coreContract);\n        require(coreCondidat.isPVPListener());\n        coreContract = coreCondidat;\n        \n    }\n    \n    function recoverSouls(address[] owners, uint256[] souls, uint256[] blocks) external onlyOwner {\n        require(recoveryAllowed);\n        \n        uint256 length = owners.length;\n        require(length == souls.length && length == blocks.length);\n        \n        for(uint256 i = 0; i < length; i ++) {\n            soulCounter[owners[i]] = souls[i];\n            ritualTimeBlock[owners[i]] = blocks[i];\n        }\n        \n        recoveryAllowed = false;\n    }\n    \n    \n    //burn warrior\n    function burnWarrior(uint256 _warriorId) whenNotPaused external {\n        coreContract.burnWarrior(_warriorId, msg.sender);\n        \n        soulCounter[msg.sender] ++;\n        \n        WarriorBurned(_warriorId, msg.sender);\n    }\n   \n    \n    function startRitual() whenNotPaused external payable {\n        // Checks for payment.\n        require(msg.value >= ritualFee);\n        \n        uint256 souls = soulCounter[msg.sender];\n        // Check that address has at least 10 burned souls\n        require(souls >= 10);\n        //\n        //Check that no rituals are in progress\n        require(ritualTimeBlock[msg.sender] == 0);\n        \n        ritualTimeBlock[msg.sender] = RITUAL_DURATION / coreContract.secondsPerBlock() + block.number;\n        \n        // Calculate any excess funds included in msg.value. If the excess\n        // is anything worth worrying about, transfer it back to message owner.\n        // NOTE: We checked above that the msg.value is greater than or\n        // equal to the price so this cannot underflow.\n        uint256 feeExcess = msg.value - ritualFee;\n\n        // Return the funds. This is not susceptible \n        // to a re-entry attack because of _isReadyToPVE check\n        // will fail\n        if (feeExcess > 0) {\n            msg.sender.transfer(feeExcess);\n        }\n        //send battle fee to beneficiary\n        coreContract.getBeneficiary().transfer(ritualFee - RITUAL_COMPENSATION);\n        \n        RitualStarted(msg.sender, souls);\n    }\n    \n    \n    //arise warrior\n    function finishRitual(address _owner) whenNotPaused external {\n        // Check ritual time is over\n        uint256 timeBlock = ritualTimeBlock[_owner];\n        require(timeBlock > 0 && timeBlock <= block.number);\n        \n        uint256 souls = soulCounter[_owner];\n        \n        require(souls >= 10);\n        \n        uint256 identity = _generateIdentity(uint256(_owner), souls, timeBlock - 1, 0);\n        \n        uint256 warriorId = coreContract.ariseWarrior(identity, _owner, block.number + (SUMMONING_SICKENESS / coreContract.secondsPerBlock()));\n    \n        soulCounter[_owner] = 0;\n        ritualTimeBlock[_owner] = 0;\n        //send compensation\n        msg.sender.transfer(RITUAL_COMPENSATION);\n        \n        RitualFinished(_owner, 10, warriorId);\n    }\n    \n    function setRitualFee(uint256 _pveRitualFee) external onlyOwner {\n        require(_pveRitualFee > RITUAL_COMPENSATION);\n        ritualFee = _pveRitualFee;\n    }\n}\n\ncontract AuctionBase {\n\tuint256 public constant PRICE_CHANGE_TIME_STEP = 15 minutes;\n    //\n    struct Auction{\n        address seller;\n        uint128 startingPrice;\n        uint128 endingPrice;\n        uint64 duration;\n        uint64 startedAt;\n    }\n    mapping (uint256 => Auction) internal tokenIdToAuction;\n    uint256 public ownerCut;\n    ERC721 public nonFungibleContract;\n\n    event AuctionCreated(uint256 tokenId, address seller, uint256 startingPrice);\n\n    event AuctionSuccessful(uint256 tokenId, uint256 totalPrice, address winner, address seller);\n\n    event AuctionCancelled(uint256 tokenId, address seller);\n\n    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool){\n        return (nonFungibleContract.ownerOf(_tokenId) == _claimant);\n    }\n\n    function _escrow(address _owner, uint256 _tokenId) internal{\n        nonFungibleContract.transferFrom(_owner, address(this), _tokenId);\n    }\n\n    function _transfer(address _receiver, uint256 _tokenId) internal{\n        nonFungibleContract.transfer(_receiver, _tokenId);\n    }\n\n    function _addAuction(uint256 _tokenId, Auction _auction) internal{\n        require(_auction.duration >= 1 minutes);\n        \n        tokenIdToAuction[_tokenId] = _auction;\n        \n        AuctionCreated(uint256(_tokenId), _auction.seller, _auction.startingPrice);\n    }\n\n    function _cancelAuction(uint256 _tokenId, address _seller) internal{\n        _removeAuction(_tokenId);\n        \n        _transfer(_seller, _tokenId);\n        \n        AuctionCancelled(_tokenId, _seller);\n    }\n\n    function _bid(uint256 _tokenId, uint256 _bidAmount) internal returns (uint256){\n        \n        Auction storage auction = tokenIdToAuction[_tokenId];\n        \n        require(_isOnAuction(auction));\n        \n        uint256 price = _currentPrice(auction);\n        \n        require(_bidAmount >= price);\n        \n        address seller = auction.seller;\n        \n        _removeAuction(_tokenId);\n        \n        if (price > 0) {\n            uint256 auctioneerCut = _computeCut(price);\n            uint256 sellerProceeds = price - auctioneerCut;\n            seller.transfer(sellerProceeds);\n            nonFungibleContract.getBeneficiary().transfer(auctioneerCut);\n        }\n        \n        uint256 bidExcess = _bidAmount - price;\n        \n        msg.sender.transfer(bidExcess);\n        \n        AuctionSuccessful(_tokenId, price, msg.sender, seller);\n        \n        return price;\n    }\n\n    function _removeAuction(uint256 _tokenId) internal{\n        delete tokenIdToAuction[_tokenId];\n    }\n\n    function _isOnAuction(Auction storage _auction) internal view returns (bool){\n        return (_auction.startedAt > 0);\n    }\n\n    function _currentPrice(Auction storage _auction)\n        internal\n        view\n        returns (uint256){\n        uint256 secondsPassed = 0;\n        \n        if (now > _auction.startedAt) {\n            secondsPassed = now - _auction.startedAt;\n        }\n        \n        return _computeCurrentPrice(_auction.startingPrice,\n            _auction.endingPrice,\n            _auction.duration,\n            secondsPassed);\n    }\n    \n    function _computeCurrentPrice(uint256 _startingPrice,\n        uint256 _endingPrice,\n        uint256 _duration,\n        uint256 _secondsPassed)\n        internal\n        pure\n        returns (uint256){\n        if (_secondsPassed >= _duration) {\n            return _endingPrice;\n        } else {\n            int256 totalPriceChange = int256(_endingPrice) - int256(_startingPrice);\n            \n            int256 currentPriceChange = totalPriceChange * int256(_secondsPassed / PRICE_CHANGE_TIME_STEP * PRICE_CHANGE_TIME_STEP) / int256(_duration);\n            \n            int256 currentPrice = int256(_startingPrice) + currentPriceChange;\n            \n            return uint256(currentPrice);\n        }\n    }\n\n    function _computeCut(uint256 _price) internal view returns (uint256){\n        \n        return _price * ownerCut / 10000;\n    }\n}\n\ncontract SaleClockAuction is Pausable, AuctionBase {\n    \n    bytes4 constant InterfaceSignature_ERC721 = bytes4(0x9f40b779);\n    \n    bool public isSaleClockAuction = true;\n    uint256 public minerSaleCount;\n    uint256[5] public lastMinerSalePrices;\n\n    function SaleClockAuction(address _nftAddress, uint256 _cut) public{\n        require(_cut <= 10000);\n        ownerCut = _cut;\n        ERC721 candidateContract = ERC721(_nftAddress);\n        require(candidateContract.supportsInterface(InterfaceSignature_ERC721));\n        require(candidateContract.getBeneficiary() != address(0));\n        \n        nonFungibleContract = candidateContract;\n    }\n\n    function cancelAuction(uint256 _tokenId)\n        external{\n        \n        AuctionBase.Auction storage auction = tokenIdToAuction[_tokenId];\n        \n        require(_isOnAuction(auction));\n        \n        address seller = auction.seller;\n        \n        require(msg.sender == seller);\n        \n        _cancelAuction(_tokenId, seller);\n    }\n\n    function cancelAuctionWhenPaused(uint256 _tokenId)\n        whenPaused\n        onlyOwner\n        external{\n        AuctionBase.Auction storage auction = tokenIdToAuction[_tokenId];\n        require(_isOnAuction(auction));\n        _cancelAuction(_tokenId, auction.seller);\n    }\n\n    function getCurrentPrice(uint256 _tokenId)\n        external\n        view\n        returns (uint256){\n        \n        AuctionBase.Auction storage auction = tokenIdToAuction[_tokenId];\n        \n        require(_isOnAuction(auction));\n        \n        return _currentPrice(auction);\n    }\n    \n    function createAuction(uint256 _tokenId,\n        uint256 _startingPrice,\n        uint256 _endingPrice,\n        uint256 _duration,\n        address _seller)\n        whenNotPaused\n        external{\n        require(_startingPrice == uint256(uint128(_startingPrice)));\n        require(_endingPrice == uint256(uint128(_endingPrice)));\n        require(_duration == uint256(uint64(_duration)));\n        require(msg.sender == address(nonFungibleContract));\n        _escrow(_seller, _tokenId);\n        \n        AuctionBase.Auction memory auction = Auction(_seller,\n            uint128(_startingPrice),\n            uint128(_endingPrice),\n            uint64(_duration),\n            uint64(now));\n        \n        _addAuction(_tokenId, auction);\n    }\n    \n    function bid(uint256 _tokenId)\n        whenNotPaused\n        external\n        payable{\n        \n        address seller = tokenIdToAuction[_tokenId].seller;\n        \n        uint256 price = _bid(_tokenId, msg.value);\n        \n        _transfer(msg.sender, _tokenId);\n        \n        if (seller == nonFungibleContract.getBeneficiary()) {\n            lastMinerSalePrices[minerSaleCount % 5] = price;\n            minerSaleCount++;\n        }\n    }\n\n    function averageMinerSalePrice() external view returns (uint256){\n        uint256 sum = 0;\n        for (uint256 i = 0; i < 5; i++){\n            sum += lastMinerSalePrices[i];\n        }\n        return sum / 5;\n    }\n    \n    /**getAuctionsById returns packed actions data\n     * @param tokenIds ids of tokens, whose auction's must be active \n     * @return auctionData as uint256 array\n     * @return stepSize number of fields describing auction \n     */\n    function getAuctionsById(uint32[] tokenIds) external view returns(uint256[] memory auctionData, uint32 stepSize) {\n        stepSize = 6;\n        auctionData = new uint256[](tokenIds.length * stepSize);\n        \n        uint32 tokenId;\n        for(uint32 i = 0; i < tokenIds.length; i ++) {\n            tokenId = tokenIds[i];\n            AuctionBase.Auction storage auction = tokenIdToAuction[tokenId];\n            require(_isOnAuction(auction));\n            _setTokenData(auctionData, auction, tokenId, i * stepSize);\n        }\n    }\n    \n    /**getAuctions returns packed actions data\n     * @param fromIndex warrior index from global warrior storage (aka warriorId)\n     * @param count Number of auction's to find, if count == 0, then exact warriorId(fromIndex) will be searched\n     * @return auctionData as uint256 array\n     * @return stepSize number of fields describing auction \n     */\n    function getAuctions(uint32 fromIndex, uint32 count) external view returns(uint256[] memory auctionData, uint32 stepSize) {\n        stepSize = 6;\n        if (count == 0) {\n            AuctionBase.Auction storage auction = tokenIdToAuction[fromIndex];\n\t        \trequire(_isOnAuction(auction));\n\t        \tauctionData = new uint256[](1 * stepSize);\n\t        \t_setTokenData(auctionData, auction, fromIndex, count);\n\t        \treturn (auctionData, stepSize);\n        } else {\n            uint256 totalWarriors = nonFungibleContract.totalSupply();\n\t        if (totalWarriors == 0) {\n\t            // Return an empty array\n\t            return (new uint256[](0), stepSize);\n\t        } else {\n\t\n\t            uint32 totalSize = 0;\n\t            uint32 tokenId;\n\t            uint32 size = 0;\n\t\t\t\tauctionData = new uint256[](count * stepSize);\n\t            for (tokenId = 0; tokenId < totalWarriors && size < count; tokenId++) {\n\t                AuctionBase.Auction storage auction1 = tokenIdToAuction[tokenId];\n\t        \n\t\t        \t\tif (_isOnAuction(auction1)) {\n\t\t        \t\t    totalSize ++;\n\t\t        \t\t    if (totalSize > fromIndex) {\n\t\t        \t\t        _setTokenData(auctionData, auction1, tokenId, size++ * stepSize);//warriorId;\n\t\t        \t\t    }\n\t\t        \t\t}\n\t            }\n\t            \n\t            if (size < count) {\n\t                size *= stepSize;\n\t                uint256[] memory repack = new uint256[](size);\n\t                for(tokenId = 0; tokenId < size; tokenId++) {\n\t                    repack[tokenId] = auctionData[tokenId];\n\t                }\n\t                return (repack, stepSize);\n\t            }\n\t\n\t            return (auctionData, stepSize);\n\t        }\n        }\n    }\n    \n    // @dev Returns auction info for an NFT on auction.\n    // @param _tokenId - ID of NFT on auction.\n    function getAuction(uint256 _tokenId) external view returns(\n        address seller,\n        uint256 startingPrice,\n        uint256 endingPrice,\n        uint256 duration,\n        uint256 startedAt\n        ){\n        \n        Auction storage auction = tokenIdToAuction[_tokenId];\n        \n        require(_isOnAuction(auction));\n        \n        return (auction.seller,\n            auction.startingPrice,\n            auction.endingPrice,\n            auction.duration,\n            auction.startedAt);\n    }\n    \n    //pack NFT data into specified array\n    function _setTokenData(uint256[] memory auctionData, \n        AuctionBase.Auction storage auction, uint32 tokenId, uint32 index\n    ) internal view {\n        auctionData[index] = uint256(tokenId);//0\n        auctionData[index + 1] = uint256(auction.seller);//1\n        auctionData[index + 2] = uint256(auction.startingPrice);//2\n        auctionData[index + 3] = uint256(auction.endingPrice);//3\n        auctionData[index + 4] = uint256(auction.duration);//4\n        auctionData[index + 5] = uint256(auction.startedAt);//5\n    }\n    \n}",
  "bytecode": "60606040526000805460a060020a60ff0219169055662386f26fc100006005556008805460ff1916600117905534156200003857600080fd5b6040516200240738038062002407833981016040528080519190602001805160008054600160a060020a03191633600160a060020a03161781559201919050808083519250601283146200008b57600080fd5b836008815181106200009957fe5b9060200190602002015163ffffffff166004141515620000b857600080fd5b83600a81518110620000c657fe5b9060200190602002015163ffffffff16600a141515620000e557600080fd5b83600b81518110620000f357fe5b9060200190602002015163ffffffff1660051415156200011257600080fd5b83600c815181106200012057fe5b9060200190602002015163ffffffff1660061415156200013f57600080fd5b600091505b82821015620001a9578382815181106200015a57fe5b90602001906020020151600283601381106200017257fe5b600891828204019190066004026101000a81548163ffffffff021916908363ffffffff160217905550818060010192505062000144565b5083600160a060020a03811663e4d9d2126000604051602001526040518163ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401602060405180830381600087803b15156200020b57600080fd5b6102c65a03f115156200021d57600080fd5b5050506040518051905015156200023357600080fd5b60018054600160a060020a03909216600160a060020a03199092169190911790555050505061219f80620002686000396000f3006060604052600436106100f85763ffffffff60e060020a60003504166309fc3c5381146100fd5780630c932e77146101155780632a4a9dd11461013a5780633321c76c146101695780633f4ba83a1461017c57806343ea03131461018f5780634c62eb61146101a55780635071fcf0146101c45780635c975abb146101fa578063775f5ec0146102215780637e3a7357146102405780638456cb591461025f5780638da5cb5b146102725780639711f20d146102a15780639729ec26146102b4578063da9ad094146102d3578063e80db5db146102f5578063eadb6e8414610308578063f2fde38b14610310578063fc2f5e671461032f575b600080fd5b341561010857600080fd5b610113600435610342565b005b341561012057600080fd5b61012861042b565b60405190815260200160405180910390f35b341561014557600080fd5b610150600435610431565b60405163ffffffff909116815260200160405180910390f35b341561017457600080fd5b61012861045e565b341561018757600080fd5b610113610469565b341561019a57600080fd5b6101136004356104e8565b34156101b057600080fd5b610128600160a060020a036004351661051b565b34156101cf57600080fd5b610113602460048035828101929082013591813580830192908201359160443591820191013561052d565b341561020557600080fd5b61020d610630565b604051901515815260200160405180910390f35b341561022c57600080fd5b610113600160a060020a0360043516610640565b341561024b57600080fd5b610128600160a060020a036004351661087a565b341561026a57600080fd5b61011361088c565b341561027d57600080fd5b610285610910565b604051600160a060020a03909116815260200160405180910390f35b34156102ac57600080fd5b61020d61091f565b34156102bf57600080fd5b610128600435602435604435606435610924565b34156102de57600080fd5b61011363ffffffff60043581169060243516610957565b341561030057600080fd5b610285610988565b610113610997565b341561031b57600080fd5b610113600160a060020a0360043516610bc6565b341561033a57600080fd5b61020d610c1c565b60005460a060020a900460ff161561035957600080fd5b600154600160a060020a031663b639c9ec823360405160e060020a63ffffffff85160281526004810192909252600160a060020a03166024820152604401600060405180830381600087803b15156103b057600080fd5b6102c65a03f115156103c157600080fd5b50505033600160a060020a03811660009081526006602052604090819020805460010190557f59bcba6a5d1ea8b61f7c2656523dda11af2309da936f882649a821ac51a44ec991839151918252600160a060020a031660208201526040908101905180910390a150565b60055481565b6002816013811061043e57fe5b60089182820401919006600402915054906101000a900463ffffffff1681565b66071afd498d000081565b60005433600160a060020a0390811691161461048457600080fd5b60005460a060020a900460ff16151561049c57600080fd5b6000805474ff0000000000000000000000000000000000000000191690557f7805862f689e2f13df9f062ff482ad3ad112aca9e0847911ed832e158c525b3360405160405180910390a1565b60005433600160a060020a0390811691161461050357600080fd5b66071afd498d0000811161051657600080fd5b600555565b60066020526000908152604090205481565b60008054819033600160a060020a0390811691161461054b57600080fd5b60085460ff16151561055c57600080fd5b869150848214801561056d57508183145b151561057857600080fd5b5060005b8181101561061c5785858281811061059057fe5b90506020020135600660008a8a8581811015156105a957fe5b60209081029290920135600160a060020a0316835250810191909152604001600020558383828181106105d857fe5b90506020020135600760008a8a8581811015156105f157fe5b60209081029290920135600160a060020a03168352508101919091526040016000205560010161057c565b50506008805460ff19169055505050505050565b60005460a060020a900460ff1681565b6000805481908190819060a060020a900460ff161561065e57600080fd5b600160a060020a0385166000908152600760205260408120549450841180156106875750438411155b151561069257600080fd5b600160a060020a0385166000908152600660205260409020549250600a8310156106bb57600080fd5b6106d485600160a060020a031684600187036000610c25565b600154909250600160a060020a0316635ae82dfd838783637a7d49376000604051602001526040518163ffffffff1660e060020a028152600401602060405180830381600087803b151561072757600080fd5b6102c65a03f1151561073857600080fd5b5050506040518051905061a8c081151561074e57fe5b04430160006040516020015260405160e060020a63ffffffff86160281526004810193909352600160a060020a0390911660248301526044820152606401602060405180830381600087803b15156107a557600080fd5b6102c65a03f115156107b657600080fd5b5050506040518051600160a060020a03808816600090815260066020908152604080832083905560079091528082208290559294503390911692509066071afd498d00009051600060405180830381858888f19350505050151561081957600080fd5b7fec248636c15f7e7f497997edf127f4de651096a21d24d233500e2cc5c8461d7285600a836040518084600160a060020a0316600160a060020a03168152602001838152602001828152602001935050505060405180910390a15050505050565b60076020526000908152604090205481565b60005433600160a060020a039081169116146108a757600080fd5b60005460a060020a900460ff16156108be57600080fd5b6000805474ff0000000000000000000000000000000000000000191660a060020a1790557f6985a02210a168e66602d3235cb6db0e70f92b3ba4d376a33c0f3d9434bff62560405160405180910390a1565b600054600160a060020a031681565b600190565b60015460009033600160a060020a0390811691161461094257600080fd5b61094e85858585610c25565b95945050505050565b60005433600160a060020a0390811691161461097257600080fd5b6109848263ffffffff16826002610cbf565b5050565b600154600160a060020a031681565b60008054819060a060020a900460ff16156109b157600080fd5b6005543410156109c057600080fd5b600160a060020a0333166000908152600660205260409020549150600a8210156109e957600080fd5b600160a060020a03331660009081526007602052604090205415610a0c57600080fd5b6001544390600160a060020a0316637a7d49376000604051602001526040518163ffffffff1660e060020a028152600401602060405180830381600087803b1515610a5657600080fd5b6102c65a03f11515610a6757600080fd5b50505060405180519050610384811515610a7d57fe5b600160a060020a03331660009081526007602052604081209290910492909201905560055434039150811115610ade57600160a060020a03331681156108fc0282604051600060405180830381858888f193505050501515610ade57600080fd5b600154600160a060020a031663565a2e2c6000604051602001526040518163ffffffff1660e060020a028152600401602060405180830381600087803b1515610b2657600080fd5b6102c65a03f11515610b3757600080fd5b50505060405180519050600160a060020a03166108fc66071afd498d0000600554039081150290604051600060405180830381858888f193505050501515610b7e57600080fd5b7f0dc02bef54f50a8aee762da4ae485cacdfac1e75ce6c85223fabf96ad14ba4e53383604051600160a060020a03909216825260208201526040908101905180910390a15050565b60005433600160a060020a03908116911614610be157600080fd5b600160a060020a03811615610c19576000805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0383161790555b50565b60085460ff1681565b6000610c2f61214a565b60006002601361026060405190810160405291906102608301826000855b82829054906101000a900463ffffffff1663ffffffff1681526020019060040190602082600301049283019260010382029150808411610c4d57905050505050509150610c9d8787878786610dc7565b9050610ca9818361118f565b50610cb58160026114f4565b9695505050505050565b60008310158015610cd15750600d8311155b1515610cdc57600080fd5b60088314158015610cee5750600a8314155b8015610cfb5750600b8314155b8015610d085750600c8314155b1515610d1357600080fd5b6007831180610d2957506103e88263ffffffff16105b1515610d3457600080fd5b600c831180610d49575060648263ffffffff16105b1515610d5457600080fd5b600d83141580610d815750600281015460646801000000000000000090910463ffffffff90811684011611155b1515610d8c57600080fd5b81818460138110610d9957fe5b600891828204019190066004026101000a81548163ffffffff021916908363ffffffff160217905550505050565b600080600080600080610dd9896115fd565b985088408b41446040519384526020840192909252600160a060020a03166c010000000000000000000000000260408084019190915260548301919091526074909101905190819003902093508915610e5557610e358b61162a565b8a02610e466000629896808761164f565b811515610e4f57fe5b04610e5a565b629896805b9250610ea1836101a089015163ffffffff166101c08a015163ffffffff166101e08b015163ffffffff166102008c015163ffffffff166102208d015163ffffffff16611669565b9150610eac846116f1565b9095509050610ed1610ecc836102408a015160010163ffffffff16611811565b61182d565b85019450610ede82611841565b85019450610eeb81611858565b9490940193610f19610f116000895163ffffffff168764174876e8006305f5e100611871565b6001016118a3565b9490940193610f4c610f44600060208a015163ffffffff1687655af3107a400064174876e800611871565b6001016118bd565b9490940193610f82610f7a600060408a015163ffffffff168767016345785d8a0000655af3107a4000611871565b6001016118d8565b9490940193610fbb610fb3600060608a015163ffffffff168768056bc75e2d6310000067016345785d8a0000611871565b6001016118f4565b9490940193610ff6610fee600060808a015163ffffffff168769152d02c7e14af680000068056bc75e2d63100000611871565b600101611912565b949094019361103361102b600060a08a015163ffffffff16876a52b7d2dcc80cd2e400000069152d02c7e14af6800000611871565b600101611931565b949094019361107361106b600060c08a015163ffffffff16876c01431e0fae6d7217caa00000006a52b7d2dcc80cd2e4000000611871565b600101611951565b94909401936110b36110ae600060e08a015163ffffffff16876d04ee2d6d415b85acef81000000006c01431e0fae6d7217caa0000000611871565b611972565b850194506110c86110c383611995565b6119ae565b94909401936110eb6110e6836101208a015163ffffffff16876119d1565b611a1a565b949094019361110e611109836101408a015163ffffffff1687611a3e565b611a7c565b8501945061112361111e83611aa0565b611aba565b8501945061113861113383611adf565b611ae2565b8501945061114581611b08565b8501945061115b6111568386611b31565b611c0e565b8501945061116888611c39565b8501945061117e6111798386611c64565b611cac565b9094019a9950505050505050505050565b60008061119b84611cd8565b905060068111156111ab57600080fd5b6001811115806111d157506002811480156111d15750600061022084015163ffffffff16115b806111f257506003811480156111f25750600061020084015163ffffffff16115b806112135750600481148015611213575060006101e084015163ffffffff16115b806112345750600581148015611234575060006101c084015163ffffffff16115b806112555750600681148015611255575060006101a084015163ffffffff16115b151561126057600080fd5b600681141580611282575061024083015163ffffffff1661128085611cf4565b115b151561128d57600080fd5b606461129885611cfc565b1080156112ad575060646112ab85611d2e565b105b80156112c1575060646112bf85611d5f565b105b80156112d6575060376112d385611d8e565b11155b15156112e157600080fd5b60026112ec85611dc6565b11156112f757600080fd5b61130084611df9565b61130985611dc6565b1461131357600080fd5b600161131e85611e0a565b111561132957600080fd5b600961133485611e41565b111561133f57600080fd5b600961134a85611e76565b111561135557600080fd5b825163ffffffff1661136685611eaf565b111561137157600080fd5b602083015163ffffffff1661138585611ec2565b111561139057600080fd5b604083015163ffffffff166113a485611ed7565b11156113af57600080fd5b606083015163ffffffff166113c385611eef565b11156113ce57600080fd5b608083015163ffffffff166113e285611f0a565b11156113ed57600080fd5b60a083015163ffffffff1661140185611f27565b111561140c57600080fd5b60c083015163ffffffff1661142085611f46565b111561142b57600080fd5b60e083015163ffffffff1661143f85611f68565b111561144a57600080fd5b61010083015163ffffffff1661145f85611f8d565b111561146a57600080fd5b61012083015163ffffffff1661147f85611fb4565b111561148a57600080fd5b61014083015163ffffffff1661149f85611fdc565b11156114aa57600080fd5b61016083015163ffffffff166114bf85612005565b11156114ca57600080fd5b61018083015163ffffffff166114df85612030565b11156114ea57600080fd5b5060019392505050565b60006114ff83611cd8565b90506002811415611546578160115b6008808204929092018054929091066004026101000a63ffffffff8181021984169382900481166000190116029190911790556115f8565b60038114156115575781601061150e565b60048114156115685781600f61150e565b60058114156115795781600e61150e565b60068114156115f8576001828101805477ffffffff000000000000000000000000000000000000000019811663ffffffff60a060020a928390048116600019018116909202179091556002840180546bffffffff0000000000000000198116680100000000000000009182900484169094019092169091029190911790555b505050565b60004361010080820682039084060181811061161f5761010081039250611623565b8092505b5050919050565b6000600161163783611e0a565b14611643576001611646565b60045b60ff1692915050565b6000838484038381151561165f57fe5b0601949350505050565b600085850184018301820180881061168457600191506116e6565b82900380881061169757600291506116e6565b8390038088106116aa57600391506116e6565b8490038088106116bd57600491506116e6565b8590038088106116d057600591506116e6565b808810156116e157600691506116e6565b600191505b509695505050505050565b6000808080808080806117368160158b766867a5a867f103b2fffa5a71fba0e7b68000000000000076010b46c6cdd6e3e0828f4db456ff0c8ea0000000000000611871565b60230194506117726000601a8b73af298d050e4395d69670b12b7f410000000000007301c06a5ec5433c60ddaa16406f5a400000000000611871565b602d0193508385607d0303600f019250848385609b03030391506117988484848c61205d565b919550935091506117a8846120a6565b860195506117b5836120cf565b860195506117c2826120f7565b860195506117cf8561211e565b860195508284116117f0578183116117e85760026117eb565b60015b611801565b8184116117fe576002611801565b60005b9599959850949650505050505050565b600060068314611822576000611824565b815b90505b92915050565b6000612710821061183d57600080fd5b5090565b6000600a821061185057600080fd5b506127100290565b60006103e8821061186857600080fd5b50620186a00290565b60008586860383858781151561188357fe5b0681151561188d57fe5b0481151561189757fe5b06019695505050505050565b60006103e882106118b357600080fd5b506305f5e1000290565b60006103e882106118cd57600080fd5b5064174876e8000290565b60006103e882106118e857600080fd5b50655af3107a40000290565b60006103e8821061190457600080fd5b5067016345785d8a00000290565b60006103e8821061192257600080fd5b5068056bc75e2d631000000290565b60006103e8821061194157600080fd5b5069152d02c7e14af68000000290565b60006103e8821061196157600080fd5b506a52b7d2dcc80cd2e40000000290565b60006103e8821061198257600080fd5b506c01431e0fae6d7217caa00000000290565b6000600282116119a6576000611827565b506001190190565b6000606482106119bd57600080fd5b506d04ee2d6d415b85acef81000000000290565b6000600384116119e2576000611a12565b611a0e600084846ec097ce7bc90715b34b9f10000000006e01ed09bead87c0378d8e6400000000611871565b6001015b949350505050565b600060648210611a2957600080fd5b506e01ed09bead87c0378d8e64000000000290565b600060048411611a4f576000611a12565b611a0e600084846f4b3b4ca85a86c47a098a2240000000006ec097ce7bc90715b34b9f1000000000611871565b600060648210611a8b57600080fd5b506ec097ce7bc90715b34b9f10000000000290565b60006001821015611ab2576000611827565b506000190190565b600060648210611ac957600080fd5b506f4b3b4ca85a86c47a098a2240000000000290565b90565b600060648210611af157600080fd5b50701d6329f1c35ca4bfabb9f56100000000000290565b6000600a8210611b1757600080fd5b5073af298d050e4395d69670b12b7f410000000000000290565b60006002831415611b8057611b766000600584751aba4714957d300d0e549208b31adb100000000000007406d79f82328ea3da61e066ebb2f88a000000000000611871565b6001019050611827565b6003831415611bc357611b766005600984751aba4714957d300d0e549208b31adb100000000000007406d79f82328ea3da61e066ebb2f88a000000000000611871565b60048310611c0557611b766000600984751aba4714957d300d0e549208b31adb100000000000007406d79f82328ea3da61e066ebb2f88a000000000000611871565b50600092915050565b60006103e88210611c1e57600080fd5b507406d79f82328ea3da61e066ebb2f88a0000000000000290565b6000600a8210611c4857600080fd5b50751aba4714957d300d0e549208b31adb100000000000000290565b600060048310611c0557611b7660006009847728c87cb5c89a2571ebfdcb54864ada834a00000000000000766867a5a867f103b2fffa5a71fba0e7b680000000000000611871565b600060648210611cbb57600080fd5b50766867a5a867f103b2fffa5a71fba0e7b6800000000000000290565b6000612710620186a0835b06811515611ced57fe5b0492915050565b612710900690565b60007301c06a5ec5433c60ddaa16406f5a40000000000073af298d050e4395d69670b12b7f4100000000000083611ce3565b600072047bf19673df52e37f2410011d1000000000007301c06a5ec5433c60ddaa16406f5a40000000000083611ce3565b6000710b7abc627050305adf14a3d9e4000000000072047bf19673df52e37f2410011d10000000000083611ce3565b600076010b46c6cdd6e3e0828f4db456ff0c8ea0000000000000766867a5a867f103b2fffa5a71fba0e7b68000000000000083611ce3565b600073af298d050e4395d69670b12b7f410000000000007406d79f82328ea3da61e066ebb2f88a00000000000083611ce3565b6000620186a06305f5e10083611ce3565b6000751aba4714957d300d0e549208b31adb1000000000000076010b46c6cdd6e3e0828f4db456ff0c8ea000000000000083611ce3565b60007406d79f82328ea3da61e066ebb2f88a000000000000751aba4714957d300d0e549208b31adb1000000000000083611ce3565b6000766867a5a867f103b2fffa5a71fba0e7b6800000000000007728c87cb5c89a2571ebfdcb54864ada834a0000000000000083611ce3565b60006305f5e10064174876e80083611ce3565b600064174876e800655af3107a400083611ce3565b6000655af3107a400067016345785d8a000083611ce3565b600067016345785d8a000068056bc75e2d6310000083611ce3565b600068056bc75e2d6310000069152d02c7e14af680000083611ce3565b600069152d02c7e14af68000006a52b7d2dcc80cd2e400000083611ce3565b60006a52b7d2dcc80cd2e40000006c01431e0fae6d7217caa000000083611ce3565b60006c01431e0fae6d7217caa00000006d04ee2d6d415b85acef810000000083611ce3565b60006d04ee2d6d415b85acef81000000006e01ed09bead87c0378d8e640000000083611ce3565b60006e01ed09bead87c0378d8e64000000006ec097ce7bc90715b34b9f100000000083611ce3565b60006ec097ce7bc90715b34b9f10000000006f4b3b4ca85a86c47a098a22400000000083611ce3565b60006f4b3b4ca85a86c47a098a224000000000701d6329f1c35ca4bfabb9f561000000000083611ce3565b6000701d6329f1c35ca4bfabb9f5610000000000710b7abc627050305adf14a3d9e4000000000083611ce3565b60008080866002850615156120725750949594855b6002600a86040615156120855750939493845b6002606486040615156120985750949594855b509596949550929392505050565b6000606482106120b557600080fd5b507301c06a5ec5433c60ddaa16406f5a4000000000000290565b6000606482106120de57600080fd5b5072047bf19673df52e37f2410011d1000000000000290565b60006064821061210657600080fd5b50710b7abc627050305adf14a3d9e400000000000290565b60006064821061212d57600080fd5b5076010b46c6cdd6e3e0828f4db456ff0c8ea00000000000000290565b6102606040519081016040526013815b60008152600019909101906020018161215a57905050905600a165627a7a723058200e90d58e89b7efd7bd1ed065f327a65956e9bdc8f71bfaecfc3fd33ba38fe0970029000000000000000000000000d79b3d20bf9e9d54c4da992fda0b52861fb6757500000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000038300000000000000000000000000000000000000000000000000000000000023180000000000000000000000000000000000000000000000000000000000015efd00000000000000000000000000000000000000000000000000000000000db88f",
  "constructorArguments": "000000000000000000000000d79b3d20bf9e9d54c4da992fda0b52861fb6757500000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000038300000000000000000000000000000000000000000000000000000000000023180000000000000000000000000000000000000000000000000000000000015efd00000000000000000000000000000000000000000000000000000000000db88f"
}