{
  "address": "0xA503F99b58baDC9c4b647D7dBf3aA4f6C29d4415",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "ProductStorage",
  "compilerVersion": "v0.5.8+commit.23d335f2",
  "optimization": false,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "// Written by Ermin Nurovic <[emailÂ protected]>\n\npragma solidity ^0.5.8;\n\nimport \"./Ownable.sol\";\nimport \"./SafeMath.sol\";\nimport \"./ReentrancyGuard.sol\";\n\ncontract CreateBuyDistribute is Ownable, ReentrancyGuard {\n\n    using SafeMath for uint256;\n    using SafeMath for uint32;\n    using SafeMath for uint8;\n\n    uint256 public dayOfLastActivity;\n    uint8 public numberOfAddressesToPay;\n    uint8 public randomPayCreatorOnceEvery;\n\n    // Buyer details including how much buyer has paid for a product and when the buyer has either contributed or\n    // had the dividend paid out.\n    struct Buyer {\n    \tuint256 contribution;\n    \tuint256 totalAtPurchase;\n    \tuint256 dividendPaid;\n    \taddress payable buyerNext;  // next buyer for creating circular linked list allowing Buyer payout\n        address payable buyerPrev;  // previous buyer for creating circular linked list allowing Buyer payout\n    }\n\n    // Product details including the creator cut percentage and nested with the Buyers.\n    struct Product {\n        address payable creator;\n        address payable buyerNextPayout;\n        address payable buyerPrevPayout;\n        bytes32 productName1;\n        bytes32 productName2;\n        uint256 productPrice;\n        uint256 totalPaid;\n        uint256 creatorPaidAmount;\n        uint256 leftoverDividend;\n        uint256 totalAtLeftoverUpdate;\n        uint256 ownerPaidAmount;\n        uint32 dayOfLastActivity;\n        uint32 creatorCut;\n        uint32 multiplier;\n        mapping (address => Buyer) buyer;\n    }\n\n    mapping (address => Product) public product;\n    mapping (address => address) public productNext;\n    mapping (address => address) public productPrev;\n\n    constructor() public {\n        numberOfAddressesToPay = 5;\n        randomPayCreatorOnceEvery = 1;\n        dayOfLastActivity = now.div(1 days).sub(182);\n    }\n\n    event productCreated(address productAddress, bytes32 name1, bytes32 name2, uint8 creatorCut, uint8 multiplier, uint256 price);\n    event productBought(address productAddress, address buyerAddress, uint256 totalPaid, uint256 totalAtPurchase);\n    event productDeleted(address productAddress);\n    event buyerClosed(address productAddress, address buyerAddress);\n\n    function endContract() external onlyOwner {\n        require((now.div(1 days)) >= (dayOfLastActivity.add(182)));\n        selfdestruct(msg.sender);\n    }\n\n    function payAddresses(uint8 _numberOfAddressesToPay, uint8 _randomPayCreatorOnceEvery) external onlyOwner {\n        numberOfAddressesToPay = _numberOfAddressesToPay;\n        randomPayCreatorOnceEvery = _randomPayCreatorOnceEvery;\n    }\n\n    function getBuyer(address _productAddress, address _buyerAddress) external view returns (uint256 contribution, uint256 totalAtPurchase, uint256 dividendPaid, address buyerPrev) {\n        contribution = product[_productAddress].buyer[_buyerAddress].contribution;\n        totalAtPurchase = product[_productAddress].buyer[_buyerAddress].totalAtPurchase;\n        dividendPaid = product[_productAddress].buyer[_buyerAddress].dividendPaid;\n        buyerPrev = product[_productAddress].buyer[_buyerAddress].buyerPrev;\n        // buyerNext = product[_productAddress].buyer[_buyerAddress].buyerNext;\n    }\n\n    function productPrice(address _productAddress, uint256 _productPrice) external {\n        require((msg.sender == product[_productAddress].creator) && (_productPrice >= 1000));\n        product[_productAddress].productPrice = _productPrice;\n    }\n\n    function getCreatorAddress(address _productAddress) external view returns (address payable) {\n        return product[_productAddress].creator;\n    }\n\n    //Creates a new product\n    function createProduct(bytes32 _productName1, bytes32 _productName2, uint _productPrice, uint8 _creatorCut, uint8 _buyerMultiplier) public {\n        require(_buyerMultiplier >= 2 && _buyerMultiplier <= 5);\n        require(_creatorCut >= 0 && _creatorCut <= 80);\n        require(_productPrice >= 1000);\n\n        dayOfLastActivity = now.div(1 days);\n\n        ProductStorage productAddress = new ProductStorage();\n        if (!(productPrev[address(0)] == address(0))) { // not the first product ever created\n            productNext[productPrev[address(0)]] = address(productAddress);\n            productPrev[address(productAddress)] = productPrev[address(0)];\n            productPrev[address(0)] = address(productAddress);\n        } else { // first product ever\n            productPrev[address(0)] = address(productAddress);\n            productNext[address(0)] = address(productAddress);\n        }\n        product[address(productAddress)].productName1 = _productName1;\n        product[address(productAddress)].productName2 = _productName2;\n        product[address(productAddress)].productPrice = _productPrice;\n        product[address(productAddress)].creatorCut = _creatorCut;\n        product[address(productAddress)].multiplier = _buyerMultiplier;\n        product[address(productAddress)].buyerNextPayout = address(0);\n        product[address(productAddress)].buyerPrevPayout = address(0);\n        product[address(productAddress)].creator = msg.sender;\n        product[address(productAddress)].dayOfLastActivity = uint32(now.div(1 days));\n\n        emit productCreated(address(productAddress), _productName1, _productName2, _creatorCut, _buyerMultiplier, _productPrice);\n    }\n\n    function deleteProduct(address payable _productAddress) public {\n        require(((now.div(1 days)) >= (product[_productAddress].dayOfLastActivity.add(182))) ||\n        ((product[_productAddress].creator == msg.sender) && (product[_productAddress].totalPaid == 0)));\n        // remove product from linked list\n        productPrev[productNext[_productAddress]] =\n        productPrev[productPrev[productNext[_productAddress]]];\n        productNext[productPrev[_productAddress]] =\n        productNext[productNext[productPrev[_productAddress]]];\n        delete productNext[_productAddress];\n        delete productPrev[_productAddress];\n        // Delete buyer mappings from product\n        address buyerToDelete = address(0);\n        address buyerToDeleteNext = product[_productAddress].buyer[buyerToDelete].buyerNext;\n        buyerToDelete = buyerToDeleteNext;\n        buyerToDeleteNext = product[_productAddress].buyer[buyerToDelete].buyerNext;\n        do {\n            delete product[_productAddress].buyer[buyerToDelete];\n            buyerToDelete = buyerToDeleteNext;\n            buyerToDeleteNext = product[_productAddress].buyer[buyerToDelete].buyerNext;\n        } while(buyerToDeleteNext != address(0));\n        // Set totalPaid to 0 for re-entrancy protection\n        product[_productAddress].totalPaid = 0;\n        product[_productAddress].totalAtLeftoverUpdate = 0;\n        // pay creator with any leftover funds\n        ProductStorage PS = ProductStorage(_productAddress);\n        PS.payTo(address(PS).balance, product[_productAddress].creator);\n        // delete product struct\n        delete product[_productAddress];\n        // delete product contract\n        PS.close();\n\n        emit productDeleted(_productAddress);\n    }\n\n    // Used for buying a product then calls function to pay dividend to other buyers.\n    function buyProduct(address payable _productAddress, address payable _buyerAddress, uint _value) external nonReentrant {\n        require(product[_productAddress].creator != address(0));\n        require(_value >= product[_productAddress].productPrice);\n        require(msg.sender == _productAddress);\n\n        uint contributionValue;\n        contributionValue = _value.mul((uint8(100).sub(product[_productAddress].creatorCut).sub(3)));\n        contributionValue = contributionValue.div(100);\n\n        if (product[_productAddress].buyer[_buyerAddress].contribution == 0) {\n            // Buyer had not bought this product before.\n            if (product[_productAddress].buyer[address(0)].buyerNext == address(0)) {\n                // First ever buyer of this product.\n                product[_productAddress].buyer[address(0)].buyerNext = _buyerAddress;\n                product[_productAddress].buyer[address(0)].buyerPrev = _buyerAddress;\n            } else {\n                product[_productAddress].buyer[\n                    product[_productAddress].buyer[address(0)].buyerPrev\n                ].buyerNext = _buyerAddress;\n                product[_productAddress].buyer[_buyerAddress].buyerPrev = product[_productAddress].buyer[address(0)].buyerPrev;\n                product[_productAddress].buyer[address(0)].buyerPrev = _buyerAddress;\n            }\n\n            // Record product total for first time buyer\n            product[_productAddress].buyer[_buyerAddress].totalAtPurchase = product[_productAddress].totalPaid;\n\n        } else {\n            // Buyer has purchased this product before.\n            uint _newTotalAtPurchase;\n            _newTotalAtPurchase = product[_productAddress].totalPaid.sub(product[_productAddress].buyer[_buyerAddress].totalAtPurchase);\n            _newTotalAtPurchase = _newTotalAtPurchase.sub(product[_productAddress].buyer[_buyerAddress].contribution);\n            _newTotalAtPurchase = _newTotalAtPurchase.mul(contributionValue);\n            _newTotalAtPurchase = _newTotalAtPurchase.div(product[_productAddress].buyer[_buyerAddress].contribution.add(contributionValue));\n            _newTotalAtPurchase = _newTotalAtPurchase.add(product[_productAddress].buyer[_buyerAddress].totalAtPurchase);\n            product[_productAddress].buyer[_buyerAddress].totalAtPurchase = _newTotalAtPurchase;\n        }\n        // Add buyer contribution value\n        product[_productAddress].buyer[_buyerAddress].contribution = product[_productAddress].buyer[_buyerAddress].contribution.add(contributionValue);\n\n        // Add contribution to the total product contribution\n        product[_productAddress].totalPaid = product[_productAddress].totalPaid.add(contributionValue);\n\n        // Update day of last activity for product\n        product[_productAddress].dayOfLastActivity = uint32(now.div(1 days));\n\n        // Pay creator cut every random number of transactions\n        uint randomPayCreator;\n        if (randomPayCreatorOnceEvery > 0) {\n            randomPayCreator = uint(keccak256(abi.encodePacked(now, _productAddress))) % randomPayCreatorOnceEvery;\n        }\n        if ((randomPayCreator == 1) || (randomPayCreatorOnceEvery == 1)) {\n            payCreatorCut(_productAddress);\n        } else {\n            randomPayCreator = 0;\n        }\n\n        // Pay dividend to previous buyers\n        if (numberOfAddressesToPay > 0) {\n            uint8 _didPay;\n            address payable _buyerNext = product[_productAddress].buyerNextPayout;\n            address payable _buyerPrev = product[_productAddress].buyerPrevPayout;\n            // Cycle in both direction of previous buyers to pay out\n            for (uint i = 0; i < (numberOfAddressesToPay.sub(randomPayCreator)); i++) {\n                _didPay = 0;\n                if (uint(keccak256(abi.encodePacked(now, _productAddress, i))) % 2 == 1) {\n                    _buyerNext = product[_productAddress].buyer[_buyerNext].buyerNext;\n                    if(_buyerNext != address(0)) {\n                        _didPay = payDividendToBuyer(_productAddress, _buyerNext);\n                    }\n                } else {\n                    _buyerPrev = product[_productAddress].buyer[_buyerPrev].buyerPrev;\n                    if(_buyerPrev != address(0)) {\n                        _didPay = payDividendToBuyer(_productAddress, _buyerPrev);\n                    }\n                }\n                i += _didPay;\n            }\n            product[_productAddress].buyerNextPayout = _buyerNext;\n            product[_productAddress].buyerPrevPayout = _buyerPrev;\n        }\n\n        emit productBought(_productAddress, _buyerAddress, product[_productAddress].totalPaid, product[_productAddress].buyer[_buyerAddress].totalAtPurchase);\n    }\n\n    // Pay dividend to buyer\n    function payDividendToBuyer(address payable _productAddress, address payable _buyerAddress) public returns (uint8 didPay) {\n        didPay = 0;\n        if (product[_productAddress].buyer[_buyerAddress].contribution > 0) {\n            uint totalPaidAdjusted = product[_productAddress].totalPaid.add(product[_productAddress].leftoverDividend.mul(product[_productAddress].totalPaid.sub(product[_productAddress].totalAtLeftoverUpdate)).div(product[_productAddress].totalPaid));\n            uint dividend = product[_productAddress].buyer[_buyerAddress].totalAtPurchase.div(2);\n            dividend = dividend.add(product[_productAddress].buyer[_buyerAddress].contribution.div(4));\n            dividend = dividend.mul(product[_productAddress].multiplier.mul(105)).div(100 - product[_productAddress].creatorCut - 3);\n            if (totalPaidAdjusted > dividend) {\n                dividend = totalPaidAdjusted.sub(dividend);\n                dividend = dividend.mul(product[_productAddress].buyer[_buyerAddress].contribution);\n                dividend = dividend.div(totalPaidAdjusted);\n                dividend = dividend.mul(product[_productAddress].multiplier.mul(105)).div(100 - product[_productAddress].creatorCut - 3);\n                if (dividend > product[_productAddress].buyer[_buyerAddress].dividendPaid) { // buyer has some dividend owing. pay the buyer\n                    dividend = dividend.sub(product[_productAddress].buyer[_buyerAddress].dividendPaid);\n                    product[_productAddress].buyer[_buyerAddress].dividendPaid = product[_productAddress].buyer[_buyerAddress].dividendPaid.add(dividend);\n                    ProductStorage PS = ProductStorage(_productAddress);\n                    if (PS.payTo(dividend, _buyerAddress)) {\n                        didPay = 1;\n                    } else {\n                        product[_productAddress].buyer[_buyerAddress].dividendPaid = product[_productAddress].buyer[_buyerAddress].dividendPaid.sub(dividend);\n                        didPay = 0;\n                    }\n                }\n            } else didPay = 0;\n            // check if buyer's dividend is paid out past the multiplier limit\n            uint maximumToBePaid = product[_productAddress].buyer[_buyerAddress].contribution.mul(product[_productAddress].multiplier.mul(100)).div(100 - product[_productAddress].creatorCut - 3);\n            // check if buyer should be closed out\n            if (product[_productAddress].buyer[_buyerAddress].dividendPaid >= maximumToBePaid) {  // pay back  multiplier amount before closing out buyer\n                // move remaining funds to a side pot\n                uint originalLeftoverDividend = product[_productAddress].leftoverDividend;\n                maximumToBePaid = maximumToBePaid.mul(105).div(100);\n                product[_productAddress].leftoverDividend = originalLeftoverDividend.add(maximumToBePaid).sub(product[_productAddress].buyer[_buyerAddress].dividendPaid);\n                product[_productAddress].totalAtLeftoverUpdate = (product[_productAddress].totalAtLeftoverUpdate.mul(originalLeftoverDividend).div(product[_productAddress].leftoverDividend)).add((product[_productAddress].totalPaid.mul(maximumToBePaid.sub(product[_productAddress].buyer[_buyerAddress].dividendPaid)).div(product[_productAddress].leftoverDividend)));\n                // delete buyer details\n                deleteBuyer(_productAddress, _buyerAddress);\n                emit buyerClosed(_productAddress, _buyerAddress);\n            }\n\n        }\n        return didPay;\n    }\n\n    // Pay the creator's cut as per the percentage cut specified in the product\n    function payCreatorCut(address payable _productAddress) public {\n        uint payCreatorAmount = product[_productAddress].totalPaid.div(100 - product[_productAddress].creatorCut - 3);\n        payCreatorAmount = payCreatorAmount.mul(product[_productAddress].creatorCut);\n        payCreatorAmount = payCreatorAmount.sub(product[_productAddress].creatorPaidAmount);\n        product[_productAddress].creatorPaidAmount = product[_productAddress].creatorPaidAmount.add(payCreatorAmount);\n        ProductStorage PS = ProductStorage(_productAddress);\n        PS.payTo(payCreatorAmount, product[_productAddress].creator);\n    }\n\n    // Pay the owner's cut\n    function payOwnerCut(address payable _productAddress) public {\n        uint payOwnerAmount = product[_productAddress].totalPaid.div(100 - product[_productAddress].creatorCut - 3);\n        payOwnerAmount = payOwnerAmount.mul(3);\n        payOwnerAmount = payOwnerAmount.sub(product[_productAddress].ownerPaidAmount);\n        product[_productAddress].ownerPaidAmount = product[_productAddress].creatorPaidAmount.add(payOwnerAmount);\n        ProductStorage PS = ProductStorage(_productAddress);\n        PS.payTo(payOwnerAmount, owner());\n    }\n\n    // Delete a buyer from ProductStorage, close the mapping link gap\n    function deleteBuyer(address _productAddress, address _buyerAddress) private {\n        product[_productAddress].buyer[\n            product[_productAddress].buyer[_buyerAddress].buyerNext\n        ].buyerPrev =\n        product[_productAddress].buyer[\n            product[_productAddress].buyer[\n                product[_productAddress].buyer[_buyerAddress].buyerNext\n            ].buyerPrev\n        ].buyerPrev;\n\n        product[_productAddress].buyer[\n            product[_productAddress].buyer[_buyerAddress].buyerPrev\n        ].buyerNext =\n        product[_productAddress].buyer[\n            product[_productAddress].buyer[\n                product[_productAddress].buyer[_buyerAddress].buyerPrev\n            ].buyerNext\n        ].buyerNext;\n\n        delete product[_productAddress].buyer[_buyerAddress];\n    }\n}\n\ncontract ProductStorage {\n\n    CreateBuyDistribute public CBD;\n\n    constructor() public {\n        CBD = CreateBuyDistribute(msg.sender);\n    }\n\n    function () external payable {\n        CBD.buyProduct(address(this), msg.sender, msg.value);\n    }\n\n    function payFrom(address payable _fromAddress) external payable {\n        CBD.buyProduct(address(this), _fromAddress, msg.value);\n    }\n\n    function payTo(uint _value,address payable _address) external returns (bool transferred) {\n        require(msg.sender == address(CBD));\n        if (!_address.send(_value)) {\n            return false;\n        } else return true;\n    }\n\n    function close() public {\n        require(msg.sender == address(CBD));\n        selfdestruct(CBD.getCreatorAddress(address(this)));\n    }\n}\n",
  "bytecode": "608060405234801561001057600080fd5b50336000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550610594806100606000396000f3fe60806040526004361061003f5760003560e01c80632a7cd7b91461013557806343d726d6146101a857806348cca690146101bf578063bb1ff80514610203575b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16635008b7dd3033346040518463ffffffff1660e01b8152600401808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018281526020019350505050600060405180830381600087803b15801561011b57600080fd5b505af115801561012f573d6000803e3d6000fd5b50505050005b34801561014157600080fd5b5061018e6004803603604081101561015857600080fd5b8101908080359060200190929190803573ffffffffffffffffffffffffffffffffffffffff16906020019092919050505061025a565b604051808215151515815260200191505060405180910390f35b3480156101b457600080fd5b506101bd610302565b005b610201600480360360208110156101d557600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919050505061044c565b005b34801561020f57600080fd5b50610218610543565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146102b557600080fd5b8173ffffffffffffffffffffffffffffffffffffffff166108fc849081150290604051600060405180830381858888f193505050506102f757600090506102fc565b600190505b92915050565b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461035b57600080fd5b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663c082c30c306040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b1580156103f957600080fd5b505afa15801561040d573d6000803e3d6000fd5b505050506040513d602081101561042357600080fd5b810190808051906020019092919050505073ffffffffffffffffffffffffffffffffffffffff16ff5b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16635008b7dd3083346040518463ffffffff1660e01b8152600401808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018281526020019350505050600060405180830381600087803b15801561052857600080fd5b505af115801561053c573d6000803e3d6000fd5b5050505050565b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff168156fea165627a7a723058201955a8728b8ce915707606bafddaeca43b5011e4f33fab67e90e4ae300606f990029"
}