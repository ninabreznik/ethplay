{
  "address": "0x912a9876fa019405323db79a6863314ee9c899b6",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "TOS",
  "compilerVersion": "v0.4.11+commit.68ef5810",
  "optimization": false,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "pragma solidity ^0.4.11;\n\ncontract Owned {\n\n    address public owner;\n\n    function Owned() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function setOwner(address _newOwner) onlyOwner {\n        owner = _newOwner;\n    }\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n    uint256 c = a * b;\n    assert(a == 0 || c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n\n  function toUINT112(uint256 a) internal constant returns(uint112) {\n    assert(uint112(a) == a);\n    return uint112(a);\n  }\n\n  function toUINT120(uint256 a) internal constant returns(uint120) {\n    assert(uint120(a) == a);\n    return uint120(a);\n  }\n\n  function toUINT128(uint256 a) internal constant returns(uint128) {\n    assert(uint128(a) == a);\n    return uint128(a);\n  }\n}\n\n\n// Abstract contract for the full ERC 20 Token standard\n// https://github.com/ethereum/EIPs/issues/20\n\ncontract Token {\n    /* This is a slight change to the ERC20 base standard.\n    function totalSupply() constant returns (uint256 supply);\n    is replaced with:\n    uint256 public totalSupply;\n    This automatically creates a getter function for the totalSupply.\n    This is moved to the base contract since public getter functions are not\n    currently recognised as an implementation of the matching abstract\n    function by the compiler.\n    */\n    /// total amount of tokens\n    //uint256 public totalSupply;\n    function totalSupply() constant returns (uint256 supply);\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return The balance\n    function balanceOf(address _owner) constant returns (uint256 balance);\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return Whether the transfer was successful or not\n    function transfer(address _to, uint256 _value) returns (bool success);\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of wei to be approved for transfer\n    /// @return Whether the approval was successful or not\n    function approve(address _spender, uint256 _value) returns (bool success);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens allowed to spent\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\n/// TOS token, ERC20 compliant\ncontract TOS is Token, Owned {\n    using SafeMath for uint256;\n\n    string public constant name    = \"TOS Token\";  //The Token's name\n    uint8 public constant decimals = 18;               //Number of decimals of the smallest unit\n    string public constant symbol  = \"TOS\";            //An identifier    \n\n    // packed to 256bit to save gas usage.\n    struct Supplies {\n        // uint128's max value is about 3e38.\n        // it's enough to present amount of tokens\n        uint128 total;\n        uint128 rawTokens;\n    }\n\n    Supplies supplies;\n\n    // Packed to 256bit to save gas usage.    \n    struct Account {\n        // uint112's max value is about 5e33.\n        // it's enough to present amount of tokens\n        uint112 balance;\n\n        // raw token can be transformed into balance with bonus        \n        uint112 rawTokens;\n\n        // safe to store timestamp\n        uint32 lastMintedTimestamp;\n    }\n\n    // Balances for each account\n    mapping(address => Account) accounts;\n\n    // Owner of account approves the transfer of an amount to another account\n    mapping(address => mapping(address => uint256)) allowed;\n\n    // bonus that can be shared by raw tokens\n    uint256 bonusOffered;\n\n    // Constructor\n    function TOS() {\n    }\n\n    function totalSupply() constant returns (uint256 supply){\n        return supplies.total;\n    }\n\n    // Send back ether sent to me\n    function () {\n        revert();\n    }\n\n    // If sealed, transfer is enabled and mint is disabled\n    function isSealed() constant returns (bool) {\n        return owner == 0;\n    }\n\n    function lastMintedTimestamp(address _owner) constant returns(uint32) {\n        return accounts[_owner].lastMintedTimestamp;\n    }\n\n    // Claim bonus by raw tokens\n    function claimBonus(address _owner) internal{      \n        require(isSealed());\n        if (accounts[_owner].rawTokens != 0) {\n            uint256 realBalance = balanceOf(_owner);\n            uint256 bonus = realBalance\n                .sub(accounts[_owner].balance)\n                .sub(accounts[_owner].rawTokens);\n\n            accounts[_owner].balance = realBalance.toUINT112();\n            accounts[_owner].rawTokens = 0;\n            if(bonus > 0){\n                Transfer(this, _owner, bonus);\n            }\n        }\n    }\n\n    // What is the balance of a particular account?\n    function balanceOf(address _owner) constant returns (uint256 balance) {\n        if (accounts[_owner].rawTokens == 0)\n            return accounts[_owner].balance;\n\n        if (bonusOffered > 0) {\n            uint256 bonus = bonusOffered\n                 .mul(accounts[_owner].rawTokens)\n                 .div(supplies.rawTokens);\n\n            return bonus.add(accounts[_owner].balance)\n                    .add(accounts[_owner].rawTokens);\n        }\n        \n        return uint256(accounts[_owner].balance)\n            .add(accounts[_owner].rawTokens);\n    }\n\n    // Transfer the balance from owner's account to another account\n    function transfer(address _to, uint256 _amount) returns (bool success) {\n        require(isSealed());\n\n        // implicitly claim bonus for both sender and receiver\n        claimBonus(msg.sender);\n        claimBonus(_to);\n\n        // according to TOS's total supply, never overflow here\n        if (accounts[msg.sender].balance >= _amount\n            && _amount > 0) {            \n            accounts[msg.sender].balance -= uint112(_amount);\n            accounts[_to].balance = _amount.add(accounts[_to].balance).toUINT112();\n            Transfer(msg.sender, _to, _amount);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // Send _value amount of tokens from address _from to address _to\n    // The transferFrom method is used for a withdraw workflow, allowing contracts to send\n    // tokens on your behalf, for example to \"deposit\" to a contract address and/or to charge\n    // fees in sub-currencies; the command should fail unless the _from account has\n    // deliberately authorized the sender of the message via some mechanism; we propose\n    // these standardized APIs for approval:\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) returns (bool success) {\n        require(isSealed());\n\n        // implicitly claim bonus for both sender and receiver\n        claimBonus(_from);\n        claimBonus(_to);\n\n        // according to TOS's total supply, never overflow here\n        if (accounts[_from].balance >= _amount\n            && allowed[_from][msg.sender] >= _amount\n            && _amount > 0) {\n            accounts[_from].balance -= uint112(_amount);\n            allowed[_from][msg.sender] -= _amount;\n            accounts[_to].balance = _amount.add(accounts[_to].balance).toUINT112();\n            Transfer(_from, _to, _amount);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n    // If this function is called again it overwrites the current allowance with _value.\n    function approve(address _spender, uint256 _amount) returns (bool success) {\n        allowed[msg.sender][_spender] = _amount;\n        Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    /* Approves and then calls the receiving contract */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n        //if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\n        ApprovalReceiver(_spender).receiveApproval(msg.sender, _value, this, _extraData);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    // Mint tokens and assign to some one\n    function mint(address _owner, uint256 _amount, bool _isRaw, uint32 timestamp) onlyOwner{\n        if (_isRaw) {\n            accounts[_owner].rawTokens = _amount.add(accounts[_owner].rawTokens).toUINT112();\n            supplies.rawTokens = _amount.add(supplies.rawTokens).toUINT128();\n        } else {\n            accounts[_owner].balance = _amount.add(accounts[_owner].balance).toUINT112();\n        }\n\n        accounts[_owner].lastMintedTimestamp = timestamp;\n\n        supplies.total = _amount.add(supplies.total).toUINT128();\n        Transfer(0, _owner, _amount);\n    }\n    \n    // Offer bonus to raw tokens holder\n    function offerBonus(uint256 _bonus) onlyOwner { \n        bonusOffered = bonusOffered.add(_bonus);\n        supplies.total = _bonus.add(supplies.total).toUINT128();\n        Transfer(0, this, _bonus);\n    }\n\n    // Set owner to zero address, to disable mint, and enable token transfer\n    function seal() onlyOwner {\n        setOwner(0);\n    }\n}\n\ncontract ApprovalReceiver {\n    function receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData);\n}\n\n\n// Contract to sell and distribute TOS tokens\ncontract TOSSale is Owned{\n\n    /// chart of stage transition \n    ///\n    /// deploy   initialize      startTime                            endTime                 finalize\n    ///                              | <-earlyStageLasts-> |             | <- closedStageLasts -> |\n    ///  O-----------O---------------O---------------------O-------------O------------------------O------------>\n    ///     Created     Initialized           Early             Normal             Closed            Finalized\n    enum Stage {\n        NotCreated,\n        Created,\n        Initialized,\n        Early,\n        Normal,\n        Closed,\n        Finalized\n    }\n\n    using SafeMath for uint256;\n    \n    uint256 public constant totalSupply         = (10 ** 9) * (10 ** 18); // 1 billion TOS, decimals set to 18\n\n    uint256 constant privateSupply              = totalSupply * 9 / 100;  // 9% for private ICO\n    uint256 constant commercialPlan             = totalSupply * 23 / 100; // 23% for commercial plan\n    uint256 constant reservedForTeam            = totalSupply * 5 / 100;  // 5% for team\n    uint256 constant reservedForOperations      = totalSupply * 22 / 100; // 22 for operations\n\n    // 59%\n    uint256 public constant nonPublicSupply     = privateSupply + commercialPlan + reservedForTeam + reservedForOperations;\n    // 41%\n    uint256 public constant publicSupply = totalSupply - nonPublicSupply;\n\n\n    uint256 public constant officialLimit = 64371825 * (10 ** 18);\n    uint256 public constant channelsLimit = publicSupply - officialLimit;\n\n    // packed to 256bit\n    struct SoldOut {\n        uint16 placeholder; // placeholder to make struct pre-alloced\n\n        // amount of tokens officially sold out.\n        // max value of 120bit is about 1e36, it's enough for token amount\n        uint120 official; \n\n        uint120 channels; // amount of tokens sold out via channels\n    }\n\n    SoldOut soldOut;\n    \n    uint256 constant tosPerEth = 3500;  // normal exchange rate\n    uint256 constant tosPerEthEarlyStage = tosPerEth + tosPerEth * 15 / 100;  // early stage has 15% reward\n\n    uint constant minBuyInterval = 30 minutes; // each account can buy once in 30 minutes\n    uint constant maxBuyEthAmount = 30 ether;\n   \n    TOS tos; // TOS token contract follows ERC20 standard\n\n    address ethVault; // the account to keep received ether\n    address tosVault; // the account to keep non-public offered TOS tokens\n\n    uint public constant startTime = 1503057600; // time to start sale\n    uint public constant endTime = 1504180800;   // tiem to close sale\n    uint public constant earlyStageLasts = 3 days; // early bird stage lasts in seconds\n\n    bool initialized;\n    bool finalized;\n\n    function TOSSale() {\n        soldOut.placeholder = 1;\n    }    \n\n    /// @notice calculte exchange rate according to current stage\n    /// @return exchange rate. zero if not in sale.\n    function exchangeRate() constant returns (uint256){\n        if (stage() == Stage.Early) {\n            return tosPerEthEarlyStage;\n        }\n        if (stage() == Stage.Normal) {\n            return tosPerEth;\n        }\n        return 0;\n    }\n\n    /// @notice for test purpose\n    function blockTime() constant returns (uint32) {\n        return uint32(block.timestamp);\n    }\n\n    /// @notice estimate stage\n    /// @return current stage\n    function stage() constant returns (Stage) { \n        if (finalized) {\n            return Stage.Finalized;\n        }\n\n        if (!initialized) {\n            // deployed but not initialized\n            return Stage.Created;\n        }\n\n        if (blockTime() < startTime) {\n            // not started yet\n            return Stage.Initialized;\n        }\n\n        if (uint256(soldOut.official).add(soldOut.channels) >= publicSupply) {\n            // all sold out\n            return Stage.Closed;\n        }\n\n        if (blockTime() < endTime) {\n            // in sale            \n            if (blockTime() < startTime.add(earlyStageLasts)) {\n                // early bird stage\n                return Stage.Early;\n            }\n            // normal stage\n            return Stage.Normal;\n        }\n\n        // closed\n        return Stage.Closed;\n    }\n\n    function isContract(address _addr) constant internal returns(bool) {\n        uint size;\n        if (_addr == 0) return false;\n        assembly {\n            size := extcodesize(_addr)\n        }\n        return size > 0;\n    }\n\n    /// @notice entry to buy tokens\n    function () payable {        \n        buy();\n    }\n\n    /// @notice entry to buy tokens\n    function buy() payable {\n        // reject contract buyer to avoid breaking interval limit\n        require(!isContract(msg.sender));\n        require(msg.value >= 0.01 ether);\n\n        uint256 rate = exchangeRate();\n        // here don't need to check stage. rate is only valid when in sale\n        require(rate > 0);\n        // each account is allowed once in minBuyInterval\n        require(blockTime() >= tos.lastMintedTimestamp(msg.sender) + minBuyInterval);\n\n        uint256 requested;\n        // and limited to maxBuyEthAmount\n        if (msg.value > maxBuyEthAmount) {\n            requested = maxBuyEthAmount.mul(rate);\n        } else {\n            requested = msg.value.mul(rate);\n        }\n\n        uint256 remained = officialLimit.sub(soldOut.official);\n        if (requested > remained) {\n            //exceed remained\n            requested = remained;\n        }\n\n        uint256 ethCost = requested.div(rate);\n        if (requested > 0) {\n            tos.mint(msg.sender, requested, true, blockTime());\n            // transfer ETH to vault\n            ethVault.transfer(ethCost);\n\n            soldOut.official = requested.add(soldOut.official).toUINT120();\n            onSold(msg.sender, requested, ethCost);        \n        }\n\n        uint256 toReturn = msg.value.sub(ethCost);\n        if(toReturn > 0) {\n            // return over payed ETH\n            msg.sender.transfer(toReturn);\n        }        \n    }\n\n    /// @notice returns tokens sold officially\n    function officialSold() constant returns (uint256) {\n        return soldOut.official;\n    }\n\n    /// @notice returns tokens sold via channels\n    function channelsSold() constant returns (uint256) {\n        return soldOut.channels;\n    } \n\n    /// @notice manually offer tokens to channel\n    function offerToChannel(address _channelAccount, uint256 _tosAmount) onlyOwner {\n        Stage stg = stage();\n        // since the settlement may be delayed, so it's allowed in closed stage\n        require(stg == Stage.Early || stg == Stage.Normal || stg == Stage.Closed);\n\n        soldOut.channels = _tosAmount.add(soldOut.channels).toUINT120();\n\n        //should not exceed limit\n        require(soldOut.channels <= channelsLimit);\n\n        tos.mint(\n            _channelAccount,\n            _tosAmount,\n            true,  // unsold tokens can be claimed by channels portion\n            blockTime()\n            );\n\n        onSold(_channelAccount, _tosAmount, 0);\n    }\n\n    /// @notice initialize to prepare for sale\n    /// @param _tos The address TOS token contract following ERC20 standard\n    /// @param _ethVault The place to store received ETH\n    /// @param _tosVault The place to store non-publicly supplied TOS tokens\n    function initialize(\n        TOS _tos,\n        address _ethVault,\n        address _tosVault) onlyOwner {\n        require(stage() == Stage.Created);\n\n        // ownership of token contract should already be this\n        require(_tos.owner() == address(this));\n\n        require(address(_ethVault) != 0);\n        require(address(_tosVault) != 0);      \n\n        tos = _tos;\n        \n        ethVault = _ethVault;\n        tosVault = _tosVault;    \n        \n        tos.mint(\n            tosVault,\n            reservedForTeam.add(reservedForOperations),\n            false, // team and operations reserved portion can't share unsold tokens\n            blockTime()\n        );\n\n        tos.mint(\n            tosVault,\n            privateSupply.add(commercialPlan),\n            true, // private ICO and commercial plan can share unsold tokens\n            blockTime()\n        );\n\n        initialized = true;\n        onInitialized();\n    }\n\n    /// @notice finalize\n    function finalize() onlyOwner {\n        // only after closed stage\n        require(stage() == Stage.Closed);       \n\n        uint256 unsold = publicSupply.sub(soldOut.official).sub(soldOut.channels);\n\n        if (unsold > 0) {\n            // unsold TOS as bonus\n            tos.offerBonus(unsold);        \n        }\n        tos.seal();\n\n        finalized = true;\n        onFinalized();\n    }\n\n    event onInitialized();\n    event onFinalized();\n\n    event onSold(address indexed buyer, uint256 venAmount, uint256 ethCost);\n}",
  "bytecode": "6060604052341561000c57fe5b5b5b33600060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505b5b5b6120a3806100616000396000f300606060405236156100ef576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806306fdde0314610105578063095ea7b31461019e57806313af4035146101f557806318160ddd1461022b57806323b872dd14610251578063313ce567146102c75780633fb27b85146102f3578063534eb1d414610305578063631f98521461032557806370a082311461034f5780637ba49b81146103995780638da5cb5b146103ef57806395d89b4114610441578063a9059cbb146104da578063b5e7324914610531578063cae9ca511461058a578063dd62ed3e14610624575b34156100f757fe5b6101035b60006000fd5b565b005b341561010d57fe5b61011561068d565b6040518080602001828103825283818151815260200191508051906020019080838360008314610164575b80518252602083111561016457602082019150602081019050602083039250610140565b505050905090810190601f1680156101905780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b34156101a657fe5b6101db600480803573ffffffffffffffffffffffffffffffffffffffff169060200190919080359060200190919050506106c7565b604051808215151515815260200191505060405180910390f35b34156101fd57fe5b610229600480803573ffffffffffffffffffffffffffffffffffffffff169060200190919050506107ba565b005b341561023357fe5b61023b61085d565b6040518082815260200191505060405180910390f35b341561025957fe5b6102ad600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803573ffffffffffffffffffffffffffffffffffffffff16906020019091908035906020019091905050610899565b604051808215151515815260200191505060405180910390f35b34156102cf57fe5b6102d7610c62565b604051808260ff1660ff16815260200191505060405180910390f35b34156102fb57fe5b610303610c67565b005b341561030d57fe5b6103236004808035906020019091905050610cd2565b005b341561032d57fe5b610335610e28565b604051808215151515815260200191505060405180910390f35b341561035757fe5b610383600480803573ffffffffffffffffffffffffffffffffffffffff16906020019091905050610e6c565b6040518082815260200191505060405180910390f35b34156103a157fe5b6103cd600480803573ffffffffffffffffffffffffffffffffffffffff16906020019091905050611224565b604051808263ffffffff1663ffffffff16815260200191505060405180910390f35b34156103f757fe5b6103ff611281565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b341561044957fe5b6104516112a7565b60405180806020018281038252838181518152602001915080519060200190808383600083146104a0575b8051825260208311156104a05760208201915060208101905060208303925061047c565b505050905090810190601f1680156104cc5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b34156104e257fe5b610517600480803573ffffffffffffffffffffffffffffffffffffffff169060200190919080359060200190919050506112e1565b604051808215151515815260200191505060405180910390f35b341561053957fe5b610588600480803573ffffffffffffffffffffffffffffffffffffffff16906020019091908035906020019091908035151590602001909190803563ffffffff16906020019091905050611597565b005b341561059257fe5b61060a600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803590602001909190803590602001908201803590602001908080601f016020809104026020016040519081016040528093929190818152602001838380828437820191505050505050919050506119c1565b604051808215151515815260200191505060405180910390f35b341561062c57fe5b610677600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803573ffffffffffffffffffffffffffffffffffffffff16906020019091905050611c14565b6040518082815260200191505060405180910390f35b604060405190810160405280600981526020017f544f5320546f6b656e000000000000000000000000000000000000000000000081525081565b600081600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925846040518082815260200191505060405180910390a3600190505b92915050565b600060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415156108175760006000fd5b80600060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505b5b50565b6000600160000160009054906101000a90046fffffffffffffffffffffffffffffffff166fffffffffffffffffffffffffffffffff1690505b90565b60006108a3610e28565b15156108af5760006000fd5b6108b884611c9c565b6108c183611c9c565b81600260008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160009054906101000a90046dffffffffffffffffffffffffffff166dffffffffffffffffffffffffffff16101580156109b9575081600360008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205410155b80156109c55750600082115b15610c515781600260008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160008282829054906101000a90046dffffffffffffffffffffffffffff160392506101000a8154816dffffffffffffffffffffffffffff02191690836dffffffffffffffffffffffffffff16021790555081600360008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282540392505081905550610b6f610b6a600260008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160009054906101000a90046dffffffffffffffffffffffffffff166dffffffffffffffffffffffffffff1684611f9d90919063ffffffff16565b611fbd565b600260008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160006101000a8154816dffffffffffffffffffffffffffff02191690836dffffffffffffffffffffffffffff1602179055508273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040518082815260200191505060405180910390a360019050610c5b565b60009050610c5b565b5b9392505050565b601281565b600060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16141515610cc45760006000fd5b610cce60006107ba565b5b5b565b600060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16141515610d2f5760006000fd5b610d4481600454611f9d90919063ffffffff16565b600481905550610d98610d93600160000160009054906101000a90046fffffffffffffffffffffffffffffffff166fffffffffffffffffffffffffffffffff1683611f9d90919063ffffffff16565b611fe3565b600160000160006101000a8154816fffffffffffffffffffffffffffffffff02191690836fffffffffffffffffffffffffffffffff1602179055503073ffffffffffffffffffffffffffffffffffffffff1660007fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef836040518082815260200191505060405180910390a35b5b50565b60006000600060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff161490505b90565b600060006000600260008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600001600e9054906101000a90046dffffffffffffffffffffffffffff166dffffffffffffffffffffffffffff161415610f5957600260008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160009054906101000a90046dffffffffffffffffffffffffffff166dffffffffffffffffffffffffffff16915061121e565b600060045411156111305761102a600160000160109054906101000a90046fffffffffffffffffffffffffffffffff166fffffffffffffffffffffffffffffffff1661101c600260008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600001600e9054906101000a90046dffffffffffffffffffffffffffff166dffffffffffffffffffffffffffff1660045461200b90919063ffffffff16565b61204090919063ffffffff16565b9050611129600260008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600001600e9054906101000a90046dffffffffffffffffffffffffffff166dffffffffffffffffffffffffffff1661111b600260008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160009054906101000a90046dffffffffffffffffffffffffffff166dffffffffffffffffffffffffffff1684611f9d90919063ffffffff16565b611f9d90919063ffffffff16565b915061121e565b61121b600260008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600001600e9054906101000a90046dffffffffffffffffffffffffffff166dffffffffffffffffffffffffffff16600260008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160009054906101000a90046dffffffffffffffffffffffffffff166dffffffffffffffffffffffffffff16611f9d90919063ffffffff16565b91505b50919050565b6000600260008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600001601c9054906101000a900463ffffffff1690505b919050565b600060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b604060405190810160405280600381526020017f544f53000000000000000000000000000000000000000000000000000000000081525081565b60006112eb610e28565b15156112f75760006000fd5b61130033611c9c565b61130983611c9c565b81600260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160009054906101000a90046dffffffffffffffffffffffffffff166dffffffffffffffffffffffffffff16101580156113855750600082115b156115875781600260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160008282829054906101000a90046dffffffffffffffffffffffffffff160392506101000a8154816dffffffffffffffffffffffffffff02191690836dffffffffffffffffffffffffffff1602179055506114a56114a0600260008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160009054906101000a90046dffffffffffffffffffffffffffff166dffffffffffffffffffffffffffff1684611f9d90919063ffffffff16565b611fbd565b600260008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160006101000a8154816dffffffffffffffffffffffffffff02191690836dffffffffffffffffffffffffffff1602179055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040518082815260200191505060405180910390a360019050611591565b60009050611591565b5b92915050565b600060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415156115f45760006000fd5b81156117835761168161167c600260008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600001600e9054906101000a90046dffffffffffffffffffffffffffff166dffffffffffffffffffffffffffff1685611f9d90919063ffffffff16565b611fbd565b600260008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600001600e6101000a8154816dffffffffffffffffffffffffffff02191690836dffffffffffffffffffffffffffff16021790555061174361173e600160000160109054906101000a90046fffffffffffffffffffffffffffffffff166fffffffffffffffffffffffffffffffff1685611f9d90919063ffffffff16565b611fe3565b600160000160106101000a8154816fffffffffffffffffffffffffffffffff02191690836fffffffffffffffffffffffffffffffff16021790555061187f565b61180a611805600260008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160009054906101000a90046dffffffffffffffffffffffffffff166dffffffffffffffffffffffffffff1685611f9d90919063ffffffff16565b611fbd565b600260008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160006101000a8154816dffffffffffffffffffffffffffff02191690836dffffffffffffffffffffffffffff1602179055505b80600260008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600001601c6101000a81548163ffffffff021916908363ffffffff16021790555061192e611929600160000160009054906101000a90046fffffffffffffffffffffffffffffffff166fffffffffffffffffffffffffffffffff1685611f9d90919063ffffffff16565b611fe3565b600160000160006101000a8154816fffffffffffffffffffffffffffffffff02191690836fffffffffffffffffffffffffffffffff1602179055508373ffffffffffffffffffffffffffffffffffffffff1660007fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef856040518082815260200191505060405180910390a35b5b50505050565b600082600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508373ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925856040518082815260200191505060405180910390a38373ffffffffffffffffffffffffffffffffffffffff16638f4ffcb1338530866040518563ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018481526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200180602001828103825283818151815260200191508051906020019080838360008314611bad575b805182526020831115611bad57602082019150602081019050602083039250611b89565b505050905090810190601f168015611bd95780820380516001836020036101000a031916815260200191505b5095505050505050600060405180830381600087803b1515611bf757fe5b6102c65a03f11515611c0557fe5b505050600190505b9392505050565b6000600360008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205490505b92915050565b60006000611ca8610e28565b1515611cb45760006000fd5b6000600260008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600001600e9054906101000a90046dffffffffffffffffffffffffffff166dffffffffffffffffffffffffffff16141515611f9757611d3383610e6c565b9150611e32600260008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600001600e9054906101000a90046dffffffffffffffffffffffffffff166dffffffffffffffffffffffffffff16611e24600260008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160009054906101000a90046dffffffffffffffffffffffffffff166dffffffffffffffffffffffffffff168561205d90919063ffffffff16565b61205d90919063ffffffff16565b9050611e3d82611fbd565b600260008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160006101000a8154816dffffffffffffffffffffffffffff02191690836dffffffffffffffffffffffffffff1602179055506000600260008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600001600e6101000a8154816dffffffffffffffffffffffffffff02191690836dffffffffffffffffffffffffffff1602179055506000811115611f96578273ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef836040518082815260200191505060405180910390a35b5b5b505050565b600060008284019050838110151515611fb257fe5b8091505b5092915050565b600081826dffffffffffffffffffffffffffff16141515611fda57fe5b8190505b919050565b600081826fffffffffffffffffffffffffffffffff1614151561200257fe5b8190505b919050565b600060008284029050600084148061202d575082848281151561202a57fe5b04145b151561203557fe5b8091505b5092915050565b60006000828481151561204f57fe5b0490508091505b5092915050565b600082821115151561206b57fe5b81830390505b929150505600a165627a7a723058203c0380d4b0f121e5b596ae52e4323a1a171f9979d721158fe40332d87ead674f0029"
}