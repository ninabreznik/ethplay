{
  "address": "0xfa86cabff17a2628a4c875ebc3260191b08448ec",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "Storage",
  "compilerVersion": "v0.5.4+commit.9549d8ff",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2019-04-03\n*/\n\npragma solidity ^0.5.2 <0.6.0;\n\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @return the address of the owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner());\n        _;\n    }\n\n    /**\n     * @return true if `msg.sender` is the owner of the contract.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Allows the current owner to relinquish control of the contract.\n     * @notice Renouncing to ownership will leave the contract without an owner.\n     * It will not be possible to call the functions with the `onlyOwner`\n     * modifier anymore.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\nlibrary RLP {\n\n    uint constant DATA_SHORT_START = 0x80;\n    uint constant DATA_LONG_START = 0xB8;\n    uint constant LIST_SHORT_START = 0xC0;\n    uint constant LIST_LONG_START = 0xF8;\n\n    uint constant DATA_LONG_OFFSET = 0xB7;\n    uint constant LIST_LONG_OFFSET = 0xF7;\n\n\n    struct RLPItem {\n        uint _unsafe_memPtr;    // Pointer to the RLP-encoded bytes.\n        uint _unsafe_length;    // Number of bytes. This is the full length of the string.\n    }\n\n    struct Iterator {\n        RLPItem _unsafe_item;   // Item that's being iterated over.\n        uint _unsafe_nextPtr;   // Position of the next item in the list.\n    }\n\n    /* Iterator */\n\n    function next(Iterator memory self) internal pure returns (RLPItem memory subItem) {\n        if(hasNext(self)) {\n            uint256 ptr = self._unsafe_nextPtr;\n            uint256 itemLength = _itemLength(ptr);\n            subItem._unsafe_memPtr = ptr;\n            subItem._unsafe_length = itemLength;\n            self._unsafe_nextPtr = ptr + itemLength;\n        }\n        else\n            revert();\n    }\n\n    function next(Iterator memory self, bool strict) internal pure returns (RLPItem memory subItem) {\n        subItem = next(self);\n        if(strict && !_validate(subItem))\n            revert();\n        return subItem;\n    }\n\n    function hasNext(\n        Iterator memory self\n    ) internal pure returns (bool) {\n        RLP.RLPItem memory item = self._unsafe_item;\n        return self._unsafe_nextPtr < item._unsafe_memPtr + item._unsafe_length;\n    }\n\n    /* RLPItem */\n\n    /// @dev Creates an RLPItem from an array of RLP encoded bytes.\n    /// @param self The RLP encoded bytes.\n    /// @return An RLPItem\n    function toRLPItem(bytes memory self) internal pure returns (RLPItem memory) {\n        uint len = self.length;\n        if (len == 0) {\n            return RLPItem(0, 0);\n        }\n        uint memPtr;\n        assembly {\n            memPtr := add(self, 0x20)\n        }\n        return RLPItem(memPtr, len);\n    }\n\n    /// @dev Creates an RLPItem from an array of RLP encoded bytes.\n    /// @param self The RLP encoded bytes.\n    /// @param strict Will throw if the data is not RLP encoded.\n    /// @return An RLPItem\n    function toRLPItem(bytes memory self, bool strict) internal pure returns (RLPItem memory) {\n        RLP.RLPItem memory item = toRLPItem(self);\n        if(strict) {\n            uint len = self.length;\n            if(_payloadOffset(item) > len)\n                revert();\n            if(_itemLength(item._unsafe_memPtr) != len)\n                revert();\n            if(!_validate(item))\n                revert();\n        }\n        return item;\n    }\n\n    /// @dev Check if the RLP item is null.\n    /// @param self The RLP item.\n    /// @return 'true' if the item is null.\n    function isNull(RLPItem memory self) internal pure returns (bool ret) {\n        return self._unsafe_length == 0;\n    }\n\n    /// @dev Check if the RLP item is a list.\n    /// @param self The RLP item.\n    /// @return 'true' if the item is a list.\n    function isList(RLPItem memory self) internal pure returns (bool ret) {\n        if (self._unsafe_length == 0)\n            return false;\n        uint memPtr = self._unsafe_memPtr;\n        assembly {\n            ret := iszero(lt(byte(0, mload(memPtr)), 0xC0))\n        }\n    }\n\n    /// @dev Check if the RLP item is data.\n    /// @param self The RLP item.\n    /// @return 'true' if the item is data.\n    function isData(RLPItem memory self) internal pure returns (bool ret) {\n        if (self._unsafe_length == 0)\n            return false;\n        uint memPtr = self._unsafe_memPtr;\n        assembly {\n            ret := lt(byte(0, mload(memPtr)), 0xC0)\n        }\n    }\n\n    /// @dev Check if the RLP item is empty (string or list).\n    /// @param self The RLP item.\n    /// @return 'true' if the item is null.\n    function isEmpty(RLPItem memory self) internal pure returns (bool ret) {\n        if(isNull(self))\n            return false;\n        uint b0;\n        uint memPtr = self._unsafe_memPtr;\n        assembly {\n            b0 := byte(0, mload(memPtr))\n        }\n        return (b0 == DATA_SHORT_START || b0 == LIST_SHORT_START);\n    }\n\n    /// @dev Get the number of items in an RLP encoded list.\n    /// @param self The RLP item.\n    /// @return The number of items.\n    function items(RLPItem memory self) internal pure returns (uint) {\n        if (!isList(self))\n            return 0;\n        uint b0;\n        uint memPtr = self._unsafe_memPtr;\n        assembly {\n            b0 := byte(0, mload(memPtr))\n        }\n        uint pos = memPtr + _payloadOffset(self);\n        uint last = memPtr + self._unsafe_length - 1;\n        uint itms;\n        while(pos <= last) {\n            pos += _itemLength(pos);\n            itms++;\n        }\n        return itms;\n    }\n\n    /// @dev Create an iterator.\n    /// @param self The RLP item.\n    /// @return An 'Iterator' over the item.\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory it) {\n        require(isList(self));\n        uint ptr = self._unsafe_memPtr + _payloadOffset(self);\n        it._unsafe_item = self;\n        it._unsafe_nextPtr = ptr;\n    }\n\n    /// @dev Return the RLP encoded bytes.\n    /// @param self The RLPItem.\n    /// @return The bytes.\n    function toBytes(RLPItem memory self) internal pure returns (bytes memory bts) {\n        uint256 len = self._unsafe_length;\n        if (len == 0)\n            return bts;\n        bts = new bytes(len);\n        _copyToBytes(self._unsafe_memPtr, bts, len);\n//\n//        uint256 len = self._unsafe_length;\n//\n//        if (len == 0) {\n//            return bts;\n//        } else if (len == 1) {\n//            bts = new bytes(len);\n//            _copyToBytes(self._unsafe_memPtr, bts, len);\n//            return bts;\n//        }\n//\n//        bts = new bytes(len-_payloadOffset(self));\n//        uint start = self._unsafe_memPtr + _payloadOffset(self);\n//        _copyToBytes(start, bts, len-_payloadOffset(self));\n    }\n\n    /// @dev Decode an RLPItem into bytes. This will not work if the\n    /// RLPItem is a list.\n    /// @param self The RLPItem.\n    /// @return The decoded string.\n    function toData(RLPItem memory self) internal pure returns (bytes memory bts) {\n        require(isData(self));\n        (uint256 rStartPos, uint256 len) = _decode(self);\n        bts = new bytes(len);\n        _copyToBytes(rStartPos, bts, len);\n    }\n\n    /// @dev Get the list of sub-items from an RLP encoded list.\n    /// Warning: This is inefficient, as it requires that the list is read twice.\n    /// @param self The RLP item.\n    /// @return Array of RLPItems.\n    function toList(RLPItem memory self) internal pure returns (RLPItem[] memory list) {\n        require(isList(self));\n        uint256 numItems = items(self);\n        list = new RLPItem[](numItems);\n        RLP.Iterator memory it = iterator(self);\n        uint idx;\n        while(hasNext(it)) {\n            list[idx] = next(it);\n            idx++;\n        }\n    }\n\n    /// @dev Decode an RLPItem into an ascii string. This will not work if the\n    /// RLPItem is a list.\n    /// @param self The RLPItem.\n    /// @return The decoded string.\n    function toAscii(RLPItem memory self) internal pure returns (string memory str) {\n        require(isData(self));\n        (uint256 rStartPos, uint256 len) = _decode(self);\n        bytes memory bts = new bytes(len);\n        _copyToBytes(rStartPos, bts, len);\n        str = string(bts);\n    }\n\n    /// @dev Decode an RLPItem into a uint. This will not work if the\n    /// RLPItem is a list.\n    /// @param self The RLPItem.\n    /// @return The decoded string.\n    function toUint(RLPItem memory self) internal pure returns (uint data) {\n        require(isData(self));\n        (uint256 rStartPos, uint256 len) = _decode(self);\n        require(len <= 32);\n        assembly {\n            data := div(mload(rStartPos), exp(256, sub(32, len)))\n        }\n    }\n\n    /// @dev Decode an RLPItem into a boolean. This will not work if the\n    /// RLPItem is a list.\n    /// @param self The RLPItem.\n    /// @return The decoded string.\n    function toBool(RLPItem memory self) internal pure returns (bool data) {\n        require(isData(self));\n        (uint256 rStartPos, uint256 len) = _decode(self);\n        require(len == 1);\n        uint temp;\n        assembly {\n            temp := byte(0, mload(rStartPos))\n        }\n        require(temp == 1 || temp == 0);\n        return temp == 1 ? true : false;\n    }\n\n    /// @dev Decode an RLPItem into a byte. This will not work if the\n    /// RLPItem is a list.\n    /// @param self The RLPItem.\n    /// @return The decoded string.\n    function toByte(RLPItem memory self)\n    internal\n    pure\n    returns (byte data)\n    {\n        require(isData(self));\n\n        (uint256 rStartPos, uint256 len) = _decode(self);\n\n        require(len == 1);\n\n        byte temp;\n        assembly {\n            temp := byte(0, mload(rStartPos))\n        }\n        return temp;\n    }\n\n    /// @dev Decode an RLPItem into an int. This will not work if the\n    /// RLPItem is a list.\n    /// @param self The RLPItem.\n    /// @return The decoded string.\n    function toInt(RLPItem memory self)\n    internal\n    pure\n    returns (int data)\n    {\n        return int(toUint(self));\n    }\n\n    /// @dev Decode an RLPItem into a bytes32. This will not work if the\n    /// RLPItem is a list.\n    /// @param self The RLPItem.\n    /// @return The decoded string.\n    function toBytes32(RLPItem memory self)\n    internal\n    pure\n    returns (bytes32 data)\n    {\n        return bytes32(toUint(self));\n    }\n\n    /// @dev Decode an RLPItem into an address. This will not work if the\n    /// RLPItem is a list.\n    /// @param self The RLPItem.\n    /// @return The decoded string.\n    function toAddress(RLPItem memory self)\n    internal\n    pure\n    returns (address data)\n    {\n        (, uint256 len) = _decode(self);\n        require(len <= 20);\n        return address(toUint(self));\n    }\n\n    // Get the payload offset.\n    function _payloadOffset(RLPItem memory self)\n    private\n    pure\n    returns (uint)\n    {\n        if(self._unsafe_length == 0)\n            return 0;\n        uint b0;\n        uint memPtr = self._unsafe_memPtr;\n        assembly {\n            b0 := byte(0, mload(memPtr))\n        }\n        if(b0 < DATA_SHORT_START)\n            return 0;\n        if(b0 < DATA_LONG_START || (b0 >= LIST_SHORT_START && b0 < LIST_LONG_START))\n            return 1;\n        if(b0 < LIST_SHORT_START)\n            return b0 - DATA_LONG_OFFSET + 1;\n        return b0 - LIST_LONG_OFFSET + 1;\n    }\n\n    // Get the full length of an RLP item.\n    function _itemLength(uint memPtr)\n    private\n    pure\n    returns (uint len)\n    {\n        uint b0;\n        assembly {\n            b0 := byte(0, mload(memPtr))\n        }\n        if (b0 < DATA_SHORT_START)\n            len = 1;\n        else if (b0 < DATA_LONG_START)\n            len = b0 - DATA_SHORT_START + 1;\n        else if (b0 < LIST_SHORT_START) {\n            assembly {\n                let bLen := sub(b0, 0xB7) // bytes length (DATA_LONG_OFFSET)\n                let dLen := div(mload(add(memPtr, 1)), exp(256, sub(32, bLen))) // data length\n                len := add(1, add(bLen, dLen)) // total length\n            }\n        } else if (b0 < LIST_LONG_START) {\n            len = b0 - LIST_SHORT_START + 1;\n        } else {\n            assembly {\n                let bLen := sub(b0, 0xF7) // bytes length (LIST_LONG_OFFSET)\n                let dLen := div(mload(add(memPtr, 1)), exp(256, sub(32, bLen))) // data length\n                len := add(1, add(bLen, dLen)) // total length\n            }\n        }\n    }\n\n    // Get start position and length of the data.\n    function _decode(RLPItem memory self)\n    private\n    pure\n    returns (uint memPtr, uint len)\n    {\n        require(isData(self));\n        uint b0;\n        uint start = self._unsafe_memPtr;\n        assembly {\n            b0 := byte(0, mload(start))\n        }\n        if (b0 < DATA_SHORT_START) {\n            memPtr = start;\n            len = 1;\n            return (memPtr, len);\n        }\n        if (b0 < DATA_LONG_START) {\n            len = self._unsafe_length - 1;\n            memPtr = start + 1;\n        } else {\n            uint bLen;\n            assembly {\n                bLen := sub(b0, 0xB7) // DATA_LONG_OFFSET\n            }\n            len = self._unsafe_length - 1 - bLen;\n            memPtr = start + bLen + 1;\n        }\n        return (memPtr, len);\n    }\n\n    // Assumes that enough memory has been allocated to store in target.\n    function _copyToBytes(\n        uint btsPtr,\n        bytes memory tgt,\n        uint btsLen) private pure\n    {\n        // Exploiting the fact that 'tgt' was the last thing to be allocated,\n        // we can write entire words, and just overwrite any excess.\n        assembly {\n            {\n                let words := div(add(btsLen, 31), 32)\n                let rOffset := btsPtr\n                let wOffset := add(tgt, 0x20)\n\n                for { let i := 0 } lt(i, words) { i := add(i, 1) } {\n                    let offset := mul(i, 0x20)\n                    mstore(add(wOffset, offset), mload(add(rOffset, offset)))\n                }\n\n                mstore(add(tgt, add(0x20, mload(tgt))), 0)\n            }\n\n        }\n    }\n\n    // Check that an RLP item is valid.\n    function _validate(RLPItem memory self)\n    private\n    pure\n    returns (bool ret)\n    {\n        // Check that RLP is well-formed.\n        uint b0;\n        uint b1;\n        uint memPtr = self._unsafe_memPtr;\n        assembly {\n            b0 := byte(0, mload(memPtr))\n            b1 := byte(1, mload(memPtr))\n        }\n        if(b0 == DATA_SHORT_START + 1 && b1 < DATA_SHORT_START)\n            return false;\n        return true;\n    }\n}\nlibrary Object {\n    using RLP for bytes;\n    using RLP for bytes[];\n    using RLP for RLP.RLPItem;\n    using RLP for RLP.Iterator;\n\n    struct Data {\n        uint sura;\n        uint ayat;\n        bytes text;\n    }\n\n    function createData(bytes memory dataBytes)\n        internal\n        pure\n        returns (Data memory)\n    {\n        RLP.RLPItem[] memory dataList = dataBytes.toRLPItem().toList();\n        return Data({\n            sura: dataList[0].toUint(),\n            ayat: dataList[1].toUint(),\n            text: dataList[2].toBytes()\n        });\n    }\n}\n\ncontract Storage is Ownable {\n    using Object for bytes;\n    using RLP for bytes;\n    using RLP for bytes[];\n    using RLP for RLP.RLPItem;\n    using RLP for RLP.Iterator;\n\n    struct coord {\n        uint sura;\n        uint ayat;\n    }\n\n    // @dev Mapping ayat's hash with its text.\n    mapping(bytes32 => bytes) public content;\n    mapping(uint => mapping(uint => bytes32)) public coordinates;\n    mapping(bytes32 => coord[]) public all_coordinates;\n\n    /** @dev Adds content.\n      * @param text Ayat text.\n      * @param sura Sura number.\n      * @param ayat Ayat number.\n      */\n    function add_content(\n        bytes memory text,\n        uint sura,\n        uint ayat\n    ) public onlyOwner {\n        bytes32 hash = keccak256(text);\n        if (coordinates[sura][ayat] != 0x0000000000000000000000000000000000000000000000000000000000000000) {\n            return;\n        }\n\n        coordinates[sura][ayat] = hash;\n        all_coordinates[hash].push(coord({sura:sura, ayat: ayat}));\n        content[hash] = text;\n    }\n\n    /** @dev Adds packed data.\n      * @param data RLP packed objects.\n      */\n    function add_data(bytes memory data) public onlyOwner {\n        RLP.RLPItem[] memory list = data.toRLPItem().toList();\n\n        for (uint index = 0; index < list.length; index++) {\n            RLP.RLPItem[] memory item = list[index].toList();\n\n            uint sura = item[0].toUint();\n            uint ayat = item[1].toUint();\n            bytes memory text = item[2].toData();\n\n            add_content(text, sura, ayat);\n        }\n    }\n\n    /** @dev Gets ayat text by hash.\n      * @param ayat_hash Ayat keccak256 hash of compressed text (gzip).\n      * @return Ayat compressed text.\n      */\n    function get_ayat_text_by_hash(\n        bytes32 ayat_hash\n    ) public view returns (bytes  memory text) {\n        text = content[ayat_hash];\n    }\n\n    /** @dev Gets ayat text by coordinates.\n      * @param sura Sura number.\n      * @param ayat Ayat number.\n      * @return Ayat compressed text.\n      */\n    function get_ayat_text_by_coordinates(\n        uint sura,\n        uint ayat\n    ) public view returns (bytes memory text) {\n        bytes32 hash = coordinates[sura][ayat];\n        text = content[hash];\n    }\n\n    /** @dev Gets number of ayats by hash.\n      * @param hash Ayat keccak256 hash of compressed text (gzip).\n      * @return Ayats number.\n      */\n    function get_ayats_length(\n        bytes32 hash\n    ) public view returns (uint) {\n        return all_coordinates[hash].length;\n    }\n\n    /** @dev Gets an ayat's number and a sura number by a hash and a index in an array.\n      * @param hash Ayat keccak256 hash of compressed text (gzip).\n      * @param index Ayat index. Ayat text is not unique in the Quran, so this may be several options.\n      */\n    function get_ayat_coordinates_by_index(\n        bytes32 hash,\n        uint index\n    ) public view returns (uint sura, uint ayat) {\n        coord memory data = all_coordinates[hash][index];\n        sura = data.sura;\n        ayat = data.ayat;\n    }\n\n    /** @dev Verifying the text of an ayat.\n      * @param text Ayat compressed text (gzip).\n      * @return bool\n      */\n    function check_ayat_text(\n        bytes memory text\n    ) public view returns(bool) {\n        bytes32 hash = keccak256(text);\n        bytes memory ayat_data = content[hash];\n        return ayat_data.length != 0;\n    }\n}",
  "abi": "[{\"constant\":false,\"inputs\":[{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"add_data\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"content\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ayat_hash\",\"type\":\"bytes32\"}],\"name\":\"get_ayat_text_by_hash\",\"outputs\":[{\"name\":\"text\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"text\",\"type\":\"bytes\"},{\"name\":\"sura\",\"type\":\"uint256\"},{\"name\":\"ayat\",\"type\":\"uint256\"}],\"name\":\"add_content\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"get_ayats_length\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"coordinates\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sura\",\"type\":\"uint256\"},{\"name\":\"ayat\",\"type\":\"uint256\"}],\"name\":\"get_ayat_text_by_coordinates\",\"outputs\":[{\"name\":\"text\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"text\",\"type\":\"bytes\"}],\"name\":\"check_ayat_text\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"hash\",\"type\":\"bytes32\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"get_ayat_coordinates_by_index\",\"outputs\":[{\"name\":\"sura\",\"type\":\"uint256\"},{\"name\":\"ayat\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"all_coordinates\",\"outputs\":[{\"name\":\"sura\",\"type\":\"uint256\"},{\"name\":\"ayat\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]",
  "bytecode": "6080604081905260008054600160a060020a0319163317808255600160a060020a0316917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0908290a36110c2806100576000396000f3fe608060405234801561001057600080fd5b5060043610610107576000357c010000000000000000000000000000000000000000000000000000000090048063955cb325116100a9578063c1b8a7c711610083578063c1b8a7c7146103cb578063d24a31b714610471578063e2375b08146104ad578063f2fde38b146104d057610107565b8063955cb325146103565780639f6b564914610385578063a462ee89146103a857610107565b8063715018a6116100e5578063715018a6146102635780637b217fc41461026b5780638da5cb5b146103165780638f32d59b1461033a57610107565b80631e9668371461010c5780632dff6941146101b457806365b13c0f14610246575b600080fd5b6101b26004803603602081101561012257600080fd5b81019060208101813564010000000081111561013d57600080fd5b82018360208201111561014f57600080fd5b8035906020019184600183028401116401000000008311171561017157600080fd5b91908080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152509295506104f6945050505050565b005b6101d1600480360360208110156101ca57600080fd5b50356105ce565b6040805160208082528351818301528351919283929083019185019080838360005b8381101561020b5781810151838201526020016101f3565b50505050905090810190601f1680156102385780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6101d16004803603602081101561025c57600080fd5b5035610668565b6101b2610708565b6101b26004803603606081101561028157600080fd5b81019060208101813564010000000081111561029c57600080fd5b8201836020820111156102ae57600080fd5b803590602001918460018302840111640100000000831117156102d057600080fd5b91908080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152509295505082359350505060200135610772565b61031e610828565b60408051600160a060020a039092168252519081900360200190f35b610342610838565b604080519115158252519081900360200190f35b6103736004803603602081101561036c57600080fd5b5035610849565b60408051918252519081900360200190f35b6103736004803603604081101561039b57600080fd5b508035906020013561085e565b6101d1600480360360408110156103be57600080fd5b508035906020013561087b565b610342600480360360208110156103e157600080fd5b8101906020810181356401000000008111156103fc57600080fd5b82018360208201111561040e57600080fd5b8035906020019184600183028401116401000000008311171561043057600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550610932945050505050565b6104946004803603604081101561048757600080fd5b50803590602001356109e1565b6040805192835260208301919091528051918290030190f35b610494600480360360408110156104c357600080fd5b5080359060200135610a3f565b6101b2600480360360208110156104e657600080fd5b5035600160a060020a0316610a7a565b6104fe610838565b151561050957600080fd5b606061051c61051783610a99565b610ade565b905060005b81518110156105c957606061054c838381518110151561053d57fe5b90602001906020020151610ade565b9050600061057182600081518110151561056257fe5b90602001906020020151610b93565b9050600061058783600181518110151561056257fe5b905060606105ac84600281518110151561059d57fe5b90602001906020020151610bdc565b90506105b9818484610772565b5050600190920191506105219050565b505050565b60016020818152600092835260409283902080548451600294821615610100026000190190911693909304601f81018390048302840183019094528383529192908301828280156106605780601f1061063557610100808354040283529160200191610660565b820191906000526020600020905b81548152906001019060200180831161064357829003601f168201915b505050505081565b60008181526001602081815260409283902080548451600294821615610100026000190190911693909304601f810183900483028401830190945283835260609390918301828280156106fc5780601f106106d1576101008083540402835291602001916106fc565b820191906000526020600020905b8154815290600101906020018083116106df57829003601f168201915b50505050509050919050565b610710610838565b151561071b57600080fd5b60008054604051600160a060020a03909116907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0908390a36000805473ffffffffffffffffffffffffffffffffffffffff19169055565b61077a610838565b151561078557600080fd5b825160208085019190912060008481526002835260408082208583529093529190912054156107b457506105c9565b6000838152600260208181526040808420868552825280842085905584845260038252808420815180830183528881528084018881528254600181810185559388528588209251960290910194855551938101939093558484529181529120855161082192870190610fc6565b5050505050565b600054600160a060020a03165b90565b600054600160a060020a0316331490565b6000818152600360205260409020545b919050565b600260209081526000928352604080842090915290825290205481565b6000828152600260208181526040808420858552825280842054808552600180845294829020805483519681161561010002600019011694909404601f8101849004840286018401909252818552606094909390929091908301828280156109245780601f106108f957610100808354040283529160200191610924565b820191906000526020600020905b81548152906001019060200180831161090757829003601f168201915b505050505091505092915050565b805160208083019190912060008181526001808452604080832080548251600294821615610100026000190190911693909304601f8101879004870284018701909252818352929460609391908301828280156109d05780601f106109a5576101008083540402835291602001916109d0565b820191906000526020600020905b8154815290600101906020018083116109b357829003601f168201915b505092511515979650505050505050565b6000806109ec611044565b6000858152600360205260409020805485908110610a0657fe5b60009182526020918290206040805180820190915260029092020180548083526001909101549190920181905290969095509350505050565b600360205281600052604060002081815481101515610a5a57fe5b600091825260209091206002909102018054600190910154909250905082565b610a82610838565b1515610a8d57600080fd5b610a9681610c42565b50565b610aa1611044565b8151801515610ac55750506040805180820190915260008082526020820152610859565b6040805180820190915260209384018152928301525090565b6060610ae982610cbf565b1515610af457600080fd5b6000610aff83610ce6565b905080604051908082528060200260200182016040528015610b3b57816020015b610b28611044565b815260200190600190039081610b205790505b509150610b4661105b565b610b4f84610d4c565b905060005b610b5d82610d85565b15610b8b57610b6b82610da4565b8482815181101515610b7957fe5b60209081029091010152600101610b54565b505050919050565b6000610b9e82610de4565b1515610ba957600080fd5b600080610bb584610e0a565b90925090506020811115610bc857600080fd5b806020036101000a82510492505050919050565b6060610be782610de4565b1515610bf257600080fd5b600080610bfe84610e0a565b91509150806040519080825280601f01601f191660200182016040528015610c2d576020820181803883390190505b509250610c3b828483610e7c565b5050919050565b600160a060020a0381161515610c5757600080fd5b60008054604051600160a060020a03808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a36000805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b6000816020015160001415610cd657506000610859565b50515160c060009190911a101590565b6000610cf182610cbf565b1515610cff57506000610859565b81518051600090811a9190610d1385610eba565b6020860151908301915082016000190160005b818311610d4257610d3683610f38565b90920191600101610d26565b9695505050505050565b610d5461105b565b610d5d82610cbf565b1515610d6857600080fd5b6000610d7383610eba565b83519383529092016020820152919050565b6000610d8f611044565b50508051602080820151915192015191011190565b610dac611044565b610db582610d85565b156101075760208201516000610dca82610f38565b828452602080850182905292019184019190915250610859565b6000816020015160001415610dfb57506000610859565b50515160c060009190911a1090565b600080610e1683610de4565b1515610e2157600080fd5b8251805160001a906080821015610e3f57925060019150610e779050565b60b8821015610e5d5760018560200151039250806001019350610e74565b602085015182820160b51901945082900360b60192505b50505b915091565b6020601f820104836020840160005b83811015610ea757602081028381015190830152600101610e8b565b5060008551602001860152505050505050565b6000816020015160001415610ed157506000610859565b8151805160001a906080821015610eed57600092505050610859565b60b8821080610f08575060c08210158015610f08575060f882105b15610f1857600192505050610859565b60c0821015610f2d575060b519019050610859565b5060f5190192915050565b8051600090811a6080811015610f515760019150610fc0565b60b8811015610f6657607e1981019150610fc0565b60c0811015610f8f57600183015160b76020839003016101000a9004810160b519019150610fc0565b60f8811015610fa45760be1981019150610fc0565b600183015160f76020839003016101000a9004810160f5190191505b50919050565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061100757805160ff1916838001178555611034565b82800160010185558215611034579182015b82811115611034578251825591602001919060010190611019565b5061104092915061107c565b5090565b604080518082019091526000808252602082015290565b60606040519081016040528061106f611044565b8152602001600081525090565b61083591905b80821115611040576000815560010161108256fea165627a7a723058202df067a9e517cc0e4144ae9d23ec5068724cfe7bb910a0e085195499fd1513b20029"
}