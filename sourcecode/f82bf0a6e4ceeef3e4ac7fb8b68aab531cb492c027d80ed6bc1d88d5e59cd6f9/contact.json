{
  "address": "0x6a20d74106f28ad19c60115917ff363ad71f525f",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "BW",
  "compilerVersion": "v0.4.24+commit.e67f0147",
  "optimization": false,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2018-06-07\n*/\n\npragma solidity ^0.4.21;\n\nlibrary BWUtility {\n    \n    // -------- UTILITY FUNCTIONS ----------\n\n\n    // Return next higher even _multiple for _amount parameter (e.g used to round up to even finneys).\n    function ceil(uint _amount, uint _multiple) pure public returns (uint) {\n        return ((_amount + _multiple - 1) / _multiple) * _multiple;\n    }\n\n    // Checks if two coordinates are adjacent:\n    // xxx\n    // xox\n    // xxx\n    // All x (_x2, _xy2) are adjacent to o (_x1, _y1) in this ascii image. \n    // Adjacency does not wrapp around map edges so if y2 = 255 and y1 = 0 then they are not ajacent\n    function isAdjacent(uint8 _x1, uint8 _y1, uint8 _x2, uint8 _y2) pure public returns (bool) {\n        return ((_x1 == _x2 &&      (_y2 - _y1 == 1 || _y1 - _y2 == 1))) ||      // Same column\n               ((_y1 == _y2 &&      (_x2 - _x1 == 1 || _x1 - _x2 == 1))) ||      // Same row\n               ((_x2 - _x1 == 1 &&  (_y2 - _y1 == 1 || _y1 - _y2 == 1))) ||      // Right upper or lower diagonal\n               ((_x1 - _x2 == 1 &&  (_y2 - _y1 == 1 || _y1 - _y2 == 1)));        // Left upper or lower diagonal\n    }\n\n    // Converts (x, y) to tileId xy\n    function toTileId(uint8 _x, uint8 _y) pure public returns (uint16) {\n        return uint16(_x) << 8 | uint16(_y);\n    }\n\n    // Converts _tileId to (x, y)\n    function fromTileId(uint16 _tileId) pure public returns (uint8, uint8) {\n        uint8 y = uint8(_tileId);\n        uint8 x = uint8(_tileId >> 8);\n        return (x, y);\n    }\n    \n    function getBoostFromTile(address _claimer, address _attacker, address _defender, uint _blockValue) pure public returns (uint, uint) {\n        if (_claimer == _attacker) {\n            return (_blockValue, 0);\n        } else if (_claimer == _defender) {\n            return (0, _blockValue);\n        }\n    }\n}\n\n\n\n\n\n\ninterface ERC20I {\n    function transfer(address _recipient, uint256 _amount) external returns (bool);\n    function balanceOf(address _holder) external view returns (uint256);\n}\n\n\ncontract BWService {\n    using SafeMath for uint256;\n    address private owner;\n    address private bw;\n    address private bwMarket;\n    BWData private bwData;\n    uint private seed = 42;\n    uint private WITHDRAW_FEE = 5; // 5%\n    uint private ATTACK_FEE = 5; // 5%\n    uint private ATTACK_BOOST_CAP = 300; // 300%\n    uint private DEFEND_BOOST_CAP = 300; // 300%\n    uint private ATTACK_BOOST_MULTIPLIER = 100; // 100%\n    uint private DEFEND_BOOST_MULTIPLIER = 100; // 100%\n    mapping (uint16 => address) private localGames;\n    \n    modifier isOwner {\n        if (msg.sender != owner) {\n            revert();\n        }\n        _;\n    }  \n\n    modifier isValidCaller {\n        if (msg.sender != bw && msg.sender != bwMarket) {\n            revert();\n        }\n        _;\n    }\n\n    event TileClaimed(uint16 tileId, address newClaimer, uint priceInWei, uint creationTime);\n    event TileFortified(uint16 tileId, address claimer, uint addedValueInWei, uint priceInWei, uint fortifyTime); // Sent when a user fortifies an existing claim by bumping its value.\n    event TileAttackedSuccessfully(uint16 tileId, address attacker, uint attackAmount, uint totalAttackAmount, address defender, uint defendAmount, uint totalDefendAmount, uint attackRoll, uint attackTime); // Sent when a user successfully attacks a tile.    \n    event TileDefendedSuccessfully(uint16 tileId, address attacker, uint attackAmount, uint totalAttackAmount, address defender, uint defendAmount, uint totalDefendAmount, uint attackRoll, uint defendTime); // Sent when a user successfully defends a tile when attacked.    \n    event BlockValueMoved(uint16 sourceTileId, uint16 destTileId, address owner, uint movedBlockValue, uint postSourceValue, uint postDestValue, uint moveTime); // Sent when a user buys a tile from another user, by accepting a tile offer\n    event UserBattleValueUpdated(address userAddress, uint battleValue, bool isWithdraw);\n\n    // Constructor.\n    constructor(address _bwData) public {\n        bwData = BWData(_bwData);\n        owner = msg.sender;\n    }\n\n    // Can't send funds straight to this contract. Avoid people sending by mistake.\n    function () payable public {\n        revert();\n    }\n\n    // OWNER-ONLY FUNCTIONS\n    function kill() public isOwner {\n        selfdestruct(owner);\n    }\n\n    function setValidBwCaller(address _bw) public isOwner {\n        bw = _bw;\n    }\n    \n    function setValidBwMarketCaller(address _bwMarket) public isOwner {\n        bwMarket = _bwMarket;\n    }\n\n    function setWithdrawFee(uint _feePercentage) public isOwner {\n        WITHDRAW_FEE = _feePercentage;\n    }\n\n    function setAttackFee(uint _feePercentage) public isOwner {\n        ATTACK_FEE = _feePercentage;\n    }\n\n    function setAttackBoostMultipler(uint _multiplierPercentage) public isOwner {\n        ATTACK_BOOST_MULTIPLIER = _multiplierPercentage;\n    }\n\n    function setDefendBoostMultiplier(uint _multiplierPercentage) public isOwner {\n        DEFEND_BOOST_MULTIPLIER = _multiplierPercentage;\n    }\n\n    function setAttackBoostCap(uint _capPercentage) public isOwner {\n        ATTACK_BOOST_CAP = _capPercentage;\n    }\n\n    function setDefendBoostCap(uint _capPercentage) public isOwner {\n        DEFEND_BOOST_CAP = _capPercentage;\n    }\n\n    // TILE-RELATED FUNCTIONS\n    // This function claims multiple previously unclaimed tiles in a single transaction.\n    // The value assigned to each tile is the msg.value divided by the number of tiles claimed.\n    // The msg.value is required to be an even multiple of the number of tiles claimed.\n    function storeInitialClaim(address _msgSender, uint16[] _claimedTileIds, uint _claimAmount, bool _useBattleValue) public isValidCaller {\n        uint tileCount = _claimedTileIds.length;\n        require(tileCount > 0);\n        require(_claimAmount >= 1 finney * tileCount); // ensure enough funds paid for all tiles\n        require(_claimAmount % tileCount == 0); // ensure payment is an even multiple of number of tiles claimed\n\n        uint valuePerBlockInWei = _claimAmount.div(tileCount); // Due to requires above this is guaranteed to be an even number\n        require(valuePerBlockInWei >= 5 finney);\n\n        if (_useBattleValue) {\n            subUserBattleValue(_msgSender, _claimAmount, false);  \n        }\n\n        addGlobalBlockValueBalance(_claimAmount);\n\n        uint16 tileId;\n        bool isNewTile;\n        for (uint16 i = 0; i < tileCount; i++) {\n            tileId = _claimedTileIds[i];\n            isNewTile = bwData.isNewTile(tileId); // Is length 0 if first time purchased\n            require(isNewTile); // Can only claim previously unclaimed tiles.\n\n            // Send claim event\n            emit TileClaimed(tileId, _msgSender, valuePerBlockInWei, block.timestamp);\n\n            // Update contract state with new tile ownership.\n            bwData.storeClaim(tileId, _msgSender, valuePerBlockInWei);\n        }\n    }\n\n    function fortifyClaims(address _msgSender, uint16[] _claimedTileIds, uint _fortifyAmount, bool _useBattleValue) public isValidCaller {\n        uint tileCount = _claimedTileIds.length;\n        require(tileCount > 0);\n\n        address(this).balance.add(_fortifyAmount); // prevent overflow with SafeMath\n        require(_fortifyAmount % tileCount == 0); // ensure payment is an even multiple of number of tiles fortified\n        uint addedValuePerTileInWei = _fortifyAmount.div(tileCount); // Due to requires above this is guaranteed to be an even number\n        require(_fortifyAmount >= 1 finney * tileCount); // ensure enough funds paid for all tiles\n\n        address claimer;\n        uint blockValue;\n        for (uint16 i = 0; i < tileCount; i++) {\n            (claimer, blockValue) = bwData.getTileClaimerAndBlockValue(_claimedTileIds[i]);\n            require(claimer != 0); // Can't do this on never-owned tiles\n            require(claimer == _msgSender); // Only current claimer can fortify claim\n\n            if (_useBattleValue) {\n                subUserBattleValue(_msgSender, addedValuePerTileInWei, false);\n            }\n            \n            fortifyClaim(_msgSender, _claimedTileIds[i], addedValuePerTileInWei);\n        }\n    }\n\n    function fortifyClaim(address _msgSender, uint16 _claimedTileId, uint _fortifyAmount) private {\n        uint blockValue;\n        uint sellPrice;\n        (blockValue, sellPrice) = bwData.getCurrentBlockValueAndSellPriceForTile(_claimedTileId);\n        uint updatedBlockValue = blockValue.add(_fortifyAmount);\n        // Send fortify event\n        emit TileFortified(_claimedTileId, _msgSender, _fortifyAmount, updatedBlockValue, block.timestamp);\n        \n        // Update tile value. The tile has been fortified by bumping up its value.\n        bwData.updateTileBlockValue(_claimedTileId, updatedBlockValue);\n\n        // Track addition to global block value\n        addGlobalBlockValueBalance(_fortifyAmount);\n    }\n\n    // Return a pseudo random number between lower and upper bounds\n    // given the number of previous blocks it should hash.\n    // Random function copied from https://github.com/axiomzen/eth-random/blob/master/contracts/Random.sol.\n    // Changed sha3 to keccak256, then modified.\n    // Changed random range from uint64 to uint (=uint256).\n    function random(uint _upper) private returns (uint)  {\n        seed = uint(keccak256(blockhash(block.number - 1), block.coinbase, block.timestamp, seed, address(0x3f5CE5FBFe3E9af3971dD833D26bA9b5C936f0bE).balance));\n        return seed % _upper;\n    }\n\n    // A user tries to claim a tile that's already owned by another user. A battle ensues.\n    // A random roll is done with % based on attacking vs defending amounts.\n    function attackTile(address _msgSender, uint16 _tileId, uint _attackAmount, bool _useBattleValue) public isValidCaller {\n        require(_attackAmount >= 1 finney);         // Don't allow attacking with less than one base tile price.\n        require(_attackAmount % 1 finney == 0);\n\n        address claimer;\n        uint blockValue;\n        (claimer, blockValue) = bwData.getTileClaimerAndBlockValue(_tileId);\n        \n        require(claimer != 0); // Can't do this on never-owned tiles\n        require(claimer != _msgSender); // Can't attack one's own tiles\n        require(claimer != owner); // Can't attack owner's tiles because it is used for raffle.\n\n        // Calculate boosted amounts for attacker and defender\n        // The base attack amount is sent in the by the user.\n        // The base defend amount is the attacked tile's current blockValue.\n        uint attackBoost;\n        uint defendBoost;\n        (attackBoost, defendBoost) = bwData.calculateBattleBoost(_tileId, _msgSender, claimer);\n\n        // Adjust boost to optimize game strategy\n        attackBoost = attackBoost.mul(ATTACK_BOOST_MULTIPLIER).div(100);\n        defendBoost = defendBoost.mul(DEFEND_BOOST_MULTIPLIER).div(100);\n        \n        // Cap the boost to minimize its impact (prevents whales somehow)\n        if (attackBoost > _attackAmount.mul(ATTACK_BOOST_CAP).div(100)) {\n            attackBoost = _attackAmount.mul(ATTACK_BOOST_CAP).div(100);\n        }\n        if (defendBoost > blockValue.mul(DEFEND_BOOST_CAP).div(100)) {\n            defendBoost = blockValue.mul(DEFEND_BOOST_CAP).div(100);\n        }\n\n        uint totalAttackAmount = _attackAmount.add(attackBoost);\n        uint totalDefendAmount = blockValue.add(defendBoost);\n\n        // Verify that attack odds are within allowed range.\n        require(totalAttackAmount.div(10) <= totalDefendAmount); // Disallow attacks with more than 1000% of defendAmount\n        require(totalAttackAmount >= totalDefendAmount.div(10)); // Disallow attacks with less than 10% of defendAmount\n\n        uint attackFeeAmount = _attackAmount.mul(ATTACK_FEE).div(100);\n        uint attackAmountAfterFee = _attackAmount.sub(attackFeeAmount);\n        \n        updateFeeBalance(attackFeeAmount);\n\n        // The battle considers boosts.\n        uint attackRoll = random(totalAttackAmount.add(totalDefendAmount)); // This is where the excitement happens!\n\n        //gas cost of attack branch is higher than denfense branch solving MSB1\n        if (attackRoll > totalDefendAmount) {\n            // Change block owner but keep same block value (attacker got battlevalue instead)\n            bwData.setClaimerForTile(_tileId, _msgSender);\n\n            // Tile successfully attacked!\n            if (_useBattleValue) {\n                // Withdraw followed by deposit of same amount to prevent MSB1\n                addUserBattleValue(_msgSender, attackAmountAfterFee); // Don't include boost here!\n                subUserBattleValue(_msgSender, attackAmountAfterFee, false);\n            } else {\n                addUserBattleValue(_msgSender, attackAmountAfterFee); // Don't include boost here!\n            }\n            addUserBattleValue(claimer, 0);\n\n            bwData.updateTileTimeStamp(_tileId);\n            // Send update event\n            emit TileAttackedSuccessfully(_tileId, _msgSender, attackAmountAfterFee, totalAttackAmount, claimer, blockValue, totalDefendAmount, attackRoll, block.timestamp);\n        } else {\n            bwData.setClaimerForTile(_tileId, claimer); //should be old owner\n            // Tile successfully defended!\n            if (_useBattleValue) {\n                subUserBattleValue(_msgSender, attackAmountAfterFee, false); // Don't include boost here!\n            }\n            addUserBattleValue(claimer, attackAmountAfterFee); // Don't include boost here!\n            \n            // Send update event\n            emit TileDefendedSuccessfully(_tileId, _msgSender, attackAmountAfterFee, totalAttackAmount, claimer, blockValue, totalDefendAmount, attackRoll, block.timestamp);\n        }\n    }\n\n    function updateFeeBalance(uint attackFeeAmount) private {\n        uint feeBalance = bwData.getFeeBalance();\n        feeBalance = feeBalance.add(attackFeeAmount);\n        bwData.setFeeBalance(feeBalance);\n    }\n\n    function moveBlockValue(address _msgSender, uint8 _xSource, uint8 _ySource, uint8 _xDest, uint8 _yDest, uint _moveAmount) public isValidCaller {\n        uint16 sourceTileId = BWUtility.toTileId(_xSource, _ySource);\n        uint16 destTileId = BWUtility.toTileId(_xDest, _yDest);\n\n        address sourceTileClaimer;\n        address destTileClaimer;\n        uint sourceTileBlockValue;\n        uint destTileBlockValue;\n        (sourceTileClaimer, sourceTileBlockValue) = bwData.getTileClaimerAndBlockValue(sourceTileId);\n        (destTileClaimer, destTileBlockValue) = bwData.getTileClaimerAndBlockValue(destTileId);\n\n        uint newBlockValue = sourceTileBlockValue.sub(_moveAmount);\n        // Must transfer the entire block value or leave at least 5\n        require(newBlockValue == 0 || newBlockValue >= 5 finney);\n\n        require(sourceTileClaimer == _msgSender);\n        require(destTileClaimer == _msgSender);\n        require(_moveAmount >= 1 finney); // Can't be less\n        require(_moveAmount % 1 finney == 0); // Move amount must be in multiples of 1 finney\n        // require(sourceTile.blockValue - _moveAmount >= BASE_TILE_PRICE_WEI); // Must always leave some at source\n        \n        require(BWUtility.isAdjacent(_xSource, _ySource, _xDest, _yDest));\n\n        sourceTileBlockValue = sourceTileBlockValue.sub(_moveAmount);\n        destTileBlockValue = destTileBlockValue.add(_moveAmount);\n\n        // If ALL block value was moved away from the source tile, we lose our claim to it. It becomes ownerless.\n        if (sourceTileBlockValue == 0) {\n            bwData.deleteTile(sourceTileId);\n        } else {\n            bwData.updateTileBlockValue(sourceTileId, sourceTileBlockValue);\n            bwData.deleteOffer(sourceTileId); // Offer invalid since block value has changed\n        }\n\n        bwData.updateTileBlockValue(destTileId, destTileBlockValue);\n        bwData.deleteOffer(destTileId);   // Offer invalid since block value has changed\n        emit BlockValueMoved(sourceTileId, destTileId, _msgSender, _moveAmount, sourceTileBlockValue, destTileBlockValue, block.timestamp);        \n    }\n\n    function verifyAmount(address _msgSender, uint _msgValue, uint _amount, bool _useBattleValue) view public isValidCaller {\n        if (_useBattleValue) {\n            require(_msgValue == 0);\n            require(bwData.getUserBattleValue(_msgSender) >= _amount);\n        } else {\n            require(_amount == _msgValue);\n        }\n    }\n\n    function setLocalGame(uint16 _tileId, address localGameAddress) public isOwner {\n        localGames[_tileId] = localGameAddress;\n    }\n\n    function getLocalGame(uint16 _tileId) view public isValidCaller returns (address) {\n        return localGames[_tileId];\n    }\n\n    // BATTLE VALUE FUNCTIONS\n    function withdrawBattleValue(address msgSender, uint _battleValueInWei) public isValidCaller returns (uint) {\n        //require(_battleValueInWei % 1 finney == 0); // Must be divisible by 1 finney\n        uint fee = _battleValueInWei.mul(WITHDRAW_FEE).div(100); // Since we divide by 20 we can never create infinite fractions, so we'll always count in whole wei amounts.\n        uint amountToWithdraw = _battleValueInWei.sub(fee);\n        uint feeBalance = bwData.getFeeBalance();\n        feeBalance = feeBalance.add(fee);\n        bwData.setFeeBalance(feeBalance);\n        subUserBattleValue(msgSender, _battleValueInWei, true);\n        return amountToWithdraw;\n    }\n\n    function addUserBattleValue(address _userId, uint _amount) public isValidCaller {\n        uint userBattleValue = bwData.getUserBattleValue(_userId);\n        uint newBattleValue = userBattleValue.add(_amount);\n        bwData.setUserBattleValue(_userId, newBattleValue); // Don't include boost here!\n        emit UserBattleValueUpdated(_userId, newBattleValue, false);\n    }\n    \n    function subUserBattleValue(address _userId, uint _amount, bool _isWithdraw) public isValidCaller {\n        uint userBattleValue = bwData.getUserBattleValue(_userId);\n        require(_amount <= userBattleValue); // Must be less than user's battle value - also implicitly checks that underflow isn't possible\n        uint newBattleValue = userBattleValue.sub(_amount);\n        bwData.setUserBattleValue(_userId, newBattleValue); // Don't include boost here!\n        emit UserBattleValueUpdated(_userId, newBattleValue, _isWithdraw);\n    }\n\n    function addGlobalBlockValueBalance(uint _amount) public isValidCaller {\n        // Track addition to global block value.\n        uint blockValueBalance = bwData.getBlockValueBalance();\n        bwData.setBlockValueBalance(blockValueBalance.add(_amount));\n    }\n\n    function subGlobalBlockValueBalance(uint _amount) public isValidCaller {\n        // Track addition to global block value.\n        uint blockValueBalance = bwData.getBlockValueBalance();\n        bwData.setBlockValueBalance(blockValueBalance.sub(_amount));\n    }\n\n    // Allow us to transfer out airdropped tokens if we ever receive any\n    function transferTokens(address _tokenAddress, address _recipient) public isOwner {\n        ERC20I token = ERC20I(_tokenAddress);\n        require(token.transfer(_recipient, token.balanceOf(this)));\n    }\n}\n\n\n\n\n\ncontract BWData {\n    address public owner;\n    address private bwService;\n    address private bw;\n    address private bwMarket;\n\n    uint private blockValueBalance = 0;\n    uint private feeBalance = 0;\n    uint private BASE_TILE_PRICE_WEI = 1 finney; // 1 milli-ETH.\n    \n    mapping (address => User) private users; // user address -> user information\n    mapping (uint16 => Tile) private tiles; // tileId -> list of TileClaims for that particular tile\n    \n    // Info about the users = those who have purchased tiles.\n    struct User {\n        uint creationTime;\n        bool censored;\n        uint battleValue;\n    }\n\n    // Info about a tile ownership\n    struct Tile {\n        address claimer;\n        uint blockValue;\n        uint creationTime;\n        uint sellPrice;    // If 0 -> not on marketplace. If > 0 -> on marketplace.\n    }\n\n    struct Boost {\n        uint8 numAttackBoosts;\n        uint8 numDefendBoosts;\n        uint attackBoost;\n        uint defendBoost;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    // Can't send funds straight to this contract. Avoid people sending by mistake.\n    function () payable public {\n        revert();\n    }\n\n    function kill() public isOwner {\n        selfdestruct(owner);\n    }\n\n    modifier isValidCaller {\n        if (msg.sender != bwService && msg.sender != bw && msg.sender != bwMarket) {\n            revert();\n        }\n        _;\n    }\n    \n    modifier isOwner {\n        if (msg.sender != owner) {\n            revert();\n        }\n        _;\n    }\n    \n    function setBwServiceValidCaller(address _bwService) public isOwner {\n        bwService = _bwService;\n    }\n\n    function setBwValidCaller(address _bw) public isOwner {\n        bw = _bw;\n    }\n\n    function setBwMarketValidCaller(address _bwMarket) public isOwner {\n        bwMarket = _bwMarket;\n    }    \n    \n    // ----------USER-RELATED GETTER FUNCTIONS------------\n    \n    //function getUser(address _user) view public returns (bytes32) {\n        //BWUtility.User memory user = users[_user];\n        //require(user.creationTime != 0);\n        //return (user.creationTime, user.imageUrl, user.tag, user.email, user.homeUrl, user.creationTime, user.censored, user.battleValue);\n    //}\n    \n    function addUser(address _msgSender) public isValidCaller {\n        User storage user = users[_msgSender];\n        require(user.creationTime == 0);\n        user.creationTime = block.timestamp;\n    }\n\n    function hasUser(address _user) view public isValidCaller returns (bool) {\n        return users[_user].creationTime != 0;\n    }\n    \n\n    // ----------TILE-RELATED GETTER FUNCTIONS------------\n\n    function getTile(uint16 _tileId) view public isValidCaller returns (address, uint, uint, uint) {\n        Tile storage currentTile = tiles[_tileId];\n        return (currentTile.claimer, currentTile.blockValue, currentTile.creationTime, currentTile.sellPrice);\n    }\n    \n    function getTileClaimerAndBlockValue(uint16 _tileId) view public isValidCaller returns (address, uint) {\n        Tile storage currentTile = tiles[_tileId];\n        return (currentTile.claimer, currentTile.blockValue);\n    }\n    \n    function isNewTile(uint16 _tileId) view public isValidCaller returns (bool) {\n        Tile storage currentTile = tiles[_tileId];\n        return currentTile.creationTime == 0;\n    }\n    \n    function storeClaim(uint16 _tileId, address _claimer, uint _blockValue) public isValidCaller {\n        tiles[_tileId] = Tile(_claimer, _blockValue, block.timestamp, 0);\n    }\n\n    function updateTileBlockValue(uint16 _tileId, uint _blockValue) public isValidCaller {\n        tiles[_tileId].blockValue = _blockValue;\n    }\n\n    function setClaimerForTile(uint16 _tileId, address _claimer) public isValidCaller {\n        tiles[_tileId].claimer = _claimer;\n    }\n\n    function updateTileTimeStamp(uint16 _tileId) public isValidCaller {\n        tiles[_tileId].creationTime = block.timestamp;\n    }\n    \n    function getCurrentClaimerForTile(uint16 _tileId) view public isValidCaller returns (address) {\n        Tile storage currentTile = tiles[_tileId];\n        if (currentTile.creationTime == 0) {\n            return 0;\n        }\n        return currentTile.claimer;\n    }\n\n    function getCurrentBlockValueAndSellPriceForTile(uint16 _tileId) view public isValidCaller returns (uint, uint) {\n        Tile storage currentTile = tiles[_tileId];\n        if (currentTile.creationTime == 0) {\n            return (0, 0);\n        }\n        return (currentTile.blockValue, currentTile.sellPrice);\n    }\n    \n    function getBlockValueBalance() view public isValidCaller returns (uint){\n        return blockValueBalance;\n    }\n\n    function setBlockValueBalance(uint _blockValueBalance) public isValidCaller {\n        blockValueBalance = _blockValueBalance;\n    }\n\n    function getFeeBalance() view public isValidCaller returns (uint) {\n        return feeBalance;\n    }\n\n    function setFeeBalance(uint _feeBalance) public isValidCaller {\n        feeBalance = _feeBalance;\n    }\n    \n    function getUserBattleValue(address _userId) view public isValidCaller returns (uint) {\n        return users[_userId].battleValue;\n    }\n    \n    function setUserBattleValue(address _userId, uint _battleValue) public  isValidCaller {\n        users[_userId].battleValue = _battleValue;\n    }\n    \n    function verifyAmount(address _msgSender, uint _msgValue, uint _amount, bool _useBattleValue) view public isValidCaller {\n        User storage user = users[_msgSender];\n        require(user.creationTime != 0);\n\n        if (_useBattleValue) {\n            require(_msgValue == 0);\n            require(user.battleValue >= _amount);\n        } else {\n            require(_amount == _msgValue);\n        }\n    }\n    \n    function addBoostFromTile(Tile _tile, address _attacker, address _defender, Boost memory _boost) pure private {\n        if (_tile.claimer == _attacker) {\n            require(_boost.attackBoost + _tile.blockValue >= _tile.blockValue); // prevent overflow\n            _boost.attackBoost += _tile.blockValue;\n            _boost.numAttackBoosts += 1;\n        } else if (_tile.claimer == _defender) {\n            require(_boost.defendBoost + _tile.blockValue >= _tile.blockValue); // prevent overflow\n            _boost.defendBoost += _tile.blockValue;\n            _boost.numDefendBoosts += 1;\n        }\n    }\n\n    function calculateBattleBoost(uint16 _tileId, address _attacker, address _defender) view public isValidCaller returns (uint, uint) {\n        uint8 x;\n        uint8 y;\n\n        (x, y) = BWUtility.fromTileId(_tileId);\n\n        Boost memory boost = Boost(0, 0, 0, 0);\n        // We overflow x, y on purpose here if x or y is 0 or 255 - the map overflows and so should adjacency.\n        // Go through all adjacent tiles to (x, y).\n        if (y != 255) {\n            if (x != 255) {\n                addBoostFromTile(tiles[BWUtility.toTileId(x+1, y+1)], _attacker, _defender, boost);\n            }\n            \n            addBoostFromTile(tiles[BWUtility.toTileId(x, y+1)], _attacker, _defender, boost);\n\n            if (x != 0) {\n                addBoostFromTile(tiles[BWUtility.toTileId(x-1, y+1)], _attacker, _defender, boost);\n            }\n        }\n\n        if (x != 255) {\n            addBoostFromTile(tiles[BWUtility.toTileId(x+1, y)], _attacker, _defender, boost);\n        }\n\n        if (x != 0) {\n            addBoostFromTile(tiles[BWUtility.toTileId(x-1, y)], _attacker, _defender, boost);\n        }\n\n        if (y != 0) {\n            if(x != 255) {\n                addBoostFromTile(tiles[BWUtility.toTileId(x+1, y-1)], _attacker, _defender, boost);\n            }\n\n            addBoostFromTile(tiles[BWUtility.toTileId(x, y-1)], _attacker, _defender, boost);\n\n            if(x != 0) {\n                addBoostFromTile(tiles[BWUtility.toTileId(x-1, y-1)], _attacker, _defender, boost);\n            }\n        }\n        // The benefit of boosts is multiplicative (quadratic):\n        // - More boost tiles gives a higher total blockValue (the sum of the adjacent tiles)\n        // - More boost tiles give a higher multiple of that total blockValue that can be used (10% per adjacent tie)\n        // Example:\n        //   A) I boost attack with 1 single tile worth 10 finney\n        //      -> Total boost is 10 * 1 / 10 = 1 finney\n        //   B) I boost attack with 3 tiles worth 1 finney each\n        //      -> Total boost is (1+1+1) * 3 / 10 = 0.9 finney\n        //   C) I boost attack with 8 tiles worth 2 finney each\n        //      -> Total boost is (2+2+2+2+2+2+2+2) * 8 / 10 = 14.4 finney\n        //   D) I boost attack with 3 tiles of 1, 5 and 10 finney respectively\n        //      -> Total boost is (ss1+5+10) * 3 / 10 = 4.8 finney\n        // This division by 10 can't create fractions since our uint is wei, and we can't have overflow from the multiplication\n        // We do allow fractions of finney here since the boosted values aren't stored anywhere, only used for attack rolls and sent in events\n        boost.attackBoost = (boost.attackBoost / 10 * boost.numAttackBoosts);\n        boost.defendBoost = (boost.defendBoost / 10 * boost.numDefendBoosts);\n\n        return (boost.attackBoost, boost.defendBoost);\n    }\n    \n    function censorUser(address _userAddress, bool _censored) public isValidCaller {\n        User storage user = users[_userAddress];\n        require(user.creationTime != 0);\n        user.censored = _censored;\n    }\n    \n    function deleteTile(uint16 _tileId) public isValidCaller {\n        delete tiles[_tileId];\n    }\n    \n    function setSellPrice(uint16 _tileId, uint _sellPrice) public isValidCaller {\n        tiles[_tileId].sellPrice = _sellPrice;  //testrpc cannot estimate gas when delete is used.\n    }\n\n    function deleteOffer(uint16 _tileId) public isValidCaller {\n        tiles[_tileId].sellPrice = 0;  //testrpc cannot estimate gas when delete is used.\n    }\n}\n\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n* Copyright 2018 Block Wars Team\n*\n*/\n\ninterface LocalGameI {\n    function getBountyBalance() view external returns (uint);\n    function getTimeLeftToNextCollect(address _claimer, uint _latestClaimTime) view external returns (uint);\n    function collectBounty(address _msgSender, uint _latestClaimTime, uint _amount) external returns (uint);\n}\n\n/*\n* @title ERC721 interface\n*/\ncontract ERC721 {\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\n    ///  may be created and assigned without emitting Transfer. At the time of\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\n    //event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n\n    /// @dev This emits when the approved address for an NFT is changed or\n    ///  reaffirmed. The zero address indicates there is no approved address.\n    ///  When a Transfer event emits, this also indicates that the approved\n    ///  address for that NFT (if any) is reset to none.\n    //event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n\n    /// @dev This emits when an operator is enabled or disabled for an owner.\n    ///  The operator can manage all NFTs of the owner.\n    //event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n    /// @notice Count all NFTs assigned to an owner\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\n    ///  function throws for queries about the zero address.\n    /// @param _owner An address for whom to query the balance\n    /// @return The number of NFTs owned by `_owner`, possibly zero\n    function balanceOf(address _owner) external view returns (uint256);\n\n    /// @notice Find the owner of an NFT\n    /// @param _tokenId The identifier for an NFT\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\n    ///  about them do throw.\n    /// @return The address of the owner of the NFT\n    function ownerOf(uint256 _tokenId) external view returns (address);\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\n    ///  `onERC721Received` on `_to` and throws if the return value is not\n    ///  `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`.\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    /// @param data Additional data with no specified format, sent in call to `_to`\n    //function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable;\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n    /// @dev This works identically to the other function with an extra data parameter,\n    ///  except this function just sets data to \"\"\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\n\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n    ///  THEY MAY BE PERMANENTLY LOST\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\n    ///  `_tokenId` is not a valid NFT.\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    //function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\n\n    /// @notice Set or reaffirm the approved address for an NFT\n    /// @dev The zero address indicates there is no approved address.\n    /// @dev Throws unless `msg.sender` is the current NFT owner, or an authorized\n    ///  operator of the current owner.\n    /// @param _approved The new approved NFT controller\n    /// @param _tokenId The NFT to approve\n    //function approve(address _approved, uint256 _tokenId) external payable;\n\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\n    ///  all of `msg.sender`'s assets.\n    /// @dev Emits the ApprovalForAll event\n    /// @param _operator Address to add to the set of authorized operators.\n    /// @param _approved True if the operators is approved, false to revoke approval\n    //function setApprovalForAll(address _operator, bool _approved) external;\n\n    /// @notice Get the approved address for a single NFT\n    /// @dev Throws if `_tokenId` is not a valid NFT\n    /// @param _tokenId The NFT to find the approved address for\n    /// @return The approved address for this NFT, or the zero address if there is none\n    //function getApproved(uint256 _tokenId) external view returns (address);\n\n    /// @notice Query if an address is an authorized operator for another address\n    /// @param _owner The address that owns the NFTs\n    /// @param _operator The address that acts on behalf of the owner\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n    //function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceID The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n    //function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n\ncontract BW { \n    using SafeMath for uint256;\n    address public owner;\n    BWService private bwService;\n    BWData private bwData;\n    bool public paused = false;\n    uint private BV_TO_BP_FEE = 5; // 5%\n    mapping (uint16 => Prize[]) private prizes; // Use mapping instead of array (key would be a unique priceId) - NO (we want to loop all prices)\n    \n    struct Prize {\n        address token; // BWT or CryptoKiities (ERC721)\n        uint tokenId; \n        uint startTime; // To be able to add a price before the game starts\n        uint hodlPeriod; // Amount of seconds you have to own the tile before being able to claim this price. One block is ~15 sec.\n    }\n\n    event PrizeCreated(uint16 tileId,  address token, uint tokenId, uint creationTime, uint startTime, uint hodlPeriod);\n    event PrizeRemoved(uint16 tileId, address token, uint tokenId, uint removeTime);\n    event PrizeClaimed(address token, uint tokenId);\n\n    // Add price (only BW owner can do this)\n    function addPrize(uint16 _tileId, address _token, uint _tokenId, uint _startTime, uint _hodlPeriod) public isOwner {\n        //startTime must be same or after block.timestamp\n        uint startTime = _startTime;\n        if(startTime < block.timestamp) {\n            startTime = block.timestamp;\n        }\n        // we could check if token exists with ownerOf function in interface, \n        // but if any erc721 token doesn't implement the function, this function would revert.\n        // also cheaper to not make an interface call\n        prizes[_tileId].push(Prize(_token, _tokenId, startTime, _hodlPeriod));\n        emit PrizeCreated(_tileId, _token, _tokenId, block.timestamp, startTime, _hodlPeriod);\n    }\n\n    // Remove price (only BW owner can do this)\n    function removePrize(uint16 _tileId, address _token, uint _tokenId) public isOwner {\n        Prize[] storage prizeArr = prizes[_tileId];\n        require(prizeArr.length > 0);\n\n        for(uint idx = 0; idx < prizeArr.length; ++idx) {\n            if(prizeArr[idx].tokenId == _tokenId && prizeArr[idx].token == _token) {\n                delete prizeArr[idx];\n                emit PrizeRemoved(_tileId, _token, _tokenId, block.timestamp);\n            }\n        }\n    }\n\n    // Add price (only BW owner can do this)\n    function claimPrize(address _tokenAddress, uint16 _tileId) public isNotPaused isNotContractCaller {\n        ERC721 token = ERC721(_tokenAddress);\n        Prize[] storage prizeArr = prizes[_tileId];\n        require(prizeArr.length > 0);\n        address claimer;\n        uint blockValue;\n        uint lastClaimTime;\n        uint sellPrice;\n        (claimer, blockValue, lastClaimTime, sellPrice) = bwData.getTile(_tileId);\n        require(lastClaimTime != 0 && claimer == msg.sender);\n\n        for(uint idx = 0; idx < prizeArr.length; ++idx) {\n            if(prizeArr[idx].startTime.add(prizeArr[idx].hodlPeriod) <= block.timestamp\n                && lastClaimTime.add(prizeArr[idx].hodlPeriod) <= block.timestamp) {\n                uint tokenId = prizeArr[idx].tokenId;\n                address tokenOwner = token.ownerOf(tokenId);\n                delete prizeArr[idx];\n                token.safeTransferFrom(tokenOwner, msg.sender, tokenId); //Will revert if token does not exists\n                emit PrizeClaimed(_tokenAddress, tokenId);\n            }\n        }\n    }\n\n    modifier isOwner {\n        if (msg.sender != owner) {\n            revert();\n        }\n        _;\n    }\n\n    // Checks if entire game (except battle value withdraw) is paused or not.\n    modifier isNotPaused {\n        if (paused) {\n            revert();\n        }\n        _;\n    }\n\n    // Only allow wallets to call this function, not contracts.\n    modifier isNotContractCaller {\n        require(msg.sender == tx.origin);\n        _;\n    }\n\n    // All contract event types.\n    event UserCreated(address userAddress, bytes32 name, bytes imageUrl, bytes32 tag, bytes32 homeUrl, uint creationTime, address invitedBy);\n    event UserCensored(address userAddress, bool isCensored);\n    event TransferTileFromOwner(uint16 tileId, address seller, address buyer, uint acceptTime); // Sent when a user buys a tile from another user, by accepting a tile offer\n    event UserUpdated(address userAddress, bytes32 name, bytes imageUrl, bytes32 tag, bytes32 homeUrl, uint updateTime);\n    event TileRetreated(uint16 tileId, address owner, uint amount, uint newBlockValue, uint retreatTime);\n    event BountyCollected(uint tile, address userAddress, uint amount, uint amountCollected, uint collectedTime, uint latestClaimTime);\n\n    // BASIC CONTRACT FUNCTIONS\n    constructor(address _bwService, address _bwData) public {\n        bwService = BWService(_bwService);\n        bwData = BWData(_bwData);\n        owner = msg.sender;\n    }\n\n    // Can't send funds straight to this contract. Avoid people sending by mistake.\n    function () payable public isOwner {\n\n    }\n\n    // Allow a new user to claim one or more previously unclaimed tiles by paying Ether.\n    function claimTilesForNewUser(bytes32 _name, bytes _imageUrl, bytes32 _tag, bytes32 _homeUrl, uint16[] _claimedTileIds, address _invitedBy) payable public isNotPaused isNotContractCaller {\n        bwData.addUser(msg.sender);\n        emit UserCreated(msg.sender, _name, _imageUrl, _tag, _homeUrl, block.timestamp, _invitedBy);\n        bwService.storeInitialClaim(msg.sender, _claimedTileIds, msg.value, false);\n    }\n\n    // Allow an existing user to claim one or more previously unclaimed tiles by paying Ether.\n    function claimTilesForExistingUser(uint16[] _claimedTileIds, uint _claimAmount, bool _useBattleValue) payable public isNotPaused isNotContractCaller {\n        bwService.verifyAmount(msg.sender, msg.value, _claimAmount, _useBattleValue);\n        bwService.storeInitialClaim(msg.sender, _claimedTileIds, _claimAmount, _useBattleValue);\n    }\n\n    // Allow users to change name, image URL, tag and home URL. Not censored status or battle value though.\n    function updateUser(bytes32 _name, bytes _imageUrl, bytes32 _tag, bytes32 _homeUrl) public isNotPaused isNotContractCaller {\n        require(bwData.hasUser(msg.sender));\n        // All the updated values are stored in events only so there's no state to update on the contract here.\n        emit UserUpdated(msg.sender, _name, _imageUrl, _tag, _homeUrl, block.timestamp);\n    }\n    \n    // This function fortifies multiple previously claimed tiles in a single transaction.\n    // The value assigned to each tile is the msg.value divided by the number of tiles fortified.\n    // The msg.value is required to be an even multiple of the number of tiles fortified.\n    // Only tiles owned by msg.sender can be fortified.\n    function fortifyClaims(uint16[] _claimedTileIds, uint _fortifyAmount, bool _useBattleValue) payable public isNotPaused isNotContractCaller {\n        bwService.verifyAmount(msg.sender, msg.value, _fortifyAmount, _useBattleValue);\n        bwService.fortifyClaims(msg.sender, _claimedTileIds, _fortifyAmount, _useBattleValue);\n    }\n\n    // A new user attacks a tile claimed by someone else, trying to make it theirs through battle.\n    function attackTileForNewUser(uint16 _tileId, bytes32 _name, bytes _imageUrl, bytes32 _tag, bytes32 _homeUrl, address _invitedBy) payable public isNotPaused isNotContractCaller {\n        bwData.addUser(msg.sender);\n        emit UserCreated(msg.sender, _name, _imageUrl, _tag, _homeUrl, block.timestamp, _invitedBy);\n        bwService.attackTile(msg.sender, _tileId, msg.value, false);\n    }\n\n    // An existing user attacks a tile claimed by someone else, trying to make it theirs through battle.\n    function attackTileForExistingUser(uint16 _tileId, uint _attackAmount, bool _useBattleValue) payable public isNotPaused isNotContractCaller {\n        bwService.verifyAmount(msg.sender, msg.value, _attackAmount, _useBattleValue);\n        bwService.attackTile(msg.sender, _tileId, _attackAmount, _useBattleValue);\n    }\n    \n    // Move \"army\" = block value from one block to an adjacent block. Moving ALL value equates giving up ownership of the source tile.\n    function moveBlockValue(uint8 _xSource, uint8 _ySource, uint8 _xDest, uint8 _yDest, uint _moveAmount) public isNotPaused isNotContractCaller {\n        require(_moveAmount > 0);\n        bwService.moveBlockValue(msg.sender, _xSource, _ySource, _xDest, _yDest, _moveAmount);\n    }\n\n    // Allow users to withdraw battle value in Ether.\n    function withdrawBattleValue(uint _battleValueInWei) public isNotContractCaller {\n        require(_battleValueInWei > 0);\n        uint amountToWithdraw = bwService.withdrawBattleValue(msg.sender, _battleValueInWei);\n        msg.sender.transfer(amountToWithdraw);\n    }\n\n    // Transfer block value to battle points for free \n    function transferBlockValueToBattleValue(uint16 _tileId, uint _amount) public isNotContractCaller {\n        require(_amount > 0);\n        address claimer;\n        uint blockValue;\n        (claimer, blockValue) = bwData.getTileClaimerAndBlockValue(_tileId);\n        require(claimer == msg.sender);\n        uint newBlockValue = blockValue.sub(_amount);\n        // Must transfer the entire block value or leave at least 5\n        require(newBlockValue == 0 || newBlockValue >= 5 finney);\n        if(newBlockValue == 0) {\n            bwData.deleteTile(_tileId);\n        } else {\n            bwData.updateTileBlockValue(_tileId, newBlockValue);\n            bwData.deleteOffer(_tileId); // Offer invalid since block value has changed\n        }\n        \n        uint fee = _amount.mul(BV_TO_BP_FEE).div(100);\n        uint userAmount = _amount.sub(fee);\n        uint feeBalance = bwData.getFeeBalance();\n        feeBalance = feeBalance.add(fee);\n        bwData.setFeeBalance(feeBalance);\n\n        bwService.addUserBattleValue(msg.sender, userAmount);\n        bwService.subGlobalBlockValueBalance(_amount);\n        emit TileRetreated(_tileId, msg.sender, _amount, newBlockValue, block.timestamp);\n    }\n\n    // -------- LOCAL GAME FUNCTIONS ----------\n\n    function getLocalBountyBalance(uint16 _tileId) view public isNotContractCaller returns (uint) {\n        address localGameAddress = bwService.getLocalGame(_tileId);\n        require(localGameAddress != 0);\n        LocalGameI localGame = LocalGameI(localGameAddress);\n        return localGame.getBountyBalance();\n    }\n\n    function getTimeLeftToNextLocalBountyCollect(uint16 _tileId) view public isNotContractCaller returns (uint) {\n        address localGameAddress = bwService.getLocalGame(_tileId);\n        require(localGameAddress != 0);\n        LocalGameI localGame = LocalGameI(localGameAddress);\n        address claimer;\n        uint blockValue;\n        uint latestClaimTime;\n        uint sellPrice;\n        (claimer, blockValue, latestClaimTime, sellPrice) = bwData.getTile(_tileId);\n        return localGame.getTimeLeftToNextCollect(claimer, latestClaimTime);\n    }\n\n    function collectLocalBounty(uint16 _tileId, uint _amount) public isNotContractCaller {\n        address localGameAddress = bwService.getLocalGame(_tileId);\n        require(localGameAddress != 0);\n        address claimer;\n        uint blockValue;\n        uint latestClaimTime;\n        uint sellPrice;\n        (claimer, blockValue, latestClaimTime, sellPrice) = bwData.getTile(_tileId);\n        require(latestClaimTime != 0 && claimer == msg.sender);\n        \n        LocalGameI localGame = LocalGameI(localGameAddress);\n        uint amountCollected = localGame.collectBounty(msg.sender, latestClaimTime, _amount);\n        emit BountyCollected(_tileId, msg.sender, _amount, amountCollected, block.timestamp, latestClaimTime);\n    }\n\n    // -------- OWNER-ONLY FUNCTIONS ----------\n\n    // Only used by owner for raffle. Owner need name, address and picture from user.\n    // These users can then be given tiles by owner using transferTileFromOwner.\n    function createNewUser(bytes32 _name, bytes _imageUrl, bytes32 _tag, bytes32 _homeUrl, address _user) public isOwner {\n        bwData.addUser(_user);\n        emit UserCreated(_user, _name, _imageUrl, _tag, _homeUrl, block.timestamp, msg.sender); //check on client if invitedBy is owner.\n    }\n\n    // Allow updating censored status. Owner only. In case someone uploads offensive content.\n    // The contract owners reserve the right to apply censorship. This will mean that the\n    // name, tag or URL images might not be displayed for a censored user.\n    function censorUser(address _userAddress, bool _censored) public isOwner {\n        bwData.censorUser(_userAddress, _censored);\n        emit UserCensored(_userAddress, _censored);\n    }\n\n    // Pause the entire game, but let users keep withdrawing battle value\n    function setPaused(bool _paused) public isOwner {\n        paused = _paused;\n    }\n\n    function kill() public isOwner {\n        selfdestruct(owner);\n    }\n    \n    function withdrawFee() public isOwner {\n        uint balance = address(this).balance;\n        uint amountToWithdraw = bwData.getFeeBalance();\n\n        if (balance < amountToWithdraw) { // Should never happen, but paranoia\n            amountToWithdraw = balance;\n        }\n        bwData.setFeeBalance(0);\n\n        owner.transfer(amountToWithdraw);\n    }\n\n    function getFee() view public isOwner returns (uint) {\n        return bwData.getFeeBalance();\n    }\n\n    function setBvToBpFee(uint _feePercentage) public isOwner {\n        BV_TO_BP_FEE = _feePercentage;\n    }\n\n    function depositBattleValue(address _user) payable public isOwner {\n        require(msg.value % 1 finney == 0); // Must be divisible by 1 finney\n        bwService.addUserBattleValue(_user, msg.value);\n    }\n\n    // The owner can transfer ownership of own tiles to other users, as prizes in competitions.\n    function transferTileFromOwner(uint16[] _tileIds, address _newOwner) public isOwner {\n        for(uint i = 0; i < _tileIds.length; ++i) {\n            uint16 tileId = _tileIds[i];\n            address claimer = bwData.getCurrentClaimerForTile(tileId);\n            require(claimer == owner);\n            bwData.setClaimerForTile(tileId, _newOwner);\n            \n            emit TransferTileFromOwner(tileId, _newOwner, msg.sender, block.timestamp);\n        }\n    }\n\n    // Allow us to transfer out airdropped tokens if we ever receive any\n    function transferTokens(address _tokenAddress, address _recipient) public isOwner {\n        ERC20I token = ERC20I(_tokenAddress);\n        require(token.transfer(_recipient, token.balanceOf(this)));\n    }\n}",
  "bytecode": "60806040526000600260146101000a81548160ff021916908315150217905550600560035534801561003057600080fd5b50604051604080614ae3833981018060405281019080805190602001909291908051906020019092919050505081600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555080600260006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550336000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050506149b3806101306000396000f30060806040526004361061015f576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063021ea45e146101bc578063124c27a91461022b57806316c38b3c1461029a578063292a9873146102c95780632ad2ae2e1461037d57806341c0e1b5146103b85780634fb0d95e146103cf578063531ef079146104145780635c975abb146104415780636a092e79146104705780637746167f146104d35780637a0e2d1a1461050e5780638beb9f12146105a15780638da5cb5b14610602578063a00545b214610659578063ad0a6cc3146106aa578063ae7fa597146106e4578063b01800f81461073f578063b607ea45146107f2578063c022ef43146108db578063c0338a0c14610920578063c26181e0146109a6578063ced72f87146109f5578063e3e5075c14610a20578063e430930714610a56578063e941fa7814610ac5578063f53773dc14610adc575b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415156101ba57600080fd5b005b6102296004803603810190808035906020019082018035906020019080806020026020016040519081016040528093929190818152602001838360200280828437820191505050505050919291929080359060200190929190803515159060200190929190505050610b09565b005b34801561023757600080fd5b50610298600480360381019080803561ffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803590602001909291908035906020019092919080359060200190929190505050610d85565b005b3480156102a657600080fd5b506102c7600480360381019080803515159060200190929190505050610f72565b005b61037b600480360381019080803561ffff1690602001909291908035600019169060200190929190803590602001908201803590602001908080601f016020809104026020016040519081016040528093929190818152602001838380828437820191505050505050919291929080356000191690602001909291908035600019169060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610fea565b005b34801561038957600080fd5b506103b6600480360381019080803561ffff16906020019092919080359060200190929190505050611351565b005b3480156103c457600080fd5b506103cd611760565b005b3480156103db57600080fd5b506103fe600480360381019080803561ffff1690602001909291905050506117f5565b6040518082815260200191505060405180910390f35b34801561042057600080fd5b5061043f600480360381019080803590602001909291905050506119db565b005b34801561044d57600080fd5b50610456611a40565b604051808215151515815260200191505060405180910390f35b34801561047c57600080fd5b506104d1600480360381019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611a53565b005b3480156104df57600080fd5b5061050c600480360381019080803561ffff16906020019092919080359060200190929190505050611c76565b005b34801561051a57600080fd5b5061059f6004803603810190808035600019169060200190929190803590602001908201803590602001908080601f016020809104026020016040519081016040528093929190818152602001838380828437820191505050505050919291929080356000191690602001909291908035600019169060200190929190505050612422565b005b3480156105ad57600080fd5b50610600600480360381019080803560ff169060200190929190803560ff169060200190929190803560ff169060200190929190803560ff16906020019092919080359060200190929190505050612687565b005b34801561060e57600080fd5b50610617612806565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b34801561066557600080fd5b506106a8600480360381019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803561ffff16906020019092919050505061282b565b005b6106e2600480360381019080803561ffff16906020019092919080359060200190929190803515159060200190929190505050612d4f565b005b3480156106f057600080fd5b5061073d600480360381019080803561ffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050612f92565b005b34801561074b57600080fd5b506107f06004803603810190808035600019169060200190929190803590602001908201803590602001908080601f016020809104026020016040519081016040528093929190818152602001838380828437820191505050505050919291929080356000191690602001909291908035600019169060200190929190803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506131c2565b005b6108d96004803603810190808035600019169060200190929190803590602001908201803590602001908080601f01602080910402602001604051908101604052809392919081815260200183838082843782019150505050505091929192908035600019169060200190929190803560001916906020019092919080359060200190820180359060200190808060200260200160405190810160405280939291908181526020018383602002808284378201915050505050509192919290803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050613435565b005b3480156108e757600080fd5b5061090a600480360381019080803561ffff1690602001909291905050506137d5565b6040518082815260200191505060405180910390f35b34801561092c57600080fd5b506109a460048036038101908080359060200190820180359060200190808060200260200160405190810160405280939291908181526020018383602002808284378201915050505050509192919290803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050613b06565b005b3480156109b257600080fd5b506109f3600480360381019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803515159060200190929190505050613e65565b005b348015610a0157600080fd5b50610a0a614014565b6040518082815260200191505060405180910390f35b610a54600480360381019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050614137565b005b610ac36004803603810190808035906020019082018035906020019080806020026020016040519081016040528093929190818152602001838360200280828437820191505050505050919291929080359060200190929190803515159060200190929190505050614293565b005b348015610ad157600080fd5b50610ada61450f565b005b348015610ae857600080fd5b50610b076004803603810190808035906020019092919050505061476c565b005b600260149054906101000a900460ff1615610b2357600080fd5b3273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16141515610b5d57600080fd5b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166332214874333485856040518563ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200184815260200183815260200182151515158152602001945050505050600060405180830381600087803b158015610c3657600080fd5b505af1158015610c4a573d6000803e3d6000fd5b50505050600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663d4212e93338585856040518563ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018060200184815260200183151515158152602001828103825285818151815260200191508051906020019060200280838360005b83811015610d40578082015181840152602081019050610d25565b5050505090500195505050505050600060405180830381600087803b158015610d6857600080fd5b505af1158015610d7c573d6000803e3d6000fd5b50505050505050565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16141515610de257600080fd5b82905042811015610df1574290505b600460008761ffff1661ffff1681526020019081526020016000206080604051908101604052808773ffffffffffffffffffffffffffffffffffffffff168152602001868152602001838152602001848152509080600181540180825580915050906001820390600052602060002090600402016000909192909190915060008201518160000160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506020820151816001015560408201518160020155606082015181600301555050507f95b8377701688cfdeae0067b4ef836749389a319ef3951dfc9b9a0662704e11e868686428587604051808761ffff1661ffff1681526020018673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001858152602001848152602001838152602001828152602001965050505050505060405180910390a1505050505050565b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16141515610fcd57600080fd5b80600260146101000a81548160ff02191690831515021790555050565b600260149054906101000a900460ff161561100457600080fd5b3273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614151561103e57600080fd5b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663421b2d8b336040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050600060405180830381600087803b1580156110fb57600080fd5b505af115801561110f573d6000803e3d6000fd5b505050507ff1e08403e8c6577dc32cd66518e15d1663f8bffdd495f968daa71684b278e90833868686864287604051808873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001876000191660001916815260200180602001866000191660001916815260200185600019166000191681526020018481526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001828103825287818151815260200191508051906020019080838360005b8381101561120f5780820151818401526020810190506111f4565b50505050905090810190601f16801561123c5780820380516001836020036101000a031916815260200191505b509850505050505050505060405180910390a1600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166372852fe533883460006040518563ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018461ffff1661ffff16815260200183815260200182151515158152602001945050505050600060405180830381600087803b15801561133157600080fd5b505af1158015611345573d6000803e3d6000fd5b50505050505050505050565b60008060008060008060003273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614151561139657600080fd5b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16631ba3afd38a6040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808261ffff1661ffff168152602001915050602060405180830381600087803b15801561142f57600080fd5b505af1158015611443573d6000803e3d6000fd5b505050506040513d602081101561145957600080fd5b8101908080519060200190929190505050965060008773ffffffffffffffffffffffffffffffffffffffff161415151561149257600080fd5b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663ac2c8bb58a6040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808261ffff1661ffff168152602001915050608060405180830381600087803b15801561152b57600080fd5b505af115801561153f573d6000803e3d6000fd5b505050506040513d608081101561155557600080fd5b810190808051906020019092919080519060200190929190805190602001909291908051906020019092919050505080965081975082985083995050505050600084141580156115d057503373ffffffffffffffffffffffffffffffffffffffff168673ffffffffffffffffffffffffffffffffffffffff16145b15156115db57600080fd5b8691508173ffffffffffffffffffffffffffffffffffffffff16630f88f1a533868b6040518463ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018381526020018281526020019350505050602060405180830381600087803b15801561168957600080fd5b505af115801561169d573d6000803e3d6000fd5b505050506040513d60208110156116b357600080fd5b810190808051906020019092919050505090507f9579a77b52045388aad0d9a4d23dac16c17649936242f724ccd8e0984fce495e89338a844289604051808761ffff1681526020018673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001858152602001848152602001838152602001828152602001965050505050505060405180910390a1505050505050505050565b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415156117bb57600080fd5b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16ff5b60008060003273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614151561183457600080fd5b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16631ba3afd3856040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808261ffff1661ffff168152602001915050602060405180830381600087803b1580156118cd57600080fd5b505af11580156118e1573d6000803e3d6000fd5b505050506040513d60208110156118f757600080fd5b8101908080519060200190929190505050915060008273ffffffffffffffffffffffffffffffffffffffff161415151561193057600080fd5b8190508073ffffffffffffffffffffffffffffffffffffffff166372067d496040518163ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401602060405180830381600087803b15801561199757600080fd5b505af11580156119ab573d6000803e3d6000fd5b505050506040513d60208110156119c157600080fd5b810190808051906020019092919050505092505050919050565b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16141515611a3657600080fd5b8060038190555050565b600260149054906101000a900460ff1681565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16141515611ab057600080fd5b8290508073ffffffffffffffffffffffffffffffffffffffff1663a9059cbb838373ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050602060405180830381600087803b158015611b6b57600080fd5b505af1158015611b7f573d6000803e3d6000fd5b505050506040513d6020811015611b9557600080fd5b81019080805190602001909291905050506040518363ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200182815260200192505050602060405180830381600087803b158015611c2b57600080fd5b505af1158015611c3f573d6000803e3d6000fd5b505050506040513d6020811015611c5557600080fd5b81019080805190602001909291905050501515611c7157600080fd5b505050565b6000806000806000803273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16141515611cb957600080fd5b600087111515611cc857600080fd5b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166357cc5941896040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808261ffff1661ffff1681526020019150506040805180830381600087803b158015611d6057600080fd5b505af1158015611d74573d6000803e3d6000fd5b505050506040513d6040811015611d8a57600080fd5b81019080805190602001909291908051906020019092919050505080965081975050503373ffffffffffffffffffffffffffffffffffffffff168673ffffffffffffffffffffffffffffffffffffffff16141515611de757600080fd5b611dfa878661490490919063ffffffff16565b93506000841480611e1257506611c37937e080008410155b1515611e1d57600080fd5b6000841415611edc57600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663f4010db0896040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808261ffff1661ffff168152602001915050600060405180830381600087803b158015611ebf57600080fd5b505af1158015611ed3573d6000803e3d6000fd5b50505050612047565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16639ea6954189866040518363ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808361ffff1661ffff16815260200182815260200192505050600060405180830381600087803b158015611f7d57600080fd5b505af1158015611f91573d6000803e3d6000fd5b50505050600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663bff10815896040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808261ffff1661ffff168152602001915050600060405180830381600087803b15801561202e57600080fd5b505af1158015612042573d6000803e3d6000fd5b505050505b61206f60646120616003548a61491d90919063ffffffff16565b61495590919063ffffffff16565b9250612084838861490490919063ffffffff16565b9150600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663d4c30ceb6040518163ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401602060405180830381600087803b15801561210c57600080fd5b505af1158015612120573d6000803e3d6000fd5b505050506040513d602081101561213657600080fd5b8101908080519060200190929190505050905061215c838261496b90919063ffffffff16565b9050600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16638580eb2f826040518263ffffffff167c010000000000000000000000000000000000000000000000000000000002815260040180828152602001915050600060405180830381600087803b1580156121ef57600080fd5b505af1158015612203573d6000803e3d6000fd5b50505050600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663330ae7b333846040518363ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200182815260200192505050600060405180830381600087803b1580156122cc57600080fd5b505af11580156122e0573d6000803e3d6000fd5b50505050600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16639f08fc38886040518263ffffffff167c010000000000000000000000000000000000000000000000000000000002815260040180828152602001915050600060405180830381600087803b15801561237557600080fd5b505af1158015612389573d6000803e3d6000fd5b505050507febf382a69d356c17e7446397e5c296bfd479081e62e71e9b7e157db51b379a068833898742604051808661ffff1661ffff1681526020018573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018481526020018381526020018281526020019550505050505060405180910390a15050505050505050565b600260149054906101000a900460ff161561243c57600080fd5b3273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614151561247657600080fd5b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a6c4ec0e336040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050602060405180830381600087803b15801561253357600080fd5b505af1158015612547573d6000803e3d6000fd5b505050506040513d602081101561255d57600080fd5b8101908080519060200190929190505050151561257957600080fd5b7ff1d9d3a279c958c3eafa779ad7a67dde66017e5dfc1989b5cf249e7b58661d12338585858542604051808773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200186600019166000191681526020018060200185600019166000191681526020018460001916600019168152602001838152602001828103825286818151815260200191508051906020019080838360005b83811015612642578082015181840152602081019050612627565b50505050905090810190601f16801561266f5780820380516001836020036101000a031916815260200191505b5097505050505050505060405180910390a150505050565b600260149054906101000a900460ff16156126a157600080fd5b3273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415156126db57600080fd5b6000811115156126ea57600080fd5b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663fe562ee63387878787876040518763ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018660ff1660ff1681526020018560ff1660ff1681526020018460ff1660ff1681526020018360ff1660ff1681526020018281526020019650505050505050600060405180830381600087803b1580156127e757600080fd5b505af11580156127fb573d6000803e3d6000fd5b505050505050505050565b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6000806000806000806000806000600260149054906101000a900460ff161561285357600080fd5b3273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614151561288d57600080fd5b8a9850600460008b61ffff1661ffff1681526020019081526020016000209750600088805490501115156128c057600080fd5b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663ac2c8bb58b6040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808261ffff1661ffff168152602001915050608060405180830381600087803b15801561295957600080fd5b505af115801561296d573d6000803e3d6000fd5b505050506040513d608081101561298357600080fd5b8101908080519060200190929190805190602001909291908051906020019092919080519060200190929190505050809750819850829950839a5050505050600085141580156129fe57503373ffffffffffffffffffffffffffffffffffffffff168773ffffffffffffffffffffffffffffffffffffffff16145b1515612a0957600080fd5b600092505b8780549050831015612d425742612a6c8985815481101515612a2c57fe5b9060005260206000209060040201600301548a86815481101515612a4c57fe5b90600052602060002090600402016002015461496b90919063ffffffff16565b11158015612aab575042612aa88985815481101515612a8757fe5b9060005260206000209060040201600301548761496b90919063ffffffff16565b11155b15612d37578783815481101515612abe57fe5b90600052602060002090600402016001015491508873ffffffffffffffffffffffffffffffffffffffff16636352211e836040518263ffffffff167c010000000000000000000000000000000000000000000000000000000002815260040180828152602001915050602060405180830381600087803b158015612b4157600080fd5b505af1158015612b55573d6000803e3d6000fd5b505050506040513d6020811015612b6b57600080fd5b810190808051906020019092919050505090508783815481101515612b8c57fe5b9060005260206000209060040201600080820160006101000a81549073ffffffffffffffffffffffffffffffffffffffff021916905560018201600090556002820160009055600382016000905550508873ffffffffffffffffffffffffffffffffffffffff166342842e0e8233856040518463ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018281526020019350505050600060405180830381600087803b158015612cb357600080fd5b505af1158015612cc7573d6000803e3d6000fd5b505050507f95681e512bc0fe659e195e06c283eada494316f3d801213e48e7101af92bf7708b83604051808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018281526020019250505060405180910390a15b826001019250612a0e565b5050505050505050505050565b600260149054906101000a900460ff1615612d6957600080fd5b3273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16141515612da357600080fd5b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166332214874333485856040518563ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200184815260200183815260200182151515158152602001945050505050600060405180830381600087803b158015612e7c57600080fd5b505af1158015612e90573d6000803e3d6000fd5b50505050600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166372852fe5338585856040518563ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018461ffff1661ffff16815260200183815260200182151515158152602001945050505050600060405180830381600087803b158015612f7557600080fd5b505af1158015612f89573d6000803e3d6000fd5b50505050505050565b6000806000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16141515612ff057600080fd5b600460008661ffff1661ffff16815260200190815260200160002091506000828054905011151561302057600080fd5b600090505b81805490508110156131bb5782828281548110151561304057fe5b9060005260206000209060040201600101541480156130c957508373ffffffffffffffffffffffffffffffffffffffff16828281548110151561307f57fe5b906000526020600020906004020160000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16145b156131b05781818154811015156130dc57fe5b9060005260206000209060040201600080820160006101000a81549073ffffffffffffffffffffffffffffffffffffffff021916905560018201600090556002820160009055600382016000905550507f46cc5a4ac65c49e4620e528287cf1c349db9515832147e43a7532aa93a8dfdd485858542604051808561ffff1661ffff1681526020018473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200183815260200182815260200194505050505060405180910390a15b806001019050613025565b5050505050565b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614151561321d57600080fd5b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663421b2d8b826040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050600060405180830381600087803b1580156132da57600080fd5b505af11580156132ee573d6000803e3d6000fd5b505050507ff1e08403e8c6577dc32cd66518e15d1663f8bffdd495f968daa71684b278e90881868686864233604051808873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001876000191660001916815260200180602001866000191660001916815260200185600019166000191681526020018481526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001828103825287818151815260200191508051906020019080838360005b838110156133ee5780820151818401526020810190506133d3565b50505050905090810190601f16801561341b5780820380516001836020036101000a031916815260200191505b509850505050505050505060405180910390a15050505050565b600260149054906101000a900460ff161561344f57600080fd5b3273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614151561348957600080fd5b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663421b2d8b336040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050600060405180830381600087803b15801561354657600080fd5b505af115801561355a573d6000803e3d6000fd5b505050507ff1e08403e8c6577dc32cd66518e15d1663f8bffdd495f968daa71684b278e90833878787874287604051808873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001876000191660001916815260200180602001866000191660001916815260200185600019166000191681526020018481526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001828103825287818151815260200191508051906020019080838360005b8381101561365a57808201518184015260208101905061363f565b50505050905090810190601f1680156136875780820380516001836020036101000a031916815260200191505b509850505050505050505060405180910390a1600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663d4212e9333843460006040518563ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018060200184815260200183151515158152602001828103825285818151815260200191508051906020019060200280838360005b8381101561378d578082015181840152602081019050613772565b5050505090500195505050505050600060405180830381600087803b1580156137b557600080fd5b505af11580156137c9573d6000803e3d6000fd5b50505050505050505050565b60008060008060008060003273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614151561381a57600080fd5b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16631ba3afd3896040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808261ffff1661ffff168152602001915050602060405180830381600087803b1580156138b357600080fd5b505af11580156138c7573d6000803e3d6000fd5b505050506040513d60208110156138dd57600080fd5b8101908080519060200190929190505050955060008673ffffffffffffffffffffffffffffffffffffffff161415151561391657600080fd5b859450600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663ac2c8bb5896040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808261ffff1661ffff168152602001915050608060405180830381600087803b1580156139b257600080fd5b505af11580156139c6573d6000803e3d6000fd5b505050506040513d60808110156139dc57600080fd5b8101908080519060200190929190805190602001909291908051906020019092919080519060200190929190505050809450819550829650839750505050508473ffffffffffffffffffffffffffffffffffffffff166380a1ba6a85846040518363ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200182815260200192505050602060405180830381600087803b158015613abe57600080fd5b505af1158015613ad2573d6000803e3d6000fd5b505050506040513d6020811015613ae857600080fd5b81019080805190602001909291905050509650505050505050919050565b60008060008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16141515613b6657600080fd5b600092505b8451831015613e5e578483815181101515613b8257fe5b906020019060200201519150600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663aae40ddc836040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808261ffff1661ffff168152602001915050602060405180830381600087803b158015613c2757600080fd5b505af1158015613c3b573d6000803e3d6000fd5b505050506040513d6020811015613c5157600080fd5b810190808051906020019092919050505090506000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16141515613cbf57600080fd5b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16632f54a61e83866040518363ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808361ffff1661ffff1681526020018273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200192505050600060405180830381600087803b158015613d8c57600080fd5b505af1158015613da0573d6000803e3d6000fd5b505050507f0936305ed8fb00934042531a7c9b5ac31f245e8891500f7ea7192f3912e2530f82853342604051808561ffff1661ffff1681526020018473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200182815260200194505050505060405180910390a1826001019250613b6b565b5050505050565b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16141515613ec057600080fd5b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663c26181e083836040518363ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018215151515815260200192505050600060405180830381600087803b158015613f8957600080fd5b505af1158015613f9d573d6000803e3d6000fd5b505050507fc661a5cc93e5e19e1839d5e38cc38bd2d6397f2e1396b1e167894642e8b44ce98282604051808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001821515151581526020019250505060405180910390a15050565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614151561407157600080fd5b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663d4c30ceb6040518163ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401602060405180830381600087803b1580156140f757600080fd5b505af115801561410b573d6000803e3d6000fd5b505050506040513d602081101561412157600080fd5b8101908080519060200190929190505050905090565b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614151561419257600080fd5b600066038d7ea4c68000348115156141a657fe5b061415156141b357600080fd5b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663330ae7b382346040518363ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200182815260200192505050600060405180830381600087803b15801561427857600080fd5b505af115801561428c573d6000803e3d6000fd5b5050505050565b600260149054906101000a900460ff16156142ad57600080fd5b3273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415156142e757600080fd5b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166332214874333485856040518563ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200184815260200183815260200182151515158152602001945050505050600060405180830381600087803b1580156143c057600080fd5b505af11580156143d4573d6000803e3d6000fd5b50505050600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663c27bc7b2338585856040518563ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018060200184815260200183151515158152602001828103825285818151815260200191508051906020019060200280838360005b838110156144ca5780820151818401526020810190506144af565b5050505090500195505050505050600060405180830381600087803b1580156144f257600080fd5b505af1158015614506573d6000803e3d6000fd5b50505050505050565b6000806000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614151561456d57600080fd5b3073ffffffffffffffffffffffffffffffffffffffff16319150600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663d4c30ceb6040518163ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401602060405180830381600087803b15801561460d57600080fd5b505af1158015614621573d6000803e3d6000fd5b505050506040513d602081101561463757600080fd5b8101908080519060200190929190505050905080821015614656578190505b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16638580eb2f60006040518263ffffffff167c010000000000000000000000000000000000000000000000000000000002815260040180828152602001915050600060405180830381600087803b1580156146e857600080fd5b505af11580156146fc573d6000803e3d6000fd5b505050506000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166108fc829081150290604051600060405180830381858888f19350505050158015614767573d6000803e3d6000fd5b505050565b60003273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415156147a857600080fd5b6000821115156147b757600080fd5b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166311bb20da33846040518363ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200182815260200192505050602060405180830381600087803b15801561487c57600080fd5b505af1158015614890573d6000803e3d6000fd5b505050506040513d60208110156148a657600080fd5b810190808051906020019092919050505090503373ffffffffffffffffffffffffffffffffffffffff166108fc829081150290604051600060405180830381858888f193505050501580156148ff573d6000803e3d6000fd5b505050565b600082821115151561491257fe5b818303905092915050565b600080831415614930576000905061494f565b818302905081838281151561494157fe5b0414151561494b57fe5b8090505b92915050565b6000818381151561496257fe5b04905092915050565b6000818301905082811015151561497e57fe5b809050929150505600a165627a7a72305820ee7f70821b09947c36beeab5b3a2676c1d335f625776157a3245d04b16c860220029000000000000000000000000168848b7ec6c61bd452ee6e74ae85b07cc3b8d1700000000000000000000000053d34d53a692e6352565909acda5af9145f11bf6",
  "constructorArguments": "000000000000000000000000168848b7ec6c61bd452ee6e74ae85b07cc3b8d1700000000000000000000000053d34d53a692e6352565909acda5af9145f11bf6"
}