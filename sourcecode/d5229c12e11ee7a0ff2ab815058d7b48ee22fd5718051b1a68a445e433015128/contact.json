{
  "address": "0xeda8b016efa8b1161208cf041cd86972eee0f31e",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "CrowdsaleToken",
  "compilerVersion": "v0.4.19+commit.c4cbbb05",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2018-03-16\n*/\n\npragma solidity ^0.4.18;\n\ncontract SafeMathLib {\n  \n  function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function safeAdd(uint256 a, uint256 b) internal pure  returns (uint256) {\n    uint c = a + b;\n    assert(c>=a);\n    return c;\n  }\n  function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n}\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control \n * functions, this simplifies the implementation of \"user permissions\". \n */\ncontract Ownable {\n  address public owner;\n  address public newOwner;\n  event OwnershipTransferred(address indexed _from, address indexed _to);\n  /** \n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n\n  /**\n   * @dev Throws if called by any account other than the owner. \n   */\n  modifier onlyOwner {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to. \n   */\n  function transferOwnership(address _newOwner) public onlyOwner {\n    newOwner = _newOwner;\n  }\n\n  function acceptOwnership() public {\n    require(msg.sender == newOwner);\n    OwnershipTransferred(owner, newOwner);\n    owner =  newOwner;\n  }\n\n}\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  uint256 public totalSupply;\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * A token that defines fractional units as decimals.\n */\ncontract FractionalERC20 is ERC20 {\n  uint8 public decimals;\n}\n\n\n\n/**\n * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation.\n *\n * Based on code by FirstBlood:\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, SafeMathLib {\n  /* Token supply got increased and a new owner received these tokens */\n  event Minted(address receiver, uint256 amount);\n\n  /* Actual balances of token holders */\n  mapping(address => uint) balances;\n\n  /* approve() allowances */\n  mapping (address => mapping (address => uint256)) allowed;\n\n  function transfer(address _to, uint256 _value)\n  public\n  returns (bool) \n  { \n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = safeSub(balances[msg.sender],_value);\n    balances[_to] = safeAdd(balances[_to],_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n    \n  }\n\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    uint _allowance = allowed[_from][msg.sender];\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= _allowance);\n    require(balances[_to] + _value > balances[_to]);\n\n    balances[_to] = safeAdd(balances[_to],_value);\n    balances[_from] = safeSub(balances[_from],_value);\n    allowed[_from][msg.sender] = safeSub(_allowance,_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  function balanceOf(address _owner) public constant returns (uint balance) {\n    return balances[_owner];\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n   /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint256 _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = safeAdd(allowed[msg.sender][_spender],_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = safeSub(oldValue,_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n/**\n * @title Burnable Token\n * @dev Token that can be irreversibly burned (destroyed).\n */\ncontract BurnableToken is StandardToken {\n\n  event Burn(address indexed burner, uint256 value);\n\n  /**\n   * @dev Burns a specific amount of tokens.\n   * @param _value The amount of token to be burned.\n   */\n  function burn(uint256 _value) public {\n    require(_value <= balances[msg.sender]);\n    // no need to require value <= totalSupply, since that would imply the\n    // sender's balance is greater than the totalSupply, which *should* be an assertion failure\n\n    address burner = msg.sender;\n    balances[burner] = safeSub(balances[burner],_value);\n    totalSupply = safeSub(totalSupply,_value);\n    Burn(burner, _value);\n  }\n}\n\n/**\n * Upgrade agent interface inspired by Lunyr.\n *\n * Upgrade agent transfers tokens to a new contract.\n * Upgrade agent itself can be the token contract, or just a middle man contract doing the heavy lifting.\n */\ncontract UpgradeAgent {\n  uint public originalSupply;\n  /** Interface marker */\n  function isUpgradeAgent() public pure returns (bool) {\n    return true;\n  }\n  function upgradeFrom(address _from, uint256 _value) public;\n}\n\n\n/**\n * A token upgrade mechanism where users can opt-in amount of tokens to the next smart contract revision.\n *\n * First envisioned by Golem and Lunyr projects.\n */\ncontract UpgradeableToken is StandardToken {\n\n  /** Contract / person who can set the upgrade path. This can be the same as team multisig wallet, as what it is with its default value. */\n  address public upgradeMaster;\n\n  /** The next contract where the tokens will be migrated. */\n  UpgradeAgent public upgradeAgent;\n\n  /** How many tokens we have upgraded by now. */\n  uint256 public totalUpgraded;\n\n  /**\n   * Upgrade states.\n   *\n   * - NotAllowed: The child contract has not reached a condition where the upgrade can bgun\n   * - WaitingForAgent: Token allows upgrade, but we don't have a new agent yet\n   * - ReadyToUpgrade: The agent is set, but not a single token has been upgraded yet\n   * - Upgrading: Upgrade agent is set and the balance holders can upgrade their tokens\n   *\n   */\n  enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}\n\n  /**\n   * Somebody has upgraded some of his tokens.\n   */\n  event Upgrade(address indexed _from, address indexed _to, uint256 _value);\n\n  /**\n   * New upgrade agent available.\n   */\n  event UpgradeAgentSet(address agent);\n\n  /**\n   * Do not allow construction without upgrade master set.\n   */\n  function UpgradeableToken(address _upgradeMaster) public {\n    upgradeMaster = _upgradeMaster;\n  }\n\n  /**\n   * Allow the token holder to upgrade some of their tokens to a new contract.\n   */\n  function upgrade(uint256 value) public {\n    UpgradeState state = getUpgradeState();\n    require((state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading));\n\n    // Validate input value.\n    require (value != 0);\n\n    balances[msg.sender] = safeSub(balances[msg.sender],value);\n\n    // Take tokens out from circulation\n    totalSupply = safeSub(totalSupply,value);\n    totalUpgraded = safeAdd(totalUpgraded,value);\n\n    // Upgrade agent reissues the tokens\n    upgradeAgent.upgradeFrom(msg.sender, value);\n    Upgrade(msg.sender, upgradeAgent, value);\n  }\n\n  /**\n   * Set an upgrade agent that handles\n   */\n  function setUpgradeAgent(address agent) external {\n    require(canUpgrade());\n\n    require(agent != 0x0);\n    // Only a master can designate the next agent\n    require(msg.sender == upgradeMaster);\n    // Upgrade has already begun for an agent\n    require(getUpgradeState() != UpgradeState.Upgrading);\n\n    upgradeAgent = UpgradeAgent(agent);\n\n    // Bad interface\n    require(upgradeAgent.isUpgradeAgent());\n    // Make sure that token supplies match in source and target\n    require(upgradeAgent.originalSupply() == totalSupply);\n\n    UpgradeAgentSet(upgradeAgent);\n  }\n\n  /**\n   * Get the state of the token upgrade.\n   */\n  function getUpgradeState() public constant returns(UpgradeState) {\n    if(!canUpgrade()) return UpgradeState.NotAllowed;\n    else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;\n    else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;\n    else return UpgradeState.Upgrading;\n  }\n\n  /**\n   * Change the upgrade master.\n   *\n   * This allows us to set a new owner for the upgrade mechanism.\n   */\n  function setUpgradeMaster(address master) public {\n    require(master != 0x0);\n    require(msg.sender == upgradeMaster);\n    upgradeMaster = master;\n  }\n\n  /**\n   * Child contract can enable to provide the condition when the upgrade can begun.\n   */\n  function canUpgrade() public view returns(bool) {\n     return true;\n  }\n\n}\n\n/**\n * Define interface for releasing the token transfer after a successful crowdsale.\n */\ncontract ReleasableToken is ERC20, Ownable {\n\n  /* The finalizer contract that allows unlift the transfer limits on this token */\n  address public releaseAgent;\n\n  /** A crowdsale contract can release us to the wild if ICO success. If false we are are in transfer lock up period.*/\n  bool public released = false;\n\n  /** Map of agents that are allowed to transfer tokens regardless of the lock down period. These are crowdsale contracts and possible the team multisig itself. */\n  mapping (address => bool) public transferAgents;\n\n  /**\n   * Limit token transfer until the crowdsale is over.\n   *\n   */\n  modifier canTransfer(address _sender) {\n\n    if(!released) {\n        require(transferAgents[_sender]);\n    }\n\n    _;\n  }\n\n  /**\n   * Set the contract that can call release and make the token transferable.\n   *\n   * Design choice. Allow reset the release agent to fix fat finger mistakes.\n   */\n  function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\n\n    // We don't do interface check here as we might want to a normal wallet address to act as a release agent\n    releaseAgent = addr;\n  }\n\n  /**\n   * Owner can allow a particular address (a crowdsale contract) to transfer tokens despite the lock up period.\n   */\n  function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\n    transferAgents[addr] = state;\n  }\n\n  /**\n   * One way function to release the tokens to the wild.\n   *\n   * Can be called only from the release agent that is the final ICO contract. It is only called if the crowdsale has been success (first milestone reached).\n   */\n  function releaseTokenTransfer() public onlyReleaseAgent {\n    released = true;\n  }\n\n  /** The function can be called only before or after the tokens have been releasesd */\n  modifier inReleaseState(bool releaseState) {\n    require(releaseState == released);\n    _;\n  }\n\n  /** The function can be called only by a whitelisted release agent. */\n  modifier onlyReleaseAgent() {\n    require(msg.sender == releaseAgent);\n    _;\n  }\n\n  function transfer(address _to, uint _value) canTransfer(msg.sender) public returns (bool success) {\n    // Call StandardToken.transfer()\n   return super.transfer(_to, _value);\n  }\n\n  function transferFrom(address _from, address _to, uint _value) canTransfer(_from) public returns (bool success) {\n    // Call StandardToken.transferForm()\n    return super.transferFrom(_from, _to, _value);\n  }\n\n}\n\n/**\n * A token that can increase its supply by another contract.\n *\n * This allows uncapped crowdsale by dynamically increasing the supply when money pours in.\n * Only mint agents, contracts whitelisted by owner, can mint new tokens.\n *\n */\ncontract MintableToken is StandardToken, Ownable {\n\n  bool public mintingFinished = false;\n\n  /** List of agents that are allowed to create new tokens */\n  mapping (address => bool) public mintAgents;\n\n  event MintingAgentChanged(address addr, bool state);\n  event Mint(address indexed to, uint256 amount);\n\n  /**\n   * Create new tokens and allocate them to an address..\n   *\n   * Only callably by a crowdsale contract (mint agent).\n   */\n  function mint(address receiver, uint256 amount) onlyMintAgent canMint public returns(bool){\n    totalSupply = safeAdd(totalSupply, amount);\n    balances[receiver] = safeAdd(balances[receiver], amount);\n\n    // This will make the mint transaction apper in EtherScan.io\n    // We can remove this after there is a standardized minting event\n    Mint(receiver, amount);\n    Transfer(0, receiver, amount);\n    return true;\n  }\n\n  /**\n   * Owner can allow a crowdsale contract to mint new tokens.\n   */\n  function setMintAgent(address addr, bool state) onlyOwner canMint public {\n    mintAgents[addr] = state;\n    MintingAgentChanged(addr, state);\n  }\n\n  modifier onlyMintAgent() {\n    // Only crowdsale contracts are allowed to mint new tokens\n    require(mintAgents[msg.sender]);\n    _;\n  }\n\n  /** Make sure we are not done yet. */\n  modifier canMint() {\n    require(!mintingFinished);\n    _;\n  }\n}\n\n/**\n * A crowdsaled token.\n *\n * An ERC-20 token designed specifically for crowdsales with investor protection and further development path.\n *\n * - The token transfer() is disabled until the crowdsale is over\n * - The token contract gives an opt-in upgrade path to a new contract\n * - The same token can be part of several crowdsales through approve() mechanism\n * - The token can be capped (supply set in the constructor) or uncapped (crowdsale contract can mint new tokens)\n *\n */\ncontract CrowdsaleToken is ReleasableToken, MintableToken, UpgradeableToken, BurnableToken {\n\n  event UpdatedTokenInformation(string newName, string newSymbol);\n\n  string public name;\n\n  string public symbol;\n\n  uint8 public decimals;\n\n  /**\n   * Construct the token.\n   *\n   * This token must be created through a team multisig wallet, so that it is owned by that wallet.\n   *\n   * @param _name Token name\n   * @param _symbol Token symbol - should be all caps\n   * @param _initialSupply How many tokens we start with\n   * @param _decimals Number of decimal places\n   * @param _mintable Are new tokens created over the crowdsale or do we distribute only the initial supply? Note that when the token becomes transferable the minting always ends.\n   */\n  function CrowdsaleToken(string _name, string _symbol, uint _initialSupply, uint8 _decimals, bool _mintable)\n    public\n    UpgradeableToken(msg.sender) \n  {\n\n    // Create any address, can be transferred\n    // to team multisig via changeOwner(),\n    // also remember to call setUpgradeMaster()\n    owner = msg.sender;\n\n    name = _name;\n    symbol = _symbol;\n\n    totalSupply = _initialSupply;\n\n    decimals = _decimals;\n\n    // Create initially all balance on the team multisig\n    balances[owner] = totalSupply;\n\n    if(totalSupply > 0) {\n      Minted(owner, totalSupply);\n    }\n\n    // No more new supply allowed after the token creation\n    if(!_mintable) {\n      mintingFinished = true;\n      require(totalSupply != 0);\n    }\n  }\n\n  /**\n   * When token is released to be transferable, enforce no new tokens can be created.\n   */\n  function releaseTokenTransfer() public onlyReleaseAgent {\n    mintingFinished = true;\n    super.releaseTokenTransfer();\n  }\n\n  /**\n   * Allow upgrade agent functionality kick in only if the crowdsale was success.\n   */\n  function canUpgrade() public view returns(bool) {\n    return released && super.canUpgrade();\n  }\n\n  /**\n   * Owner can update token information here\n   */\n  function setTokenInformation(string _name, string _symbol) onlyOwner public {\n    name = _name;\n    symbol = _symbol;\n    UpdatedTokenInformation(name, symbol);\n  }\n\n}\n\n/**\n * Finalize agent defines what happens at the end of succeseful crowdsale.\n *\n * - Allocate tokens for founders, bounties and community\n * - Make tokens transferable\n * - etc.\n */\ncontract FinalizeAgent {\n\n  function isFinalizeAgent() public pure returns(bool) {\n    return true;\n  }\n\n  /** Return true if we can run finalizeCrowdsale() properly.\n   *\n   * This is a safety check function that doesn't allow crowdsale to begin\n   * unless the finalizer has been set up properly.\n   */\n  function isSane() public view returns (bool);\n\n  /** Called once by crowdsale finalize() if the sale was success. */\n  function finalizeCrowdsale() public ;\n\n}\n\n/**\n * Interface for defining crowdsale pricing.\n */\ncontract PricingStrategy {\n\n  /** Interface declaration. */\n  function isPricingStrategy() public pure returns (bool) {\n    return true;\n  }\n\n  /** Self check if all references are correctly set.\n   *\n   * Checks that pricing strategy matches crowdsale parameters.\n   */\n  function isSane(address crowdsale) public view returns (bool) {\n    return true;\n  }\n\n  /**\n   * When somebody tries to buy tokens for X eth, calculate how many tokens they get.\n   *\n   *\n   * @param value - What is the value of the transaction send in as wei\n   * @param tokensSold - how much tokens have been sold this far\n   * @param weiRaised - how much money has been raised this far\n   * @param msgSender - who is the investor of this transaction\n   * @param decimals - how many decimal units the token has\n   * @return Amount of tokens the investor receives\n   */\n  function calculatePrice(uint256 value, uint256 weiRaised, uint256 tokensSold, address msgSender, uint256 decimals) public constant returns (uint256 tokenAmount);\n}\n\n/*\n * Haltable\n *\n * Abstract contract that allows children to implement an\n * emergency stop mechanism. Differs from Pausable by causing a throw when in halt mode.\n *\n *\n * Originally envisioned in FirstBlood ICO contract.\n */\ncontract Haltable is Ownable {\n  bool public halted;\n\n  modifier stopInEmergency {\n    require(!halted);\n    _;\n  }\n\n  modifier onlyInEmergency {\n    require(halted);\n    _;\n  }\n\n  // called by the owner on emergency, triggers stopped state\n  function halt() external onlyOwner {\n    halted = true;\n  }\n\n  // called by the owner on end of emergency, returns to normal state\n  function unhalt() external onlyOwner onlyInEmergency {\n    halted = false;\n  }\n\n}\ncontract Allocatable is Ownable {\n\n  /** List of agents that are allowed to allocate new tokens */\n  mapping (address => bool) public allocateAgents;\n\n  event AllocateAgentChanged(address addr, bool state  );\n\n  /**\n   * Owner can allow a crowdsale contract to allocate new tokens.\n   */\n  function setAllocateAgent(address addr, bool state) onlyOwner public {\n    allocateAgents[addr] = state;\n    AllocateAgentChanged(addr, state);\n  }\n\n  modifier onlyAllocateAgent() {\n    // Only crowdsale contracts are allowed to allocate new tokens\n    require(allocateAgents[msg.sender]);\n    _;\n  }\n}\n\n/**\n * Abstract base contract for token sales.\n *\n * Handle\n * - start and end dates\n * - accepting investments\n * - minimum funding goal and refund\n * - various statistics during the crowdfund\n * - different pricing strategies\n * - different investment policies (require server side customer id, allow only whitelisted addresses)\n *\n */\ncontract Crowdsale is Allocatable, Haltable, SafeMathLib {\n\n  /* Max investment count when we are still allowed to change the multisig address */\n  uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\n\n  /* The token we are selling */\n  FractionalERC20 public token;\n\n  /* Token Vesting Contract */\n  address public tokenVestingAddress;\n\n  /* How we are going to price our offering */\n  PricingStrategy public pricingStrategy;\n\n  /* Post-success callback */\n  FinalizeAgent public finalizeAgent;\n\n  /* tokens will be transfered from this address */\n  address public multisigWallet;\n\n  /* if the funding goal is not reached, investors may withdraw their funds */\n  uint256 public minimumFundingGoal;\n\n  /* the UNIX timestamp start date of the crowdsale */\n  uint256 public startsAt;\n\n  /* the UNIX timestamp end date of the crowdsale */\n  uint256 public endsAt;\n\n  /* the number of tokens already sold through this contract*/\n  uint256 public tokensSold = 0;\n\n  /* How many wei of funding we have raised */\n  uint256 public weiRaised = 0;\n\n  /* How many distinct addresses have invested */\n  uint256 public investorCount = 0;\n\n  /* How much wei we have returned back to the contract after a failed crowdfund. */\n  uint256 public loadedRefund = 0;\n\n  /* How much wei we have given back to investors.*/\n  uint256 public weiRefunded = 0;\n\n  /* Has this crowdsale been finalized */\n  bool public finalized;\n\n  /* Do we need to have unique contributor id for each customer */\n  bool public requireCustomerId;\n\n  /**\n    * Do we verify that contributor has been cleared on the server side (accredited investors only).\n    * This method was first used in FirstBlood crowdsale to ensure all contributors have accepted terms on sale (on the web).\n    */\n  bool public requiredSignedAddress;\n\n  /* Server side address that signed allowed contributors (Ethereum addresses) that can participate the crowdsale */\n  address public signerAddress;\n\n  /** How much ETH each address has invested to this crowdsale */\n  mapping (address => uint256) public investedAmountOf;\n\n  /** How much tokens this crowdsale has credited for each investor address */\n  mapping (address => uint256) public tokenAmountOf;\n\n  /** Addresses that are allowed to invest even before ICO offical opens. For testing, for ICO partners, etc. */\n  mapping (address => bool) public earlyParticipantWhitelist;\n\n  /** This is for manul testing for the interaction from owner wallet. You can set it to any value and inspect this in blockchain explorer to see that crowdsale interaction works. */\n  uint256 public ownerTestValue;\n\n  uint256 public earlyPariticipantWeiPrice =82815734989648;\n\n  uint256 public whitelistBonusPercentage = 15;\n  uint256 public whitelistPrincipleLockPercentage = 50;\n  uint256 public whitelistBonusLockPeriod = 7776000;\n  uint256 public whitelistPrincipleLockPeriod = 7776000;\n\n  /** State machine\n   *\n   * - Preparing: All contract initialization calls and variables have not been set yet\n   * - Prefunding: We have not passed start time yet\n   * - Funding: Active crowdsale\n   * - Success: Minimum funding goal reached\n   * - Failure: Minimum funding goal not reached before ending time\n   * - Finalized: The finalized has been called and succesfully executed\n   * - Refunding: Refunds are loaded on the contract for reclaim.\n   */\n  enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized, Refunding}\n\n  // A new investment was made\n  event Invested(address investor, uint256 weiAmount, uint256 tokenAmount, uint128 customerId);\n\n  // Refund was processed for a contributor\n  event Refund(address investor, uint256 weiAmount);\n\n  // The rules were changed what kind of investments we accept\n  event InvestmentPolicyChanged(bool requireCustId, bool requiredSignedAddr, address signerAddr);\n\n  // Address early participation whitelist status changed\n  event Whitelisted(address addr, bool status);\n\n  // Crowdsale end time has been changed\n  event EndsAtChanged(uint256 endAt);\n\n  // Crowdsale start time has been changed\n  event StartAtChanged(uint256 endsAt);\n\n  function Crowdsale(address _token, PricingStrategy _pricingStrategy, address _multisigWallet, \n  uint256 _start, uint256 _end, uint256 _minimumFundingGoal, address _tokenVestingAddress) public \n  {\n\n    owner = msg.sender;\n\n    token = FractionalERC20(_token);\n\n    tokenVestingAddress = _tokenVestingAddress;\n\n    setPricingStrategy(_pricingStrategy);\n\n    multisigWallet = _multisigWallet;\n    require(multisigWallet != 0);\n\n    require(_start != 0);\n\n    startsAt = _start;\n\n    require(_end != 0);\n\n    endsAt = _end;\n\n    // Don't mess the dates\n    require(startsAt < endsAt);\n\n    // Minimum funding goal can be zero\n    minimumFundingGoal = _minimumFundingGoal;\n\n  }\n\n  /**\n   * Don't expect to just send in money and get tokens.\n   */\n  function() payable public {\n    invest(msg.sender);\n  }\n\n  /** Function to set default vesting schedule parameters. */\n    function setDefaultWhitelistVestingParameters(uint256 _bonusPercentage, uint256 _principleLockPercentage, uint256 _bonusLockPeriod, uint256 _principleLockPeriod, uint256 _earlyPariticipantWeiPrice) onlyAllocateAgent public {\n\n        whitelistBonusPercentage = _bonusPercentage;\n        whitelistPrincipleLockPercentage = _principleLockPercentage;\n        whitelistBonusLockPeriod = _bonusLockPeriod;\n        whitelistPrincipleLockPeriod = _principleLockPeriod;\n        earlyPariticipantWeiPrice = _earlyPariticipantWeiPrice;\n    }\n\n  /**\n   * Make an investment.\n   *\n   * Crowdsale must be running for one to invest.\n   * We must have not pressed the emergency brake.\n   *\n   * @param receiver The Ethereum address who receives the tokens\n   * @param customerId (optional) UUID v4 to track the successful payments on the server side\n   *\n   */\n  function investInternal(address receiver, uint128 customerId) stopInEmergency private {\n\n    uint256 tokenAmount;\n    uint256 weiAmount = msg.value;\n    // Determine if it's a good time to accept investment from this participant\n    if (getState() == State.PreFunding) {\n        // Are we whitelisted for early deposit\n        require(earlyParticipantWhitelist[receiver]);\n        require(weiAmount >= safeMul(15, uint(10 ** 18)));\n        require(weiAmount <= safeMul(50, uint(10 ** 18)));\n        tokenAmount = safeDiv(safeMul(weiAmount, uint(10) ** token.decimals()), earlyPariticipantWeiPrice);\n        \n        if (investedAmountOf[receiver] == 0) {\n          // A new investor\n          investorCount++;\n        }\n\n        // Update investor\n        investedAmountOf[receiver] = safeAdd(investedAmountOf[receiver],weiAmount);\n        tokenAmountOf[receiver] = safeAdd(tokenAmountOf[receiver],tokenAmount);\n\n        // Update totals\n        weiRaised = safeAdd(weiRaised,weiAmount);\n        tokensSold = safeAdd(tokensSold,tokenAmount);\n\n        // Check that we did not bust the cap\n        require(!isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold));\n\n        if (safeAdd(whitelistPrincipleLockPercentage,whitelistBonusPercentage) > 0) {\n\n            uint256 principleAmount = safeDiv(safeMul(tokenAmount, 100), safeAdd(whitelistBonusPercentage, 100));\n            uint256 bonusLockAmount = safeDiv(safeMul(whitelistBonusPercentage, principleAmount), 100);\n            uint256 principleLockAmount = safeDiv(safeMul(whitelistPrincipleLockPercentage, principleAmount), 100);\n\n            uint256 totalLockAmount = safeAdd(principleLockAmount, bonusLockAmount);\n            TokenVesting tokenVesting = TokenVesting(tokenVestingAddress);\n            \n            // to prevent minting of tokens which will be useless as vesting amount cannot be updated\n            require(!tokenVesting.isVestingSet(receiver));\n            require(totalLockAmount <= tokenAmount);\n            assignTokens(tokenVestingAddress,totalLockAmount);\n            \n            // set vesting with default schedule\n            tokenVesting.setVesting(receiver, principleLockAmount, whitelistPrincipleLockPeriod, bonusLockAmount, whitelistBonusLockPeriod); \n        }\n\n        // assign remaining tokens to contributor\n        if (tokenAmount - totalLockAmount > 0) {\n            assignTokens(receiver, tokenAmount - totalLockAmount);\n        }\n\n        // Pocket the money\n        require(multisigWallet.send(weiAmount));\n\n        // Tell us invest was success\n        Invested(receiver, weiAmount, tokenAmount, customerId);       \n\n    \n    } else if(getState() == State.Funding) {\n        // Retail participants can only come in when the crowdsale is running\n        tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());\n        require(tokenAmount != 0);\n\n\n        if(investedAmountOf[receiver] == 0) {\n          // A new investor\n          investorCount++;\n        }\n\n        // Update investor\n        investedAmountOf[receiver] = safeAdd(investedAmountOf[receiver],weiAmount);\n        tokenAmountOf[receiver] = safeAdd(tokenAmountOf[receiver],tokenAmount);\n\n        // Update totals\n        weiRaised = safeAdd(weiRaised,weiAmount);\n        tokensSold = safeAdd(tokensSold,tokenAmount);\n\n        // Check that we did not bust the cap\n        require(!isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold));\n\n        assignTokens(receiver, tokenAmount);\n\n        // Pocket the money\n        require(multisigWallet.send(weiAmount));\n\n        // Tell us invest was success\n        Invested(receiver, weiAmount, tokenAmount, customerId);\n\n    } else {\n      // Unwanted state\n      require(false);\n    }\n  }\n\n  /**\n   * allocate tokens for the early investors.\n   *\n   * Preallocated tokens have been sold before the actual crowdsale opens.\n   * This function mints the tokens and moves the crowdsale needle.\n   *\n   * Investor count is not handled; it is assumed this goes for multiple investors\n   * and the token distribution happens outside the smart contract flow.\n   *\n   * No money is exchanged, as the crowdsale team already have received the payment.\n   *\n   * @param weiPrice Price of a single full token in wei\n   *\n   */\n  function preallocate(address receiver, uint256 tokenAmount, uint256 weiPrice, uint256 principleLockAmount, uint256 principleLockPeriod, uint256 bonusLockAmount, uint256 bonusLockPeriod) public onlyAllocateAgent {\n\n\n    uint256 weiAmount = (weiPrice * tokenAmount)/10**uint256(token.decimals()); // This can be also 0, we give out tokens for free\n    uint256 totalLockAmount = 0;\n    weiRaised = safeAdd(weiRaised,weiAmount);\n    tokensSold = safeAdd(tokensSold,tokenAmount);\n\n    investedAmountOf[receiver] = safeAdd(investedAmountOf[receiver],weiAmount);\n    tokenAmountOf[receiver] = safeAdd(tokenAmountOf[receiver],tokenAmount);\n\n    // cannot lock more than total tokens\n    totalLockAmount = safeAdd(principleLockAmount, bonusLockAmount);\n    require(totalLockAmount <= tokenAmount);\n\n    // assign locked token to Vesting contract\n    if (totalLockAmount > 0) {\n\n      TokenVesting tokenVesting = TokenVesting(tokenVestingAddress);\n      \n      // to prevent minting of tokens which will be useless as vesting amount cannot be updated\n      require(!tokenVesting.isVestingSet(receiver));\n      assignTokens(tokenVestingAddress,totalLockAmount);\n      \n      // set vesting with default schedule\n      tokenVesting.setVesting(receiver, principleLockAmount, principleLockPeriod, bonusLockAmount, bonusLockPeriod); \n    }\n\n    // assign remaining tokens to contributor\n    if (tokenAmount - totalLockAmount > 0) {\n      assignTokens(receiver, tokenAmount - totalLockAmount);\n    }\n\n    // Tell us invest was success\n    Invested(receiver, weiAmount, tokenAmount, 0);\n  }\n\n  /**\n   * Track who is the customer making the payment so we can send thank you email.\n   */\n  function investWithCustomerId(address addr, uint128 customerId) public payable {\n    require(!requiredSignedAddress);\n    require(customerId != 0);\n    investInternal(addr, customerId);\n  }\n\n  /**\n   * Allow anonymous contributions to this crowdsale.\n   */\n  function invest(address addr) public payable {\n    require(!requireCustomerId);\n    \n    require(!requiredSignedAddress);\n    investInternal(addr, 0);\n  }\n\n  /**\n   * Invest to tokens, recognize the payer and clear his address.\n   *\n   */\n  \n  // function buyWithSignedAddress(uint128 customerId, uint8 v, bytes32 r, bytes32 s) public payable {\n  //   investWithSignedAddress(msg.sender, customerId, v, r, s);\n  // }\n\n  /**\n   * Invest to tokens, recognize the payer.\n   *\n   */\n  function buyWithCustomerId(uint128 customerId) public payable {\n    investWithCustomerId(msg.sender, customerId);\n  }\n\n  /**\n   * The basic entry point to participate the crowdsale process.\n   *\n   * Pay for funding, get invested tokens back in the sender address.\n   */\n  function buy() public payable {\n    invest(msg.sender);\n  }\n\n  /**\n   * Finalize a succcesful crowdsale.\n   *\n   * The owner can triggre a call the contract that provides post-crowdsale actions, like releasing the tokens.\n   */\n  function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n\n    // Already finalized\n    require(!finalized);\n\n    // Finalizing is optional. We only call it if we are given a finalizing agent.\n    if(address(finalizeAgent) != 0) {\n      finalizeAgent.finalizeCrowdsale();\n    }\n\n    finalized = true;\n  }\n\n  /**\n   * Allow to (re)set finalize agent.\n   *\n   * Design choice: no state restrictions on setting this, so that we can fix fat finger mistakes.\n   */\n  function setFinalizeAgent(FinalizeAgent addr) public onlyOwner {\n    finalizeAgent = addr;\n\n    // Don't allow setting bad agent\n    require(finalizeAgent.isFinalizeAgent());\n  }\n\n  /**\n   * Set policy do we need to have server-side customer ids for the investments.\n   *\n   */\n  function setRequireCustomerId(bool value) public onlyOwner {\n    requireCustomerId = value;\n    InvestmentPolicyChanged(requireCustomerId, requiredSignedAddress, signerAddress);\n  }\n\n  /**\n   * Allow addresses to do early participation.\n   *\n   * TODO: Fix spelling error in the name\n   */\n  function setEarlyParicipantWhitelist(address addr, bool status) public onlyAllocateAgent {\n    earlyParticipantWhitelist[addr] = status;\n    Whitelisted(addr, status);\n  }\n\n  function setWhiteList(address[] _participants) public onlyAllocateAgent {\n      \n      require(_participants.length > 0);\n      uint256 participants = _participants.length;\n\n      for (uint256 j=0; j<participants; j++) {\n      require(_participants[j] != 0);\n      earlyParticipantWhitelist[_participants[j]] = true;\n      Whitelisted(_participants[j], true);\n    }\n\n  }\n\n  /**\n   * Allow crowdsale owner to close early or extend the crowdsale.\n   *\n   * This is useful e.g. for a manual soft cap implementation:\n   * - after X amount is reached determine manual closing\n   *\n   * This may put the crowdsale to an invalid state,\n   * but we trust owners know what they are doing.\n   *\n   */\n  function setEndsAt(uint time) public onlyOwner {\n\n    require(now <= time);\n\n    endsAt = time;\n    EndsAtChanged(endsAt);\n  }\n\n  /**\n   * Allow crowdsale owner to begin early or extend the crowdsale.\n   *\n   * This is useful e.g. for a manual soft cap implementation:\n   * - after X amount is reached determine manual closing\n   *\n   * This may put the crowdsale to an invalid state,\n   * but we trust owners know what they are doing.\n   *\n   */\n  function setStartAt(uint time) public onlyOwner {\n\n    startsAt = time;\n    StartAtChanged(endsAt);\n  }\n\n  /**\n   * Allow to (re)set pricing strategy.\n   *\n   * Design choice: no state restrictions on the set, so that we can fix fat finger mistakes.\n   */\n  function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner {\n    pricingStrategy = _pricingStrategy;\n\n    // Don't allow setting bad agent\n    require(pricingStrategy.isPricingStrategy());\n  }\n\n  /**\n   * Allow to change the team multisig address in the case of emergency.\n   *\n   * This allows to save a deployed crowdsale wallet in the case the crowdsale has not yet begun\n   * (we have done only few test transactions). After the crowdsale is going\n   * then multisig address stays locked for the safety reasons.\n   */\n  function setMultisig(address addr) public onlyOwner {\n\n    // Change\n    require(investorCount <= MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE);\n\n    multisigWallet = addr;\n  }\n\n  /**\n   * Allow load refunds back on the contract for the refunding.\n   *\n   * The team can transfer the funds back on the smart contract in the case the minimum goal was not reached..\n   */\n  function loadRefund() public payable inState(State.Failure) {\n    require(msg.value != 0);\n    loadedRefund = safeAdd(loadedRefund,msg.value);\n  }\n\n  /**\n   * Investors can claim refund.\n   */\n  function refund() public inState(State.Refunding) {\n    uint256 weiValue = investedAmountOf[msg.sender];\n    require(weiValue != 0);\n    investedAmountOf[msg.sender] = 0;\n    weiRefunded = safeAdd(weiRefunded,weiValue);\n    Refund(msg.sender, weiValue);\n    require(msg.sender.send(weiValue));\n  }\n\n  /**\n   * @return true if the crowdsale has raised enough money to be a succes\n   */\n  function isMinimumGoalReached() public constant returns (bool reached) {\n    return weiRaised >= minimumFundingGoal;\n  }\n\n  /**\n   * Check if the contract relationship looks good.\n   */\n  function isFinalizerSane() public constant returns (bool sane) {\n    return finalizeAgent.isSane();\n  }\n\n  /**\n   * Check if the contract relationship looks good.\n   */\n  function isPricingSane() public constant returns (bool sane) {\n    return pricingStrategy.isSane(address(this));\n  }\n\n  /**\n   * Crowdfund state machine management.\n   *\n   * We make it a function and do not assign the result to a variable, so there is no chance of the variable being stale.\n   */\n  function getState() public constant returns (State) {\n    if(finalized) return State.Finalized;\n    else if (address(finalizeAgent) == 0) return State.Preparing;\n    else if (!finalizeAgent.isSane()) return State.Preparing;\n    else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\n    else if (block.timestamp < startsAt) return State.PreFunding;\n    else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\n    else if (isMinimumGoalReached()) return State.Success;\n    else if (!isMinimumGoalReached() && weiRaised > 0 && loadedRefund >= weiRaised) return State.Refunding;\n    else return State.Failure;\n  }\n\n  /** This is for manual testing of multisig wallet interaction */\n  function setOwnerTestValue(uint val) public onlyOwner {\n    ownerTestValue = val;\n  }\n\n  /** Interface marker. */\n  function isCrowdsale() public pure returns (bool) {\n    return true;\n  }\n\n  //\n  // Modifiers\n  //\n\n  /** Modified allowing execution only if the crowdsale is currently running.  */\n  modifier inState(State state) {\n    require(getState() == state);\n    _;\n  }\n\n\n  //\n  // Abstract functions\n  //\n\n  /**\n   * Check if the current invested breaks our cap rules.\n   *\n   *\n   * The child contract must define their own cap setting rules.\n   * We allow a lot of flexibility through different capping strategies (ETH, token count)\n   * Called from invest().\n   *\n   * @param weiAmount The amount of wei the investor tries to invest in the current transaction\n   * @param tokenAmount The amount of tokens we try to give to the investor in the current transaction\n   * @param weiRaisedTotal What would be our total raised balance after this transaction\n   * @param tokensSoldTotal What would be our total sold tokens count after this transaction\n   *\n   * @return true if taking this investment would break our cap rules\n   */\n  function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken);\n  /**\n   * Check if the current crowdsale is full and we can no longer sell any tokens.\n   */\n  function isCrowdsaleFull() public constant returns (bool);\n\n  /**\n   * Create new tokens or transfer issued tokens to the investor depending on the cap model.\n   */\n  function assignTokens(address receiver, uint tokenAmount) private;\n}\n\n/**\n * At the end of the successful crowdsale allocate % bonus of tokens to the team.\n *\n * Unlock tokens.\n *\n * BonusAllocationFinal must be set as the minting agent for the MintableToken.\n *\n */\ncontract BonusFinalizeAgent is FinalizeAgent, SafeMathLib {\n\n  CrowdsaleToken public token;\n  Crowdsale public crowdsale;\n  uint256 public allocatedTokens;\n  uint256 tokenCap;\n  address walletAddress;\n\n\n  function BonusFinalizeAgent(CrowdsaleToken _token, Crowdsale _crowdsale, uint256 _tokenCap, address _walletAddress) public {\n    token = _token;\n    crowdsale = _crowdsale;\n\n    //crowdsale address must not be 0\n    require(address(crowdsale) != 0);\n\n    tokenCap = _tokenCap;\n    walletAddress = _walletAddress;\n  }\n\n  /* Can we run finalize properly */\n  function isSane() public view returns (bool) {\n    return (token.mintAgents(address(this)) == true) && (token.releaseAgent() == address(this));\n  }\n\n  /** Called once by crowdsale finalize() if the sale was success. */\n  function finalizeCrowdsale() public {\n\n    // if finalized is not being called from the crowdsale \n    // contract then throw\n    require (msg.sender == address(crowdsale));\n\n    // get the total sold tokens count.\n    uint256 tokenSupply = token.totalSupply();\n\n    allocatedTokens = safeSub(tokenCap,tokenSupply);\n    \n    if ( allocatedTokens > 0) {\n      token.mint(walletAddress, allocatedTokens);\n    }\n\n    token.releaseTokenTransfer();\n  }\n\n}\n\n/**\n * ICO crowdsale contract that is capped by amout of ETH.\n *\n * - Tokens are dynamically created during the crowdsale\n *\n *\n */\ncontract MintedEthCappedCrowdsale is Crowdsale {\n\n  /* Maximum amount of wei this crowdsale can raise. */\n  uint public weiCap;\n\n  function MintedEthCappedCrowdsale(address _token, PricingStrategy _pricingStrategy, \n    address _multisigWallet, uint256 _start, uint256 _end, uint256 _minimumFundingGoal, uint256 _weiCap, address _tokenVestingAddress) \n    Crowdsale(_token, _pricingStrategy, _multisigWallet, _start, _end, _minimumFundingGoal,_tokenVestingAddress) public\n    { \n      weiCap = _weiCap;\n    }\n\n  /**\n   * Called from invest() to confirm if the curret investment does not break our cap rule.\n   */\n  function isBreakingCap(uint256 weiAmount, uint256 tokenAmount, uint256 weiRaisedTotal, uint256 tokensSoldTotal) public constant returns (bool limitBroken) {\n    return weiRaisedTotal > weiCap;\n  }\n\n  function isCrowdsaleFull() public constant returns (bool) {\n    return weiRaised >= weiCap;\n  }\n\n  /**\n   * Dynamically create tokens and assign them to the investor.\n   */\n  function assignTokens(address receiver, uint256 tokenAmount) private {\n    MintableToken mintableToken = MintableToken(token);\n    mintableToken.mint(receiver, tokenAmount);\n  }\n}\n\n\n/// @dev Tranche based pricing with special support for pre-ico deals.\n///      Implementing \"first price\" tranches, meaning, that if byers order is\n///      covering more than one tranche, the price of the lowest tranche will apply\n///      to the whole order.\ncontract EthTranchePricing is PricingStrategy, Ownable, SafeMathLib {\n\n  uint public constant MAX_TRANCHES = 10;\n \n \n  // This contains all pre-ICO addresses, and their prices (weis per token)\n  mapping (address => uint256) public preicoAddresses;\n\n  /**\n  * Define pricing schedule using tranches.\n  */\n\n  struct Tranche {\n      // Amount in weis when this tranche becomes active\n      uint amount;\n      // How many tokens per wei you will get while this tranche is active\n      uint price;\n  }\n\n  // Store tranches in a fixed array, so that it can be seen in a blockchain explorer\n  // Tranche 0 is always (0, 0)\n  // (TODO: change this when we confirm dynamic arrays are explorable)\n  Tranche[10] public tranches;\n\n  // How many active tranches we have\n  uint public trancheCount;\n\n  /// @dev Contruction, creating a list of tranches\n  /// @param _tranches uint[] tranches Pairs of (start amount, price)\n  function EthTranchePricing(uint[] _tranches) public {\n\n    // Need to have tuples, length check\n    require(!(_tranches.length % 2 == 1 || _tranches.length >= MAX_TRANCHES*2));\n    trancheCount = _tranches.length / 2;\n    uint256 highestAmount = 0;\n    for(uint256 i=0; i<_tranches.length/2; i++) {\n      tranches[i].amount = _tranches[i*2];\n      tranches[i].price = _tranches[i*2+1];\n      // No invalid steps\n      require(!((highestAmount != 0) && (tranches[i].amount <= highestAmount)));\n      highestAmount = tranches[i].amount;\n    }\n\n    // We need to start from zero, otherwise we blow up our deployment\n    require(tranches[0].amount == 0);\n\n    // Last tranche price must be zero, terminating the crowdale\n    require(tranches[trancheCount-1].price == 0);\n  }\n\n  /// @dev This is invoked once for every pre-ICO address, set pricePerToken\n  ///      to 0 to disable\n  /// @param preicoAddress PresaleFundCollector address\n  /// @param pricePerToken How many weis one token cost for pre-ico investors\n  function setPreicoAddress(address preicoAddress, uint pricePerToken)\n    public\n    onlyOwner\n  {\n    preicoAddresses[preicoAddress] = pricePerToken;\n  }\n\n  /// @dev Iterate through tranches. You reach end of tranches when price = 0\n  /// @return tuple (time, price)\n  function getTranche(uint256 n) public constant returns (uint, uint) {\n    return (tranches[n].amount, tranches[n].price);\n  }\n\n  function getFirstTranche() private constant returns (Tranche) {\n    return tranches[0];\n  }\n\n  function getLastTranche() private constant returns (Tranche) {\n    return tranches[trancheCount-1];\n  }\n\n  function getPricingStartsAt() public constant returns (uint) {\n    return getFirstTranche().amount;\n  }\n\n  function getPricingEndsAt() public constant returns (uint) {\n    return getLastTranche().amount;\n  }\n\n  function isSane(address _crowdsale) public view returns(bool) {\n    // Our tranches are not bound by time, so we can't really check are we sane\n    // so we presume we are ;)\n    // In the future we could save and track raised tokens, and compare it to\n    // the Crowdsale contract.\n    return true;\n  }\n\n  /// @dev Get the current tranche or bail out if we are not in the tranche periods.\n  /// @param weiRaised total amount of weis raised, for calculating the current tranche\n  /// @return {[type]} [description]\n  function getCurrentTranche(uint256 weiRaised) private constant returns (Tranche) {\n    uint i;\n    for(i=0; i < tranches.length; i++) {\n      if(weiRaised < tranches[i].amount) {\n        return tranches[i-1];\n      }\n    }\n  }\n\n  /// @dev Get the current price.\n  /// @param weiRaised total amount of weis raised, for calculating the current tranche\n  /// @return The current price or 0 if we are outside trache ranges\n  function getCurrentPrice(uint256 weiRaised) public constant returns (uint256 result) {\n    return getCurrentTranche(weiRaised).price;\n  }\n\n  /// @dev Calculate the current price for buy in amount.\n  function calculatePrice(uint256 value, uint256 weiRaised, uint256 tokensSold, address msgSender, uint256 decimals) public constant returns (uint256) {\n\n    uint256 multiplier = 10 ** decimals;\n\n    // This investor is coming through pre-ico\n    if(preicoAddresses[msgSender] > 0) {\n      return safeMul(value, multiplier) / preicoAddresses[msgSender];\n    }\n\n    uint256 price = getCurrentPrice(weiRaised);\n    \n    return safeMul(value, multiplier) / price;\n  }\n\n  function() payable public {\n    revert(); // No money on this contract\n  }\n\n}\n\n/**\n * Contract to enforce Token Vesting\n */\ncontract TokenVesting is Allocatable, SafeMathLib {\n\n    address public TokenAddress;\n\n    /** keep track of total tokens yet to be released, \n     * this should be less than or equal to tokens held by this contract. \n     */\n    uint256 public totalUnreleasedTokens;\n\n\n    struct VestingSchedule {\n        uint256 startAt;\n        uint256 principleLockAmount;\n        uint256 principleLockPeriod;\n        uint256 bonusLockAmount;\n        uint256 bonusLockPeriod;\n        uint256 amountReleased;\n        bool isPrincipleReleased;\n        bool isBonusReleased;\n    }\n\n    mapping (address => VestingSchedule) public vestingMap;\n\n    event VestedTokensReleased(address _adr, uint256 _amount);\n\n\n    function TokenVesting(address _TokenAddress) public {\n        TokenAddress = _TokenAddress;\n    }\n\n\n\n    /** Function to set/update vesting schedule. PS - Amount cannot be changed once set */\n    function setVesting(address _adr, uint256 _principleLockAmount, uint256 _principleLockPeriod, uint256 _bonusLockAmount, uint256 _bonuslockPeriod) public onlyAllocateAgent {\n\n        VestingSchedule storage vestingSchedule = vestingMap[_adr];\n\n        // data validation\n        require(safeAdd(_principleLockAmount, _bonusLockAmount) > 0);\n\n        //startAt is set current time as start time.\n\n        vestingSchedule.startAt = block.timestamp;\n        vestingSchedule.bonusLockPeriod = safeAdd(block.timestamp,_bonuslockPeriod);\n        vestingSchedule.principleLockPeriod = safeAdd(block.timestamp,_principleLockPeriod);\n\n        // check if enough tokens are held by this contract\n        ERC20 token = ERC20(TokenAddress);\n        uint256 _totalAmount = safeAdd(_principleLockAmount, _bonusLockAmount);\n        require(token.balanceOf(this) >= safeAdd(totalUnreleasedTokens, _totalAmount));\n        vestingSchedule.principleLockAmount = _principleLockAmount;\n        vestingSchedule.bonusLockAmount = _bonusLockAmount;\n        vestingSchedule.isPrincipleReleased = false;\n        vestingSchedule.isBonusReleased = false;\n        totalUnreleasedTokens = safeAdd(totalUnreleasedTokens, _totalAmount);\n        vestingSchedule.amountReleased = 0;\n    }\n\n    function isVestingSet(address adr) public constant returns (bool isSet) {\n        return vestingMap[adr].principleLockAmount != 0 || vestingMap[adr].bonusLockAmount != 0;\n    }\n\n\n    /** Release tokens as per vesting schedule, called by contributor  */\n    function releaseMyVestedTokens() public {\n        releaseVestedTokens(msg.sender);\n    }\n\n    /** Release tokens as per vesting schedule, called by anyone  */\n    function releaseVestedTokens(address _adr) public {\n        VestingSchedule storage vestingSchedule = vestingMap[_adr];\n        \n        uint256 _totalTokens = safeAdd(vestingSchedule.principleLockAmount, vestingSchedule.bonusLockAmount);\n        // check if all tokens are not vested\n        require(safeSub(_totalTokens, vestingSchedule.amountReleased) > 0);\n        \n        // calculate total vested tokens till now        \n        uint256 amountToRelease = 0;\n\n        if (block.timestamp >= vestingSchedule.principleLockPeriod && !vestingSchedule.isPrincipleReleased) {\n            amountToRelease = safeAdd(amountToRelease,vestingSchedule.principleLockAmount);\n            vestingSchedule.amountReleased = safeAdd(vestingSchedule.amountReleased, amountToRelease);\n            vestingSchedule.isPrincipleReleased = true;\n        }\n        if (block.timestamp >= vestingSchedule.bonusLockPeriod && !vestingSchedule.isBonusReleased) {\n            amountToRelease = safeAdd(amountToRelease,vestingSchedule.bonusLockAmount);\n            vestingSchedule.amountReleased = safeAdd(vestingSchedule.amountReleased, amountToRelease);\n            vestingSchedule.isBonusReleased = true;\n        }\n\n        // transfer vested tokens\n        require(amountToRelease > 0);\n        ERC20 token = ERC20(TokenAddress);\n        token.transfer(_adr, amountToRelease);\n        // decrement overall unreleased token count\n        totalUnreleasedTokens = safeSub(totalUnreleasedTokens, amountToRelease);\n        VestedTokensReleased(_adr, amountToRelease);\n    }\n\n}",
  "abi": "[{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setTransferAgent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintingFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setReleaseAgent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"mintAgents\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setMintAgent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"upgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"setTokenInformation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgradeAgent\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"releaseTokenTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgradeMaster\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUpgradeState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"transferAgents\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"released\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"canUpgrade\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalUpgraded\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"releaseAgent\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"agent\",\"type\":\"address\"}],\"name\":\"setUpgradeAgent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"master\",\"type\":\"address\"}],\"name\":\"setUpgradeMaster\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_initialSupply\",\"type\":\"uint256\"},{\"name\":\"_decimals\",\"type\":\"uint8\"},{\"name\":\"_mintable\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newName\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"newSymbol\",\"type\":\"string\"}],\"name\":\"UpdatedTokenInformation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"burner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Upgrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"agent\",\"type\":\"address\"}],\"name\":\"UpgradeAgentSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"MintingAgentChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Minted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]",
  "bytecode": "60606040526005805460a060020a60ff02191690556007805460ff1916905534156200002a57600080fd5b60405162001a5b38038062001a5b833981016040528080518201919060200180518201919060200180519190602001805191906020018051600380546009805433600160a060020a0316600160a060020a0319918216811790925591821681179091161790559150600c9050858051620000a992916020019062000179565b50600d848051620000bf92916020019062000179565b506000838155600e805460ff191660ff8516179055600354600160a060020a031681526001602052604081208490558311156200014a576003546000547f30385c845b448a36257a6a1716e6ad2e1bc2cbe333cde1e69fe849ad6511adfe91600160a060020a031690604051600160a060020a03909216825260208201526040908101905180910390a15b8015156200016e576007805460ff1916600117905560005415156200016e57600080fd5b50505050506200021e565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f10620001bc57805160ff1916838001178555620001ec565b82800160010185558215620001ec579182015b82811115620001ec578251825591602001919060010190620001cf565b50620001fa929150620001fe565b5090565b6200021b91905b80821115620001fa576000815560010162000205565b90565b61182d806200022e6000396000f30060606040526004361061019d5763ffffffff60e060020a60003504166302f652a381146101a257806305d2035b146101c857806306fdde03146101ef578063095ea7b31461027957806318160ddd1461029b57806323b872dd146102c057806329ff4f53146102e8578063313ce5671461030757806340c10f191461033057806342966c681461035257806342c1867b14610368578063432146751461038757806345977d03146103ab5780634eee966f146103c15780635de4ccb0146104545780635f412d4f14610483578063600440cb1461049657806366188463146104a957806370a08231146104cb57806379ba5097146104ea5780638444b391146104fd578063867c2857146105345780638da5cb5b1461055357806395d89b411461056657806396132521146105795780639738968c1461058c578063a9059cbb1461059f578063c752ff62146105c1578063d1f276d3146105d4578063d4ee1d90146105e7578063d73dd623146105fa578063d7e7088a1461061c578063dd62ed3e1461063b578063f2fde38b14610660578063ffeb7d751461067f575b600080fd5b34156101ad57600080fd5b6101c6600160a060020a0360043516602435151561069e565b005b34156101d357600080fd5b6101db6106ff565b604051901515815260200160405180910390f35b34156101fa57600080fd5b610202610708565b60405160208082528190810183818151815260200191508051906020019080838360005b8381101561023e578082015183820152602001610226565b50505050905090810190601f16801561026b5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b341561028457600080fd5b6101db600160a060020a03600435166024356107a6565b34156102a657600080fd5b6102ae610812565b60405190815260200160405180910390f35b34156102cb57600080fd5b6101db600160a060020a0360043581169060243516604435610818565b34156102f357600080fd5b6101c6600160a060020a036004351661086b565b341561031257600080fd5b61031a6108d0565b60405160ff909116815260200160405180910390f35b341561033b57600080fd5b6101db600160a060020a03600435166024356108d9565b341561035d57600080fd5b6101c66004356109db565b341561037357600080fd5b6101db600160a060020a0360043516610a90565b341561039257600080fd5b6101c6600160a060020a03600435166024351515610aa5565b34156103b657600080fd5b6101c6600435610b41565b34156103cc57600080fd5b6101c660046024813581810190830135806020601f8201819004810201604051908101604052818152929190602084018383808284378201915050505050509190803590602001908201803590602001908080601f016020809104026020016040519081016040528181529291906020840183838082843750949650610c9895505050505050565b341561045f57600080fd5b610467610e06565b604051600160a060020a03909116815260200160405180910390f35b341561048e57600080fd5b6101c6610e15565b34156104a157600080fd5b610467610e47565b34156104b457600080fd5b6101db600160a060020a0360043516602435610e56565b34156104d657600080fd5b6102ae600160a060020a0360043516610f4a565b34156104f557600080fd5b6101c6610f65565b341561050857600080fd5b610510610ff0565b6040518082600481111561052057fe5b60ff16815260200191505060405180910390f35b341561053f57600080fd5b6101db600160a060020a036004351661103a565b341561055e57600080fd5b61046761104f565b341561057157600080fd5b61020261105e565b341561058457600080fd5b6101db6110c9565b341561059757600080fd5b6101db6110d9565b34156105aa57600080fd5b6101db600160a060020a03600435166024356110fd565b34156105cc57600080fd5b6102ae61114e565b34156105df57600080fd5b610467611154565b34156105f257600080fd5b610467611163565b341561060557600080fd5b6101db600160a060020a0360043516602435611172565b341561062757600080fd5b6101c6600160a060020a0360043516611210565b341561064657600080fd5b6102ae600160a060020a03600435811690602435166113c7565b341561066b57600080fd5b6101c6600160a060020a03600435166113f2565b341561068a57600080fd5b6101c6600160a060020a036004351661143c565b60035433600160a060020a039081169116146106b957600080fd5b60055460009060a060020a900460ff16156106d357600080fd5b50600160a060020a03919091166000908152600660205260409020805460ff1916911515919091179055565b60075460ff1681565b600c8054600181600116156101000203166002900480601f01602080910402602001604051908101604052809291908181526020018280546001816001161561010002031660029004801561079e5780601f106107735761010080835404028352916020019161079e565b820191906000526020600020905b81548152906001019060200180831161078157829003601f168201915b505050505081565b600160a060020a03338116600081815260026020908152604080832094871680845294909152808220859055909291907f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b9259085905190815260200160405180910390a350600192915050565b60005481565b600554600090849060a060020a900460ff16151561085757600160a060020a03811660009081526006602052604090205460ff16151561085757600080fd5b61086285858561149b565b95945050505050565b60035433600160a060020a0390811691161461088657600080fd5b60055460009060a060020a900460ff16156108a057600080fd5b506005805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b600e5460ff1681565b600160a060020a03331660009081526008602052604081205460ff16151561090057600080fd5b60075460ff161561091057600080fd5b61091c6000548361160c565b6000908155600160a060020a038416815260016020526040902054610941908361160c565b600160a060020a0384166000818152600160205260409081902092909255907f0f6798a560793a54c3bcfe86a93cde1e73087d944c0ea20544137d41213968859084905190815260200160405180910390a282600160a060020a031660007fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef8460405190815260200160405180910390a350600192915050565b600160a060020a033316600090815260016020526040812054821115610a0057600080fd5b5033600160a060020a038116600090815260016020526040902054610a259083611622565b600160a060020a03821660009081526001602052604081209190915554610a4c9083611622565b600055600160a060020a0381167fcc16f5dbb4873280815c1ee09dbd06736cffcc184412cf7a71a0fdb75d397ca58360405190815260200160405180910390a25050565b60086020526000908152604090205460ff1681565b60035433600160a060020a03908116911614610ac057600080fd5b60075460ff1615610ad057600080fd5b600160a060020a03821660009081526008602052604090819020805460ff19168315151790557f4b0adf6c802794c7dde28a08a4e07131abcff3bf9603cd71f14f90bec7865efa908390839051600160a060020a039092168252151560208201526040908101905180910390a15050565b6000610b4b610ff0565b90506003816004811115610b5b57fe5b1480610b7257506004816004811115610b7057fe5b145b1515610b7d57600080fd5b811515610b8957600080fd5b600160a060020a033316600090815260016020526040902054610bac9083611622565b600160a060020a03331660009081526001602052604081209190915554610bd39083611622565b600055600b54610be3908361160c565b600b55600a54600160a060020a031663753e88e5338460405160e060020a63ffffffff8516028152600160a060020a0390921660048301526024820152604401600060405180830381600087803b1515610c3c57600080fd5b6102c65a03f11515610c4d57600080fd5b5050600a54600160a060020a03908116915033167f7e5c344a8141a805725cb476f76c6953b842222b967edd1f78ddb6e8b3f397ac8460405190815260200160405180910390a35050565b60035433600160a060020a03908116911614610cb357600080fd5b600c828051610cc6929160200190611769565b50600d818051610cda929160200190611769565b507fd131ab1e6f279deea74e13a18477e13e2107deb6dc8ae955648948be5841fb46600c600d604051604080825283546002600019610100600184161502019091160490820181905281906020820190606083019086908015610d7e5780601f10610d5357610100808354040283529160200191610d7e565b820191906000526020600020905b815481529060010190602001808311610d6157829003601f168201915b5050838103825284546002600019610100600184161502019091160480825260209091019085908015610df25780601f10610dc757610100808354040283529160200191610df2565b820191906000526020600020905b815481529060010190602001808311610dd557829003601f168201915b505094505050505060405180910390a15050565b600a54600160a060020a031681565b60055433600160a060020a03908116911614610e3057600080fd5b6007805460ff19166001179055610e45611634565b565b600954600160a060020a031681565b600160a060020a03338116600090815260026020908152604080832093861683529290529081205480831115610eb357600160a060020a033381166000908152600260209081526040808320938816835292905290812055610ee4565b610ebd8184611622565b600160a060020a033381166000908152600260209081526040808320938916835292905220555b600160a060020a0333811660008181526002602090815260408083209489168084529490915290819020547f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925915190815260200160405180910390a35060019392505050565b600160a060020a031660009081526001602052604090205490565b60045433600160a060020a03908116911614610f8057600080fd5b600454600354600160a060020a0391821691167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a36004546003805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a03909216919091179055565b6000610ffa6110d9565b151561100857506001611037565b600a54600160a060020a0316151561102257506002611037565b600b54151561103357506003611037565b5060045b90565b60066020526000908152604090205460ff1681565b600354600160a060020a031681565b600d8054600181600116156101000203166002900480601f01602080910402602001604051908101604052809291908181526020018280546001816001161561010002031660029004801561079e5780601f106107735761010080835404028352916020019161079e565b60055460a060020a900460ff1681565b60055460009060a060020a900460ff1680156110f857506110f8611675565b905090565b600554600090339060a060020a900460ff16151561113c57600160a060020a03811660009081526006602052604090205460ff16151561113c57600080fd5b611146848461167a565b949350505050565b600b5481565b600554600160a060020a031681565b600454600160a060020a031681565b600160a060020a0333811660009081526002602090815260408083209386168352929052908120546111a4908361160c565b600160a060020a0333811660008181526002602090815260408083209489168084529490915290819020849055919290917f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92591905190815260200160405180910390a350600192915050565b6112186110d9565b151561122357600080fd5b600160a060020a038116151561123857600080fd5b60095433600160a060020a0390811691161461125357600080fd5b600461125d610ff0565b600481111561126857fe5b141561127357600080fd5b600a805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a038381169190911791829055166361d3d7a66000604051602001526040518163ffffffff1660e060020a028152600401602060405180830381600087803b15156112de57600080fd5b6102c65a03f115156112ef57600080fd5b50505060405180519050151561130457600080fd5b60008054600a549091600160a060020a0390911690634b2ba0dd90604051602001526040518163ffffffff1660e060020a028152600401602060405180830381600087803b151561135457600080fd5b6102c65a03f1151561136557600080fd5b5050506040518051905014151561137b57600080fd5b600a547f7845d5aa74cc410e35571258d954f23b82276e160fe8c188fa80566580f279cc90600160a060020a0316604051600160a060020a03909116815260200160405180910390a150565b600160a060020a03918216600090815260026020908152604080832093909416825291909152205490565b60035433600160a060020a0390811691161461140d57600080fd5b6004805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b600160a060020a038116151561145157600080fd5b60095433600160a060020a0390811691161461146c57600080fd5b6009805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b600160a060020a03808416600090815260026020908152604080832033851684529091528120549091841615156114d157600080fd5b600160a060020a0385166000908152600160205260409020548311156114f657600080fd5b8083111561150357600080fd5b600160a060020a0384166000908152600160205260409020548381011161152957600080fd5b600160a060020a03841660009081526001602052604090205461154c908461160c565b600160a060020a03808616600090815260016020526040808220939093559087168152205461157b9084611622565b600160a060020a03861660009081526001602052604090205561159e8184611622565b600160a060020a03808716600081815260026020908152604080832033861684529091529081902093909355908616917fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef9086905190815260200160405180910390a3506001949350505050565b60008282018381101561161b57fe5b9392505050565b60008282111561162e57fe5b50900390565b60055433600160a060020a0390811691161461164f57600080fd5b6005805474ff0000000000000000000000000000000000000000191660a060020a179055565b600190565b6000600160a060020a038316151561169157600080fd5b600160a060020a0333166000908152600160205260409020548211156116b657600080fd5b600160a060020a0333166000908152600160205260409020546116d99083611622565b600160a060020a033381166000908152600160205260408082209390935590851681522054611708908361160c565b600160a060020a0380851660008181526001602052604090819020939093559133909116907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef9085905190815260200160405180910390a350600192915050565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f106117aa57805160ff19168380011785556117d7565b828001600101855582156117d7579182015b828111156117d75782518255916020019190600101906117bc565b506117e39291506117e7565b5090565b61103791905b808211156117e357600081556001016117ed5600a165627a7a72305820814c58a8c440f8a64cda6204cbf7bf296a3d8a82ee2c2221fb8a73853ab762dd002900000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000d4920484f55534520544f4b454e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034948540000000000000000000000000000000000000000000000000000000000",
  "constructorArguments": "00000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000d4920484f55534520544f4b454e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034948540000000000000000000000000000000000000000000000000000000000"
}