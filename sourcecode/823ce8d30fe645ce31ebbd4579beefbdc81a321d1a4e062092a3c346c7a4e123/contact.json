{
  "address": "0xc582a48c09aa74fe1fd483066eeb230d54dfde6e",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "DiscountPack",
  "compilerVersion": "v0.4.24+commit.e67f0147",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2018-11-27\n*/\n\npragma solidity 0.4.24;\n\ncontract Ownable {\n\n    address public owner;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function setOwner(address _owner) public onlyOwner {\n        owner = _owner;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n}\n\n\n\n\n\n\n\n\n\ncontract Governable {\n\n    event Pause();\n    event Unpause();\n\n    address public governor;\n    bool public paused = false;\n\n    constructor() public {\n        governor = msg.sender;\n    }\n\n    function setGovernor(address _gov) public onlyGovernor {\n        governor = _gov;\n    }\n\n    modifier onlyGovernor {\n        require(msg.sender == governor);\n        _;\n    }\n\n    /**\n    * @dev Modifier to make a function callable only when the contract is not paused.\n    */\n    modifier whenNotPaused() {\n        require(!paused);\n        _;\n    }\n\n    /**\n    * @dev Modifier to make a function callable only when the contract is paused.\n    */\n    modifier whenPaused() {\n        require(paused);\n        _;\n    }\n\n    /**\n    * @dev called by the owner to pause, triggers stopped state\n    */\n    function pause() onlyGovernor whenNotPaused public {\n        paused = true;\n        emit Pause();\n    }\n\n    /**\n    * @dev called by the owner to unpause, returns to normal state\n    */\n    function unpause() onlyGovernor whenPaused public {\n        paused = false;\n        emit Unpause();\n    }\n\n}\n\n\n\ncontract CardBase is Governable {\n\n\n    struct Card {\n        uint16 proto;\n        uint16 purity;\n    }\n\n    function getCard(uint id) public view returns (uint16 proto, uint16 purity) {\n        Card memory card = cards[id];\n        return (card.proto, card.purity);\n    }\n\n    function getShine(uint16 purity) public pure returns (uint8) {\n        return uint8(purity / 1000);\n    }\n\n    Card[] public cards;\n    \n}\n\n\n\ncontract CardProto is CardBase {\n\n    event NewProtoCard(\n        uint16 id, uint8 season, uint8 god, \n        Rarity rarity, uint8 mana, uint8 attack, \n        uint8 health, uint8 cardType, uint8 tribe, bool packable\n    );\n\n    struct Limit {\n        uint64 limit;\n        bool exists;\n    }\n\n    // limits for mythic cards\n    mapping(uint16 => Limit) public limits;\n\n    // can only set limits once\n    function setLimit(uint16 id, uint64 limit) public onlyGovernor {\n        Limit memory l = limits[id];\n        require(!l.exists);\n        limits[id] = Limit({\n            limit: limit,\n            exists: true\n        });\n    }\n\n    function getLimit(uint16 id) public view returns (uint64 limit, bool set) {\n        Limit memory l = limits[id];\n        return (l.limit, l.exists);\n    }\n\n    // could make these arrays to save gas\n    // not really necessary - will be update a very limited no of times\n    mapping(uint8 => bool) public seasonTradable;\n    mapping(uint8 => bool) public seasonTradabilityLocked;\n    uint8 public currentSeason;\n\n    function makeTradeable(uint8 season) public onlyGovernor {\n        seasonTradable[season] = true;\n    }\n\n    function makeUntradable(uint8 season) public onlyGovernor {\n        require(!seasonTradabilityLocked[season]);\n        seasonTradable[season] = false;\n    }\n\n    function makePermanantlyTradable(uint8 season) public onlyGovernor {\n        require(seasonTradable[season]);\n        seasonTradabilityLocked[season] = true;\n    }\n\n    function isTradable(uint16 proto) public view returns (bool) {\n        return seasonTradable[protos[proto].season];\n    }\n\n    function nextSeason() public onlyGovernor {\n        //Seasons shouldn't go to 0 if there is more than the uint8 should hold, the governor should know this ¯\\_(ツ)_/¯ -M\n        require(currentSeason <= 255); \n\n        currentSeason++;\n        mythic.length = 0;\n        legendary.length = 0;\n        epic.length = 0;\n        rare.length = 0;\n        common.length = 0;\n    }\n\n    enum Rarity {\n        Common,\n        Rare,\n        Epic,\n        Legendary, \n        Mythic\n    }\n\n    uint8 constant SPELL = 1;\n    uint8 constant MINION = 2;\n    uint8 constant WEAPON = 3;\n    uint8 constant HERO = 4;\n\n    struct ProtoCard {\n        bool exists;\n        uint8 god;\n        uint8 season;\n        uint8 cardType;\n        Rarity rarity;\n        uint8 mana;\n        uint8 attack;\n        uint8 health;\n        uint8 tribe;\n    }\n\n    // there is a particular design decision driving this:\n    // need to be able to iterate over mythics only for card generation\n    // don't store 5 different arrays: have to use 2 ids\n    // better to bear this cost (2 bytes per proto card)\n    // rather than 1 byte per instance\n\n    uint16 public protoCount;\n    \n    mapping(uint16 => ProtoCard) protos;\n\n    uint16[] public mythic;\n    uint16[] public legendary;\n    uint16[] public epic;\n    uint16[] public rare;\n    uint16[] public common;\n\n    function addProtos(\n        uint16[] externalIDs, uint8[] gods, Rarity[] rarities, uint8[] manas, uint8[] attacks, uint8[] healths, uint8[] cardTypes, uint8[] tribes, bool[] packable\n    ) public onlyGovernor returns(uint16) {\n\n        for (uint i = 0; i < externalIDs.length; i++) {\n\n            ProtoCard memory card = ProtoCard({\n                exists: true,\n                god: gods[i],\n                season: currentSeason,\n                cardType: cardTypes[i],\n                rarity: rarities[i],\n                mana: manas[i],\n                attack: attacks[i],\n                health: healths[i],\n                tribe: tribes[i]\n            });\n\n            _addProto(externalIDs[i], card, packable[i]);\n        }\n        \n    }\n\n    function addProto(\n        uint16 externalID, uint8 god, Rarity rarity, uint8 mana, uint8 attack, uint8 health, uint8 cardType, uint8 tribe, bool packable\n    ) public onlyGovernor returns(uint16) {\n        ProtoCard memory card = ProtoCard({\n            exists: true,\n            god: god,\n            season: currentSeason,\n            cardType: cardType,\n            rarity: rarity,\n            mana: mana,\n            attack: attack,\n            health: health,\n            tribe: tribe\n        });\n\n        _addProto(externalID, card, packable);\n    }\n\n    function addWeapon(\n        uint16 externalID, uint8 god, Rarity rarity, uint8 mana, uint8 attack, uint8 durability, bool packable\n    ) public onlyGovernor returns(uint16) {\n\n        ProtoCard memory card = ProtoCard({\n            exists: true,\n            god: god,\n            season: currentSeason,\n            cardType: WEAPON,\n            rarity: rarity,\n            mana: mana,\n            attack: attack,\n            health: durability,\n            tribe: 0\n        });\n\n        _addProto(externalID, card, packable);\n    }\n\n    function addSpell(uint16 externalID, uint8 god, Rarity rarity, uint8 mana, bool packable) public onlyGovernor returns(uint16) {\n\n        ProtoCard memory card = ProtoCard({\n            exists: true,\n            god: god,\n            season: currentSeason,\n            cardType: SPELL,\n            rarity: rarity,\n            mana: mana,\n            attack: 0,\n            health: 0,\n            tribe: 0\n        });\n\n        _addProto(externalID, card, packable);\n    }\n\n    function addMinion(\n        uint16 externalID, uint8 god, Rarity rarity, uint8 mana, uint8 attack, uint8 health, uint8 tribe, bool packable\n    ) public onlyGovernor returns(uint16) {\n\n        ProtoCard memory card = ProtoCard({\n            exists: true,\n            god: god,\n            season: currentSeason,\n            cardType: MINION,\n            rarity: rarity,\n            mana: mana,\n            attack: attack,\n            health: health,\n            tribe: tribe\n        });\n\n        _addProto(externalID, card, packable);\n    }\n\n    function _addProto(uint16 externalID, ProtoCard memory card, bool packable) internal {\n\n        require(!protos[externalID].exists);\n\n        card.exists = true;\n\n        protos[externalID] = card;\n\n        protoCount++;\n\n        emit NewProtoCard(\n            externalID, currentSeason, card.god, \n            card.rarity, card.mana, card.attack, \n            card.health, card.cardType, card.tribe, packable\n        );\n\n        if (packable) {\n            Rarity rarity = card.rarity;\n            if (rarity == Rarity.Common) {\n                common.push(externalID);\n            } else if (rarity == Rarity.Rare) {\n                rare.push(externalID);\n            } else if (rarity == Rarity.Epic) {\n                epic.push(externalID);\n            } else if (rarity == Rarity.Legendary) {\n                legendary.push(externalID);\n            } else if (rarity == Rarity.Mythic) {\n                mythic.push(externalID);\n            } else {\n                require(false);\n            }\n        }\n    }\n\n    function getProto(uint16 id) public view returns(\n        bool exists, uint8 god, uint8 season, uint8 cardType, Rarity rarity, uint8 mana, uint8 attack, uint8 health, uint8 tribe\n    ) {\n        ProtoCard memory proto = protos[id];\n        return (\n            proto.exists,\n            proto.god,\n            proto.season,\n            proto.cardType,\n            proto.rarity,\n            proto.mana,\n            proto.attack,\n            proto.health,\n            proto.tribe\n        );\n    }\n\n    function getRandomCard(Rarity rarity, uint16 random) public view returns (uint16) {\n        // modulo bias is fine - creates rarity tiers etc\n        // will obviously revert is there are no cards of that type: this is expected - should never happen\n        if (rarity == Rarity.Common) {\n            return common[random % common.length];\n        } else if (rarity == Rarity.Rare) {\n            return rare[random % rare.length];\n        } else if (rarity == Rarity.Epic) {\n            return epic[random % epic.length];\n        } else if (rarity == Rarity.Legendary) {\n            return legendary[random % legendary.length];\n        } else if (rarity == Rarity.Mythic) {\n            // make sure a mythic is available\n            uint16 id;\n            uint64 limit;\n            bool set;\n            for (uint i = 0; i < mythic.length; i++) {\n                id = mythic[(random + i) % mythic.length];\n                (limit, set) = getLimit(id);\n                if (set && limit > 0){\n                    return id;\n                }\n            }\n            // if not, they get a legendary :(\n            return legendary[random % legendary.length];\n        }\n        require(false);\n        return 0;\n    }\n\n    // can never adjust tradable cards\n    // each season gets a 'balancing beta'\n    // totally immutable: season, rarity\n    function replaceProto(\n        uint16 index, uint8 god, uint8 cardType, uint8 mana, uint8 attack, uint8 health, uint8 tribe\n    ) public onlyGovernor {\n        ProtoCard memory pc = protos[index];\n        require(!seasonTradable[pc.season]);\n        protos[index] = ProtoCard({\n            exists: true,\n            god: god,\n            season: pc.season,\n            cardType: cardType,\n            rarity: pc.rarity,\n            mana: mana,\n            attack: attack,\n            health: health,\n            tribe: tribe\n        });\n    }\n\n}\n\n\ncontract MigrationInterface {\n\n    function createCard(address user, uint16 proto, uint16 purity) public returns (uint);\n\n    function getRandomCard(CardProto.Rarity rarity, uint16 random) public view returns (uint16);\n\n    function migrate(uint id) public;\n\n}\n\n\n\ncontract CardPackFour {\n\n    MigrationInterface public migration;\n    uint public creationBlock;\n\n    constructor(MigrationInterface _core) public payable {\n        migration = _core;\n        creationBlock = 5939061 + 2000; // set to creation block of first contracts + 8 hours for down time\n    }\n\n    event Referral(address indexed referrer, uint value, address purchaser);\n\n    /**\n    * purchase 'count' of this type of pack\n    */\n    function purchase(uint16 packCount, address referrer) public payable;\n\n    // store purity and shine as one number to save users gas\n    function _getPurity(uint16 randOne, uint16 randTwo) internal pure returns (uint16) {\n        if (randOne >= 998) {\n            return 3000 + randTwo;\n        } else if (randOne >= 988) {\n            return 2000 + randTwo;\n        } else if (randOne >= 938) {\n            return 1000 + randTwo;\n        } else {\n            return randTwo;\n        }\n    }\n\n}\n\n\n\n\n\n\n\n\n\ncontract Pausable is Ownable {\n    \n    event Pause();\n    event Unpause();\n\n    bool public paused = false;\n\n\n    /**\n    * @dev Modifier to make a function callable only when the contract is not paused.\n    */\n    modifier whenNotPaused() {\n        require(!paused);\n        _;\n    }\n\n    /**\n    * @dev Modifier to make a function callable only when the contract is paused.\n    */\n    modifier whenPaused() {\n        require(paused);\n        _;\n    }\n\n    /**\n    * @dev called by the owner to pause, triggers stopped state\n    */\n    function pause() onlyOwner whenNotPaused public {\n        paused = true;\n        emit Pause();\n    }\n\n    /**\n    * @dev called by the owner to unpause, returns to normal state\n    */\n    function unpause() onlyOwner whenPaused public {\n        paused = false;\n        emit Unpause();\n    }\n}\n\n\n\n\n\n\n\ncontract Vault is Ownable { \n\n    function () public payable {\n\n    }\n\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    function withdraw(uint amount) public onlyOwner {\n        require(address(this).balance >= amount);\n        owner.transfer(amount);\n    }\n\n    function withdrawAll() public onlyOwner {\n        withdraw(address(this).balance);\n    }\n}\n\n\n\ncontract CappedVault is Vault { \n\n    uint public limit;\n    uint withdrawn = 0;\n\n    constructor() public {\n        limit = 33333 ether;\n    }\n\n    function () public payable {\n        require(total() + msg.value <= limit);\n    }\n\n    function total() public view returns(uint) {\n        return getBalance() + withdrawn;\n    }\n\n    function withdraw(uint amount) public onlyOwner {\n        require(address(this).balance >= amount);\n        owner.transfer(amount);\n        withdrawn += amount;\n    }\n\n}\n\n\ncontract PresalePackFour is CardPackFour, Pausable {\n\n    CappedVault public vault;\n\n    Purchase[] public purchases;\n\n    function getPurchaseCount() public view returns (uint) {\n        return purchases.length;\n    }\n\n    struct Purchase {\n        uint16 current;\n        uint16 count;\n        address user;\n        uint randomness;\n        uint64 commit;\n    }\n\n    event PacksPurchased(uint indexed id, address indexed user, uint16 count);\n    event PackOpened(uint indexed id, uint16 startIndex, address indexed user, uint[] cardIDs);\n    event RandomnessReceived(uint indexed id, address indexed user, uint16 count, uint randomness);\n    event Recommit(uint indexed id);\n\n    constructor(MigrationInterface _core, CappedVault _vault) public payable CardPackFour(_core) {\n        vault = _vault;\n    }\n\n    function basePrice() public returns (uint);\n    function getCardDetails(uint16 packIndex, uint8 cardIndex, uint result) public view returns (uint16 proto, uint16 purity);\n    \n    function packSize() public view returns (uint8) {\n        return 5;\n    }\n\n    uint16 public perClaim = 15;\n\n    function setPacksPerClaim(uint16 _perClaim) public onlyOwner {\n        perClaim = _perClaim;\n    }\n\n    function packsPerClaim() public view returns (uint16) {\n        return perClaim;\n    }\n\n    // start in bytes, length in bytes\n    function extract(uint num, uint length, uint start) internal pure returns (uint) {\n        return (((1 << (length * 8)) - 1) & (num >> ((start * 8) - 1)));\n    }\n\n    function purchaseFor(address user, uint16 packCount, address referrer) whenNotPaused public payable {\n        _purchase(user, packCount, referrer);\n    }\n\n    function purchase(uint16 packCount, address referrer) whenNotPaused public payable {\n        _purchase(msg.sender, packCount, referrer);\n    }\n\n    function _purchase(address user, uint16 packCount, address referrer) internal {\n        require(packCount > 0);\n        require(referrer != user);\n\n        uint price = calculatePrice(basePrice(), packCount);\n        uint value = msg.value;\n\n        require(value >= price);\n\n        Purchase memory p = Purchase({\n            user: user,\n            count: packCount,\n            commit: uint64(block.number),\n            randomness: 0,\n            current: 0\n        });\n\n        uint id = purchases.push(p) - 1;\n\n        emit PacksPurchased(id, user, packCount);\n\n        if (referrer != address(0)) {\n            uint commission = price / 10;\n            referrer.transfer(commission);\n            price -= commission;\n            emit Referral(referrer, commission, user);\n        }\n        \n        address(vault).transfer(price);\n    }\n\n    // can recommit\n    // this gives you more chances\n    // if no-one else sends the callback (should never happen)\n    // still only get a random extra chance\n    function recommit(uint id) public {\n\n        Purchase storage p = purchases[id];\n\n        require(p.randomness == 0);\n\n        require(block.number >= p.commit + 256);\n\n        p.commit = uint64(block.number);\n\n        emit Recommit(id);\n    }\n\n    // can be called by anybody\n    // can miners withhold blocks --> not really\n    // giving up block reward for extra chance --> still really low\n    function callback(uint id) public {\n\n        Purchase storage p = purchases[id];\n\n        require(p.randomness == 0);\n\n        // must be within last 256 blocks, otherwise recommit\n        require(block.number - 256 < p.commit);\n\n        // can't callback on the original block\n        require(uint64(block.number) != p.commit);\n\n        bytes32 bhash = blockhash(p.commit);\n        // will get the same on every block\n        // only use properties which can't be altered by the user\n        uint random = uint(keccak256(abi.encodePacked(bhash, p.user, address(this), p.count)));\n\n        require(uint(bhash) != 0);\n\n        p.randomness = random;\n\n        emit RandomnessReceived(id, p.user, p.count, p.randomness);\n    }\n\n    function claim(uint id) public {\n        \n        Purchase storage p = purchases[id];\n\n        require(canClaim);\n\n        uint16 proto;\n        uint16 purity;\n        uint16 count = p.count;\n        uint result = p.randomness;\n        uint8 size = packSize();\n\n        address user = p.user;\n        uint16 current = p.current;\n\n        require(result != 0); // have to wait for the callback\n        // require(user == msg.sender); // not needed\n        require(count > 0);\n\n        uint[] memory ids = new uint[](size);\n\n        uint16 end = current + packsPerClaim() > count ? count : current + packsPerClaim();\n\n        require(end > current);\n\n        for (uint16 i = current; i < end; i++) {\n            for (uint8 j = 0; j < size; j++) {\n                (proto, purity) = getCardDetails(i, j, result);\n                ids[j] = migration.createCard(user, proto, purity);\n            }\n            emit PackOpened(id, (i * size), user, ids);\n        }\n        p.current += (end - current);\n    }\n\n    function predictPacks(uint id) external view returns (uint16[] protos, uint16[] purities) {\n\n        Purchase memory p = purchases[id];\n\n        uint16 proto;\n        uint16 purity;\n        uint16 count = p.count;\n        uint result = p.randomness;\n        uint8 size = packSize();\n\n        purities = new uint16[](size * count);\n        protos = new uint16[](size * count);\n\n        for (uint16 i = 0; i < count; i++) {\n            for (uint8 j = 0; j < size; j++) {\n                (proto, purity) = getCardDetails(i, j, result);\n                purities[(i * size) + j] = purity;\n                protos[(i * size) + j] = proto;\n            }\n        }\n        return (protos, purities);\n    }\n\n    function calculatePrice(uint base, uint16 packCount) public view returns (uint) {\n        // roughly 6k blocks per day\n        uint difference = block.number - creationBlock;\n        uint numDays = difference / 6000;\n        if (20 > numDays) {\n            return (base - (((20 - numDays) * base) / 100)) * packCount;\n        }\n        return base * packCount;\n    }\n\n    function _getCommonPlusRarity(uint32 rand) internal pure returns (CardProto.Rarity) {\n        if (rand == 999999) {\n            return CardProto.Rarity.Mythic;\n        } else if (rand >= 998345) {\n            return CardProto.Rarity.Legendary;\n        } else if (rand >= 986765) {\n            return CardProto.Rarity.Epic;\n        } else if (rand >= 924890) {\n            return CardProto.Rarity.Rare;\n        } else {\n            return CardProto.Rarity.Common;\n        }\n    }\n\n    function _getRarePlusRarity(uint32 rand) internal pure returns (CardProto.Rarity) {\n        if (rand == 999999) {\n            return CardProto.Rarity.Mythic;\n        } else if (rand >= 981615) {\n            return CardProto.Rarity.Legendary;\n        } else if (rand >= 852940) {\n            return CardProto.Rarity.Epic;\n        } else {\n            return CardProto.Rarity.Rare;\n        } \n    }\n\n    function _getEpicPlusRarity(uint32 rand) internal pure returns (CardProto.Rarity) {\n        if (rand == 999999) {\n            return CardProto.Rarity.Mythic;\n        } else if (rand >= 981615) {\n            return CardProto.Rarity.Legendary;\n        } else {\n            return CardProto.Rarity.Epic;\n        }\n    }\n\n    function _getLegendaryPlusRarity(uint32 rand) internal pure returns (CardProto.Rarity) {\n        if (rand == 999999) {\n            return CardProto.Rarity.Mythic;\n        } else {\n            return CardProto.Rarity.Legendary;\n        } \n    }\n\n    bool public canClaim = true;\n\n    function setCanClaim(bool claim) public onlyOwner {\n        canClaim = claim;\n    }\n\n    function getComponents(\n        uint16 i, uint8 j, uint rand\n    ) internal returns (\n        uint random, uint32 rarityRandom, uint16 purityOne, uint16 purityTwo, uint16 protoRandom\n    ) {\n        random = uint(keccak256(abi.encodePacked(i, rand, j)));\n        rarityRandom = uint32(extract(random, 4, 10) % 1000000);\n        purityOne = uint16(extract(random, 2, 4) % 1000);\n        purityTwo = uint16(extract(random, 2, 6) % 1000);\n        protoRandom = uint16(extract(random, 2, 8) % (2**16-1));\n        return (random, rarityRandom, purityOne, purityTwo, protoRandom);\n    }\n\n    function withdraw() public onlyOwner {\n        owner.transfer(address(this).balance);\n    }\n\n}\n\n\ncontract DiscountPack is Vault {\n\n    PresalePackFour private pack;\n    uint public basePrice;\n    uint public baseDiscount;\n\n    constructor(PresalePackFour packToDiscount) public {\n        pack = packToDiscount;\n\n        baseDiscount = uint(7) * pack.basePrice() / uint(100);\n        basePrice = pack.basePrice() - baseDiscount;\n    }\n\n    event PackDiscount(address purchaser, uint16 packs, uint discount);\n \n    function() public payable {}\n\n    function purchase(uint16 packs) public payable {\n        uint discountedPrice = packs * basePrice;\n        uint discount = packs * baseDiscount;\n        uint fullPrice = discountedPrice + discount;\n\n        require(msg.value >= discountedPrice, \"Not enough value for the desired pack count.\");\n        require(address(this).balance >= discount, \"This contract is out of front money.\");\n\n        // This should route the referral back to this contract\n        pack.purchaseFor.value(fullPrice)(msg.sender, packs, this);\n        emit PackDiscount(msg.sender, packs, discount);\n    }\n\n    function fraction(uint value, uint8 num, uint8 denom) internal pure returns (uint) {\n        return (uint(num) * value) / uint(denom);\n    }\n}",
  "bytecode": "608060405234801561001057600080fd5b50604051602080610621833981016040818152915160008054600160a060020a03199081163317825560018054600160a060020a038086169190931617908190557fc7876ea40000000000000000000000000000000000000000000000000000000085529451929460649491169263c7876ea492600480840193602093929083900390910190829087803b1580156100a757600080fd5b505af11580156100bb573d6000803e3d6000fd5b505050506040513d60208110156100d157600080fd5b50516007028115156100df57fe5b046003819055600154604080517fc7876ea40000000000000000000000000000000000000000000000000000000081529051600160a060020a039092169163c7876ea4916004808201926020929091908290030181600087803b15801561014557600080fd5b505af1158015610159573d6000803e3d6000fd5b505050506040513d602081101561016f57600080fd5b5051036002555061049c806101856000396000f30060806040526004361061008d5763ffffffff7c010000000000000000000000000000000000000000000000000000000060003504166312065fe0811461008f57806313af4035146100b65780632e1a7d4d146100d7578063853828b6146100ef5780638da5cb5b146101045780639ea8f36a14610135578063c7876ea41461014a578063efbce0301461015f575b005b34801561009b57600080fd5b506100a461016e565b60408051918252519081900360200190f35b3480156100c257600080fd5b5061008d600160a060020a0360043516610173565b3480156100e357600080fd5b5061008d6004356101b9565b3480156100fb57600080fd5b5061008d61021b565b34801561011057600080fd5b5061011961023e565b60408051600160a060020a039092168252519081900360200190f35b34801561014157600080fd5b506100a461024d565b34801561015657600080fd5b506100a4610253565b61008d61ffff60043516610259565b303190565b600054600160a060020a0316331461018a57600080fd5b6000805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b600054600160a060020a031633146101d057600080fd5b30318111156101de57600080fd5b60008054604051600160a060020a039091169183156108fc02918491818181858888f19350505050158015610217573d6000803e3d6000fd5b5050565b600054600160a060020a0316331461023257600080fd5b61023c30316101b9565b565b600054600160a060020a031681565b60035481565b60025481565b60025460035461ffff831691820291028082013483111561030157604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602c60248201527f4e6f7420656e6f7567682076616c756520666f7220746865206465736972656460448201527f207061636b20636f756e742e0000000000000000000000000000000000000000606482015290519081900360840190fd5b303182111561039657604080517f08c379a0000000000000000000000000000000000000000000000000000000008152602060048201526024808201527f5468697320636f6e7472616374206973206f7574206f662066726f6e74206d6f60448201527f6e65792e00000000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b600154604080517fb01d5b6300000000000000000000000000000000000000000000000000000000815233600482015261ffff871660248201523060448201529051600160a060020a039092169163b01d5b63918491606480830192600092919082900301818588803b15801561040c57600080fd5b505af1158015610420573d6000803e3d6000fd5b50506040805133815261ffff8916602082015280820187905290517ffce71e8366bd12219bd8a9d61186b8c5c5ea0963b364b9ecc45d85bf8c44359b94509081900360600192509050a1505050505600a165627a7a723058208368529188e2b259245a9ba28c117c58f8be26698947ac123b50fce516f785e300290000000000000000000000000777f76d195795268388789343068e4fcd286919",
  "constructorArguments": "0000000000000000000000000777f76d195795268388789343068e4fcd286919"
}