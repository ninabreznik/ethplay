{
  "address": "0x0bc693480d447ab97aff7aa215d1586f1868cb01",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "LockManager",
  "compilerVersion": "v0.4.24+commit.e67f0147",
  "optimization": true,
  "runs": "999",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2019-02-05\n*/\n\npragma solidity ^0.4.24;\n\n/**\n * @title Module\n * @dev Interface for a module. \n * A module MUST implement the addModule() method to ensure that a wallet with at least one module\n * can never end up in a \"frozen\" state.\n * @author Julien Niset - <[email protected]>\n */\ninterface Module {\n\n    /**\n     * @dev Inits a module for a wallet by e.g. setting some wallet specific parameters in storage.\n     * @param _wallet The wallet.\n     */\n    function init(BaseWallet _wallet) external;\n\n    /**\n     * @dev Adds a module to a wallet.\n     * @param _wallet The target wallet.\n     * @param _module The modules to authorise.\n     */\n    function addModule(BaseWallet _wallet, Module _module) external;\n\n    /**\n    * @dev Utility method to recover any ERC20 token that was sent to the\n    * module by mistake. \n    * @param _token The token to recover.\n    */\n    function recoverToken(address _token) external;\n}\n\n/**\n * @title BaseModule\n * @dev Basic module that contains some methods common to all modules.\n * @author Julien Niset - <[email protected]>\n */\ncontract BaseModule is Module {\n\n    // The adddress of the module registry.\n    ModuleRegistry internal registry;\n\n    event ModuleCreated(bytes32 name);\n    event ModuleInitialised(address wallet);\n\n    constructor(ModuleRegistry _registry, bytes32 _name) public {\n        registry = _registry;\n        emit ModuleCreated(_name);\n    }\n\n    /**\n     * @dev Throws if the sender is not the target wallet of the call.\n     */\n    modifier onlyWallet(BaseWallet _wallet) {\n        require(msg.sender == address(_wallet), \"BM: caller must be wallet\");\n        _;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner of the target wallet or the module itself.\n     */\n    modifier onlyOwner(BaseWallet _wallet) {\n        require(msg.sender == address(this) || isOwner(_wallet, msg.sender), \"BM: must be an owner for the wallet\");\n        _;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner of the target wallet.\n     */\n    modifier strictOnlyOwner(BaseWallet _wallet) {\n        require(isOwner(_wallet, msg.sender), \"BM: msg.sender must be an owner for the wallet\");\n        _;\n    }\n\n    /**\n     * @dev Inits the module for a wallet by logging an event.\n     * The method can only be called by the wallet itself.\n     * @param _wallet The wallet.\n     */\n    function init(BaseWallet _wallet) external onlyWallet(_wallet) {\n        emit ModuleInitialised(_wallet);\n    }\n\n    /**\n     * @dev Adds a module to a wallet. First checks that the module is registered.\n     * @param _wallet The target wallet.\n     * @param _module The modules to authorise.\n     */\n    function addModule(BaseWallet _wallet, Module _module) external strictOnlyOwner(_wallet) {\n        require(registry.isRegisteredModule(_module), \"BM: module is not registered\");\n        _wallet.authoriseModule(_module, true);\n    }\n\n    /**\n    * @dev Utility method enbaling anyone to recover ERC20 token sent to the\n    * module by mistake and transfer them to the Module Registry. \n    * @param _token The token to recover.\n    */\n    function recoverToken(address _token) external {\n        uint total = ERC20(_token).balanceOf(address(this));\n        ERC20(_token).transfer(address(registry), total);\n    }\n\n    /**\n     * @dev Helper method to check if an address is the owner of a target wallet.\n     * @param _wallet The target wallet.\n     * @param _addr The address.\n     */\n    function isOwner(BaseWallet _wallet, address _addr) internal view returns (bool) {\n        return _wallet.owner() == _addr;\n    }\n}\n\n/**\n * @title RelayerModule\n * @dev Base module containing logic to execute transactions signed by eth-less accounts and sent by a relayer. \n * @author Julien Niset - <[email protected]>\n */\ncontract RelayerModule is Module {\n\n    uint256 constant internal BLOCKBOUND = 10000;\n\n    mapping (address => RelayerConfig) public relayer; \n\n    struct RelayerConfig {\n        uint256 nonce;\n        mapping (bytes32 => bool) executedTx;\n    }\n\n    event TransactionExecuted(address indexed wallet, bool indexed success, bytes32 signedHash);\n\n    /**\n     * @dev Throws if the call did not go through the execute() method.\n     */\n    modifier onlyExecute {\n        require(msg.sender == address(this), \"RM: must be called via execute()\");\n        _;\n    }\n\n    /* ***************** Abstract method ************************* */\n\n    /**\n    * @dev Gets the number of valid signatures that must be provided to execute a\n    * specific relayed transaction.\n    * @param _wallet The target wallet.\n    * @param _data The data of the relayed transaction.\n    * @return The number of required signatures.\n    */\n    function getRequiredSignatures(BaseWallet _wallet, bytes _data) internal view returns (uint256);\n\n    /**\n    * @dev Validates the signatures provided with a relayed transaction.\n    * The method MUST throw if one or more signatures are not valid.\n    * @param _wallet The target wallet.\n    * @param _data The data of the relayed transaction.\n    * @param _signHash The signed hash representing the relayed transaction.\n    * @param _signatures The signatures as a concatenated byte array.\n    */\n    function validateSignatures(BaseWallet _wallet, bytes _data, bytes32 _signHash, bytes _signatures) internal view returns (bool);\n\n    /* ************************************************************ */\n\n    /**\n    * @dev Executes a relayed transaction.\n    * @param _wallet The target wallet.\n    * @param _data The data for the relayed transaction\n    * @param _nonce The nonce used to prevent replay attacks.\n    * @param _signatures The signatures as a concatenated byte array.\n    * @param _gasPrice The gas price to use for the gas refund.\n    * @param _gasLimit The gas limit to use for the gas refund.\n    */\n    function execute(\n        BaseWallet _wallet,\n        bytes _data, \n        uint256 _nonce, \n        bytes _signatures, \n        uint256 _gasPrice,\n        uint256 _gasLimit\n    )\n        external\n        returns (bool success)\n    {\n        uint startGas = gasleft();\n        bytes32 signHash = getSignHash(address(this), _wallet, 0, _data, _nonce, _gasPrice, _gasLimit);\n        require(checkAndUpdateUniqueness(_wallet, _nonce, signHash), \"RM: Duplicate request\");\n        require(verifyData(address(_wallet), _data), \"RM: the wallet authorized is different then the target of the relayed data\");\n        uint256 requiredSignatures = getRequiredSignatures(_wallet, _data);\n        if((requiredSignatures * 65) == _signatures.length) {\n            if(verifyRefund(_wallet, _gasLimit, _gasPrice, requiredSignatures)) {\n                if(requiredSignatures == 0 || validateSignatures(_wallet, _data, signHash, _signatures)) {\n                    // solium-disable-next-line security/no-call-value\n                    success = address(this).call(_data);\n                    refund(_wallet, startGas - gasleft(), _gasPrice, _gasLimit, requiredSignatures, msg.sender);\n                }\n            }\n        }\n        emit TransactionExecuted(_wallet, success, signHash); \n    }\n\n    /**\n    * @dev Gets the current nonce for a wallet.\n    * @param _wallet The target wallet.\n    */\n    function getNonce(BaseWallet _wallet) external view returns (uint256 nonce) {\n        return relayer[_wallet].nonce;\n    }\n\n    /**\n    * @dev Generates the signed hash of a relayed transaction according to ERC 1077.\n    * @param _from The starting address for the relayed transaction (should be the module)\n    * @param _to The destination address for the relayed transaction (should be the wallet)\n    * @param _value The value for the relayed transaction\n    * @param _data The data for the relayed transaction\n    * @param _nonce The nonce used to prevent replay attacks.\n    * @param _gasPrice The gas price to use for the gas refund.\n    * @param _gasLimit The gas limit to use for the gas refund.\n    */\n    function getSignHash(\n        address _from,\n        address _to, \n        uint256 _value, \n        bytes _data, \n        uint256 _nonce,\n        uint256 _gasPrice,\n        uint256 _gasLimit\n    ) \n        internal \n        pure\n        returns (bytes32) \n    {\n        return keccak256(\n            abi.encodePacked(\n                \"\\x19Ethereum Signed Message:\\n32\",\n                keccak256(abi.encodePacked(byte(0x19), byte(0), _from, _to, _value, _data, _nonce, _gasPrice, _gasLimit))\n        ));\n    }\n\n    /**\n    * @dev Checks if the relayed transaction is unique.\n    * @param _wallet The target wallet.\n    * @param _nonce The nonce\n    * @param _signHash The signed hash of the transaction\n    */\n    function checkAndUpdateUniqueness(BaseWallet _wallet, uint256 _nonce, bytes32 _signHash) internal returns (bool) {\n        if(relayer[_wallet].executedTx[_signHash] == true) {\n            return false;\n        }\n        relayer[_wallet].executedTx[_signHash] = true;\n        return true;\n    }\n\n    /**\n    * @dev Checks that a nonce has the correct format and is valid. \n    * It must be constructed as nonce = {block number}{timestamp} where each component is 16 bytes.\n    * @param _wallet The target wallet.\n    * @param _nonce The nonce\n    */\n    function checkAndUpdateNonce(BaseWallet _wallet, uint256 _nonce) internal returns (bool) {\n        if(_nonce <= relayer[_wallet].nonce) {\n            return false;\n        }   \n        uint256 nonceBlock = (_nonce & 0xffffffffffffffffffffffffffffffff00000000000000000000000000000000) >> 128;\n        if(nonceBlock > block.number + BLOCKBOUND) {\n            return false;\n        }\n        relayer[_wallet].nonce = _nonce;\n        return true;    \n    }\n\n    /**\n    * @dev Recovers the signer at a given position from a list of concatenated signatures.\n    * @param _signedHash The signed hash\n    * @param _signatures The concatenated signatures.\n    * @param _index The index of the signature to recover.\n    */\n    function recoverSigner(bytes32 _signedHash, bytes _signatures, uint _index) internal pure returns (address) {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        // we jump 32 (0x20) as the first slot of bytes contains the length\n        // we jump 65 (0x41) per signature\n        // for v we load 32 bytes ending with v (the first 31 come from s) then apply a mask\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            r := mload(add(_signatures, add(0x20,mul(0x41,_index))))\n            s := mload(add(_signatures, add(0x40,mul(0x41,_index))))\n            v := and(mload(add(_signatures, add(0x41,mul(0x41,_index)))), 0xff)\n        }\n        require(v == 27 || v == 28); \n        return ecrecover(_signedHash, v, r, s);\n    }\n\n    /**\n    * @dev Refunds the gas used to the Relayer. \n    * For security reasons the default behavior is to not refund calls with 0 or 1 signatures. \n    * @param _wallet The target wallet.\n    * @param _gasUsed The gas used.\n    * @param _gasPrice The gas price for the refund.\n    * @param _gasLimit The gas limit for the refund.\n    * @param _signatures The number of signatures used in the call.\n    * @param _relayer The address of the Relayer.\n    */\n    function refund(BaseWallet _wallet, uint _gasUsed, uint _gasPrice, uint _gasLimit, uint _signatures, address _relayer) internal {\n        uint256 amount = 29292 + _gasUsed; // 21000 (transaction) + 7620 (execution of refund) + 672 to log the event + _gasUsed\n        // only refund if gas price not null, more than 1 signatures, gas less than gasLimit\n        if(_gasPrice > 0 && _signatures > 1 && amount <= _gasLimit) {\n            if(_gasPrice > tx.gasprice) {\n                amount = amount * tx.gasprice;\n            }\n            else {\n                amount = amount * _gasPrice;\n            }\n            _wallet.invoke(_relayer, amount, \"\");\n        }\n    }\n\n    /**\n    * @dev Returns false if the refund is expected to fail.\n    * @param _wallet The target wallet.\n    * @param _gasUsed The expected gas used.\n    * @param _gasPrice The expected gas price for the refund.\n    */\n    function verifyRefund(BaseWallet _wallet, uint _gasUsed, uint _gasPrice, uint _signatures) internal view returns (bool) {\n        if(_gasPrice > 0 \n            && _signatures > 1 \n            && (address(_wallet).balance < _gasUsed * _gasPrice || _wallet.authorised(this) == false)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n    * @dev Checks that the wallet address provided as the first parameter of the relayed data is the same\n    * as the wallet passed as the input of the execute() method. \n    @return false if the addresses are different.\n    */\n    function verifyData(address _wallet, bytes _data) private pure returns (bool) {\n        require(_data.length >= 36, \"RM: Invalid dataWallet\");\n        address dataWallet;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            //_data = {length:32}{sig:4}{_wallet:32}{...}\n            dataWallet := mload(add(_data, 0x24))\n        }\n        return dataWallet == _wallet;\n    }\n\n    /**\n    * @dev Parses the data to extract the method signature. \n    */\n    function functionPrefix(bytes _data) internal pure returns (bytes4 prefix) {\n        require(_data.length >= 4, \"RM: Invalid functionPrefix\");\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            prefix := mload(add(_data, 0x20))\n        }\n    }\n}\n\n/**\n * ERC20 contract interface.\n */\ncontract ERC20 {\n    function totalSupply() public view returns (uint);\n    function decimals() public view returns (uint);\n    function balanceOf(address tokenOwner) public view returns (uint balance);\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n    function transfer(address to, uint tokens) public returns (bool success);\n    function approve(address spender, uint tokens) public returns (bool success);\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n}\n\n/**\n * @title Owned\n * @dev Basic contract to define an owner.\n * @author Julien Niset - <[email protected]>\n */\ncontract Owned {\n\n    // The owner\n    address public owner;\n\n    event OwnerChanged(address indexed _newOwner);\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Must be owner\");\n        _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    /**\n     * @dev Lets the owner transfer ownership of the contract to a new owner.\n     * @param _newOwner The new owner.\n     */\n    function changeOwner(address _newOwner) external onlyOwner {\n        require(_newOwner != address(0), \"Address must not be null\");\n        owner = _newOwner;\n        emit OwnerChanged(_newOwner);\n    }\n}\n\n/**\n * @title ModuleRegistry\n * @dev Registry of authorised modules. \n * Modules must be registered before they can be authorised on a wallet.\n * @author Julien Niset - <[email protected]>\n */\ncontract ModuleRegistry is Owned {\n\n    mapping (address => Info) internal modules;\n    mapping (address => Info) internal upgraders;\n\n    event ModuleRegistered(address indexed module, bytes32 name);\n    event ModuleDeRegistered(address module);\n    event UpgraderRegistered(address indexed upgrader, bytes32 name);\n    event UpgraderDeRegistered(address upgrader);\n\n    struct Info {\n        bool exists;\n        bytes32 name;\n    }\n\n    /**\n     * @dev Registers a module.\n     * @param _module The module.\n     * @param _name The unique name of the module.\n     */\n    function registerModule(address _module, bytes32 _name) external onlyOwner {\n        require(!modules[_module].exists, \"MR: module already exists\");\n        modules[_module] = Info({exists: true, name: _name});\n        emit ModuleRegistered(_module, _name);\n    }\n\n    /**\n     * @dev Deregisters a module.\n     * @param _module The module.\n     */\n    function deregisterModule(address _module) external onlyOwner {\n        require(modules[_module].exists, \"MR: module does not exists\");\n        delete modules[_module];\n        emit ModuleDeRegistered(_module);\n    }\n\n        /**\n     * @dev Registers an upgrader.\n     * @param _upgrader The upgrader.\n     * @param _name The unique name of the upgrader.\n     */\n    function registerUpgrader(address _upgrader, bytes32 _name) external onlyOwner {\n        require(!upgraders[_upgrader].exists, \"MR: upgrader already exists\");\n        upgraders[_upgrader] = Info({exists: true, name: _name});\n        emit UpgraderRegistered(_upgrader, _name);\n    }\n\n    /**\n     * @dev Deregisters an upgrader.\n     * @param _upgrader The _upgrader.\n     */\n    function deregisterUpgrader(address _upgrader) external onlyOwner {\n        require(upgraders[_upgrader].exists, \"MR: upgrader does not exists\");\n        delete upgraders[_upgrader];\n        emit UpgraderDeRegistered(_upgrader);\n    }\n\n    /**\n    * @dev Utility method enbaling the owner of the registry to claim any ERC20 token that was sent to the\n    * registry.\n    * @param _token The token to recover.\n    */\n    function recoverToken(address _token) external onlyOwner {\n        uint total = ERC20(_token).balanceOf(address(this));\n        ERC20(_token).transfer(msg.sender, total);\n    } \n\n    /**\n     * @dev Gets the name of a module from its address.\n     * @param _module The module address.\n     * @return the name.\n     */\n    function moduleInfo(address _module) external view returns (bytes32) {\n        return modules[_module].name;\n    }\n\n    /**\n     * @dev Gets the name of an upgrader from its address.\n     * @param _upgrader The upgrader address.\n     * @return the name.\n     */\n    function upgraderInfo(address _upgrader) external view returns (bytes32) {\n        return upgraders[_upgrader].name;\n    }\n\n    /**\n     * @dev Checks if a module is registered.\n     * @param _module The module address.\n     * @return true if the module is registered.\n     */\n    function isRegisteredModule(address _module) external view returns (bool) {\n        return modules[_module].exists;\n    }\n\n    /**\n     * @dev Checks if a list of modules are registered.\n     * @param _modules The list of modules address.\n     * @return true if all the modules are registered.\n     */\n    function isRegisteredModule(address[] _modules) external view returns (bool) {\n        for(uint i = 0; i < _modules.length; i++) {\n            if (!modules[_modules[i]].exists) {\n                return false;\n            }\n        }\n        return true;\n    }  \n\n    /**\n     * @dev Checks if an upgrader is registered.\n     * @param _upgrader The upgrader address.\n     * @return true if the upgrader is registered.\n     */\n    function isRegisteredUpgrader(address _upgrader) external view returns (bool) {\n        return upgraders[_upgrader].exists;\n    } \n}\n\n/**\n * @title BaseWallet\n * @dev Simple modular wallet that authorises modules to call its invoke() method.\n * Based on https://gist.github.com/Arachnid/a619d31f6d32757a4328a428286da186 by \n * @author Julien Niset - <[email protected]>\n */\ncontract BaseWallet {\n\n    // The implementation of the proxy\n    address public implementation;\n    // The owner \n    address public owner;\n    // The authorised modules\n    mapping (address => bool) public authorised;\n    // The enabled static calls\n    mapping (bytes4 => address) public enabled;\n    // The number of modules\n    uint public modules;\n    \n    event AuthorisedModule(address indexed module, bool value);\n    event EnabledStaticCall(address indexed module, bytes4 indexed method);\n    event Invoked(address indexed module, address indexed target, uint indexed value, bytes data);\n    event Received(uint indexed value, address indexed sender, bytes data);\n    event OwnerChanged(address owner);\n    \n    /**\n     * @dev Throws if the sender is not an authorised module.\n     */\n    modifier moduleOnly {\n        require(authorised[msg.sender], \"BW: msg.sender not an authorized module\");\n        _;\n    }\n\n    /**\n     * @dev Inits the wallet by setting the owner and authorising a list of modules.\n     * @param _owner The owner.\n     * @param _modules The modules to authorise.\n     */\n    function init(address _owner, address[] _modules) external {\n        require(owner == address(0) && modules == 0, \"BW: wallet already initialised\");\n        require(_modules.length > 0, \"BW: construction requires at least 1 module\");\n        owner = _owner;\n        modules = _modules.length;\n        for(uint256 i = 0; i < _modules.length; i++) {\n            require(authorised[_modules[i]] == false, \"BW: module is already added\");\n            authorised[_modules[i]] = true;\n            Module(_modules[i]).init(this);\n            emit AuthorisedModule(_modules[i], true);\n        }\n    }\n    \n    /**\n     * @dev Enables/Disables a module.\n     * @param _module The target module.\n     * @param _value Set to true to authorise the module.\n     */\n    function authoriseModule(address _module, bool _value) external moduleOnly {\n        if (authorised[_module] != _value) {\n            if(_value == true) {\n                modules += 1;\n                authorised[_module] = true;\n                Module(_module).init(this);\n            }\n            else {\n                modules -= 1;\n                require(modules > 0, \"BW: wallet must have at least one module\");\n                delete authorised[_module];\n            }\n            emit AuthorisedModule(_module, _value);\n        }\n    }\n\n    /**\n    * @dev Enables a static method by specifying the target module to which the call\n    * must be delegated.\n    * @param _module The target module.\n    * @param _method The static method signature.\n    */\n    function enableStaticCall(address _module, bytes4 _method) external moduleOnly {\n        require(authorised[_module], \"BW: must be an authorised module for static call\");\n        enabled[_method] = _module;\n        emit EnabledStaticCall(_module, _method);\n    }\n\n    /**\n     * @dev Sets a new owner for the wallet.\n     * @param _newOwner The new owner.\n     */\n    function setOwner(address _newOwner) external moduleOnly {\n        require(_newOwner != address(0), \"BW: address cannot be null\");\n        owner = _newOwner;\n        emit OwnerChanged(_newOwner);\n    }\n    \n    /**\n     * @dev Performs a generic transaction.\n     * @param _target The address for the transaction.\n     * @param _value The value of the transaction.\n     * @param _data The data of the transaction.\n     */\n    function invoke(address _target, uint _value, bytes _data) external moduleOnly {\n        // solium-disable-next-line security/no-call-value\n        require(_target.call.value(_value)(_data), \"BW: call to target failed\");\n        emit Invoked(msg.sender, _target, _value, _data);\n    }\n\n    /**\n     * @dev This method makes it possible for the wallet to comply to interfaces expecting the wallet to\n     * implement specific static methods. It delegates the static call to a target contract if the data corresponds \n     * to an enabled method, or logs the call otherwise.\n     */\n    function() public payable {\n        if(msg.data.length > 0) { \n            address module = enabled[msg.sig];\n            if(module == address(0)) {\n                emit Received(msg.value, msg.sender, msg.data);\n            } \n            else {\n                require(authorised[module], \"BW: must be an authorised module for static call\");\n                // solium-disable-next-line security/no-inline-assembly\n                assembly {\n                    calldatacopy(0, 0, calldatasize())\n                    let result := staticcall(gas, module, 0, calldatasize(), 0, 0)\n                    returndatacopy(0, 0, returndatasize())\n                    switch result \n                    case 0 {revert(0, returndatasize())} \n                    default {return (0, returndatasize())}\n                }\n            }\n        }\n    }\n}\n\n/**\n * @title Storage\n * @dev Base contract for the storage of a wallet.\n * @author Julien Niset - <[email protected]>\n */\ncontract Storage {\n\n    /**\n     * @dev Throws if the caller is not an authorised module.\n     */\n    modifier onlyModule(BaseWallet _wallet) {\n        require(_wallet.authorised(msg.sender), \"TS: must be an authorized module to call this method\");\n        _;\n    }\n}\n\n/**\n * @title GuardianStorage\n * @dev Contract storing the state of wallets related to guardians and lock.\n * The contract only defines basic setters and getters with no logic. Only modules authorised\n * for a wallet can modify its state.\n * @author Julien Niset - <[email protected]>\n * @author Olivier Van Den Biggelaar - <[email protected]>\n */\ncontract GuardianStorage is Storage {\n\n    struct GuardianStorageConfig {\n        // the list of guardians\n        address[] guardians;\n        // the info about guardians\n        mapping (address => GuardianInfo) info;\n        // the lock's release timestamp\n        uint256 lock; \n        // the module that set the last lock\n        address locker;\n    }\n\n    struct GuardianInfo {\n        bool exists;\n        uint128 index;\n    }\n\n    // wallet specific storage\n    mapping (address => GuardianStorageConfig) internal configs;\n\n    // *************** External Functions ********************* //\n\n    /**\n     * @dev Lets an authorised module add a guardian to a wallet.\n     * @param _wallet The target wallet.\n     * @param _guardian The guardian to add.\n     */\n    function addGuardian(BaseWallet _wallet, address _guardian) external onlyModule(_wallet) {\n        GuardianStorageConfig storage config = configs[_wallet];\n        config.info[_guardian].exists = true;\n        config.info[_guardian].index = uint128(config.guardians.push(_guardian) - 1);\n    }\n\n    /**\n     * @dev Lets an authorised module revoke a guardian from a wallet.\n     * @param _wallet The target wallet.\n     * @param _guardian The guardian to revoke.\n     */\n    function revokeGuardian(BaseWallet _wallet, address _guardian) external onlyModule(_wallet) {\n        GuardianStorageConfig storage config = configs[_wallet];\n        address lastGuardian = config.guardians[config.guardians.length - 1];\n        if (_guardian != lastGuardian) {\n            uint128 targetIndex = config.info[_guardian].index;\n            config.guardians[targetIndex] = lastGuardian;\n            config.info[lastGuardian].index = targetIndex;\n        }\n        config.guardians.length--;\n        delete config.info[_guardian];\n    }\n\n    /**\n     * @dev Returns the number of guardians for a wallet.\n     * @param _wallet The target wallet.\n     * @return the number of guardians.\n     */\n    function guardianCount(BaseWallet _wallet) external view returns (uint256) {\n        return configs[_wallet].guardians.length;\n    }\n    \n    /**\n     * @dev Gets the list of guaridans for a wallet.\n     * @param _wallet The target wallet.\n     * @return the list of guardians.\n     */\n    function getGuardians(BaseWallet _wallet) external view returns (address[]) {\n        GuardianStorageConfig storage config = configs[_wallet];\n        address[] memory guardians = new address[](config.guardians.length);\n        for (uint256 i = 0; i < config.guardians.length; i++) {\n            guardians[i] = config.guardians[i];\n        }\n        return guardians;\n    }\n\n    /**\n     * @dev Checks if an account is a guardian for a wallet.\n     * @param _wallet The target wallet.\n     * @param _guardian The account.\n     * @return true if the account is a guardian for a wallet.\n     */\n    function isGuardian(BaseWallet _wallet, address _guardian) external view returns (bool) {\n        return configs[_wallet].info[_guardian].exists;\n    }\n\n    /**\n     * @dev Lets an authorised module set the lock for a wallet.\n     * @param _wallet The target wallet.\n     * @param _releaseAfter The epoch time at which the lock should automatically release.\n     */\n    function setLock(BaseWallet _wallet, uint256 _releaseAfter) external onlyModule(_wallet) {\n        configs[_wallet].lock = _releaseAfter;\n        if(_releaseAfter != 0 && msg.sender != configs[_wallet].locker) {\n            configs[_wallet].locker = msg.sender;\n        }\n    }\n\n    /**\n     * @dev Checks if the lock is set for a wallet.\n     * @param _wallet The target wallet.\n     * @return true if the lock is set for the wallet.\n     */\n    function isLocked(BaseWallet _wallet) external view returns (bool) {\n        return configs[_wallet].lock > now;\n    }\n\n    /**\n     * @dev Gets the time at which the lock of a wallet will release.\n     * @param _wallet The target wallet.\n     * @return the time at which the lock of a wallet will release, or zero if there is no lock set.\n     */\n    function getLock(BaseWallet _wallet) external view returns (uint256) {\n        return configs[_wallet].lock;\n    }\n\n    /**\n     * @dev Gets the address of the last module that modified the lock for a wallet.\n     * @param _wallet The target wallet.\n     * @return the address of the last module that modified the lock for a wallet.\n     */\n    function getLocker(BaseWallet _wallet) external view returns (address) {\n        return configs[_wallet].locker;\n    }\n}\n\nlibrary GuardianUtils {\n\n    /**\n    * @dev Checks if an address is an account guardian or an account authorised to sign on behalf of a smart-contract guardian\n    * given a list of guardians.\n    * @param _guardians the list of guardians\n    * @param _guardian the address to test\n    * @return true and the list of guardians minus the found guardian upon success, false and the original list of guardians if not found.\n    */\n    function isGuardian(address[] _guardians, address _guardian) internal view returns (bool, address[]) {\n        if(_guardians.length == 0 || _guardian == address(0)) {\n            return (false, _guardians);\n        }\n        bool isFound = false;\n        address[] memory updatedGuardians = new address[](_guardians.length - 1);\n        uint256 index = 0;\n        for (uint256 i = 0; i < _guardians.length; i++) {\n            if(!isFound) {\n                // check if _guardian is an account guardian\n                if(_guardian == _guardians[i]) {\n                    isFound = true;\n                    continue;\n                }\n                // check if _guardian is the owner of a smart contract guardian\n                if(isContract(_guardians[i]) && isGuardianOwner(_guardians[i], _guardian)) {\n                    isFound = true;\n                    continue;\n                }\n            }\n            if(index < updatedGuardians.length) {\n                updatedGuardians[index] = _guardians[i];\n                index++;\n            }\n        }\n        return isFound ? (true, updatedGuardians) : (false, _guardians);\n    }\n\n   /**\n    * @dev Checks if an address is a contract.\n    * @param _addr The address.\n    */\n    function isContract(address _addr) internal view returns (bool) {\n        uint32 size;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            size := extcodesize(_addr)\n        }\n        return (size > 0);\n    }\n\n    /**\n    * @dev Checks if an address is the owner of a guardian contract. \n    * The method does not revert if the call to the owner() method consumes more then 5000 gas. \n    * @param _guardian The guardian contract\n    * @param _owner The owner to verify.\n    */\n    function isGuardianOwner(address _guardian, address _owner) internal view returns (bool) {\n        address owner = address(0);\n        bytes4 sig = bytes4(keccak256(\"owner()\"));\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr,sig)\n            let result := staticcall(5000, _guardian, ptr, 0x20, ptr, 0x20)\n            if eq(result, 1) {\n                owner := mload(ptr)\n            }\n        }\n        return owner == _owner;\n    }\n} \n\n/**\n * @title LockManager\n * @dev Module to manage the state of a wallet's lock.\n * Other modules can use the state of the lock to determine if their operations \n * should be authorised or blocked. Only the guardians of a wallet can lock and unlock it. \n * The lock automatically unlocks after a given period. The lock state is stored on a separate\n * contract to facilitate its use by other modules.\n * @author Julien Niset - <[email protected]>\n * @author Olivier Van Den Biggelaar - <[email protected]>\n */\ncontract LockManager is BaseModule, RelayerModule {\n\n    bytes32 constant NAME = \"LockManager\";\n\n    // the address of the Guardian storage\n    GuardianStorage public guardianStorage;\n    // The lock period\n    uint256 public lockPeriod;\n\n    // *************** Events *************************** //\n\n    event Locked(address indexed wallet, uint64 releaseAfter);\n    event Unlocked(address indexed wallet);\n    \n    // *************** Modifiers ************************ //\n\n    /**\n     * @dev Throws if the wallet is not locked.\n     */\n    modifier onlyWhenLocked(BaseWallet _wallet) {\n        // solium-disable-next-line security/no-block-members\n        require(guardianStorage.isLocked(_wallet), \"GD: wallet must be locked\");\n        _;\n    }\n\n    /**\n     * @dev Throws if the wallet is locked.\n     */\n    modifier onlyWhenUnlocked(BaseWallet _wallet) {\n        // solium-disable-next-line security/no-block-members\n        require(!guardianStorage.isLocked(_wallet), \"GD: wallet must be unlocked\");\n        _;\n    }\n\n    /**\n     * @dev Throws if the caller is not a guardian for the wallet.\n     */\n    modifier onlyGuardian(BaseWallet _wallet) {\n        (bool isGuardian, ) = GuardianUtils.isGuardian(guardianStorage.getGuardians(_wallet), msg.sender);\n        require(msg.sender == address(this) || isGuardian, \"GD: wallet must be unlocked\");\n        _;\n    }\n\n    // *************** Constructor ************************ //\n\n    constructor(ModuleRegistry _registry, GuardianStorage _guardianStorage, uint256 _lockPeriod) BaseModule(_registry, NAME) public {\n        guardianStorage = _guardianStorage;\n        lockPeriod = _lockPeriod;\n    }\n\n    // *************** External functions ************************ //\n\n    /**\n     * @dev Lets a guardian lock a wallet.\n     * @param _wallet The target wallet.\n     */\n    function lock(BaseWallet _wallet) external onlyGuardian(_wallet) onlyWhenUnlocked(_wallet) {\n        guardianStorage.setLock(_wallet, now + lockPeriod);\n        emit Locked(_wallet, uint64(now + lockPeriod));\n    }\n\n    /**\n     * @dev Lets a guardian unlock a locked wallet.\n     * @param _wallet The target wallet.\n     */\n    function unlock(BaseWallet _wallet) external onlyGuardian(_wallet) onlyWhenLocked(_wallet) {\n        address locker = guardianStorage.getLocker(_wallet);\n        require(locker == address(this), \"LM: cannot unlock a wallet that was locked by another module\");\n        guardianStorage.setLock(_wallet, 0);\n        emit Unlocked(_wallet);\n    }\n\n    /**\n     * @dev Returns the release time of a wallet lock or 0 if the wallet is unlocked.\n     * @param _wallet The target wallet.\n     * @return The epoch time at which the lock will release (in seconds).\n     */\n    function getLock(BaseWallet _wallet) public view returns(uint64 _releaseAfter) {\n        uint256 lockEnd = guardianStorage.getLock(_wallet); \n        if(lockEnd > now) {\n            _releaseAfter = uint64(lockEnd);\n        }\n    }\n\n    /**\n     * @dev Checks if a wallet is locked.\n     * @param _wallet The target wallet.\n     * @return true if the wallet is locked.\n     */\n    function isLocked(BaseWallet _wallet) external view returns (bool _isLocked) {\n        return guardianStorage.isLocked(_wallet);\n    }\n\n    // *************** Implementation of RelayerModule methods ********************* //\n\n    // Overrides to use the incremental nonce and save some gas\n    function checkAndUpdateUniqueness(BaseWallet _wallet, uint256 _nonce, bytes32 _signHash) internal returns (bool) {\n        return checkAndUpdateNonce(_wallet, _nonce);\n    }\n\n    function validateSignatures(BaseWallet _wallet, bytes _data, bytes32 _signHash, bytes _signatures) internal view returns (bool) {\n        (bool isGuardian, ) = GuardianUtils.isGuardian(guardianStorage.getGuardians(_wallet), recoverSigner(_signHash, _signatures, 0));\n        return isGuardian; // \"LM: must be a guardian to lock or unlock\"\n    }\n\n    function getRequiredSignatures(BaseWallet _wallet, bytes _data) internal view returns (uint256) {\n        return 1;\n    }\n}",
  "bytecode": "608060405234801561001057600080fd5b50604051606080611c6883398101604081815282516020808501519483015160008054600160a060020a031916600160a060020a0385161790557f4c6f636b4d616e6167657200000000000000000000000000000000000000000080865293519295949093869390927f3019c8fc80239e3dff8f781212ae2004839c2cb61d6c70acd279ac65392145df928290030190a1505060028054600160a060020a031916600160a060020a03939093169290921790915560035550611b91806100d76000396000f3006080604052600436106100b95763ffffffff7c010000000000000000000000000000000000000000000000000000000060003504166319ab453c81146100be5780632d0335ab146100e15780632f6c493c146101145780633fd8b02f146101355780634a4fbeec1461014a5780635a1db8c41461017f5780636b9db4e6146101a65780639be65a60146101e4578063aacaaf8814610205578063c9b5ef8e14610248578063d89784fc14610269578063f435f5a71461029a575b600080fd5b3480156100ca57600080fd5b506100df600160a060020a03600435166102bb565b005b3480156100ed57600080fd5b50610102600160a060020a0360043516610361565b60408051918252519081900360200190f35b34801561012057600080fd5b506100df600160a060020a036004351661037c565b34801561014157600080fd5b506101026107bb565b34801561015657600080fd5b5061016b600160a060020a03600435166107c1565b604080519115158252519081900360200190f35b34801561018b57600080fd5b506100df600160a060020a036004358116906024351661085e565b3480156101b257600080fd5b506101c7600160a060020a0360043516610a64565b6040805167ffffffffffffffff9092168252519081900360200190f35b3480156101f057600080fd5b506100df600160a060020a0360043516610b0d565b34801561021157600080fd5b5061016b60048035600160a060020a031690602480358082019290810135916044359160643591820191013560843560a435610c41565b34801561025457600080fd5b50610102600160a060020a0360043516610f3b565b34801561027557600080fd5b5061027e610f4d565b60408051600160a060020a039092168252519081900360200190f35b3480156102a657600080fd5b506100df600160a060020a0360043516610f5c565b8033600160a060020a038216146103215760408051600080516020611b46833981519152815260206004820152601960248201527f424d3a2063616c6c6572206d7573742062652077616c6c657400000000000000604482015290519081900360640190fd5b60408051600160a060020a038416815290517f9fcca3f73f85397e2bf03647abf243c20b753bd54463ff3cae74de2971c112fa9181900360200190a15050565b600160a060020a031660009081526001602052604090205490565b600254604080517ff18858ab000000000000000000000000000000000000000000000000000000008152600160a060020a03808516600483015291516000938593859361048093919092169163f18858ab916024808301928792919082900301818387803b1580156103ed57600080fd5b505af1158015610401573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052602081101561042a57600080fd5b81019080805164010000000081111561044257600080fd5b8201602081018481111561045557600080fd5b815185602082028301116401000000008211171561047257600080fd5b50509291905050503361120e565b5090503330148061048e5750805b15156104e95760408051600080516020611b46833981519152815260206004820152601b60248201527f47443a2077616c6c6574206d75737420626520756e6c6f636b65640000000000604482015290519081900360640190fd5b600254604080517f4a4fbeec000000000000000000000000000000000000000000000000000000008152600160a060020a038088166004830152915187939290921691634a4fbeec916024808201926020929091908290030181600087803b15801561055457600080fd5b505af1158015610568573d6000803e3d6000fd5b505050506040513d602081101561057e57600080fd5b505115156105db5760408051600080516020611b46833981519152815260206004820152601960248201527f47443a2077616c6c6574206d757374206265206c6f636b656400000000000000604482015290519081900360640190fd5b600254604080517f919884bf000000000000000000000000000000000000000000000000000000008152600160a060020a0388811660048301529151919092169163919884bf9160248083019260209291908290030181600087803b15801561064357600080fd5b505af1158015610657573d6000803e3d6000fd5b505050506040513d602081101561066d57600080fd5b50519350600160a060020a03841630146106fc5760408051600080516020611b46833981519152815260206004820152603c60248201527f4c4d3a2063616e6e6f7420756e6c6f636b20612077616c6c657420746861742060448201527f776173206c6f636b656420627920616e6f74686572206d6f64756c6500000000606482015290519081900360840190fd5b600254604080517fb0fc29e6000000000000000000000000000000000000000000000000000000008152600160a060020a038881166004830152600060248301819052925193169263b0fc29e69260448084019391929182900301818387803b15801561076857600080fd5b505af115801561077c573d6000803e3d6000fd5b5050604051600160a060020a03881692507f7e6adfec7e3f286831a0200a754127c171a2da564078722cb97704741bbdb0ea9150600090a25050505050565b60035481565b600254604080517f4a4fbeec000000000000000000000000000000000000000000000000000000008152600160a060020a03848116600483015291516000939290921691634a4fbeec9160248082019260209290919082900301818787803b15801561082c57600080fd5b505af1158015610840573d6000803e3d6000fd5b505050506040513d602081101561085657600080fd5b505192915050565b816108698133611395565b15156108ea5760408051600080516020611b46833981519152815260206004820152602e60248201527f424d3a206d73672e73656e646572206d75737420626520616e206f776e65722060448201527f666f72207468652077616c6c6574000000000000000000000000000000000000606482015290519081900360840190fd5b60008054604080517f0bcd4ebb000000000000000000000000000000000000000000000000000000008152600160a060020a03868116600483015291519190921692630bcd4ebb92602480820193602093909283900390910190829087803b15801561095557600080fd5b505af1158015610969573d6000803e3d6000fd5b505050506040513d602081101561097f57600080fd5b505115156109dc5760408051600080516020611b46833981519152815260206004820152601c60248201527f424d3a206d6f64756c65206973206e6f74207265676973746572656400000000604482015290519081900360640190fd5b604080517f1f17732d000000000000000000000000000000000000000000000000000000008152600160a060020a03848116600483015260016024830152915191851691631f17732d9160448082019260009290919082900301818387803b158015610a4757600080fd5b505af1158015610a5b573d6000803e3d6000fd5b50505050505050565b600254604080517f6b9db4e6000000000000000000000000000000000000000000000000000000008152600160a060020a038481166004830152915160009384931691636b9db4e691602480830192602092919082900301818787803b158015610acd57600080fd5b505af1158015610ae1573d6000803e3d6000fd5b505050506040513d6020811015610af757600080fd5b5051905042811115610b07578091505b50919050565b604080517f70a082310000000000000000000000000000000000000000000000000000000081523060048201529051600091600160a060020a038416916370a082319160248082019260209290919082900301818787803b158015610b7157600080fd5b505af1158015610b85573d6000803e3d6000fd5b505050506040513d6020811015610b9b57600080fd5b505160008054604080517fa9059cbb000000000000000000000000000000000000000000000000000000008152600160a060020a0392831660048201526024810185905290519394509085169263a9059cbb92604480840193602093929083900390910190829087803b158015610c1157600080fd5b505af1158015610c25573d6000803e3d6000fd5b505050506040513d6020811015610c3b57600080fd5b50505050565b6000806000805a9250610c8c308d60008e8e8080601f0160208091040260200160405190810160405280939291908181526020018383808284378201915050505050508d8b8b611435565b9150610c998c8a84611629565b1515610cf45760408051600080516020611b46833981519152815260206004820152601560248201527f524d3a204475706c696361746520726571756573740000000000000000000000604482015290519081900360640190fd5b610d2e8c8c8c8080601f0160208091040260200160405190810160405280939291908181526020018383808284375061163d945050505050565b1515610dd55760408051600080516020611b46833981519152815260206004820152604a60248201527f524d3a207468652077616c6c657420617574686f72697a65642069732064696660448201527f666572656e74207468656e2074686520746172676574206f662074686520726560648201527f6c61796564206461746100000000000000000000000000000000000000000000608482015290519081900360a40190fd5b610e0f8c8c8c8080601f016020809104026020016040519081016040528093929190818152602001838380828437506116c7945050505050565b905060418102871415610eea57610e288c8688846116cf565b15610eea57801580610ea35750610ea38c8c8c8080601f016020809104026020016040519081016040528093929190818152602001838380828437820191505050505050848b8b8080601f016020809104026020016040519081016040528093929190818152602001838380828437506117a3945050505050565b15610eea5730600160a060020a03168b8b604051808383808284378201915050925050506000604051808303816000865af19150509350610eea8c5a8503888885336118ba565b60408051838152905185151591600160a060020a038f16917f6bb0b384ce772133df63560651bc8c727c53306cec1d51e2cbf8ea35fb8f2ec19181900360200190a350505098975050505050505050565b60016020526000908152604090205481565b600254600160a060020a031681565b600254604080517ff18858ab000000000000000000000000000000000000000000000000000000008152600160a060020a03808516600483015291518493600093610fca9391169163f18858ab91602480820192879290919082900301818387803b1580156103ed57600080fd5b50905033301480610fd85750805b15156110335760408051600080516020611b46833981519152815260206004820152601b60248201527f47443a2077616c6c6574206d75737420626520756e6c6f636b65640000000000604482015290519081900360640190fd5b600254604080517f4a4fbeec000000000000000000000000000000000000000000000000000000008152600160a060020a038087166004830152915186939290921691634a4fbeec916024808201926020929091908290030181600087803b15801561109e57600080fd5b505af11580156110b2573d6000803e3d6000fd5b505050506040513d60208110156110c857600080fd5b5051156111245760408051600080516020611b46833981519152815260206004820152601b60248201527f47443a2077616c6c6574206d75737420626520756e6c6f636b65640000000000604482015290519081900360640190fd5b600254600354604080517fb0fc29e6000000000000000000000000000000000000000000000000000000008152600160a060020a0388811660048301524290930160248201529051919092169163b0fc29e691604480830192600092919082900301818387803b15801561119757600080fd5b505af11580156111ab573d6000803e3d6000fd5b5050505083600160a060020a03167f6395bace6e0acbe4f22761b149d3cc2e88c7dde6bf4d8481825eef404cf989a16003544201604051808267ffffffffffffffff1667ffffffffffffffff16815260200191505060405180910390a250505050565b60006060600060606000808751600014806112305750600160a060020a038716155b15611241576000889550955061138a565b600093506001885103604051908082528060200260200182016040528015611273578160200160208202803883390190505b50925060009150600090505b87518110156113745783151561131f57878181518110151561129d57fe5b90602001906020020151600160a060020a031687600160a060020a031614156112c9576001935061136c565b6112e988828151811015156112da57fe5b90602001906020020151611989565b80156113115750611311888281518110151561130157fe5b9060200190602002015188611997565b1561131f576001935061136c565b825182101561136c57878181518110151561133657fe5b90602001906020020151838381518110151561134e57fe5b600160a060020a039092166020928302909101909101526001909101905b60010161127f565b8361138157600088611385565b6001835b955095505b505050509250929050565b600081600160a060020a031683600160a060020a0316638da5cb5b6040518163ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401602060405180830381600087803b1580156113f857600080fd5b505af115801561140c573d6000803e3d6000fd5b505050506040513d602081101561142257600080fd5b5051600160a060020a0316149392505050565b6040517f190000000000000000000000000000000000000000000000000000000000000060208083018281526000602185018190526c01000000000000000000000000600160a060020a03808e16820260228801528c16026036860152604a85018a90528851909485938d938d938d938d938d938d938d939192606a909201918701908083835b602083106114db5780518252601f1990920191602091820191016114bc565b6001836020036101000a03801982511681845116808217855250505050505090500184815260200183815260200182815260200199505050505050505050506040516020818303038152906040526040518082805190602001908083835b602083106115585780518252601f199092019160209182019101611539565b51815160209384036101000a6000190180199092169116179052604080519290940182900382207f19457468657265756d205369676e6564204d6573736167653a0a33320000000083830152603c8084019190915284518084039091018152605c9092019384905281519195509293508392850191508083835b602083106115f15780518252601f1990920191602091820191016115d2565b5181516020939093036101000a600019018019909116921691909117905260405192018290039091209b9a5050505050505050505050565b60006116358484611a0b565b949350505050565b60008060248351101515156116a15760408051600080516020611b46833981519152815260206004820152601660248201527f524d3a20496e76616c6964206461746157616c6c657400000000000000000000604482015290519081900360640190fd5b6024830151905083600160a060020a031681600160a060020a03161491505b5092915050565b600192915050565b600080831180156116e05750600182115b801561178b575082840285600160a060020a031631108061178b5750604080517fd6eb1bbf0000000000000000000000000000000000000000000000000000000081523060048201529051600160a060020a0387169163d6eb1bbf9160248083019260209291908290030181600087803b15801561175d57600080fd5b505af1158015611771573d6000803e3d6000fd5b505050506040513d602081101561178757600080fd5b5051155b1561179857506000611635565b506001949350505050565b600254604080517ff18858ab000000000000000000000000000000000000000000000000000000008152600160a060020a038781166004830152915160009384936118af9391169163f18858ab91602480820192879290919082900301818387803b15801561181157600080fd5b505af1158015611825573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052602081101561184e57600080fd5b81019080805164010000000081111561186657600080fd5b8201602081018481111561187957600080fd5b815185602082028301116401000000008211171561189657600080fd5b50509291905050506118aa86866000611a98565b61120e565b509695505050505050565b61726c85016000851180156118cf5750600183115b80156118db5750838111155b15610a5b573a8511156118ef573a026118f2565b84025b604080517f8f6f0332000000000000000000000000000000000000000000000000000000008152600160a060020a03848116600483015260248201849052606060448301526000606483018190529251908a1692638f6f03329260a4808201939182900301818387803b15801561196857600080fd5b505af115801561197c573d6000803e3d6000fd5b5050505050505050505050565b6000903b63ffffffff161190565b604080517f6f776e657228290000000000000000000000000000000000000000000000000081529051908190036007018120808252600091829190602081818189611388fa60018114156119ea57815193505b505083600160a060020a031682600160a060020a0316149250505092915050565b600160a060020a03821660009081526001602052604081205481908311611a3557600091506116c0565b507001000000000000000000000000000000006fffffffffffffffffffffffffffffffff198316044361271001811115611a7257600091506116c0565b5050600160a060020a039190911660009081526001602081905260409091209190915590565b6041808202830160208101516040820151919092015160009260ff9190911691601b831480611aca57508260ff16601c145b1515611ad557600080fd5b60408051600080825260208083018085528b905260ff8716838501526060830186905260808301859052925160019360a0808501949193601f19840193928390039091019190865af1158015611b2f573d6000803e3d6000fd5b5050604051601f19015198975050505050505050560008c379a000000000000000000000000000000000000000000000000000000000a165627a7a72305820f19f76ab7a1a80aac40b54247b2316f3a86a7ae633e62775ebbc30dd79d9225b0029000000000000000000000000c17d432bd8e8850fd7b32b0270f5afac65db010500000000000000000000000044da3a8051ba88eab0440db3779cab9d679ae76f0000000000000000000000000000000000000000000000000000000000069780",
  "constructorArguments": "000000000000000000000000c17d432bd8e8850fd7b32b0270f5afac65db010500000000000000000000000044da3a8051ba88eab0440db3779cab9d679ae76f0000000000000000000000000000000000000000000000000000000000069780"
}