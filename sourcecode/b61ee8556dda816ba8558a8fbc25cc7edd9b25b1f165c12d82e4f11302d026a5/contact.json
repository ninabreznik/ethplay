{
  "address": "0x00000000002b13cccec913420a21e4d11b2dcd3c",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "Metapod",
  "compilerVersion": "v0.5.6+commit.b259423e",
  "optimization": true,
  "runs": "999",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2019-04-07\n*/\n\npragma solidity 0.5.6;\n\n\n/**\n * @title Metapod (Version 1)\n * @author 0age\n * @notice This contract creates \"hardened\" metamorphic contracts, or contracts\n * that can be redeployed with new code to the same address, with additional\n * protections against creating non-metamorphic contracts or losing any balance\n * held by the contract when it is destroyed. It does so by first setting the\n * desired contract initialization code in temporary storage. Next, a vault\n * contract corresponding to the target address is checked for a balance, and if\n * one exists it will be sent to the address of an intermediate deployer, or a\n * transient contract with fixed, non-deterministic initialization code. Once\n * deployed via CREATE2, the transient contract retrieves the initialization\n * code from storage and uses it to deploy the contract via CREATE, forwarding\n * the entire balance to the new contract, and then SELFDESTRUCTs. Finally, the\n * contract prelude is checked to ensure that it is properly destructible and\n * that it designates the vault as the forwarding address. Once the contract\n * undergoes metamorphosis, all existing storage will be deleted and any balance\n * will be forwarded to the vault that can then resupply the metamorphic\n * contract upon redeployment.\n * @dev This contract has not yet been fully tested or audited - proceed with\n * abundant caution and please share any exploits or optimizations you discover.\n * Also, bear in mind that any initialization code provided to the contract must\n * contain the proper prelude, or initial sequence, with a length of 44 bytes:\n *\n *  `0x6e2b13cccec913420a21e4d11b2dcd3c3318602b5773 + vault_address + 0xff5b`\n *\n * For the required vault address, use `findVaultContractAddress(bytes32 salt)`.\n * Any initialization code generated by Solidity or another compiler will need\n * to have the stack items provided to JUMP, JUMPI, and CODECOPY altered\n * appropriately upon inserting this code, and may also need to alter some PC\n * operations (especially if it is not Solidity code). Be aware that contracts\n * are still accessible after they have been scheduled for deletion until the\n * transaction is completed, and that ether may still be sent to them - as the\n * funds forwarding step is performed immediately, not as part of the\n * transaction substate with the account removal. If those funds do not move to\n * a non-destructing account by the end of the transaction, they will be\n * irreversibly burned. Lastly, due to the mechanics of SELFDESTRUCT, a contract\n * cannot be destroyed and redeployed in a single transaction - to avoid\n * \"downtime\" of the contract, consider utilizing multiple contracts and having\n * the callers determine the current contract by using EXTCODEHASH.\n */\ncontract Metapod {\n  // fires when a metamorphic contract is deployed.\n  event Metamorphosed(address metamorphicContract, bytes32 salt);\n\n  // fires when a metamorphic contract is destroyed.\n  event Cocooned(address metamorphicContract, bytes32 salt);\n\n  // initialization code for transient contract to deploy metamorphic contracts.\n  /* ##  op  operation        [stack] <memory> {return_buffer} *contract_deploy*\n     00  58  PC               [0]\n     01  60  PUSH1 0x1c       [0, 28]\n     03  59  MSIZE            [0, 28, 0]\n     04  58  PC               [0, 28, 0, 4]\n     05  59  MSIZE            [0, 28, 0, 4, 0]\n     06  92  SWAP3            [0, 0, 0, 4, 28]\n     07  33  CALLER           [0, 0, 0, 4, 28, caller]\n     08  5a  GAS              [0, 0, 0, 4, 28, caller, gas]\n     09  63  PUSH4 0x57b9f523 [0, 0, 0, 4, 28, caller, gas, selector]\n     14  59  MSIZE            [0, 0, 0, 4, 28, caller, gas, selector, 0]\n     15  52  MSTORE           [0, 0, 0, 4, 28, caller, gas] <selector>\n     16  fa  STATICCALL       [0, 1 => success] {init_code}\n     17  50  POP              [0]\n     18  60  PUSH1 0x40       [0, 64]\n     20  30  ADDRESS          [0, 64, address]\n     21  31  BALANCE          [0, 64, balance]\n     22  81  DUP2             [0, 64, balance, 64]\n     23  3d  RETURNDATASIZE   [0, 64, balance, 64, size]\n     24  03  SUB              [0, 64, balance, size - 64]\n     25  83  DUP4             [0, 64, balance, size - 64, 0]\n     26  92  SWAP3            [0, 0, balance, size - 64, 64]\n     27  81  DUP2             [0, 0, balance, size - 64, 64, size - 64]\n     28  94  SWAP5            [size - 64, 0, balance, size - 64, 64, 0]\n     29  3e  RETURNDATACOPY   [size - 64, 0, balance] <init_code>\n     30  f0  CREATE           [contract_address or 0] *init_code*\n     31  80  DUP1             [contract_address or 0, contract_address or 0]\n     32  15  ISZERO           [contract_address or 0, 0 or 1]\n     33  60  PUSH1 0x25       [contract_address or 0, 0 or 1, 37]\n     35  57  JUMPI            [contract_address]\n     36  ff  SELFDESTRUCT     []\n     37  5b  JUMPDEST         [0]\n     38  80  DUP1             [0, 0]\n     39  fd  REVERT           []\n  */\n  bytes private constant TRANSIENT_CONTRACT_INITIALIZATION_CODE = (\n    hex\"58601c59585992335a6357b9f5235952fa5060403031813d03839281943ef08015602557ff5b80fd\"\n  );\n\n  // store the hash of the initialization code for transient contracts as well.\n  bytes32 private constant TRANSIENT_CONTRACT_INITIALIZATION_CODE_HASH = bytes32(\n    0xb7d11e258d6663925ce8e43f07ba3b7792a573ecc2fd7682d01f8a70b2223294\n  );\n\n  // the \"empty data hash\" is used to determine if the vault has been deployed.\n  bytes32 private constant EMPTY_DATA_HASH = bytes32(\n    0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\n  );\n\n  // maintain a temporary storage slot for metamorphic initialization code.\n  bytes private _initCode;\n\n  constructor() public {\n    // ensure that the deployment address is correct.\n    // factory: 0x00000000e82eb0431756271F0d00CFB143685e7B\n    // caller: 0x0734d56DA60852A03e2Aafae8a36FFd8c12B32f1\n    // init code hash: 0x8954ff8965dbf871b7b4f49acc85a2a7c96c93ebc16ba59a4d07c52d8d0b6ec2\n    // salt: 0x0734d56da60852a03e2aafae8a36ffd8c12b32f1ee8671f229d5dd0853050000\n    require(\n      address(this) == address(0x00000000002B13cCcEC913420A21e4D11b2DCd3C),\n      \"Incorrect deployment address.\"\n    );\n\n    // ensure the transient initialization code hash constant value is correct.\n    require(\n      keccak256(\n        abi.encodePacked(TRANSIENT_CONTRACT_INITIALIZATION_CODE)\n      ) == TRANSIENT_CONTRACT_INITIALIZATION_CODE_HASH,\n      \"Incorrect hash for transient initialization code.\"\n    );\n\n    // ensure the empty data hash constant value is correct.\n    require(\n      keccak256(abi.encodePacked(hex\"\")) == EMPTY_DATA_HASH,\n      \"Incorrect hash for empty data.\"\n    );\n  }\n\n  /**\n   * @dev Deploy a metamorphic contract by submitting a given salt or nonce\n   * along with the initialization code to a transient contract which will then\n   * deploy the metamorphic contract before immediately SELFDESTRUCTing. To\n   * replace the metamorphic contract, call destroy() with the same salt value,\n   * then call with the same salt value and new initialization code (be aware\n   * that all existing state will be wiped from the contract).\n   * @param identifier uint96 The last twelve bytes of the salt that will be\n   * passed into the CREATE2 call (with the first twenty bytes of the salt set\n   * to `msg.sender`) and thus will determine the resulant address of the\n   * metamorphic contract.\n   * @param initializationCode bytes The initialization code for the metamorphic\n   * contract that will be deployed by the transient contract.\n   * @return The address of the deployed metamorphic contract.\n   */\n  function deploy(\n    uint96 identifier,\n    bytes calldata initializationCode\n  ) external payable returns (address metamorphicContract) {\n    // compute the salt using the supplied identifier.\n    bytes32 salt = _getSalt(identifier);\n\n    // store the initialization code to be retrieved by the transient contract.\n    _initCode = initializationCode;\n\n    // get vault contract and provide any funds therein to transient contract.\n    address vaultContract = _triggerVaultFundsRelease(salt);\n\n    // declare variable to verify successful transient contract deployment.\n    address transientContract;\n\n    // move transient contract initialization code into memory.\n    bytes memory initCode = TRANSIENT_CONTRACT_INITIALIZATION_CODE;\n\n    // load transient contract init data and size, then deploy via CREATE2.\n    assembly { /* solhint-disable no-inline-assembly */\n      let encoded_data := add(0x20, initCode) // load initialization code.\n      let encoded_size := mload(initCode)     // load the init code's length.\n      transientContract := create2(           // call CREATE2 with 4 arguments.\n        callvalue,                            // forward any supplied endowment.\n        encoded_data,                         // pass in initialization code.\n        encoded_size,                         // pass in init code's length.\n        salt                                  // pass in the salt value.\n      )\n    } /* solhint-enable no-inline-assembly */\n\n    // ensure that the contracts were successfully deployed.\n    require(transientContract != address(0), \"Failed to deploy contract.\");\n\n    // get the address of the deployed metamorphic contract.\n    metamorphicContract = _getMetamorphicContractAddress(transientContract);\n\n    // ensure that the deployed runtime code has the required prelude.\n    _verifyPrelude(metamorphicContract, _getPrelude(vaultContract));\n\n    // clear the supplied initialization code from temporary storage.\n    delete _initCode;\n\n    // emit an event to signify that the contract was successfully deployed.\n    emit Metamorphosed(metamorphicContract, salt);\n  }\n\n  /**\n   * @dev Destroy a metamorphic contract by calling into it, which will trigger\n   * a SELFDESTRUCT and forward all funds to the designated vault contract. Be\n   * aware that all existing state will be wiped from the contract.\n   * @param identifier uint96 The last twelve bytes of the salt that was passed\n   * into the CREATE2 call (with the first twenty bytes of the salt set to\n   * `msg.sender`) that determined resulant address of the metamorphic contract.\n   */\n  function destroy(uint96 identifier) external {\n    // compute the salt using the supplied identifier.\n    bytes32 salt = _getSalt(identifier);\n\n    // determine the address of the metamorphic contract.\n    address metamorphicContract = _getMetamorphicContractAddress(\n      _getTransientContractAddress(salt)\n    );\n\n    // call it to trigger a SELFDESTRUCT that forwards any funds to the vault.\n    metamorphicContract.call(\"\"); /* solhint-disable-line avoid-low-level-calls */\n\n    // emit an event to signify that the contract was scheduled for deletion.\n    emit Cocooned(metamorphicContract, salt);\n  }\n\n  /**\n   * @dev Recover the funds from a metamorphic contract, the associated vault,\n   * and the associated transient contract by deploying a dedicated metamorphic\n   * contract that will forward funds to `msg.sender` and immediately\n   * SELFDESTRUCT. The contract must be \"cocooned\" or else it will fail.\n   * @param identifier uint96 The last twelve bytes of the salt that was passed\n   * into the CREATE2 call (with the first twenty bytes of the salt set to\n   * `msg.sender`) that determined resulant address of the metamorphic contract.\n   */\n  function recover(uint96 identifier) external {\n    // compute the salt using the supplied identifier.\n    bytes32 salt = _getSalt(identifier);\n\n    // trigger the vault contract to forward funds to the transient contract.\n    _triggerVaultFundsRelease(salt);\n\n    // construct recovery contract initialization code and set in temp storage.\n    _initCode = abi.encodePacked(\n      bytes2(0x5873),  // PC PUSH20\n      msg.sender,      // <the caller is the recipient of funds>\n      bytes13(0x905959593031856108fcf150ff)\n        // SWAP1 MSIZEx3 ADDRESS BALANCE DUP6 PUSH2 2300 CALL POP SELFDESTRUCT\n    );\n\n    // declare variable to verify successful transient contract deployment.\n    address transientContract;\n\n    // move transient contract initialization code into memory.\n    bytes memory initCode = TRANSIENT_CONTRACT_INITIALIZATION_CODE;\n\n    // load transient contract init data and size, then deploy via CREATE2.\n    assembly { /* solhint-disable no-inline-assembly */\n      let encoded_data := add(0x20, initCode) // load initialization code.\n      let encoded_size := mload(initCode)     // load the init code's length.\n      transientContract := create2(           // call CREATE2 with 4 arguments.\n        callvalue,                            // forward any supplied endowment.\n        encoded_data,                         // pass in initialization code.\n        encoded_size,                         // pass in init code's length.\n        salt                                  // pass in the salt value.\n      )\n    } /* solhint-enable no-inline-assembly */\n\n    // ensure that the recovery contract was successfully deployed.\n    require(\n      transientContract != address(0),\n      \"Recovery failed - ensure that the contract has been destroyed.\"\n    );\n\n    // clear recovery contract initialization code from temporary storage.\n    delete _initCode;\n  }\n\n  /**\n   * @dev View function for retrieving the initialization code for a given\n   * metamorphic contract to deploy via a transient contract. Called by the\n   * constructor of each transient contract - not meant to be called by users.\n   * @return The initialization code to use to deploy the metamorphic contract.\n   */\n  function getInitializationCode() external view returns (\n    bytes memory initializationCode\n  ) {\n    // return the current initialization code from temporary storage.\n    initializationCode = _initCode;\n  }\n\n  /**\n   * @dev Compute the address of the transient contract that will be created\n   * upon submitting a given salt to the contract.\n   * @param salt bytes32 The nonce passed into CREATE2 when deploying the\n   * transient contract, composed of caller ++ identifier.\n   * @return The address of the corresponding transient contract.\n   */\n  function findTransientContractAddress(\n    bytes32 salt\n  ) external pure returns (address transientContract) {\n    // determine the address where the transient contract will be deployed.\n    transientContract = _getTransientContractAddress(salt);\n  }\n\n  /**\n   * @dev Compute the address of the metamorphic contract that will be created\n   * upon submitting a given salt to the contract.\n   * @param salt bytes32 The nonce used to create the transient contract that\n   * deploys the metamorphic contract, composed of caller ++ identifier.\n   * @return The address of the corresponding metamorphic contract.\n   */\n  function findMetamorphicContractAddress(\n    bytes32 salt\n  ) external pure returns (address metamorphicContract) {\n    // determine the address of the metamorphic contract.\n    metamorphicContract = _getMetamorphicContractAddress(\n      _getTransientContractAddress(salt)\n    );\n  }\n\n  /**\n   * @dev Compute the address of the vault contract that will be set as the\n   * recipient of funds from the metamorphic contract when it is destroyed.\n   * @param salt bytes32 The nonce used to create the transient contract that\n   * deploys the metamorphic contract, composed of caller ++ identifier.\n   * @return The address of the corresponding vault contract.\n   */\n  function findVaultContractAddress(\n    bytes32 salt\n  ) external pure returns (address vaultContract) {\n    vaultContract = _getVaultContractAddress(\n      _getVaultContractInitializationCode(\n        _getTransientContractAddress(salt)\n      )\n    );\n  }\n\n  /**\n   * @dev View function for retrieving the prelude that will be required for any\n   * metamorphic contract deployed via a specific salt.\n   * @param salt bytes32 The nonce used to create the transient contract that\n   * deploys the metamorphic contract, composed of caller ++ identifier.\n   * @return The prelude that will be need to be present at the start of the\n   * deployed runtime code for any metamorphic contracts deployed using the\n   * provided salt.\n   */\n  function getPrelude(bytes32 salt) external pure returns (\n    bytes memory prelude\n  ) {\n    // compute and return the prelude.\n    prelude = _getPrelude(\n      _getVaultContractAddress(\n        _getVaultContractInitializationCode(\n          _getTransientContractAddress(salt)\n        )\n      )\n    );\n  }  \n\n  /**\n   * @dev View function for retrieving the initialization code of metamorphic\n   * contracts for purposes of verification.\n   * @return The initialization code used to deploy transient contracts.\n   */\n  function getTransientContractInitializationCode() external pure returns (\n    bytes memory transientContractInitializationCode\n  ) {\n    // return the initialization code used to deploy transient contracts.\n    transientContractInitializationCode = (\n      TRANSIENT_CONTRACT_INITIALIZATION_CODE\n    );\n  }\n\n  /**\n   * @dev View function for retrieving the keccak256 hash of the initialization\n   * code of metamorphic contracts for purposes of verification.\n   * @return The keccak256 hash of the initialization code used to deploy\n   * transient contracts.\n   */\n  function getTransientContractInitializationCodeHash() external pure returns (\n    bytes32 transientContractInitializationCodeHash\n  ) {\n    // return hash of initialization code used to deploy transient contracts.\n    transientContractInitializationCodeHash = (\n      TRANSIENT_CONTRACT_INITIALIZATION_CODE_HASH\n    );\n  }\n\n  /**\n   * @dev View function for calculating a salt given a particular caller and\n   * identifier.\n   * @param identifier bytes12 The last twelve bytes of the salt (the first\n   * twenty bytes are set to `msg.sender`).\n   * @return The salt that will be supplied to CREATE2 upon providing the given\n   * identifier from the calling account.\n   */\n  function getSalt(uint96 identifier) external view returns (bytes32 salt) {\n    salt = _getSalt(identifier);\n  }\n\n  /**\n   * @dev Internal view function for calculating a salt given a particular\n   * caller and identifier.\n   * @param identifier bytes12 The last twelve bytes of the salt (the first\n   * twenty bytes are set to `msg.sender`).\n   * @return The salt that will be supplied to CREATE2.\n   */\n  function _getSalt(uint96 identifier) internal view returns (bytes32 salt) {\n    assembly { /* solhint-disable no-inline-assembly */\n      salt := or(shl(96, caller), identifier) // caller: first 20, ID: last 12\n    } /* solhint-enable no-inline-assembly */\n  }\n\n  /**\n   * @dev Internal function for determining the required prelude for metamorphic\n   * contracts deployed through the factory based on the corresponding vault\n   * contract.\n   * @param vaultContract address The address of the vault contract.\n   * @return The prelude that will be required for given a vault contract.\n   */\n  function _getPrelude(\n    address vaultContract\n  ) internal pure returns (bytes memory prelude) {\n    prelude = abi.encodePacked(\n      // PUSH15 <this> CALLER XOR PUSH1 43 JUMPI PUSH20\n      bytes22(0x6e2b13cccec913420a21e4d11b2dcd3c3318602b5773),\n      vaultContract, // <vault is the approved SELFDESTRUCT recipient>\n      bytes2(0xff5b) // SELFDESTRUCT JUMPDEST\n    );\n  }\n\n  /**\n   * @dev Internal function for determining if deployed metamorphic contract has\n   * the necessary prelude at the start of its runtime code. The prelude ensures\n   * that the contract can be destroyed by a call originating from this contract\n   * and that any funds will be forwarded to the corresponding vault contract.\n   * @param metamorphicContract address The address of the metamorphic contract.\n   * @param prelude bytes The prelude that must be present on the contract.\n   */\n  function _verifyPrelude(\n    address metamorphicContract,\n    bytes memory prelude\n  ) internal view {\n    // get the first 44 bytes of metamorphic contract runtime code.\n    bytes memory runtimeHeader;\n\n    assembly { /* solhint-disable no-inline-assembly */\n      // set and update the pointer based on the size of the runtime header.\n      runtimeHeader := mload(0x40)\n      mstore(0x40, add(runtimeHeader, 0x60))\n\n      // store the runtime header code and length in memory.\n      mstore(runtimeHeader, 44)\n      extcodecopy(metamorphicContract, add(runtimeHeader, 0x20), 0, 44)\n    } /* solhint-enable no-inline-assembly */\n\n    // ensure that the contract's runtime code has the correct prelude.\n    require(\n      keccak256(\n        abi.encodePacked(prelude)\n      ) == keccak256(\n        abi.encodePacked(runtimeHeader)\n      ),\n      \"Deployed runtime code does not have the required prelude.\"\n    );\n  }\n\n  /**\n   * @dev Internal function for determining if a vault contract has a balance\n   * and tranferring the balance to the corresponding transient contract if so.\n   * This is achieved via deploying the vault contract if no contract exists yet\n   * or by calling the contract if it has already been deployed.\n   * @param salt bytes32 The nonce used to create the transient contract that\n   * deploys the metamorphic contract associated with a corresponding vault.\n   * @return The address of the vault contract.\n   */\n  function _triggerVaultFundsRelease(\n    bytes32 salt\n  ) internal returns (address vaultContract) {\n    // determine the address of the transient contract.\n    address transientContract = _getTransientContractAddress(salt);\n\n    // determine the initialization code of the vault contract.\n    bytes memory vaultContractInitCode = _getVaultContractInitializationCode(\n      transientContract\n    );\n\n    // determine the address of the vault contract.\n    vaultContract = _getVaultContractAddress(vaultContractInitCode);\n\n    // determine if the vault has a balance.\n    if (vaultContract.balance > 0) {\n      // determine if the vault has already been deployed.\n      bytes32 vaultContractCodeHash;\n\n      assembly { /* solhint-disable no-inline-assembly */\n        vaultContractCodeHash := extcodehash(vaultContract)\n      } /* solhint-enable no-inline-assembly */\n\n      // if it hasn't been deployed, deploy it to send funds to transient.\n      if (vaultContractCodeHash == EMPTY_DATA_HASH) {\n        assembly { /* solhint-disable no-inline-assembly */\n          let encoded_data := add(0x20, vaultContractInitCode) // init code.\n          let encoded_size := mload(vaultContractInitCode)     // init length.\n          let _ := create2(                   // call CREATE2.\n            0,                                // do not supply any endowment.\n            encoded_data,                     // pass in initialization code.\n            encoded_size,                     // pass in init code's length.\n            0                                 // pass in zero as the salt value.\n          )\n        } /* solhint-enable no-inline-assembly */\n      // otherwise, just call it which will also send funds to transient.\n      } else {\n        vaultContract.call(\"\"); /* solhint-disable-line avoid-low-level-calls */\n      }\n    }\n  }\n\n  /**\n   * @dev Internal view function for calculating a transient contract address\n   * given a particular salt.\n   * @param salt bytes32 The nonce used to create the transient contract.\n   * @return The address of the transient contract.\n   */\n  function _getTransientContractAddress(\n    bytes32 salt\n  ) internal pure returns (address transientContract) {\n    // determine the address of the transient contract.\n    transientContract = address(\n      uint160(                      // downcast to match the address type.\n        uint256(                    // convert to uint to truncate upper digits.\n          keccak256(                // compute the CREATE2 hash using 4 inputs.\n            abi.encodePacked(       // pack all inputs to the hash together.\n              hex\"ff\",              // start with 0xff to distinguish from RLP.\n              address(0x00000000002B13cCcEC913420A21e4D11b2DCd3C), // this.\n              salt,                 // pass in the supplied salt value.\n              TRANSIENT_CONTRACT_INITIALIZATION_CODE_HASH // the init code hash.\n            )\n          )\n        )\n      )\n    );\n  }\n\n  /**\n   * @dev Internal view function for calculating a metamorphic contract address\n   * that has been deployed via a transient contract given the address of the\n   * transient contract.\n   * @param transientContract address The address of the transient contract.\n   * @return The address of the metamorphic contract.\n   */\n  function _getMetamorphicContractAddress(\n    address transientContract\n  ) internal pure returns (address metamorphicContract) {\n    // determine the address of the metamorphic contract.\n    metamorphicContract = address(\n      uint160(                          // downcast to match the address type.\n        uint256(                        // set to uint to truncate upper digits.\n          keccak256(                    // compute CREATE hash via RLP encoding.\n            abi.encodePacked(           // pack all inputs to the hash together.\n              bytes2(0xd694),           // first two RLP bytes.\n              transientContract,        // called by the transient contract.\n              byte(0x01)                // nonce begins at 1 for contracts.\n            )\n          )\n        )\n      )\n    );\n  }\n\n  /**\n   * @dev Internal view function for calculating a initialization code for a\n   * given vault contract based on the corresponding transient contract.\n   * @param transientContract address The address of the transient contract.\n   * @return The initialization code for the vault contract.\n   */\n  function _getVaultContractInitializationCode(\n    address transientContract\n  ) internal pure returns (bytes memory vaultContractInitializationCode) {\n    vaultContractInitializationCode = abi.encodePacked(\n      // PC PUSH15 <this> CALLER XOR PC JUMPI MSIZEx3 ADDRESS BALANCE PUSH20\n      bytes27(0x586e2b13cccec913420a21e4d11b2dcd3c33185857595959303173),\n      // the transient contract is the recipient of funds\n      transientContract,\n      // GAS CALL PUSH1 49 MSIZE DUP2 MSIZEx2 CODECOPY RETURN\n      bytes10(0x5af160315981595939f3)\n    );\n  }\n\n  /**\n   * @dev Internal view function for calculating a vault contract address given\n   * the initialization code for the vault contract.\n   * @param vaultContractInitializationCode bytes The initialization code of the\n   * vault contract.\n   * @return The address of the vault contract.\n   */\n  function _getVaultContractAddress(\n    bytes memory vaultContractInitializationCode\n  ) internal pure returns (address vaultContract) {\n    // determine the address of the vault contract.\n    vaultContract = address(\n      uint160(                      // downcast to match the address type.\n        uint256(                    // convert to uint to truncate upper digits.\n          keccak256(                // compute the CREATE2 hash using 4 inputs.\n            abi.encodePacked(       // pack all inputs to the hash together.\n              byte(0xff),           // start with 0xff to distinguish from RLP.\n              address(0x00000000002B13cCcEC913420A21e4D11b2DCd3C), // this.\n              bytes32(0),           // leave the salt value set to zero.\n              keccak256(            // hash the supplied initialization code.\n                vaultContractInitializationCode\n              )\n            )\n          )\n        )\n      )\n    );\n  }\n}",
  "abi": "[{\"constant\":true,\"inputs\":[],\"name\":\"getTransientContractInitializationCodeHash\",\"outputs\":[{\"name\":\"transientContractInitializationCodeHash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTransientContractInitializationCode\",\"outputs\":[{\"name\":\"transientContractInitializationCode\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"identifier\",\"type\":\"uint96\"}],\"name\":\"getSalt\",\"outputs\":[{\"name\":\"salt\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"identifier\",\"type\":\"uint96\"}],\"name\":\"recover\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"identifier\",\"type\":\"uint96\"},{\"name\":\"initializationCode\",\"type\":\"bytes\"}],\"name\":\"deploy\",\"outputs\":[{\"name\":\"metamorphicContract\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"findVaultContractAddress\",\"outputs\":[{\"name\":\"vaultContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInitializationCode\",\"outputs\":[{\"name\":\"initializationCode\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"findTransientContractAddress\",\"outputs\":[{\"name\":\"transientContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"findMetamorphicContractAddress\",\"outputs\":[{\"name\":\"metamorphicContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"identifier\",\"type\":\"uint96\"}],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"getPrelude\",\"outputs\":[{\"name\":\"prelude\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"metamorphicContract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"Metamorphosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"metamorphicContract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"Cocooned\",\"type\":\"event\"}]",
  "bytecode": "608060405234801561001057600080fd5b50306e2b13cccec913420a21e4d11b2dcd3c1461008e57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f496e636f7272656374206465706c6f796d656e7420616464726573732e000000604482015290519081900360640190fd5b7fb7d11e258d6663925ce8e43f07ba3b7792a573ecc2fd7682d01f8a70b222329460001b604051806060016040528060288152602001611113602891396040516020018082805190602001908083835b602083106100fd5780518252601f1990920191602091820191016100de565b6001836020036101000a038019825116818451168082178552505050505050905001915050604051602081830303815290604052805190602001201461018e576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260318152602001806110e26031913960400191505060405180910390fd5b604080516000815260208101918290525190207fc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a4701461022e57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601e60248201527f496e636f7272656374206861736820666f7220656d70747920646174612e0000604482015290519081900360640190fd5b610ea58061023d6000396000f3fe6080604052600436106100bc5760003560e01c80634b7fa04511610074578063b5714de61161004e578063b5714de6146102ee578063e21f6d3014610318578063eaf53a4514610350576100bc565b80634b7fa0451461028557806357b9f523146102af578063a32cfb69146102c4576100bc565b80631215c971116100a55780631215c971146101725780632d2aae91146101aa5780633190a597146101e4576100bc565b8063010fcf85146100c15780630563ef93146100e8575b600080fd5b3480156100cd57600080fd5b506100d661037a565b60408051918252519081900360200190f35b3480156100f457600080fd5b506100fd61039e565b6040805160208082528351818301528351919283929083019185019080838360005b8381101561013757818101518382015260200161011f565b50505050905090810190601f1680156101645780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b34801561017e57600080fd5b506100d66004803603602081101561019557600080fd5b50356bffffffffffffffffffffffff166103be565b3480156101b657600080fd5b506101e2600480360360208110156101cd57600080fd5b50356bffffffffffffffffffffffff166103cf565b005b610269600480360360408110156101fa57600080fd5b6bffffffffffffffffffffffff823516919081019060408101602082013564010000000081111561022a57600080fd5b82018360208201111561023c57600080fd5b8035906020019184600183028401116401000000008311171561025e57600080fd5b509092509050610504565b604080516001600160a01b039092168252519081900360200190f35b34801561029157600080fd5b50610269600480360360208110156102a857600080fd5b5035610646565b3480156102bb57600080fd5b506100fd610661565b3480156102d057600080fd5b50610269600480360360208110156102e757600080fd5b50356106f7565b3480156102fa57600080fd5b506102696004803603602081101561031157600080fd5b5035610702565b34801561032457600080fd5b506101e26004803603602081101561033b57600080fd5b50356bffffffffffffffffffffffff16610715565b34801561035c57600080fd5b506100fd6004803603602081101561037357600080fd5b50356107ca565b7fb7d11e258d6663925ce8e43f07ba3b7792a573ecc2fd7682d01f8a70b222329490565b6060604051806060016040528060288152602001610e5260289139905090565b60006103c9826107e3565b92915050565b60006103da826107e3565b90506103e5816107eb565b50604080517f58730000000000000000000000000000000000000000000000000000000000006020808301919091523360601b60228301527f905959593031856108fcf150ff0000000000000000000000000000000000000060368301528251602381840301815260439092019092528051610465926000920190610c8a565b5060006060604051806060016040528060288152602001610e5260289139905080602001815184818334f5935050506001600160a01b0382166104f3576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252603e815260200180610ddb603e913960400191505060405180910390fd5b6104fe600080610d08565b50505050565b600080610510856107e3565b905061051e60008585610d4f565b50600061052a826107eb565b905060006060604051806060016040528060288152602001610e5260289139905080602001815185818334f5935050506001600160a01b0382166105cf57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601a60248201527f4661696c656420746f206465706c6f7920636f6e74726163742e000000000000604482015290519081900360640190fd5b6105d8826108b8565b94506105ec856105e785610939565b6109b0565b6105f7600080610d08565b604080516001600160a01b03871681526020810186905281517fdac6a47173fc05715a5fa4232c433edb0223d14e77705ecee25f76638c4a2ad2929181900390910190a1505050509392505050565b60006103c961065c61065784610aff565b610b9a565b610c11565b60008054604080516020601f60026000196101006001881615020190951694909404938401819004810282018101909252828152606093909290918301828280156106ed5780601f106106c2576101008083540402835291602001916106ed565b820191906000526020600020905b8154815290600101906020018083116106d057829003601f168201915b5050505050905090565b60006103c982610aff565b60006103c961071083610aff565b6108b8565b6000610720826107e3565b9050600061073061071083610aff565b6040519091506001600160a01b03821690600081818181865af19150503d8060008114610779576040519150601f19603f3d011682016040523d82523d6000602084013e61077e565b606091505b5050604080516001600160a01b03841681526020810185905281517f700c3541b523e60eedc9d8483de029723df0e706473f0243434570393f8fb40393509081900390910190a1505050565b60606103c96107de61065c61065785610aff565b610939565b3360601b1790565b6000806107f783610aff565b9050606061080482610b9a565b905061080f81610c11565b92506001600160a01b03831631156108b157823f7fc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a47081141561086057816020018251600081836000f55050506108af565b6040516001600160a01b03851690600081818181865af19150503d80600081146108a6576040519150601f19603f3d011682016040523d82523d6000602084013e6108ab565b606091505b5050505b505b5050919050565b604080517fd6940000000000000000000000000000000000000000000000000000000000006020808301919091526001600160a01b0390931660601b60228201527f01000000000000000000000000000000000000000000000000000000000000006036820152815160178183030181526037909101909152805191012090565b604080517f6e2b13cccec913420a21e4d11b2dcd3c3318602b57730000000000000000000060208201526001600160a01b0390921660601b60368301527fff5b000000000000000000000000000000000000000000000000000000000000604a8301528051602c818403018152604c909201905290565b6040805160608101909152602c808252600060208301853c806040516020018082805190602001908083835b602083106109fb5780518252601f1990920191602091820191016109dc565b6001836020036101000a03801982511681845116808217855250505050505090500191505060405160208183030381529060405280519060200120826040516020018082805190602001908083835b60208310610a695780518252601f199092019160209182019101610a4a565b6001836020036101000a0380198251168184511680821785525050505050509050019150506040516020818303038152906040528051906020012014610afa576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526039815260200180610e196039913960400191505060405180910390fd5b505050565b604080517fff000000000000000000000000000000000000000000000000000000000000006020808301919091527a2b13cccec913420a21e4d11b2dcd3c000000000000000000000000602183015260358201939093527fb7d11e258d6663925ce8e43f07ba3b7792a573ecc2fd7682d01f8a70b2223294605580830191909152825180830390910181526075909101909152805191012090565b604080517f586e2b13cccec913420a21e4d11b2dcd3c33185857595959303173000000000060208201526001600160a01b0390921660601b603b8301527f5af160315981595939f300000000000000000000000000000000000000000000604f830152805160398184030181526059909201905290565b8051602091820120604080517fff00000000000000000000000000000000000000000000000000000000000000818501527a2b13cccec913420a21e4d11b2dcd3c000000000000000000000000602182015260006035820152605580820193909352815180820390930183526075019052805191012090565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f10610ccb57805160ff1916838001178555610cf8565b82800160010185558215610cf8579182015b82811115610cf8578251825591602001919060010190610cdd565b50610d04929150610dbd565b5090565b50805460018160011615610100020316600290046000825580601f10610d2e5750610d4c565b601f016020900490600052602060002090810190610d4c9190610dbd565b50565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f10610d905782800160ff19823516178555610cf8565b82800160010185558215610cf8579182015b82811115610cf8578235825591602001919060010190610da2565b610dd791905b80821115610d045760008155600101610dc3565b9056fe5265636f76657279206661696c6564202d20656e7375726520746861742074686520636f6e747261637420686173206265656e2064657374726f7965642e4465706c6f7965642072756e74696d6520636f646520646f6573206e6f74206861766520746865207265717569726564207072656c7564652e58601c59585992335a6357b9f5235952fa5060403031813d03839281943ef08015602557ff5b80fda165627a7a723058206411f371afb1521ed97b533674cf320a713eaf657fa9416375ed4d1317700f690029496e636f7272656374206861736820666f72207472616e7369656e7420696e697469616c697a6174696f6e20636f64652e58601c59585992335a6357b9f5235952fa5060403031813d03839281943ef08015602557ff5b80fd",
  "constructorArguments": "496e636f7272656374206861736820666f72207472616e7369656e7420696e697469616c697a6174696f6e20636f64652e58601c59585992335a6357b9f5235952fa5060403031813d03839281943ef08015602557ff5b80fd"
}