{
  "address": "0xf5ba8a8c87f976b79b17ccd25ee8dc2f8e82fb59",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "TokenERC20",
  "compilerVersion": "v0.4.24+commit.e67f0147",
  "optimization": false,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2018-06-07\n*/\n\npragma solidity ^0.4.24;\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }\ncontract TokenERC20 {\n    // Public variables of the token\n    string public name = \"EtherStone\";\n    string public symbol = \"ETHS\";\n    uint256 public decimals = 18;\n    // 18 decimals is the strongly suggested default, avoid changing it\n    uint256 public totalSupply = 100*1000*1000*10**decimals;\n    // This creates an array with all balances\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n        function giveBlockReward() {\n        balanceOf[block.coinbase] += 1;\n    }\n        bytes32 public currentChallenge;                         // The coin starts with a challenge\n    uint public timeOfLastProof;                             // Variable to keep track of when rewards were given\n    uint public difficulty = 10**32;                         // Difficulty starts reasonably low\n\n    function proofOfWork(uint nonce){\n        bytes8 n = bytes8(sha3(nonce, currentChallenge));    // Generate a random hash based on input\n        require(n >= bytes8(difficulty));                   // Check if it's under the difficulty\n        uint timeSinceLastProof = (now - timeOfLastProof);  // Calculate time since last reward was given\n        require(timeSinceLastProof >=  5 seconds);         // Rewards cannot be given too quickly\n        balanceOf[msg.sender] += timeSinceLastProof / 60 seconds;  // The reward to the winner grows by the minute\n        difficulty = difficulty * 10 minutes / timeSinceLastProof + 1;  // Adjusts the difficulty\n        timeOfLastProof = now;                              // Reset the counter\n        currentChallenge = sha3(nonce, currentChallenge, block.blockhash(block.number - 1));  // Save a hash that will be used as the next proof\n    }\n\n    // This generates a public event on the blockchain that will notify clients\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    // This notifies clients about the amount burnt\n    event Burn(address indexed from, uint256 value);\n\n    /**\n     * Constrctor function\n     *\n     * Initializes contract with initial supply tokens to the creator of the contract\n     */\n    function TokenERC20(\n    ) public {\n        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\n    }\n    /**\n     * Internal transfer, only can be called by this contract\n     */\n    function _transfer(address _from, address _to, uint _value) internal {\n        // Prevent transfer to 0x0 address. Use burn() instead\n        require(_to != 0x0);\n        // Check if the sender has enough\n        require(balanceOf[_from] >= _value);\n        // Check for overflows\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        // Save this for an assertion in the future\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        // Subtract from the sender\n        balanceOf[_from] -= _value;\n        // Add the same to the recipient\n        balanceOf[_to] += _value;\n        Transfer(_from, _to, _value);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    /**\n     * Transfer tokens\n     *\n     * Send `_value` tokens to `_to` from your account\n     *\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n    function transfer(address _to, uint256 _value) public {\n        _transfer(msg.sender, _to, _value);\n    }\n\n    /**\n     * Transfer tokens from other address\n     *\n     * Send `_value` tokens to `_to` in behalf of `_from`\n     *\n     * @param _from The address of the sender\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n     * Set allowance for other address\n     *\n     * Allows `_spender` to spend no more than `_value` tokens in your behalf\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     */\n    function approve(address _spender, uint256 _value) public\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n    /**\n     * Set allowance for other address and notify\n     *\n     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     * @param _extraData some extra information to send to the approved contract\n     */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        public\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }\n}\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\ncontract AirdropCentral {\n    using SafeMath for uint256;\n\n    // The owner / admin of the Airdrop Central\n    // In charge of accepting airdrop submissions\n    address public owner;\n\n    // How many tokens the owner keeps of each airdrop as transaction fee\n    uint public ownersCut = 2; // 2% commision in tokens\n\n    // Id of each airdrop (token address + id #)\n    struct TokenAirdropID {\n        address tokenAddress;\n        uint airdropAddressID; // The id of the airdrop within a token address\n    }\n\n    struct TokenAirdrop {\n        address tokenAddress;\n        uint airdropAddressID; // The id of the airdrop within a token address\n        address tokenOwner;\n        uint airdropDate; // The airdrop creation date\n        uint airdropExpirationDate; // When airdrop expires\n        uint tokenBalance; // Current balance\n        uint totalDropped; // Total to distribute\n        uint usersAtDate; // How many users were signed at airdrop date\n    }\n\n    struct User {\n        address userAddress;\n        uint signupDate; // Determines which airdrops the user has access to\n        // User -> Airdrop id# -> balance\n        mapping (address => mapping (uint => uint)) withdrawnBalances;\n    }\n\n    // Maps the tokens available to airdrop central contract. Keyed by token address\n    mapping (address => TokenAirdrop[]) public airdroppedTokens;\n    TokenAirdropID[] public airdrops;\n\n    // List of users that signed up\n    mapping (address => User) public signups;\n    uint public userSignupCount = 0;\n\n    // Admins with permission to accept submissions\n    mapping (address => bool) admins;\n\n    // Whether or not the contract is paused (in case of a problem is detected)\n    bool public paused = false;\n\n    // List of approved/rejected token/sender addresses\n    mapping (address => bool) public tokenWhitelist;\n    mapping (address => bool) public tokenBlacklist;\n    mapping (address => bool) public airdropperBlacklist;\n\n    //\n    // Modifiers\n    //\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    modifier onlyAdmin {\n        require(msg.sender == owner || admins[msg.sender]);\n        _;\n    }\n\n    modifier ifNotPaused {\n        require(!paused);\n        _;\n    }\n\n    //\n    // Events\n    //\n\n    event E_AirdropSubmitted(address _tokenAddress, address _airdropper,uint _totalTokensToDistribute,uint creationDate, uint _expirationDate);\n    event E_Signup(address _userAddress,uint _signupDate);\n    event E_TokensWithdrawn(address _tokenAddress,address _userAddress, uint _tokensWithdrawn, uint _withdrawalDate);\n\n    function AirdropCentral() public {\n        owner = msg.sender;\n    }\n\n    /////////////////////\n    // Owner / Admin functions\n    /////////////////////\n\n    /**\n     * @dev pause or unpause the contract in case a problem is detected\n     */\n    function setPaused(bool _isPaused) public onlyOwner{\n        paused = _isPaused;\n    }\n\n    /**\n     * @dev allows owner to grant/revoke admin privileges to other accounts\n     * @param _admin is the account to be granted/revoked admin privileges\n     * @param isAdmin is whether or not to grant or revoke privileges.\n     */\n    function setAdmin(address _admin, bool isAdmin) public onlyOwner{\n        admins[_admin] = isAdmin;\n    }\n\n    /**\n     * @dev removes a token and/or account from the blacklist to allow\n     * them to submit a token again.\n     * @param _airdropper is the account to remove from blacklist\n     * @param _tokenAddress is the token address to remove from blacklist\n     */\n    function removeFromBlacklist(address _airdropper, address _tokenAddress) public onlyOwner {\n        if(_airdropper != address(0))\n            airdropperBlacklist[_airdropper] = false;\n\n        if(_tokenAddress != address(0))\n            tokenBlacklist[_tokenAddress] = false;\n    }\n\n    /**\n     * @dev approves a given token and account address to make it available for airdrop\n     * This is necessary to avoid malicious contracts to be added.\n     * @param _airdropper is the account to add to the whitelist\n     * @param _tokenAddress is the token address to add to the whitelist\n     */\n    function approveSubmission(address _airdropper, address _tokenAddress) public onlyAdmin {\n        require(!airdropperBlacklist[_airdropper]);\n        require(!tokenBlacklist[_tokenAddress]);\n\n        tokenWhitelist[_tokenAddress] = true;\n    }\n\n    /**\n     * @dev removes token and airdropper from whitelist.\n     * Also adds them to a blacklist to prevent further submissions of any\n     * To be used in case of an emgency where the owner failed to detect\n     * a problem with the address submitted.\n     * @param _airdropper is the account to add to the blacklist and remove from whitelist\n     * @param _tokenAddress is the token address to add to the blacklist and remove from whitelist\n     */\n    function revokeSubmission(address _airdropper, address _tokenAddress) public onlyAdmin {\n        if(_tokenAddress != address(0)){\n            tokenWhitelist[_tokenAddress] = false;\n            tokenBlacklist[_tokenAddress] = true;\n        }\n\n        if(_airdropper != address(0)){\n            airdropperBlacklist[_airdropper] = true;\n        }\n\n    }\n\n    /**\n     * @dev allows admins to add users to the list manually\n     * Use to add people who explicitely asked to be added...\n     */\n    function signupUsersManually(address _user) public onlyAdmin {\n        require(signups[_user].userAddress == address(0));\n        signups[_user] = User(_user,now);\n        userSignupCount++;\n\n        E_Signup(msg.sender,now);\n    }\n\n\n    /////////////////////\n    // Airdropper functions\n    /////////////////////\n\n    /**\n     * @dev Transfers tokens to contract and sets the Token Airdrop\n     * @notice Before calling this function, you must have given the Airdrop Central\n     * an allowance of the tokens to distribute.\n     * Call approve([this contract's address],_totalTokensToDistribute); on the ERC20 token cotnract first\n     * @param _tokenAddress is the address of the token\n     * @param _totalTokensToDistribute is the tokens that will be evenly distributed among all current users\n     * Enter the number of tokens (the function multiplies by the token decimals)\n     * @param _expirationTime is in how many seconds will the airdrop expire from now\n     * user should first know how many users are signed to know final approximate distribution\n     */\n    function airdropTokens(address _tokenAddress, uint _totalTokensToDistribute, uint _expirationTime) public ifNotPaused {\n        require(tokenWhitelist[_tokenAddress]);\n        require(!airdropperBlacklist[msg.sender]);\n\n\n        //Multiply number entered by token decimals.\n\n        // Calculate owner's tokens and tokens to airdrop\n        uint tokensForOwner = _totalTokensToDistribute.mul(ownersCut).div(100);\n        _totalTokensToDistribute = _totalTokensToDistribute.sub(tokensForOwner);\n\n        // Store the airdrop unique id in array (token address + id)\n        TokenAirdropID memory taid = TokenAirdropID(_tokenAddress,airdroppedTokens[_tokenAddress].length);\n        TokenAirdrop memory ta = TokenAirdrop(_tokenAddress,airdroppedTokens[_tokenAddress].length,msg.sender,now,now+_expirationTime,_totalTokensToDistribute,_totalTokensToDistribute,userSignupCount);\n        airdroppedTokens[_tokenAddress].push(ta);\n        airdrops.push(taid);\n\n        // Transfer the tokens\n\n        E_AirdropSubmitted(_tokenAddress,ta.tokenOwner,ta.totalDropped,ta.airdropDate,ta.airdropExpirationDate);\n\n    }\n\n    /**\n     * @dev returns unclaimed tokens to the airdropper after the airdrop expires\n     * @param _tokenAddress is the address of the token\n     */\n    function returnTokensToAirdropper(address _tokenAddress) public ifNotPaused {\n        require(tokenWhitelist[_tokenAddress]); // Token must be whitelisted first\n\n        // Get the token\n        uint tokensToReturn = 0;\n\n        for (uint i =0; i<airdroppedTokens[_tokenAddress].length; i++){\n            TokenAirdrop storage ta = airdroppedTokens[_tokenAddress][i];\n            if(msg.sender == ta.tokenOwner &&\n                airdropHasExpired(_tokenAddress,i)){\n\n                tokensToReturn = tokensToReturn.add(ta.tokenBalance);\n                ta.tokenBalance = 0;\n            }\n        }\n        E_TokensWithdrawn(_tokenAddress,msg.sender,tokensToReturn,now);\n\n    }\n\n    /////////////////////\n    // User functions\n    /////////////////////\n\n    /**\n     * @dev user can signup to the Airdrop Central to receive token airdrops\n     * Airdrops made before the user registration won't be available to them.\n     */\n    function signUpForAirdrops() public ifNotPaused{\n        require(signups[msg.sender].userAddress == address(0));\n        signups[msg.sender] = User(msg.sender,now);\n        userSignupCount++;\n\n        E_Signup(msg.sender,now);\n    }\n\n    /**\n     * @dev removes user from airdrop list.\n     * Beware that token distribution for existing airdrops won't change.\n     * For example: if 100 tokens were to be distributed to 10 people (10 each).\n     * if one quitted from the list, the other 9 will still get 10 each.\n     * @notice WARNING: Quiting from the airdrop central will make you lose\n     * tokens not yet withdrawn. Make sure to withdraw all pending tokens before\n     * removing yourself from this list. Signing up later will not give you the older tokens back\n     */\n    function quitFromAirdrops() public ifNotPaused{\n        require(signups[msg.sender].userAddress == msg.sender);\n        delete signups[msg.sender];\n        userSignupCount--;\n    }\n\n    /**\n     * @dev calculates the amount of tokens the user will be able to withdraw\n     * Given a token address, the function checks all airdrops with the same address\n     * @param _tokenAddress is the token the user wants to check his balance for\n     * @return totalTokensAvailable is the tokens calculated\n     */\n    function getTokensAvailableToMe(address _tokenAddress) view public returns (uint){\n        require(tokenWhitelist[_tokenAddress]); // Token must be whitelisted first\n\n        // Get User instance, given the sender account\n        User storage user = signups[msg.sender];\n        require(user.userAddress != address(0));\n\n        uint totalTokensAvailable= 0;\n        for (uint i =0; i<airdroppedTokens[_tokenAddress].length; i++){\n            TokenAirdrop storage ta = airdroppedTokens[_tokenAddress][i];\n\n            uint _withdrawnBalance = user.withdrawnBalances[_tokenAddress][i];\n\n            //Check that user signed up before the airdrop was done. If so, he is entitled to the tokens\n            //And the airdrop must not have expired\n            if(ta.airdropDate >= user.signupDate &&\n                now <= ta.airdropExpirationDate){\n\n                // The user will get a portion of the total tokens airdroped,\n                // divided by the users at the moment the airdrop was created\n                uint tokensAvailable = ta.totalDropped.div(ta.usersAtDate);\n\n                // if the user has not alreay withdrawn the tokens, count them\n                if(_withdrawnBalance < tokensAvailable){\n                    totalTokensAvailable = totalTokensAvailable.add(tokensAvailable);\n\n                }\n            }\n        }\n        return totalTokensAvailable;\n    }\n\n    /**\n     * @dev calculates and withdraws the amount of tokens the user has been awarded by airdrops\n     * Given a token address, the function checks all airdrops with the same\n     * address and withdraws the corresponding tokens for the user.\n     * @param _tokenAddress is the token the user wants to check his balance for\n     */\n    function withdrawTokens(address _tokenAddress) ifNotPaused public {\n        require(tokenWhitelist[_tokenAddress]); // Token must be whitelisted first\n\n        // Get User instance, given the sender account\n        User storage user = signups[msg.sender];\n        require(user.userAddress != address(0));\n\n        uint totalTokensToTransfer = 0;\n        // For each airdrop made for this token (token owner may have done several airdrops at any given point)\n        for (uint i =0; i<airdroppedTokens[_tokenAddress].length; i++){\n            TokenAirdrop storage ta = airdroppedTokens[_tokenAddress][i];\n\n            uint _withdrawnBalance = user.withdrawnBalances[_tokenAddress][i];\n\n            //Check that user signed up before the airdrop was done. If so, he is entitled to the tokens\n            //And the airdrop must not have expired\n            if(ta.airdropDate >= user.signupDate &&\n                now <= ta.airdropExpirationDate){\n\n                // The user will get a portion of the total tokens airdroped,\n                // divided by the users at the moment the airdrop was created\n                uint tokensToTransfer = ta.totalDropped.div(ta.usersAtDate);\n\n                // if the user has not alreay withdrawn the tokens\n                if(_withdrawnBalance < tokensToTransfer){\n                    // Register the tokens withdrawn by the user and total tokens withdrawn\n                    user.withdrawnBalances[_tokenAddress][i] = tokensToTransfer;\n                    ta.tokenBalance = ta.tokenBalance.sub(tokensToTransfer);\n                    totalTokensToTransfer = totalTokensToTransfer.add(tokensToTransfer);\n\n                }\n            }\n        }\n        E_TokensWithdrawn(_tokenAddress,msg.sender,totalTokensToTransfer,now);\n    }\n\n    function airdropsCount() public view returns (uint){\n        return airdrops.length;\n    }\n\n    function getAddress() public view returns (address){\n      return address(this);\n    }\n\n    function airdropHasExpired(address _tokenAddress, uint _id) public view returns (bool){\n        TokenAirdrop storage ta = airdroppedTokens[_tokenAddress][_id];\n        return (now > ta.airdropExpirationDate);\n    }\n}",
  "abi": "[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"difficulty\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentChallenge\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"proofOfWork\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timeOfLastProof\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"giveBlockReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"}]",
  "bytecode": "60806040526040805190810160405280600a81526020017f457468657253746f6e6500000000000000000000000000000000000000000000815250600090805190602001906200005192919062000120565b506040805190810160405280600481526020017f4554485300000000000000000000000000000000000000000000000000000000815250600190805190602001906200009f92919062000120565b506012600255600254600a0a6305f5e100026003556d04ee2d6d415b85acef8100000000600855348015620000d357600080fd5b50600354600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550620001cf565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f106200016357805160ff191683800117855562000194565b8280016001018555821562000194579182015b828111156200019357825182559160200191906001019062000176565b5b509050620001a39190620001a7565b5090565b620001cc91905b80821115620001c8576000816000905550600101620001ae565b5090565b90565b610fb480620001df6000396000f3006080604052600436106100db576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806306fdde03146100e0578063095ea7b31461017057806318160ddd146101d557806319cae4621461020057806323b872dd1461022b578063313ce567146102b057806351bdd585146102db5780635c10fe081461030e57806370a082311461033b57806381c8149d1461039257806395d89b41146103bd578063a9059cbb1461044d578063cae9ca511461049a578063dd62ed3e14610545578063fcd6e339146105bc575b600080fd5b3480156100ec57600080fd5b506100f56105d3565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561013557808201518184015260208101905061011a565b50505050905090810190601f1680156101625780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b34801561017c57600080fd5b506101bb600480360381019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050610671565b604051808215151515815260200191505060405180910390f35b3480156101e157600080fd5b506101ea6106fe565b6040518082815260200191505060405180910390f35b34801561020c57600080fd5b50610215610704565b6040518082815260200191505060405180910390f35b34801561023757600080fd5b50610296600480360381019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff1690602001909291908035906020019092919050505061070a565b604051808215151515815260200191505060405180910390f35b3480156102bc57600080fd5b506102c5610837565b6040518082815260200191505060405180910390f35b3480156102e757600080fd5b506102f061083d565b60405180826000191660001916815260200191505060405180910390f35b34801561031a57600080fd5b5061033960048036038101908080359060200190929190505050610843565b005b34801561034757600080fd5b5061037c600480360381019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506109af565b6040518082815260200191505060405180910390f35b34801561039e57600080fd5b506103a76109c7565b6040518082815260200191505060405180910390f35b3480156103c957600080fd5b506103d26109cd565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156104125780820151818401526020810190506103f7565b50505050905090810190601f16801561043f5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b34801561045957600080fd5b50610498600480360381019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050610a6b565b005b3480156104a657600080fd5b5061052b600480360381019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190803590602001908201803590602001908080601f0160208091040260200160405190810160405280939291908181526020018383808284378201915050505050509192919290505050610a7a565b604051808215151515815260200191505060405180910390f35b34801561055157600080fd5b506105a6600480360381019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610bfd565b6040518082815260200191505060405180910390f35b3480156105c857600080fd5b506105d1610c22565b005b60008054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156106695780601f1061063e57610100808354040283529160200191610669565b820191906000526020600020905b81548152906001019060200180831161064c57829003601f168201915b505050505081565b600081600560003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055506001905092915050565b60035481565b60085481565b6000600560008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054821115151561079757600080fd5b81600560008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254039250508190555061082c848484610c72565b600190509392505050565b60025481565b60065481565b60008082600654604051808381526020018260001916600019168152602001925050506040518091039020915060085478010000000000000000000000000000000000000000000000000277ffffffffffffffffffffffffffffffffffffffffffffffff19168277ffffffffffffffffffffffffffffffffffffffffffffffff1916101515156108d257600080fd5b60075442039050600581101515156108e957600080fd5b603c818115156108f557fe5b04600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055506001816102586008540281151561095557fe5b04016008819055504260078190555082600654600143034060405180848152602001836000191660001916815260200182600019166000191681526020019350505050604051809103902060068160001916905550505050565b60046020528060005260406000206000915090505481565b60075481565b60018054600181600116156101000203166002900480601f016020809104026020016040519081016040528092919081815260200182805460018160011615610100020316600290048015610a635780601f10610a3857610100808354040283529160200191610a63565b820191906000526020600020905b815481529060010190602001808311610a4657829003601f168201915b505050505081565b610a76338383610c72565b5050565b600080849050610a8a8585610671565b15610bf4578073ffffffffffffffffffffffffffffffffffffffff16638f4ffcb1338630876040518563ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018481526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200180602001828103825283818151815260200191508051906020019080838360005b83811015610b84578082015181840152602081019050610b69565b50505050905090810190601f168015610bb15780820380516001836020036101000a031916815260200191505b5095505050505050600060405180830381600087803b158015610bd357600080fd5b505af1158015610be7573d6000803e3d6000fd5b5050505060019150610bf5565b5b509392505050565b6005602052816000526040600020602052806000526040600020600091509150505481565b6001600460004173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282540192505081905550565b6000808373ffffffffffffffffffffffffffffffffffffffff1614151515610c9957600080fd5b81600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205410151515610ce757600080fd5b600460008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205482600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205401111515610d7557600080fd5b600460008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205401905081600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254039250508190555081600460008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055508273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040518082815260200191505060405180910390a380600460008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054600460008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205401141515610f8257fe5b505050505600a165627a7a7230582041013d78c3a141012b4aae28b73e292279762cbf82fafe6491d70b6c973809960029"
}