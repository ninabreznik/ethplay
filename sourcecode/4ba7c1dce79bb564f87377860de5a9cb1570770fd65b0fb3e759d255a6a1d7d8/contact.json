{
  "address": "0x3f6edd51a6ea3377bb52ece46df033b9215d61dc",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "StreamityTariff",
  "compilerVersion": "v0.4.25+commit.59dbf8f1",
  "optimization": false,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2018-12-03\n*/\n\npragma solidity ^0.4.18;\n\nlibrary SafeMath\n{\n    function mul(uint256 a, uint256 b) internal pure\n        returns (uint256)\n    {\n        uint256 c = a * b;\n\n        assert(a == 0 || c / a == b);\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure\n        returns (uint256)\n    {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure\n        returns (uint256)\n    {\n        assert(b <= a);\n\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b) internal pure\n        returns (uint256)\n    {\n        uint256 c = a + b;\n\n        assert(c >= a);\n\n        return c;\n    }\n}\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable\n{\n    address public owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    function Ownable() public {\n        owner = msg.sender;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n}\n\ninterface tokenRecipient\n{\n    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external;\n}\n\ncontract TokenERC20 is Ownable\n{\n    using SafeMath for uint;\n\n    // Public variables of the token\n    string public name;\n    string public symbol;\n    uint256 public decimals = 18;\n    uint256 DEC = 10 ** uint256(decimals);\n    uint256 public totalSupply;\n    uint256 public avaliableSupply;\n    uint256 public buyPrice = 1000000000000000000 wei;\n\n    // This creates an array with all balances\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    // This generates a public event on the blockchain that will notify clients\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Burn(address indexed from, uint256 value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    /**\n     * Constrctor function\n     *\n     * Initializes contract with initial supply tokens to the creator of the contract\n     */\n    function TokenERC20(\n        uint256 initialSupply,\n        string tokenName,\n        string tokenSymbol\n    ) public\n    {\n        totalSupply = initialSupply.mul(DEC);  // Update total supply with the decimal amount\n        balanceOf[this] = totalSupply;         // Give the creator all initial tokens\n        avaliableSupply = balanceOf[this];     // Show how much tokens on contract\n        name = tokenName;                      // Set the name for display purposes\n        symbol = tokenSymbol;                  // Set the symbol for display purposes\n    }\n\n    /**\n     * Internal transfer, only can be called by this contract\n     *\n     * @param _from - address of the contract\n     * @param _to - address of the investor\n     * @param _value - tokens for the investor\n     */\n    function _transfer(address _from, address _to, uint256 _value) internal\n    {\n        // Prevent transfer to 0x0 address. Use burn() instead\n        require(_to != 0x0);\n        // Check if the sender has enough\n        require(balanceOf[_from] >= _value);\n        // Check for overflows\n        require(balanceOf[_to].add(_value) > balanceOf[_to]);\n        // Save this for an assertion in the future\n        uint previousBalances = balanceOf[_from].add(balanceOf[_to]);\n        // Subtract from the sender\n        balanceOf[_from] = balanceOf[_from].sub(_value);\n        // Add the same to the recipient\n        balanceOf[_to] = balanceOf[_to].add(_value);\n\n        emit Transfer(_from, _to, _value);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(balanceOf[_from].add(balanceOf[_to]) == previousBalances);\n    }\n\n    /**\n     * Transfer tokens\n     *\n     * Send `_value` tokens to `_to` from your account\n     *\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n    function transfer(address _to, uint256 _value) public\n    {\n        _transfer(msg.sender, _to, _value);\n    }\n\n    /**\n     * Transfer tokens from other address\n     *\n     * Send `_value` tokens to `_to` in behalf of `_from`\n     *\n     * @param _from The address of the sender\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n    function transferFrom(address _from, address _to, uint256 _value) public\n        returns (bool success)\n    {\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n\n        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);\n        _transfer(_from, _to, _value);\n\n        return true;\n    }\n\n    /**\n     * Set allowance for other address\n     *\n     * Allows `_spender` to spend no more than `_value` tokens in your behalf\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     */\n    function approve(address _spender, uint256 _value) public\n        returns (bool success)\n    {\n        allowance[msg.sender][_spender] = _value;\n\n        return true;\n    }\n\n    /**\n     * Set allowance for other address and notify\n     *\n     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     * @param _extraData some extra information to send to the approved contract\n     */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public onlyOwner\n        returns (bool success)\n    {\n        tokenRecipient spender = tokenRecipient(_spender);\n\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n\n            return true;\n        }\n    }\n\n    /**\n     * approve should be called when allowed[_spender] == 0. To increment\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     */\n    function increaseApproval (address _spender, uint _addedValue) public\n        returns (bool success)\n    {\n        allowance[msg.sender][_spender] = allowance[msg.sender][_spender].add(_addedValue);\n\n        emit Approval(msg.sender, _spender, allowance[msg.sender][_spender]);\n\n        return true;\n    }\n\n    function decreaseApproval (address _spender, uint _subtractedValue) public\n        returns (bool success)\n    {\n        uint oldValue = allowance[msg.sender][_spender];\n\n        if (_subtractedValue > oldValue) {\n            allowance[msg.sender][_spender] = 0;\n        } else {\n            allowance[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n        }\n\n        emit Approval(msg.sender, _spender, allowance[msg.sender][_spender]);\n\n        return true;\n    }\n\n    /**\n     * Destroy tokens\n     *\n     * Remove `_value` tokens from the system irreversibly\n     *\n     * @param _value the amount of money to burn\n     */\n    function burn(uint256 _value) public onlyOwner\n        returns (bool success)\n    {\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n\n        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);  // Subtract from the sender\n        totalSupply = totalSupply.sub(_value);                      // Updates totalSupply\n        avaliableSupply = avaliableSupply.sub(_value);\n\n        emit Burn(msg.sender, _value);\n\n        return true;\n    }\n\n    /**\n     * Destroy tokens from other account\n     *\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n     *\n     * @param _from the address of the sender\n     * @param _value the amount of money to burn\n     */\n    function burnFrom(address _from, uint256 _value) public onlyOwner\n        returns (bool success)\n    {\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n\n        balanceOf[_from] = balanceOf[_from].sub(_value);    // Subtract from the targeted balance\n        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);    // Subtract from the sender's allowance\n        totalSupply = totalSupply.sub(_value);              // Update totalSupply\n        avaliableSupply = avaliableSupply.sub(_value);\n\n        emit Burn(_from, _value);\n\n        return true;\n    }\n}\n\n\n/**\n * @title Eliptic curve signature operations\n *\n * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\n */\n\nlibrary ECRecovery {\n\n  /**\n   * @dev Recover signer address from a message by using his signature\n   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\n   * @param sig bytes signature, the signature is generated using web3.eth.sign()\n   */\n  function recover(bytes32 hash, bytes sig) public pure returns (address) {\n    bytes32 r;\n    bytes32 s;\n    uint8 v;\n\n    //Check the signature length\n    if (sig.length != 65) {\n      return (address(0));\n    }\n\n    // Divide the signature in r, s and v variables\n    assembly {\n      r := mload(add(sig, 32))\n      s := mload(add(sig, 64))\n      v := byte(0, mload(add(sig, 96)))\n    }\n\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n    if (v < 27) {\n      v += 27;\n    }\n\n    // If the version is correct return the signer address\n    if (v != 27 && v != 28) {\n      return (address(0));\n    } else {\n      return ecrecover(hash, v, r, s);\n    }\n  }\n\n}\n\ncontract StreamityTariff is Ownable {\n    using ECRecovery for bytes32;\n    \n    uint8 constant public EMPTY = 0x0;\n\n    TokenERC20 public streamityContractAddress;\n\n    mapping(bytes32 => Deal) public streamityTransfers;\n\n    function StreamityTariff(address streamityContract) public {\n        require(streamityContract != 0x0);\n        streamityContractAddress = TokenERC20(streamityContract);\n    }\n\n    struct Deal {\n        uint256 value;\n    }\n\n    event BuyTariff(bytes32 _hashDeal);\n\n    function payAltCoin(bytes32 _tradeID, uint256 _value, bytes _sign) \n    external \n    {\n        bytes32 _hashDeal = keccak256(_tradeID, _value);\n        verifyDeal(_hashDeal, _sign);\n        bool result = streamityContractAddress.transferFrom(msg.sender, address(this), _value);\n        require(result == true);\n        startDeal(_hashDeal, _value);\n    }\n\n    function verifyDeal(bytes32 _hashDeal, bytes _sign) private view {\n        require(_hashDeal.recover(_sign) == owner);\n        require(streamityTransfers[_hashDeal].value == EMPTY); \n    }\n\n    function startDeal(bytes32 _hashDeal, uint256 _value) \n    private returns(bytes32) \n    {\n        Deal storage userDeals = streamityTransfers[_hashDeal];\n        userDeals.value = _value; \n        emit BuyTariff(_hashDeal);\n        \n        return _hashDeal;\n    }\n\n    function withdrawCommisionToAddressAltCoin(address _to, uint256 _amount) external onlyOwner {\n        streamityContractAddress.transfer(_to, _amount);\n    }\n\n    function setStreamityContractAddress(address newAddress) \n    external onlyOwner \n    {\n        streamityContractAddress = TokenERC20(newAddress);\n    }\n}",
  "abi": "[{\"constant\":true,\"inputs\":[],\"name\":\"EMPTY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"streamityContractAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"streamityTransfers\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawCommisionToAddressAltCoin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setStreamityContractAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeID\",\"type\":\"bytes32\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_sign\",\"type\":\"bytes\"}],\"name\":\"payAltCoin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"streamityContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_hashDeal\",\"type\":\"bytes32\"}],\"name\":\"BuyTariff\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]",
  "bytecode": "608060405234801561001057600080fd5b50604051602080610b7583398101806040528101908080519060200190929190505050336000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060008173ffffffffffffffffffffffffffffffffffffffff161415151561009957600080fd5b80600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050610a8b806100ea6000396000f30060806040526004361061008e576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806302399125146100935780634f1fa7ef146100c457806353122f561461011b5780638b845c1d146101605780638da5cb5b146101ad578063b0dbce7114610204578063f2fde38b14610247578063f7b8a6001461028a575b600080fd5b34801561009f57600080fd5b506100a86102dd565b604051808260ff1660ff16815260200191505060405180910390f35b3480156100d057600080fd5b506100d96102e2565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b34801561012757600080fd5b5061014a6004803603810190808035600019169060200190929190505050610308565b6040518082815260200191505060405180910390f35b34801561016c57600080fd5b506101ab600480360381019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050610326565b005b3480156101b957600080fd5b506101c2610462565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b34801561021057600080fd5b50610245600480360381019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610487565b005b34801561025357600080fd5b50610288600480360381019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610526565b005b34801561029657600080fd5b506102db60048036038101908080356000191690602001909291908035906020019092919080359060200190820180359060200191909192939192939050505061067b565b005b600081565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b60026020528060005260406000206000915090508060000154905081565b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614151561038157600080fd5b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb83836040518363ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200182815260200192505050600060405180830381600087803b15801561044657600080fd5b505af115801561045a573d6000803e3d6000fd5b505050505050565b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415156104e257600080fd5b80600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614151561058157600080fd5b600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16141515156105bd57600080fd5b8073ffffffffffffffffffffffffffffffffffffffff166000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a3806000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b600080858560405180836000191660001916815260200182815260200192505050604051809103902091506106e28285858080601f01602080910402602001604051908101604052809392919081815260200183838082843782019150505050505061083e565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd3330886040518463ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018281526020019350505050602060405180830381600087803b1580156107db57600080fd5b505af11580156107ef573d6000803e3d6000fd5b505050506040513d602081101561080557600080fd5b810190808051906020019092919050505090506001151581151514151561082b57600080fd5b61083582866109ed565b50505050505050565b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16826000191673b07e22f5f0810563c47307bb171f9d00817868136319045a259091846040518363ffffffff167c010000000000000000000000000000000000000000000000000000000002815260040180836000191660001916815260200180602001828103825283818151815260200191508051906020019080838360005b838110156109115780820151818401526020810190506108f6565b50505050905090810190601f16801561093e5780820380516001836020036101000a031916815260200191505b50935050505060206040518083038186803b15801561095c57600080fd5b505af4158015610970573d6000803e3d6000fd5b505050506040513d602081101561098657600080fd5b810190808051906020019092919050505073ffffffffffffffffffffffffffffffffffffffff161415156109b957600080fd5b600060ff16600260008460001916600019168152602001908152602001600020600001541415156109e957600080fd5b5050565b60008060026000856000191660001916815260200190815260200160002090508281600001819055507fb3db26290887337d62ad02e84f9f27a55fc389bae19b4922721f6c587dbf78288460405180826000191660001916815260200191505060405180910390a183915050929150505600a165627a7a723058207f56ae68830c695ac98f7cad23d27f50cb2ab763b295b68c681e4cfc2ba80ea80029000000000000000000000000611171923b84185e9328827cfaae6630481ecc7a",
  "constructorArguments": "000000000000000000000000611171923b84185e9328827cfaae6630481ecc7a",
  "libraries": [
    {
      "name": "ECRecovery",
      "address": "0xB07e22f5f0810563C47307bb171F9d0081786813"
    }
  ]
}