{
  "address": "0xeeabcb509e0a2c9f52efd7d788b86a4ea8a095b1",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "PriceOracleInterface",
  "compilerVersion": "v0.5.2+commit.1df8f40c",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2019-05-06\n*/\n\n// File: contracts/Oracle/DSMath.sol\n\npragma solidity ^0.5.2;\n\n\ncontract DSMath {\n    /*\n    standard uint256 functions\n     */\n\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assert((z = x + y) >= x);\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assert((z = x - y) <= x);\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assert((z = x * y) >= x);\n    }\n\n    function div(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x / y;\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x <= y ? x : y;\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x >= y ? x : y;\n    }\n\n    /*\n    uint128 functions (h is for half)\n     */\n\n    function hadd(uint128 x, uint128 y) internal pure returns (uint128 z) {\n        assert((z = x + y) >= x);\n    }\n\n    function hsub(uint128 x, uint128 y) internal pure returns (uint128 z) {\n        assert((z = x - y) <= x);\n    }\n\n    function hmul(uint128 x, uint128 y) internal pure returns (uint128 z) {\n        assert((z = x * y) >= x);\n    }\n\n    function hdiv(uint128 x, uint128 y) internal pure returns (uint128 z) {\n        z = x / y;\n    }\n\n    function hmin(uint128 x, uint128 y) internal pure returns (uint128 z) {\n        return x <= y ? x : y;\n    }\n\n    function hmax(uint128 x, uint128 y) internal pure returns (uint128 z) {\n        return x >= y ? x : y;\n    }\n\n    /*\n    int256 functions\n     */\n\n    function imin(int256 x, int256 y) internal pure returns (int256 z) {\n        return x <= y ? x : y;\n    }\n\n    function imax(int256 x, int256 y) internal pure returns (int256 z) {\n        return x >= y ? x : y;\n    }\n\n    /*\n    WAD math\n     */\n\n    uint128 constant WAD = 10 ** 18;\n\n    function wadd(uint128 x, uint128 y) internal pure returns (uint128) {\n        return hadd(x, y);\n    }\n\n    function wsub(uint128 x, uint128 y) internal pure returns (uint128) {\n        return hsub(x, y);\n    }\n\n    function wmul(uint128 x, uint128 y) internal pure returns (uint128 z) {\n        z = cast((uint256(x) * y + WAD / 2) / WAD);\n    }\n\n    function wdiv(uint128 x, uint128 y) internal pure returns (uint128 z) {\n        z = cast((uint256(x) * WAD + y / 2) / y);\n    }\n\n    function wmin(uint128 x, uint128 y) internal pure returns (uint128) {\n        return hmin(x, y);\n    }\n\n    function wmax(uint128 x, uint128 y) internal pure returns (uint128) {\n        return hmax(x, y);\n    }\n\n    /*\n    RAY math\n     */\n\n    uint128 constant RAY = 10 ** 27;\n\n    function radd(uint128 x, uint128 y) internal pure returns (uint128) {\n        return hadd(x, y);\n    }\n\n    function rsub(uint128 x, uint128 y) internal pure returns (uint128) {\n        return hsub(x, y);\n    }\n\n    function rmul(uint128 x, uint128 y) internal pure returns (uint128 z) {\n        z = cast((uint256(x) * y + RAY / 2) / RAY);\n    }\n\n    function rdiv(uint128 x, uint128 y) internal pure returns (uint128 z) {\n        z = cast((uint256(x) * RAY + y / 2) / y);\n    }\n\n    function rpow(uint128 x, uint64 n) internal pure returns (uint128 z) {\n        // This famous algorithm is called \"exponentiation by squaring\"\n        // and calculates x^n with x as fixed-point and n as regular unsigned.\n        //\n        // It's O(log n), instead of O(n) for naive repeated multiplication.\n        //\n        // These facts are why it works:\n        //\n        //  If n is even, then x^n = (x^2)^(n/2).\n        //  If n is odd,  then x^n = x * x^(n-1),\n        //   and applying the equation for even x gives\n        //    x^n = x * (x^2)^((n-1) / 2).\n        //\n        //  Also, EVM division is flooring and\n        //    floor[(n-1) / 2] = floor[n / 2].\n\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n\n    function rmin(uint128 x, uint128 y) internal pure returns (uint128) {\n        return hmin(x, y);\n    }\n\n    function rmax(uint128 x, uint128 y) internal pure returns (uint128) {\n        return hmax(x, y);\n    }\n\n    function cast(uint256 x) internal pure returns (uint128 z) {\n        assert((z = uint128(x)) == x);\n    }\n\n}\n\n// File: contracts/Oracle/DSAuth.sol\n\npragma solidity ^0.5.2;\n\n\ncontract DSAuthority {\n    function canCall(address src, address dst, bytes4 sig) public view returns (bool);\n}\n\n\ncontract DSAuthEvents {\n    event LogSetAuthority(address indexed authority);\n    event LogSetOwner(address indexed owner);\n}\n\n\ncontract DSAuth is DSAuthEvents {\n    DSAuthority public authority;\n    address public owner;\n\n    constructor() public {\n        owner = msg.sender;\n        emit LogSetOwner(msg.sender);\n    }\n\n    function setOwner(address owner_) public auth {\n        owner = owner_;\n        emit LogSetOwner(owner);\n    }\n\n    function setAuthority(DSAuthority authority_) public auth {\n        authority = authority_;\n        emit LogSetAuthority(address(authority));\n    }\n\n    modifier auth {\n        require(isAuthorized(msg.sender, msg.sig), \"It must be an authorized call\");\n        _;\n    }\n\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else if (authority == DSAuthority(0)) {\n            return false;\n        } else {\n            return authority.canCall(src, address(this), sig);\n        }\n    }\n}\n\n// File: contracts/Oracle/DSNote.sol\n\npragma solidity ^0.5.2;\n\n\ncontract DSNote {\n    event LogNote(\n        bytes4 indexed sig,\n        address indexed guy,\n        bytes32 indexed foo,\n        bytes32 bar,\n        uint wad,\n        bytes fax\n    );\n\n    modifier note {\n        bytes32 foo;\n        bytes32 bar;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            foo := calldataload(4)\n            bar := calldataload(36)\n        }\n\n        emit LogNote(\n            msg.sig,\n            msg.sender,\n            foo,\n            bar,\n            msg.value,\n            msg.data\n        );\n\n        _;\n    }\n}\n\n// File: contracts/Oracle/DSThing.sol\n\npragma solidity ^0.5.2;\n\n\n\n\n\ncontract DSThing is DSAuth, DSNote, DSMath {}\n\n// File: contracts/Oracle/PriceFeed.sol\n\npragma solidity ^0.5.2;\n/// price-feed.sol\n\n// Copyright (C) 2017  DappHub, LLC\n\n// Licensed under the Apache License, Version 2.0 (the \"License\").\n// You may not use this file except in compliance with the License.\n\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND (express or implied).\n\n\n\ncontract PriceFeed is DSThing {\n    uint128 val;\n    uint32 public zzz;\n\n    function peek() public view returns (bytes32, bool) {\n        return (bytes32(uint256(val)), block.timestamp < zzz);\n    }\n\n    function read() public view returns (bytes32) {\n        assert(block.timestamp < zzz);\n        return bytes32(uint256(val));\n    }\n\n    function post(uint128 val_, uint32 zzz_, address med_) public payable note auth {\n        val = val_;\n        zzz = zzz_;\n        (bool success, ) = med_.call(abi.encodeWithSignature(\"poke()\"));\n        require(success, \"The poke must succeed\");\n    }\n\n    function void() public payable note auth {\n        zzz = 0;\n    }\n\n}\n\n// File: contracts/Oracle/DSValue.sol\n\npragma solidity ^0.5.2;\n\n\n\ncontract DSValue is DSThing {\n    bool has;\n    bytes32 val;\n    function peek() public view returns (bytes32, bool) {\n        return (val, has);\n    }\n\n    function read() public view returns (bytes32) {\n        (bytes32 wut, bool _has) = peek();\n        assert(_has);\n        return wut;\n    }\n\n    function poke(bytes32 wut) public payable note auth {\n        val = wut;\n        has = true;\n    }\n\n    function void() public payable note auth {\n        // unset the value\n        has = false;\n    }\n}\n\n// File: contracts/Oracle/Medianizer.sol\n\npragma solidity ^0.5.2;\n\n\n\ncontract Medianizer is DSValue {\n    mapping(bytes12 => address) public values;\n    mapping(address => bytes12) public indexes;\n    bytes12 public next = bytes12(uint96(1));\n    uint96 public minimun = 0x1;\n\n    function set(address wat) public auth {\n        bytes12 nextId = bytes12(uint96(next) + 1);\n        assert(nextId != 0x0);\n        set(next, wat);\n        next = nextId;\n    }\n\n    function set(bytes12 pos, address wat) public payable note auth {\n        require(pos != 0x0, \"pos cannot be 0x0\");\n        require(wat == address(0) || indexes[wat] == 0, \"wat is not defined or it has an index\");\n\n        indexes[values[pos]] = bytes12(0); // Making sure to remove a possible existing address in that position\n\n        if (wat != address(0)) {\n            indexes[wat] = pos;\n        }\n\n        values[pos] = wat;\n    }\n\n    function setMin(uint96 min_) public payable note auth {\n        require(min_ != 0x0, \"min cannot be 0x0\");\n        minimun = min_;\n    }\n\n    function setNext(bytes12 next_) public payable note auth {\n        require(next_ != 0x0, \"next cannot be 0x0\");\n        next = next_;\n    }\n\n    function unset(bytes12 pos) public {\n        set(pos, address(0));\n    }\n\n    function unset(address wat) public {\n        set(indexes[wat], address(0));\n    }\n\n    function poke() public {\n        poke(0);\n    }\n\n    function poke(bytes32) public payable note {\n        (val, has) = compute();\n    }\n\n    function compute() public view returns (bytes32, bool) {\n        bytes32[] memory wuts = new bytes32[](uint96(next) - 1);\n        uint96 ctr = 0;\n        for (uint96 i = 1; i < uint96(next); i++) {\n            if (values[bytes12(i)] != address(0)) {\n                (bytes32 wut, bool wuz) = DSValue(values[bytes12(i)]).peek();\n                if (wuz) {\n                    if (ctr == 0 || wut >= wuts[ctr - 1]) {\n                        wuts[ctr] = wut;\n                    } else {\n                        uint96 j = 0;\n                        while (wut >= wuts[j]) {\n                            j++;\n                        }\n                        for (uint96 k = ctr; k > j; k--) {\n                            wuts[k] = wuts[k - 1];\n                        }\n                        wuts[j] = wut;\n                    }\n                    ctr++;\n                }\n            }\n        }\n\n        if (ctr < minimun)\n            return (val, false);\n\n        bytes32 value;\n        if (ctr % 2 == 0) {\n            uint128 val1 = uint128(uint(wuts[(ctr / 2) - 1]));\n            uint128 val2 = uint128(uint(wuts[ctr / 2]));\n            value = bytes32(uint256(wdiv(hadd(val1, val2), 2 ether)));\n        } else {\n            value = wuts[(ctr - 1) / 2];\n        }\n\n        return (value, true);\n    }\n}\n\n// File: contracts/Oracle/PriceOracleInterface.sol\n\npragma solidity ^0.5.2;\n\n/*\nThis contract is the interface between the MakerDAO priceFeed and our DX platform.\n*/\n\n\n\n\ncontract PriceOracleInterface {\n    address public priceFeedSource;\n    address public owner;\n    bool public emergencyMode;\n\n    // Modifiers\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only the owner can do the operation\");\n        _;\n    }\n\n    /// @dev constructor of the contract\n    /// @param _priceFeedSource address of price Feed Source -> should be maker feeds Medianizer contract\n    constructor(address _owner, address _priceFeedSource) public {\n        owner = _owner;\n        priceFeedSource = _priceFeedSource;\n    }\n    \n    /// @dev gives the owner the possibility to put the Interface into an emergencyMode, which will\n    /// output always a price of 600 USD. This gives everyone time to set up a new pricefeed.\n    function raiseEmergency(bool _emergencyMode) public onlyOwner {\n        emergencyMode = _emergencyMode;\n    }\n\n    /// @dev updates the priceFeedSource\n    /// @param _owner address of owner\n    function updateCurator(address _owner) public onlyOwner {\n        owner = _owner;\n    }\n\n    /// @dev returns the USDETH price\n    function getUsdEthPricePeek() public view returns (bytes32 price, bool valid) {\n        return Medianizer(priceFeedSource).peek();\n    }\n\n    /// @dev returns the USDETH price, ie gets the USD price from Maker feed with 18 digits, but last 18 digits are cut off\n    function getUSDETHPrice() public view returns (uint256) {\n        // if the contract is in the emergencyMode, because there is an issue with the oracle, we will simply return a price of 600 USD\n        if (emergencyMode) {\n            return 600;\n        }\n        (bytes32 price, ) = Medianizer(priceFeedSource).peek();\n\n        // ensuring that there is no underflow or overflow possible,\n        // even if the price is compromised\n        uint priceUint = uint256(price)/(1 ether);\n        if (priceUint == 0) {\n            return 1;\n        }\n        if (priceUint > 1000000) {\n            return 1000000; \n        }\n        return priceUint;\n    }\n}",
  "bytecode": "608060405234801561001057600080fd5b5060405160408061052e8339810180604052604081101561003057600080fd5b50805160209091015160018054600160a060020a03938416600160a060020a031991821617909155600080549390921692169190911790556104b7806100776000396000f3fe608060405234801561001057600080fd5b506004361061009a576000357c0100000000000000000000000000000000000000000000000000000000900480638da5cb5b116100785780638da5cb5b146101045780639e385fa414610128578063a3ca17b214610147578063c5ace443146101615761009a565b80630905f5601461009f5780630c6a62dd146100bb5780630c8fe9db146100e3575b600080fd5b6100a7610169565b604080519115158252519081900360200190f35b6100e1600480360360208110156100d157600080fd5b5035600160a060020a031661018a565b005b6100eb61021c565b6040805192835290151560208301528051918290030190f35b61010c6102b2565b60408051600160a060020a039092168252519081900360200190f35b6100e16004803603602081101561013e57600080fd5b503515156102c1565b61014f610364565b60408051918252519081900360200190f35b61010c610459565b60015474010000000000000000000000000000000000000000900460ff1681565b600154600160a060020a031633146101ed576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260238152602001806104696023913960400191505060405180910390fd5b6001805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b60008054604080517f59e02dd700000000000000000000000000000000000000000000000000000000815281518493600160a060020a0316926359e02dd79260048082019391829003018186803b15801561027657600080fd5b505afa15801561028a573d6000803e3d6000fd5b505050506040513d60408110156102a057600080fd5b50805160209091015190925090509091565b600154600160a060020a031681565b600154600160a060020a03163314610324576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260238152602001806104696023913960400191505060405180910390fd5b60018054911515740100000000000000000000000000000000000000000274ff000000000000000000000000000000000000000019909216919091179055565b60015460009074010000000000000000000000000000000000000000900460ff16156103935750610258610456565b60008054604080517f59e02dd70000000000000000000000000000000000000000000000000000000081528151600160a060020a03909316926359e02dd792600480840193919291829003018186803b1580156103ef57600080fd5b505afa158015610403573d6000803e3d6000fd5b505050506040513d604081101561041957600080fd5b50519050670de0b6b3a7640000810480151561043a57600192505050610456565b620f424081111561045257620f424092505050610456565b9150505b90565b600054600160a060020a03168156fe4f6e6c7920746865206f776e65722063616e20646f20746865206f7065726174696f6ea165627a7a72305820f8cd4b58f4f3e3098c84b71d160e3d8d65980184cbc47188718bb9c551103e1e00290000000000000000000000000ddc793680ff4f5793849c8c6992be1695cbe72a000000000000000000000000729d19f657bd0614b4985cf1d82531c67569197b",
  "constructorArguments": "0000000000000000000000000ddc793680ff4f5793849c8c6992be1695cbe72a000000000000000000000000729d19f657bd0614b4985cf1d82531c67569197b"
}