{
  "address": "0x51ffc1b089392a5bb65bf24eaf04d07d0e6f88b5",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "ProfitContainer",
  "compilerVersion": "v0.4.6+commit.2dabbdf0",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2017-01-03\n*/\n\npragma solidity ^0.4.0;\n/*\nThis vSlice token contract is based on the ERC20 token contract. Additional\nfunctionality has been integrated:\n* the contract Lockable, which is used as a parent of the Token contract\n* the function mintTokens(), which makes use of the currentSwapRate() and safeToAdd() helpers\n* the function disableTokenSwapLock()\n*/\n\ncontract Lockable {\n    uint public numOfCurrentEpoch;\n    uint public creationTime;\n    uint public constant UNLOCKED_TIME = 25 days;\n    uint public constant LOCKED_TIME = 5 days;\n    uint public constant EPOCH_LENGTH = 30 days;\n    bool public lock;\n    bool public tokenSwapLock;\n\n    event Locked();\n    event Unlocked();\n\n    // This modifier should prevent tokens transfers while the tokenswap\n    // is still ongoing\n    modifier isTokenSwapOn {\n        if (tokenSwapLock) throw;\n        _;\n    }\n\n    // This modifier checks and, if needed, updates the value of current\n    // token contract epoch, before executing a token transfer of any\n    // kind\n    modifier isNewEpoch {\n        if (numOfCurrentEpoch * EPOCH_LENGTH + creationTime < now ) {\n            numOfCurrentEpoch = (now - creationTime) / EPOCH_LENGTH + 1;\n        }\n        _;\n    }\n\n    // This modifier check whether the contract should be in a locked\n    // or unlocked state, then acts and updates accordingly if\n    // necessary\n    modifier checkLock {\n        if ((creationTime + numOfCurrentEpoch * UNLOCKED_TIME) +\n        (numOfCurrentEpoch - 1) * LOCKED_TIME < now) {\n            // avoids needless lock state change and event spamming\n            if (lock) throw;\n\n            lock = true;\n            Locked();\n            return;\n        }\n        else {\n            // only set to false if in a locked state, to avoid\n            // needless state change and event spam\n            if (lock) {\n                lock = false;\n                Unlocked();\n            }\n        }\n        _;\n    }\n\n    function Lockable() {\n        creationTime = now;\n        numOfCurrentEpoch = 1;\n        tokenSwapLock = true;\n    }\n}\n\n\ncontract ERC20 {\n    function totalSupply() constant returns (uint);\n    function balanceOf(address who) constant returns (uint);\n    function allowance(address owner, address spender) constant returns (uint);\n\n    function transfer(address to, uint value) returns (bool ok);\n    function transferFrom(address from, address to, uint value) returns (bool ok);\n    function approve(address spender, uint value) returns (bool ok);\n\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract Token is ERC20, Lockable {\n\n  mapping( address => uint ) _balances;\n  mapping( address => mapping( address => uint ) ) _approvals;\n  uint _supply;\n  address public walletAddress;\n\n  event TokenMint(address newTokenHolder, uint amountOfTokens);\n  event TokenSwapOver();\n\n  modifier onlyFromWallet {\n      if (msg.sender != walletAddress) throw;\n      _;\n  }\n\n  function Token( uint initial_balance, address wallet) {\n    _balances[msg.sender] = initial_balance;\n    _supply = initial_balance;\n    walletAddress = wallet;\n  }\n\n  function totalSupply() constant returns (uint supply) {\n    return _supply;\n  }\n\n  function balanceOf( address who ) constant returns (uint value) {\n    return _balances[who];\n  }\n\n  function allowance(address owner, address spender) constant returns (uint _allowance) {\n    return _approvals[owner][spender];\n  }\n\n  // A helper to notify if overflow occurs\n  function safeToAdd(uint a, uint b) internal returns (bool) {\n    return (a + b >= a && a + b >= b);\n  }\n\n  function transfer( address to, uint value)\n    isTokenSwapOn\n    isNewEpoch\n    checkLock\n    returns (bool ok) {\n\n    if( _balances[msg.sender] < value ) {\n        throw;\n    }\n    if( !safeToAdd(_balances[to], value) ) {\n        throw;\n    }\n\n    _balances[msg.sender] -= value;\n    _balances[to] += value;\n    Transfer( msg.sender, to, value );\n    return true;\n  }\n\n  function transferFrom( address from, address to, uint value)\n    isTokenSwapOn\n    isNewEpoch\n    checkLock\n    returns (bool ok) {\n    // if you don't have enough balance, throw\n    if( _balances[from] < value ) {\n        throw;\n    }\n    // if you don't have approval, throw\n    if( _approvals[from][msg.sender] < value ) {\n        throw;\n    }\n    if( !safeToAdd(_balances[to], value) ) {\n        throw;\n    }\n    // transfer and return true\n    _approvals[from][msg.sender] -= value;\n    _balances[from] -= value;\n    _balances[to] += value;\n    Transfer( from, to, value );\n    return true;\n  }\n\n  function approve(address spender, uint value)\n    isTokenSwapOn\n    isNewEpoch\n    checkLock\n    returns (bool ok) {\n    _approvals[msg.sender][spender] = value;\n    Approval( msg.sender, spender, value );\n    return true;\n  }\n\n  // The function currentSwapRate() returns the current exchange rate\n  // between vSlice tokens and Ether during the token swap period\n  function currentSwapRate() constant returns(uint) {\n      if (creationTime + 1 weeks > now) {\n          return 130;\n      }\n      else if (creationTime + 2 weeks > now) {\n          return 120;\n      }\n      else if (creationTime + 4 weeks > now) {\n          return 100;\n      }\n      else {\n          return 0;\n      }\n  }\n\n  // The function mintTokens is only usable by the chosen wallet\n  // contract to mint a number of tokens proportional to the\n  // amount of ether sent to the wallet contract. The function\n  // can only be called during the tokenswap period\n  function mintTokens(address newTokenHolder, uint etherAmount)\n    external\n    onlyFromWallet {\n\n        uint tokensAmount = currentSwapRate() * etherAmount;\n        if(!safeToAdd(_balances[newTokenHolder],tokensAmount )) throw;\n        if(!safeToAdd(_supply,tokensAmount)) throw;\n\n        _balances[newTokenHolder] += tokensAmount;\n        _supply += tokensAmount;\n\n        TokenMint(newTokenHolder, tokensAmount);\n  }\n\n  // The function disableTokenSwapLock() is called by the wallet\n  // contract once the token swap has reached its end conditions\n  function disableTokenSwapLock()\n    external\n    onlyFromWallet {\n        tokenSwapLock = false;\n        TokenSwapOver();\n  }\n}\n\n\npragma solidity ^0.4.0;\n/*\nThe ProfitContainer contract receives profits from the vDice games and allows a\na fair distribution between token holders.\n*/\n\ncontract Ownable {\n  address public owner;\n\n  function Ownable() {\n    owner = msg.sender;\n  }\n\n  modifier onlyOwner() {\n    if (msg.sender == owner)\n      _;\n  }\n\n  function transferOwnership(address _newOwner)\n      external\n      onlyOwner {\n      if (_newOwner == address(0x0)) throw;\n      owner = _newOwner;\n  }\n\n}\n\ncontract ProfitContainer is Ownable {\n    uint public currentEpoch;\n    //This is to mitigate supersend and the possibility of\n    //different payouts for same token ownership during payout phase\n    uint public initEpochBalance;\n    mapping (address => uint) lastPaidOutEpoch;\n    Token public tokenCtr;\n\n    event WithdrawalEnabled();\n    event ProfitWithdrawn(address tokenHolder, uint amountPaidOut);\n    event TokenContractChanged(address newTokenContractAddr);\n\n    // The modifier onlyNotPaidOut prevents token holders who have\n    // already withdrawn their share of profits in the epoch, to cash\n    // out additional shares.\n    modifier onlyNotPaidOut {\n        if (lastPaidOutEpoch[msg.sender] == currentEpoch) throw;\n        _;\n    }\n\n    // The modifier onlyLocked prevents token holders from collecting\n    // their profits when the token contract is in an unlocked state\n    modifier onlyLocked {\n        if (!tokenCtr.lock()) throw;\n        _;\n    }\n\n    // The modifier resetPaidOut updates the currenct epoch, and\n    // enables the smart contract to track when a token holder\n    // has already received their fair share of profits or not\n    // and sets the balance for the epoch using current balance\n    modifier resetPaidOut {\n        if(currentEpoch < tokenCtr.numOfCurrentEpoch()) {\n            currentEpoch = tokenCtr.numOfCurrentEpoch();\n            initEpochBalance = this.balance;\n            WithdrawalEnabled();\n        }\n        _;\n    }\n\n    function ProfitContainer(address _token) {\n        tokenCtr = Token(_token);\n    }\n\n    function ()\n        payable {\n\n    }\n\n    // The function withdrawalProfit() enables token holders\n    // to collect a fair share of profits from the ProfitContainer,\n    // proportional to the amount of tokens they own. Token holders\n    // will be able to collect their profits only once\n    function withdrawalProfit()\n        external\n        resetPaidOut\n        onlyLocked\n        onlyNotPaidOut {\n        uint currentEpoch = tokenCtr.numOfCurrentEpoch();\n        uint tokenBalance = tokenCtr.balanceOf(msg.sender);\n        uint totalSupply = tokenCtr.totalSupply();\n\n        if (tokenBalance == 0) throw;\n\n        lastPaidOutEpoch[msg.sender] = currentEpoch;\n\n        // Overflow risk only exists if balance is greater than\n        // 1e+33 ether, assuming max of 96M tokens minted.\n        // Functions throws, as such a state should never be reached\n        // Unless significantly more tokens are minted\n        if (!safeToMultiply(tokenBalance, initEpochBalance)) throw;\n        uint senderPortion = (tokenBalance * initEpochBalance);\n\n        uint amountToPayOut = senderPortion / totalSupply;\n\n        if(!msg.sender.send(amountToPayOut)) {\n            throw;\n        }\n\n        ProfitWithdrawn(msg.sender, amountToPayOut);\n    }\n\n    function changeTokenContract(address _newToken)\n        external\n        onlyOwner {\n\n        if (_newToken == address(0x0)) throw;\n\n        tokenCtr = Token(_newToken);\n        TokenContractChanged(_newToken);\n    }\n\n    // returns expected payout for tokenholder during lock phase\n    function expectedPayout(address _tokenHolder)\n        external\n        constant returns (uint) {\n\n        if (!tokenCtr.lock())\n            return 0;\n\n        return (tokenCtr.balanceOf(_tokenHolder) * initEpochBalance) / tokenCtr.totalSupply();\n    }\n\n    function safeToMultiply(uint _a, uint _b)\n        private\n        constant returns (bool) {\n\n        return (_b == 0 || ((_a * _b) / _b) == _a);\n    }\n}",
  "bytecode": "6060604052346100005760405160208061085483398101604052515b5b60008054600160a060020a0319166c01000000000000000000000000338102041790555b60048054600160a060020a0319166c01000000000000000000000000838102041790555b505b6107e0806100746000396000f36060604052361561006c5760e060020a60003504632ebec916811461007557806336bc32a21461008457806350148ed2146100a6578063523aee69146100c557806376671808146100d75780638da5cb5b146100f6578063aef251a71461011f578063f2fde38b14610148575b6100735b5b565b005b346100005761007361015a565b005b346100005761009460043561052c565b60408051918252519081900360200190f35b3461000057610094610694565b60408051918252519081900360200190f35b346100005761007360043561069a565b005b3461000057610094610739565b60408051918252519081900360200190f35b346100005761010361073f565b60408051600160a060020a039092168252519081900360200190f35b346100005761010361074e565b60408051600160a060020a039092168252519081900360200190f35b346100005761007360043561075d565b005b60006000600060006000600460009054906101000a9004600160a060020a0316600160a060020a031663018e13d06000604051602001526040518160e060020a028152600401809050602060405180830381600087803b156100005760325a03f115610000575050604051516001541015905061026d57600460009054906101000a9004600160a060020a0316600160a060020a031663018e13d06000604051602001526040518160e060020a028152600401809050602060405180830381600087803b156100005760325a03f1156100005750506040518051600155600160a060020a033016316002557f66f7d730c9ba098beec19ac6c1d94380c4f8b016455b36cb348ca4c646a075bc9150600090a15b600460009054906101000a9004600160a060020a0316600160a060020a031663f83d08ba6000604051602001526040518160e060020a028152600401809050602060405180830381600087803b156100005760325a03f11561000057505060405151151590506102dc57610000565b600154600160a060020a033316600090815260036020526040902054141561030357610000565b600460009054906101000a9004600160a060020a0316600160a060020a031663018e13d06000604051602001526040518160e060020a028152600401809050602060405180830381600087803b156100005760325a03f115610000575050604080518051600480546000602094850181905285517f70a08231000000000000000000000000000000000000000000000000000000008152600160a060020a03338116948201949094529551939b50911694506370a08231936024808201949392918390030190829087803b156100005760325a03f115610000575050604080518051600480546000602094850181905285517f18160ddd0000000000000000000000000000000000000000000000000000000081529551939a50600160a060020a0390911695506318160ddd94808301949392908390030190829087803b156100005760325a03f1156100005750506040515193505083151561046557610000565b600160a060020a033316600090815260036020526040902085905560025461048e9085906107bf565b151561049957610000565b6002548402915082828115610000576040519190049150600160a060020a0333169082156108fc029083906000818181858888f1935050505015156104dd57610000565b60408051600160a060020a03331681526020810183905281517f016e128b6bdadd9e9068abd0b18db2fc8b27ed3dbced50e4aa6cc0a6934251ab929181900390910190a15b5b5b5b5050505050565b6000600460009054906101000a9004600160a060020a0316600160a060020a031663f83d08ba6000604051602001526040518160e060020a028152600401809050602060405180830381600087803b156100005760325a03f11561000057505060405151151590506105a05750600061068f565b600460009054906101000a9004600160a060020a0316600160a060020a03166318160ddd6000604051602001526040518160e060020a028152600401809050602060405180830381600087803b156100005760325a03f1156100005750505060405180519060200150600254600460009054906101000a9004600160a060020a0316600160a060020a03166370a08231856000604051602001526040518260e060020a0281526004018082600160a060020a03168152602001915050602060405180830381600087803b156100005760325a03f115610000575050604051519190910290508115610000570490505b919050565b60025481565b60005433600160a060020a039081169116141561073457600160a060020a03811615156106c657610000565b6004805473ffffffffffffffffffffffffffffffffffffffff19166c010000000000000000000000008381020417905560408051600160a060020a038316815290517fe89f98a27789c8313baa22de83cdb921b7026d66af0ee02973c97d45f952b6be916020908290030190a15b5b5b50565b60015481565b600054600160a060020a031681565b600454600160a060020a031681565b60005433600160a060020a039081169116141561073457600160a060020a038116151561078957610000565b6000805473ffffffffffffffffffffffffffffffffffffffff19166c01000000000000000000000000838102041790555b5b5b50565b60008115806107d75750828283850281156100005704145b90505b9291505056",
  "constructorArguments": "0000000000000000000000005c543e7ae0a1104f78406c340e9c64fd9fce5170"
}