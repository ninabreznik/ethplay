{
  "address": "0xf4985070ce32b6b1994329df787d1acc9a2dd9e2",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "AxieClockAuction",
  "compilerVersion": "v0.4.19+commit.c4cbbb05",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2018-04-02\n*/\n\npragma solidity ^0.4.19;\n\n// File: contracts/erc/erc721/IERC721Base.sol\n\n/// @title ERC-721 Non-Fungible Token Standard\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n///  Note: the ERC-165 identifier for this interface is 0x6466353c\ninterface IERC721Base /* is IERC165  */ {\n  /// @dev This emits when ownership of any NFT changes by any mechanism.\n  ///  This event emits when NFTs are created (`from` == 0) and destroyed\n  ///  (`to` == 0). Exception: during contract creation, any number of NFTs\n  ///  may be created and assigned without emitting Transfer. At the time of\n  ///  any transfer, the approved address for that NFT (if any) is reset to none.\n  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n\n  /// @dev This emits when the approved address for an NFT is changed or\n  ///  reaffirmed. The zero address indicates there is no approved address.\n  ///  When a Transfer event emits, this also indicates that the approved\n  ///  address for that NFT (if any) is reset to none.\n  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n\n  /// @dev This emits when an operator is enabled or disabled for an owner.\n  ///  The operator can manage all NFTs of the owner.\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n  /// @notice Count all NFTs assigned to an owner\n  /// @dev NFTs assigned to the zero address are considered invalid, and this\n  ///  function throws for queries about the zero address.\n  /// @param _owner An address for whom to query the balance\n  /// @return The number of NFTs owned by `_owner`, possibly zero\n  function balanceOf(address _owner) external view returns (uint256);\n\n  /// @notice Find the owner of an NFT\n  /// @param _tokenId The identifier for an NFT\n  /// @dev NFTs assigned to zero address are considered invalid, and queries\n  ///  about them do throw.\n  /// @return The address of the owner of the NFT\n  function ownerOf(uint256 _tokenId) external view returns (address);\n\n  /// @notice Transfers the ownership of an NFT from one address to another address\n  /// @dev Throws unless `msg.sender` is the current owner, an authorized\n  ///  operator, or the approved address for this NFT. Throws if `_from` is\n  ///  not the current owner. Throws if `_to` is the zero address. Throws if\n  ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\n  ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\n  ///  `onERC721Received` on `_to` and throws if the return value is not\n  ///  `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`.\n  /// @param _from The current owner of the NFT\n  /// @param _to The new owner\n  /// @param _tokenId The NFT to transfer\n  /// @param _data Additional data with no specified format, sent in call to `_to`\n  // solium-disable-next-line arg-overflow\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) external payable;\n\n  /// @notice Transfers the ownership of an NFT from one address to another address\n  /// @dev This works identically to the other function with an extra data parameter,\n  ///  except this function just sets data to []\n  /// @param _from The current owner of the NFT\n  /// @param _to The new owner\n  /// @param _tokenId The NFT to transfer\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\n\n  /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n  ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n  ///  THEY MAY BE PERMANENTLY LOST\n  /// @dev Throws unless `msg.sender` is the current owner, an authorized\n  ///  operator, or the approved address for this NFT. Throws if `_from` is\n  ///  not the current owner. Throws if `_to` is the zero address. Throws if\n  ///  `_tokenId` is not a valid NFT.\n  /// @param _from The current owner of the NFT\n  /// @param _to The new owner\n  /// @param _tokenId The NFT to transfer\n  function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\n\n  /// @notice Set or reaffirm the approved address for an NFT\n  /// @dev The zero address indicates there is no approved address.\n  /// @dev Throws unless `msg.sender` is the current NFT owner, or an authorized\n  ///  operator of the current owner.\n  /// @param _approved The new approved NFT controller\n  /// @param _tokenId The NFT to approve\n  function approve(address _approved, uint256 _tokenId) external payable;\n\n  /// @notice Enable or disable approval for a third party (\"operator\") to manage\n  ///  all your asset.\n  /// @dev Emits the ApprovalForAll event\n  /// @param _operator Address to add to the set of authorized operators.\n  /// @param _approved True if the operators is approved, false to revoke approval\n  function setApprovalForAll(address _operator, bool _approved) external;\n\n  /// @notice Get the approved address for a single NFT\n  /// @dev Throws if `_tokenId` is not a valid NFT\n  /// @param _tokenId The NFT to find the approved address for\n  /// @return The approved address for this NFT, or the zero address if there is none\n  function getApproved(uint256 _tokenId) external view returns (address);\n\n  /// @notice Query if an address is an authorized operator for another address\n  /// @param _owner The address that owns the NFTs\n  /// @param _operator The address that acts on behalf of the owner\n  /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n  function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n}\n\n// File: zeppelin/contracts/ownership/Ownable.sol\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() {\n    owner = msg.sender;\n  }\n\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) onlyOwner public {\n    require(newOwner != address(0));\n    OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n// File: zeppelin/contracts/lifecycle/Pausable.sol\n\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    Unpause();\n  }\n}\n\n// File: zeppelin/contracts/ownership/HasNoEther.sol\n\n/**\n * @title Contracts that should not own Ether\n * @author Remco Bloemen <[email protected]π.com>\n * @dev This tries to block incoming ether to prevent accidental loss of Ether. Should Ether end up\n * in the contract, it will allow the owner to reclaim this ether.\n * @notice Ether can still be send to this contract by:\n * calling functions labeled `payable`\n * `selfdestruct(contract_address)`\n * mining directly to the contract address\n*/\ncontract HasNoEther is Ownable {\n\n  /**\n  * @dev Constructor that rejects incoming Ether\n  * @dev The `payable` flag is added so we can access `msg.value` without compiler warning. If we\n  * leave out payable, then Solidity will allow inheriting contracts to implement a payable\n  * constructor. By doing it this way we prevent a payable constructor from working. Alternatively\n  * we could use assembly to access msg.value.\n  */\n  function HasNoEther() payable {\n    require(msg.value == 0);\n  }\n\n  /**\n   * @dev Disallows direct send by settings a default function without the `payable` flag.\n   */\n  function() external {\n  }\n\n  /**\n   * @dev Transfer all Ether held by the contract to the owner.\n   */\n  function reclaimEther() external onlyOwner {\n    assert(owner.send(this.balance));\n  }\n}\n\n// File: contracts/marketplace/AxieClockAuction.sol\n\n/// @title Clock auction for non-fungible tokens.\ncontract AxieClockAuction is HasNoEther, Pausable {\n\n  // Represents an auction on an NFT\n  struct Auction {\n    // Current owner of NFT\n    address seller;\n    // Price (in wei) at beginning of auction\n    uint128 startingPrice;\n    // Price (in wei) at end of auction\n    uint128 endingPrice;\n    // Duration (in seconds) of auction\n    uint64 duration;\n    // Time when auction started\n    // NOTE: 0 if this auction has been concluded\n    uint64 startedAt;\n  }\n\n  // Cut owner takes on each auction, measured in basis points (1/100 of a percent).\n  // Values 0-10,000 map to 0%-100%\n  uint256 public ownerCut;\n\n  // Map from token ID to their corresponding auction.\n  mapping (address => mapping (uint256 => Auction)) public auctions;\n\n  event AuctionCreated(\n    address indexed _nftAddress,\n    uint256 indexed _tokenId,\n    uint256 _startingPrice,\n    uint256 _endingPrice,\n    uint256 _duration,\n    address _seller\n  );\n\n  event AuctionSuccessful(\n    address indexed _nftAddress,\n    uint256 indexed _tokenId,\n    uint256 _totalPrice,\n    address _winner\n  );\n\n  event AuctionCancelled(\n    address indexed _nftAddress,\n    uint256 indexed _tokenId\n  );\n\n  /// @dev Constructor creates a reference to the NFT ownership contract\n  ///  and verifies the owner cut is in the valid range.\n  /// @param _ownerCut - percent cut the owner takes on each auction, must be\n  ///  between 0-10,000.\n  function AxieClockAuction(uint256 _ownerCut) public {\n    require(_ownerCut <= 10000);\n    ownerCut = _ownerCut;\n  }\n\n  /// @dev DON'T give me your money.\n  function () external {}\n\n  // Modifiers to check that inputs can be safely stored with a certain\n  // number of bits. We use constants and multiple modifiers to save gas.\n  modifier canBeStoredWith64Bits(uint256 _value) {\n    require(_value <= 18446744073709551615);\n    _;\n  }\n\n  modifier canBeStoredWith128Bits(uint256 _value) {\n    require(_value < 340282366920938463463374607431768211455);\n    _;\n  }\n\n  /// @dev Returns auction info for an NFT on auction.\n  /// @param _nftAddress - Address of the NFT.\n  /// @param _tokenId - ID of NFT on auction.\n  function getAuction(\n    address _nftAddress,\n    uint256 _tokenId\n  )\n    external\n    view\n    returns (\n      address seller,\n      uint256 startingPrice,\n      uint256 endingPrice,\n      uint256 duration,\n      uint256 startedAt\n    )\n  {\n    Auction storage _auction = auctions[_nftAddress][_tokenId];\n    require(_isOnAuction(_auction));\n    return (\n      _auction.seller,\n      _auction.startingPrice,\n      _auction.endingPrice,\n      _auction.duration,\n      _auction.startedAt\n    );\n  }\n\n  /// @dev Returns the current price of an auction.\n  /// @param _nftAddress - Address of the NFT.\n  /// @param _tokenId - ID of the token price we are checking.\n  function getCurrentPrice(\n    address _nftAddress,\n    uint256 _tokenId\n  )\n    external\n    view\n    returns (uint256)\n  {\n    Auction storage _auction = auctions[_nftAddress][_tokenId];\n    require(_isOnAuction(_auction));\n    return _getCurrentPrice(_auction);\n  }\n\n  /// @dev Creates and begins a new auction.\n  /// @param _nftAddress - address of a deployed contract implementing\n  ///  the Nonfungible Interface.\n  /// @param _tokenId - ID of token to auction, sender must be owner.\n  /// @param _startingPrice - Price of item (in wei) at beginning of auction.\n  /// @param _endingPrice - Price of item (in wei) at end of auction.\n  /// @param _duration - Length of time to move between starting\n  ///  price and ending price (in seconds).\n  function createAuction(\n    address _nftAddress,\n    uint256 _tokenId,\n    uint256 _startingPrice,\n    uint256 _endingPrice,\n    uint256 _duration\n  )\n    external\n    whenNotPaused\n    canBeStoredWith128Bits(_startingPrice)\n    canBeStoredWith128Bits(_endingPrice)\n    canBeStoredWith64Bits(_duration)\n  {\n    address _seller = msg.sender;\n    require(_owns(_nftAddress, _seller, _tokenId));\n    _escrow(_nftAddress, _seller, _tokenId);\n    Auction memory _auction = Auction(\n      _seller,\n      uint128(_startingPrice),\n      uint128(_endingPrice),\n      uint64(_duration),\n      uint64(now)\n    );\n    _addAuction(_nftAddress, _tokenId, _auction, _seller);\n  }\n\n  /// @dev Bids on an open auction, completing the auction and transferring\n  ///  ownership of the NFT if enough Ether is supplied.\n  /// @param _nftAddress - address of a deployed contract implementing\n  ///  the Nonfungible Interface.\n  /// @param _tokenId - ID of token to bid on.\n  function bid(\n    address _nftAddress,\n    uint256 _tokenId\n  )\n    external\n    payable\n    whenNotPaused\n  {\n    // _bid will throw if the bid or funds transfer fails\n    _bid(_nftAddress, _tokenId, msg.value);\n    _transfer(_nftAddress, msg.sender, _tokenId);\n  }\n\n  /// @dev Cancels an auction that hasn't been won yet.\n  ///  Returns the NFT to original owner.\n  /// @notice This is a state-modifying function that can\n  ///  be called while the contract is paused.\n  /// @param _nftAddress - Address of the NFT.\n  /// @param _tokenId - ID of token on auction\n  function cancelAuction(address _nftAddress, uint256 _tokenId) external {\n    Auction storage _auction = auctions[_nftAddress][_tokenId];\n    require(_isOnAuction(_auction));\n    require(msg.sender == _auction.seller);\n    _cancelAuction(_nftAddress, _tokenId, _auction.seller);\n  }\n\n  /// @dev Cancels an auction when the contract is paused.\n  ///  Only the owner may do this, and NFTs are returned to\n  ///  the seller. This should only be used in emergencies.\n  /// @param _nftAddress - Address of the NFT.\n  /// @param _tokenId - ID of the NFT on auction to cancel.\n  function cancelAuctionWhenPaused(\n    address _nftAddress,\n    uint256 _tokenId\n  )\n    external\n    whenPaused\n    onlyOwner\n  {\n    Auction storage _auction = auctions[_nftAddress][_tokenId];\n    require(_isOnAuction(_auction));\n    _cancelAuction(_nftAddress, _tokenId, _auction.seller);\n  }\n\n  /// @dev Returns true if the NFT is on auction.\n  /// @param _auction - Auction to check.\n  function _isOnAuction(Auction storage _auction) internal view returns (bool) {\n    return (_auction.startedAt > 0);\n  }\n\n  /// @dev Gets the NFT object from an address, validating that implementsERC721 is true.\n  /// @param _nftAddress - Address of the NFT.\n  function _getNftContract(address _nftAddress) internal pure returns (IERC721Base) {\n    IERC721Base candidateContract = IERC721Base(_nftAddress);\n    // require(candidateContract.implementsERC721());\n    return candidateContract;\n  }\n\n  /// @dev Returns current price of an NFT on auction. Broken into two\n  ///  functions (this one, that computes the duration from the auction\n  ///  structure, and the other that does the price computation) so we\n  ///  can easily test that the price computation works correctly.\n  function _getCurrentPrice(\n    Auction storage _auction\n  )\n    internal\n    view\n    returns (uint256)\n  {\n    uint256 _secondsPassed = 0;\n\n    // A bit of insurance against negative values (or wraparound).\n    // Probably not necessary (since Ethereum guarantees that the\n    // now variable doesn't ever go backwards).\n    if (now > _auction.startedAt) {\n      _secondsPassed = now - _auction.startedAt;\n    }\n\n    return _computeCurrentPrice(\n      _auction.startingPrice,\n      _auction.endingPrice,\n      _auction.duration,\n      _secondsPassed\n    );\n  }\n\n  /// @dev Computes the current price of an auction. Factored out\n  ///  from _currentPrice so we can run extensive unit tests.\n  ///  When testing, make this function external and turn on\n  ///  `Current price computation` test suite.\n  function _computeCurrentPrice(\n    uint256 _startingPrice,\n    uint256 _endingPrice,\n    uint256 _duration,\n    uint256 _secondsPassed\n  )\n    internal\n    pure\n    returns (uint256)\n  {\n    // NOTE: We don't use SafeMath (or similar) in this function because\n    //  all of our external functions carefully cap the maximum values for\n    //  time (at 64-bits) and currency (at 128-bits). _duration is\n    //  also known to be non-zero (see the require() statement in\n    //  _addAuction())\n    if (_secondsPassed >= _duration) {\n      // We've reached the end of the dynamic pricing portion\n      // of the auction, just return the end price.\n      return _endingPrice;\n    } else {\n      // Starting price can be higher than ending price (and often is!), so\n      // this delta can be negative.\n      int256 _totalPriceChange = int256(_endingPrice) - int256(_startingPrice);\n\n      // This multiplication can't overflow, _secondsPassed will easily fit within\n      // 64-bits, and _totalPriceChange will easily fit within 128-bits, their product\n      // will always fit within 256-bits.\n      int256 _currentPriceChange = _totalPriceChange * int256(_secondsPassed) / int256(_duration);\n\n      // _currentPriceChange can be negative, but if so, will have a magnitude\n      // less that _startingPrice. Thus, this result will always end up positive.\n      int256 _currentPrice = int256(_startingPrice) + _currentPriceChange;\n\n      return uint256(_currentPrice);\n    }\n  }\n\n  /// @dev Returns true if the claimant owns the token.\n  /// @param _nftAddress - The address of the NFT.\n  /// @param _claimant - Address claiming to own the token.\n  /// @param _tokenId - ID of token whose ownership to verify.\n  function _owns(address _nftAddress, address _claimant, uint256 _tokenId) private view returns (bool) {\n    IERC721Base _nftContract = _getNftContract(_nftAddress);\n    return (_nftContract.ownerOf(_tokenId) == _claimant);\n  }\n\n  /// @dev Adds an auction to the list of open auctions. Also fires the\n  ///  AuctionCreated event.\n  /// @param _tokenId The ID of the token to be put on auction.\n  /// @param _auction Auction to add.\n  function _addAuction(\n    address _nftAddress,\n    uint256 _tokenId,\n    Auction _auction,\n    address _seller\n  ) internal {\n    // Require that all auctions have a duration of\n    // at least one minute. (Keeps our math from getting hairy!)\n    require(_auction.duration >= 1 minutes);\n\n    auctions[_nftAddress][_tokenId] = _auction;\n\n    AuctionCreated(\n      _nftAddress,\n      _tokenId,\n      uint256(_auction.startingPrice),\n      uint256(_auction.endingPrice),\n      uint256(_auction.duration),\n      _seller\n    );\n  }\n\n  /// @dev Removes an auction from the list of open auctions.\n  /// @param _tokenId - ID of NFT on auction.\n  function _removeAuction(address _nftAddress, uint256 _tokenId) internal {\n    delete auctions[_nftAddress][_tokenId];\n  }\n\n  /// @dev Cancels an auction unconditionally.\n  function _cancelAuction(address _nftAddress, uint256 _tokenId, address _seller) internal {\n    _removeAuction(_nftAddress, _tokenId);\n    _transfer(_nftAddress, _seller, _tokenId);\n    AuctionCancelled(_nftAddress, _tokenId);\n  }\n\n  /// @dev Escrows the NFT, assigning ownership to this contract.\n  /// Throws if the escrow fails.\n  /// @param _nftAddress - The address of the NFT.\n  /// @param _owner - Current owner address of token to escrow.\n  /// @param _tokenId - ID of token whose approval to verify.\n  function _escrow(address _nftAddress, address _owner, uint256 _tokenId) private {\n    IERC721Base _nftContract = _getNftContract(_nftAddress);\n\n    // It will throw if transfer fails\n    _nftContract.transferFrom(_owner, this, _tokenId);\n  }\n\n  /// @dev Transfers an NFT owned by this contract to another address.\n  /// Returns true if the transfer succeeds.\n  /// @param _nftAddress - The address of the NFT.\n  /// @param _receiver - Address to transfer NFT to.\n  /// @param _tokenId - ID of token to transfer.\n  function _transfer(address _nftAddress, address _receiver, uint256 _tokenId) internal {\n    IERC721Base _nftContract = _getNftContract(_nftAddress);\n\n    // It will throw if transfer fails\n    _nftContract.transferFrom(this, _receiver, _tokenId);\n  }\n\n  /// @dev Computes owner's cut of a sale.\n  /// @param _price - Sale price of NFT.\n  function _computeCut(uint256 _price) internal view returns (uint256) {\n    // NOTE: We don't use SafeMath (or similar) in this function because\n    //  all of our entry functions carefully cap the maximum values for\n    //  currency (at 128-bits), and ownerCut <= 10000 (see the require()\n    //  statement in the ClockAuction constructor). The result of this\n    //  function is always guaranteed to be <= _price.\n    return _price * ownerCut / 10000;\n  }\n\n  /// @dev Computes the price and transfers winnings.\n  /// Does NOT transfer ownership of token.\n  function _bid(\n    address _nftAddress,\n    uint256 _tokenId,\n    uint256 _bidAmount\n  )\n    internal\n    returns (uint256)\n  {\n    // Get a reference to the auction struct\n    Auction storage _auction = auctions[_nftAddress][_tokenId];\n\n    // Explicitly check that this auction is currently live.\n    // (Because of how Ethereum mappings work, we can't just count\n    // on the lookup above failing. An invalid _tokenId will just\n    // return an auction object that is all zeros.)\n    require(_isOnAuction(_auction));\n\n    // Check that the incoming bid is higher than the current\n    // price\n    uint256 _price = _getCurrentPrice(_auction);\n    require(_bidAmount >= _price);\n\n    // Grab a reference to the seller before the auction struct\n    // gets deleted.\n    address _seller = _auction.seller;\n\n    // The bid is good! Remove the auction before sending the fees\n    // to the sender so we can't have a reentrancy attack.\n    _removeAuction(_nftAddress, _tokenId);\n\n    // Transfer proceeds to seller (if there are any!)\n    if (_price > 0) {\n      //  Calculate the auctioneer's cut.\n      // (NOTE: _computeCut() is guaranteed to return a\n      //  value <= price, so this subtraction can't go negative.)\n      uint256 _auctioneerCut = _computeCut(_price);\n      uint256 _sellerProceeds = _price - _auctioneerCut;\n\n      // NOTE: Doing a transfer() in the middle of a complex\n      // method like this is generally discouraged because of\n      // reentrancy attacks and DoS attacks if the seller is\n      // a contract with an invalid fallback function. We explicitly\n      // guard against reentrancy attacks by removing the auction\n      // before calling transfer(), and the only thing the seller\n      // can DoS is the sale of their own asset! (And if it's an\n      // accident, they can call cancelAuction(). )\n      _seller.transfer(_sellerProceeds);\n    }\n\n    if (_bidAmount > _price) {\n      // Calculate any excess funds included with the bid. If the excess\n      // is anything worth worrying about, transfer it back to bidder.\n      // NOTE: We checked above that the bid amount is greater than or\n      // equal to the price so this cannot underflow.\n      uint256 _bidExcess = _bidAmount - _price;\n\n      // Return the funds. Similar to the previous transfer, this is\n      // not susceptible to a re-entry attack because the auction is\n      // removed before any transfers occur.\n      msg.sender.transfer(_bidExcess);\n    }\n\n    // Tell the world!\n    AuctionSuccessful(_nftAddress, _tokenId, _price, msg.sender);\n\n    return _price;\n  }\n}",
  "abi": "[{\"constant\":false,\"inputs\":[{\"name\":\"_nftAddress\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"cancelAuctionWhenPaused\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"auctions\",\"outputs\":[{\"name\":\"seller\",\"type\":\"address\"},{\"name\":\"startingPrice\",\"type\":\"uint128\"},{\"name\":\"endingPrice\",\"type\":\"uint128\"},{\"name\":\"duration\",\"type\":\"uint64\"},{\"name\":\"startedAt\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nftAddress\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"bid\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_nftAddress\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getCurrentPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_nftAddress\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getAuction\",\"outputs\":[{\"name\":\"seller\",\"type\":\"address\"},{\"name\":\"startingPrice\",\"type\":\"uint256\"},{\"name\":\"endingPrice\",\"type\":\"uint256\"},{\"name\":\"duration\",\"type\":\"uint256\"},{\"name\":\"startedAt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerCut\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nftAddress\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"cancelAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nftAddress\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_startingPrice\",\"type\":\"uint256\"},{\"name\":\"_endingPrice\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"createAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reclaimEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_ownerCut\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_nftAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_startingPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_endingPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_duration\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_seller\",\"type\":\"address\"}],\"name\":\"AuctionCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_nftAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_totalPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_winner\",\"type\":\"address\"}],\"name\":\"AuctionSuccessful\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_nftAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"AuctionCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]",
  "bytecode": "60606040526000805460a060020a60ff0219169055341561001f57600080fd5b604051602080610fa48339810160405280805160008054600160a060020a03191633600160a060020a0316179055915050341561005b57600080fd5b61271081111561006a57600080fd5b600155610f288061007c6000396000f3006060604052600436106100b65763ffffffff60e060020a6000350416631ae6b6ee81146100c35780633f4ba83a146100e557806344f91c1e146100f857806359d667a51461016c5780635c975abb146101835780636c54df52146101aa578063762a66a2146101de57806383b5ff8b1461023b5780638456cb591461024e578063859b97fe146102615780638da5cb5b14610283578063961c9ae4146102b25780639f727c27146102dd578063f2fde38b146102f0575b34156100c157600080fd5b005b34156100ce57600080fd5b6100c1600160a060020a036004351660243561030f565b34156100f057600080fd5b6100c1610398565b341561010357600080fd5b61011a600160a060020a0360043516602435610417565b604051600160a060020a0390951685526001608060020a0393841660208601529190921660408085019190915267ffffffffffffffff92831660608501529116608083015260a0909101905180910390f35b6100c1600160a060020a0360043516602435610487565b341561018e57600080fd5b6101966104b9565b604051901515815260200160405180910390f35b34156101b557600080fd5b6101cc600160a060020a03600435166024356104c9565b60405190815260200160405180910390f35b34156101e957600080fd5b610200600160a060020a0360043516602435610511565b604051600160a060020a03909516855260208501939093526040808501929092526060840152608083019190915260a0909101905180910390f35b341561024657600080fd5b6101cc6105b4565b341561025957600080fd5b6100c16105ba565b341561026c57600080fd5b6100c1600160a060020a036004351660243561063e565b341561028e57600080fd5b61029661068f565b604051600160a060020a03909116815260200160405180910390f35b34156102bd57600080fd5b6100c1600160a060020a036004351660243560443560643560843561069e565b34156102e857600080fd5b6100c1610792565b34156102fb57600080fd5b6100c1600160a060020a03600435166107e5565b6000805460a060020a900460ff16151561032857600080fd5b60005433600160a060020a0390811691161461034357600080fd5b50600160a060020a0382166000908152600260209081526040808320848452909152902061037081610880565b151561037b57600080fd5b80546103939084908490600160a060020a03166108a1565b505050565b60005433600160a060020a039081169116146103b357600080fd5b60005460a060020a900460ff1615156103cb57600080fd5b6000805474ff0000000000000000000000000000000000000000191690557f7805862f689e2f13df9f062ff482ad3ad112aca9e0847911ed832e158c525b3360405160405180910390a1565b60026020818152600093845260408085209091529183529120805460018201549190920154600160a060020a03909216916001608060020a03808316927001000000000000000000000000000000009004169067ffffffffffffffff808216916801000000000000000090041685565b60005460a060020a900460ff161561049e57600080fd5b6104a98282346108f2565b506104b5823383610a40565b5050565b60005460a060020a900460ff1681565b600160a060020a038216600090815260026020908152604080832084845290915281206104f581610880565b151561050057600080fd5b61050981610ac8565b949350505050565b600160a060020a03821660009081526002602090815260408083208484529091528120819081908190819061054581610880565b151561055057600080fd5b80546001820154600290920154600160a060020a03909116996001608060020a038084169a50700100000000000000000000000000000000909304909216975067ffffffffffffffff80821697506801000000000000000090910416945092505050565b60015481565b60005433600160a060020a039081169116146105d557600080fd5b60005460a060020a900460ff16156105ec57600080fd5b6000805474ff0000000000000000000000000000000000000000191660a060020a1790557f6985a02210a168e66602d3235cb6db0e70f92b3ba4d376a33c0f3d9434bff62560405160405180910390a1565b600160a060020a0382166000908152600260209081526040808320848452909152902061066a81610880565b151561067557600080fd5b805433600160a060020a0390811691161461037b57600080fd5b600054600160a060020a031681565b60006106a8610ece565b60005460a060020a900460ff16156106bf57600080fd5b846001608060020a0381106106d357600080fd5b846001608060020a0381106106e757600080fd5b8467ffffffffffffffff8111156106fd57600080fd5b33945061070b8a868b610b56565b151561071657600080fd5b6107218a868b610bec565b60a06040519081016040528086600160a060020a03168152602001896001608060020a03168152602001886001608060020a031681526020018767ffffffffffffffff1681526020014267ffffffffffffffff1681525093506107868a8a8688610c5a565b50505050505050505050565b60005433600160a060020a039081169116146107ad57600080fd5b600054600160a060020a039081169030163180156108fc0290604051600060405180830381858888f1935050505015156107e357fe5b565b60005433600160a060020a0390811691161461080057600080fd5b600160a060020a038116151561081557600080fd5b600054600160a060020a0380831691167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a36000805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b6002015460006801000000000000000090910467ffffffffffffffff161190565b6108ab8383610e20565b6108b6838284610a40565b8183600160a060020a03167f018b64b6242d32aa550e95d78985b938d71af5b3f10827b0683f55da1639304860405160405180910390a3505050565b600160a060020a03831660009081526002602090815260408083208584529091528120818080808061092386610880565b151561092e57600080fd5b61093786610ac8565b94508488101561094657600080fd5b8554600160a060020a0316935061095d8a8a610e20565b60008511156109a75761096f85610e82565b92508285039150600160a060020a03841682156108fc0283604051600060405180830381858888f1935050505015156109a757600080fd5b848811156109e45750838703600160a060020a03331681156108fc0282604051600060405180830381858888f1935050505015156109e457600080fd5b888a600160a060020a03167f6c00bb44a64da29b6a73920d50ff280237d277bda3e1f3cdf4e24392e6839efe8733604051918252600160a060020a031660208201526040908101905180910390a3509298975050505050505050565b6000610a4b84610e8e565b905080600160a060020a03166323b872dd30858560405160e060020a63ffffffff8616028152600160a060020a0393841660048201529190921660248201526044810191909152606401600060405180830381600087803b1515610aae57600080fd5b6102c65a03f11515610abf57600080fd5b50505050505050565b6002810154600090819068010000000000000000900467ffffffffffffffff16421115610b0e5750600282015468010000000000000000900467ffffffffffffffff1642035b60018301546002840154610b4f916001608060020a0380821692700100000000000000000000000000000000909204169067ffffffffffffffff1684610e91565b9392505050565b600080610b6285610e8e565b905083600160a060020a031681600160a060020a0316636352211e8560006040516020015260405160e060020a63ffffffff84160281526004810191909152602401602060405180830381600087803b1515610bbd57600080fd5b6102c65a03f11515610bce57600080fd5b50505060405180519050600160a060020a0316149150509392505050565b6000610bf784610e8e565b905080600160a060020a03166323b872dd84308560405160e060020a63ffffffff8616028152600160a060020a0393841660048201529190921660248201526044810191909152606401600060405180830381600087803b1515610aae57600080fd5b603c826060015167ffffffffffffffff161015610c7657600080fd5b600160a060020a0384166000908152600260209081526040808320868452909152902082908151815473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a039190911617815560208201516001820180546fffffffffffffffffffffffffffffffff19166001608060020a039290921691909117905560408201516001820180546001608060020a03928316700100000000000000000000000000000000029216919091179055606082015160028201805467ffffffffffffffff191667ffffffffffffffff9290921691909117905560808201516002909101805467ffffffffffffffff9290921668010000000000000000026fffffffffffffffff0000000000000000199092169190911790555082600160a060020a0385167febc6e332a2c695c53d77b2922a18bcf3ab024549f5f2bfa67e0875ec29d59d4660208501516001608060020a031685604001516001608060020a0316866060015167ffffffffffffffff16866040519384526020840192909252604080840191909152600160a060020a0390911660608301526080909101905180910390a350505050565b600160a060020a039091166000908152600260208181526040808420948452939052918120805473ffffffffffffffffffffffffffffffffffffffff1916815560018101919091550180546fffffffffffffffffffffffffffffffff19169055565b60015461271091020490565b90565b6000808080858510610ea557869350610ec3565b878703925085858402811515610eb757fe5b05915081880190508093505b505050949350505050565b60a06040519081016040908152600080835260208301819052908201819052606082018190526080820152905600a165627a7a723058202006b21bd123c97e5aa47d69d98a066c6ac130a7125f23df9c9e6a98a3d99de1002900000000000000000000000000000000000000000000000000000000000001a9",
  "constructorArguments": "00000000000000000000000000000000000000000000000000000000000001a9"
}