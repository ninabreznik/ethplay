{
  "address": "0x000000000063b99b8036c31e91c64fc89bff9ca7",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "ImmutableCreate2Factory",
  "compilerVersion": "v0.5.8+commit.23d335f2",
  "optimization": true,
  "runs": "99999",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2019-05-20\n*/\n\npragma solidity 0.5.8; // optimization enabled, 99999 runs\n\n\n/**\n * @title Immutable Create2 Contract Factory\n * @author 0age\n * @notice This contract provides a safeCreate2 function that takes a salt value\n * and a block of initialization code as arguments and passes them into inline\n * assembly. The contract prevents redeploys by maintaining a mapping of all\n * contracts that have already been deployed, and prevents frontrunning or other\n * collisions by requiring that the first 20 bytes of the salt are equal to the\n * address of the caller (this can be bypassed by setting the first 20 bytes to\n * the null address). There is also a view function that computes the address of\n * the contract that will be created when submitting a given salt or nonce along\n * with a given block of initialization code.\n * @dev This contract has not yet been fully tested or audited - proceed with\n * caution and please share any exploits or optimizations you discover.\n */\ncontract ImmutableCreate2Factory {\n  // mapping to track which addresses have already been deployed.\n  mapping(address => bool) private _deployed;\n\n  /**\n   * @dev Create a contract using CREATE2 by submitting a given salt or nonce\n   * along with the initialization code for the contract. Note that the first 20\n   * bytes of the salt must match those of the calling address, which prevents\n   * contract creation events from being submitted by unintended parties.\n   * @param salt bytes32 The nonce that will be passed into the CREATE2 call.\n   * @param initializationCode bytes The initialization code that will be passed\n   * into the CREATE2 call.\n   * @return Address of the contract that will be created, or the null address\n   * if a contract already exists at that address.\n   */\n  function safeCreate2(\n    bytes32 salt,\n    bytes calldata initializationCode\n  ) external payable containsCaller(salt) returns (address deploymentAddress) {\n    // move the initialization code from calldata to memory.\n    bytes memory initCode = initializationCode;\n\n    // determine the target address for contract deployment.\n    address targetDeploymentAddress = address(\n      uint160(                    // downcast to match the address type.\n        uint256(                  // convert to uint to truncate upper digits.\n          keccak256(              // compute the CREATE2 hash using 4 inputs.\n            abi.encodePacked(     // pack all inputs to the hash together.\n              hex\"ff\",            // start with 0xff to distinguish from RLP.\n              address(this),      // this contract will be the caller.\n              salt,               // pass in the supplied salt value.\n              keccak256(          // pass in the hash of initialization code.\n                abi.encodePacked(\n                  initCode\n                )\n              )\n            )\n          )\n        )\n      )\n    );\n\n    // ensure that a contract hasn't been previously deployed to target address.\n    require(\n      !_deployed[targetDeploymentAddress],\n      \"Invalid contract creation - contract has already been deployed.\"\n    );\n\n    // using inline assembly: load data and length of data, then call CREATE2.\n    assembly {                                // solhint-disable-line\n      let encoded_data := add(0x20, initCode) // load initialization code.\n      let encoded_size := mload(initCode)     // load the init code's length.\n      deploymentAddress := create2(           // call CREATE2 with 4 arguments.\n        callvalue,                            // forward any attached value.\n        encoded_data,                         // pass in initialization code.\n        encoded_size,                         // pass in init code's length.\n        salt                                  // pass in the salt value.\n      )\n    }\n\n    // check address against target to ensure that deployment was successful.\n    require(\n      deploymentAddress == targetDeploymentAddress,\n      \"Failed to deploy contract using provided salt and initialization code.\"\n    );\n\n    // record the deployment of the contract to prevent redeploys.\n    _deployed[deploymentAddress] = true;\n  }\n\n  /**\n   * @dev Compute the address of the contract that will be created when\n   * submitting a given salt or nonce to the contract along with the contract's\n   * initialization code. The CREATE2 address is computed in accordance with\n   * EIP-1014, and adheres to the formula therein of\n   * `keccak256( 0xff ++ address ++ salt ++ keccak256(init_code)))[12:]` when\n   * performing the computation. The computed address is then checked for any\n   * existing contract code - if so, the null address will be returned instead.\n   * @param salt bytes32 The nonce passed into the CREATE2 address calculation.\n   * @param initCode bytes The contract initialization code to be used.\n   * that will be passed into the CREATE2 address calculation.\n   * @return Address of the contract that will be created, or the null address\n   * if a contract has already been deployed to that address.\n   */\n  function findCreate2Address(\n    bytes32 salt,\n    bytes calldata initCode\n  ) external view returns (address deploymentAddress) {\n    // determine the address where the contract will be deployed.\n    deploymentAddress = address(\n      uint160(                      // downcast to match the address type.\n        uint256(                    // convert to uint to truncate upper digits.\n          keccak256(                // compute the CREATE2 hash using 4 inputs.\n            abi.encodePacked(       // pack all inputs to the hash together.\n              hex\"ff\",              // start with 0xff to distinguish from RLP.\n              address(this),        // this contract will be the caller.\n              salt,                 // pass in the supplied salt value.\n              keccak256(            // pass in the hash of initialization code.\n                abi.encodePacked(\n                  initCode\n                )\n              )\n            )\n          )\n        )\n      )\n    );\n\n    // return null address to signify failure if contract has been deployed.\n    if (_deployed[deploymentAddress]) {\n      return address(0);\n    }\n  }\n\n  /**\n   * @dev Compute the address of the contract that will be created when\n   * submitting a given salt or nonce to the contract along with the keccak256\n   * hash of the contract's initialization code. The CREATE2 address is computed\n   * in accordance with EIP-1014, and adheres to the formula therein of\n   * `keccak256( 0xff ++ address ++ salt ++ keccak256(init_code)))[12:]` when\n   * performing the computation. The computed address is then checked for any\n   * existing contract code - if so, the null address will be returned instead.\n   * @param salt bytes32 The nonce passed into the CREATE2 address calculation.\n   * @param initCodeHash bytes32 The keccak256 hash of the initialization code\n   * that will be passed into the CREATE2 address calculation.\n   * @return Address of the contract that will be created, or the null address\n   * if a contract has already been deployed to that address.\n   */\n  function findCreate2AddressViaHash(\n    bytes32 salt,\n    bytes32 initCodeHash\n  ) external view returns (address deploymentAddress) {\n    // determine the address where the contract will be deployed.\n    deploymentAddress = address(\n      uint160(                      // downcast to match the address type.\n        uint256(                    // convert to uint to truncate upper digits.\n          keccak256(                // compute the CREATE2 hash using 4 inputs.\n            abi.encodePacked(       // pack all inputs to the hash together.\n              hex\"ff\",              // start with 0xff to distinguish from RLP.\n              address(this),        // this contract will be the caller.\n              salt,                 // pass in the supplied salt value.\n              initCodeHash          // pass in the hash of initialization code.\n            )\n          )\n        )\n      )\n    );\n\n    // return null address to signify failure if contract has been deployed.\n    if (_deployed[deploymentAddress]) {\n      return address(0);\n    }\n  }\n\n  /**\n   * @dev Determine if a contract has already been deployed by the factory to a\n   * given address.\n   * @param deploymentAddress address The contract address to check.\n   * @return True if the contract has been deployed, false otherwise.\n   */\n  function hasBeenDeployed(\n    address deploymentAddress\n  ) external view returns (bool) {\n    // determine if a contract has been deployed to the provided address.\n    return _deployed[deploymentAddress];\n  }\n\n  /**\n   * @dev Modifier to ensure that the first 20 bytes of a submitted salt match\n   * those of the calling account. This provides protection against the salt\n   * being stolen by frontrunners or other attackers. The protection can also be\n   * bypassed if desired by setting each of the first 20 bytes to zero.\n   * @param salt bytes32 The salt value to check against the calling address.\n   */\n  modifier containsCaller(bytes32 salt) {\n    // prevent contract submissions from being stolen from tx.pool by requiring\n    // that first 20 bytes of the submitted salt match msg.sender or are empty.\n    require(\n      (address(bytes20(salt)) == msg.sender) ||\n      (bytes20(salt) == bytes20(0)),\n      \"Invalid salt - first 20 bytes of the salt must match calling address.\"\n    );\n    _;\n  }\n}",
  "bytecode": "608060405234801561001057600080fd5b506107e6806100206000396000f3fe60806040526004361061003f5760003560e01c806308508b8f1461004457806364e030871461009857806385cf97ab14610138578063a49a7c90146101bc575b600080fd5b34801561005057600080fd5b506100846004803603602081101561006757600080fd5b503573ffffffffffffffffffffffffffffffffffffffff166101ec565b604080519115158252519081900360200190f35b61010f600480360360408110156100ae57600080fd5b813591908101906040810160208201356401000000008111156100d057600080fd5b8201836020820111156100e257600080fd5b8035906020019184600183028401116401000000008311171561010457600080fd5b509092509050610217565b6040805173ffffffffffffffffffffffffffffffffffffffff9092168252519081900360200190f35b34801561014457600080fd5b5061010f6004803603604081101561015b57600080fd5b8135919081019060408101602082013564010000000081111561017d57600080fd5b82018360208201111561018f57600080fd5b803590602001918460018302840111640100000000831117156101b157600080fd5b509092509050610572565b3480156101c857600080fd5b5061010f600480360360408110156101df57600080fd5b508035906020013561065a565b73ffffffffffffffffffffffffffffffffffffffff1660009081526020819052604090205460ff1690565b600083606081901c33148061024c57507fffffffffffffffffffffffffffffffffffffffff0000000000000000000000008116155b6102a1576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260458152602001806107306045913960600191505060405180910390fd5b606084848080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920182905250604051855195965090943094508b93508692506020918201918291908401908083835b6020831061033557805182527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe090920191602091820191016102f8565b51815160209384036101000a7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff018019909216911617905260408051929094018281037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe00183528085528251928201929092207fff000000000000000000000000000000000000000000000000000000000000008383015273ffffffffffffffffffffffffffffffffffffffff98891660601b6021840152603583019790975260558083019790975283518083039097018752607590910183528551958101959095209586166000908152948590525090922054929350505060ff1615610487576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252603f8152602001806106f1603f913960400191505060405180910390fd5b81602001825188818334f5955050508073ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff161461051a576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260468152602001806107756046913960600191505060405180910390fd5b50505073ffffffffffffffffffffffffffffffffffffffff8116600090815260208190526040902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001660011790559392505050565b6000308484846040516020018083838082843760408051919093018181037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe001825280845281516020928301207fff000000000000000000000000000000000000000000000000000000000000008383015273ffffffffffffffffffffffffffffffffffffffff998a1660601b602183015260358201989098526055808201989098528351808203909801885260750183528651968101969096209687166000908152958690525090932054939450505060ff909116159050610653575060005b9392505050565b604080517fff000000000000000000000000000000000000000000000000000000000000006020808301919091523060601b6021830152603582018590526055808301859052835180840390910181526075909201835281519181019190912073ffffffffffffffffffffffffffffffffffffffff81166000908152918290529190205460ff16156106ea575060005b9291505056fe496e76616c696420636f6e7472616374206372656174696f6e202d20636f6e74726163742068617320616c7265616479206265656e206465706c6f7965642e496e76616c69642073616c74202d206669727374203230206279746573206f66207468652073616c74206d757374206d617463682063616c6c696e6720616464726573732e4661696c656420746f206465706c6f7920636f6e7472616374207573696e672070726f76696465642073616c7420616e6420696e697469616c697a6174696f6e20636f64652ea165627a7a72305820a2f367298b22aaee45f2d5513daa15eb1766546ca48056e28fbe04aed0f73bff0029"
}