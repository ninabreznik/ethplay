{
  "address": "0xf238f55ede5120915b36715b0fffe20ff57f8134",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "ZodiacERC20",
  "compilerVersion": "v0.4.24+commit.e67f0147",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2018-08-28\n*/\n\npragma solidity ^0.4.24;\n\ncontract Ownable {\n    address public owner;\n\n    function Ownable()\n        public\n    {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function transferOwnership(address newOwner)\n        public\n        onlyOwner\n    {\n        if (newOwner != address(0)) {\n            owner = newOwner;\n        }\n    }\n}\n\nlibrary SafeMath {\n    function safeMul(uint a, uint b)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint c = a * b;\n        assert(a == 0 || c / a == b);\n        return c;\n    }\n\n    function safeDiv(uint a, uint b)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint c = a / b;\n        return c;\n    }\n\n    function safeSub(uint a, uint b)\n        internal\n        pure\n        returns (uint256)\n    {\n        assert(b <= a);\n        return a - b;\n    }\n\n    function safeAdd(uint a, uint b)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint c = a + b;\n        assert(c >= a);\n        return c;\n    }\n\n    function max64(uint64 a, uint64 b)\n        internal\n        pure\n        returns (uint256)\n    {\n        return a >= b ? a : b;\n    }\n\n    function min64(uint64 a, uint64 b)\n        internal\n        pure\n        returns (uint256)\n    {\n        return a < b ? a : b;\n    }\n\n    function max256(uint256 a, uint256 b)\n        internal\n        pure\n        returns (uint256)\n    {\n        return a >= b ? a : b;\n    }\n\n    function min256(uint256 a, uint256 b)\n        internal\n        pure\n        returns (uint256)\n    {\n        return a < b ? a : b;\n    }\n}\n\n\n/**\n * @title BytesToTypes\n * @dev The BytesToTypes contract converts the memory byte arrays to the standard solidity types\n */\n\ncontract BytesToTypes {\n\n\n    function bytesToAddress(uint _offst, bytes memory _input) internal pure returns (address _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToBool(uint _offst, bytes memory _input) internal pure returns (bool _output) {\n\n        uint8 x;\n        assembly {\n            x := mload(add(_input, _offst))\n        }\n        x==0 ? _output = false : _output = true;\n    }\n\n    function getStringSize(uint _offst, bytes memory _input) internal pure returns(uint size){\n\n        assembly{\n\n            size := mload(add(_input,_offst))\n            let chunk_count := add(div(size,32),1) // chunk_count = size/32 + 1\n\n            if gt(mod(size,32),0) {// if size%32 > 0\n                chunk_count := add(chunk_count,1)\n            }\n\n             size := mul(chunk_count,32)// first 32 bytes reseves for size in strings\n        }\n    }\n\n    function bytesToString(uint _offst, bytes memory _input, bytes memory _output) internal  {\n\n        uint size = 32;\n        assembly {\n            let loop_index:= 0\n\n            let chunk_count\n\n            size := mload(add(_input,_offst))\n            chunk_count := add(div(size,32),1) // chunk_count = size/32 + 1\n\n            if gt(mod(size,32),0) {\n                chunk_count := add(chunk_count,1)  // chunk_count++\n            }\n\n\n            loop:\n                mstore(add(_output,mul(loop_index,32)),mload(add(_input,_offst)))\n                _offst := sub(_offst,32)           // _offst -= 32\n                loop_index := add(loop_index,1)\n\n            jumpi(loop , lt(loop_index , chunk_count))\n\n        }\n    }\n\n    function slice(bytes _bytes, uint _start, uint _length) internal  pure returns (bytes) {\n        require(_bytes.length >= (_start + _length));\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n\n    function bytesToBytes32(uint _offst, bytes memory  _input) internal pure returns (bytes32 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt8(uint _offst, bytes memory  _input) internal pure returns (int8 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt16(uint _offst, bytes memory _input) internal pure returns (int16 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt24(uint _offst, bytes memory _input) internal pure returns (int24 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt32(uint _offst, bytes memory _input) internal pure returns (int32 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt40(uint _offst, bytes memory _input) internal pure returns (int40 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt48(uint _offst, bytes memory _input) internal pure returns (int48 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt56(uint _offst, bytes memory _input) internal pure returns (int56 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt64(uint _offst, bytes memory _input) internal pure returns (int64 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt72(uint _offst, bytes memory _input) internal pure returns (int72 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt80(uint _offst, bytes memory _input) internal pure returns (int80 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt88(uint _offst, bytes memory _input) internal pure returns (int88 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt96(uint _offst, bytes memory _input) internal pure returns (int96 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n\tfunction bytesToInt104(uint _offst, bytes memory _input) internal pure returns (int104 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt112(uint _offst, bytes memory _input) internal pure returns (int112 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt120(uint _offst, bytes memory _input) internal pure returns (int120 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt128(uint _offst, bytes memory _input) internal pure returns (int128 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt136(uint _offst, bytes memory _input) internal pure returns (int136 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt144(uint _offst, bytes memory _input) internal pure returns (int144 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt152(uint _offst, bytes memory _input) internal pure returns (int152 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt160(uint _offst, bytes memory _input) internal pure returns (int160 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt168(uint _offst, bytes memory _input) internal pure returns (int168 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt176(uint _offst, bytes memory _input) internal pure returns (int176 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt184(uint _offst, bytes memory _input) internal pure returns (int184 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt192(uint _offst, bytes memory _input) internal pure returns (int192 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt200(uint _offst, bytes memory _input) internal pure returns (int200 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt208(uint _offst, bytes memory _input) internal pure returns (int208 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt216(uint _offst, bytes memory _input) internal pure returns (int216 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt224(uint _offst, bytes memory _input) internal pure returns (int224 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt232(uint _offst, bytes memory _input) internal pure returns (int232 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt240(uint _offst, bytes memory _input) internal pure returns (int240 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt248(uint _offst, bytes memory _input) internal pure returns (int248 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt256(uint _offst, bytes memory _input) internal pure returns (int256 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n\tfunction bytesToUint8(uint _offst, bytes memory _input) internal pure returns (uint8 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n\tfunction bytesToUint16(uint _offst, bytes memory _input) internal pure returns (uint16 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n\tfunction bytesToUint24(uint _offst, bytes memory _input) internal pure returns (uint24 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n\tfunction bytesToUint32(uint _offst, bytes memory _input) internal pure returns (uint32 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n\tfunction bytesToUint40(uint _offst, bytes memory _input) internal pure returns (uint40 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n\tfunction bytesToUint48(uint _offst, bytes memory _input) internal pure returns (uint48 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n\tfunction bytesToUint56(uint _offst, bytes memory _input) internal pure returns (uint56 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n\tfunction bytesToUint64(uint _offst, bytes memory _input) internal pure returns (uint64 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n\tfunction bytesToUint72(uint _offst, bytes memory _input) internal pure returns (uint72 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n\tfunction bytesToUint80(uint _offst, bytes memory _input) internal pure returns (uint80 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n\tfunction bytesToUint88(uint _offst, bytes memory _input) internal pure returns (uint88 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n\tfunction bytesToUint96(uint _offst, bytes memory _input) internal pure returns (uint96 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n\tfunction bytesToUint104(uint _offst, bytes memory _input) internal pure returns (uint104 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint112(uint _offst, bytes memory _input) internal pure returns (uint112 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint120(uint _offst, bytes memory _input) internal pure returns (uint120 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint128(uint _offst, bytes memory _input) internal pure returns (uint128 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint136(uint _offst, bytes memory _input) internal pure returns (uint136 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint144(uint _offst, bytes memory _input) internal pure returns (uint144 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint152(uint _offst, bytes memory _input) internal pure returns (uint152 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint160(uint _offst, bytes memory _input) internal pure returns (uint160 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint168(uint _offst, bytes memory _input) internal pure returns (uint168 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint176(uint _offst, bytes memory _input) internal pure returns (uint176 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint184(uint _offst, bytes memory _input) internal pure returns (uint184 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint192(uint _offst, bytes memory _input) internal pure returns (uint192 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint200(uint _offst, bytes memory _input) internal pure returns (uint200 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint208(uint _offst, bytes memory _input) internal pure returns (uint208 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint216(uint _offst, bytes memory _input) internal pure returns (uint216 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint224(uint _offst, bytes memory _input) internal pure returns (uint224 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint232(uint _offst, bytes memory _input) internal pure returns (uint232 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint240(uint _offst, bytes memory _input) internal pure returns (uint240 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint248(uint _offst, bytes memory _input) internal pure returns (uint248 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToUint256(uint _offst, bytes memory _input) internal pure returns (uint256 _output) {\n\n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n}\n\ninterface ITradeable {\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return The balance\n    function balanceOf(address _owner) external view returns (uint balance);\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return Whether the transfer was successful or not\n    function transfer(address _to, uint _value) external returns (bool success);\n\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\n\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of wei to be approved for transfer\n    /// @return Whether the approval was successful or not\n    function approve(address _spender, uint _value) external returns (bool success);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens allowed to spent\n    function allowance(address _owner, address _spender) external view returns (uint remaining);\n}\n\n\ncontract ITrader {\n\n  function getDataLength(\n  ) public pure returns (uint256);\n\n  function getProtocol(\n  ) public pure returns (uint8);\n\n  function getAvailableVolume(\n    bytes orderData\n  ) public view returns(uint);\n\n  function isExpired(\n    bytes orderData\n  ) public view returns (bool);\n\n  function trade(\n    bool isSell,\n    bytes orderData,\n    uint volume,\n    uint volumeEth\n  ) public;\n\n  function getFillVolumes(\n    bool isSell,\n    bytes orderData,\n    uint volume,\n    uint volumeEth\n  ) public view returns(uint, uint);\n\n}\n\ncontract ITraders {\n\n  /// @dev Add a valid trader address. Only owner.\n  function addTrader(uint8 id, ITrader trader) public;\n\n  /// @dev Remove a trader address. Only owner.\n  function removeTrader(uint8 id) public;\n\n  /// @dev Get trader by id.\n  function getTrader(uint8 id) public view returns(ITrader);\n\n  /// @dev Check if an address is a valid trader.\n  function isValidTraderAddress(address addr) public view returns(bool);\n\n}\n\ncontract Members is Ownable {\n\n  mapping(address => bool) public members; // Mappings of addresses of allowed addresses\n\n  modifier onlyMembers() {\n    require(isValidMember(msg.sender));\n    _;\n  }\n\n  /// @dev Check if an address is a valid member.\n  function isValidMember(address _member) public view returns(bool) {\n    return members[_member];\n  }\n\n  /// @dev Add a valid member address. Only owner.\n  function addMember(address _member) public onlyOwner {\n    members[_member] = true;\n  }\n\n  /// @dev Remove a member address. Only owner.\n  function removeMember(address _member) public onlyOwner {\n    delete members[_member];\n  }\n}\n\ncontract ZodiacERC20 is Ownable, BytesToTypes {\n  ITraders public traders; // Smart contract that hold the list of valid traders\n  bool public tradingEnabled; // Switch to enable or disable the contract\n  uint feePercentage;\n  event Sell(\n    address account,\n    address destinationAddr,\n    address traedeable,\n    uint volume,\n    uint volumeEth,\n    uint volumeEffective,\n    uint volumeEthEffective\n  );\n  event Buy(\n    address account,\n    address destinationAddr,\n    address traedeable,\n    uint volume,\n    uint volumeEth,\n    uint volumeEffective,\n    uint volumeEthEffective\n  );\n\n\n  function ZodiacERC20(ITraders _traders, uint _feePercentage) public {\n    traders = _traders;\n    tradingEnabled = true;\n    feePercentage = _feePercentage;\n  }\n\n  /// @dev Only accepts payment from smart contract traders.\n  function() public payable {\n  //  require(traders.isValidTraderAddress(msg.sender));\n  }\n\n  function changeFeePercentage(uint _feePercentage) public onlyOwner {\n    feePercentage = _feePercentage;\n  }\n\n  /// @dev Setter for traders smart contract (Only owner)\n  function changeTraders(ITraders _traders) public onlyOwner {\n    traders = _traders;\n  }\n\n  /// @dev Enable/Disable trading with smart contract (Only owner)\n  function changeTradingEnabled(bool enabled) public onlyOwner {\n    tradingEnabled = enabled;\n  }\n\n  /// @dev Buy a token.\n  function buy(\n    ITradeable tradeable,\n    uint volume,\n    bytes ordersData,\n    address destinationAddr,\n    address affiliate\n  ) external payable\n  {\n\n    require(tradingEnabled);\n\n    // Execute the trade (at most fullfilling volume)\n    trade(\n      false,\n      tradeable,\n      volume,\n      ordersData,\n      affiliate\n    );\n\n    // Since our balance before trade was 0. What we bought is our current balance.\n    uint volumeEffective = tradeable.balanceOf(this);\n\n    // We make sure that something was traded\n    require(volumeEffective > 0);\n\n    // Used ethers are: balance_before - balance_after.\n    // And since before call balance=0; then balance_before = msg.value\n    uint volumeEthEffective = SafeMath.safeSub(msg.value, address(this).balance);\n\n    // IMPORTANT: Check that: effective_price <= agreed_price (guarantee a good deal for the buyer)\n    require(\n      SafeMath.safeDiv(volumeEthEffective, volumeEffective) <=\n      SafeMath.safeDiv(msg.value, volume)\n    );\n\n    // Return remaining ethers\n    if(address(this).balance > 0) {\n      destinationAddr.transfer(address(this).balance);\n    }\n\n    // Send the tokens\n    transferTradeable(tradeable, destinationAddr, volumeEffective);\n\n    emit Buy(msg.sender, destinationAddr, tradeable, volume, msg.value, volumeEffective, volumeEthEffective);\n  }\n\n  /// @dev sell a token.\n  function sell(\n    ITradeable tradeable,\n    uint volume,\n    uint volumeEth,\n    bytes ordersData,\n    address destinationAddr,\n    address affiliate\n  ) external\n  {\n    require(tradingEnabled);\n\n    // We transfer to ouselves the user's trading volume, to operate on it\n    // note: Our balance is 0 before this\n    require(tradeable.transferFrom(msg.sender, this, volume));\n\n    // Execute the trade (at most fullfilling volume)\n    trade(\n      true,\n      tradeable,\n      volume,\n      ordersData,\n      affiliate\n    );\n\n    // Check how much we traded. Our balance = volume - tradedVolume\n    // then: tradedVolume = volume - balance\n    uint volumeEffective = SafeMath.safeSub(volume, tradeable.balanceOf(this));\n\n    // We make sure that something was traded\n    require(volumeEffective > 0);\n\n    // Collects service fee\n    uint volumeEthEffective = collectSellFee();\n\n    // IMPORTANT: Check that: effective_price >= agreed_price (guarantee a good deal for the seller)\n    require(\n      SafeMath.safeDiv(volumeEthEffective, volumeEffective) >=\n      SafeMath.safeDiv(volumeEth, volume)\n    );\n\n    // Return remaining volume\n    if (volumeEffective < volume) {\n     transferTradeable(tradeable, destinationAddr, SafeMath.safeSub(volume, volumeEffective));\n    }\n\n    // Send ethers obtained\n    destinationAddr.transfer(volumeEthEffective);\n\n    emit Sell(msg.sender, destinationAddr, tradeable, volume, volumeEth, volumeEffective, volumeEthEffective);\n  }\n\n\n  /// @dev Trade buy or sell orders.\n  function trade(\n    bool isSell,\n    ITradeable tradeable,\n    uint volume,\n    bytes ordersData,\n    address affiliate\n  ) internal\n  {\n    uint remainingVolume = volume;\n    uint offset = ordersData.length;\n\n    while(offset > 0 && remainingVolume > 0) {\n      //Get the trader\n      uint8 protocolId = bytesToUint8(offset, ordersData);\n      ITrader trader = traders.getTrader(protocolId);\n      require(trader != address(0));\n\n      //Get the order data\n      uint dataLength = trader.getDataLength();\n      offset = SafeMath.safeSub(offset, dataLength);\n      bytes memory orderData = slice(ordersData, offset, dataLength);\n\n      //Fill order\n      remainingVolume = fillOrder(\n         isSell,\n         tradeable,\n         trader,\n         remainingVolume,\n         orderData,\n         affiliate\n      );\n    }\n  }\n\n  /// @dev Fills a buy order.\n  function fillOrder(\n    bool isSell,\n    ITradeable tradeable,\n    ITrader trader,\n    uint remaining,\n    bytes memory orderData,\n    address affiliate\n    ) internal returns(uint)\n  {\n\n    //Checks that there is enoughh amount to execute the trade\n    uint volume;\n    uint volumeEth;\n    (volume, volumeEth) = trader.getFillVolumes(\n      isSell,\n      orderData,\n      remaining,\n      address(this).balance\n    );\n\n    if(volume > 0) {\n\n      if(isSell) {\n        //Approve available amount of token to trader\n        require(tradeable.approve(trader, volume));\n      } else {\n        //Collects service fee\n        //TODO: transfer fees after all iteration\n        //volumeEth = collectBuyFee(volumeEth, affiliate);\n        volumeEth = collectFee(volumeEth);\n        address(trader).transfer(volumeEth);\n      }\n\n      //Call trader to trade orders\n      trader.trade(\n        isSell,\n        orderData,\n        volume,\n        volumeEth\n      );\n\n    }\n\n    return SafeMath.safeSub(remaining, volume);\n  }\n\n  /// @dev Transfer tradeables to user account.\n  function transferTradeable(ITradeable tradeable, address account, uint amount) internal {\n    require(tradeable.transfer(account, amount));\n  }\n\n  // @dev Collect service/affiliate fee for a buy\n  function collectFee(uint ethers) internal returns(uint) {\n    uint fee = SafeMath.safeMul(ethers, feePercentage) / (1 ether);\n    owner.transfer(fee);\n    uint remaining = SafeMath.safeSub(ethers, fee);\n    return remaining;\n  }\n\n  // @dev Collect service/affiliate fee for a sell\n  function collectSellFee() internal returns(uint) {\n    uint fee = SafeMath.safeMul(address(this).balance, feePercentage) / (1 ether);\n    owner.transfer(fee);\n    return address(this).balance;\n  }\n\n}",
  "abi": "[{\"constant\":false,\"inputs\":[{\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"changeTradingEnabled\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tradeable\",\"type\":\"address\"},{\"name\":\"volume\",\"type\":\"uint256\"},{\"name\":\"ordersData\",\"type\":\"bytes\"},{\"name\":\"destinationAddr\",\"type\":\"address\"},{\"name\":\"affiliate\",\"type\":\"address\"}],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tradingEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tradeable\",\"type\":\"address\"},{\"name\":\"volume\",\"type\":\"uint256\"},{\"name\":\"volumeEth\",\"type\":\"uint256\"},{\"name\":\"ordersData\",\"type\":\"bytes\"},{\"name\":\"destinationAddr\",\"type\":\"address\"},{\"name\":\"affiliate\",\"type\":\"address\"}],\"name\":\"sell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"traders\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_traders\",\"type\":\"address\"}],\"name\":\"changeTraders\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_feePercentage\",\"type\":\"uint256\"}],\"name\":\"changeFeePercentage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_traders\",\"type\":\"address\"},{\"name\":\"_feePercentage\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"destinationAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"traedeable\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"volume\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"volumeEth\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"volumeEffective\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"volumeEthEffective\",\"type\":\"uint256\"}],\"name\":\"Sell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"destinationAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"traedeable\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"volume\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"volumeEth\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"volumeEffective\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"volumeEthEffective\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"}]",
  "bytecode": "608060405234801561001057600080fd5b50604051604080610f448339810160405280516020909101516000805433600160a060020a031991821617825560018054740100000000000000000000000000000000000000009216600160a060020a039095169490941760a060020a60ff02191617909255600255610ebb90819061008990396000f30060806040526004361061007f5763ffffffff60e060020a60003504166316925ee28114610081578063321a9ab91461009b5780634ada218b146100cc5780638da5cb5b146100f5578063ce68736114610126578063ddbdf24214610168578063eeca2d171461017d578063f2fde38b1461019e578063fae14192146101bf575b005b34801561008d57600080fd5b5061007f60043515156101d7565b61007f600160a060020a0360048035821691602480359260443591820192910135906064358116906084351661022e565b3480156100d857600080fd5b506100e161041e565b604080519115158252519081900360200190f35b34801561010157600080fd5b5061010a61043f565b60408051600160a060020a039092168252519081900360200190f35b34801561013257600080fd5b5061007f60048035600160a060020a03908116916024803592604435926064359283019201359060843581169060a4351661044e565b34801561017457600080fd5b5061010a6106f3565b34801561018957600080fd5b5061007f600160a060020a0360043516610702565b3480156101aa57600080fd5b5061007f600160a060020a0360043516610748565b3480156101cb57600080fd5b5061007f60043561079a565b600054600160a060020a031633146101ee57600080fd5b60018054911515740100000000000000000000000000000000000000000274ff000000000000000000000000000000000000000019909216919091179055565b600154600090819074010000000000000000000000000000000000000000900460ff16151561025c57600080fd5b61029b6000898989898080601f016020809104026020016040519081016040528093929190818152602001838380828437508c94506107b69350505050565b604080517f70a082310000000000000000000000000000000000000000000000000000000081523060048201529051600160a060020a038a16916370a082319160248083019260209291908290030181600087803b1580156102fc57600080fd5b505af1158015610310573d6000803e3d6000fd5b505050506040513d602081101561032657600080fd5b505191506000821161033757600080fd5b610342343031610936565b905061034e3488610948565b6103588284610948565b111561036357600080fd5b6000303111156103a557604051600160a060020a03851690303180156108fc02916000818181858888f193505050501580156103a3573d6000803e3d6000fd5b505b6103b088858461095f565b60408051338152600160a060020a0380871660208301528a16818301526060810189905234608082015260a0810184905260c0810183905290517f4c5de51a00fa52b3d883d5627b5d614583a2f5eec10c63c6efe8a6f1f68b11e39181900360e00190a15050505050505050565b60015474010000000000000000000000000000000000000000900460ff1681565b600054600160a060020a031681565b600154600090819074010000000000000000000000000000000000000000900460ff16151561047c57600080fd5b604080517f23b872dd000000000000000000000000000000000000000000000000000000008152336004820152306024820152604481018a90529051600160a060020a038b16916323b872dd9160648083019260209291908290030181600087803b1580156104ea57600080fd5b505af11580156104fe573d6000803e3d6000fd5b505050506040513d602081101561051457600080fd5b5051151561052157600080fd5b61056060018a8a89898080601f016020809104026020016040519081016040528093929190818152602001838380828437508c94506107b69350505050565b604080517f70a0823100000000000000000000000000000000000000000000000000000000815230600482015290516105f8918a91600160a060020a038d16916370a082319160248083019260209291908290030181600087803b1580156105c757600080fd5b505af11580156105db573d6000803e3d6000fd5b505050506040513d60208110156105f157600080fd5b5051610936565b91506000821161060757600080fd5b61060f6109fe565b905061061b8789610948565b6106258284610948565b101561063057600080fd5b8782101561064c5761064c89856106478b86610936565b61095f565b604051600160a060020a0385169082156108fc029083906000818181858888f19350505050158015610682573d6000803e3d6000fd5b5060408051338152600160a060020a0380871660208301528b1681830152606081018a90526080810189905260a0810184905260c0810183905290517f2182e4add8250752f872eda9b48eab6b84aa81f99ee69c557acfbf103828083c9181900360e00190a1505050505050505050565b600154600160a060020a031681565b600054600160a060020a0316331461071957600080fd5b6001805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b600054600160a060020a0316331461075f57600080fd5b600160a060020a03811615610797576000805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0383161790555b50565b600054600160a060020a031633146107b157600080fd5b600255565b815183906000808060605b6000851180156107d15750600086115b15610929576107e08589610a72565b600154604080517fcb56e40b00000000000000000000000000000000000000000000000000000000815260ff841660048201529051929650600160a060020a039091169163cb56e40b916024808201926020929091908290030181600087803b15801561084c57600080fd5b505af1158015610860573d6000803e3d6000fd5b505050506040513d602081101561087657600080fd5b50519250600160a060020a038316151561088f57600080fd5b82600160a060020a0316633da767886040518163ffffffff1660e060020a028152600401602060405180830381600087803b1580156108cd57600080fd5b505af11580156108e1573d6000803e3d6000fd5b505050506040513d60208110156108f757600080fd5b505191506109058583610936565b9450610912888684610a77565b90506109228b8b8589858c610af8565b95506107c1565b5050505050505050505050565b60008282111561094257fe5b50900390565b600080828481151561095657fe5b04949350505050565b82600160a060020a031663a9059cbb83836040518363ffffffff1660e060020a0281526004018083600160a060020a0316600160a060020a0316815260200182815260200192505050602060405180830381600087803b1580156109c257600080fd5b505af11580156109d6573d6000803e3d6000fd5b505050506040513d60208110156109ec57600080fd5b505115156109f957600080fd5b505050565b600080670de0b6b3a7640000610a2030600160a060020a031631600254610dee565b811515610a2957fe5b60008054604051939092049350600160a060020a039091169183156108fc0291849190818181858888f19350505050158015610a69573d6000803e3d6000fd5b50303191505090565b015190565b606080828401855110151515610a8c57600080fd5b82158015610aa557604051915060208201604052610aef565b6040519150601f8416801560200281840101858101878315602002848b0101015b81831015610ade578051835260209283019201610ac6565b5050858452601f01601f1916604052505b50949350505050565b600080600086600160a060020a031663c228bcc68a878930600160a060020a0316316040518563ffffffff1660e060020a028152600401808515151515815260200180602001848152602001838152602001828103825285818151815260200191508051906020019080838360005b83811015610b7f578181015183820152602001610b67565b50505050905090810190601f168015610bac5780820380516001836020036101000a031916815260200191505b50955050505050506040805180830381600087803b158015610bcd57600080fd5b505af1158015610be1573d6000803e3d6000fd5b505050506040513d6040811015610bf757600080fd5b50805160209091015190925090506000821115610dd7578815610cb35787600160a060020a031663095ea7b388846040518363ffffffff1660e060020a0281526004018083600160a060020a0316600160a060020a0316815260200182815260200192505050602060405180830381600087803b158015610c7757600080fd5b505af1158015610c8b573d6000803e3d6000fd5b505050506040513d6020811015610ca157600080fd5b50511515610cae57600080fd5b610cf7565b610cbc81610e19565b604051909150600160a060020a0388169082156108fc029083906000818181858888f19350505050158015610cf5573d6000803e3d6000fd5b505b86600160a060020a031663e244054a8a8785856040518563ffffffff1660e060020a028152600401808515151515815260200180602001848152602001838152602001828103825285818151815260200191508051906020019080838360005b83811015610d6f578181015183820152602001610d57565b50505050905090810190601f168015610d9c5780820380516001836020036101000a031916815260200191505b5095505050505050600060405180830381600087803b158015610dbe57600080fd5b505af1158015610dd2573d6000803e3d6000fd5b505050505b610de18683610936565b9998505050505050505050565b6000828202831580610e0a5750828482811515610e0757fe5b04145b1515610e1257fe5b9392505050565b6000806000670de0b6b3a7640000610e3385600254610dee565b811515610e3c57fe5b60008054604051939092049450600160a060020a039091169184156108fc0291859190818181858888f19350505050158015610e7c573d6000803e3d6000fd5b50610e878483610936565b9493505050505600a165627a7a723058206f37f45b3b208d5258344f2a7e6f96deb089597dee0bfaab5eef3392489e0b0a002900000000000000000000000046390621186d4e7b20e71f4f7786275ebeb824d40000000000000000000000000000000000000000000000000011c37937e08000",
  "constructorArguments": "00000000000000000000000046390621186d4e7b20e71f4f7786275ebeb824d40000000000000000000000000000000000000000000000000011c37937e08000"
}