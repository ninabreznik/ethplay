{
  "address": "0x2136bbba2edca21afdddee838fff19ea70d10f03",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "EtherDelta",
  "compilerVersion": "v0.3.5-2016-07-21-6610add",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2016-08-04\n*/\n\n//last compiled with soljson-v0.3.5-2016-07-21-6610add.js\n\ncontract SafeMath {\n  //internals\n\n  function safeMul(uint a, uint b) internal returns (uint) {\n    uint c = a * b;\n    assert(a == 0 || c / a == b);\n    return c;\n  }\n\n  function safeSub(uint a, uint b) internal returns (uint) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function safeAdd(uint a, uint b) internal returns (uint) {\n    uint c = a + b;\n    assert(c>=a && c>=b);\n    return c;\n  }\n\n  function assert(bool assertion) internal {\n    if (!assertion) throw;\n  }\n}\n\ncontract Token {\n\n    /// @return total amount of tokens\n    function totalSupply() constant returns (uint256 supply) {}\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return The balance\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return Whether the transfer was successful or not\n    function transfer(address _to, uint256 _value) returns (bool success) {}\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of wei to be approved for transfer\n    /// @return Whether the approval was successful or not\n    function approve(address _spender, uint256 _value) returns (bool success) {}\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens allowed to spent\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n}\n\ncontract StandardToken is Token {\n\n    function transfer(address _to, uint256 _value) returns (bool success) {\n        //Default assumes totalSupply can't be over max (2^256 - 1).\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n        //Replace the if with this one instead.\n        if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n        //if (balances[msg.sender] >= _value && _value > 0) {\n            balances[msg.sender] -= _value;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        } else { return false; }\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n            balances[_to] += _value;\n            balances[_from] -= _value;\n            allowed[_from][msg.sender] -= _value;\n            Transfer(_from, _to, _value);\n            return true;\n        } else { return false; }\n    }\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n      return allowed[_owner][_spender];\n    }\n\n    mapping(address => uint256) balances;\n\n    mapping (address => mapping (address => uint256)) allowed;\n\n    uint256 public totalSupply;\n\n}\n\ncontract ReserveToken is StandardToken, SafeMath {\n    address public minter;\n    function ReserveToken() {\n      minter = msg.sender;\n    }\n    function create(address account, uint amount) {\n      if (msg.sender != minter) throw;\n      balances[account] = safeAdd(balances[account], amount);\n      totalSupply = safeAdd(totalSupply, amount);\n    }\n    function destroy(address account, uint amount) {\n      if (msg.sender != minter) throw;\n      if (balances[account] < amount) throw;\n      balances[account] = safeSub(balances[account], amount);\n      totalSupply = safeSub(totalSupply, amount);\n    }\n}\n\ncontract EtherDelta is SafeMath {\n\n  mapping (address => mapping (address => uint)) tokens; //mapping of token addresses to mapping of account balances\n  //ether balances are held in the token=0 account\n  mapping (bytes32 => uint) orderFills;\n  address public feeAccount;\n  uint public feeMake; //percentage times (1 ether)\n  uint public feeTake; //percentage times (1 ether)\n\n  event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s);\n  event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s);\n  event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give);\n  event Deposit(address token, address user, uint amount, uint balance);\n  event Withdraw(address token, address user, uint amount, uint balance);\n\n  function EtherDelta(address feeAccount_, uint feeMake_, uint feeTake_) {\n    feeAccount = feeAccount_;\n    feeMake = feeMake_;\n    feeTake = feeTake_;\n  }\n\n  function() {\n    throw;\n  }\n\n  function deposit() {\n    tokens[0][msg.sender] = safeAdd(tokens[0][msg.sender], msg.value);\n    Deposit(0, msg.sender, msg.value, tokens[0][msg.sender]);\n  }\n\n  function withdraw(uint amount) {\n    if (msg.value>0) throw;\n    if (tokens[0][msg.sender] < amount) throw;\n    tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], amount);\n    if (!msg.sender.call.value(amount)()) throw;\n    Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);\n  }\n\n  function depositToken(address token, uint amount) {\n    //remember to call Token(address).approve(this, amount) or this contract will not be able to do the transfer on your behalf.\n    if (msg.value>0 || token==0) throw;\n    if (!Token(token).transferFrom(msg.sender, this, amount)) throw;\n    tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender], amount);\n    Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\n  }\n\n  function withdrawToken(address token, uint amount) {\n    if (msg.value>0 || token==0) throw;\n    if (tokens[token][msg.sender] < amount) throw;\n    tokens[token][msg.sender] = safeSub(tokens[token][msg.sender], amount);\n    if (!Token(token).transfer(msg.sender, amount)) throw;\n    Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);\n  }\n\n  function balanceOf(address token, address user) constant returns (uint) {\n    return tokens[token][user];\n  }\n\n  function order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, uint8 v, bytes32 r, bytes32 s) {\n    if (msg.value>0) throw;\n    Order(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender, v, r, s);\n  }\n\n  function trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount) {\n    //amount is in amountGet terms\n    if (msg.value>0) throw;\n    bytes32 hash = sha256(tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n    if (!(\n      ecrecover(hash,v,r,s) == user &&\n      block.number <= expires &&\n      safeAdd(orderFills[hash], amount) <= amountGet &&\n      tokens[tokenGet][msg.sender] >= amount &&\n      tokens[tokenGive][user] >= safeMul(amountGive, amount) / amountGet\n    )) throw;\n    tokens[tokenGet][msg.sender] = safeSub(tokens[tokenGet][msg.sender], amount);\n    tokens[tokenGet][user] = safeAdd(tokens[tokenGet][user], safeMul(amount, ((1 ether) - feeMake)) / (1 ether));\n    tokens[tokenGet][feeAccount] = safeAdd(tokens[tokenGet][feeAccount], safeMul(amount, feeMake) / (1 ether));\n    tokens[tokenGive][user] = safeSub(tokens[tokenGive][user], safeMul(amountGive, amount) / amountGet);\n    tokens[tokenGive][msg.sender] = safeAdd(tokens[tokenGive][msg.sender], safeMul(safeMul(((1 ether) - feeTake), amountGive), amount) / amountGet / (1 ether));\n    tokens[tokenGive][feeAccount] = safeAdd(tokens[tokenGive][feeAccount], safeMul(safeMul(feeTake, amountGive), amount) / amountGet / (1 ether));\n    orderFills[hash] = safeAdd(orderFills[hash], amount);\n    Trade(tokenGet, amount, tokenGive, amountGive * amount / amountGet, user, msg.sender);\n  }\n\n  function testTrade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount, address sender) constant returns(bool) {\n    if (!(\n      tokens[tokenGet][sender] >= amount &&\n      availableVolume(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, user, v, r, s) >= amount\n    )) return false;\n    return true;\n  }\n\n  function availableVolume(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) constant returns(uint) {\n    bytes32 hash = sha256(tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n    if (!(\n      ecrecover(hash,v,r,s) == user &&\n      block.number <= expires\n    )) return 0;\n    uint available1 = safeSub(amountGet, orderFills[hash]);\n    uint available2 = safeMul(tokens[tokenGive][user], amountGet) / amountGive;\n    if (available1<available2) return available1;\n    return available2;\n  }\n\n  function cancelOrder(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) {\n    if (msg.value>0) throw;\n    bytes32 hash = sha256(tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n    if (user!=msg.sender) throw;\n    orderFills[hash] = amountGet;\n    Cancel(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender, v, r, s);\n  }\n}",
  "bytecode": "6060604052604051606080610f3983395060c06040525160805160a05160028054600160a060020a031916909317909255600355600455610ef5806100446000396000f3606060405236156100a35760e060020a60003504630a19b14a81146100ab5780632e1a7d4d146100e2578063338b5dea146100f6578063577863941461012157806365e17c9d1461012a5780636c86888b1461013c57806374e60a48146101ab57806393f0bb51146101de5780639e281a981461020b578063c281309e14610236578063d0e30db01461023f578063f7888aec1461028b578063fb6e155f146102bf575b6103d1610002565b6103d160043560243560443560643560843560a43560c43560e4356101043561012435610144356000600034111561041657610002565b6103d160043560003411156108cd57610002565b6103d16004356024356000341180610117575081600160a060020a03166000145b1561097b57610002565b6103d360035481565b6103e5600254600160a060020a031681565b61040260043560243560443560643560843560a43560c43560e43561010435610124356101443561016435600160a060020a038c8116600090815260208181526040808320938516835292905290812054839010801590610aa9575082610aa68e8e8e8e8e8e8e8e8e8e6102e3565b6103d160043560243560443560643560843560a43560c43560e435610104356101243560006000341115610ab757610002565b6103d160043560243560443560643560843560a43560c43560e435610104356000341115610be757610002565b6103d1600435602435600034118061022c575081600160a060020a03166000145b15610c7357610002565b6103d360045481565b6103d133600160a060020a03166000908152600080516020610ed58339815191526020526040902054610ddf90345b6000828201610ec58482108015906102865750838210155b610627565b6103d3600435602435600160a060020a03828116600090815260208181526040808320938516835292905220545b92915050565b6103d360043560243560443560643560843560a43560c43560e43561010435610124355b600060006000600060028e8e8e8e8e8e6040518087600160a060020a0316606060020a02815260140186815260200185600160a060020a0316606060020a02815260140184815260200183815260200182815260200196505050505050506020604051808303816000866161da5a03f11561000257505060408051805160ff8a166020838101919091528284018a9052606083018990529251909550600160a060020a038b169260019260808082019391829003018187866161da5a03f11561000257505060405151600160a060020a03161480156103c25750894311155b1515610e655760009350610e54565b005b60408051918252519081900360200190f35b60408051600160a060020a03929092168252519081900360200190f35b604080519115158252519081900360200190f35b60028c8c8c8c8c8c6040518087600160a060020a0316606060020a02815260140186815260200185600160a060020a0316606060020a02815260140184815260200183815260200182815260200196505050505050506020604051808303816000866161da5a03f11561000257505060408051805160ff8816602083810191909152828401889052606083018790529251909350600160a060020a038916926001926080818101939182900301816000866161da5a03f11561000257505060405151600160a060020a03161480156104ee5750874311155b801561051357506000818152600160205260409020548b90610510908461026e565b11155b80156105445750600160a060020a038c81166000908152602081815260408083203390941683529290522054829010155b801561058157508a6105568a846105d7565b600160a060020a038c8116600090815260208181526040808320938c16835292905220549190049010155b15156105f257610002565b600160a060020a038d8116600090815260208181526040808320338516845290915280822093909355908816815220546003546106339190670de0b6b3a76400009061068390869083035b6000818302610ec58483148061028657508385830414610627565b600160a060020a038c8116600090815260208181526040808320339094168352929052205461058c90835b6000610ecc838311155b8015156108ca57610002565b600160a060020a038d81166000908152602081815260408083208b8516845290915280822093909355600254909116815220546003546106899190670de0b6b3a7640000906106839086906105d7565b0461026e565b600160a060020a038d8116600090815260208181526040808320600254851684528252808320949094558d83168252818152838220928a1682529190915220546106d8908c61072d8c866105d7565b600160a060020a038b81166000908152602081815260408083208b851684529091528082209390935533909116815220546004546107339190670de0b6b3a7640000908e906107889061078f9084038f6105d7565b0461061d565b600160a060020a038b8116600090815260208181526040808320338516845290915280822093909355600254909116815220546004546107959190670de0b6b3a7640000908e906107889061078f908f6105d7565b040461026e565b876105d7565b600160a060020a038b811660009081526020818152604080832060025490941683529281528282209390935583815260019092529020546107d6908361026e565b600082815260016020908152604091829020929092558051600160a060020a038f811682529281018590528c8316818301528b85028e9004606082015288831660808201523390921660a0830152517f6effdda786735d5033bfad5f53e5131abcced9e52be6c507b62d639685fbed6d9181900360c00190a1505050505050505050505050565b33600160a060020a03166000818152600080516020610ed58339815191526020908152604080832054815193845291830193909352818301849052606082015290517ff341246adaac6f497bc2a656f546ab9e182111d630394f0c57c710a59a2cb5679181900360800190a15b50565b33600160a060020a03166000908152600080516020610ed583398151915260205260409020548190101561090057610002565b33600160a060020a03166000908152600080516020610ed58339815191526020526040902054610930908261061d565b33600160a060020a03166000818152600080516020610ed58339815191526020526040808220939093559151909183919081818185876185025a03f192505050151561085d57610002565b81600160a060020a03166323b872dd3330846040518460e060020a0281526004018084600160a060020a0316815260200183600160a060020a0316815260200182815260200193505050506020604051808303816000876161da5a03f11561000257505060405151151590506109f057610002565b600160a060020a038281166000908152602081815260408083203390941683529290522054610a1f908261026e565b600160a060020a03838116600081815260208181526040808320339095168084529482529182902085905581519283528201929092528082018490526060810192909252517fdcbc1c05240f31ff3ad067ef1ee35ce4997762752e3a095284754544f4c709d79181900360800190a15050565b5060015b9c9b505050505050505050505050565b10155b1515610a9257506000610a96565b60028b8b8b8b8b8b6040518087600160a060020a0316606060020a02815260140186815260200185600160a060020a0316606060020a02815260140184815260200183815260200182815260200196505050505050506020604051808303816000866161da5a03f115610002575050604051519050600160a060020a038581163390911614610b4557610002565b6000818152600160209081526040918290208c90558151600160a060020a038e811682529181018d90528b821681840152606081018b9052608081018a905260a081018990523390911660c082015260ff861660e08201526101008101859052610120810184905290517f1e0b760c386003e9cb9bcf4fcf3997886042859d9b6ed6320e804597fcdb28b0918190036101400190a15050505050505050505050565b60408051600160a060020a038b81168252602082018b905289811682840152606082018990526080820188905260a08201879052331660c082015260ff851660e08201526101008101849052610120810183905290517f91daf02b6d1454acd74c097a67e389a9d9371da3ff51366947022dc36748ce4d918190036101400190a1505050505050505050565b600160a060020a03828116600090815260208181526040808320339094168352929052205481901015610ca557610002565b600160a060020a038281166000908152602081815260408083203390941683529290522054610cd4908261061d565b600160a060020a03838116600081815260208181526040808320339095168084529482528083209590955584517fa9059cbb0000000000000000000000000000000000000000000000000000000081526004810194909452602484018690529351919363a9059cbb9360448181019492939183900301908290876161da5a03f1156100025750506040515115159050610d6c57610002565b600160a060020a03828116600081815260208181526040808320339095168084529482529182902054825193845290830193909352818101849052606082019290925290517ff341246adaac6f497bc2a656f546ab9e182111d630394f0c57c710a59a2cb5679181900360800190a15050565b33600160a060020a03166000818152600080516020610ed58339815191526020908152604080832085905580519283529082019290925234818301526060810192909252517fdcbc1c05240f31ff3ad067ef1ee35ce4997762752e3a095284754544f4c709d79181900360800190a1565b8093505b5050509a9950505050505050505050565b600083815260016020526040902054610e7f908e9061061d565b600160a060020a038d8116600090815260208181526040808320938d16835292905220549092508b90610eb2908f6105d7565b04905080821015610e5057819350610e54565b9392505050565b508082036102b956ad3228b676f7d3cd4284a5443f17f1962b36e491b30a40b2405849e597ba5fb5",
  "constructorArguments": "0000000000000000000000001ed014aec47fae44c9e55bac7662c0b78ae617980000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000aa87bee538000"
}