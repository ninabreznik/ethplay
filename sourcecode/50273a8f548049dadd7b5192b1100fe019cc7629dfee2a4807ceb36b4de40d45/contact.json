{
  "address": "0xbc42b8d87086b7b609f80c1bea0d15a094d5a516",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "WrapConversionRate",
  "compilerVersion": "v0.4.18+commit.9cf6e910",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2018-03-07\n*/\n\npragma solidity 0.4.18;\n\n// File: contracts/ERC20Interface.sol\n\n// https://github.com/ethereum/EIPs/issues/20\ninterface ERC20 {\n    function totalSupply() public view returns (uint supply);\n    function balanceOf(address _owner) public view returns (uint balance);\n    function transfer(address _to, uint _value) public returns (bool success);\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n    function approve(address _spender, uint _value) public returns (bool success);\n    function allowance(address _owner, address _spender) public view returns (uint remaining);\n    function decimals() public view returns(uint digits);\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\n\n// File: contracts/ConversionRatesInterface.sol\n\ninterface ConversionRatesInterface {\n\n    function recordImbalance(\n        ERC20 token,\n        int buyAmount,\n        uint rateUpdateBlock,\n        uint currentBlock\n    )\n        public;\n\n    function getRate(ERC20 token, uint currentBlockNumber, bool buy, uint qty) public view returns(uint);\n    function setQtyStepFunction(ERC20 token, int[] xBuy, int[] yBuy, int[] xSell, int[] ySell) public;\n    function setImbalanceStepFunction(ERC20 token, int[] xBuy, int[] yBuy, int[] xSell, int[] ySell) public;\n    function claimAdmin() public;\n    function addOperator(address newOperator) public;\n    function transferAdmin(address newAdmin) public;\n    function addToken(ERC20 token) public;\n    function setTokenControlInfo(\n        ERC20 token,\n        uint minimalRecordResolution,\n        uint maxPerBlockImbalance,\n        uint maxTotalImbalance\n    ) public;\n    function enableTokenTrade(ERC20 token) public;\n    function getTokenControlInfo(ERC20 token) public view returns(uint, uint, uint);\n}\n\n// File: contracts/Utils.sol\n\n/// @title Kyber constants contract\ncontract Utils {\n\n    ERC20 constant internal ETH_TOKEN_ADDRESS = ERC20(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\n    uint  constant internal PRECISION = (10**18);\n    uint  constant internal MAX_QTY   = (10**28); // 10B tokens\n    uint  constant internal MAX_RATE  = (PRECISION * 10**6); // up to 1M tokens per ETH\n    uint  constant internal MAX_DECIMALS = 18;\n    uint  constant internal ETH_DECIMALS = 18;\n    mapping(address=>uint) internal decimals;\n\n    function setDecimals(ERC20 token) internal {\n        if (token == ETH_TOKEN_ADDRESS) decimals[token] = ETH_DECIMALS;\n        else decimals[token] = token.decimals();\n    }\n\n    function getDecimals(ERC20 token) internal view returns(uint) {\n        if (token == ETH_TOKEN_ADDRESS) return ETH_DECIMALS; // save storage access\n        uint tokenDecimals = decimals[token];\n        // technically, there might be token with decimals 0\n        // moreover, very possible that old tokens have decimals 0\n        // these tokens will just have higher gas fees.\n        if(tokenDecimals == 0) return token.decimals();\n\n        return tokenDecimals;\n    }\n\n    function calcDstQty(uint srcQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\n        require(srcQty <= MAX_QTY);\n        require(rate <= MAX_RATE);\n\n        if (dstDecimals >= srcDecimals) {\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\n            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\n        } else {\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\n            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\n        }\n    }\n\n    function calcSrcQty(uint dstQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\n        require(dstQty <= MAX_QTY);\n        require(rate <= MAX_RATE);\n        \n        //source quantity is rounded up. to avoid dest quantity being too low.\n        uint numerator;\n        uint denominator;\n        if (srcDecimals >= dstDecimals) {\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\n            numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)));\n            denominator = rate;\n        } else {\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\n            numerator = (PRECISION * dstQty);\n            denominator = (rate * (10**(dstDecimals - srcDecimals)));\n        }\n        return (numerator + denominator - 1) / denominator; //avoid rounding down errors\n    }\n}\n\n// File: contracts/PermissionGroups.sol\n\ncontract PermissionGroups {\n\n    address public admin;\n    address public pendingAdmin;\n    mapping(address=>bool) internal operators;\n    mapping(address=>bool) internal alerters;\n    address[] internal operatorsGroup;\n    address[] internal alertersGroup;\n    uint constant internal MAX_GROUP_SIZE = 50;\n\n    function PermissionGroups() public {\n        admin = msg.sender;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin);\n        _;\n    }\n\n    modifier onlyOperator() {\n        require(operators[msg.sender]);\n        _;\n    }\n\n    modifier onlyAlerter() {\n        require(alerters[msg.sender]);\n        _;\n    }\n\n    function getOperators () external view returns(address[]) {\n        return operatorsGroup;\n    }\n\n    function getAlerters () external view returns(address[]) {\n        return alertersGroup;\n    }\n\n    event TransferAdminPending(address pendingAdmin);\n\n    /**\n     * @dev Allows the current admin to set the pendingAdmin address.\n     * @param newAdmin The address to transfer ownership to.\n     */\n    function transferAdmin(address newAdmin) public onlyAdmin {\n        require(newAdmin != address(0));\n        TransferAdminPending(pendingAdmin);\n        pendingAdmin = newAdmin;\n    }\n\n    /**\n     * @dev Allows the current admin to set the admin in one tx. Useful initial deployment.\n     * @param newAdmin The address to transfer ownership to.\n     */\n    function transferAdminQuickly(address newAdmin) public onlyAdmin {\n        require(newAdmin != address(0));\n        TransferAdminPending(newAdmin);\n        AdminClaimed(newAdmin, admin);\n        admin = newAdmin;\n    }\n\n    event AdminClaimed( address newAdmin, address previousAdmin);\n\n    /**\n     * @dev Allows the pendingAdmin address to finalize the change admin process.\n     */\n    function claimAdmin() public {\n        require(pendingAdmin == msg.sender);\n        AdminClaimed(pendingAdmin, admin);\n        admin = pendingAdmin;\n        pendingAdmin = address(0);\n    }\n\n    event AlerterAdded (address newAlerter, bool isAdd);\n\n    function addAlerter(address newAlerter) public onlyAdmin {\n        require(!alerters[newAlerter]); // prevent duplicates.\n        require(alertersGroup.length < MAX_GROUP_SIZE);\n\n        AlerterAdded(newAlerter, true);\n        alerters[newAlerter] = true;\n        alertersGroup.push(newAlerter);\n    }\n\n    function removeAlerter (address alerter) public onlyAdmin {\n        require(alerters[alerter]);\n        alerters[alerter] = false;\n\n        for (uint i = 0; i < alertersGroup.length; ++i) {\n            if (alertersGroup[i] == alerter) {\n                alertersGroup[i] = alertersGroup[alertersGroup.length - 1];\n                alertersGroup.length--;\n                AlerterAdded(alerter, false);\n                break;\n            }\n        }\n    }\n\n    event OperatorAdded(address newOperator, bool isAdd);\n\n    function addOperator(address newOperator) public onlyAdmin {\n        require(!operators[newOperator]); // prevent duplicates.\n        require(operatorsGroup.length < MAX_GROUP_SIZE);\n\n        OperatorAdded(newOperator, true);\n        operators[newOperator] = true;\n        operatorsGroup.push(newOperator);\n    }\n\n    function removeOperator (address operator) public onlyAdmin {\n        require(operators[operator]);\n        operators[operator] = false;\n\n        for (uint i = 0; i < operatorsGroup.length; ++i) {\n            if (operatorsGroup[i] == operator) {\n                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];\n                operatorsGroup.length -= 1;\n                OperatorAdded(operator, false);\n                break;\n            }\n        }\n    }\n}\n\n// File: contracts/Withdrawable.sol\n\n/**\n * @title Contracts that should be able to recover tokens or ethers\n * @author Ilan Doron\n * @dev This allows to recover any tokens or Ethers received in a contract.\n * This will prevent any accidental loss of tokens.\n */\ncontract Withdrawable is PermissionGroups {\n\n    event TokenWithdraw(ERC20 token, uint amount, address sendTo);\n\n    /**\n     * @dev Withdraw all ERC20 compatible tokens\n     * @param token ERC20 The address of the token contract\n     */\n    function withdrawToken(ERC20 token, uint amount, address sendTo) external onlyAdmin {\n        require(token.transfer(sendTo, amount));\n        TokenWithdraw(token, amount, sendTo);\n    }\n\n    event EtherWithdraw(uint amount, address sendTo);\n\n    /**\n     * @dev Withdraw Ethers\n     */\n    function withdrawEther(uint amount, address sendTo) external onlyAdmin {\n        sendTo.transfer(amount);\n        EtherWithdraw(amount, sendTo);\n    }\n}\n\n// File: contracts/VolumeImbalanceRecorder.sol\n\ncontract VolumeImbalanceRecorder is Withdrawable {\n\n    uint constant internal SLIDING_WINDOW_SIZE = 5;\n    uint constant internal POW_2_64 = 2 ** 64;\n\n    struct TokenControlInfo {\n        uint minimalRecordResolution; // can be roughly 1 cent\n        uint maxPerBlockImbalance; // in twei resolution\n        uint maxTotalImbalance; // max total imbalance (between rate updates)\n                            // before halting trade\n    }\n\n    mapping(address => TokenControlInfo) internal tokenControlInfo;\n\n    struct TokenImbalanceData {\n        int  lastBlockBuyUnitsImbalance;\n        uint lastBlock;\n\n        int  totalBuyUnitsImbalance;\n        uint lastRateUpdateBlock;\n    }\n\n    mapping(address => mapping(uint=>uint)) public tokenImbalanceData;\n\n    function VolumeImbalanceRecorder(address _admin) public {\n        require(_admin != address(0));\n        admin = _admin;\n    }\n\n    function setTokenControlInfo(\n        ERC20 token,\n        uint minimalRecordResolution,\n        uint maxPerBlockImbalance,\n        uint maxTotalImbalance\n    )\n        public\n        onlyAdmin\n    {\n        tokenControlInfo[token] =\n            TokenControlInfo(\n                minimalRecordResolution,\n                maxPerBlockImbalance,\n                maxTotalImbalance\n            );\n    }\n\n    function getTokenControlInfo(ERC20 token) public view returns(uint, uint, uint) {\n        return (tokenControlInfo[token].minimalRecordResolution,\n                tokenControlInfo[token].maxPerBlockImbalance,\n                tokenControlInfo[token].maxTotalImbalance);\n    }\n\n    function addImbalance(\n        ERC20 token,\n        int buyAmount,\n        uint rateUpdateBlock,\n        uint currentBlock\n    )\n        internal\n    {\n        uint currentBlockIndex = currentBlock % SLIDING_WINDOW_SIZE;\n        int recordedBuyAmount = int(buyAmount / int(tokenControlInfo[token].minimalRecordResolution));\n\n        int prevImbalance = 0;\n\n        TokenImbalanceData memory currentBlockData =\n            decodeTokenImbalanceData(tokenImbalanceData[token][currentBlockIndex]);\n\n        // first scenario - this is not the first tx in the current block\n        if (currentBlockData.lastBlock == currentBlock) {\n            if (uint(currentBlockData.lastRateUpdateBlock) == rateUpdateBlock) {\n                // just increase imbalance\n                currentBlockData.lastBlockBuyUnitsImbalance += recordedBuyAmount;\n                currentBlockData.totalBuyUnitsImbalance += recordedBuyAmount;\n            } else {\n                // imbalance was changed in the middle of the block\n                prevImbalance = getImbalanceInRange(token, rateUpdateBlock, currentBlock);\n                currentBlockData.totalBuyUnitsImbalance = int(prevImbalance) + recordedBuyAmount;\n                currentBlockData.lastBlockBuyUnitsImbalance += recordedBuyAmount;\n                currentBlockData.lastRateUpdateBlock = uint(rateUpdateBlock);\n            }\n        } else {\n            // first tx in the current block\n            int currentBlockImbalance;\n            (prevImbalance, currentBlockImbalance) = getImbalanceSinceRateUpdate(token, rateUpdateBlock, currentBlock);\n\n            currentBlockData.lastBlockBuyUnitsImbalance = recordedBuyAmount;\n            currentBlockData.lastBlock = uint(currentBlock);\n            currentBlockData.lastRateUpdateBlock = uint(rateUpdateBlock);\n            currentBlockData.totalBuyUnitsImbalance = int(prevImbalance) + recordedBuyAmount;\n        }\n\n        tokenImbalanceData[token][currentBlockIndex] = encodeTokenImbalanceData(currentBlockData);\n    }\n\n    function setGarbageToVolumeRecorder(ERC20 token) internal {\n        for (uint i = 0; i < SLIDING_WINDOW_SIZE; i++) {\n            tokenImbalanceData[token][i] = 0x1;\n        }\n    }\n\n    function getImbalanceInRange(ERC20 token, uint startBlock, uint endBlock) internal view returns(int buyImbalance) {\n        // check the imbalance in the sliding window\n        require(startBlock <= endBlock);\n\n        buyImbalance = 0;\n\n        for (uint windowInd = 0; windowInd < SLIDING_WINDOW_SIZE; windowInd++) {\n            TokenImbalanceData memory perBlockData = decodeTokenImbalanceData(tokenImbalanceData[token][windowInd]);\n\n            if (perBlockData.lastBlock <= endBlock && perBlockData.lastBlock >= startBlock) {\n                buyImbalance += int(perBlockData.lastBlockBuyUnitsImbalance);\n            }\n        }\n    }\n\n    function getImbalanceSinceRateUpdate(ERC20 token, uint rateUpdateBlock, uint currentBlock)\n        internal view\n        returns(int buyImbalance, int currentBlockImbalance)\n    {\n        buyImbalance = 0;\n        currentBlockImbalance = 0;\n        uint latestBlock = 0;\n        int imbalanceInRange = 0;\n        uint startBlock = rateUpdateBlock;\n        uint endBlock = currentBlock;\n\n        for (uint windowInd = 0; windowInd < SLIDING_WINDOW_SIZE; windowInd++) {\n            TokenImbalanceData memory perBlockData = decodeTokenImbalanceData(tokenImbalanceData[token][windowInd]);\n\n            if (perBlockData.lastBlock <= endBlock && perBlockData.lastBlock >= startBlock) {\n                imbalanceInRange += perBlockData.lastBlockBuyUnitsImbalance;\n            }\n\n            if (perBlockData.lastRateUpdateBlock != rateUpdateBlock) continue;\n            if (perBlockData.lastBlock < latestBlock) continue;\n\n            latestBlock = perBlockData.lastBlock;\n            buyImbalance = perBlockData.totalBuyUnitsImbalance;\n            if (uint(perBlockData.lastBlock) == currentBlock) {\n                currentBlockImbalance = perBlockData.lastBlockBuyUnitsImbalance;\n            }\n        }\n\n        if (buyImbalance == 0) {\n            buyImbalance = imbalanceInRange;\n        }\n    }\n\n    function getImbalance(ERC20 token, uint rateUpdateBlock, uint currentBlock)\n        internal view\n        returns(int totalImbalance, int currentBlockImbalance)\n    {\n\n        int resolution = int(tokenControlInfo[token].minimalRecordResolution);\n\n        (totalImbalance, currentBlockImbalance) =\n            getImbalanceSinceRateUpdate(\n                token,\n                rateUpdateBlock,\n                currentBlock);\n\n        totalImbalance *= resolution;\n        currentBlockImbalance *= resolution;\n    }\n\n    function getMaxPerBlockImbalance(ERC20 token) internal view returns(uint) {\n        return tokenControlInfo[token].maxPerBlockImbalance;\n    }\n\n    function getMaxTotalImbalance(ERC20 token) internal view returns(uint) {\n        return tokenControlInfo[token].maxTotalImbalance;\n    }\n\n    function encodeTokenImbalanceData(TokenImbalanceData data) internal pure returns(uint) {\n        // check for overflows\n        require(data.lastBlockBuyUnitsImbalance < int(POW_2_64 / 2));\n        require(data.lastBlockBuyUnitsImbalance > int(-1 * int(POW_2_64) / 2));\n        require(data.lastBlock < POW_2_64);\n        require(data.totalBuyUnitsImbalance < int(POW_2_64 / 2));\n        require(data.totalBuyUnitsImbalance > int(-1 * int(POW_2_64) / 2));\n        require(data.lastRateUpdateBlock < POW_2_64);\n\n        // do encoding\n        uint result = uint(data.lastBlockBuyUnitsImbalance) & (POW_2_64 - 1);\n        result |= data.lastBlock * POW_2_64;\n        result |= (uint(data.totalBuyUnitsImbalance) & (POW_2_64 - 1)) * POW_2_64 * POW_2_64;\n        result |= data.lastRateUpdateBlock * POW_2_64 * POW_2_64 * POW_2_64;\n\n        return result;\n    }\n\n    function decodeTokenImbalanceData(uint input) internal pure returns(TokenImbalanceData) {\n        TokenImbalanceData memory data;\n\n        data.lastBlockBuyUnitsImbalance = int(int64(input & (POW_2_64 - 1)));\n        data.lastBlock = uint(uint64((input / POW_2_64) & (POW_2_64 - 1)));\n        data.totalBuyUnitsImbalance = int(int64((input / (POW_2_64 * POW_2_64)) & (POW_2_64 - 1)));\n        data.lastRateUpdateBlock = uint(uint64((input / (POW_2_64 * POW_2_64 * POW_2_64))));\n\n        return data;\n    }\n}\n\n// File: contracts/ConversionRates.sol\n\ncontract ConversionRates is ConversionRatesInterface, VolumeImbalanceRecorder, Utils {\n\n    // bps - basic rate steps. one step is 1 / 10000 of the rate.\n    struct StepFunction {\n        int[] x; // quantity for each step. Quantity of each step includes previous steps.\n        int[] y; // rate change per quantity step  in bps.\n    }\n\n    struct TokenData {\n        bool listed;  // was added to reserve\n        bool enabled; // whether trade is enabled\n\n        // position in the compact data\n        uint compactDataArrayIndex;\n        uint compactDataFieldIndex;\n\n        // rate data. base and changes according to quantity and reserve balance.\n        // generally speaking. Sell rate is 1 / buy rate i.e. the buy in the other direction.\n        uint baseBuyRate;  // in PRECISION units. see KyberConstants\n        uint baseSellRate; // PRECISION units. without (sell / buy) spread it is 1 / baseBuyRate\n        StepFunction buyRateQtyStepFunction; // in bps. higher quantity - bigger the rate.\n        StepFunction sellRateQtyStepFunction;// in bps. higher the qua\n        StepFunction buyRateImbalanceStepFunction; // in BPS. higher reserve imbalance - bigger the rate.\n        StepFunction sellRateImbalanceStepFunction;\n    }\n\n    /*\n    this is the data for tokenRatesCompactData\n    but solidity compiler optimizer is sub-optimal, and cannot write this structure in a single storage write\n    so we represent it as bytes32 and do the byte tricks ourselves.\n    struct TokenRatesCompactData {\n        bytes14 buy;  // change buy rate of token from baseBuyRate in 10 bps\n        bytes14 sell; // change sell rate of token from baseSellRate in 10 bps\n\n        uint32 blockNumber;\n    } */\n    uint public validRateDurationInBlocks = 10; // rates are valid for this amount of blocks\n    ERC20[] internal listedTokens;\n    mapping(address=>TokenData) internal tokenData;\n    bytes32[] internal tokenRatesCompactData;\n    uint public numTokensInCurrentCompactData = 0;\n    address public reserveContract;\n    uint constant internal NUM_TOKENS_IN_COMPACT_DATA = 14;\n    uint constant internal BYTES_14_OFFSET = (2 ** (8 * NUM_TOKENS_IN_COMPACT_DATA));\n    uint constant internal MAX_STEPS_IN_FUNCTION = 10;\n    int  constant internal MAX_BPS_ADJUSTMENT = 10 ** 11; // 1B %\n    int  constant internal MIN_BPS_ADJUSTMENT = -100 * 100; // cannot go down by more than 100%\n\n    function ConversionRates(address _admin) public VolumeImbalanceRecorder(_admin)\n        { } // solhint-disable-line no-empty-blocks\n\n    function addToken(ERC20 token) public onlyAdmin {\n\n        require(!tokenData[token].listed);\n        tokenData[token].listed = true;\n        listedTokens.push(token);\n\n        if (numTokensInCurrentCompactData == 0) {\n            tokenRatesCompactData.length++; // add new structure\n        }\n\n        tokenData[token].compactDataArrayIndex = tokenRatesCompactData.length - 1;\n        tokenData[token].compactDataFieldIndex = numTokensInCurrentCompactData;\n\n        numTokensInCurrentCompactData = (numTokensInCurrentCompactData + 1) % NUM_TOKENS_IN_COMPACT_DATA;\n\n        setGarbageToVolumeRecorder(token);\n\n        setDecimals(token);\n    }\n\n    function setCompactData(bytes14[] buy, bytes14[] sell, uint blockNumber, uint[] indices) public onlyOperator {\n\n        require(buy.length == sell.length);\n        require(indices.length == buy.length);\n        require(blockNumber <= 0xFFFFFFFF);\n\n        uint bytes14Offset = BYTES_14_OFFSET;\n\n        for (uint i = 0; i < indices.length; i++) {\n            require(indices[i] < tokenRatesCompactData.length);\n            uint data = uint(buy[i]) | uint(sell[i]) * bytes14Offset | (blockNumber * (bytes14Offset * bytes14Offset));\n            tokenRatesCompactData[indices[i]] = bytes32(data);\n        }\n    }\n\n    function setBaseRate(\n        ERC20[] tokens,\n        uint[] baseBuy,\n        uint[] baseSell,\n        bytes14[] buy,\n        bytes14[] sell,\n        uint blockNumber,\n        uint[] indices\n    )\n        public\n        onlyOperator\n    {\n        require(tokens.length == baseBuy.length);\n        require(tokens.length == baseSell.length);\n        require(sell.length == buy.length);\n        require(sell.length == indices.length);\n\n        for (uint ind = 0; ind < tokens.length; ind++) {\n            require(tokenData[tokens[ind]].listed);\n            tokenData[tokens[ind]].baseBuyRate = baseBuy[ind];\n            tokenData[tokens[ind]].baseSellRate = baseSell[ind];\n        }\n\n        setCompactData(buy, sell, blockNumber, indices);\n    }\n\n    function setQtyStepFunction(\n        ERC20 token,\n        int[] xBuy,\n        int[] yBuy,\n        int[] xSell,\n        int[] ySell\n    )\n        public\n        onlyOperator\n    {\n        require(xBuy.length == yBuy.length);\n        require(xSell.length == ySell.length);\n        require(xBuy.length <= MAX_STEPS_IN_FUNCTION);\n        require(xSell.length <= MAX_STEPS_IN_FUNCTION);\n        require(tokenData[token].listed);\n\n        tokenData[token].buyRateQtyStepFunction = StepFunction(xBuy, yBuy);\n        tokenData[token].sellRateQtyStepFunction = StepFunction(xSell, ySell);\n    }\n\n    function setImbalanceStepFunction(\n        ERC20 token,\n        int[] xBuy,\n        int[] yBuy,\n        int[] xSell,\n        int[] ySell\n    )\n        public\n        onlyOperator\n    {\n        require(xBuy.length == yBuy.length);\n        require(xSell.length == ySell.length);\n        require(xBuy.length <= MAX_STEPS_IN_FUNCTION);\n        require(xSell.length <= MAX_STEPS_IN_FUNCTION);\n        require(tokenData[token].listed);\n\n        tokenData[token].buyRateImbalanceStepFunction = StepFunction(xBuy, yBuy);\n        tokenData[token].sellRateImbalanceStepFunction = StepFunction(xSell, ySell);\n    }\n\n    function setValidRateDurationInBlocks(uint duration) public onlyAdmin {\n        validRateDurationInBlocks = duration;\n    }\n\n    function enableTokenTrade(ERC20 token) public onlyAdmin {\n        require(tokenData[token].listed);\n        require(tokenControlInfo[token].minimalRecordResolution != 0);\n        tokenData[token].enabled = true;\n    }\n\n    function disableTokenTrade(ERC20 token) public onlyAlerter {\n        require(tokenData[token].listed);\n        tokenData[token].enabled = false;\n    }\n\n    function setReserveAddress(address reserve) public onlyAdmin {\n        reserveContract = reserve;\n    }\n\n    function recordImbalance(\n        ERC20 token,\n        int buyAmount,\n        uint rateUpdateBlock,\n        uint currentBlock\n    )\n        public\n    {\n        require(msg.sender == reserveContract);\n\n        if (rateUpdateBlock == 0) rateUpdateBlock = getRateUpdateBlock(token);\n\n        return addImbalance(token, buyAmount, rateUpdateBlock, currentBlock);\n    }\n\n    /* solhint-disable function-max-lines */\n    function getRate(ERC20 token, uint currentBlockNumber, bool buy, uint qty) public view returns(uint) {\n        // check if trade is enabled\n        if (!tokenData[token].enabled) return 0;\n        if (tokenControlInfo[token].minimalRecordResolution == 0) return 0; // token control info not set\n\n        // get rate update block\n        bytes32 compactData = tokenRatesCompactData[tokenData[token].compactDataArrayIndex];\n\n        uint updateRateBlock = getLast4Bytes(compactData);\n        if (currentBlockNumber >= updateRateBlock + validRateDurationInBlocks) return 0; // rate is expired\n        // check imbalance\n        int totalImbalance;\n        int blockImbalance;\n        (totalImbalance, blockImbalance) = getImbalance(token, updateRateBlock, currentBlockNumber);\n\n        // calculate actual rate\n        int imbalanceQty;\n        int extraBps;\n        int8 rateUpdate;\n        uint rate;\n\n        if (buy) {\n            // start with base rate\n            rate = tokenData[token].baseBuyRate;\n\n            // add rate update\n            rateUpdate = getRateByteFromCompactData(compactData, token, true);\n            extraBps = int(rateUpdate) * 10;\n            rate = addBps(rate, extraBps);\n\n            // compute token qty\n            qty = getTokenQty(token, rate, qty);\n            imbalanceQty = int(qty);\n            totalImbalance += imbalanceQty;\n\n            // add qty overhead\n            extraBps = executeStepFunction(tokenData[token].buyRateQtyStepFunction, int(qty));\n            rate = addBps(rate, extraBps);\n\n            // add imbalance overhead\n            extraBps = executeStepFunction(tokenData[token].buyRateImbalanceStepFunction, totalImbalance);\n            rate = addBps(rate, extraBps);\n        } else {\n            // start with base rate\n            rate = tokenData[token].baseSellRate;\n\n            // add rate update\n            rateUpdate = getRateByteFromCompactData(compactData, token, false);\n            extraBps = int(rateUpdate) * 10;\n            rate = addBps(rate, extraBps);\n\n            // compute token qty\n            imbalanceQty = -1 * int(qty);\n            totalImbalance += imbalanceQty;\n\n            // add qty overhead\n            extraBps = executeStepFunction(tokenData[token].sellRateQtyStepFunction, int(qty));\n            rate = addBps(rate, extraBps);\n\n            // add imbalance overhead\n            extraBps = executeStepFunction(tokenData[token].sellRateImbalanceStepFunction, totalImbalance);\n            rate = addBps(rate, extraBps);\n        }\n\n        if (abs(totalImbalance) >= getMaxTotalImbalance(token)) return 0;\n        if (abs(blockImbalance + imbalanceQty) >= getMaxPerBlockImbalance(token)) return 0;\n\n        return rate;\n    }\n    /* solhint-enable function-max-lines */\n\n    function getBasicRate(ERC20 token, bool buy) public view returns(uint) {\n        if (buy)\n            return tokenData[token].baseBuyRate;\n        else\n            return tokenData[token].baseSellRate;\n    }\n\n    function getCompactData(ERC20 token) public view returns(uint, uint, byte, byte) {\n        require(tokenData[token].listed);\n\n        uint arrayIndex = tokenData[token].compactDataArrayIndex;\n        uint fieldOffset = tokenData[token].compactDataFieldIndex;\n\n        return (\n            arrayIndex,\n            fieldOffset,\n            byte(getRateByteFromCompactData(tokenRatesCompactData[arrayIndex], token, true)),\n            byte(getRateByteFromCompactData(tokenRatesCompactData[arrayIndex], token, false))\n        );\n    }\n\n    function getTokenBasicData(ERC20 token) public view returns(bool, bool) {\n        return (tokenData[token].listed, tokenData[token].enabled);\n    }\n\n    /* solhint-disable code-complexity */\n    function getStepFunctionData(ERC20 token, uint command, uint param) public view returns(int) {\n        if (command == 0) return int(tokenData[token].buyRateQtyStepFunction.x.length);\n        if (command == 1) return tokenData[token].buyRateQtyStepFunction.x[param];\n        if (command == 2) return int(tokenData[token].buyRateQtyStepFunction.y.length);\n        if (command == 3) return tokenData[token].buyRateQtyStepFunction.y[param];\n\n        if (command == 4) return int(tokenData[token].sellRateQtyStepFunction.x.length);\n        if (command == 5) return tokenData[token].sellRateQtyStepFunction.x[param];\n        if (command == 6) return int(tokenData[token].sellRateQtyStepFunction.y.length);\n        if (command == 7) return tokenData[token].sellRateQtyStepFunction.y[param];\n\n        if (command == 8) return int(tokenData[token].buyRateImbalanceStepFunction.x.length);\n        if (command == 9) return tokenData[token].buyRateImbalanceStepFunction.x[param];\n        if (command == 10) return int(tokenData[token].buyRateImbalanceStepFunction.y.length);\n        if (command == 11) return tokenData[token].buyRateImbalanceStepFunction.y[param];\n\n        if (command == 12) return int(tokenData[token].sellRateImbalanceStepFunction.x.length);\n        if (command == 13) return tokenData[token].sellRateImbalanceStepFunction.x[param];\n        if (command == 14) return int(tokenData[token].sellRateImbalanceStepFunction.y.length);\n        if (command == 15) return tokenData[token].sellRateImbalanceStepFunction.y[param];\n\n        revert();\n    }\n    /* solhint-enable code-complexity */\n\n    function getRateUpdateBlock(ERC20 token) public view returns(uint) {\n        bytes32 compactData = tokenRatesCompactData[tokenData[token].compactDataArrayIndex];\n        return getLast4Bytes(compactData);\n    }\n\n    function getListedTokens() public view returns(ERC20[]) {\n        return listedTokens;\n    }\n\n    function getTokenQty(ERC20 token, uint ethQty, uint rate) internal view returns(uint) {\n        uint dstDecimals = getDecimals(token);\n        uint srcDecimals = ETH_DECIMALS;\n\n        return calcDstQty(ethQty, srcDecimals, dstDecimals, rate);\n    }\n\n    function getLast4Bytes(bytes32 b) internal pure returns(uint) {\n        // cannot trust compiler with not turning bit operations into EXP opcode\n        return uint(b) / (BYTES_14_OFFSET * BYTES_14_OFFSET);\n    }\n\n    function getRateByteFromCompactData(bytes32 data, ERC20 token, bool buy) internal view returns(int8) {\n        uint fieldOffset = tokenData[token].compactDataFieldIndex;\n        uint byteOffset;\n        if (buy)\n            byteOffset = 32 - NUM_TOKENS_IN_COMPACT_DATA + fieldOffset;\n        else\n            byteOffset = 4 + fieldOffset;\n\n        return int8(data[byteOffset]);\n    }\n\n    function executeStepFunction(StepFunction f, int x) internal pure returns(int) {\n        uint len = f.y.length;\n        for (uint ind = 0; ind < len; ind++) {\n            if (x <= f.x[ind]) return f.y[ind];\n        }\n\n        return f.y[len-1];\n    }\n\n    function addBps(uint rate, int bps) internal pure returns(uint) {\n        require(rate <= MAX_RATE);\n        require(bps >= MIN_BPS_ADJUSTMENT);\n        require(bps <= MAX_BPS_ADJUSTMENT);\n\n        uint maxBps = 100 * 100;\n        return (rate * uint(int(maxBps) + bps)) / maxBps;\n    }\n\n    function abs(int x) internal pure returns(uint) {\n        if (x < 0)\n            return uint(-1 * x);\n        else\n            return uint(x);\n    }\n}\n\n// File: contracts/wrapperContracts/WrapperBase.sol\n\ncontract WrapperBase is Withdrawable {\n\n    PermissionGroups wrappedContract;\n\n    struct DataTracker {\n        address [] approveSignatureArray;\n        uint lastSetNonce;\n    }\n\n    DataTracker[] internal dataInstances;\n\n    function WrapperBase(PermissionGroups _wrappedContract, address _admin, uint _numDataInstances) public {\n        require(_wrappedContract != address(0));\n        require(_admin != address(0));\n        wrappedContract = _wrappedContract;\n        admin = _admin;\n\n        for (uint i = 0; i < _numDataInstances; i++){\n            addDataInstance();\n        }\n    }\n\n    function claimWrappedContractAdmin() public onlyOperator {\n        wrappedContract.claimAdmin();\n    }\n\n    function transferWrappedContractAdmin (address newAdmin) public onlyAdmin {\n        wrappedContract.transferAdmin(newAdmin);\n    }\n\n    function addDataInstance() internal {\n        address[] memory add = new address[](0);\n        dataInstances.push(DataTracker(add, 0));\n    }\n\n    function setNewData(uint dataIndex) internal {\n        require(dataIndex < dataInstances.length);\n        dataInstances[dataIndex].lastSetNonce++;\n        dataInstances[dataIndex].approveSignatureArray.length = 0;\n    }\n\n    function addSignature(uint dataIndex, uint signedNonce, address signer) internal returns(bool allSigned) {\n        require(dataIndex < dataInstances.length);\n        require(dataInstances[dataIndex].lastSetNonce == signedNonce);\n\n        for(uint i = 0; i < dataInstances[dataIndex].approveSignatureArray.length; i++) {\n            if (signer == dataInstances[dataIndex].approveSignatureArray[i]) revert();\n        }\n        dataInstances[dataIndex].approveSignatureArray.push(signer);\n\n        if (dataInstances[dataIndex].approveSignatureArray.length == operatorsGroup.length) {\n            allSigned = true;\n        } else {\n            allSigned = false;\n        }\n    }\n\n    function getWrappedContract() public view returns (PermissionGroups _wrappedContract) {\n        return(wrappedContract);\n    }\n\n    function getDataTrackingParameters(uint index) internal view returns (address[], uint) {\n        require(index < dataInstances.length);\n        return(dataInstances[index].approveSignatureArray, dataInstances[index].lastSetNonce);\n    }\n}\n\n// File: contracts/wrapperContracts/WrapConversionRate.sol\n\ncontract WrapConversionRate is WrapperBase {\n\n    ConversionRates conversionRates;\n\n    //add token parameters\n    ERC20     addTokenToken;\n    uint      addTokenMinimalResolution; // can be roughly 1 cent\n    uint      addTokenMaxPerBlockImbalance; // in twei resolution\n    uint      addTokenMaxTotalImbalance;\n\n    //set token control info parameters.\n    ERC20[]     tokenInfoTokenList;\n    uint[]      tokenInfoPerBlockImbalance; // in twei resolution\n    uint[]      tokenInfoMaxTotalImbalance;\n\n    //valid duration\n    uint pendingValidDurationBlocks;\n\n    //data indexes\n    uint constant addTokenDataIndex = 0;\n    uint constant tokenInfoDataIndex = 1;\n    uint constant validDurationIndex = 2;\n    uint constant numDataInstances = 3;\n\n    //general functions\n    function WrapConversionRate(ConversionRates _conversionRates, address _admin) public\n        WrapperBase(PermissionGroups(address(_conversionRates)), _admin, numDataInstances)\n    {\n        require (_conversionRates != address(0));\n        conversionRates = _conversionRates;\n    }\n\n    // add token functions\n    //////////////////////\n    function setAddTokenData(ERC20 token, uint minimalRecordResolution, uint maxPerBlockImbalance, uint maxTotalImbalance) public onlyOperator {\n        require(minimalRecordResolution != 0);\n        require(maxPerBlockImbalance != 0);\n        require(maxTotalImbalance != 0);\n\n        //update data tracking\n        setNewData(addTokenDataIndex);\n\n        addTokenToken = token;\n        addTokenMinimalResolution = minimalRecordResolution; // can be roughly 1 cent\n        addTokenMaxPerBlockImbalance = maxPerBlockImbalance; // in twei resolution\n        addTokenMaxTotalImbalance = maxTotalImbalance;\n    }\n\n    function approveAddTokenData(uint nonce) public onlyOperator {\n        if(addSignature(addTokenDataIndex, nonce, msg.sender)) {\n            // can perform operation.\n            performAddToken();\n        }\n    }\n\n    function performAddToken() internal {\n        conversionRates.addToken(addTokenToken);\n\n        conversionRates.addOperator(this);\n\n        //token control info\n        conversionRates.setTokenControlInfo(\n            addTokenToken,\n            addTokenMinimalResolution,\n            addTokenMaxPerBlockImbalance,\n            addTokenMaxTotalImbalance\n        );\n\n        //step functions\n        int[] memory zeroArr = new int[](1);\n        zeroArr[0] = 0;\n\n        conversionRates.setQtyStepFunction(addTokenToken, zeroArr, zeroArr, zeroArr, zeroArr);\n        conversionRates.setImbalanceStepFunction(addTokenToken, zeroArr, zeroArr, zeroArr, zeroArr);\n\n        conversionRates.enableTokenTrade(addTokenToken);\n\n        conversionRates.removeOperator(this);\n    }\n\n    function getAddTokenParameters() public view\n        returns(uint nonce, ERC20 token, uint minimalRecordResolution, uint maxPerBlockImbalance, uint maxTotalImbalance)\n    {\n        (, nonce) = getDataTrackingParameters(addTokenDataIndex);\n        token = addTokenToken;\n        minimalRecordResolution = addTokenMinimalResolution;\n        maxPerBlockImbalance = addTokenMaxPerBlockImbalance; // in twei resolution\n        maxTotalImbalance = addTokenMaxTotalImbalance;\n        return(nonce, token, minimalRecordResolution, maxPerBlockImbalance, maxTotalImbalance);\n    }\n\n    function getAddTokenSignatures() public view returns (address[] signatures) {\n        uint nonce;\n        (signatures, nonce) = getDataTrackingParameters(addTokenDataIndex);\n        return(signatures);\n    }\n\n    //set token control info\n    ////////////////////////\n    function setTokenInfoData(ERC20 [] tokens, uint[] maxPerBlockImbalanceValues, uint[] maxTotalImbalanceValues)\n        public\n        onlyOperator\n    {\n        require(maxPerBlockImbalanceValues.length == tokens.length);\n        require(maxTotalImbalanceValues.length == tokens.length);\n\n        //update data tracking\n        setNewData(tokenInfoDataIndex);\n\n        tokenInfoTokenList = tokens;\n        tokenInfoPerBlockImbalance = maxPerBlockImbalanceValues;\n        tokenInfoMaxTotalImbalance = maxTotalImbalanceValues;\n    }\n\n    function approveTokenControlInfo(uint nonce) public onlyOperator {\n        if(addSignature(tokenInfoDataIndex, nonce, msg.sender)) {\n            // can perform operation.\n            performSetTokenControlInfo();\n        }\n    }\n\n    function performSetTokenControlInfo() internal {\n        require(tokenInfoTokenList.length == tokenInfoPerBlockImbalance.length);\n        require(tokenInfoTokenList.length == tokenInfoMaxTotalImbalance.length);\n\n        uint minimalRecordResolution;\n\n        for (uint i = 0; i < tokenInfoTokenList.length; i++) {\n            (minimalRecordResolution, , ) =\n                conversionRates.getTokenControlInfo(tokenInfoTokenList[i]);\n            require(minimalRecordResolution != 0);\n\n            conversionRates.setTokenControlInfo(tokenInfoTokenList[i],\n                                                minimalRecordResolution,\n                                                tokenInfoPerBlockImbalance[i],\n                                                tokenInfoMaxTotalImbalance[i]);\n        }\n    }\n\n    function getControlInfoPerToken (uint index) public view returns(ERC20 token, uint _maxPerBlockImbalance, uint _maxTotalImbalance) {\n        require (tokenInfoTokenList.length > index);\n        require (tokenInfoPerBlockImbalance.length > index);\n        require (tokenInfoMaxTotalImbalance.length > index);\n\n        return(tokenInfoTokenList[index], tokenInfoPerBlockImbalance[index], tokenInfoMaxTotalImbalance[index]);\n    }\n\n    function getTokenInfoNumToknes() public view returns(uint numSetTokens) {\n        return tokenInfoTokenList.length;\n    }\n\n    function getTokenInfoData() public view returns(uint nonce, uint numSetTokens, ERC20[] tokenAddress, uint[] maxPerBlock, uint[] maxTotal) {\n        (, nonce) = getDataTrackingParameters(tokenInfoDataIndex);\n        return(nonce, tokenInfoTokenList.length, tokenInfoTokenList, tokenInfoPerBlockImbalance, tokenInfoMaxTotalImbalance);\n    }\n\n    function getTokenInfoSignatures() public view returns (address[] signatures) {\n        uint nonce;\n        (signatures, nonce) = getDataTrackingParameters(tokenInfoDataIndex);\n        return(signatures);\n    }\n\n    function getTokenInfoNonce() public view returns(uint nonce) {\n        address[] memory signatures;\n        (signatures, nonce) = getDataTrackingParameters(tokenInfoDataIndex);\n        return nonce;\n    }\n\n    //valid duration blocks\n    ///////////////////////\n    function setValidDurationData(uint validDurationBlocks) public onlyOperator {\n        require(validDurationBlocks > 5);\n\n        //update data tracking\n        setNewData(validDurationIndex);\n\n        pendingValidDurationBlocks = validDurationBlocks;\n    }\n\n    function approveValidDurationData(uint nonce) public onlyOperator {\n        if(addSignature(validDurationIndex, nonce, msg.sender)) {\n            // can perform operation.\n            conversionRates.setValidRateDurationInBlocks(pendingValidDurationBlocks);\n        }\n    }\n\n    function getValidDurationBlocksData() public view returns(uint validDuration, uint nonce) {\n        (, nonce) = getDataTrackingParameters(validDurationIndex);\n        return(nonce, pendingValidDurationBlocks);\n    }\n\n    function getValidDurationSignatures() public view returns (address[] signatures) {\n        uint nonce;\n        (signatures, nonce) = getDataTrackingParameters(validDurationIndex);\n        return(signatures);\n    }\n}",
  "bytecode": "606060405234156200001057600080fd5b60405160408062002530833981016040528080519190602001805160008054600160a060020a03191633600160a060020a03908116919091178255919350849250839160039190841615156200006557600080fd5b600160a060020a03831615156200007b57600080fd5b5060068054600160a060020a03808616600160a060020a03199283161790925560008054928516929091169190911781555b81811015620000d757620000ce6401000000006200210a6200011882021704565b600101620000ad565b50505050600160a060020a0382161515620000f157600080fd5b5060088054600160a060020a031916600160a060020a0392909216919091179055620002f4565b62000122620001a9565b6000604051805910620001325750595b90808252806020026020018201604052509050600780548060010182816200015b9190620001bb565b91600052602060002090600202016000604080519081016040528481526000602082015291905081518190805162000198929160200190620001ef565b506020820151816001015550505050565b60206040519081016040526000815290565b815481835581811511620001ea57600202816002028360005260206000209182019101620001ea91906200025b565b505050565b82805482825590600052602060002090810192821562000249579160200282015b82811115620002495782518254600160a060020a031916600160a060020a03919091161782556020929092019160019091019062000210565b50620002579291506200028d565b5090565b6200028a91905b8082111562000257576000620002798282620002b4565b506000600182015560020162000262565b90565b6200028a91905b8082111562000257578054600160a060020a031916815560010162000294565b5080546000825590600052602060002090810190620002d49190620002d7565b50565b6200028a91905b80821115620002575760008155600101620002de565b61222c80620003046000396000f3006060604052600436106101715763ffffffff60e060020a600035041663010afc20811461017657806301a12fd31461018b57806326782247146101aa57806327a099d8146101d95780633be1212b1461023f5780633ccdbb2814610255578063408ee7fe1461027e5780634fd1519c1461029d57806350ca6227146102c857806358047913146103c75780635adc0c68146103da5780636aad70b61461042657806370835f6b1461043957806375829def1461044f57806376f9b8d91461046e57806377f50f971461048157806378b8c58c146104945780637acc8678146104b95780637c423f54146104d85780638d7cffb7146104eb5780639870d7fe1461050a578063aaa1f91d14610529578063ac8a584a14610551578063bb78d15914610570578063bd467b6e14610586578063c8d172d614610655578063ce56c45414610668578063e9c268931461068a578063f851a440146106a0578063fd56d4c8146106b3578063ffcab3e9146106ff575b600080fd5b341561018157600080fd5b610189610712565b005b341561019657600080fd5b610189600160a060020a036004351661078e565b34156101b557600080fd5b6101bd6108fe565b604051600160a060020a03909116815260200160405180910390f35b34156101e457600080fd5b6101ec61090d565b60405160208082528190810183818151815260200191508051906020019060200280838360005b8381101561022b578082015183820152602001610213565b505050509050019250505060405180910390f35b341561024a57600080fd5b610189600435610976565b341561026057600080fd5b610189600160a060020a036004358116906024359060443516610a14565b341561028957600080fd5b610189600160a060020a0360043516610b0b565b34156102a857600080fd5b6102b0610c07565b60405191825260208201526040908101905180910390f35b34156102d357600080fd5b6102db610c21565b60405180868152602001858152602001806020018060200180602001848103845287818151815260200191508051906020019060200280838360005b8381101561032f578082015183820152602001610317565b50505050905001848103835286818151815260200191508051906020019060200280838360005b8381101561036e578082015183820152602001610356565b50505050905001848103825285818151815260200191508051906020019060200280838360005b838110156103ad578082015183820152602001610395565b505050509050019850505050505050505060405180910390f35b34156103d257600080fd5b6101bd610d63565b34156103e557600080fd5b6103ed610d72565b604051948552600160a060020a0390931660208501526040808501929092526060840152608083019190915260a0909101905180910390f35b341561043157600080fd5b6101ec610dac565b341561044457600080fd5b610189600435610dca565b341561045a57600080fd5b610189600160a060020a0360043516610e0a565b341561047957600080fd5b6101ec610ea5565b341561048c57600080fd5b610189610eb9565b341561049f57600080fd5b6104a7610f53565b60405190815260200160405180910390f35b34156104c457600080fd5b610189600160a060020a0360043516610f59565b34156104e357600080fd5b6101ec61103b565b34156104f657600080fd5b610189600160a060020a03600435166110a1565b341561051557600080fd5b610189600160a060020a036004351661110c565b341561053457600080fd5b610189600160a060020a03600435166024356044356064356111dc565b341561055c57600080fd5b610189600160a060020a0360043516611260565b341561057b57600080fd5b6101896004356113cc565b341561059157600080fd5b6101896004602481358181019083013580602081810201604051908101604052809392919081815260200183836020028082843782019150505050505091908035906020019082018035906020019080806020026020016040519081016040528093929190818152602001838360200280828437820191505050505050919080359060200190820180359060200190808060200260200160405190810160405280939291908181526020018383602002808284375094965061140c95505050505050565b341561066057600080fd5b6104a7611494565b341561067357600080fd5b610189600435600160a060020a03602435166114af565b341561069557600080fd5b610189600435611542565b34156106ab57600080fd5b6101bd611585565b34156106be57600080fd5b6106c9600435611594565b6040518084600160a060020a0316600160a060020a03168152602001838152602001828152602001935050505060405180910390f35b341561070a57600080fd5b6101ec611630565b600160a060020a03331660009081526002602052604090205460ff16151561073957600080fd5b600654600160a060020a03166377f50f976040518163ffffffff1660e060020a028152600401600060405180830381600087803b151561077857600080fd5b6102c65a03f1151561078957600080fd5b505050565b6000805433600160a060020a039081169116146107aa57600080fd5b600160a060020a03821660009081526003602052604090205460ff1615156107d157600080fd5b50600160a060020a0381166000908152600360205260408120805460ff191690555b6005548110156108fa5781600160a060020a031660058281548110151561081657fe5b600091825260209091200154600160a060020a031614156108f25760058054600019810190811061084357fe5b60009182526020909120015460058054600160a060020a03909216918390811061086957fe5b60009182526020909120018054600160a060020a031916600160a060020a039290921691909117905560058054906108a5906000198301611ff0565b507f5611bf3e417d124f97bf2c788843ea8bb502b66079fbee02158ef30b172cb762826000604051600160a060020a039092168252151560208201526040908101905180910390a16108fa565b6001016107f3565b5050565b600154600160a060020a031681565b610915612014565b600480548060200260200160405190810160405280929190818152602001828054801561096b57602002820191906000526020600020905b8154600160a060020a0316815260019091019060200180831161094d575b505050505090505b90565b600160a060020a03331660009081526002602052604090205460ff16151561099d57600080fd5b6109a960028233611644565b15610a1157600854601054600160a060020a0390911690636c6295b89060405160e060020a63ffffffff84160281526004810191909152602401600060405180830381600087803b15156109fc57600080fd5b6102c65a03f11515610a0d57600080fd5b5050505b50565b60005433600160a060020a03908116911614610a2f57600080fd5b82600160a060020a031663a9059cbb828460006040516020015260405160e060020a63ffffffff8516028152600160a060020a0390921660048301526024820152604401602060405180830381600087803b1515610a8c57600080fd5b6102c65a03f11515610a9d57600080fd5b505050604051805190501515610ab257600080fd5b7f72cb8a894ddb372ceec3d2a7648d86f17d5a15caae0e986c53109b8a9a9385e6838383604051600160a060020a03938416815260208101929092529091166040808301919091526060909101905180910390a1505050565b60005433600160a060020a03908116911614610b2657600080fd5b600160a060020a03811660009081526003602052604090205460ff1615610b4c57600080fd5b60055460329010610b5c57600080fd5b7f5611bf3e417d124f97bf2c788843ea8bb502b66079fbee02158ef30b172cb762816001604051600160a060020a039092168252151560208201526040908101905180910390a1600160a060020a0381166000908152600360205260409020805460ff191660019081179091556005805490918101610bdb8382611ff0565b5060009182526020909120018054600160a060020a031916600160a060020a0392909216919091179055565b600080610c146002611798565b6010549093509150509091565b600080610c2c612014565b610c34612014565b610c3c612014565b610c466001611798565b600d8054919750879250600e600f8284602080820201604051908101604052809291908181526020018280548015610ca757602002820191906000526020600020905b8154600160a060020a03168152600190910190602001808311610c89575b5050505050925081805480602002602001604051908101604052809291908181526020018280548015610cf957602002820191906000526020600020905b815481526020019060010190808311610ce5575b5050505050915080805480602002602001604051908101604052809291908181526020018280548015610d4b57602002820191906000526020600020905b815481526020019060010190808311610d37575b50505050509050945094509450945094509091929394565b600654600160a060020a031690565b6000806000806000610d846000611798565b600954600a54600b54600c54939a600160a060020a0390931699509097509550909350915050565b610db4612014565b6000610dc06000611798565b90925090505b5090565b600160a060020a03331660009081526002602052604090205460ff161515610df157600080fd5b610dfd60008233611644565b15610a1157610a11611856565b60005433600160a060020a03908116911614610e2557600080fd5b600160a060020a0381161515610e3a57600080fd5b6001547f3b81caf78fa51ecbc8acb482fd7012a277b428d9b80f9d156e8a54107496cc4090600160a060020a0316604051600160a060020a03909116815260200160405180910390a160018054600160a060020a031916600160a060020a0392909216919091179055565b610ead612014565b6000610dc06001611798565b60015433600160a060020a03908116911614610ed457600080fd5b6001546000547f65da1cfc2c2e81576ad96afb24a581f8e109b7a403b35cbd3243a1c99efdb9ed91600160a060020a039081169116604051600160a060020a039283168152911660208201526040908101905180910390a16001805460008054600160a060020a0319908116600160a060020a03841617909155169055565b600d5490565b60005433600160a060020a03908116911614610f7457600080fd5b600160a060020a0381161515610f8957600080fd5b7f3b81caf78fa51ecbc8acb482fd7012a277b428d9b80f9d156e8a54107496cc4081604051600160a060020a03909116815260200160405180910390a16000547f65da1cfc2c2e81576ad96afb24a581f8e109b7a403b35cbd3243a1c99efdb9ed908290600160a060020a0316604051600160a060020a039283168152911660208201526040908101905180910390a160008054600160a060020a031916600160a060020a0392909216919091179055565b611043612014565b600580548060200260200160405190810160405280929190818152602001828054801561096b57602002820191906000526020600020908154600160a060020a0316815260019091019060200180831161094d575050505050905090565b60005433600160a060020a039081169116146110bc57600080fd5b600654600160a060020a03166375829def8260405160e060020a63ffffffff8416028152600160a060020a039091166004820152602401600060405180830381600087803b15156109fc57600080fd5b60005433600160a060020a0390811691161461112757600080fd5b600160a060020a03811660009081526002602052604090205460ff161561114d57600080fd5b6004546032901061115d57600080fd5b7f091a7a4b85135fdd7e8dbc18b12fabe5cc191ea867aa3c2e1a24a102af61d58b816001604051600160a060020a039092168252151560208201526040908101905180910390a1600160a060020a0381166000908152600260205260409020805460ff191660019081179091556004805490918101610bdb8382611ff0565b600160a060020a03331660009081526002602052604090205460ff16151561120357600080fd5b82151561120f57600080fd5b81151561121b57600080fd5b80151561122757600080fd5b6112316000611dcc565b60098054600160a060020a031916600160a060020a039590951694909417909355600a91909155600b55600c55565b6000805433600160a060020a0390811691161461127c57600080fd5b600160a060020a03821660009081526002602052604090205460ff1615156112a357600080fd5b50600160a060020a0381166000908152600260205260408120805460ff191690555b6004548110156108fa5781600160a060020a03166004828154811015156112e857fe5b600091825260209091200154600160a060020a031614156113c45760048054600019810190811061131557fe5b60009182526020909120015460048054600160a060020a03909216918390811061133b57fe5b60009182526020909120018054600160a060020a031916600160a060020a03929092169190911790556004805460001901906113779082611ff0565b507f091a7a4b85135fdd7e8dbc18b12fabe5cc191ea867aa3c2e1a24a102af61d58b826000604051600160a060020a039092168252151560208201526040908101905180910390a16108fa565b6001016112c5565b600160a060020a03331660009081526002602052604090205460ff1615156113f357600080fd5b6113ff60018233611644565b15610a1157610a11611e28565b600160a060020a03331660009081526002602052604090205460ff16151561143357600080fd5b825182511461144157600080fd5b825181511461144f57600080fd5b6114596001611dcc565b600d83805161146c929160200190612026565b50600e828051611480929160200190612089565b50600f818051610a0d929160200190612089565b600061149e612014565b6114a86001611798565b9392505050565b60005433600160a060020a039081169116146114ca57600080fd5b600160a060020a03811682156108fc0283604051600060405180830381858888f1935050505015156114fb57600080fd5b7fec47e7ed86c86774d1a72c19f35c639911393fe7c1a34031fdbd260890da90de8282604051918252600160a060020a031660208201526040908101905180910390a15050565b600160a060020a03331660009081526002602052604090205460ff16151561156957600080fd5b6005811161157657600080fd5b6115806002611dcc565b601055565b600054600160a060020a031681565b600d54600090819081908490116115aa57600080fd5b600e548490116115b957600080fd5b600f548490116115c857600080fd5b600d8054859081106115d657fe5b600091825260209091200154600e8054600160a060020a0390921691869081106115fc57fe5b906000526020600020900154600f8681548110151561161757fe5b9060005260206000209001549250925092509193909250565b611638612014565b6000610dc06002611798565b6007546000908190851061165757600080fd5b8360078681548110151561166757fe5b90600052602060002090600202016001015414151561168557600080fd5b5060005b600780548690811061169757fe5b60009182526020909120600290910201548110156117075760078054869081106116bd57fe5b9060005260206000209060020201600001818154811015156116db57fe5b600091825260209091200154600160a060020a03848116911614156116ff57600080fd5b600101611689565b600780548690811061171557fe5b600091825260209091206002909102018054600181016117358382611ff0565b5060009182526020909120018054600160a060020a031916600160a060020a038516179055600454600780548790811061176b57fe5b6000918252602090912060029091020154141561178b5760019150611790565b600091505b509392505050565b6117a0612014565b60075460009083106117b157600080fd5b60078054849081106117bf57fe5b90600052602060002090600202016000016007848154811015156117df57fe5b9060005260206000209060020201600101548180548060200260200160405190810160405280929190818152602001828054801561184657602002820191906000526020600020905b8154600160a060020a03168152600190910190602001808311611828575b5050505050915091509150915091565b61185e612014565b600854600954600160a060020a039182169163d48bfca7911660405160e060020a63ffffffff8416028152600160a060020a039091166004820152602401600060405180830381600087803b15156118b557600080fd5b6102c65a03f115156118c657600080fd5b5050600854600160a060020a03169050639870d7fe3060405160e060020a63ffffffff8416028152600160a060020a039091166004820152602401600060405180830381600087803b151561191a57600080fd5b6102c65a03f1151561192b57600080fd5b5050600854600954600a54600b54600c54600160a060020a03948516955063bfee3569949093169260405160e060020a63ffffffff8716028152600160a060020a039094166004850152602484019290925260448301526064820152608401600060405180830381600087803b15156119a357600080fd5b6102c65a03f115156119b457600080fd5b50505060016040518059106119c65750595b908082528060200260200182016040525090506000816000815181106119e857fe5b60209081029091010152600854600954600160a060020a03918216916380d8b3809116838080806040518663ffffffff1660e060020a0281526004018086600160a060020a0316600160a060020a0316815260200180602001806020018060200180602001858103855289818151815260200191508051906020019060200280838360005b83811015611a85578082015183820152602001611a6d565b50505050905001858103845288818151815260200191508051906020019060200280838360005b83811015611ac4578082015183820152602001611aac565b50505050905001858103835287818151815260200191508051906020019060200280838360005b83811015611b03578082015183820152602001611aeb565b50505050905001858103825286818151815260200191508051906020019060200280838360005b83811015611b42578082015183820152602001611b2a565b505050509050019950505050505050505050600060405180830381600087803b1515611b6d57600080fd5b6102c65a03f11515611b7e57600080fd5b5050600854600954600160a060020a03918216925063bc9cbcc89116838080806040518663ffffffff1660e060020a0281526004018086600160a060020a0316600160a060020a0316815260200180602001806020018060200180602001858103855289818151815260200191508051906020019060200280838360005b83811015611c14578082015183820152602001611bfc565b50505050905001858103845288818151815260200191508051906020019060200280838360005b83811015611c53578082015183820152602001611c3b565b50505050905001858103835287818151815260200191508051906020019060200280838360005b83811015611c92578082015183820152602001611c7a565b50505050905001858103825286818151815260200191508051906020019060200280838360005b83811015611cd1578082015183820152602001611cb9565b505050509050019950505050505050505050600060405180830381600087803b1515611cfc57600080fd5b6102c65a03f11515611d0d57600080fd5b5050600854600954600160a060020a039182169250631d6a8bda911660405160e060020a63ffffffff8416028152600160a060020a039091166004820152602401600060405180830381600087803b1515611d6757600080fd5b6102c65a03f11515611d7857600080fd5b5050600854600160a060020a0316905063ac8a584a3060405160e060020a63ffffffff8416028152600160a060020a039091166004820152602401600060405180830381600087803b15156109fc57600080fd5b6007548110611dda57600080fd5b6007805482908110611de857fe5b60009182526020822060016002909202018101805490910190556007805483908110611e1057fe5b600091825260209091206108fa916002020182611ff0565b600e54600d54600091829114611e3d57600080fd5b600f54600d5414611e4d57600080fd5b5060005b600d548110156108fa57600854600d8054600160a060020a039092169163e7d4fd91919084908110611e7f57fe5b6000918252602082200154600160a060020a0316906040516060015260405160e060020a63ffffffff8416028152600160a060020a039091166004820152602401606060405180830381600087803b1515611ed957600080fd5b6102c65a03f11515611eea57600080fd5b5050506040518051906020018051906020018051509193505050811515611f1057600080fd5b600854600d8054600160a060020a039092169163bfee3569919084908110611f3457fe5b600091825260209091200154600e8054600160a060020a039092169186919086908110611f5d57fe5b906000526020600020900154600f86815481101515611f7857fe5b90600052602060002090015460405160e060020a63ffffffff8716028152600160a060020a039094166004850152602484019290925260448301526064820152608401600060405180830381600087803b1515611fd457600080fd5b6102c65a03f11515611fe557600080fd5b505050600101611e51565b815481835581811511610789576000838152602090206107899181019083016120cc565b60206040519081016040526000815290565b82805482825590600052602060002090810192821561207d579160200282015b8281111561207d5782518254600160a060020a031916600160a060020a039190911617825560209290920191600190910190612046565b50610dc69291506120e6565b8280548282559060005260206000209081019282156120c4579160200282015b828111156120c45782518255916020019190600101906120a9565b50610dc69291505b61097391905b80821115610dc657600081556001016120d2565b61097391905b80821115610dc6578054600160a060020a03191681556001016120ec565b612112612014565b60006040518059106121215750595b90808252806020026020018201604052509050600780548060010182816121489190612194565b916000526020600020906002020160006040805190810160405284815260006020820152919050815181908051612183929160200190612026565b506020820151816001015550505050565b81548183558181151161078957600083815260209020610789916109739160029182028101918502015b80821115610dc65760006121d282826121e2565b50600060018201556002016121be565b5080546000825590600052602060002090810190610a1191906120cc5600a165627a7a723058208cf825c19026399588cc62ee184beeb8b2fe5290fafac27064fcf8b0e77015c20029000000000000000000000000e3e415a7a6c287a95dc68a01ff036828073fd2e6000000000000000000000000a2d8fcba79bd76bbf4bf1051f33d08e37bb11584",
  "constructorArguments": "000000000000000000000000e3e415a7a6c287a95dc68a01ff036828073fd2e6000000000000000000000000a2d8fcba79bd76bbf4bf1051f33d08e37bb11584"
}