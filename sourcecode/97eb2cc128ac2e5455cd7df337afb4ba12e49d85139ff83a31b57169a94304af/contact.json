{
  "address": "0xdfa1468d07fc86840a6eb53e0e65cebde81d1af9",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "RecoveryManager",
  "compilerVersion": "v0.4.24+commit.e67f0147",
  "optimization": true,
  "runs": "999",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2019-02-05\n*/\n\npragma solidity ^0.4.24;\n\n/**\n * @title Module\n * @dev Interface for a module. \n * A module MUST implement the addModule() method to ensure that a wallet with at least one module\n * can never end up in a \"frozen\" state.\n * @author Julien Niset - <[email protected]>\n */\ninterface Module {\n\n    /**\n     * @dev Inits a module for a wallet by e.g. setting some wallet specific parameters in storage.\n     * @param _wallet The wallet.\n     */\n    function init(BaseWallet _wallet) external;\n\n    /**\n     * @dev Adds a module to a wallet.\n     * @param _wallet The target wallet.\n     * @param _module The modules to authorise.\n     */\n    function addModule(BaseWallet _wallet, Module _module) external;\n\n    /**\n    * @dev Utility method to recover any ERC20 token that was sent to the\n    * module by mistake. \n    * @param _token The token to recover.\n    */\n    function recoverToken(address _token) external;\n}\n\n/**\n * @title BaseModule\n * @dev Basic module that contains some methods common to all modules.\n * @author Julien Niset - <[email protected]>\n */\ncontract BaseModule is Module {\n\n    // The adddress of the module registry.\n    ModuleRegistry internal registry;\n\n    event ModuleCreated(bytes32 name);\n    event ModuleInitialised(address wallet);\n\n    constructor(ModuleRegistry _registry, bytes32 _name) public {\n        registry = _registry;\n        emit ModuleCreated(_name);\n    }\n\n    /**\n     * @dev Throws if the sender is not the target wallet of the call.\n     */\n    modifier onlyWallet(BaseWallet _wallet) {\n        require(msg.sender == address(_wallet), \"BM: caller must be wallet\");\n        _;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner of the target wallet or the module itself.\n     */\n    modifier onlyOwner(BaseWallet _wallet) {\n        require(msg.sender == address(this) || isOwner(_wallet, msg.sender), \"BM: must be an owner for the wallet\");\n        _;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner of the target wallet.\n     */\n    modifier strictOnlyOwner(BaseWallet _wallet) {\n        require(isOwner(_wallet, msg.sender), \"BM: msg.sender must be an owner for the wallet\");\n        _;\n    }\n\n    /**\n     * @dev Inits the module for a wallet by logging an event.\n     * The method can only be called by the wallet itself.\n     * @param _wallet The wallet.\n     */\n    function init(BaseWallet _wallet) external onlyWallet(_wallet) {\n        emit ModuleInitialised(_wallet);\n    }\n\n    /**\n     * @dev Adds a module to a wallet. First checks that the module is registered.\n     * @param _wallet The target wallet.\n     * @param _module The modules to authorise.\n     */\n    function addModule(BaseWallet _wallet, Module _module) external strictOnlyOwner(_wallet) {\n        require(registry.isRegisteredModule(_module), \"BM: module is not registered\");\n        _wallet.authoriseModule(_module, true);\n    }\n\n    /**\n    * @dev Utility method enbaling anyone to recover ERC20 token sent to the\n    * module by mistake and transfer them to the Module Registry. \n    * @param _token The token to recover.\n    */\n    function recoverToken(address _token) external {\n        uint total = ERC20(_token).balanceOf(address(this));\n        ERC20(_token).transfer(address(registry), total);\n    }\n\n    /**\n     * @dev Helper method to check if an address is the owner of a target wallet.\n     * @param _wallet The target wallet.\n     * @param _addr The address.\n     */\n    function isOwner(BaseWallet _wallet, address _addr) internal view returns (bool) {\n        return _wallet.owner() == _addr;\n    }\n}\n\n/**\n * @title RelayerModule\n * @dev Base module containing logic to execute transactions signed by eth-less accounts and sent by a relayer. \n * @author Julien Niset - <[email protected]>\n */\ncontract RelayerModule is Module {\n\n    uint256 constant internal BLOCKBOUND = 10000;\n\n    mapping (address => RelayerConfig) public relayer; \n\n    struct RelayerConfig {\n        uint256 nonce;\n        mapping (bytes32 => bool) executedTx;\n    }\n\n    event TransactionExecuted(address indexed wallet, bool indexed success, bytes32 signedHash);\n\n    /**\n     * @dev Throws if the call did not go through the execute() method.\n     */\n    modifier onlyExecute {\n        require(msg.sender == address(this), \"RM: must be called via execute()\");\n        _;\n    }\n\n    /* ***************** Abstract method ************************* */\n\n    /**\n    * @dev Gets the number of valid signatures that must be provided to execute a\n    * specific relayed transaction.\n    * @param _wallet The target wallet.\n    * @param _data The data of the relayed transaction.\n    * @return The number of required signatures.\n    */\n    function getRequiredSignatures(BaseWallet _wallet, bytes _data) internal view returns (uint256);\n\n    /**\n    * @dev Validates the signatures provided with a relayed transaction.\n    * The method MUST throw if one or more signatures are not valid.\n    * @param _wallet The target wallet.\n    * @param _data The data of the relayed transaction.\n    * @param _signHash The signed hash representing the relayed transaction.\n    * @param _signatures The signatures as a concatenated byte array.\n    */\n    function validateSignatures(BaseWallet _wallet, bytes _data, bytes32 _signHash, bytes _signatures) internal view returns (bool);\n\n    /* ************************************************************ */\n\n    /**\n    * @dev Executes a relayed transaction.\n    * @param _wallet The target wallet.\n    * @param _data The data for the relayed transaction\n    * @param _nonce The nonce used to prevent replay attacks.\n    * @param _signatures The signatures as a concatenated byte array.\n    * @param _gasPrice The gas price to use for the gas refund.\n    * @param _gasLimit The gas limit to use for the gas refund.\n    */\n    function execute(\n        BaseWallet _wallet,\n        bytes _data, \n        uint256 _nonce, \n        bytes _signatures, \n        uint256 _gasPrice,\n        uint256 _gasLimit\n    )\n        external\n        returns (bool success)\n    {\n        uint startGas = gasleft();\n        bytes32 signHash = getSignHash(address(this), _wallet, 0, _data, _nonce, _gasPrice, _gasLimit);\n        require(checkAndUpdateUniqueness(_wallet, _nonce, signHash), \"RM: Duplicate request\");\n        require(verifyData(address(_wallet), _data), \"RM: the wallet authorized is different then the target of the relayed data\");\n        uint256 requiredSignatures = getRequiredSignatures(_wallet, _data);\n        if((requiredSignatures * 65) == _signatures.length) {\n            if(verifyRefund(_wallet, _gasLimit, _gasPrice, requiredSignatures)) {\n                if(requiredSignatures == 0 || validateSignatures(_wallet, _data, signHash, _signatures)) {\n                    // solium-disable-next-line security/no-call-value\n                    success = address(this).call(_data);\n                    refund(_wallet, startGas - gasleft(), _gasPrice, _gasLimit, requiredSignatures, msg.sender);\n                }\n            }\n        }\n        emit TransactionExecuted(_wallet, success, signHash); \n    }\n\n    /**\n    * @dev Gets the current nonce for a wallet.\n    * @param _wallet The target wallet.\n    */\n    function getNonce(BaseWallet _wallet) external view returns (uint256 nonce) {\n        return relayer[_wallet].nonce;\n    }\n\n    /**\n    * @dev Generates the signed hash of a relayed transaction according to ERC 1077.\n    * @param _from The starting address for the relayed transaction (should be the module)\n    * @param _to The destination address for the relayed transaction (should be the wallet)\n    * @param _value The value for the relayed transaction\n    * @param _data The data for the relayed transaction\n    * @param _nonce The nonce used to prevent replay attacks.\n    * @param _gasPrice The gas price to use for the gas refund.\n    * @param _gasLimit The gas limit to use for the gas refund.\n    */\n    function getSignHash(\n        address _from,\n        address _to, \n        uint256 _value, \n        bytes _data, \n        uint256 _nonce,\n        uint256 _gasPrice,\n        uint256 _gasLimit\n    ) \n        internal \n        pure\n        returns (bytes32) \n    {\n        return keccak256(\n            abi.encodePacked(\n                \"\\x19Ethereum Signed Message:\\n32\",\n                keccak256(abi.encodePacked(byte(0x19), byte(0), _from, _to, _value, _data, _nonce, _gasPrice, _gasLimit))\n        ));\n    }\n\n    /**\n    * @dev Checks if the relayed transaction is unique.\n    * @param _wallet The target wallet.\n    * @param _nonce The nonce\n    * @param _signHash The signed hash of the transaction\n    */\n    function checkAndUpdateUniqueness(BaseWallet _wallet, uint256 _nonce, bytes32 _signHash) internal returns (bool) {\n        if(relayer[_wallet].executedTx[_signHash] == true) {\n            return false;\n        }\n        relayer[_wallet].executedTx[_signHash] = true;\n        return true;\n    }\n\n    /**\n    * @dev Checks that a nonce has the correct format and is valid. \n    * It must be constructed as nonce = {block number}{timestamp} where each component is 16 bytes.\n    * @param _wallet The target wallet.\n    * @param _nonce The nonce\n    */\n    function checkAndUpdateNonce(BaseWallet _wallet, uint256 _nonce) internal returns (bool) {\n        if(_nonce <= relayer[_wallet].nonce) {\n            return false;\n        }   \n        uint256 nonceBlock = (_nonce & 0xffffffffffffffffffffffffffffffff00000000000000000000000000000000) >> 128;\n        if(nonceBlock > block.number + BLOCKBOUND) {\n            return false;\n        }\n        relayer[_wallet].nonce = _nonce;\n        return true;    \n    }\n\n    /**\n    * @dev Recovers the signer at a given position from a list of concatenated signatures.\n    * @param _signedHash The signed hash\n    * @param _signatures The concatenated signatures.\n    * @param _index The index of the signature to recover.\n    */\n    function recoverSigner(bytes32 _signedHash, bytes _signatures, uint _index) internal pure returns (address) {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        // we jump 32 (0x20) as the first slot of bytes contains the length\n        // we jump 65 (0x41) per signature\n        // for v we load 32 bytes ending with v (the first 31 come from s) then apply a mask\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            r := mload(add(_signatures, add(0x20,mul(0x41,_index))))\n            s := mload(add(_signatures, add(0x40,mul(0x41,_index))))\n            v := and(mload(add(_signatures, add(0x41,mul(0x41,_index)))), 0xff)\n        }\n        require(v == 27 || v == 28); \n        return ecrecover(_signedHash, v, r, s);\n    }\n\n    /**\n    * @dev Refunds the gas used to the Relayer. \n    * For security reasons the default behavior is to not refund calls with 0 or 1 signatures. \n    * @param _wallet The target wallet.\n    * @param _gasUsed The gas used.\n    * @param _gasPrice The gas price for the refund.\n    * @param _gasLimit The gas limit for the refund.\n    * @param _signatures The number of signatures used in the call.\n    * @param _relayer The address of the Relayer.\n    */\n    function refund(BaseWallet _wallet, uint _gasUsed, uint _gasPrice, uint _gasLimit, uint _signatures, address _relayer) internal {\n        uint256 amount = 29292 + _gasUsed; // 21000 (transaction) + 7620 (execution of refund) + 672 to log the event + _gasUsed\n        // only refund if gas price not null, more than 1 signatures, gas less than gasLimit\n        if(_gasPrice > 0 && _signatures > 1 && amount <= _gasLimit) {\n            if(_gasPrice > tx.gasprice) {\n                amount = amount * tx.gasprice;\n            }\n            else {\n                amount = amount * _gasPrice;\n            }\n            _wallet.invoke(_relayer, amount, \"\");\n        }\n    }\n\n    /**\n    * @dev Returns false if the refund is expected to fail.\n    * @param _wallet The target wallet.\n    * @param _gasUsed The expected gas used.\n    * @param _gasPrice The expected gas price for the refund.\n    */\n    function verifyRefund(BaseWallet _wallet, uint _gasUsed, uint _gasPrice, uint _signatures) internal view returns (bool) {\n        if(_gasPrice > 0 \n            && _signatures > 1 \n            && (address(_wallet).balance < _gasUsed * _gasPrice || _wallet.authorised(this) == false)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n    * @dev Checks that the wallet address provided as the first parameter of the relayed data is the same\n    * as the wallet passed as the input of the execute() method. \n    @return false if the addresses are different.\n    */\n    function verifyData(address _wallet, bytes _data) private pure returns (bool) {\n        require(_data.length >= 36, \"RM: Invalid dataWallet\");\n        address dataWallet;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            //_data = {length:32}{sig:4}{_wallet:32}{...}\n            dataWallet := mload(add(_data, 0x24))\n        }\n        return dataWallet == _wallet;\n    }\n\n    /**\n    * @dev Parses the data to extract the method signature. \n    */\n    function functionPrefix(bytes _data) internal pure returns (bytes4 prefix) {\n        require(_data.length >= 4, \"RM: Invalid functionPrefix\");\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            prefix := mload(add(_data, 0x20))\n        }\n    }\n}\n\n/**\n * ERC20 contract interface.\n */\ncontract ERC20 {\n    function totalSupply() public view returns (uint);\n    function decimals() public view returns (uint);\n    function balanceOf(address tokenOwner) public view returns (uint balance);\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n    function transfer(address to, uint tokens) public returns (bool success);\n    function approve(address spender, uint tokens) public returns (bool success);\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n}\n\n/**\n * @title Owned\n * @dev Basic contract to define an owner.\n * @author Julien Niset - <[email protected]>\n */\ncontract Owned {\n\n    // The owner\n    address public owner;\n\n    event OwnerChanged(address indexed _newOwner);\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Must be owner\");\n        _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    /**\n     * @dev Lets the owner transfer ownership of the contract to a new owner.\n     * @param _newOwner The new owner.\n     */\n    function changeOwner(address _newOwner) external onlyOwner {\n        require(_newOwner != address(0), \"Address must not be null\");\n        owner = _newOwner;\n        emit OwnerChanged(_newOwner);\n    }\n}\n\n/**\n * @title ModuleRegistry\n * @dev Registry of authorised modules. \n * Modules must be registered before they can be authorised on a wallet.\n * @author Julien Niset - <[email protected]>\n */\ncontract ModuleRegistry is Owned {\n\n    mapping (address => Info) internal modules;\n    mapping (address => Info) internal upgraders;\n\n    event ModuleRegistered(address indexed module, bytes32 name);\n    event ModuleDeRegistered(address module);\n    event UpgraderRegistered(address indexed upgrader, bytes32 name);\n    event UpgraderDeRegistered(address upgrader);\n\n    struct Info {\n        bool exists;\n        bytes32 name;\n    }\n\n    /**\n     * @dev Registers a module.\n     * @param _module The module.\n     * @param _name The unique name of the module.\n     */\n    function registerModule(address _module, bytes32 _name) external onlyOwner {\n        require(!modules[_module].exists, \"MR: module already exists\");\n        modules[_module] = Info({exists: true, name: _name});\n        emit ModuleRegistered(_module, _name);\n    }\n\n    /**\n     * @dev Deregisters a module.\n     * @param _module The module.\n     */\n    function deregisterModule(address _module) external onlyOwner {\n        require(modules[_module].exists, \"MR: module does not exists\");\n        delete modules[_module];\n        emit ModuleDeRegistered(_module);\n    }\n\n        /**\n     * @dev Registers an upgrader.\n     * @param _upgrader The upgrader.\n     * @param _name The unique name of the upgrader.\n     */\n    function registerUpgrader(address _upgrader, bytes32 _name) external onlyOwner {\n        require(!upgraders[_upgrader].exists, \"MR: upgrader already exists\");\n        upgraders[_upgrader] = Info({exists: true, name: _name});\n        emit UpgraderRegistered(_upgrader, _name);\n    }\n\n    /**\n     * @dev Deregisters an upgrader.\n     * @param _upgrader The _upgrader.\n     */\n    function deregisterUpgrader(address _upgrader) external onlyOwner {\n        require(upgraders[_upgrader].exists, \"MR: upgrader does not exists\");\n        delete upgraders[_upgrader];\n        emit UpgraderDeRegistered(_upgrader);\n    }\n\n    /**\n    * @dev Utility method enbaling the owner of the registry to claim any ERC20 token that was sent to the\n    * registry.\n    * @param _token The token to recover.\n    */\n    function recoverToken(address _token) external onlyOwner {\n        uint total = ERC20(_token).balanceOf(address(this));\n        ERC20(_token).transfer(msg.sender, total);\n    } \n\n    /**\n     * @dev Gets the name of a module from its address.\n     * @param _module The module address.\n     * @return the name.\n     */\n    function moduleInfo(address _module) external view returns (bytes32) {\n        return modules[_module].name;\n    }\n\n    /**\n     * @dev Gets the name of an upgrader from its address.\n     * @param _upgrader The upgrader address.\n     * @return the name.\n     */\n    function upgraderInfo(address _upgrader) external view returns (bytes32) {\n        return upgraders[_upgrader].name;\n    }\n\n    /**\n     * @dev Checks if a module is registered.\n     * @param _module The module address.\n     * @return true if the module is registered.\n     */\n    function isRegisteredModule(address _module) external view returns (bool) {\n        return modules[_module].exists;\n    }\n\n    /**\n     * @dev Checks if a list of modules are registered.\n     * @param _modules The list of modules address.\n     * @return true if all the modules are registered.\n     */\n    function isRegisteredModule(address[] _modules) external view returns (bool) {\n        for(uint i = 0; i < _modules.length; i++) {\n            if (!modules[_modules[i]].exists) {\n                return false;\n            }\n        }\n        return true;\n    }  \n\n    /**\n     * @dev Checks if an upgrader is registered.\n     * @param _upgrader The upgrader address.\n     * @return true if the upgrader is registered.\n     */\n    function isRegisteredUpgrader(address _upgrader) external view returns (bool) {\n        return upgraders[_upgrader].exists;\n    } \n}\n\n/**\n * @title BaseWallet\n * @dev Simple modular wallet that authorises modules to call its invoke() method.\n * Based on https://gist.github.com/Arachnid/a619d31f6d32757a4328a428286da186 by \n * @author Julien Niset - <[email protected]>\n */\ncontract BaseWallet {\n\n    // The implementation of the proxy\n    address public implementation;\n    // The owner \n    address public owner;\n    // The authorised modules\n    mapping (address => bool) public authorised;\n    // The enabled static calls\n    mapping (bytes4 => address) public enabled;\n    // The number of modules\n    uint public modules;\n    \n    event AuthorisedModule(address indexed module, bool value);\n    event EnabledStaticCall(address indexed module, bytes4 indexed method);\n    event Invoked(address indexed module, address indexed target, uint indexed value, bytes data);\n    event Received(uint indexed value, address indexed sender, bytes data);\n    event OwnerChanged(address owner);\n    \n    /**\n     * @dev Throws if the sender is not an authorised module.\n     */\n    modifier moduleOnly {\n        require(authorised[msg.sender], \"BW: msg.sender not an authorized module\");\n        _;\n    }\n\n    /**\n     * @dev Inits the wallet by setting the owner and authorising a list of modules.\n     * @param _owner The owner.\n     * @param _modules The modules to authorise.\n     */\n    function init(address _owner, address[] _modules) external {\n        require(owner == address(0) && modules == 0, \"BW: wallet already initialised\");\n        require(_modules.length > 0, \"BW: construction requires at least 1 module\");\n        owner = _owner;\n        modules = _modules.length;\n        for(uint256 i = 0; i < _modules.length; i++) {\n            require(authorised[_modules[i]] == false, \"BW: module is already added\");\n            authorised[_modules[i]] = true;\n            Module(_modules[i]).init(this);\n            emit AuthorisedModule(_modules[i], true);\n        }\n    }\n    \n    /**\n     * @dev Enables/Disables a module.\n     * @param _module The target module.\n     * @param _value Set to true to authorise the module.\n     */\n    function authoriseModule(address _module, bool _value) external moduleOnly {\n        if (authorised[_module] != _value) {\n            if(_value == true) {\n                modules += 1;\n                authorised[_module] = true;\n                Module(_module).init(this);\n            }\n            else {\n                modules -= 1;\n                require(modules > 0, \"BW: wallet must have at least one module\");\n                delete authorised[_module];\n            }\n            emit AuthorisedModule(_module, _value);\n        }\n    }\n\n    /**\n    * @dev Enables a static method by specifying the target module to which the call\n    * must be delegated.\n    * @param _module The target module.\n    * @param _method The static method signature.\n    */\n    function enableStaticCall(address _module, bytes4 _method) external moduleOnly {\n        require(authorised[_module], \"BW: must be an authorised module for static call\");\n        enabled[_method] = _module;\n        emit EnabledStaticCall(_module, _method);\n    }\n\n    /**\n     * @dev Sets a new owner for the wallet.\n     * @param _newOwner The new owner.\n     */\n    function setOwner(address _newOwner) external moduleOnly {\n        require(_newOwner != address(0), \"BW: address cannot be null\");\n        owner = _newOwner;\n        emit OwnerChanged(_newOwner);\n    }\n    \n    /**\n     * @dev Performs a generic transaction.\n     * @param _target The address for the transaction.\n     * @param _value The value of the transaction.\n     * @param _data The data of the transaction.\n     */\n    function invoke(address _target, uint _value, bytes _data) external moduleOnly {\n        // solium-disable-next-line security/no-call-value\n        require(_target.call.value(_value)(_data), \"BW: call to target failed\");\n        emit Invoked(msg.sender, _target, _value, _data);\n    }\n\n    /**\n     * @dev This method makes it possible for the wallet to comply to interfaces expecting the wallet to\n     * implement specific static methods. It delegates the static call to a target contract if the data corresponds \n     * to an enabled method, or logs the call otherwise.\n     */\n    function() public payable {\n        if(msg.data.length > 0) { \n            address module = enabled[msg.sig];\n            if(module == address(0)) {\n                emit Received(msg.value, msg.sender, msg.data);\n            } \n            else {\n                require(authorised[module], \"BW: must be an authorised module for static call\");\n                // solium-disable-next-line security/no-inline-assembly\n                assembly {\n                    calldatacopy(0, 0, calldatasize())\n                    let result := staticcall(gas, module, 0, calldatasize(), 0, 0)\n                    returndatacopy(0, 0, returndatasize())\n                    switch result \n                    case 0 {revert(0, returndatasize())} \n                    default {return (0, returndatasize())}\n                }\n            }\n        }\n    }\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n    /**\n    * @dev Returns ceil(a / b).\n    */\n    function ceil(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a / b;\n        if(a % b == 0) {\n            return c;\n        }\n        else {\n            return c + 1;\n        }\n    }\n}\n\n/**\n * @title Storage\n * @dev Base contract for the storage of a wallet.\n * @author Julien Niset - <[email protected]>\n */\ncontract Storage {\n\n    /**\n     * @dev Throws if the caller is not an authorised module.\n     */\n    modifier onlyModule(BaseWallet _wallet) {\n        require(_wallet.authorised(msg.sender), \"TS: must be an authorized module to call this method\");\n        _;\n    }\n}\n\n/**\n * @title GuardianStorage\n * @dev Contract storing the state of wallets related to guardians and lock.\n * The contract only defines basic setters and getters with no logic. Only modules authorised\n * for a wallet can modify its state.\n * @author Julien Niset - <[email protected]>\n * @author Olivier Van Den Biggelaar - <[email protected]>\n */\ncontract GuardianStorage is Storage {\n\n    struct GuardianStorageConfig {\n        // the list of guardians\n        address[] guardians;\n        // the info about guardians\n        mapping (address => GuardianInfo) info;\n        // the lock's release timestamp\n        uint256 lock; \n        // the module that set the last lock\n        address locker;\n    }\n\n    struct GuardianInfo {\n        bool exists;\n        uint128 index;\n    }\n\n    // wallet specific storage\n    mapping (address => GuardianStorageConfig) internal configs;\n\n    // *************** External Functions ********************* //\n\n    /**\n     * @dev Lets an authorised module add a guardian to a wallet.\n     * @param _wallet The target wallet.\n     * @param _guardian The guardian to add.\n     */\n    function addGuardian(BaseWallet _wallet, address _guardian) external onlyModule(_wallet) {\n        GuardianStorageConfig storage config = configs[_wallet];\n        config.info[_guardian].exists = true;\n        config.info[_guardian].index = uint128(config.guardians.push(_guardian) - 1);\n    }\n\n    /**\n     * @dev Lets an authorised module revoke a guardian from a wallet.\n     * @param _wallet The target wallet.\n     * @param _guardian The guardian to revoke.\n     */\n    function revokeGuardian(BaseWallet _wallet, address _guardian) external onlyModule(_wallet) {\n        GuardianStorageConfig storage config = configs[_wallet];\n        address lastGuardian = config.guardians[config.guardians.length - 1];\n        if (_guardian != lastGuardian) {\n            uint128 targetIndex = config.info[_guardian].index;\n            config.guardians[targetIndex] = lastGuardian;\n            config.info[lastGuardian].index = targetIndex;\n        }\n        config.guardians.length--;\n        delete config.info[_guardian];\n    }\n\n    /**\n     * @dev Returns the number of guardians for a wallet.\n     * @param _wallet The target wallet.\n     * @return the number of guardians.\n     */\n    function guardianCount(BaseWallet _wallet) external view returns (uint256) {\n        return configs[_wallet].guardians.length;\n    }\n    \n    /**\n     * @dev Gets the list of guaridans for a wallet.\n     * @param _wallet The target wallet.\n     * @return the list of guardians.\n     */\n    function getGuardians(BaseWallet _wallet) external view returns (address[]) {\n        GuardianStorageConfig storage config = configs[_wallet];\n        address[] memory guardians = new address[](config.guardians.length);\n        for (uint256 i = 0; i < config.guardians.length; i++) {\n            guardians[i] = config.guardians[i];\n        }\n        return guardians;\n    }\n\n    /**\n     * @dev Checks if an account is a guardian for a wallet.\n     * @param _wallet The target wallet.\n     * @param _guardian The account.\n     * @return true if the account is a guardian for a wallet.\n     */\n    function isGuardian(BaseWallet _wallet, address _guardian) external view returns (bool) {\n        return configs[_wallet].info[_guardian].exists;\n    }\n\n    /**\n     * @dev Lets an authorised module set the lock for a wallet.\n     * @param _wallet The target wallet.\n     * @param _releaseAfter The epoch time at which the lock should automatically release.\n     */\n    function setLock(BaseWallet _wallet, uint256 _releaseAfter) external onlyModule(_wallet) {\n        configs[_wallet].lock = _releaseAfter;\n        if(_releaseAfter != 0 && msg.sender != configs[_wallet].locker) {\n            configs[_wallet].locker = msg.sender;\n        }\n    }\n\n    /**\n     * @dev Checks if the lock is set for a wallet.\n     * @param _wallet The target wallet.\n     * @return true if the lock is set for the wallet.\n     */\n    function isLocked(BaseWallet _wallet) external view returns (bool) {\n        return configs[_wallet].lock > now;\n    }\n\n    /**\n     * @dev Gets the time at which the lock of a wallet will release.\n     * @param _wallet The target wallet.\n     * @return the time at which the lock of a wallet will release, or zero if there is no lock set.\n     */\n    function getLock(BaseWallet _wallet) external view returns (uint256) {\n        return configs[_wallet].lock;\n    }\n\n    /**\n     * @dev Gets the address of the last module that modified the lock for a wallet.\n     * @param _wallet The target wallet.\n     * @return the address of the last module that modified the lock for a wallet.\n     */\n    function getLocker(BaseWallet _wallet) external view returns (address) {\n        return configs[_wallet].locker;\n    }\n}\n\nlibrary GuardianUtils {\n\n    /**\n    * @dev Checks if an address is an account guardian or an account authorised to sign on behalf of a smart-contract guardian\n    * given a list of guardians.\n    * @param _guardians the list of guardians\n    * @param _guardian the address to test\n    * @return true and the list of guardians minus the found guardian upon success, false and the original list of guardians if not found.\n    */\n    function isGuardian(address[] _guardians, address _guardian) internal view returns (bool, address[]) {\n        if(_guardians.length == 0 || _guardian == address(0)) {\n            return (false, _guardians);\n        }\n        bool isFound = false;\n        address[] memory updatedGuardians = new address[](_guardians.length - 1);\n        uint256 index = 0;\n        for (uint256 i = 0; i < _guardians.length; i++) {\n            if(!isFound) {\n                // check if _guardian is an account guardian\n                if(_guardian == _guardians[i]) {\n                    isFound = true;\n                    continue;\n                }\n                // check if _guardian is the owner of a smart contract guardian\n                if(isContract(_guardians[i]) && isGuardianOwner(_guardians[i], _guardian)) {\n                    isFound = true;\n                    continue;\n                }\n            }\n            if(index < updatedGuardians.length) {\n                updatedGuardians[index] = _guardians[i];\n                index++;\n            }\n        }\n        return isFound ? (true, updatedGuardians) : (false, _guardians);\n    }\n\n   /**\n    * @dev Checks if an address is a contract.\n    * @param _addr The address.\n    */\n    function isContract(address _addr) internal view returns (bool) {\n        uint32 size;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            size := extcodesize(_addr)\n        }\n        return (size > 0);\n    }\n\n    /**\n    * @dev Checks if an address is the owner of a guardian contract. \n    * The method does not revert if the call to the owner() method consumes more then 5000 gas. \n    * @param _guardian The guardian contract\n    * @param _owner The owner to verify.\n    */\n    function isGuardianOwner(address _guardian, address _owner) internal view returns (bool) {\n        address owner = address(0);\n        bytes4 sig = bytes4(keccak256(\"owner()\"));\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr,sig)\n            let result := staticcall(5000, _guardian, ptr, 0x20, ptr, 0x20)\n            if eq(result, 1) {\n                owner := mload(ptr)\n            }\n        }\n        return owner == _owner;\n    }     \n} \n\n/**\n * @title RecoveryManager\n * @dev Module to manage the recovery of a wallet owner.\n * Recovery is executed by a consensus of the wallet's guardians and takes\n * 24 hours before it can be finalized. Once finalised the ownership of the wallet\n * is transfered to a new address.\n * @author Julien Niset - <[email protected]>\n * @author Olivier Van Den Biggelaar - <[email protected]>\n */\ncontract RecoveryManager is BaseModule, RelayerModule {\n\n    bytes32 constant NAME = \"RecoveryManager\";\n\n    bytes4 constant internal EXECUTE_PREFIX = bytes4(keccak256(\"executeRecovery(address,address)\"));\n    bytes4 constant internal FINALIZE_PREFIX = bytes4(keccak256(\"finalizeRecovery(address)\"));\n    bytes4 constant internal CANCEL_PREFIX = bytes4(keccak256(\"cancelRecovery(address)\"));\n\n    struct RecoveryManagerConfig {\n        address recovery;\n        uint64 executeAfter;\n        uint32 guardianCount;\n    }\n\n    // the wallet specific storage\n    mapping (address => RecoveryManagerConfig) internal configs;\n    // Recovery period   \n    uint256 public recoveryPeriod; \n    // Lock period\n    uint256 public lockPeriod;\n    // location of the Guardian storage\n    GuardianStorage public guardianStorage;\n\n    // *************** Events *************************** //\n\n    event RecoveryExecuted(address indexed wallet, address indexed _recovery, uint64 executeAfter);\n    event RecoveryFinalized(address indexed wallet, address indexed _recovery);\n    event RecoveryCanceled(address indexed wallet, address indexed _recovery);\n\n    // *************** Modifiers ************************ //\n\n    /**\n     * @dev Throws if there is no ongoing recovery procedure.\n     */\n    modifier onlyWhenRecovery(BaseWallet _wallet) {\n        require(configs[_wallet].executeAfter > 0, \"RM: there must be an ongoing recovery\");\n        _;\n    }\n\n    /**\n     * @dev Throws if there is an ongoing recovery procedure.\n     */\n    modifier notWhenRecovery(BaseWallet _wallet) {\n        require(configs[_wallet].executeAfter == 0, \"RM: there cannot be an ongoing recovery\");\n        _;\n    }\n\n    // *************** Constructor ************************ //\n\n    constructor(\n        ModuleRegistry _registry, \n        GuardianStorage _guardianStorage, \n        uint256 _recoveryPeriod, \n        uint256 _lockPeriod\n    ) \n        BaseModule(_registry, NAME) \n        public \n    {\n        guardianStorage = _guardianStorage;\n        recoveryPeriod = _recoveryPeriod;\n        lockPeriod = _lockPeriod;\n    }\n\n    // *************** External functions ************************ //\n    \n    /**\n     * @dev Lets the guardians start the execution of the recovery procedure.\n     * Once triggered the recovery is pending for the security period before it can \n     * be finalised.\n     * Must be confirmed by N guardians, where N = ((Nb Guardian + 1) / 2).\n     * @param _wallet The target wallet.\n     * @param _recovery The address to which ownership should be transferred.\n     */\n    function executeRecovery(BaseWallet _wallet, address _recovery) external onlyExecute notWhenRecovery(_wallet) {\n        require(_recovery != address(0), \"RM: recovery address cannot be null\");\n        RecoveryManagerConfig storage config = configs[_wallet];\n        config.recovery = _recovery;\n        config.executeAfter = uint64(now + recoveryPeriod);\n        config.guardianCount = uint32(guardianStorage.guardianCount(_wallet));\n        guardianStorage.setLock(_wallet, now + lockPeriod);\n        emit RecoveryExecuted(_wallet, _recovery, config.executeAfter);\n    }\n\n    /**\n     * @dev Finalizes an ongoing recovery procedure if the security period is over.\n     * The method is public and callable by anyone to enable orchestration.\n     * @param _wallet The target wallet.\n     */\n    function finalizeRecovery(BaseWallet _wallet) external onlyExecute onlyWhenRecovery(_wallet) {\n        RecoveryManagerConfig storage config = configs[_wallet];\n        require(uint64(now) > config.executeAfter, \"RM: the recovery period is not over yet\");\n        _wallet.setOwner(config.recovery); \n        emit RecoveryFinalized(_wallet, config.recovery);\n        guardianStorage.setLock(_wallet, 0);\n        delete configs[_wallet];\n    }\n\n    /**\n     * @dev Lets the owner cancel an ongoing recovery procedure.\n     * Must be confirmed by N guardians, where N = ((Nb Guardian + 1) / 2) - 1.\n     * @param _wallet The target wallet.\n     */\n    function cancelRecovery(BaseWallet _wallet) external onlyExecute onlyWhenRecovery(_wallet) {\n        RecoveryManagerConfig storage config = configs[_wallet];\n        emit  RecoveryCanceled(_wallet, config.recovery);\n        guardianStorage.setLock(_wallet, 0);\n        delete configs[_wallet];\n    }\n\n    /** \n    * @dev Gets the details of the ongoing recovery procedure if any.\n    * @param _wallet The target wallet.\n    */\n    function getRecovery(BaseWallet _wallet) public view returns(address _address, uint64 _executeAfter, uint32 _guardianCount) {\n        RecoveryManagerConfig storage config = configs[_wallet];\n        return (config.recovery, config.executeAfter, config.guardianCount);\n    }\n\n    // *************** Implementation of RelayerModule methods ********************* //\n\n    function validateSignatures(BaseWallet _wallet, bytes _data, bytes32 _signHash, bytes _signatures) internal view returns (bool) {\n        address lastSigner = address(0);\n        address[] memory guardians = guardianStorage.getGuardians(_wallet);\n        bool isGuardian = false;\n        for (uint8 i = 0; i < _signatures.length / 65; i++) {\n            address signer = recoverSigner(_signHash, _signatures, i);\n            if(i == 0 && isOwner(_wallet, signer)) {\n                // first signer can be owner\n                continue;\n            }\n            else {\n                if(signer <= lastSigner) {\n                    return false;\n                } // \"RM: signers must be different\"\n                lastSigner = signer;\n                (isGuardian, guardians) = GuardianUtils.isGuardian(guardians, signer);\n                if(!isGuardian) {\n                    return false;\n                } // \"RM: signatures not valid\"\n            }\n        }\n        return true;\n    }\n\n    function getRequiredSignatures(BaseWallet _wallet, bytes _data) internal view returns (uint256) {\n        bytes4 methodId = functionPrefix(_data);\n        if (methodId == EXECUTE_PREFIX) {\n            return SafeMath.ceil(guardianStorage.guardianCount(_wallet) + 1, 2);\n        }\n        if (methodId == FINALIZE_PREFIX) {\n            return 0;\n        }\n        if(methodId == CANCEL_PREFIX) {\n            return SafeMath.ceil(configs[_wallet].guardianCount + 1, 2);\n        }\n        revert(\"RM: unknown  method\");\n    }\n}",
  "bytecode": "608060405234801561001057600080fd5b5060405160808061217c83398101604081815282516020808501518386015160609096015160008054600160a060020a031916600160a060020a0386161790557f5265636f766572794d616e61676572000000000000000000000000000000000080875294519396919591949093879391927f3019c8fc80239e3dff8f781212ae2004839c2cb61d6c70acd279ac65392145df92908290030190a1505060058054600160a060020a031916600160a060020a03949094169390931790925560035560045550612098806100e46000396000f3006080604052600436106100c45763ffffffff7c010000000000000000000000000000000000000000000000000000000060003504166316c3e22f81146100c957806319ab453c146100f05780632d0335ab14610113578063315a7af3146101345780633fd8b02f146101555780635a1db8c41461016a5780639769c3fe146101915780639be65a60146101e9578063aacaaf881461020a578063b0ba4da014610261578063c90db44714610288578063c9b5ef8e146102a9578063d89784fc146102ca575b600080fd5b3480156100d557600080fd5b506100de6102fb565b60408051918252519081900360200190f35b3480156100fc57600080fd5b50610111600160a060020a0360043516610301565b005b34801561011f57600080fd5b506100de600160a060020a03600435166103a7565b34801561014057600080fd5b50610111600160a060020a03600435166103c2565b34801561016157600080fd5b506100de6106fe565b34801561017657600080fd5b50610111600160a060020a0360043581169060243516610704565b34801561019d57600080fd5b506101b2600160a060020a036004351661090a565b60408051600160a060020a03909416845267ffffffffffffffff909216602084015263ffffffff1682820152519081900360600190f35b3480156101f557600080fd5b50610111600160a060020a0360043516610974565b34801561021657600080fd5b5061024d60048035600160a060020a031690602480358082019290810135916044359160643591820191013560843560a435610aa8565b604080519115158252519081900360200190f35b34801561026d57600080fd5b50610111600160a060020a0360043581169060243516610da2565b34801561029457600080fd5b50610111600160a060020a03600435166111ac565b3480156102b557600080fd5b506100de600160a060020a036004351661137c565b3480156102d657600080fd5b506102df61138e565b60408051600160a060020a039092168252519081900360200190f35b60035481565b8033600160a060020a03821614610367576040805160008051602061204d833981519152815260206004820152601960248201527f424d3a2063616c6c6572206d7573742062652077616c6c657400000000000000604482015290519081900360640190fd5b60408051600160a060020a038416815290517f9fcca3f73f85397e2bf03647abf243c20b753bd54463ff3cae74de2971c112fa9181900360200190a15050565b600160a060020a031660009081526001602052604090205490565b6000333014610420576040805160008051602061204d833981519152815260206004820181905260248201527f524d3a206d7573742062652063616c6c65642076696120657865637574652829604482015290519081900360640190fd5b600160a060020a03821660009081526002602052604081205483917401000000000000000000000000000000000000000090910467ffffffffffffffff16116104de576040805160008051602061204d833981519152815260206004820152602560248201527f524d3a207468657265206d75737420626520616e206f6e676f696e672072656360448201527f6f76657279000000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b600160a060020a0383166000908152600260205260409020805490925067ffffffffffffffff74010000000000000000000000000000000000000000909104811642909116116105a3576040805160008051602061204d833981519152815260206004820152602760248201527f524d3a20746865207265636f7665727920706572696f64206973206e6f74206f60448201527f7665722079657400000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b8154604080517f13af4035000000000000000000000000000000000000000000000000000000008152600160a060020a0392831660048201529051918516916313af40359160248082019260009290919082900301818387803b15801561060957600080fd5b505af115801561061d573d6000803e3d6000fd5b50508354604051600160a060020a03918216935090861691507fd8667de85dae2d56d76e700d16de53d21ac2ce4d5549cb0bf51c55fdc37f0bc190600090a3600554604080517fb0fc29e6000000000000000000000000000000000000000000000000000000008152600160a060020a038681166004830152600060248301819052925193169263b0fc29e69260448084019391929182900301818387803b1580156106c857600080fd5b505af11580156106dc573d6000803e3d6000fd5b505050600160a060020a03909316600090815260026020526040812055505050565b60045481565b8161070f813361139d565b1515610790576040805160008051602061204d833981519152815260206004820152602e60248201527f424d3a206d73672e73656e646572206d75737420626520616e206f776e65722060448201527f666f72207468652077616c6c6574000000000000000000000000000000000000606482015290519081900360840190fd5b60008054604080517f0bcd4ebb000000000000000000000000000000000000000000000000000000008152600160a060020a03868116600483015291519190921692630bcd4ebb92602480820193602093909283900390910190829087803b1580156107fb57600080fd5b505af115801561080f573d6000803e3d6000fd5b505050506040513d602081101561082557600080fd5b50511515610882576040805160008051602061204d833981519152815260206004820152601c60248201527f424d3a206d6f64756c65206973206e6f74207265676973746572656400000000604482015290519081900360640190fd5b604080517f1f17732d000000000000000000000000000000000000000000000000000000008152600160a060020a03848116600483015260016024830152915191851691631f17732d9160448082019260009290919082900301818387803b1580156108ed57600080fd5b505af1158015610901573d6000803e3d6000fd5b50505050505050565b600160a060020a039081166000908152600260205260409020549081169174010000000000000000000000000000000000000000820467ffffffffffffffff16917c0100000000000000000000000000000000000000000000000000000000900463ffffffff1690565b604080517f70a082310000000000000000000000000000000000000000000000000000000081523060048201529051600091600160a060020a038416916370a082319160248082019260209290919082900301818787803b1580156109d857600080fd5b505af11580156109ec573d6000803e3d6000fd5b505050506040513d6020811015610a0257600080fd5b505160008054604080517fa9059cbb000000000000000000000000000000000000000000000000000000008152600160a060020a0392831660048201526024810185905290519394509085169263a9059cbb92604480840193602093929083900390910190829087803b158015610a7857600080fd5b505af1158015610a8c573d6000803e3d6000fd5b505050506040513d6020811015610aa257600080fd5b50505050565b6000806000805a9250610af3308d60008e8e8080601f0160208091040260200160405190810160405280939291908181526020018383808284378201915050505050508d8b8b61143d565b9150610b008c8a84611631565b1515610b5b576040805160008051602061204d833981519152815260206004820152601560248201527f524d3a204475706c696361746520726571756573740000000000000000000000604482015290519081900360640190fd5b610b958c8c8c8080601f016020809104026020016040519081016040528093929190818152602001838380828437506116a3945050505050565b1515610c3c576040805160008051602061204d833981519152815260206004820152604a60248201527f524d3a207468652077616c6c657420617574686f72697a65642069732064696660448201527f666572656e74207468656e2074686520746172676574206f662074686520726560648201527f6c61796564206461746100000000000000000000000000000000000000000000608482015290519081900360a40190fd5b610c768c8c8c8080601f0160208091040260200160405190810160405280939291908181526020018383808284375061172d945050505050565b905060418102871415610d5157610c8f8c8688846119b1565b15610d5157801580610d0a5750610d0a8c8c8c8080601f016020809104026020016040519081016040528093929190818152602001838380828437820191505050505050848b8b8080601f01602080910402602001604051908101604052809392919081815260200183838082843750611a86945050505050565b15610d515730600160a060020a03168b8b604051808383808284378201915050925050506000604051808303816000865af19150509350610d518c5a850388888533611c26565b60408051838152905185151591600160a060020a038f16917f6bb0b384ce772133df63560651bc8c727c53306cec1d51e2cbf8ea35fb8f2ec19181900360200190a350505098975050505050505050565b6000333014610e00576040805160008051602061204d833981519152815260206004820181905260248201527f524d3a206d7573742062652063616c6c65642076696120657865637574652829604482015290519081900360640190fd5b600160a060020a038316600090815260026020526040902054839074010000000000000000000000000000000000000000900467ffffffffffffffff1615610ebd576040805160008051602061204d833981519152815260206004820152602760248201527f524d3a2074686572652063616e6e6f7420626520616e206f6e676f696e67207260448201527f65636f7665727900000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b600160a060020a0383161515610f48576040805160008051602061204d833981519152815260206004820152602360248201527f524d3a207265636f7665727920616464726573732063616e6e6f74206265206e60448201527f756c6c0000000000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b600160a060020a03808516600081815260026020908152604080832080548987167fffffffffffffffffffffffff00000000000000000000000000000000000000009091161780825560035467ffffffffffffffff429091011674010000000000000000000000000000000000000000027fffffffff0000000000000000ffffffffffffffffffffffffffffffffffffffff90911617815560055482517f5040fb7600000000000000000000000000000000000000000000000000000000815260048101969096529151909750941693635040fb7693602480820194918390030190829087803b15801561103b57600080fd5b505af115801561104f573d6000803e3d6000fd5b505050506040513d602081101561106557600080fd5b5051825463ffffffff9091167c0100000000000000000000000000000000000000000000000000000000027bffffffffffffffffffffffffffffffffffffffffffffffffffffffff90911617825560055460048054604080517fb0fc29e6000000000000000000000000000000000000000000000000000000008152600160a060020a038981169482019490945242909201602483015251919092169163b0fc29e691604480830192600092919082900301818387803b15801561112857600080fd5b505af115801561113c573d6000803e3d6000fd5b50508354604080517401000000000000000000000000000000000000000090920467ffffffffffffffff16825251600160a060020a038781169450881692507f5f59bfd9baba55ae30bb440923cbbe30987d50e12a4e9134ffac3fd9afc3526d916020908290030190a350505050565b600033301461120a576040805160008051602061204d833981519152815260206004820181905260248201527f524d3a206d7573742062652063616c6c65642076696120657865637574652829604482015290519081900360640190fd5b600160a060020a03821660009081526002602052604081205483917401000000000000000000000000000000000000000090910467ffffffffffffffff16116112c8576040805160008051602061204d833981519152815260206004820152602560248201527f524d3a207468657265206d75737420626520616e206f6e676f696e672072656360448201527f6f76657279000000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b600160a060020a03808416600081815260026020526040808220805491519096509316927fc45926607303da71dbeffd2ed5c6b00f581982586b697655d19ae4c4d558f2599190a3600554604080517fb0fc29e6000000000000000000000000000000000000000000000000000000008152600160a060020a038681166004830152600060248301819052925193169263b0fc29e69260448084019391929182900301818387803b1580156106c857600080fd5b60016020526000908152604090205481565b600554600160a060020a031681565b600081600160a060020a031683600160a060020a0316638da5cb5b6040518163ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401602060405180830381600087803b15801561140057600080fd5b505af1158015611414573d6000803e3d6000fd5b505050506040513d602081101561142a57600080fd5b5051600160a060020a0316149392505050565b6040517f190000000000000000000000000000000000000000000000000000000000000060208083018281526000602185018190526c01000000000000000000000000600160a060020a03808e16820260228801528c16026036860152604a85018a90528851909485938d938d938d938d938d938d938d939192606a909201918701908083835b602083106114e35780518252601f1990920191602091820191016114c4565b6001836020036101000a03801982511681845116808217855250505050505090500184815260200183815260200182815260200199505050505050505050506040516020818303038152906040526040518082805190602001908083835b602083106115605780518252601f199092019160209182019101611541565b51815160209384036101000a6000190180199092169116179052604080519290940182900382207f19457468657265756d205369676e6564204d6573736167653a0a33320000000083830152603c8084019190915284518084039091018152605c9092019384905281519195509293508392850191508083835b602083106115f95780518252601f1990920191602091820191016115da565b5181516020939093036101000a600019018019909116921691909117905260405192018290039091209b9a5050505050505050505050565b600160a060020a0383166000908152600160208181526040808420858552830190915282205460ff161515141561166a5750600061169c565b50600160a060020a03831660009081526001602081815260408084208585528301909152909120805460ff1916821790555b9392505050565b6000806024835110151515611707576040805160008051602061204d833981519152815260206004820152601660248201527f524d3a20496e76616c6964206461746157616c6c657400000000000000000000604482015290519081900360640190fd5b6024830151905083600160a060020a031681600160a060020a03161491505b5092915050565b60008061173983611cf5565b604080517f657865637574655265636f7665727928616464726573732c6164647265737329815290519081900360200190209091507fffffffff000000000000000000000000000000000000000000000000000000008083169116141561184457600554604080517f5040fb76000000000000000000000000000000000000000000000000000000008152600160a060020a038781166004830152915161183d939290921691635040fb76916024808201926020929091908290030181600087803b15801561180757600080fd5b505af115801561181b573d6000803e3d6000fd5b505050506040513d602081101561183157600080fd5b50516001016002611d60565b9150611726565b604080517f66696e616c697a655265636f7665727928616464726573732900000000000000815290519081900360190190207fffffffff00000000000000000000000000000000000000000000000000000000828116911614156118ab5760009150611726565b604080517f63616e63656c5265636f76657279286164647265737329000000000000000000815290519081900360170190207fffffffff000000000000000000000000000000000000000000000000000000008281169116141561195c57600160a060020a03841660009081526002602081905260409091205461183d917c010000000000000000000000000000000000000000000000000000000090910463ffffffff9081166001011690611d60565b6040805160008051602061204d833981519152815260206004820152601360248201527f524d3a20756e6b6e6f776e20206d6574686f6400000000000000000000000000604482015290519081900360640190fd5b600080831180156119c25750600182115b8015611a6d575082840285600160a060020a0316311080611a6d5750604080517fd6eb1bbf0000000000000000000000000000000000000000000000000000000081523060048201529051600160a060020a0387169163d6eb1bbf9160248083019260209291908290030181600087803b158015611a3f57600080fd5b505af1158015611a53573d6000803e3d6000fd5b505050506040513d6020811015611a6957600080fd5b5051155b15611a7a57506000611a7e565b5060015b949350505050565b600554604080517ff18858ab000000000000000000000000000000000000000000000000000000008152600160a060020a03878116600483015291516000938493606093859384938493169163f18858ab916024808301928692919082900301818387803b158015611af757600080fd5b505af1158015611b0b573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526020811015611b3457600080fd5b810190808051640100000000811115611b4c57600080fd5b82016020810184811115611b5f57600080fd5b8151856020820283011164010000000082111715611b7c57600080fd5b5090975060009650869550505050505b8651604190048260ff161015611c1457611baa88888460ff16611d96565b905060ff8216158015611bc25750611bc28a8261139d565b15611bcc57611c09565b600160a060020a0380861690821611611be85760009550611c19565b809450611bf58482611e43565b94509250821515611c095760009550611c19565b600190910190611b8c565b600195505b5050505050949350505050565b61726c8501600085118015611c3b5750600183115b8015611c475750838111155b15610901573a851115611c5b573a02611c5e565b84025b604080517f8f6f0332000000000000000000000000000000000000000000000000000000008152600160a060020a03848116600483015260248201849052606060448301526000606483018190529251908a1692638f6f03329260a4808201939182900301818387803b158015611cd457600080fd5b505af1158015611ce8573d6000803e3d6000fd5b5050505050505050505050565b60006004825110151515611d58576040805160008051602061204d833981519152815260206004820152601a60248201527f524d3a20496e76616c69642066756e6374696f6e507265666978000000000000604482015290519081900360640190fd5b506020015190565b6000808284811515611d6e57fe5b0490508284811515611d7c57fe5b061515611d8b57809150611726565b806001019150611726565b6041808202830160208101516040820151919092015160009260ff9190911691601b831480611dc857508260ff16601c145b1515611dd357600080fd5b60408051600080825260208083018085528b905260ff8716838501526060830186905260808301859052925160019360a0808501949193601f19840193928390039091019190865af1158015611e2d573d6000803e3d6000fd5b5050604051601f19015198975050505050505050565b6000606060006060600080875160001480611e655750600160a060020a038716155b15611e765760008895509550611fbf565b600093506001885103604051908082528060200260200182016040528015611ea8578160200160208202803883390190505b50925060009150600090505b8751811015611fa957831515611f54578781815181101515611ed257fe5b90602001906020020151600160a060020a031687600160a060020a03161415611efe5760019350611fa1565b611f1e8882815181101515611f0f57fe5b90602001906020020151611fca565b8015611f465750611f468882815181101515611f3657fe5b9060200190602002015188611fd8565b15611f545760019350611fa1565b8251821015611fa1578781815181101515611f6b57fe5b906020019060200201518383815181101515611f8357fe5b600160a060020a039092166020928302909101909101526001909101905b600101611eb4565b83611fb657600088611fba565b6001835b955095505b505050509250929050565b6000903b63ffffffff161190565b604080517f6f776e657228290000000000000000000000000000000000000000000000000081529051908190036007018120808252600091829190602081818189611388fa600181141561202b57815193505b505083600160a060020a031682600160a060020a0316149250505092915050560008c379a000000000000000000000000000000000000000000000000000000000a165627a7a723058205545813c8ff5f82ec30694aa855cdae73e071df9957707273a7cfa589b758a570029000000000000000000000000c17d432bd8e8850fd7b32b0270f5afac65db010500000000000000000000000044da3a8051ba88eab0440db3779cab9d679ae76f000000000000000000000000000000000000000000000000000000000001fa400000000000000000000000000000000000000000000000000000000000069780",
  "constructorArguments": "000000000000000000000000c17d432bd8e8850fd7b32b0270f5afac65db010500000000000000000000000044da3a8051ba88eab0440db3779cab9d679ae76f000000000000000000000000000000000000000000000000000000000001fa400000000000000000000000000000000000000000000000000000000000069780"
}