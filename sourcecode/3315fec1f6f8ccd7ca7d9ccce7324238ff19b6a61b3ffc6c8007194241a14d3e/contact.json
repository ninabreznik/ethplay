{
  "address": "0x2690402e8d303c1ca4eceff9e17c85dd7383ef47",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "Crowdsale",
  "compilerVersion": "v0.4.21+commit.dfe3193c",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2019-01-10\n*/\n\npragma solidity ^0.4.21;\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a / b;\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n * This code is taken from openZeppelin without any changes.\n */\ncontract Ownable {\n    address public owner;\n\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    function Ownable() public {\n        owner = msg.sender;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n\n}\n\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n\n    mapping (address => bool) public unpausedWallet;\n\n    event Pause();\n    event Unpause();\n\n    bool public paused = true;\n\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     */\n    modifier whenNotPaused(address _to) {\n        require(!paused||unpausedWallet[msg.sender]||unpausedWallet[_to]);\n        _;\n    }\n\n    // Add a wallet ignoring the \"Exchange pause\". Available to the owner of the contract.\n    function setUnpausedWallet(address _wallet, bool mode) public {\n        require(owner == msg.sender || msg.sender == Crowdsale(owner).wallets(uint8(Crowdsale.Roles.manager)));\n        unpausedWallet[_wallet] = mode;\n    }\n\n    /**\n     * @dev called by the owner to pause, triggers stopped state\n     */\n    function setPause(bool mode) public onlyOwner {\n        if (!paused && mode) {\n            paused = true;\n            emit Pause();\n        }\n        if (paused && !mode) {\n            paused = false;\n            emit Unpause();\n        }\n    }\n\n}\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n * This code is taken from openZeppelin without any changes.\n */\ncontract ERC20Basic {\n    function totalSupply() public view returns (uint256);\n    function balanceOf(address who) public view returns (uint256);\n    function transfer(address to, uint256 value) public returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n * This code is taken from openZeppelin without any changes.\n */\ncontract ERC20 is ERC20Basic {\n    function allowance(address owner, address spender) public view returns (uint256);\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\n    function approve(address spender, uint256 value) public returns (bool);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n * This code is taken from openZeppelin without any changes.\n */\ncontract BasicToken is ERC20Basic {\n    using SafeMath for uint256;\n\n    mapping(address => uint256) balances;\n\n    uint256 totalSupply_;\n\n    /**\n    * @dev total number of tokens in existence\n    */\n    function totalSupply() public view returns (uint256) {\n        return totalSupply_;\n    }\n\n    /**\n    * @dev transfer token for a specified address\n    * @param _to The address to transfer to.\n    * @param _value The amount to be transferred.\n    */\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(_value <= balances[msg.sender]);\n\n        // SafeMath.sub will throw if there is not enough balance.\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    /**\n    * @dev Gets the balance of the specified address.\n    * @param _owner The address to query the the balance of.\n    * @return An uint256 representing the amount owned by the passed address.\n    */\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n}\n\n/**\n* @title Standard ERC20 token\n*\n* @dev Implementation of the basic standard token.\n* @dev https://github.com/ethereum/EIPs/issues/20\n* @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n* This code is taken from openZeppelin without any changes.\n*/\ncontract StandardToken is ERC20, BasicToken {\n\n    mapping (address => mapping (address => uint256)) internal allowed;\n\n\n    /**\n     * @dev Transfer tokens from one address to another\n     * @param _from address The address which you want to send tokens from\n     * @param _to address The address which you want to transfer to\n     * @param _value uint256 the amount of tokens to be transferred\n     */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(_value <= balances[_from]);\n        require(_value <= allowed[_from][msg.sender]);\n\n        balances[_from] = balances[_from].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n     *\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param _spender The address which will spend the funds.\n     * @param _value The amount of tokens to be spent.\n     */\n    function approve(address _spender, uint256 _value) public returns (bool) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /**\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n     * @param _owner address The address which owns the funds.\n     * @param _spender address The address which will spend the funds.\n     * @return A uint256 specifying the amount of tokens still available for the spender.\n     */\n    function allowance(address _owner, address _spender) public view returns (uint256) {\n        return allowed[_owner][_spender];\n    }\n\n    /**\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\n     *\n     * approve should be called when allowed[_spender] == 0. To increment\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * @param _spender The address which will spend the funds.\n     * @param _addedValue The amount of tokens to increase the allowance by.\n     */\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    /**\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n     *\n     * approve should be called when allowed[_spender] == 0. To decrement\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * @param _spender The address which will spend the funds.\n     * @param _subtractedValue The amount of tokens to decrease the allowance by.\n     */\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n        uint oldValue = allowed[msg.sender][_spender];\n        if (_subtractedValue > oldValue) {\n            allowed[msg.sender][_spender] = 0;\n        } else {\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n        }\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n}\n\n/**\n * @title Pausable token\n * @dev StandardToken modified with pausable transfers.\n **/\ncontract PausableToken is StandardToken, Pausable {\n\n    mapping (address => bool) public grantedToSetUnpausedWallet;\n\n    function transfer(address _to, uint256 _value) public whenNotPaused(_to) returns (bool) {\n        return super.transfer(_to, _value);\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused(_to) returns (bool) {\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function grantToSetUnpausedWallet(address _to, bool permission) public {\n        require(owner == msg.sender || msg.sender == Crowdsale(owner).wallets(uint8(Crowdsale.Roles.manager)));\n        grantedToSetUnpausedWallet[_to] = permission;\n    }\n\n    // Add a wallet ignoring the \"Exchange pause\". Available to the owner of the contract.\n    function setUnpausedWallet(address _wallet, bool mode) public {\n        require(owner == msg.sender || grantedToSetUnpausedWallet[msg.sender] || msg.sender == Crowdsale(owner).wallets(uint8(Crowdsale.Roles.manager)));\n        unpausedWallet[_wallet] = mode;\n    }\n}\n\ncontract FreezingToken is PausableToken {\n    struct freeze {\n    uint256 amount;\n    uint256 when;\n    }\n\n\n    mapping (address => freeze) freezedTokens;\n\n\n    // @ Do I have to use the function      no\n    // @ When it is possible to call        any time\n    // @ When it is launched automatically  -\n    // @ Who can call the function          any\n    function freezedTokenOf(address _beneficiary) public view returns (uint256 amount){\n        freeze storage _freeze = freezedTokens[_beneficiary];\n        if(_freeze.when < now) return 0;\n        return _freeze.amount;\n    }\n\n    // @ Do I have to use the function      no\n    // @ When it is possible to call        any time\n    // @ When it is launched automatically  -\n    // @ Who can call the function          any\n    function defrostDate(address _beneficiary) public view returns (uint256 Date) {\n        freeze storage _freeze = freezedTokens[_beneficiary];\n        if(_freeze.when < now) return 0;\n        return _freeze.when;\n    }\n\n\n    // ***CHECK***SCENARIO***\n    function freezeTokens(address _beneficiary, uint256 _amount, uint256 _when) public onlyOwner {\n        freeze storage _freeze = freezedTokens[_beneficiary];\n        _freeze.amount = _amount;\n        _freeze.when = _when;\n    }\n\n    function transferAndFreeze(address _to, uint256 _value, uint256 _when) external {\n        require(unpausedWallet[msg.sender]);\n        if(_when > 0){\n            freeze storage _freeze = freezedTokens[_to];\n            _freeze.amount = _freeze.amount.add(_value);\n            _freeze.when = (_freeze.when > _when)? _freeze.when: _when;\n        }\n        transfer(_to,_value);\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(balanceOf(msg.sender) >= freezedTokenOf(msg.sender).add(_value));\n        return super.transfer(_to,_value);\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(balanceOf(_from) >= freezedTokenOf(_from).add(_value));\n        return super.transferFrom( _from,_to,_value);\n    }\n\n\n\n}\n\n/**\n * @title Mintable token\n * @dev Simple ERC20 Token example, with mintable token creation\n * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120\n * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\n * This code is taken from openZeppelin without any changes.\n */\ncontract MintableToken is StandardToken, Ownable {\n    event Mint(address indexed to, uint256 amount);\n    event MintFinished();\n\n    /**\n     * @dev Function to mint tokens\n     * @param _to The address that will receive the minted tokens.\n     * @param _amount The amount of tokens to mint.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function mint(address _to, uint256 _amount) onlyOwner public returns (bool) {\n        totalSupply_ = totalSupply_.add(_amount);\n        balances[_to] = balances[_to].add(_amount);\n        emit Mint(_to, _amount);\n        emit Transfer(address(0), _to, _amount);\n        return true;\n    }\n}\n\ncontract MigrationAgent\n{\n    function migrateFrom(address _from, uint256 _value) public;\n}\n\ncontract MigratableToken is BasicToken,Ownable {\n\n    uint256 public totalMigrated;\n    address public migrationAgent;\n\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n\n    function setMigrationAgent(address _migrationAgent) public onlyOwner {\n        require(migrationAgent == 0x0);\n        migrationAgent = _migrationAgent;\n    }\n\n    function migrateInternal(address _holder) internal {\n        require(migrationAgent != 0x0);\n\n        uint256 value = balances[_holder];\n        balances[_holder] = 0;\n\n        totalSupply_ = totalSupply_.sub(value);\n        totalMigrated = totalMigrated.add(value);\n\n        MigrationAgent(migrationAgent).migrateFrom(_holder, value);\n        emit Migrate(_holder,migrationAgent,value);\n    }\n\n    function migrateAll(address[] _holders) public onlyOwner {\n        for(uint i = 0; i < _holders.length; i++){\n            migrateInternal(_holders[i]);\n        }\n    }\n\n    // Reissue your tokens.\n    function migrate() public\n    {\n        require(balances[msg.sender] > 0);\n        migrateInternal(msg.sender);\n    }\n\n}\n\ncontract BurnableToken is BasicToken, Ownable {\n\n    event Burn(address indexed burner, uint256 value);\n\n    /**\n     * @dev Burns a specific amount of tokens.\n     * @param _value The amount of token to be burned.\n     */\n    function burn(address _beneficiary, uint256 _value) public onlyOwner {\n        require(_value <= balances[_beneficiary]);\n        // no need to require value <= totalSupply, since that would imply the\n        // sender's balance is greater than the totalSupply, which *should* be an assertion failure\n\n        balances[_beneficiary] = balances[_beneficiary].sub(_value);\n        totalSupply_ = totalSupply_.sub(_value);\n        emit Burn(_beneficiary, _value);\n        emit Transfer(_beneficiary, address(0), _value);\n    }\n}\n\ncontract UnburnableListToken is BurnableToken {\n\n    mapping (address => bool) public grantedToSetUnburnableWallet;\n    mapping (address => bool) public unburnableWallet;\n\n    function grantToSetUnburnableWallet(address _to, bool permission) public {\n        require(owner == msg.sender || msg.sender == Crowdsale(owner).wallets(uint8(Crowdsale.Roles.manager)));\n        grantedToSetUnburnableWallet[_to] = permission;\n    }\n\n    // Add a wallet to unburnable list. After adding wallet can not be removed from list. Available to the owner of the contract.\n    function setUnburnableWallet(address _wallet) public {\n        require(owner == msg.sender || grantedToSetUnburnableWallet[msg.sender] || msg.sender == Crowdsale(owner).wallets(uint8(Crowdsale.Roles.manager)));\n        unburnableWallet[_wallet] = true;\n    }\n\n    /**\n     * @dev Burns a specific amount of tokens.\n     * @param _value The amount of token to be burned.\n     */\n    function burn(address _beneficiary, uint256 _value) public onlyOwner {\n        require(!unburnableWallet[_beneficiary]);\n\n        return super.burn(_beneficiary, _value);\n    }\n}\n\n/*\n* Contract that is working with ERC223 tokens\n*/\ncontract ERC223ReceivingContract {\n    function tokenFallback(address _from, uint _value, bytes _data) public;\n}\n\n// (A2)\n// Contract token\ncontract Token is FreezingToken, MintableToken, MigratableToken, UnburnableListToken {\n    string public constant name = \"TOSS\";\n\n    string public constant symbol = \"PROOF OF TOSS\";\n\n    uint8 public constant decimals = 18;\n\n    mapping (address => mapping (address => bool)) public grantedToAllowBlocking; // Address of smart contract that can allow other contracts to block tokens\n    mapping (address => mapping (address => bool)) public allowedToBlocking; // Address of smart contract that can block tokens\n    mapping (address => mapping (address => uint256)) public blocked; // Blocked tokens per blocker\n\n    event TokenOperationEvent(string operation, address indexed from, address indexed to, uint256 value, address indexed _contract);\n\n\n    modifier contractOnly(address _to) {\n        uint256 codeLength;\n\n        assembly {\n        // Retrieve the size of the code on target address, this needs assembly .\n        codeLength := extcodesize(_to)\n        }\n\n        require(codeLength > 0);\n\n        _;\n    }\n\n    /**\n    * @dev Transfer the specified amount of tokens to the specified address.\n    * Invokes the `tokenFallback` function if the recipient is a contract.\n    * The token transfer fails if the recipient is a contract\n    * but does not implement the `tokenFallback` function\n    * or the fallback function to receive funds.\n    *\n    * @param _to Receiver address.\n    * @param _value Amount of tokens that will be transferred.\n    * @param _data Transaction metadata.\n    */\n\n    function transferToContract(address _to, uint256 _value, bytes _data) public contractOnly(_to) returns (bool) {\n        // Standard function transfer similar to ERC20 transfer with no _data .\n        // Added due to backwards compatibility reasons .\n\n\n        super.transfer(_to, _value);\n\n        ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\n        receiver.tokenFallback(msg.sender, _value, _data);\n\n        return true;\n    }\n\n    // @brief Allow another contract to allow another contract to block tokens. Can be revoked\n    // @param _spender another contract address\n    // @param _value amount of approved tokens\n    function grantToAllowBlocking(address _contract, bool permission) contractOnly(_contract) public {\n\n\n        grantedToAllowBlocking[msg.sender][_contract] = permission;\n\n        emit TokenOperationEvent('grant_allow_blocking', msg.sender, _contract, 0, 0);\n    }\n\n    // @brief Allow another contract to block tokens. Can't be revoked\n    // @param _owner tokens owner\n    // @param _contract another contract address\n    function allowBlocking(address _owner, address _contract) contractOnly(_contract) public {\n\n\n        require(_contract != msg.sender && _contract != owner);\n\n        require(grantedToAllowBlocking[_owner][msg.sender]);\n\n        allowedToBlocking[_owner][_contract] = true;\n\n        emit TokenOperationEvent('allow_blocking', _owner, _contract, 0, msg.sender);\n    }\n\n    // @brief Blocks tokens\n    // @param _blocking The address of tokens which are being blocked\n    // @param _value The blocked token count\n    function blockTokens(address _blocking, uint256 _value) whenNotPaused(_blocking) public {\n        require(allowedToBlocking[_blocking][msg.sender]);\n\n        require(balanceOf(_blocking) >= freezedTokenOf(_blocking).add(_value) && _value > 0);\n\n        balances[_blocking] = balances[_blocking].sub(_value);\n        blocked[_blocking][msg.sender] = blocked[_blocking][msg.sender].add(_value);\n\n        emit Transfer(_blocking, address(0), _value);\n        emit TokenOperationEvent('block', _blocking, 0, _value, msg.sender);\n    }\n\n    // @brief Unblocks tokens and sends them to the given address (to _unblockTo)\n    // @param _blocking The address of tokens which are blocked\n    // @param _unblockTo The address to send to the blocked tokens after unblocking\n    // @param _value The blocked token count to unblock\n    function unblockTokens(address _blocking, address _unblockTo, uint256 _value) whenNotPaused(_unblockTo) public {\n        require(allowedToBlocking[_blocking][msg.sender]);\n        require(blocked[_blocking][msg.sender] >= _value && _value > 0);\n\n        blocked[_blocking][msg.sender] = blocked[_blocking][msg.sender].sub(_value);\n        balances[_unblockTo] = balances[_unblockTo].add(_value);\n\n        emit Transfer(address(0), _blocking, _value);\n\n        if (_blocking != _unblockTo) {\n            emit Transfer(_blocking, _unblockTo, _value);\n        }\n\n        emit TokenOperationEvent('unblock', _blocking, _unblockTo, _value, msg.sender);\n    }\n}\n\n// (A3)\n// Contract for freezing of investors' funds. Hence, investors will be able to withdraw money if the\n// round does not attain the softcap. From here the wallet of the beneficiary will receive all the\n// money (namely, the beneficiary, not the manager's wallet).\ncontract RefundVault is Ownable {\n    using SafeMath for uint256;\n\n    enum State { Active, Refunding, Closed }\n\n    uint8 round;\n\n    mapping (uint8 => mapping (address => uint256)) public deposited;\n\n    State public state;\n\n    event Closed();\n    event RefundsEnabled();\n    event Refunded(address indexed beneficiary, uint256 weiAmount);\n    event Deposited(address indexed beneficiary, uint256 weiAmount);\n\n    function RefundVault() public {\n        state = State.Active;\n    }\n\n    // Depositing funds on behalf of an TokenSale investor. Available to the owner of the contract (Crowdsale Contract).\n    function deposit(address investor) onlyOwner public payable {\n        require(state == State.Active);\n        deposited[round][investor] = deposited[round][investor].add(msg.value);\n        emit Deposited(investor,msg.value);\n    }\n\n    // Move the collected funds to a specified address. Available to the owner of the contract.\n    function close(address _wallet1, address _wallet2, uint256 _feesValue) onlyOwner public {\n        require(state == State.Active);\n        require(_wallet1 != 0x0);\n        state = State.Closed;\n        emit Closed();\n        if(_wallet2 != 0x0)\n        _wallet2.transfer(_feesValue);\n        _wallet1.transfer(address(this).balance);\n    }\n\n    // Allow refund to investors. Available to the owner of the contract.\n    function enableRefunds() onlyOwner public {\n        require(state == State.Active);\n        state = State.Refunding;\n        emit RefundsEnabled();\n    }\n\n    // Return the funds to a specified investor. In case of failure of the round, the investor\n    // should call this method of this contract (RefundVault) or call the method claimRefund of Crowdsale\n    // contract. This function should be called either by the investor himself, or the company\n    // (or anyone) can call this function in the loop to return funds to all investors en masse.\n    function refund(address investor) public {\n        require(state == State.Refunding);\n        uint256 depositedValue = deposited[round][investor];\n        require(depositedValue > 0);\n        deposited[round][investor] = 0;\n        investor.transfer(depositedValue);\n        emit Refunded(investor, depositedValue);\n    }\n\n    function restart() external onlyOwner {\n        require(state == State.Closed);\n        round++;\n        state = State.Active;\n\n    }\n\n    // Destruction of the contract with return of funds to the specified address. Available to\n    // the owner of the contract.\n    function del(address _wallet) external onlyOwner {\n        selfdestruct(_wallet);\n    }\n}\n\n// The contract for freezing tokens for the players and investors..\ncontract PeriodicAllocation is Ownable {\n    using SafeMath for uint256;\n\n    struct Share {\n        uint256 proportion;\n        uint256 periods;\n        uint256 periodLength;\n    }\n\n    // How many days to freeze from the moment of finalizing ICO\n    uint256 public unlockStart;\n    uint256 public totalShare;\n\n    mapping(address => Share) public shares;\n    mapping(address => uint256) public unlocked;\n\n    ERC20Basic public token;\n\n    function PeriodicAllocation(ERC20Basic _token) public {\n        token = _token;\n    }\n\n    function setUnlockStart(uint256 _unlockStart) onlyOwner external {\n        require(unlockStart == 0);\n        require(_unlockStart >= now);\n\n        unlockStart = _unlockStart;\n    }\n\n    function addShare(address _beneficiary, uint256 _proportion, uint256 _periods, uint256 _periodLength) onlyOwner external {\n        shares[_beneficiary] = Share(shares[_beneficiary].proportion.add(_proportion),_periods,_periodLength);\n        totalShare = totalShare.add(_proportion);\n    }\n\n    // If the time of freezing expired will return the funds to the owner.\n    function unlockFor(address _owner) public {\n        require(unlockStart > 0);\n        require(now >= (unlockStart.add(shares[_owner].periodLength)));\n        uint256 share = shares[_owner].proportion;\n        uint256 periodsSinceUnlockStart = (now.sub(unlockStart)).div(shares[_owner].periodLength);\n\n        if (periodsSinceUnlockStart < shares[_owner].periods) {\n            share = share.div(shares[_owner].periods).mul(periodsSinceUnlockStart);\n        }\n\n        share = share.sub(unlocked[_owner]);\n\n        if (share > 0) {\n            uint256 unlockedToken = token.balanceOf(this).mul(share).div(totalShare);\n            totalShare = totalShare.sub(share);\n            unlocked[_owner] += share;\n            token.transfer(_owner,unlockedToken);\n        }\n    }\n}\n\ncontract AllocationQueue is Ownable {\n    using SafeMath for uint256;\n\n    // address => date => tokens\n    mapping(address => mapping(uint256 => uint256)) public queue;\n    uint256 public totalShare;\n\n    ERC20Basic public token;\n\n    uint constant DAY_IN_SECONDS = 86400;\n    uint constant YEAR_IN_SECONDS = 31536000;\n    uint constant LEAP_YEAR_IN_SECONDS = 31622400;\n\n    uint16 constant ORIGIN_YEAR = 1970;\n    uint constant LEAP_YEARS_BEFORE_ORIGIN_YEAR = 477;\n\n    function AllocationQueue(ERC20Basic _token) public {\n        token = _token;\n    }\n\n    function isLeapYear(uint16 year) internal pure returns (bool) {\n        if (year % 4 != 0) {\n            return false;\n        }\n        if (year % 100 != 0) {\n            return true;\n        }\n        if (year % 400 != 0) {\n            return false;\n        }\n        return true;\n    }\n\n    function groupDates(uint256 _date) internal view returns (uint256) {\n        uint secondsAccountedFor = 0;\n\n        // Year\n        uint year = ORIGIN_YEAR + _date / YEAR_IN_SECONDS;\n        uint numLeapYears = ((year - 1) / 4 - (year - 1) / 100 + (year - 1) / 400) - LEAP_YEARS_BEFORE_ORIGIN_YEAR; // leapYearsBefore(year) - LEAP_YEARS_BEFORE_ORIGIN_YEAR\n\n        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\n        secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\n\n        while (secondsAccountedFor > _date) {\n            if (isLeapYear(uint16(year - 1))) {\n                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\n            }\n            else {\n                secondsAccountedFor -= YEAR_IN_SECONDS;\n            }\n            year -= 1;\n        }\n\n        // Month\n        uint8 month;\n\n        uint seconds31 = 31 * DAY_IN_SECONDS;\n        uint seconds30 = 30 * DAY_IN_SECONDS;\n        uint secondsFeb = (isLeapYear(uint16(year)) ? 29 : 28) * DAY_IN_SECONDS;\n\n        if (secondsAccountedFor + seconds31 > _date) {\n            month = 1;\n        } else if (secondsAccountedFor + seconds31 + secondsFeb > _date) {\n            month = 2;\n        } else if (secondsAccountedFor + 2 * seconds31 + secondsFeb > _date) {\n            month = 3;\n        } else if (secondsAccountedFor + 2 * seconds31 + seconds30 + secondsFeb > _date) {\n            month = 4;\n        } else if (secondsAccountedFor + 3 * seconds31 + seconds30 + secondsFeb > _date) {\n            month = 5;\n        } else if (secondsAccountedFor + 3 * seconds31 + 2 * seconds30 + secondsFeb > _date) {\n            month = 6;\n        } else if (secondsAccountedFor + 4 * seconds31 + 2 * seconds30 + secondsFeb > _date) {\n            month = 7;\n        } else if (secondsAccountedFor + 5 * seconds31 + 2 * seconds30 + secondsFeb > _date) {\n            month = 8;\n        } else if (secondsAccountedFor + 5 * seconds31 + 3 * seconds30 + secondsFeb > _date) {\n            month = 9;\n        } else if (secondsAccountedFor + 6 * seconds31 + 3 * seconds30 + secondsFeb > _date) {\n            month = 10;\n        } else if (secondsAccountedFor + 6 * seconds31 + 4 * seconds30 + secondsFeb > _date) {\n            month = 11;\n        } else {\n            month = 12;\n        }\n\n        return uint256(year) * 100 + uint256(month);\n    }\n\n    function addShare(address _beneficiary, uint256 _tokens, uint256 _freezeTime) onlyOwner external {\n        require(_beneficiary != 0x0);\n        require(token.balanceOf(this) == totalShare.add(_tokens));\n\n        uint256 currentDate = groupDates(now);\n        uint256 unfreezeDate = groupDates(now.add(_freezeTime));\n\n        require(unfreezeDate > currentDate);\n\n        queue[_beneficiary][unfreezeDate] = queue[_beneficiary][unfreezeDate].add(_tokens);\n        totalShare = totalShare.add(_tokens);\n    }\n\n    function unlockFor(address _owner, uint256 _date) public {\n        uint256 date = groupDates(_date);\n\n        require(date <= groupDates(now));\n\n        uint256 share = queue[_owner][date];\n\n        queue[_owner][date] = 0;\n\n        if (share > 0) {\n            token.transfer(_owner,share);\n            totalShare = totalShare.sub(share);\n        }\n    }\n\n    // Available to unlock funds for the date. Constant.\n    function getShare(address _owner, uint256 _date) public view returns(uint256){\n        uint256 date = groupDates(_date);\n\n        return queue[_owner][date];\n    }\n}\n\ncontract Creator{\n    Token public token = new Token();\n    RefundVault public refund = new RefundVault();\n\n    function createToken() external returns (Token) {\n        token.transferOwnership(msg.sender);\n        return token;\n    }\n\n    function createPeriodicAllocation(Token _token) external returns (PeriodicAllocation) {\n        PeriodicAllocation allocation = new PeriodicAllocation(_token);\n        allocation.transferOwnership(msg.sender);\n        return allocation;\n    }\n\n    function createAllocationQueue(Token _token) external returns (AllocationQueue) {\n        AllocationQueue allocation = new AllocationQueue(_token);\n        allocation.transferOwnership(msg.sender);\n        return allocation;\n    }\n\n    function createRefund() external returns (RefundVault) {\n        refund.transferOwnership(msg.sender);\n        return refund;\n    }\n\n}\n\n// Project: toss.pro\n// Developed by AXIOMAdev.com and CryptoB2B.io\n// Copying in whole or in part is prohibited\n\n// (A1)\n// The main contract for the sale and management of rounds.\n// 0000000000000000000000000000000000000000000000000000000000000000\ncontract Crowdsale{\n\n    uint256 constant USER_UNPAUSE_TOKEN_TIMEOUT =  60 days;\n    uint256 constant FORCED_REFUND_TIMEOUT1     = 400 days;\n    uint256 constant FORCED_REFUND_TIMEOUT2     = 600 days;\n    uint256 constant ROUND_PROLONGATE           =   0 days;\n    uint256 constant BURN_TOKENS_TIME           =  90 days;\n\n    using SafeMath for uint256;\n\n    enum TokenSaleType {round1, round2}\n    TokenSaleType public TokenSale = TokenSaleType.round2;\n\n    //              0             1         2        3        4        5       6       7        8     9     10        11       12\n    enum Roles {beneficiary, accountant, manager, observer, bounty, advisers, team, founders, fund, fees, players, airdrop, referrals}\n\n    Creator public creator;\n    bool creator2;\n    bool isBegin=false;\n    Token public token;\n    RefundVault public vault;\n    PeriodicAllocation public allocation;\n    AllocationQueue public allocationQueue;\n\n    bool public isFinalized;\n    bool public isInitialized;\n    bool public isPausedCrowdsale;\n    bool public chargeBonuses;\n\n    // Initially, all next 7+ roles/wallets are given to the Manager. The Manager is an employee of the company\n    // with knowledge of IT, who publishes the contract and sets it up. However, money and tokens require\n    // a Beneficiary and other roles (Accountant, Team, etc.). The Manager will not have the right\n    // to receive them. To enable this, the Manager must either enter specific wallets here, or perform\n    // this via method changeWallet. In the finalization methods it is written which wallet and\n    // what percentage of tokens are received.\n    address[13] public wallets = [\n\n    // Beneficiary\n    // Receives all the money (when finalizing Round1 & Round2)\n    0x4e82764a0be4E0859e87cD47eF348e8D892C2567,\n\n    // Accountant\n    // Receives all the tokens for non-ETH investors (when finalizing Round1 & Round2)\n    0xD29f0aE1621F4Be48C4DF438038E38af546DA498,\n\n    // Manager\n    // All rights except the rights to receive tokens or money. Has the right to change any other\n    // wallets (Beneficiary, Accountant, ...), but only if the round has not started. Once the\n    // round is initialized, the Manager has lost all rights to change the wallets.\n    // If the TokenSale is conducted by one person, then nothing needs to be changed. Permit all 7 roles\n    // point to a single wallet.\n    msg.sender,\n\n    // Observer\n    // Has only the right to call paymentsInOtherCurrency (please read the document)\n    0x27609c2e3d9810FdFCe157F2c1d87b717d0b0C10,\n\n    // Bounty - 1% freeze 2 month\n    0xd7AC0393e2B29D8aC6221CF69c27171aba6278c4,\n\n    // Advisers 4% freeze 1 month\n    0x765f60E314766Bc25eb2a9F66991Fe867D42A449,\n\n    // Team, 7%, freeze 50% 6 month, 50% 12 month\n    0xF9f0c53c07803a2670a354F3de88482393ABdBac,\n\n    // Founders, 11% freeze 50% 6 month, 50% 12 month\n    0x4816b3bA11477e42A81FffA8a4e376e4D1a7f007,\n\n    // Fund, 12% freeze 50% 2 month, 50% 12 month\n    0xe3C02072f8145DabCd7E7fe769ba1E3e73688ECc,\n\n    // Fees, 7% money\n    0xEB29e654AFF7658394C9d413dDC66711ADD44F59,\n\n    // Players and investors, 7% freezed. Unfreeze 1% per month after ICO finished\n    0x6faEc0c1ff412Fd041aB30081Cae677B362bd3c1,\n\n    // Airdrop, 4% freeze 2 month\n    0x7AA186f397dB8aE1FB80897e4669c1Ea126BA788,\n\n    // Referrals, 4% no freeze\n    0xAC26988d1573FC6626069578E6A5a4264F76f0C5\n\n    ];\n\n\n\n    struct Bonus {\n    uint256 value;\n    uint256 procent;\n    }\n\n    struct Profit {\n    uint256 percent;\n    uint256 duration;\n    }\n\n    Bonus[] public bonuses;\n    Profit[] public profits;\n\n\n    uint256 public startTime= 1547197200;\n    uint256 public stopTime= 0;\n\n    // How many tokens (excluding the bonus) are transferred to the investor in exchange for 1 ETH\n    // **QUINTILLIONS** 10^18 for human, *10**18 for Solidity, 1e18 for MyEtherWallet (MEW).\n    // Example: if 1ETH = 40.5 Token ==> use 40500 finney\n    uint256 public rate = 25000 ether;\n\n    // ETH/USD rate in US$\n    // **QUINTILLIONS** 10^18 / *10**18 / 1e18. Example: ETH/USD=$1000 ==> use 1000*10**18 (Solidity) or 1000 ether or 1000e18 (MEW)\n    uint256 public exchange  = 150 ether; // not in use\n\n    // If the round does not attain this value before the closing date, the round is recognized as a\n    // failure and investors take the money back (the founders will not interfere in any way).\n    // **QUINTILLIONS** 10^18 / *10**18 / 1e18. Example: softcap=15ETH ==> use 15*10**18 (Solidity) or 15e18 (MEW)\n    uint256 public softCap = 16133 ether;\n\n    // The maximum possible amount of income\n    // **QUINTILLIONS** 10^18 / *10**18 / 1e18. Example: hardcap=123.45ETH ==> use 123450*10**15 (Solidity) or 12345e15 (MEW)\n    uint256 public hardCap = 63333 ether;\n\n    // If the last payment is slightly higher than the hardcap, then the usual contracts do\n    // not accept it, because it goes beyond the hardcap. However it is more reasonable to accept the\n    // last payment, very slightly raising the hardcap. The value indicates by how many ETH the\n    // last payment can exceed the hardcap to allow it to be paid. Immediately after this payment, the\n    // round closes. The funders should write here a small number, not more than 1% of the CAP.\n    // Can be equal to zero, to cancel.\n    // **QUINTILLIONS** 10^18 / *10**18 / 1e18\n    uint256 public overLimit = 20 ether;\n\n    // The minimum possible payment from an investor in ETH. Payments below this value will be rejected.\n    // **QUINTILLIONS** 10^18 / *10**18 / 1e18. Example: minPay=0.1ETH ==> use 100*10**15 (Solidity) or 100e15 (MEW)\n    uint256 public minPay = 71 finney;\n\n    uint256 public maxAllProfit = 30;\n\n    uint256 public ethWeiRaised;\n    uint256 public nonEthWeiRaised;\n    uint256 public weiRound1;\n    uint256 public tokenReserved;\n\n    uint256 public totalSaledToken;\n\n    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n\n    event Finalized();\n    event Initialized();\n\n    function Crowdsale(Creator _creator) public\n    {\n        creator2=true;\n        creator=_creator;\n    }\n\n    function onlyAdmin(bool forObserver) internal view {\n        require(wallets[uint8(Roles.manager)] == msg.sender || wallets[uint8(Roles.beneficiary)] == msg.sender ||\n        forObserver==true && wallets[uint8(Roles.observer)] == msg.sender);\n    }\n\n    // Setting of basic parameters, analog of class constructor\n    // @ Do I have to use the function      see your scenario\n    // @ When it is possible to call        before Round 1/2\n    // @ When it is launched automatically  -\n    // @ Who can call the function          admins\n    function begin() internal\n    {\n        if (isBegin) return;\n        isBegin=true;\n\n        token = creator.createToken();\n        allocation = creator.createPeriodicAllocation(token);\n        allocationQueue = creator.createAllocationQueue(token);\n\n        if (creator2) {\n            vault = creator.createRefund();\n        }\n\n        token.setUnpausedWallet(wallets[uint8(Roles.accountant)], true);\n        token.setUnpausedWallet(wallets[uint8(Roles.manager)], true);\n        token.setUnpausedWallet(wallets[uint8(Roles.bounty)], true);\n        token.setUnpausedWallet(wallets[uint8(Roles.advisers)], true);\n        token.setUnpausedWallet(wallets[uint8(Roles.observer)], true);\n        token.setUnpausedWallet(wallets[uint8(Roles.players)], true);\n        token.setUnpausedWallet(wallets[uint8(Roles.airdrop)], true);\n        token.setUnpausedWallet(wallets[uint8(Roles.fund)], true);\n        token.setUnpausedWallet(wallets[uint8(Roles.founders)], true);\n        token.setUnpausedWallet(wallets[uint8(Roles.referrals)], true);\n\n        token.setUnpausedWallet(allocation, true);\n        token.setUnpausedWallet(allocationQueue, true);\n\n        bonuses.push(Bonus(71 ether, 30));\n\n        profits.push(Profit(15,2 days));\n        profits.push(Profit(10,2 days));\n        profits.push(Profit(5,4 days));\n\n    }\n\n\n\n    // Issue of tokens for the zero round, it is usually called: private pre-sale (Round 0)\n    // @ Do I have to use the function      may be\n    // @ When it is possible to call        before Round 1/2 and untill crowdsale end\n    // @ When it is launched automatically  -\n    // @ Who can call the function          admins\n    function privateMint(uint256 _amount) public {\n        onlyAdmin(false);\n        require(stopTime == 0);\n\n        uint256 weiAmount = _amount.mul(1 ether).div(rate);\n        bool withinCap = weiAmount <= hardCap.sub(weiRaised()).add(overLimit);\n\n        require(withinCap);\n\n        begin();\n\n        // update state\n        ethWeiRaised = ethWeiRaised.add(weiAmount);\n\n        token.mint(wallets[uint8(Roles.accountant)],_amount);\n        systemWalletsMint(_amount);\n    }\n\n    // info\n    function totalSupply() external view returns (uint256){\n        return token.totalSupply();\n    }\n\n    // Returns the name of the current round in plain text. Constant.\n    function getTokenSaleType() external view returns(string){\n        return (TokenSale == TokenSaleType.round1)?'round1':'round2';\n    }\n\n    // Transfers the funds of the investor to the contract of return of funds. Internal.\n    function forwardFunds() internal {\n        if(address(vault) != 0x0){\n            vault.deposit.value(msg.value)(msg.sender);\n        }else {\n            if(address(this).balance > 0){\n                wallets[uint8(Roles.beneficiary)].transfer(address(this).balance);\n            }\n        }\n\n    }\n\n    // Check for the possibility of buying tokens. Inside. Constant.\n    function validPurchase() internal view returns (bool) {\n\n        // The round started and did not end\n        bool withinPeriod = (now > startTime && stopTime == 0);\n\n        // Rate is greater than or equal to the minimum\n        bool nonZeroPurchase = msg.value >= minPay;\n\n        // hardCap is not reached, and in the event of a transaction, it will not be exceeded by more than OverLimit\n        bool withinCap = msg.value <= hardCap.sub(weiRaised()).add(overLimit);\n\n        // round is initialized and no \"Pause of trading\" is set\n        return withinPeriod && nonZeroPurchase && withinCap && isInitialized && !isPausedCrowdsale;\n    }\n\n    // Check for the ability to finalize the round. Constant.\n    function hasEnded() public view returns (bool) {\n\n        bool capReached = weiRaised() >= hardCap;\n\n        return (stopTime > 0 || capReached) && isInitialized;\n    }\n\n    // Finalize. Only available to the Manager and the Beneficiary. If the round failed, then\n    // anyone can call the finalization to unlock the return of funds to investors\n    // You must call a function to finalize each round (after the Round1 & after the Round2)\n    // @ Do I have to use the function      yes\n    // @ When it is possible to call        after end of Round1 & Round2\n    // @ When it is launched automatically  no\n    // @ Who can call the function          admins or anybody (if round is failed)\n    function finalize() public {\n\n        require(wallets[uint8(Roles.manager)] == msg.sender || wallets[uint8(Roles.beneficiary)] == msg.sender || !goalReached());\n        require(!isFinalized);\n        require(hasEnded() || ((wallets[uint8(Roles.manager)] == msg.sender || wallets[uint8(Roles.beneficiary)] == msg.sender) && goalReached()));\n\n        isFinalized = true;\n        finalization();\n        emit Finalized();\n    }\n\n    // The logic of finalization. Internal\n    // @ Do I have to use the function      no\n    // @ When it is possible to call        -\n    // @ When it is launched automatically  after end of round\n    // @ Who can call the function          -\n    function finalization() internal {\n\n        if (stopTime == 0) {\n            stopTime = now;\n        }\n\n        //uint256 feesValue;\n        // If the goal of the achievement\n        if (goalReached()) {\n\n            if(address(vault) != 0x0){\n                // Send ether to Beneficiary\n                vault.close(wallets[uint8(Roles.beneficiary)], wallets[uint8(Roles.fees)], ethWeiRaised.mul(7).div(100)); //7% for fees\n            }\n\n            // if there is anything to give\n            if (tokenReserved > 0) {\n\n                token.mint(wallets[uint8(Roles.accountant)],tokenReserved);\n\n                // Reset the counter\n                tokenReserved = 0;\n            }\n\n            // If the finalization is Round 1\n            if (TokenSale == TokenSaleType.round1) {\n\n                // Reset settings\n                isInitialized = false;\n                isFinalized = false;\n\n                // Switch to the second round (to Round2)\n                TokenSale = TokenSaleType.round2;\n\n                // Reset the collection counter\n                weiRound1 = weiRaised();\n                ethWeiRaised = 0;\n                nonEthWeiRaised = 0;\n\n\n\n            }\n            else // If the second round is finalized\n            {\n\n                // Permission to collect tokens to those who can pick them up\n                chargeBonuses = true;\n\n                totalSaledToken = token.totalSupply();\n\n            }\n\n        }\n        else if (address(vault) != 0x0) // If they failed round\n        {\n            // Allow investors to withdraw their funds\n\n            vault.enableRefunds();\n        }\n    }\n\n    // The Manager freezes the tokens for the Team.\n    // You must call a function to finalize Round 2 (only after the Round2)\n    // @ Do I have to use the function      yes\n    // @ When it is possible to call        Round2\n    // @ When it is launched automatically  -\n    // @ Who can call the function          admins\n    function finalize2() public {\n\n        onlyAdmin(false);\n        require(chargeBonuses);\n        chargeBonuses = false;\n\n        allocation.addShare(wallets[uint8(Roles.players)], 7, 7, 30 days); // Freeze 7%. Unfreeze 1% per month after ICO finished\n\n        allocation.setUnlockStart(now);\n    }\n\n\n\n    // Initializing the round. Available to the manager. After calling the function,\n    // the Manager loses all rights: Manager can not change the settings (setup), change\n    // wallets, prevent the beginning of the round, etc. You must call a function after setup\n    // for the initial round (before the Round1 and before the Round2)\n    // @ Do I have to use the function      yes\n    // @ When it is possible to call        before each round\n    // @ When it is launched automatically  -\n    // @ Who can call the function          admins\n    function initialize() public {\n\n        onlyAdmin(false);\n        // If not yet initialized\n        require(!isInitialized);\n        begin();\n\n\n        // And the specified start time has not yet come\n        // If initialization return an error, check the start date!\n        require(now <= startTime);\n\n        initialization();\n\n        emit Initialized();\n\n        isInitialized = true;\n    }\n\n    function initialization() internal {\n        if (address(vault) != 0x0 && vault.state() != RefundVault.State.Active){\n            vault.restart();\n        }\n    }\n\n    // Manually stops the round. Available to the manager.\n    // @ Do I have to use the function      yes\n    // @ When it is possible to call        after each round\n    // @ When it is launched automatically  -\n    // @ Who can call the function          admins\n    function stop() public {\n        onlyAdmin(false);\n\n        require(stopTime == 0 && now > startTime);\n\n        stopTime = now;\n    }\n\n    // At the request of the investor, we raise the funds (if the round has failed because of the hardcap)\n    // @ Do I have to use the function      no\n    // @ When it is possible to call        if round is failed (softcap not reached)\n    // @ When it is launched automatically  -\n    // @ Who can call the function          all investors\n    function claimRefund() external {\n        require(address(vault) != 0x0);\n        vault.refund(msg.sender);\n    }\n\n    // We check whether we collected the necessary minimum funds. Constant.\n    function goalReached() public view returns (bool) {\n        return weiRaised() >= softCap;\n    }\n\n\n    // Customize. The arguments are described in the constructor above.\n    // @ Do I have to use the function      yes\n    // @ When it is possible to call        before each round\n    // @ When it is launched automatically  -\n    // @ Who can call the function          admins\n    function setup(uint256 _startTime, uint256 _softCap, uint256 _hardCap,\n    uint256 _rate, uint256 _exchange,\n    uint256 _maxAllProfit, uint256 _overLimit, uint256 _minPay,\n    uint256[] _durationTB , uint256[] _percentTB, uint256[] _valueVB, uint256[] _percentVB) public\n    {\n\n        onlyAdmin(false);\n        require(!isInitialized);\n\n        begin();\n\n        // Date and time are correct\n        require(now <= _startTime);\n        startTime = _startTime;\n\n        // The parameters are correct\n        require(_softCap <= _hardCap);\n        softCap = _softCap;\n        hardCap = _hardCap;\n\n        require(_rate > 0);\n        rate = _rate;\n\n        overLimit = _overLimit;\n        minPay = _minPay;\n        exchange = _exchange;\n        maxAllProfit = _maxAllProfit;\n\n        require(_valueVB.length == _percentVB.length);\n        bonuses.length = _valueVB.length;\n        for(uint256 i = 0; i < _valueVB.length; i++){\n            bonuses[i] = Bonus(_valueVB[i],_percentVB[i]);\n        }\n\n        require(_percentTB.length == _durationTB.length);\n        profits.length = _percentTB.length;\n        for( i = 0; i < _percentTB.length; i++){\n            profits[i] = Profit(_percentTB[i],_durationTB[i]);\n        }\n\n    }\n\n    // Collected funds for the current round. Constant.\n    function weiRaised() public constant returns(uint256){\n        return ethWeiRaised.add(nonEthWeiRaised);\n    }\n\n    // Returns the amount of fees for both phases. Constant.\n    function weiTotalRaised() external constant returns(uint256){\n        return weiRound1.add(weiRaised());\n    }\n\n    // Returns the percentage of the bonus on the current date. Constant.\n    function getProfitPercent() public constant returns (uint256){\n        return getProfitPercentForData(now);\n    }\n\n    // Returns the percentage of the bonus on the given date. Constant.\n    function getProfitPercentForData(uint256 _timeNow) public constant returns (uint256){\n        uint256 allDuration;\n        for(uint8 i = 0; i < profits.length; i++){\n            allDuration = allDuration.add(profits[i].duration);\n            if(_timeNow < startTime.add(allDuration)){\n                return profits[i].percent;\n            }\n        }\n        return 0;\n    }\n\n    function getBonuses(uint256 _value) public constant returns (uint256,uint256){\n        if(bonuses.length == 0 || bonuses[0].value > _value){\n            return (0,0);\n        }\n        uint16 i = 1;\n        for(i; i < bonuses.length; i++){\n            if(bonuses[i].value > _value){\n                break;\n            }\n        }\n        return (bonuses[i-1].value,bonuses[i-1].procent);\n    }\n\n    // Remove the \"Pause of exchange\". Available to the manager at any time. If the\n    // manager refuses to remove the pause, then 30-120 days after the successful\n    // completion of the TokenSale, anyone can remove a pause and allow the exchange to continue.\n    // The manager does not interfere and will not be able to delay the term.\n    // He can only cancel the pause before the appointed time.\n    // ***CHECK***SCENARIO***\n    // @ Do I have to use the function      YES YES YES\n    // @ When it is possible to call        after end of Token Sale  (or any time - not necessary)\n    // @ When it is launched automatically  -\n    // @ Who can call the function          admins or anybody\n    function tokenUnpause() external {\n\n        require(wallets[uint8(Roles.manager)] == msg.sender\n        || (stopTime != 0 && now > stopTime.add(USER_UNPAUSE_TOKEN_TIMEOUT) && TokenSale == TokenSaleType.round2 && isFinalized && goalReached()));\n        token.setPause(false);\n    }\n\n    // Enable the \"Pause of exchange\". Available to the manager until the TokenSale is completed.\n    // The manager cannot turn on the pause, for example, 3 years after the end of the TokenSale.\n    // ***CHECK***SCENARIO***\n    // @ Do I have to use the function      no\n    // @ When it is possible to call        while Round2 not ended\n    // @ When it is launched automatically  Round0\n    // @ Who can call the function          admins\n    function tokenPause() public {\n        onlyAdmin(false);\n        require(!isFinalized);\n        token.setPause(true);\n    }\n\n    // Pause of sale. Available to the manager.\n    // @ Do I have to use the function      no\n    // @ When it is possible to call        during active rounds\n    // @ When it is launched automatically  -\n    // @ Who can call the function          admins\n    function setCrowdsalePause(bool mode) public {\n        onlyAdmin(false);\n        isPausedCrowdsale = mode;\n    }\n\n    // For example - After 5 years of the project's existence, all of us suddenly decided collectively\n    // (company + investors) that it would be more profitable for everyone to switch to another smart\n    // contract responsible for tokens. The company then prepares a new token, investors\n    // disassemble, study, discuss, etc. After a general agreement, the manager allows any investor:\n    //      - to burn the tokens of the previous contract\n    //      - generate new tokens for a new contract\n    // It is understood that after a general solution through this function all investors\n    // will collectively (and voluntarily) move to a new token.\n    // @ Do I have to use the function      no\n    // @ When it is possible to call        only after Token Sale!\n    // @ When it is launched automatically  -\n    // @ Who can call the function          admins\n    function moveTokens(address _migrationAgent) public {\n        onlyAdmin(false);\n        token.setMigrationAgent(_migrationAgent);\n    }\n\n    // @ Do I have to use the function      no\n    // @ When it is possible to call        only after Token Sale!\n    // @ When it is launched automatically  -\n    // @ Who can call the function          admins\n    function migrateAll(address[] _holders) public {\n        onlyAdmin(false);\n        token.migrateAll(_holders);\n    }\n\n    // Change the address for the specified role.\n    // Available to any wallet owner except the observer.\n    // Available to the manager until the round is initialized.\n    // The Observer's wallet or his own manager can change at any time.\n    // @ Do I have to use the function      no\n    // @ When it is possible to call        depend...\n    // @ When it is launched automatically  -\n    // @ Who can call the function          staff (all 7+ roles)\n    function changeWallet(Roles _role, address _wallet) external\n    {\n        require(\n        (msg.sender == wallets[uint8(_role)] && _role != Roles.observer)\n        ||\n        (msg.sender == wallets[uint8(Roles.manager)] && (!isInitialized || _role == Roles.observer) && _role != Roles.fees )\n        );\n\n        wallets[uint8(_role)] = _wallet;\n    }\n\n\n    // The beneficiary at any time can take rights in all roles and prescribe his wallet in all the\n    // rollers. Thus, he will become the recipient of tokens for the role of Accountant,\n    // Team, etc. Works at any time.\n    // @ Do I have to use the function      no\n    // @ When it is possible to call        any time\n    // @ When it is launched automatically  -\n    // @ Who can call the function          only Beneficiary\n    function resetAllWallets() external{\n        address _beneficiary = wallets[uint8(Roles.beneficiary)];\n        require(msg.sender == _beneficiary);\n        for(uint8 i = 0; i < wallets.length; i++){\n            if(uint8(Roles.fees) == i || uint8(Roles.team) == i)\n                continue;\n\n            wallets[i] = _beneficiary;\n        }\n        token.setUnpausedWallet(_beneficiary, true);\n    }\n\n\n    // Burn the investor tokens, if provided by the Token Sale scenario. Limited time available - BURN_TOKENS_TIME\n    // ***CHECK***SCENARIO***\n    // @ Do I have to use the function      no\n    // @ When it is possible to call        any time\n    // @ When it is launched automatically  -\n    // @ Who can call the function          admin\n    function massBurnTokens(address[] _beneficiary, uint256[] _value) external {\n        onlyAdmin(false);\n        require(stopTime == 0 || stopTime.add(BURN_TOKENS_TIME) > now);\n        require(_beneficiary.length == _value.length);\n        for(uint16 i; i<_beneficiary.length; i++) {\n            token.burn(_beneficiary[i],_value[i]);\n        }\n    }\n\n    // If a little more than a year has elapsed (Round2 start date + 400 days), a smart contract\n    // will allow you to send all the money to the Beneficiary, if any money is present. This is\n    // possible if you mistakenly launch the Round2 for 30 years (not 30 days), investors will transfer\n    // money there and you will not be able to pick them up within a reasonable time. It is also\n    // possible that in our checked script someone will make unforeseen mistakes, spoiling the\n    // finalization. Without finalization, money cannot be returned. This is a rescue option to\n    // get around this problem, but available only after a year (400 days).\n\n    // Another reason - the TokenSale was a failure, but not all ETH investors took their money during the year after.\n    // Some investors may have lost a wallet key, for example.\n\n    // The method works equally with the Round1 and Round2. When the Round1 starts, the time for unlocking\n    // the distructVault begins. If the TokenSale is then started, then the term starts anew from the first day of the TokenSale.\n\n    // Next, act independently, in accordance with obligations to investors.\n\n    // Within 400 days (FORCED_REFUND_TIMEOUT1) of the start of the Round, if it fails only investors can take money. After\n    // the deadline this can also include the company as well as investors, depending on who is the first to use the method.\n    // @ Do I have to use the function      no\n    // @ When it is possible to call        -\n    // @ When it is launched automatically  -\n    // @ Who can call the function          beneficiary & manager\n    function distructVault() public {\n        require(address(vault) != 0x0);\n        require(stopTime != 0 && !goalReached());\n\n        if (wallets[uint8(Roles.beneficiary)] == msg.sender && (now > startTime.add(FORCED_REFUND_TIMEOUT1))) {\n            vault.del(wallets[uint8(Roles.beneficiary)]);\n        }\n        if (wallets[uint8(Roles.manager)] == msg.sender && (now > startTime.add(FORCED_REFUND_TIMEOUT2))) {\n            vault.del(wallets[uint8(Roles.manager)]);\n        }\n    }\n\n\n    // We accept payments other than Ethereum (ETH) and other currencies, for example, Bitcoin (BTC).\n    // Perhaps other types of cryptocurrency - see the original terms in the white paper and on the TokenSale website.\n\n    // We release tokens on Ethereum. During the Round1 and Round2 with a smart contract, you directly transfer\n    // the tokens there and immediately, with the same transaction, receive tokens in your wallet.\n\n    // When paying in any other currency, for example in BTC, we accept your money via one common wallet.\n    // Our manager fixes the amount received for the bitcoin wallet and calls the method of the smart\n    // contract paymentsInOtherCurrency to inform him how much foreign currency has been received - on a daily basis.\n    // The smart contract pins the number of accepted ETH directly and the number of BTC. Smart contract\n    // monitors softcap and hardcap, so as not to go beyond this framework.\n\n    // In theory, it is possible that when approaching hardcap, we will receive a transfer (one or several\n    // transfers) to the wallet of BTC, that together with previously received money will exceed the hardcap in total.\n    // In this case, we will refund all the amounts above, in order not to exceed the hardcap.\n\n    // Collection of money in BTC will be carried out via one common wallet. The wallet's address will be published\n    // everywhere (in a white paper, on the TokenSale website, on Telegram, on Bitcointalk, in this code, etc.)\n    // Anyone interested can check that the administrator of the smart contract writes down exactly the amount\n    // in ETH (in equivalent for BTC) there. In theory, the ability to bypass a smart contract to accept money in\n    // BTC and not register them in ETH creates a possibility for manipulation by the company. Thanks to\n    // paymentsInOtherCurrency however, this threat is leveled.\n\n    // Any user can check the amounts in BTC and the variable of the smart contract that accounts for this\n    // (paymentsInOtherCurrency method). Any user can easily check the incoming transactions in a smart contract\n    // on a daily basis. Any hypothetical tricks on the part of the company can be exposed and panic during the TokenSale,\n    // simply pointing out the incompatibility of paymentsInOtherCurrency (ie, the amount of ETH + BTC collection)\n    // and the actual transactions in BTC. The company strictly adheres to the described principles of openness.\n\n    // The company administrator is required to synchronize paymentsInOtherCurrency every working day (but you\n    // cannot synchronize if there are no new BTC payments). In the case of unforeseen problems, such as\n    // brakes on the Ethereum network, this operation may be difficult. You should only worry if the\n    // administrator does not synchronize the amount for more than 96 hours in a row, and the BTC wallet\n    // receives significant amounts.\n\n    // This scenario ensures that for the sum of all fees in all currencies this value does not exceed hardcap.\n\n    // Addresses for other currencies:\n    // BTC Address: 3NKfzN4kShB7zpWTe2vzFDY4NuYa1SqdEV\n\n    // ** QUINTILLIONS ** 10^18 / 1**18 / 1e18\n\n    // @ Do I have to use the function      no\n    // @ When it is possible to call        during active rounds\n    // @ When it is launched automatically  every day from cryptob2b token software\n    // @ Who can call the function          admins + observer\n    function paymentsInOtherCurrency(uint256 _token, uint256 _value) public {\n        //require(wallets[uint8(Roles.observer)] == msg.sender || wallets[uint8(Roles.manager)] == msg.sender);\n        onlyAdmin(true);\n        bool withinPeriod = (now >= startTime && stopTime == 0);\n\n        bool withinCap = _value.add(ethWeiRaised) <= hardCap.add(overLimit);\n        require(withinPeriod && withinCap && isInitialized);\n\n        nonEthWeiRaised = _value;\n        tokenReserved = _token;\n\n    }\n\n    function queueMint(address _beneficiary, uint256 _value, uint256 _freezeTime) internal {\n        token.mint(address(allocationQueue), _value);\n        allocationQueue.addShare(_beneficiary, _value, _freezeTime);\n    }\n\n    function systemWalletsMint(uint256 tokens) internal {\n        // 4%  tokens for Airdrop, freeze 2 month\n        queueMint(wallets[uint8(Roles.airdrop)], tokens.mul(4).div(50), 60 days);\n\n        // 7% - tokens for Players and Investors\n        token.mint(address(allocation), tokens.mul(7).div(50));\n\n        // 4% - tokens to Advisers wallet, freeze 1 month\n        queueMint(wallets[uint8(Roles.advisers)], tokens.mul(4).div(50), 30 days);\n\n        // 7% - tokens to Team wallet, freeze 50% 6 month, 50% 12 month\n        queueMint(wallets[uint8(Roles.team)], tokens.mul(7).div(2).div(50), 6 * 30 days);\n        queueMint(wallets[uint8(Roles.team)], tokens.mul(7).div(2).div(50), 365 days);\n\n        // 1% - tokens to Bounty wallet, freeze 2 month\n        queueMint(wallets[uint8(Roles.bounty)], tokens.mul(1).div(50), 60 days);\n\n        // 11% - tokens to Founders wallet, freeze 50% 6 month, 50% 12 month\n        queueMint(wallets[uint8(Roles.founders)], tokens.mul(11).div(2).div(50), 6 * 30 days);\n        queueMint(wallets[uint8(Roles.founders)], tokens.mul(11).div(2).div(50), 365 days);\n\n        // 12% - tokens to Fund wallet, freeze 50% 2 month, 50% 12 month\n        queueMint(wallets[uint8(Roles.fund)], tokens.mul(12).div(2).div(50), 2 * 30 days);\n        queueMint(wallets[uint8(Roles.fund)], tokens.mul(12).div(2).div(50), 365 days);\n\n        // 4% - tokens for Referrals\n        token.mint(wallets[uint8(Roles.referrals)], tokens.mul(4).div(50));\n    }\n\n    // The function for obtaining smart contract funds in ETH. If all the checks are true, the token is\n    // transferred to the buyer, taking into account the current bonus.\n    function buyTokens(address beneficiary) public payable {\n        require(beneficiary != 0x0);\n        require(validPurchase());\n\n        uint256 weiAmount = msg.value;\n\n        uint256 ProfitProcent = getProfitPercent();\n\n        uint256 value;\n        uint256 percent;\n\n        (value, percent) = getBonuses(weiAmount);\n\n        Bonus memory curBonus = Bonus(value, percent);\n\n        uint256 bonus = curBonus.procent;\n\n        // --------------------------------------------------------------------------------------------\n        // *** Scenario 1 - select max from all bonuses + check maxAllProfit\n        uint256 totalProfit = (ProfitProcent < bonus) ? bonus : ProfitProcent;\n\n        // --------------------------------------------------------------------------------------------\n        totalProfit = (totalProfit > maxAllProfit) ? maxAllProfit : totalProfit;\n\n        // calculate token amount to be created\n        uint256 tokens = weiAmount.mul(rate).mul(totalProfit.add(100)).div(100 ether);\n\n        // update state\n        ethWeiRaised = ethWeiRaised.add(weiAmount);\n\n        token.mint(beneficiary, tokens);\n\n        systemWalletsMint(tokens);\n\n        emit TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\n\n        forwardFunds();\n    }\n\n    // buyTokens alias\n    function () public payable {\n        buyTokens(msg.sender);\n    }\n\n\n\n}",
  "abi": "[{\"constant\":false,\"inputs\":[],\"name\":\"finalize2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"creator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stopTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address[]\"},{\"name\":\"_value\",\"type\":\"uint256[]\"}],\"name\":\"massBurnTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"tokenPause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRound1\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"tokenUnpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiTotalRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"profits\",\"outputs\":[{\"name\":\"percent\",\"type\":\"uint256\"},{\"name\":\"duration\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TokenSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"uint256\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"paymentsInOtherCurrency\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isInitialized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxAllProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethWeiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetAllWallets\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getProfitPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSaledToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_migrationAgent\",\"type\":\"address\"}],\"name\":\"moveTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_holders\",\"type\":\"address[]\"}],\"name\":\"migrateAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"wallets\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"goalReached\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minPay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allocation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_role\",\"type\":\"uint8\"},{\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"changeWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFinalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"softCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_timeNow\",\"type\":\"uint256\"}],\"name\":\"getProfitPercentForData\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"distructVault\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_softCap\",\"type\":\"uint256\"},{\"name\":\"_hardCap\",\"type\":\"uint256\"},{\"name\":\"_rate\",\"type\":\"uint256\"},{\"name\":\"_exchange\",\"type\":\"uint256\"},{\"name\":\"_maxAllProfit\",\"type\":\"uint256\"},{\"name\":\"_overLimit\",\"type\":\"uint256\"},{\"name\":\"_minPay\",\"type\":\"uint256\"},{\"name\":\"_durationTB\",\"type\":\"uint256[]\"},{\"name\":\"_percentTB\",\"type\":\"uint256[]\"},{\"name\":\"_valueVB\",\"type\":\"uint256[]\"},{\"name\":\"_percentVB\",\"type\":\"uint256[]\"}],\"name\":\"setup\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bonuses\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"procent\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"privateMint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nonEthWeiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"chargeBonuses\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isPausedCrowdsale\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allocationQueue\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenSaleType\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchange\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"overLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenReserved\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"getBonuses\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"mode\",\"type\":\"bool\"}],\"name\":\"setCrowdsalePause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasEnded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_creator\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Finalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Initialized\",\"type\":\"event\"}]",
  "bytecode": "606060409081526000805460b060020a60ff021960ff199091166001171690556101a090519081016040908152734e82764a0be4e0859e87cd47ef348e8d892c2567825273d29f0ae1621f4be48c4df438038e38af546da498602083015233600160a060020a0316908201527327609c2e3d9810fdfce157f2c1d87b717d0b0c10606082015273d7ac0393e2b29d8ac6221cf69c27171aba6278c4608082015273765f60e314766bc25eb2a9f66991fe867d42a44960a082015273f9f0c53c07803a2670a354f3de88482393abdbac60c0820152734816b3ba11477e42a81fffa8a4e376e4d1a7f00760e082015273e3c02072f8145dabcd7e7fe769ba1e3e73688ecc61010082015273eb29e654aff7658394c9d413ddc66711add44f59610120820152736faec0c1ff412fd041ab30081cae677b362bd3c1610140820152737aa186f397db8ae1fb80897e4669c1ea126ba78861016082015273ac26988d1573fc6626069578e6a5a4264f76f0c56101808201526200018490600590600d6200025a565b50635c385b10601455600060155569054b40b1f852bda00000601655680821ab0d441498000060175569036a9259c7b3e0f40000601855690d6949ef6b62867400006019556801158e460913d00000601a5566fc3e1fb30d8000601b55601e601c553415620001f257600080fd5b604051602080620032fb8339810160405280805160008054600160a060020a039092166101000261010060a860020a031960a860020a60ff02199093167501000000000000000000000000000000000000000000179290921691909117905550620002e39050565b82600d8101928215620002a7579160200282015b82811115620002a75782518254600160a060020a031916600160a060020a0391909116178255602092909201916001909101906200026e565b50620002b5929150620002b9565b5090565b620002e091905b80821115620002b5578054600160a060020a0319168155600101620002c0565b90565b61300880620002f36000396000f30060606040526004361061026e5763ffffffff60e060020a60003504166302093ee2811461027957806302d05d3f1461028c57806303ff5e73146102bb5780630580d5c7146102e057806307da68f51461030a5780630abd2ba81461031d5780631391697d1461033057806318160ddd146103435780631b302a16146103565780632c4e722e146103695780632cde15d11461037c5780632e5f6d4c1461038f57806331380c89146103bd578063333dbda8146103f4578063392e53cd1461040d5780634042b66f14610434578063426f5531146104475780634bb278f31461045a5780634bca46261461046d578063549df19f14610480578063566fc6de1461049357806360a22932146104a657806363689b4a146104b9578063680b3bdf146104d857806378e97925146105275780637ad71f721461053a5780637d3d6522146105505780638129fc1c1461056357806382d186501461057657806388a17bde146105895780638a0c47cd1461059c5780638d4e4083146105c1578063906a26e0146105d457806391816981146105e757806399554fb7146105fd578063a1d7d1dd14610610578063ab37564114610744578063abfe40a81461075a578063b16d153814610770578063b5545a3c14610783578063bc7411b214610796578063c8b43c10146107a9578063c9e57259146107bc578063caa035d6146107cf578063d2f7265a14610859578063e06e0e431461086c578063e195d0961461087f578063e59c9ada14610892578063e9bec833146108a8578063ec8ac4d8146108c0578063ecb70fb7146108d4578063fb86a404146108e7578063fbfa77cf146108fa578063fc0c546a1461090d575b61027733610920565b005b341561028457600080fd5b610277610af3565b341561029757600080fd5b61029f610c2c565b604051600160a060020a03909116815260200160405180910390f35b34156102c657600080fd5b6102ce610c40565b60405190815260200160405180910390f35b34156102eb57600080fd5b6102776024600480358281019290820135918135918201910135610c46565b341561031557600080fd5b610277610d46565b341561032857600080fd5b610277610d72565b341561033b57600080fd5b6102ce610ddd565b341561034e57600080fd5b6102ce610de3565b341561036157600080fd5b610277610e41565b341561037457600080fd5b6102ce610f1a565b341561038757600080fd5b6102ce610f20565b341561039a57600080fd5b6103a5600435610f41565b60405191825260208201526040908101905180910390f35b34156103c857600080fd5b6103d0610f6d565b604051808260018111156103e057fe5b60ff16815260200191505060405180910390f35b34156103ff57600080fd5b610277600435602435610f76565b341561041857600080fd5b610420610ffa565b604051901515815260200160405180910390f35b341561043f57600080fd5b6102ce61100a565b341561045257600080fd5b6102ce611023565b341561046557600080fd5b610277611029565b341561047857600080fd5b6102ce611153565b341561048b57600080fd5b610277611159565b341561049e57600080fd5b6102ce611255565b34156104b157600080fd5b6102ce611260565b34156104c457600080fd5b610277600160a060020a0360043516611266565b34156104e357600080fd5b61027760046024813581810190830135806020818102016040519081016040528093929190818152602001838360200280828437509496506112d395505050505050565b341561053257600080fd5b6102ce611365565b341561054557600080fd5b61029f60043561136b565b341561055b57600080fd5b610420611388565b341561056e57600080fd5b61027761139c565b341561058157600080fd5b6102ce61142f565b341561059457600080fd5b61029f611435565b34156105a757600080fd5b61027760ff60043516600160a060020a0360243516611444565b34156105cc57600080fd5b61042061153d565b34156105df57600080fd5b6102ce61154d565b34156105f257600080fd5b6102ce600435611553565b341561060857600080fd5b6102776115f6565b341561061b57600080fd5b6102776004803590602480359160443591606435916084359160a4359160c4359160e43591906101249061010435908101908301358060208181020160405190810160405280939291908181526020018383602002808284378201915050505050509190803590602001908201803590602001908080602002602001604051908101604052809392919081815260200183836020028082843782019150505050505091908035906020019082018035906020019080806020026020016040519081016040528093929190818152602001838360200280828437820191505050505050919080359060200190820180359060200190808060200260200160405190810160405280939291908181526020018383602002808284375094965061177695505050505050565b341561074f57600080fd5b6103a5600435611942565b341561076557600080fd5b610277600435611950565b341561077b57600080fd5b6102ce611a62565b341561078e57600080fd5b610277611a68565b34156107a157600080fd5b610420611acf565b34156107b457600080fd5b610420611af3565b34156107c757600080fd5b61029f611b03565b34156107da57600080fd5b6107e2611b12565b60405160208082528190810183818151815260200191508051906020019080838360005b8381101561081e578082015183820152602001610806565b50505050905090810190601f16801561084b5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b341561086457600080fd5b6102ce611ba3565b341561087757600080fd5b6102ce611ba9565b341561088a57600080fd5b6102ce611baf565b341561089d57600080fd5b6103a5600435611bb5565b34156108b357600080fd5b6102776004351515611ca2565b610277600160a060020a0360043516610920565b34156108df57600080fd5b610420611cdd565b34156108f257600080fd5b6102ce611d19565b341561090557600080fd5b61029f611d1f565b341561091857600080fd5b61029f611d2e565b60008060008061092e612f67565b60008080600160a060020a038916151561094757600080fd5b61094f611d3d565b151561095a57600080fd5b349750610965611255565b965061097088611bb5565b9096509450604080519081016040528681526020810186815290945051925082871061099c578661099e565b825b9150601c5482116109af57816109b3565b601c545b9150610a0268056bc75e2d631000006109f66109d685606463ffffffff611dba16565b6016546109ea908d9063ffffffff611dd416565b9063ffffffff611dd416565b9063ffffffff611dff16565b601d54909150610a18908963ffffffff611dba16565b601d55600154600160a060020a03166340c10f198a8360405160e060020a63ffffffff8516028152600160a060020a0390921660048301526024820152604401602060405180830381600087803b1515610a7157600080fd5b5af11515610a7e57600080fd5b5050506040518051905050610a9281611e16565b88600160a060020a031633600160a060020a03167f623b3804fa71d67900d064613da8f94b9617215ee90799290593e1745087ad188a8460405191825260208201526040908101905180910390a3610ae8612089565b505050505050505050565b610afd600061214f565b60045477010000000000000000000000000000000000000000000000900460ff161515610b2957600080fd5b6004805477ff000000000000000000000000000000000000000000000019169055600354600160a060020a031663f331de4c6005600a0154600160a060020a031660078062278d0060405160e060020a63ffffffff8716028152600160a060020a039094166004850152602484019290925260448301526064820152608401600060405180830381600087803b1515610bc157600080fd5b5af11515610bce57600080fd5b5050600354600160a060020a03169050633ce1314f4260405160e060020a63ffffffff84160281526004810191909152602401600060405180830381600087803b1515610c1a57600080fd5b5af11515610c2757600080fd5b505050565b6000546101009004600160a060020a031681565b60155481565b6000610c52600061214f565b6015541580610c7657506015544290610c74906276a70063ffffffff611dba16565b115b1515610c8157600080fd5b838214610c8d57600080fd5b61ffff811684901015610d3f57600154600160a060020a0316639dc29fac868661ffff8516818110610cbb57fe5b90506020020135600160a060020a031685858561ffff168181101515610cdd57fe5b9050602002013560405160e060020a63ffffffff8516028152600160a060020a0390921660048301526024820152604401600060405180830381600087803b1515610d2757600080fd5b5af11515610d3457600080fd5b505050600101610c8d565b5050505050565b610d50600061214f565b601554158015610d61575060145442115b1515610d6c57600080fd5b42601555565b610d7c600061214f565b60045460a060020a900460ff1615610d9357600080fd5b60018054600160a060020a03169063bedb86fb9060405160e060020a63ffffffff84160281529015156004820152602401600060405180830381600087803b1515610c1a57600080fd5b601f5481565b600154600090600160a060020a03166318160ddd6040518163ffffffff1660e060020a028152600401602060405180830381600087803b1515610e2557600080fd5b5af11515610e3257600080fd5b50505060405180519150505b90565b33600160a060020a0316600560020154600160a060020a03161480610ec6575060155415801590610e865750601554610e8390624f1a0063ffffffff611dba16565b42115b8015610ea25750600160005460ff166001811115610ea057fe5b145b8015610eb7575060045460a060020a900460ff165b8015610ec65750610ec6611388565b1515610ed157600080fd5b600154600160a060020a031663bedb86fb600060405160e060020a63ffffffff84160281529015156004820152602401600060405180830381600087803b1515610c1a57600080fd5b60165481565b6000610f3c610f2d61100a565b601f549063ffffffff611dba16565b905090565b6013805482908110610f4f57fe5b60009182526020909120600290910201805460019091015490915082565b60005460ff1681565b600080610f83600161214f565b6014544210158015610f955750601554155b9150610fae601a54601954611dba90919063ffffffff16565b601d54610fc290859063ffffffff611dba16565b11159050818015610fd05750805b8015610fe5575060045460a860020a900460ff165b1515610ff057600080fd5b5050601e55602055565b60045460a860020a900460ff1681565b6000610f3c601e54601d54611dba90919063ffffffff16565b601c5481565b33600160a060020a0316600560020154600160a060020a03161480611064575033600160a060020a0316600560000154600160a060020a0316145b806110745750611072611388565b155b151561107f57600080fd5b60045460a060020a900460ff161561109657600080fd5b61109e611cdd565b806110ee575033600160a060020a0316600560020154600160a060020a031614806110df575033600160a060020a0316600560000154600160a060020a0316145b80156110ee57506110ee611388565b15156110f957600080fd5b6004805474ff0000000000000000000000000000000000000000191660a060020a1790556111256121c6565b7f6823b073d48d6e3a7d385eeb601452d680e74bb46afe3255a7d778f3a9b1768160405160405180910390a1565b601d5481565b600554600160a060020a03908116906000903316821461117857600080fd5b5060005b600d8160ff1610156111ed57600960ff8216148061119d5750600660ff8216145b156111a7576111e5565b81600560ff8316600d81106111b857fe5b01805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a03929092169190911790555b60010161117c565b60018054600160a060020a03169063b3e1f52390849060405160e060020a63ffffffff8516028152600160a060020a03909216600483015215156024820152604401600060405180830381600087803b151561124857600080fd5b5af11515610d3f57600080fd5b6000610f3c42611553565b60215481565b611270600061214f565b600154600160a060020a03166375e2ff658260405160e060020a63ffffffff8416028152600160a060020a039091166004820152602401600060405180830381600087803b15156112c057600080fd5b5af115156112cd57600080fd5b50505050565b6112dd600061214f565b600154600160a060020a031663680b3bdf826040518263ffffffff1660e060020a0281526004018080602001828103825283818151815260200191508051906020019060200280838360005b83811015611341578082015183820152602001611329565b5050505090500192505050600060405180830381600087803b15156112c057600080fd5b60145481565b600581600d811061137857fe5b0154600160a060020a0316905081565b600060185461139561100a565b1015905090565b6113a6600061214f565b60045460a860020a900460ff16156113bd57600080fd5b6113c5612456565b6014544211156113d457600080fd5b6113dc612dae565b7f5daa87a0e9463431830481fd4b6e3403442dfb9a12b9c07597e9f61d50b633c860405160405180910390a16004805475ff000000000000000000000000000000000000000000191660a860020a179055565b601b5481565b600354600160a060020a031681565b600582600c81111561145257fe5b60ff16600d811061145f57fe5b015433600160a060020a0390811691161480156114885750600382600c81111561148557fe5b14155b806114e6575060056002015433600160a060020a0390811691161480156114ce575060045460a860020a900460ff1615806114ce5750600382600c8111156114cc57fe5b145b80156114e65750600982600c8111156114e357fe5b14155b15156114f157600080fd5b80600583600c81111561150057fe5b60ff16600d811061150d57fe5b01805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a03929092169190911790555050565b60045460a060020a900460ff1681565b60185481565b600080805b60135460ff821610156115ea5761159b60138260ff1681548110151561157a57fe5b90600052602060002090600202016001015483611dba90919063ffffffff16565b6014549092506115b1908363ffffffff611dba16565b8410156115e2576013805460ff83169081106115c957fe5b90600052602060002090600202016000015492506115ef565b600101611558565b600092505b5050919050565b600254600160a060020a0316151561160d57600080fd5b601554158015906116235750611621611388565b155b151561162e57600080fd5b33600160a060020a0316600560000154600160a060020a031614801561166957506014546116669063020f580063ffffffff611dba16565b42115b156116dd57600254600160a060020a031663b9caebf4600560000154600160a060020a031660405160e060020a63ffffffff8416028152600160a060020a039091166004820152602401600060405180830381600087803b15156116cc57600080fd5b5af115156116d957600080fd5b5050505b33600160a060020a0316600560020154600160a060020a0316148015611718575060145461171590630317040063ffffffff611dba16565b42115b1561177457600254600754600160a060020a039182169163b9caebf4911660405160e060020a63ffffffff8416028152600160a060020a039091166004820152602401600060405180830381600087803b1515610c1a57600080fd5b565b6000611782600061214f565b60045460a860020a900460ff161561179957600080fd5b6117a1612456565b428d9011156117af57600080fd5b60148d90558a8c11156117c157600080fd5b60188c905560198b905560008a116117d857600080fd5b60168a9055601a879055601b8690556017899055601c88905581518351146117ff57600080fd5b825161180c601282612f7e565b50600090505b825181101561189257604080519081016040528084838151811061183257fe5b90602001906020020151815260200183838151811061184d57fe5b906020019060200201519052601280548390811061186757fe5b9060005260206000209060020201600082015181556020820151600191820155919091019050611812565b84518451146118a057600080fd5b83516118ad601382612f7e565b50600090505b83518110156119335760408051908101604052808583815181106118d357fe5b9060200190602002015181526020018683815181106118ee57fe5b906020019060200201519052601380548390811061190857fe5b90600052602060002090600202016000820151815560208201516001918201559190910190506118b3565b50505050505050505050505050565b6012805482908110610f4f57fe5b60008061195d600061214f565b6015541561196a57600080fd5b601654611989906109f685670de0b6b3a764000063ffffffff611dd416565b91506119b7601a546119ab61199c61100a565b6019549063ffffffff612e6d16565b9063ffffffff611dba16565b8211159050806119c657600080fd5b6119ce612456565b601d546119e1908363ffffffff611dba16565b601d55600154600654600160a060020a03918216916340c10f1991168560405160e060020a63ffffffff8516028152600160a060020a0390921660048301526024820152604401602060405180830381600087803b1515611a4157600080fd5b5af11515611a4e57600080fd5b5050506040518051905050610c2783611e16565b601e5481565b600254600160a060020a03161515611a7f57600080fd5b600254600160a060020a031663fa89401a3360405160e060020a63ffffffff8416028152600160a060020a039091166004820152602401600060405180830381600087803b1515610c1a57600080fd5b60045477010000000000000000000000000000000000000000000000900460ff1681565b60045460b060020a900460ff1681565b600454600160a060020a031681565b611b1a612faa565b6000805460ff166001811115611b2c57fe5b14611b6a5760408051908101604052600681527f726f756e643200000000000000000000000000000000000000000000000000006020820152610f3c565b60408051908101604052600681527f726f756e643100000000000000000000000000000000000000000000000000006020820152905090565b60175481565b601a5481565b60205481565b601254600090819081901580611beb57508360126000815481101515611bd757fe5b906000526020600020906002020160000154115b15611bfc5760009250829150611c9c565b5060015b60125461ffff82161015611c47578360128261ffff16815481101515611c2257fe5b9060005260206000209060020201600001541115611c3f57611c47565b600101611c00565b6012805461ffff600019840116908110611c5d57fe5b90600052602060002090600202016000015460126001830361ffff16815481101515611c8557fe5b906000526020600020906002020160010154925092505b50915091565b611cac600061214f565b6004805491151560b060020a0276ff0000000000000000000000000000000000000000000019909216919091179055565b600080601954611ceb61100a565b1015905060006015541180611cfd5750805b8015611d12575060045460a860020a900460ff165b91505b5090565b60195481565b600254600160a060020a031681565b600154600160a060020a031681565b60008060008060145442118015611d545750601554155b9250601b543410159150611d6f601a546119ab61199c61100a565b3411159050828015611d7e5750815b8015611d875750805b8015611d9c575060045460a860020a900460ff165b8015611db2575060045460b060020a900460ff16155b935050505090565b600082820183811015611dc957fe5b8091505b5092915050565b600080831515611de75760009150611dcd565b50828202828482811515611df757fe5b0414611dc957fe5b6000808284811515611e0d57fe5b04949350505050565b601054611e3f90600160a060020a0316611e3660326109f6856004611dd4565b624f1a00612e7f565b600154600354600160a060020a03918216916340c10f199116611e6e60326109f686600763ffffffff611dd416565b60405160e060020a63ffffffff8516028152600160a060020a0390921660048301526024820152604401602060405180830381600087803b1515611eb157600080fd5b5af11515611ebe57600080fd5b50505060405180515050600a54611ef190600160a060020a0316611ee860326109f6856004611dd4565b62278d00612e7f565b600b54611f1d90600160a060020a0316611f1460326109f6600281876007611dd4565b62ed4e00612e7f565b600b54611f4a90600160a060020a0316611f4060326109f6600281876007611dd4565b6301e13380612e7f565b600954611f6a90600160a060020a0316611e3660326109f6856001611dd4565b600c54611f8d90600160a060020a0316611f1460326109f660028187600b611dd4565b600c54611fb090600160a060020a0316611f4060326109f660028187600b611dd4565b600d54611fd390600160a060020a0316611e3660326109f660028187600c611dd4565b600d54611ff690600160a060020a0316611f4060326109f660028187600c611dd4565b600154600160a060020a03166340c10f196005600c0154600160a060020a031661202c60326109f686600463ffffffff611dd416565b60405160e060020a63ffffffff8516028152600160a060020a0390921660048301526024820152604401602060405180830381600087803b151561206f57600080fd5b5af1151561207c57600080fd5b5050506040518051505050565b600254600160a060020a03161561210057600254600160a060020a031663f340fa01343360405160e060020a63ffffffff8516028152600160a060020a0390911660048201526024016000604051808303818588803b15156120ea57600080fd5b5af115156120f757600080fd5b50505050611774565b600030600160a060020a031631111561177457600560000154600160a060020a039081169030163180156108fc0290604051600060405180830381858888f19350505050151561177457600080fd5b33600160a060020a0316600560020154600160a060020a0316148061218a575033600160a060020a0316600560000154600160a060020a0316145b806121b8575060018115151480156121b8575033600160a060020a0316600560030154600160a060020a0316145b15156121c357600080fd5b50565b60155415156121d457426015555b6121dc611388565b1561240657600254600160a060020a03161561228757600254600554600e54601d54600160a060020a039384169363f5bf7413938116921690612227906064906109f6906007611dd4565b60405160e060020a63ffffffff8616028152600160a060020a0393841660048201529190921660248201526044810191909152606401600060405180830381600087803b151561227657600080fd5b5af1151561228357600080fd5b5050505b6000602054111561230f57600154600654602054600160a060020a03928316926340c10f1992169060405160e060020a63ffffffff8516028152600160a060020a0390921660048301526024820152604401602060405180830381600087803b15156122f257600080fd5b5af115156122ff57600080fd5b5050506040518051505060006020555b6000805460ff16600181111561232157fe5b141561236d576004805475ffff0000000000000000000000000000000000000000191690556000805460ff1916600117905561235b61100a565b601f556000601d819055601e55612401565b6004805477ff0000000000000000000000000000000000000000000000191677010000000000000000000000000000000000000000000000179055600154600160a060020a03166318160ddd6040518163ffffffff1660e060020a028152600401602060405180830381600087803b15156123e757600080fd5b5af115156123f457600080fd5b5050506040518051602155505b611774565b600254600160a060020a03161561177457600254600160a060020a0316638c52dc416040518163ffffffff1660e060020a028152600401600060405180830381600087803b1515610c1a57600080fd5b60005460b060020a900460ff161561246d57611774565b6000805476ff00000000000000000000000000000000000000000000191660b060020a1790819055600160a060020a0361010090910416639cbf9e366040518163ffffffff1660e060020a028152600401602060405180830381600087803b15156124d757600080fd5b5af115156124e457600080fd5b50505060405180516001805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392831617908190556000546101009004821692506332061829911660405160e060020a63ffffffff8416028152600160a060020a039091166004820152602401602060405180830381600087803b151561256857600080fd5b5af1151561257557600080fd5b50505060405180516003805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a039283161790556000546001546101009091048216925063e4eb2173911660405160e060020a63ffffffff8416028152600160a060020a039091166004820152602401602060405180830381600087803b15156125fb57600080fd5b5af1151561260857600080fd5b50505060405180516004805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a03929092169190911790555060005460a860020a900460ff16156126d8576000546101009004600160a060020a0316633b8b4a616040518163ffffffff1660e060020a028152600401602060405180830381600087803b151561269457600080fd5b5af115156126a157600080fd5b50505060405180516002805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055505b60018054600160a060020a03169063b3e1f523906005900154600160a060020a0316600160405160e060020a63ffffffff8516028152600160a060020a03909216600483015215156024820152604401600060405180830381600087803b151561274157600080fd5b5af1151561274e57600080fd5b5050600154600160a060020a0316905063b3e1f523600560020154600160a060020a0316600160405160e060020a63ffffffff8516028152600160a060020a03909216600483015215156024820152604401600060405180830381600087803b15156127b957600080fd5b5af115156127c657600080fd5b5050600154600160a060020a0316905063b3e1f523600560040154600160a060020a0316600160405160e060020a63ffffffff8516028152600160a060020a03909216600483015215156024820152604401600060405180830381600087803b151561283157600080fd5b5af1151561283e57600080fd5b5050600154600160a060020a0316905063b3e1f5236005800154600160a060020a0316600160405160e060020a63ffffffff8516028152600160a060020a03909216600483015215156024820152604401600060405180830381600087803b15156128a857600080fd5b5af115156128b557600080fd5b5050600154600160a060020a0316905063b3e1f523600560030154600160a060020a0316600160405160e060020a63ffffffff8516028152600160a060020a03909216600483015215156024820152604401600060405180830381600087803b151561292057600080fd5b5af1151561292d57600080fd5b5050600154600160a060020a0316905063b3e1f5236005600a0154600160a060020a0316600160405160e060020a63ffffffff8516028152600160a060020a03909216600483015215156024820152604401600060405180830381600087803b151561299857600080fd5b5af115156129a557600080fd5b5050600154600160a060020a0316905063b3e1f5236005600b0154600160a060020a0316600160405160e060020a63ffffffff8516028152600160a060020a03909216600483015215156024820152604401600060405180830381600087803b1515612a1057600080fd5b5af11515612a1d57600080fd5b5050600154600160a060020a0316905063b3e1f523600560080154600160a060020a0316600160405160e060020a63ffffffff8516028152600160a060020a03909216600483015215156024820152604401600060405180830381600087803b1515612a8857600080fd5b5af11515612a9557600080fd5b5050600154600160a060020a0316905063b3e1f523600560070154600160a060020a0316600160405160e060020a63ffffffff8516028152600160a060020a03909216600483015215156024820152604401600060405180830381600087803b1515612b0057600080fd5b5af11515612b0d57600080fd5b5050600154600160a060020a0316905063b3e1f5236005600c0154600160a060020a0316600160405160e060020a63ffffffff8516028152600160a060020a03909216600483015215156024820152604401600060405180830381600087803b1515612b7857600080fd5b5af11515612b8557600080fd5b505060018054600354600160a060020a03918216935063b3e1f5239291169060405160e060020a63ffffffff8516028152600160a060020a03909216600483015215156024820152604401600060405180830381600087803b1515612be957600080fd5b5af11515612bf657600080fd5b505060018054600454600160a060020a03918216935063b3e1f5239291169060405160e060020a63ffffffff8516028152600160a060020a03909216600483015215156024820152604401600060405180830381600087803b1515612c5a57600080fd5b5af11515612c6757600080fd5b50505060128054806001018281612c7e9190612f7e565b91600052602060002090600202016000604080519081016040526803d952abd36cbc00008152601e6020820152919050815181556020820151816001015550505060138054806001018281612cd39190612f7e565b9160005260206000209060020201600060408051908101604052600f81526202a3006020820152919050815181556020820151816001015550505060138054806001018281612d229190612f7e565b9160005260206000209060020201600060408051908101604052600a81526202a3006020820152919050815181556020820151816001015550505060138054806001018281612d719190612f7e565b9160005260206000209060020201600060408051908101604052600581526205460060208201529190508151815560208201518160010155505050565b600254600160a060020a031615801590612e2957506000600254600160a060020a031663c19d93fb6040518163ffffffff1660e060020a028152600401602060405180830381600087803b1515612e0457600080fd5b5af11515612e1157600080fd5b505050604051805190506002811115612e2657fe5b14155b1561177457600254600160a060020a0316631ef3755d6040518163ffffffff1660e060020a028152600401600060405180830381600087803b1515610c1a57600080fd5b600082821115612e7957fe5b50900390565b600154600454600160a060020a03918216916340c10f1991168460405160e060020a63ffffffff8516028152600160a060020a0390921660048301526024820152604401602060405180830381600087803b1515612edc57600080fd5b5af11515612ee957600080fd5b50505060405180515050600454600160a060020a031663ae7d0cac84848460405160e060020a63ffffffff8616028152600160a060020a03909316600484015260248301919091526044820152606401600060405180830381600087803b1515612f5257600080fd5b5af11515612f5f57600080fd5b505050505050565b604080519081016040526000808252602082015290565b815481835581811511610c2757600202816002028360005260206000209182019101610c279190612fbc565b60206040519081016040526000815290565b610e3e91905b80821115611d155760008082556001820155600201612fc25600a165627a7a72305820b7c0b8f3ef8ab3354912f555345ff1da668253687667f402cf52ff980588eee300290000000000000000000000001702d78c30cd099f4573e09336dd48d804cceac7",
  "constructorArguments": "0000000000000000000000001702d78c30cd099f4573e09336dd48d804cceac7"
}