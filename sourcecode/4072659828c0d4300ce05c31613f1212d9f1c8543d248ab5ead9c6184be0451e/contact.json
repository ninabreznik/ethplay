{
  "address": "0x56d06701fd44a4a857cb96b266f505a2832950c5",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "Home",
  "compilerVersion": "v0.4.24+commit.e67f0147",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2018-10-08\n*/\n\npragma solidity ^0.4.24;\n\n\n\ncontract Base\n{\n    uint8 constant HEROLEVEL_MIN = 1;\n    uint8 constant HEROLEVEL_MAX = 5;\n\n    uint8 constant LIMITCHIP_MINLEVEL = 3;\n    uint constant PARTWEIGHT_NORMAL = 100;\n    uint constant PARTWEIGHT_LIMIT = 40;\n\n    address creator;\n\n    constructor() public\n    {\n        creator = msg.sender;\n    }\n\n    modifier CreatorAble()\n    {\n        require(msg.sender == creator);\n        _;\n    }\n\n    function IsLimitPart(uint8 level, uint part) internal pure returns(bool)\n    {\n        if (level < LIMITCHIP_MINLEVEL) return false;\n        if (part < GetPartNum(level)) return false;\n        return true;\n    }\n\n    function GetPartWeight(uint8 level, uint part) internal pure returns(uint)\n    {\n        if (IsLimitPart(level, part)) return PARTWEIGHT_LIMIT;\n        return PARTWEIGHT_NORMAL;\n    }\n    \n    function GetPartNum(uint8 level) internal pure returns(uint)\n    {\n        if (level <= 2) return 3;\n        else if (level <= 4) return 4;\n        return 5;\n    }\n\n    function GetPartLimit(uint8 level, uint part) internal pure returns(uint8)\n    {\n        if (!IsLimitPart(level, part)) return 0;\n        if (level == 5) return 1;\n        if (level == 4) return 8;\n        return 15;\n    }\n\n}\n\n\n\n\ncontract BasicAuth is Base\n{\n\n    mapping(address => bool) auth_list;\n\n    modifier OwnerAble(address acc)\n    {\n        require(acc == tx.origin);\n        _;\n    }\n\n    modifier AuthAble()\n    {\n        require(auth_list[msg.sender]);\n        _;\n    }\n\n    modifier ValidHandleAuth()\n    {\n        require(tx.origin==creator || msg.sender==creator);\n        _;\n    }\n   \n    function SetAuth(address target) external ValidHandleAuth\n    {\n        auth_list[target] = true;\n    }\n\n    function ClearAuth(address target) external ValidHandleAuth\n    {\n        delete auth_list[target];\n    }\n\n}\n\n\n\n\nlibrary IndexList\n{\n    function insert(uint32[] storage self, uint32 index, uint pos) external\n    {\n        require(self.length >= pos);\n        self.length++;\n        for (uint i=self.length; i>pos; i++)\n        {\n            self[i+1] = self[i];\n        }\n        self[pos] = index;\n    }\n\n    function remove(uint32[] storage self, uint32 index) external returns(bool)\n    {\n        return remove(self,index,0);\n    }\n\n    function remove(uint32[] storage self, uint32 index, uint startPos) public returns(bool)\n    {\n        for (uint i=startPos; i<self.length; i++)\n        {\n            if (self[i] != index) continue;\n            for (uint j=i; j<self.length-1; j++)\n            {\n                self[j] = self[j+1];\n            }\n            delete self[self.length-1];\n            self.length--;\n            return true;\n        }\n        return false;\n    }\n\n}\n\n\n\n\ncontract MainCard is BasicAuth\n{\n    struct Card {\n        uint32 m_Index;\n        uint32 m_Duration;\n        uint8 m_Level;\n        uint16 m_DP;  //DynamicProfit\n        uint16 m_DPK; //K is coefficient\n        uint16 m_SP;  //StaticProfit\n        uint16 m_IP;  //ImmediateProfit\n        uint32[] m_Parts;\n    }\n\n    struct CardLib {\n        uint32[] m_List;\n        mapping(uint32 => Card) m_Lib;\n    }\n\n    CardLib g_CardLib;\n\n    function AddNewCard(uint32 iCard, uint32 duration, uint8 level, uint16 dp, uint16 dpk, uint16 sp, uint16 ip, uint32[] parts) internal\n    {\n        g_CardLib.m_List.push(iCard);\n        g_CardLib.m_Lib[iCard] = Card({\n            m_Index   : iCard,\n            m_Duration: duration,\n            m_Level   : level,\n            m_DP      : dp,\n            m_DPK     : dpk,\n            m_SP      : sp,\n            m_IP      : ip,\n            m_Parts   : parts\n        });\n    }\n\n    function CardExists(uint32 iCard) public view returns(bool)\n    {\n        Card storage obj = g_CardLib.m_Lib[iCard];\n        return obj.m_Index == iCard;\n    }\n\n    function GetCard(uint32 iCard) internal view returns(Card storage)\n    {\n        return g_CardLib.m_Lib[iCard];\n    }\n\n    function GetCardInfo(uint32 iCard) external view returns(uint32, uint32, uint8, uint16, uint16, uint16, uint16, uint32[])\n    {\n        Card storage obj = GetCard(iCard);\n        return (obj.m_Index, obj.m_Duration, obj.m_Level, obj.m_DP, obj.m_DPK, obj.m_SP, obj.m_IP, obj.m_Parts);\n    }\n\n    function GetExistsCardList() external view returns(uint32[])\n    {\n        return g_CardLib.m_List;\n    }\n\n}\n\n\n\n\ncontract MainChip is BasicAuth\n{\n    using IndexList for uint32[];\n\n    struct Chip\n    {\n        uint8 m_Level;\n        uint8 m_LimitNum;\n        uint8 m_Part;\n        uint32 m_Index;\n        uint256 m_UsedNum;\n    }\n\n    struct PartManager\n    {\n        uint32[] m_IndexList;   //index list, player can obtain\n        uint32[] m_UnableList;  //player can't obtain\n    }\n\n    struct ChipLib\n    {\n        uint32[] m_List;\n        mapping(uint32 => Chip) m_Lib;\n        mapping(uint32 => uint[]) m_TempList;\n        mapping(uint8 => mapping(uint => PartManager)) m_PartMap;//level -> level list\n    }\n\n    ChipLib g_ChipLib;\n\n    function AddNewChip(uint32 iChip, uint8 lv, uint8 limit, uint8 part) internal\n    {\n        require(!ChipExists(iChip));\n        g_ChipLib.m_List.push(iChip);\n        g_ChipLib.m_Lib[iChip] = Chip({\n            m_Index       : iChip,\n            m_Level       : lv,\n            m_LimitNum    : limit,\n            m_Part        : part,\n            m_UsedNum     : 0\n        });\n        PartManager storage pm = GetPartManager(lv,part);\n        pm.m_IndexList.push(iChip);\n    }\n\n    function GetChip(uint32 iChip) internal view returns(Chip storage)\n    {\n        return g_ChipLib.m_Lib[iChip];\n    }\n\n    function GetPartManager(uint8 level, uint iPart) internal view returns(PartManager storage)\n    {\n        return g_ChipLib.m_PartMap[level][iPart];\n    }\n\n    function ChipExists(uint32 iChip) public view returns(bool)\n    {\n        Chip storage obj = GetChip(iChip);\n        return obj.m_Index == iChip;\n    }\n\n    function GetChipUsedNum(uint32 iChip) internal view returns(uint)\n    {\n        Chip storage obj = GetChip(iChip);\n        uint[] memory tempList = g_ChipLib.m_TempList[iChip];\n        uint num = tempList.length;\n        for (uint i=num; i>0; i--)\n        {\n            if(tempList[i-1]<=now) {\n                num -= i;\n                break;\n            }\n        }\n        return obj.m_UsedNum + num;\n    }\n\n    function CanObtainChip(uint32 iChip) internal view returns(bool)\n    {\n        Chip storage obj = GetChip(iChip);\n        if (obj.m_LimitNum == 0) return true;\n        if (GetChipUsedNum(iChip) < obj.m_LimitNum) return true;\n        return false;\n    }\n\n    function CostChip(uint32 iChip) internal\n    {\n        BeforeChipCost(iChip);\n        Chip storage obj = GetChip(iChip);\n        obj.m_UsedNum--;\n    }\n\n    function ObtainChip(uint32 iChip) internal\n    {\n        BeforeChipObtain(iChip);\n        Chip storage obj = GetChip(iChip);\n        obj.m_UsedNum++;\n    }\n\n    function BeforeChipObtain(uint32 iChip) internal\n    {\n        Chip storage obj = GetChip(iChip);\n        if (obj.m_LimitNum == 0) return;\n        uint usedNum = GetChipUsedNum(iChip);\n        require(obj.m_LimitNum >= usedNum+1);\n        if (obj.m_LimitNum == usedNum+1) {\n            PartManager storage pm = GetPartManager(obj.m_Level,obj.m_Part);\n            if (pm.m_IndexList.remove(iChip)){\n                pm.m_UnableList.push(iChip);\n            }\n        }\n    }\n\n    function BeforeChipCost(uint32 iChip) internal\n    {\n        Chip storage obj = GetChip(iChip);\n        if (obj.m_LimitNum == 0) return;\n        uint usedNum = GetChipUsedNum(iChip);\n        require(obj.m_LimitNum >= usedNum);\n        if (obj.m_LimitNum == usedNum) {\n            PartManager storage pm = GetPartManager(obj.m_Level,obj.m_Part);\n            if (pm.m_UnableList.remove(iChip)) {\n                pm.m_IndexList.push(iChip);\n            }\n        }\n    }\n\n    function AddChipTempTime(uint32 iChip, uint expireTime) internal\n    {\n        uint[] storage list = g_ChipLib.m_TempList[iChip];\n        require(list.length==0 || expireTime>=list[list.length-1]);\n        BeforeChipObtain(iChip);\n        list.push(expireTime);\n    }\n\n    function RefreshChipUnableList(uint8 level) internal\n    {\n        uint partNum = GetPartNum(level);\n        for (uint iPart=1; iPart<=partNum; iPart++)\n        {\n            PartManager storage pm = GetPartManager(level,iPart);\n            for (uint i=pm.m_UnableList.length; i>0; i--)\n            {\n                uint32 iChip = pm.m_UnableList[i-1];\n                if (CanObtainChip(iChip)) {\n                    pm.m_IndexList.push(iChip);\n                    pm.m_UnableList.remove(iChip,i-1);\n                }\n            }\n        }\n    }\n\n    function GenChipByWeight(uint random, uint8 level, uint[] extWeight) internal view returns(uint32)\n    {\n        uint partNum = GetPartNum(level);\n        uint allWeight;\n        uint[] memory newWeight = new uint[](partNum+1);\n        uint[] memory realWeight = new uint[](partNum+1);\n        for (uint iPart=1; iPart<=partNum; iPart++)\n        {\n            PartManager storage pm = GetPartManager(level,iPart);\n            uint curWeight = extWeight[iPart-1]+GetPartWeight(level,iPart);\n            allWeight += pm.m_IndexList.length*curWeight;\n            newWeight[iPart] = allWeight;\n            realWeight[iPart] = curWeight;\n        }\n\n        uint weight = random % allWeight;\n        for (iPart=1; iPart<=partNum; iPart++)\n        {\n            if (weight >= newWeight[iPart]) continue;\n            pm = GetPartManager(level,iPart);\n            uint idx = (weight-newWeight[iPart-1])/realWeight[iPart];\n            return pm.m_IndexList[idx];\n        }\n    }\n\n    function GetChipInfo(uint32 iChip) external view returns(uint32, uint8, uint8, uint, uint8, uint)\n    {\n        Chip storage obj = GetChip(iChip);\n        return (obj.m_Index, obj.m_Level, obj.m_LimitNum, GetPartWeight(obj.m_Level,obj.m_Part), obj.m_Part, GetChipUsedNum(iChip));\n    }\n\n    function GetExistsChipList() external view returns(uint32[])\n    {\n        return g_ChipLib.m_List;\n    }\n\n}\n\n\n\n\ncontract BasicTime\n{\n    uint constant DAY_SECONDS = 60 * 60 * 24;\n\n    function GetDayCount(uint timestamp) pure internal returns(uint)\n    {\n        return timestamp/DAY_SECONDS;\n    }\n\n    function GetExpireTime(uint timestamp, uint dayCnt) pure internal returns(uint)\n    {\n        uint dayEnd = GetDayCount(timestamp) + dayCnt;\n        return dayEnd * DAY_SECONDS;\n    }\n\n}\n\n\n\n\nlibrary ItemList {\n\n    struct Data {\n        uint32[] m_List;\n        mapping(uint32 => uint) m_Maps;\n    }\n\n    function set(Data storage self, uint32 key, uint num) public\n    {\n        if (!has(self,key)) {\n            if (num == 0) return;\n            self.m_List.push(key);\n            self.m_Maps[key] = num;\n        }\n        else if (num == 0) {\n            delete self.m_Maps[key];\n        } \n        else {\n            uint old = self.m_Maps[key];\n            if (old == num) return;\n            self.m_Maps[key] = num;\n        }\n    }\n\n    function add(Data storage self, uint32 key, uint num) external\n    {\n        uint iOld = get(self,key);\n        uint iNow = iOld+num;\n        require(iNow >= iOld);\n        set(self,key,iNow);\n    }\n\n    function sub(Data storage self, uint32 key, uint num) external\n    {\n        uint iOld = get(self,key);\n        require(iOld >= num);\n        set(self,key,iOld-num);\n    }\n\n    function has(Data storage self, uint32 key) public view returns(bool)\n    {\n        return self.m_Maps[key] > 0;\n    }\n\n    function get(Data storage self, uint32 key) public view returns(uint)\n    {\n        return self.m_Maps[key];\n    }\n\n    function list(Data storage self) view external returns(uint32[],uint[])\n    {\n        uint len = self.m_List.length;\n        uint[] memory values = new uint[](len);\n        for (uint i=0; i<len; i++)\n        {\n            uint32 key = self.m_List[i];\n            values[i] = self.m_Maps[key];\n        }\n        return (self.m_List,values);\n    }\n\n    function isEmpty(Data storage self) view external returns(bool)\n    {\n        return self.m_List.length == 0;\n    }\n\n    function keys(Data storage self) view external returns(uint32[])\n    {\n        return self.m_List;\n    }\n\n}\n\n\n\n\ncontract MainBonus is BasicTime,BasicAuth,MainCard\n{\n    uint constant BASERATIO = 10000;\n\n    struct PlayerBonus\n    {\n        uint m_Bonus;       // bonus by immediateprofit\n        uint m_DrawedDay;\n        uint16 m_DDPermanent;// drawed day permanent\n        mapping(uint => uint16) m_DayStatic;\n        mapping(uint => uint16) m_DayPermanent;\n        mapping(uint => uint32[]) m_DayDynamic;\n    }\n\n    struct DayRatio\n    {\n        uint16 m_Static;\n        uint16 m_Permanent;\n        uint32[] m_DynamicCard;\n        mapping(uint32 => uint) m_CardNum;\n    }\n\n    struct BonusData\n    {\n        uint m_RewardBonus;//bonus pool,waiting for withdraw\n        uint m_RecordDay;// recordday\n        uint m_RecordBonus;//recordday bonus , to show\n        uint m_RecordPR;// recordday permanent ratio\n        mapping(uint => DayRatio) m_DayRatio;\n        mapping(uint => uint) m_DayBonus;// day final bonus\n        mapping(address => PlayerBonus) m_PlayerBonus;\n    }\n\n    address receiver;\n    BonusData g_Bonus;\n\n    constructor(address Receiver) public\n    {\n        g_Bonus.m_RecordDay = GetDayCount(now);\n        receiver = Receiver;\n    }\n\n    function() external payable {}\n\n    function NeedRefresh(uint dayNo) internal view returns(bool)\n    {\n        if (g_Bonus.m_RecordBonus == 0) return false;\n        if (g_Bonus.m_RecordDay == dayNo) return false;\n        return true;\n    }\n\n    function PlayerNeedRefresh(address acc, uint dayNo) internal view returns(bool)\n    {\n        if (g_Bonus.m_RecordBonus == 0) return false;\n        PlayerBonus storage pb = g_Bonus.m_PlayerBonus[acc];\n        if (pb.m_DrawedDay == dayNo) return false;\n        return true;\n    }\n\n    function GetDynamicRatio(uint dayNo) internal view returns(uint tempRatio)\n    {\n        DayRatio storage dr = g_Bonus.m_DayRatio[dayNo];\n        for (uint i=0; i<dr.m_DynamicCard.length; i++)\n        {\n            uint32 iCard = dr.m_DynamicCard[i];\n            uint num = dr.m_CardNum[iCard];\n            Card storage oCard = GetCard(iCard);\n            tempRatio += num*oCard.m_DP*oCard.m_DPK/(oCard.m_DPK+num);\n        }\n    }\n\n    function GenDayRatio(uint dayNo) internal view returns(uint iDR)\n    {\n        DayRatio storage dr = g_Bonus.m_DayRatio[dayNo];\n        iDR += dr.m_Permanent;\n        iDR += dr.m_Static;\n        iDR += GetDynamicRatio(dayNo);\n    }\n\n    function GetDynamicCardNum(uint32 iCard, uint dayNo) internal view returns(uint num)\n    {\n        DayRatio storage dr = g_Bonus.m_DayRatio[dayNo];\n        num = dr.m_CardNum[iCard];\n    }\n\n    function GetPlayerDynamicRatio(address acc, uint dayNo) internal view returns(uint tempRatio)\n    {\n        PlayerBonus storage pb = g_Bonus.m_PlayerBonus[acc];\n        DayRatio storage dr = g_Bonus.m_DayRatio[dayNo];\n        uint32[] storage cards = pb.m_DayDynamic[dayNo];\n        for (uint idx=0; idx<cards.length; idx++)\n        {\n            uint32 iCard = cards[idx];\n            uint num = dr.m_CardNum[iCard];\n            Card storage oCard = GetCard(iCard);\n            tempRatio += oCard.m_DP*oCard.m_DPK/(oCard.m_DPK+num);\n        }\n    }\n\n    function GenPlayerRatio(address acc, uint dayNo) internal view returns(uint tempRatio)\n    {\n        PlayerBonus storage pb = g_Bonus.m_PlayerBonus[acc];\n        tempRatio += pb.m_DayPermanent[dayNo];\n        tempRatio += pb.m_DayStatic[dayNo];\n        tempRatio += GetPlayerDynamicRatio(acc,dayNo);\n    }\n\n    function RefreshDayBonus() internal\n    {\n        uint todayNo = GetDayCount(now);\n        if (!NeedRefresh(todayNo)) return;\n\n        uint tempBonus = g_Bonus.m_RecordBonus;\n        uint tempPR = g_Bonus.m_RecordPR;\n        uint tempRatio;\n        for (uint dayNo=g_Bonus.m_RecordDay; dayNo<todayNo; dayNo++)\n        {\n            tempRatio = tempPR+GenDayRatio(dayNo);\n            if (tempRatio == 0) continue;\n            DayRatio storage dr = g_Bonus.m_DayRatio[dayNo];\n            tempPR += dr.m_Permanent;\n            g_Bonus.m_DayBonus[dayNo] = tempBonus;\n            tempBonus -= tempBonus*tempRatio/BASERATIO;\n        }\n\n        g_Bonus.m_RecordPR = tempPR;\n        g_Bonus.m_RecordDay = todayNo;\n        g_Bonus.m_RecordBonus = tempBonus;\n    }\n\n    function QueryPlayerBonus(address acc, uint todayNo) view internal returns(uint accBonus,uint16 accPR)\n    {\n        PlayerBonus storage pb = g_Bonus.m_PlayerBonus[acc];\n        accPR = pb.m_DDPermanent;\n        accBonus = pb.m_Bonus;\n\n        if (!PlayerNeedRefresh(acc, todayNo)) return;\n\n        uint tempBonus = g_Bonus.m_RecordBonus;\n        uint tempPR = g_Bonus.m_RecordPR;\n        uint dayNo = pb.m_DrawedDay;\n        if (dayNo == 0) return;\n        for (; dayNo<todayNo; dayNo++)\n        {\n            uint tempRatio = tempPR+GenDayRatio(dayNo);\n            if (tempRatio == 0) continue;\n\n            uint accRatio = accPR+GenPlayerRatio(acc,dayNo);\n            accPR += pb.m_DayPermanent[dayNo];\n\n            DayRatio storage dr = g_Bonus.m_DayRatio[dayNo];\n            if (dayNo >= g_Bonus.m_RecordDay) {\n                tempPR += dr.m_Permanent;\n                accBonus += tempBonus*accRatio/BASERATIO;\n                tempBonus -= tempBonus*tempRatio/BASERATIO;\n            }\n            else {\n                if (accRatio == 0) continue;\n                accBonus += g_Bonus.m_DayBonus[dayNo]*accRatio/BASERATIO;\n            }\n        }\n    }\n\n    function GetDynamicCardAmount(uint32 iCard, uint timestamp) external view returns(uint num)\n    {\n        num = GetDynamicCardNum(iCard, GetDayCount(timestamp));\n    }\n\n    function AddDynamicProfit(address acc, uint32 iCard, uint duration) internal\n    {\n        RefreshDayBonus();\n        uint todayNo = GetDayCount(now);\n        PlayerBonus storage pb = g_Bonus.m_PlayerBonus[acc];\n        if (pb.m_DrawedDay == 0) pb.m_DrawedDay = todayNo;\n        for (uint dayNo=todayNo; dayNo<todayNo+duration; dayNo++)\n        {\n            pb.m_DayDynamic[dayNo].push(iCard);\n            DayRatio storage dr= g_Bonus.m_DayRatio[dayNo];\n            if (dr.m_CardNum[iCard] == 0) {\n                dr.m_DynamicCard.push(iCard);\n            }\n            dr.m_CardNum[iCard]++;\n        }\n    }\n\n    function AddStaticProfit(address acc,uint16 ratio,uint duration) internal\n    {\n        RefreshDayBonus();\n        uint todayNo = GetDayCount(now);\n        PlayerBonus storage pb = g_Bonus.m_PlayerBonus[acc];\n        if (pb.m_DrawedDay == 0) pb.m_DrawedDay = todayNo;\n        if (duration == 0) {\n            pb.m_DayPermanent[todayNo] += ratio;\n            g_Bonus.m_DayRatio[todayNo].m_Permanent += ratio;\n        }\n        else {\n            for (uint dayNo=todayNo; dayNo<todayNo+duration; dayNo++)\n            {\n                pb.m_DayStatic[dayNo] += ratio;\n                g_Bonus.m_DayRatio[dayNo].m_Static += ratio;\n            }\n        }\n    }\n\n    function ImmediateProfit(address acc, uint ratio) internal\n    {\n        RefreshDayBonus();\n        if (g_Bonus.m_RecordBonus == 0) return;\n        uint bonus = ratio*g_Bonus.m_RecordBonus/BASERATIO;\n        g_Bonus.m_RecordBonus -= bonus;\n        g_Bonus.m_RewardBonus -= bonus;\n        g_Bonus.m_PlayerBonus[acc].m_Bonus += bonus;\n    }\n\n    function ProfitByCard(address acc, uint32 iCard) internal\n    {\n        Card storage oCard = GetCard(iCard);\n        if (oCard.m_IP > 0) {\n            ImmediateProfit(acc,oCard.m_IP);\n        }\n        else if (oCard.m_SP > 0) {\n            AddStaticProfit(acc,oCard.m_SP,oCard.m_Duration);\n        }\n        else {\n            AddDynamicProfit(acc,iCard,oCard.m_Duration);\n        }\n    }\n\n    function QueryBonus() external view returns(uint)\n    {\n        uint todayNo = GetDayCount(now);\n        if (!NeedRefresh(todayNo)) return g_Bonus.m_RecordBonus;\n\n        uint tempBonus = g_Bonus.m_RecordBonus;\n        uint tempPR = g_Bonus.m_RecordPR;\n        uint tempRatio;\n        for (uint dayNo=g_Bonus.m_RecordDay; dayNo<todayNo; dayNo++)\n        {\n            tempRatio = tempPR+GenDayRatio(dayNo);\n            if (tempRatio == 0) continue;\n            DayRatio storage dr = g_Bonus.m_DayRatio[dayNo];\n            tempPR += dr.m_Permanent;\n            tempBonus -= tempBonus*tempRatio/BASERATIO;\n        }\n        return tempBonus;\n    }\n\n    function QueryMyBonus(address acc) external view returns(uint bonus)\n    {\n        (bonus,) = QueryPlayerBonus(acc, GetDayCount(now));\n    }\n\n    function AddBonus(uint bonus) external AuthAble\n    {\n        RefreshDayBonus();\n        g_Bonus.m_RewardBonus += bonus;\n        g_Bonus.m_RecordBonus += bonus;\n    }\n\n    function Withdraw(address acc) external OwnerAble(acc)\n    {\n        RefreshDayBonus();\n        PlayerBonus storage pb = g_Bonus.m_PlayerBonus[acc];\n        uint bonus;\n        uint todayNo = GetDayCount(now);\n        (bonus, pb.m_DDPermanent) = QueryPlayerBonus(acc, todayNo);\n        require(bonus > 0);\n        pb.m_Bonus = 0;\n        pb.m_DrawedDay = todayNo;\n        g_Bonus.m_RewardBonus -= bonus;\n        acc.transfer(bonus);\n    }\n\n    function MasterWithdraw() external\n    {\n        uint bonus = address(this).balance-g_Bonus.m_RewardBonus;\n        require(bonus > 0);\n        receiver.transfer(bonus);\n    }\n\n\n}\n\n\n\n\ncontract MainBag is BasicTime,BasicAuth,MainChip,MainCard\n{\n    using ItemList for ItemList.Data;\n\n    struct Bag\n    {\n        ItemList.Data m_Stuff;\n        ItemList.Data m_TempStuff;\n        ItemList.Data m_Chips;\n        ItemList.Data m_TempCards; // temporary cards\n        ItemList.Data m_PermCards; // permanent cards\n    }\n\n    mapping(address => Bag) g_BagList;\n\n    function GainStuff(address acc, uint32 iStuff, uint iNum) external AuthAble OwnerAble(acc)\n    {\n        Bag storage obj = g_BagList[acc];\n        obj.m_Stuff.add(iStuff,iNum);\n    }\n\n    function CostStuff(address acc, uint32 iStuff, uint iNum) external AuthAble OwnerAble(acc)\n    {\n        Bag storage obj = g_BagList[acc];\n        obj.m_Stuff.sub(iStuff,iNum);\n    }\n\n    function GetStuffNum(address acc, uint32 iStuff) view external returns(uint)\n    {\n        Bag storage obj = g_BagList[acc];\n        return obj.m_Stuff.get(iStuff);\n    }\n\n    function GetStuffList(address acc) external view returns(uint32[],uint[])\n    {\n        Bag storage obj = g_BagList[acc];\n        return obj.m_Stuff.list();\n    }\n\n    function GainTempStuff(address acc, uint32 iStuff, uint dayCnt) external AuthAble OwnerAble(acc)\n    {\n        Bag storage obj = g_BagList[acc];\n        require(obj.m_TempStuff.get(iStuff) <= now);\n        obj.m_TempStuff.set(iStuff,now+dayCnt*DAY_SECONDS);\n    }\n\n    function GetTempStuffExpire(address acc, uint32 iStuff) external view returns(uint expire)\n    {\n        Bag storage obj = g_BagList[acc];\n        expire = obj.m_TempStuff.get(iStuff);\n    }\n\n    function GetTempStuffList(address acc) external view returns(uint32[],uint[])\n    {\n        Bag storage obj = g_BagList[acc];\n        return obj.m_TempStuff.list();\n    }\n\n    function GainChip(address acc, uint32 iChip,bool bGenerated) external AuthAble OwnerAble(acc)\n    {\n        if (!bGenerated) {\n            require(CanObtainChip(iChip));\n            ObtainChip(iChip);\n        }\n        Bag storage obj = g_BagList[acc];\n        obj.m_Chips.add(iChip,1);\n    }\n\n    function CostChip(address acc, uint32 iChip) external AuthAble OwnerAble(acc)\n    {\n        Bag storage obj = g_BagList[acc];\n        obj.m_Chips.sub(iChip,1);\n        CostChip(iChip);\n    }\n\n    function GetChipNum(address acc, uint32 iChip) external view returns(uint)\n    {\n        Bag storage obj = g_BagList[acc];\n        return obj.m_Chips.get(iChip);\n    }\n\n    function GetChipList(address acc) external view returns(uint32[],uint[])\n    {\n        Bag storage obj = g_BagList[acc];\n        return obj.m_Chips.list();\n    }\n\n    function GainCard2(address acc, uint32 iCard) internal\n    {\n        Card storage oCard = GetCard(iCard);\n        if (oCard.m_IP > 0) return;\n        uint i;\n        uint32 iChip;\n        Bag storage obj = g_BagList[acc];\n        if (oCard.m_Duration > 0) {\n            // temporary\n            uint expireTime = GetExpireTime(now,oCard.m_Duration);\n            for (i=0; i<oCard.m_Parts.length; i++)\n            {\n                iChip = oCard.m_Parts[i];\n                AddChipTempTime(iChip,expireTime);\n            }\n            obj.m_TempCards.set(iCard,expireTime);\n        }\n        else {\n            // permanent\n            for (i=0; i<oCard.m_Parts.length; i++)\n            {\n                iChip = oCard.m_Parts[i];\n                ObtainChip(iChip);\n            }\n            obj.m_PermCards.set(iCard,1);\n        }\n    }\n\n    function HasCard(address acc, uint32 iCard) public view returns(bool)\n    {\n        Bag storage obj = g_BagList[acc];\n        if (obj.m_TempCards.get(iCard) > now) return true;\n        if (obj.m_PermCards.has(iCard)) return true;\n        return false;\n    }\n\n    function GetCardList(address acc) external view returns(uint32[] tempCards, uint[] cardsTime, uint32[] permCards)\n    {\n        Bag storage obj = g_BagList[acc];\n        (tempCards,cardsTime) = obj.m_TempCards.list();\n        permCards = obj.m_PermCards.keys();\n    }\n\n\n}\n\n\n\n\ncontract OldMain\n{\n    function GetStuffList(address) external view returns(uint32[], uint[]);\n    function GetTempStuffList(address acc) external view returns(uint32[], uint[]);\n    function GetChipList(address acc) external view returns(uint32[], uint[]);\n    function GetCardList(address acc) external view returns(uint32[] tempCards, uint[] cardsTime, uint32[] permCards);\n}\n\ncontract Main is MainChip,MainCard,MainBag,MainBonus\n{\n    using ItemList for ItemList.Data;\n\n    constructor(address Receiver) public MainBonus(Receiver) {}\n\n    ///==================================================================\n    bool g_Synced = false;\n    function SyncOldData(OldMain oldMain, address[] accounts) external CreatorAble\n    {\n        // transfer itemdata\n        require(!g_Synced);\n        g_Synced = true;\n        for (uint i=0; i<accounts.length; i++)\n        {\n            address acc = accounts[i];\n            SyncStuff(oldMain, acc);\n            SyncTempStuff(oldMain, acc);\n            SyncChip(oldMain, acc);\n            SyncCard(oldMain, acc);\n        }\n    }\n\n    function SyncItemData(ItemList.Data storage Data, uint32[] idxList, uint[] valList) internal\n    {\n        if (idxList.length == 0) return;\n        for (uint i=0; i<idxList.length; i++)\n        {\n            uint32 index = idxList[i];\n            uint val = valList[i];\n            Data.set(index, val);\n        }\n    }\n\n    function SyncStuff(OldMain oldMain, address acc) internal\n    {\n        (uint32[] memory idxList, uint[] memory valList) = oldMain.GetStuffList(acc);\n        SyncItemData(g_BagList[acc].m_Stuff, idxList, valList);\n    }\n\n    function SyncTempStuff(OldMain oldMain, address acc) internal\n    {\n        (uint32[] memory idxList, uint[] memory valList) = oldMain.GetTempStuffList(acc);\n        SyncItemData(g_BagList[acc].m_TempStuff, idxList, valList);\n    }\n\n    function SyncChip(OldMain oldMain, address acc) internal\n    {\n        (uint32[] memory idxList, uint[] memory valList) = oldMain.GetChipList(acc);\n        SyncItemData(g_BagList[acc].m_Chips, idxList, valList);\n    }\n\n    function CompensateChips(address acc, uint32[] idxList) internal\n    {\n        for (uint i=0; i<idxList.length; i++)\n        {\n            uint32 iCard = idxList[i];\n            if (iCard == 0) return;\n            Card storage obj = GetCard(iCard);\n            for (uint j=0; j<obj.m_Parts.length; j++)\n            {\n                uint32 iChip = obj.m_Parts[j];\n                g_BagList[acc].m_Chips.add(iChip,1);\n            }\n        }\n    }\n\n    function SyncCard(OldMain oldMain, address acc) internal\n    {\n        (uint32[] memory idxList, uint[] memory valList ,uint32[] memory permCards) = oldMain.GetCardList(acc);\n        uint32[] memory allCards = new uint32[](idxList.length+permCards.length);\n        uint i=0;\n        uint j=0;\n        for (j=0; j<idxList.length; j++)\n        {\n            uint expire = valList[j];\n            if (expire < now) continue;\n            allCards[i] = idxList[j];\n            i++;\n        }\n        for (j=0; j<permCards.length; j++)\n        {\n            allCards[i] = permCards[j];\n            i++;\n        }\n        CompensateChips(acc, allCards);\n    }\n\n    ///==================================================================\n\n    function InsertCard(uint32 iCard, uint32 duration, uint8 level, uint16 dp, uint16 dpk, uint16 sp, uint16 ip, uint32[] parts) external CreatorAble\n    {\n        require(!CardExists(iCard));\n        require(level<=HEROLEVEL_MAX && level>=HEROLEVEL_MIN);\n        require(GetPartNum(level) == parts.length);\n        AddNewCard(iCard, duration, level, dp, dpk, sp, ip, parts);\n        for (uint8 iPart=1; iPart<=parts.length; iPart++)\n        {\n            uint idx = iPart-1;\n            uint32 iChip = parts[idx];\n            uint8 limit = GetPartLimit(level, iPart);\n            AddNewChip(iChip, level, limit, iPart);\n        }\n    }\n\n    function GainCard(address acc, uint32 iCard) external AuthAble OwnerAble(acc)\n    {\n        require(CardExists(iCard) && !HasCard(acc,iCard));\n        GainCard2(acc,iCard);\n        ProfitByCard(acc,iCard);\n    }\n\n    function GetDynamicCardAmountList(address acc) external view returns(uint[] amountList)\n    {\n        Bag storage oBag = g_BagList[acc];\n        uint len = oBag.m_TempCards.m_List.length;\n        amountList = new uint[](len);\n        for (uint i=0; i<len; i++)\n        {\n            uint32 iCard = oBag.m_TempCards.m_List[i];\n            amountList[i] = GetDynamicCardNum(iCard,GetDayCount(now));\n        }\n    }\n\n    function GenChipByRandomWeight(uint random, uint8 level, uint[] extWeight) external AuthAble returns(uint32 iChip)\n    {\n        RefreshChipUnableList(level);\n        iChip = GenChipByWeight(random,level,extWeight);\n        ObtainChip(iChip);\n    }\n\n    function CheckGenChip(uint32 iChip) external view returns(bool)\n    {\n        return CanObtainChip(iChip);\n    }\n\n    function GenChip(uint32 iChip) external AuthAble\n    {\n        require(CanObtainChip(iChip));\n        ObtainChip(iChip);\n    }\n\n}\n\n\n\n\ncontract Child is Base {\n\n    Main g_Main;\n\n    constructor(Main main) public\n    {\n        require(main != address(0));\n        g_Main = main;\n        g_Main.SetAuth(this);\n    }\n\n    function kill() external CreatorAble\n    {\n        g_Main.ClearAuth(this);\n        selfdestruct(creator);\n    }\n\n    function AddBonus(uint percent) internal\n    {\n        address(g_Main).transfer(msg.value);\n        g_Main.AddBonus(msg.value * percent / 100);\n    }\n\n    function GenRandom(uint seed,uint base) internal view returns(uint,uint)\n    {\n        uint r = uint(keccak256(abi.encodePacked(msg.sender,seed,now)));\n        if (base != 0) r %= base;\n        return (r,seed+1);\n    }\n\n}\n\n\n\n\ncontract Home is Child,BasicTime\n{\n    uint32 constant SGININ_REWARD_TEMPSTUFF = 23001;\n    uint constant SGININ_REWARD_FREEDAY = 10;\n    uint32 constant SGININ_REWARD_STUFF = 21000;\n    uint constant SGININ_REWARD_NUM = 300;\n\n    mapping(address => uint) g_SignInDay;\n\n\n    constructor(Main main) public Child(main) {}\n\n    function CanSignIn() internal view returns(bool bCanSignIn, uint expire, uint dayNo)\n    {\n        dayNo = GetDayCount(now);\n        expire = g_Main.GetTempStuffExpire(msg.sender,SGININ_REWARD_TEMPSTUFF);\n        if (g_SignInDay[msg.sender] >= dayNo) return;\n        if (expire>0 && expire<now) return;\n        bCanSignIn = true;\n    }\n\n    function GetDayReward() external\n    {\n        (bool bCanSignIn, uint expire, uint todayNo) = CanSignIn();\n        require(bCanSignIn);\n        g_SignInDay[msg.sender] = todayNo;\n        if (expire == 0) {\n            // new player has a few days to free signin\n            g_Main.GainTempStuff(msg.sender, SGININ_REWARD_TEMPSTUFF, SGININ_REWARD_FREEDAY);\n        }\n        g_Main.GainStuff(msg.sender, SGININ_REWARD_STUFF, SGININ_REWARD_NUM);\n    }\n\n    function Withdraw() external\n    {\n        g_Main.Withdraw(msg.sender);\n    }\n\n    function GetPlayerInfo() external view returns(\n        bool bCanSignIn,\n        uint allBonus,\n        uint myBonus,\n        uint32[] stuffIdxList,\n        uint[] stuffNumList,\n        uint32[] tempStuffList,\n        uint[] tempStuffTime\n    )\n    {\n        (bCanSignIn,,) = CanSignIn();\n        allBonus = g_Main.QueryBonus();\n        myBonus = g_Main.QueryMyBonus(msg.sender);\n        (stuffIdxList,stuffNumList) = g_Main.GetStuffList(msg.sender);\n        (tempStuffList,tempStuffTime) = g_Main.GetTempStuffList(msg.sender);\n    }\n\n    function Donate() payable external\n    {\n        require(msg.value > 0);\n        AddBonus(100);\n    }\n\n}",
  "bytecode": "608060405234801561001057600080fd5b50604051602080610b33833981016040525160008054600160a060020a0319163317905580600160a060020a038116151561004a57600080fd5b60018054600160a060020a031916600160a060020a038381169190911791829055604080517fbf7abee60000000000000000000000000000000000000000000000000000000081523060048201529051929091169163bf7abee69160248082019260009290919082900301818387803b1580156100c657600080fd5b505af11580156100da573d6000803e3d6000fd5b505050505050610a44806100ef6000396000f30060806040526004361061006c5763ffffffff7c01000000000000000000000000000000000000000000000000000000006000350416632e639fd5811461007157806341c0e1b5146101c257806357ea89b6146101d9578063d917deb5146101ee578063da51f168146101f6575b600080fd5b34801561007d57600080fd5b5061008661020b565b604051808815151515815260200187815260200186815260200180602001806020018060200180602001858103855289818151815260200191508051906020019060200280838360005b838110156100e85781810151838201526020016100d0565b50505050905001858103845288818151815260200191508051906020019060200280838360005b8381101561012757818101518382015260200161010f565b50505050905001858103835287818151815260200191508051906020019060200280838360005b8381101561016657818101518382015260200161014e565b50505050905001858103825286818151815260200191508051906020019060200280838360005b838110156101a557818101518382015260200161018d565b505050509050019b50505050505050505050505060405180910390f35b3480156101ce57600080fd5b506101d76105d3565b005b3480156101e557600080fd5b506101d7610676565b6101d76106f5565b34801561020257600080fd5b506101d761070e565b600080600060608060608061021e610865565b5050600154604080517f1bb409c40000000000000000000000000000000000000000000000000000000081529051929950600160a060020a0390911691631bb409c4916004808201926020929091908290030181600087803b15801561028357600080fd5b505af1158015610297573d6000803e3d6000fd5b505050506040513d60208110156102ad57600080fd5b5051600154604080517f54370a8d0000000000000000000000000000000000000000000000000000000081523360048201529051929850600160a060020a03909116916354370a8d916024808201926020929091908290030181600087803b15801561031857600080fd5b505af115801561032c573d6000803e3d6000fd5b505050506040513d602081101561034257600080fd5b5051600154604080517fdf67ae3d0000000000000000000000000000000000000000000000000000000081523360048201529051929750600160a060020a039091169163df67ae3d9160248082019260009290919082900301818387803b1580156103ac57600080fd5b505af11580156103c0573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160409081528110156103e957600080fd5b81019080805164010000000081111561040157600080fd5b8201602081018481111561041457600080fd5b815185602082028301116401000000008211171561043157600080fd5b5050929190602001805164010000000081111561044d57600080fd5b8201602081018481111561046057600080fd5b815185602082028301116401000000008211171561047d57600080fd5b5050600154604080517f74e9e1020000000000000000000000000000000000000000000000000000000081523360048201529051969a50919850600160a060020a0316946374e9e10294506024808301945060009350909182900301818387803b1580156104ea57600080fd5b505af11580156104fe573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604090815281101561052757600080fd5b81019080805164010000000081111561053f57600080fd5b8201602081018481111561055257600080fd5b815185602082028301116401000000008211171561056f57600080fd5b5050929190602001805164010000000081111561058b57600080fd5b8201602081018481111561059e57600080fd5b81518560208202830111640100000000821117156105bb57600080fd5b509b9c9a9b5098999798969793969550929350505050565b600054600160a060020a031633146105ea57600080fd5b600154604080517fcc9b714c0000000000000000000000000000000000000000000000000000000081523060048201529051600160a060020a039092169163cc9b714c9160248082019260009290919082900301818387803b15801561064f57600080fd5b505af1158015610663573d6000803e3d6000fd5b5050600054600160a060020a0316915050ff5b600154604080517ff67611510000000000000000000000000000000000000000000000000000000081523360048201529051600160a060020a039092169163f67611519160248082019260009290919082900301818387803b1580156106db57600080fd5b505af11580156106ef573d6000803e3d6000fd5b50505050565b6000341161070257600080fd5b61070c6064610951565b565b600080600061071b610865565b92509250925082151561072d57600080fd5b3360009081526002602052604090208190558115156107d357600154604080517f64d57a030000000000000000000000000000000000000000000000000000000081523360048201526159d96024820152600a60448201529051600160a060020a03909216916364d57a039160648082019260009290919082900301818387803b1580156107ba57600080fd5b505af11580156107ce573d6000803e3d6000fd5b505050505b600154604080517f26b7fe35000000000000000000000000000000000000000000000000000000008152336004820152615208602482015261012c60448201529051600160a060020a03909216916326b7fe359160648082019260009290919082900301818387803b15801561084857600080fd5b505af115801561085c573d6000803e3d6000fd5b50505050505050565b600080600061087342610a0f565b600154604080517f4ce197f30000000000000000000000000000000000000000000000000000000081523360048201526159d960248201529051929350600160a060020a0390911691634ce197f3916044808201926020929091908290030181600087803b1580156108e457600080fd5b505af11580156108f8573d6000803e3d6000fd5b505050506040513d602081101561090e57600080fd5b505133600090815260026020526040902054909250811161092e5761094c565b60008211801561093d57504282105b156109475761094c565b600192505b909192565b600154604051600160a060020a03909116903480156108fc02916000818181858888f1935050505015801561098a573d6000803e3d6000fd5b50600154600160a060020a0316636bdea7eb6064348402046040518263ffffffff167c010000000000000000000000000000000000000000000000000000000002815260040180828152602001915050600060405180830381600087803b1580156109f457600080fd5b505af1158015610a08573d6000803e3d6000fd5b5050505050565b620151809004905600a165627a7a723058203c3eff6c172abd61e78606bd49a70657e600d8b685da15afe7595442437fe08a0029000000000000000000000000318bf186c7681ed7efd57839e6415cd8a162713c",
  "constructorArguments": "000000000000000000000000318bf186c7681ed7efd57839e6415cd8a162713c"
}