{
  "address": "0x03d9550c4ce1df4ad97bbcfe4df24cdec9cf3b24",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "BucketLenderWithRecoveryDelay",
  "compilerVersion": "v0.4.24+commit.e67f0147",
  "optimization": true,
  "runs": "10000",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2018-11-16\n*/\n\npragma solidity 0.4.24;\npragma experimental \"v0.5.0\";\n\n/*\n\n    Copyright 2018 dYdX Trading Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\n// File: openzeppelin-solidity/contracts/math/Math.sol\n\n/**\n * @title Math\n * @dev Assorted math operations\n */\nlibrary Math {\n  function max64(uint64 _a, uint64 _b) internal pure returns (uint64) {\n    return _a >= _b ? _a : _b;\n  }\n\n  function min64(uint64 _a, uint64 _b) internal pure returns (uint64) {\n    return _a < _b ? _a : _b;\n  }\n\n  function max256(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    return _a >= _b ? _a : _b;\n  }\n\n  function min256(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    return _a < _b ? _a : _b;\n  }\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (_a == 0) {\n      return 0;\n    }\n\n    c = _a * _b;\n    assert(c / _a == _b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = _a / _b;\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n    return _a / _b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    assert(_b <= _a);\n    return _a - _b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    c = _a + _b;\n    assert(c >= _a);\n    return c;\n  }\n}\n\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n  event OwnershipRenounced(address indexed previousOwner);\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to relinquish control of the contract.\n   * @notice Renouncing to ownership will leave the contract without an owner.\n   * It will not be possible to call the functions with the `onlyOwner`\n   * modifier anymore.\n   */\n  function renounceOwnership() public onlyOwner {\n    emit OwnershipRenounced(owner);\n    owner = address(0);\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address _newOwner) public onlyOwner {\n    _transferOwnership(_newOwner);\n  }\n\n  /**\n   * @dev Transfers control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function _transferOwnership(address _newOwner) internal {\n    require(_newOwner != address(0));\n    emit OwnershipTransferred(owner, _newOwner);\n    owner = _newOwner;\n  }\n}\n\n// File: contracts/lib/AccessControlledBase.sol\n\n/**\n * @title AccessControlledBase\n * @author dYdX\n *\n * Base functionality for access control. Requires an implementation to\n * provide a way to grant and optionally revoke access\n */\ncontract AccessControlledBase {\n    // ============ State Variables ============\n\n    mapping (address => bool) public authorized;\n\n    // ============ Events ============\n\n    event AccessGranted(\n        address who\n    );\n\n    event AccessRevoked(\n        address who\n    );\n\n    // ============ Modifiers ============\n\n    modifier requiresAuthorization() {\n        require(\n            authorized[msg.sender],\n            \"AccessControlledBase#requiresAuthorization: Sender not authorized\"\n        );\n        _;\n    }\n}\n\n// File: contracts/lib/StaticAccessControlled.sol\n\n/**\n * @title StaticAccessControlled\n * @author dYdX\n *\n * Allows for functions to be access controled\n * Permissions cannot be changed after a grace period\n */\ncontract StaticAccessControlled is AccessControlledBase, Ownable {\n    using SafeMath for uint256;\n\n    // ============ State Variables ============\n\n    // Timestamp after which no additional access can be granted\n    uint256 public GRACE_PERIOD_EXPIRATION;\n\n    // ============ Constructor ============\n\n    constructor(\n        uint256 gracePeriod\n    )\n        public\n        Ownable()\n    {\n        GRACE_PERIOD_EXPIRATION = block.timestamp.add(gracePeriod);\n    }\n\n    // ============ Owner-Only State-Changing Functions ============\n\n    function grantAccess(\n        address who\n    )\n        external\n        onlyOwner\n    {\n        require(\n            block.timestamp < GRACE_PERIOD_EXPIRATION,\n            \"StaticAccessControlled#grantAccess: Cannot grant access after grace period\"\n        );\n\n        emit AccessGranted(who);\n        authorized[who] = true;\n    }\n}\n\n// File: contracts/lib/GeneralERC20.sol\n\n/**\n * @title GeneralERC20\n * @author dYdX\n *\n * Interface for using ERC20 Tokens. We have to use a special interface to call ERC20 functions so\n * that we dont automatically revert when calling non-compliant tokens that have no return value for\n * transfer(), transferFrom(), or approve().\n */\ninterface GeneralERC20 {\n    function totalSupply(\n    )\n        external\n        view\n        returns (uint256);\n\n    function balanceOf(\n        address who\n    )\n        external\n        view\n        returns (uint256);\n\n    function allowance(\n        address owner,\n        address spender\n    )\n        external\n        view\n        returns (uint256);\n\n    function transfer(\n        address to,\n        uint256 value\n    )\n        external;\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    )\n        external;\n\n    function approve(\n        address spender,\n        uint256 value\n    )\n        external;\n}\n\n// File: contracts/lib/TokenInteract.sol\n\n/**\n * @title TokenInteract\n * @author dYdX\n *\n * This library contains functions for interacting with ERC20 tokens\n */\nlibrary TokenInteract {\n    function balanceOf(\n        address token,\n        address owner\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        return GeneralERC20(token).balanceOf(owner);\n    }\n\n    function allowance(\n        address token,\n        address owner,\n        address spender\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        return GeneralERC20(token).allowance(owner, spender);\n    }\n\n    function approve(\n        address token,\n        address spender,\n        uint256 amount\n    )\n        internal\n    {\n        GeneralERC20(token).approve(spender, amount);\n\n        require(\n            checkSuccess(),\n            \"TokenInteract#approve: Approval failed\"\n        );\n    }\n\n    function transfer(\n        address token,\n        address to,\n        uint256 amount\n    )\n        internal\n    {\n        address from = address(this);\n        if (\n            amount == 0\n            || from == to\n        ) {\n            return;\n        }\n\n        GeneralERC20(token).transfer(to, amount);\n\n        require(\n            checkSuccess(),\n            \"TokenInteract#transfer: Transfer failed\"\n        );\n    }\n\n    function transferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 amount\n    )\n        internal\n    {\n        if (\n            amount == 0\n            || from == to\n        ) {\n            return;\n        }\n\n        GeneralERC20(token).transferFrom(from, to, amount);\n\n        require(\n            checkSuccess(),\n            \"TokenInteract#transferFrom: TransferFrom failed\"\n        );\n    }\n\n    // ============ Private Helper-Functions ============\n\n    /**\n     * Checks the return value of the previous function up to 32 bytes. Returns true if the previous\n     * function returned 0 bytes or 32 bytes that are not all-zero.\n     */\n    function checkSuccess(\n    )\n        private\n        pure\n        returns (bool)\n    {\n        uint256 returnValue = 0;\n\n        /* solium-disable-next-line security/no-inline-assembly */\n        assembly {\n            // check number of bytes returned from last function call\n            switch returndatasize\n\n            // no bytes returned: assume success\n            case 0x0 {\n                returnValue := 1\n            }\n\n            // 32 bytes returned: check if non-zero\n            case 0x20 {\n                // copy 32 bytes into scratch space\n                returndatacopy(0x0, 0x0, 0x20)\n\n                // load those bytes into returnValue\n                returnValue := mload(0x0)\n            }\n\n            // not sure what was returned: dont mark as success\n            default { }\n        }\n\n        return returnValue != 0;\n    }\n}\n\n// File: contracts/margin/TokenProxy.sol\n\n/**\n * @title TokenProxy\n * @author dYdX\n *\n * Used to transfer tokens between addresses which have set allowance on this contract.\n */\ncontract TokenProxy is StaticAccessControlled {\n    using SafeMath for uint256;\n\n    // ============ Constructor ============\n\n    constructor(\n        uint256 gracePeriod\n    )\n        public\n        StaticAccessControlled(gracePeriod)\n    {}\n\n    // ============ Authorized-Only State Changing Functions ============\n\n    /**\n     * Transfers tokens from an address (that has set allowance on the proxy) to another address.\n     *\n     * @param  token  The address of the ERC20 token\n     * @param  from   The address to transfer token from\n     * @param  to     The address to transfer tokens to\n     * @param  value  The number of tokens to transfer\n     */\n    function transferTokens(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    )\n        external\n        requiresAuthorization\n    {\n        TokenInteract.transferFrom(\n            token,\n            from,\n            to,\n            value\n        );\n    }\n\n    // ============ Public Constant Functions ============\n\n    /**\n     * Getter function to get the amount of token that the proxy is able to move for a particular\n     * address. The minimum of 1) the balance of that address and 2) the allowance given to proxy.\n     *\n     * @param  who    The owner of the tokens\n     * @param  token  The address of the ERC20 token\n     * @return        The number of tokens able to be moved by the proxy from the address specified\n     */\n    function available(\n        address who,\n        address token\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return Math.min256(\n            TokenInteract.allowance(token, who, address(this)),\n            TokenInteract.balanceOf(token, who)\n        );\n    }\n}\n\n// File: contracts/margin/Vault.sol\n\n/**\n * @title Vault\n * @author dYdX\n *\n * Holds and transfers tokens in vaults denominated by id\n *\n * Vault only supports ERC20 tokens, and will not accept any tokens that require\n * a tokenFallback or equivalent function (See ERC223, ERC777, etc.)\n */\ncontract Vault is StaticAccessControlled\n{\n    using SafeMath for uint256;\n\n    // ============ Events ============\n\n    event ExcessTokensWithdrawn(\n        address indexed token,\n        address indexed to,\n        address caller\n    );\n\n    // ============ State Variables ============\n\n    // Address of the TokenProxy contract. Used for moving tokens.\n    address public TOKEN_PROXY;\n\n    // Map from vault ID to map from token address to amount of that token attributed to the\n    // particular vault ID.\n    mapping (bytes32 => mapping (address => uint256)) public balances;\n\n    // Map from token address to total amount of that token attributed to some account.\n    mapping (address => uint256) public totalBalances;\n\n    // ============ Constructor ============\n\n    constructor(\n        address proxy,\n        uint256 gracePeriod\n    )\n        public\n        StaticAccessControlled(gracePeriod)\n    {\n        TOKEN_PROXY = proxy;\n    }\n\n    // ============ Owner-Only State-Changing Functions ============\n\n    /**\n     * Allows the owner to withdraw any excess tokens sent to the vault by unconventional means,\n     * including (but not limited-to) token airdrops. Any tokens moved to the vault by TOKEN_PROXY\n     * will be accounted for and will not be withdrawable by this function.\n     *\n     * @param  token  ERC20 token address\n     * @param  to     Address to transfer tokens to\n     * @return        Amount of tokens withdrawn\n     */\n    function withdrawExcessToken(\n        address token,\n        address to\n    )\n        external\n        onlyOwner\n        returns (uint256)\n    {\n        uint256 actualBalance = TokenInteract.balanceOf(token, address(this));\n        uint256 accountedBalance = totalBalances[token];\n        uint256 withdrawableBalance = actualBalance.sub(accountedBalance);\n\n        require(\n            withdrawableBalance != 0,\n            \"Vault#withdrawExcessToken: Withdrawable token amount must be non-zero\"\n        );\n\n        TokenInteract.transfer(token, to, withdrawableBalance);\n\n        emit ExcessTokensWithdrawn(token, to, msg.sender);\n\n        return withdrawableBalance;\n    }\n\n    // ============ Authorized-Only State-Changing Functions ============\n\n    /**\n     * Transfers tokens from an address (that has approved the proxy) to the vault.\n     *\n     * @param  id      The vault which will receive the tokens\n     * @param  token   ERC20 token address\n     * @param  from    Address from which the tokens will be taken\n     * @param  amount  Number of the token to be sent\n     */\n    function transferToVault(\n        bytes32 id,\n        address token,\n        address from,\n        uint256 amount\n    )\n        external\n        requiresAuthorization\n    {\n        // First send tokens to this contract\n        TokenProxy(TOKEN_PROXY).transferTokens(\n            token,\n            from,\n            address(this),\n            amount\n        );\n\n        // Then increment balances\n        balances[id][token] = balances[id][token].add(amount);\n        totalBalances[token] = totalBalances[token].add(amount);\n\n        // This should always be true. If not, something is very wrong\n        assert(totalBalances[token] >= balances[id][token]);\n\n        validateBalance(token);\n    }\n\n    /**\n     * Transfers a certain amount of funds to an address.\n     *\n     * @param  id      The vault from which to send the tokens\n     * @param  token   ERC20 token address\n     * @param  to      Address to transfer tokens to\n     * @param  amount  Number of the token to be sent\n     */\n    function transferFromVault(\n        bytes32 id,\n        address token,\n        address to,\n        uint256 amount\n    )\n        external\n        requiresAuthorization\n    {\n        // Next line also asserts that (balances[id][token] >= amount);\n        balances[id][token] = balances[id][token].sub(amount);\n\n        // Next line also asserts that (totalBalances[token] >= amount);\n        totalBalances[token] = totalBalances[token].sub(amount);\n\n        // This should always be true. If not, something is very wrong\n        assert(totalBalances[token] >= balances[id][token]);\n\n        // Do the sending\n        TokenInteract.transfer(token, to, amount); // asserts transfer succeeded\n\n        // Final validation\n        validateBalance(token);\n    }\n\n    // ============ Private Helper-Functions ============\n\n    /**\n     * Verifies that this contract is in control of at least as many tokens as accounted for\n     *\n     * @param  token  Address of ERC20 token\n     */\n    function validateBalance(\n        address token\n    )\n        private\n        view\n    {\n        // The actual balance could be greater than totalBalances[token] because anyone\n        // can send tokens to the contract's address which cannot be accounted for\n        assert(TokenInteract.balanceOf(token, address(this)) >= totalBalances[token]);\n    }\n}\n\n// File: contracts/lib/ReentrancyGuard.sol\n\n/**\n * @title ReentrancyGuard\n * @author dYdX\n *\n * Optimized version of the well-known ReentrancyGuard contract\n */\ncontract ReentrancyGuard {\n    uint256 private _guardCounter = 1;\n\n    modifier nonReentrant() {\n        uint256 localCounter = _guardCounter + 1;\n        _guardCounter = localCounter;\n        _;\n        require(\n            _guardCounter == localCounter,\n            \"Reentrancy check failure\"\n        );\n    }\n}\n\n// File: openzeppelin-solidity/contracts/AddressUtils.sol\n\n/**\n * Utility library of inline functions on addresses\n */\nlibrary AddressUtils {\n\n  /**\n   * Returns whether the target address is a contract\n   * @dev This function will return false if invoked during the constructor of a contract,\n   * as the code is not actually created until after the constructor finishes.\n   * @param _addr address to check\n   * @return whether the target address is a contract\n   */\n  function isContract(address _addr) internal view returns (bool) {\n    uint256 size;\n    // XXX Currently there is no better way to check if there is a contract in an address\n    // than to check the size of the code at that address.\n    // See https://ethereum.stackexchange.com/a/14016/36603\n    // for more details about how this works.\n    // TODO Check this again before the Serenity release, because all addresses will be\n    // contracts then.\n    // solium-disable-next-line security/no-inline-assembly\n    assembly { size := extcodesize(_addr) }\n    return size > 0;\n  }\n\n}\n\n// File: contracts/lib/Fraction.sol\n\n/**\n * @title Fraction\n * @author dYdX\n *\n * This library contains implementations for fraction structs.\n */\nlibrary Fraction {\n    struct Fraction128 {\n        uint128 num;\n        uint128 den;\n    }\n}\n\n// File: contracts/lib/FractionMath.sol\n\n/**\n * @title FractionMath\n * @author dYdX\n *\n * This library contains safe math functions for manipulating fractions.\n */\nlibrary FractionMath {\n    using SafeMath for uint256;\n    using SafeMath for uint128;\n\n    /**\n     * Returns a Fraction128 that is equal to a + b\n     *\n     * @param  a  The first Fraction128\n     * @param  b  The second Fraction128\n     * @return    The result (sum)\n     */\n    function add(\n        Fraction.Fraction128 memory a,\n        Fraction.Fraction128 memory b\n    )\n        internal\n        pure\n        returns (Fraction.Fraction128 memory)\n    {\n        uint256 left = a.num.mul(b.den);\n        uint256 right = b.num.mul(a.den);\n        uint256 denominator = a.den.mul(b.den);\n\n        // if left + right overflows, prevent overflow\n        if (left + right < left) {\n            left = left.div(2);\n            right = right.div(2);\n            denominator = denominator.div(2);\n        }\n\n        return bound(left.add(right), denominator);\n    }\n\n    /**\n     * Returns a Fraction128 that is equal to a - (1/2)^d\n     *\n     * @param  a  The Fraction128\n     * @param  d  The power of (1/2)\n     * @return    The result\n     */\n    function sub1Over(\n        Fraction.Fraction128 memory a,\n        uint128 d\n    )\n        internal\n        pure\n        returns (Fraction.Fraction128 memory)\n    {\n        if (a.den % d == 0) {\n            return bound(\n                a.num.sub(a.den.div(d)),\n                a.den\n            );\n        }\n        return bound(\n            a.num.mul(d).sub(a.den),\n            a.den.mul(d)\n        );\n    }\n\n    /**\n     * Returns a Fraction128 that is equal to a / d\n     *\n     * @param  a  The first Fraction128\n     * @param  d  The divisor\n     * @return    The result (quotient)\n     */\n    function div(\n        Fraction.Fraction128 memory a,\n        uint128 d\n    )\n        internal\n        pure\n        returns (Fraction.Fraction128 memory)\n    {\n        if (a.num % d == 0) {\n            return bound(\n                a.num.div(d),\n                a.den\n            );\n        }\n        return bound(\n            a.num,\n            a.den.mul(d)\n        );\n    }\n\n    /**\n     * Returns a Fraction128 that is equal to a * b.\n     *\n     * @param  a  The first Fraction128\n     * @param  b  The second Fraction128\n     * @return    The result (product)\n     */\n    function mul(\n        Fraction.Fraction128 memory a,\n        Fraction.Fraction128 memory b\n    )\n        internal\n        pure\n        returns (Fraction.Fraction128 memory)\n    {\n        return bound(\n            a.num.mul(b.num),\n            a.den.mul(b.den)\n        );\n    }\n\n    /**\n     * Returns a fraction from two uint256's. Fits them into uint128 if necessary.\n     *\n     * @param  num  The numerator\n     * @param  den  The denominator\n     * @return      The Fraction128 that matches num/den most closely\n     */\n    /* solium-disable-next-line security/no-assign-params */\n    function bound(\n        uint256 num,\n        uint256 den\n    )\n        internal\n        pure\n        returns (Fraction.Fraction128 memory)\n    {\n        uint256 max = num > den ? num : den;\n        uint256 first128Bits = (max >> 128);\n        if (first128Bits != 0) {\n            first128Bits += 1;\n            num /= first128Bits;\n            den /= first128Bits;\n        }\n\n        assert(den != 0); // coverage-enable-line\n        assert(den < 2**128);\n        assert(num < 2**128);\n\n        return Fraction.Fraction128({\n            num: uint128(num),\n            den: uint128(den)\n        });\n    }\n\n    /**\n     * Returns an in-memory copy of a Fraction128\n     *\n     * @param  a  The Fraction128 to copy\n     * @return    A copy of the Fraction128\n     */\n    function copy(\n        Fraction.Fraction128 memory a\n    )\n        internal\n        pure\n        returns (Fraction.Fraction128 memory)\n    {\n        validate(a);\n        return Fraction.Fraction128({ num: a.num, den: a.den });\n    }\n\n    // ============ Private Helper-Functions ============\n\n    /**\n     * Asserts that a Fraction128 is valid (i.e. the denominator is non-zero)\n     *\n     * @param  a  The Fraction128 to validate\n     */\n    function validate(\n        Fraction.Fraction128 memory a\n    )\n        private\n        pure\n    {\n        assert(a.den != 0); // coverage-enable-line\n    }\n}\n\n// File: contracts/lib/Exponent.sol\n\n/**\n * @title Exponent\n * @author dYdX\n *\n * This library contains an implementation for calculating e^X for arbitrary fraction X\n */\nlibrary Exponent {\n    using SafeMath for uint256;\n    using FractionMath for Fraction.Fraction128;\n\n    // ============ Constants ============\n\n    // 2**128 - 1\n    uint128 constant public MAX_NUMERATOR = 340282366920938463463374607431768211455;\n\n    // Number of precomputed integers, X, for E^((1/2)^X)\n    uint256 constant public MAX_PRECOMPUTE_PRECISION = 32;\n\n    // Number of precomputed integers, X, for E^X\n    uint256 constant public NUM_PRECOMPUTED_INTEGERS = 32;\n\n    // ============ Public Implementation Functions ============\n\n    /**\n     * Returns e^X for any fraction X\n     *\n     * @param  X                    The exponent\n     * @param  precomputePrecision  Accuracy of precomputed terms\n     * @param  maclaurinPrecision   Accuracy of Maclaurin terms\n     * @return                      e^X\n     */\n    function exp(\n        Fraction.Fraction128 memory X,\n        uint256 precomputePrecision,\n        uint256 maclaurinPrecision\n    )\n        internal\n        pure\n        returns (Fraction.Fraction128 memory)\n    {\n        require(\n            precomputePrecision <= MAX_PRECOMPUTE_PRECISION,\n            \"Exponent#exp: Precompute precision over maximum\"\n        );\n\n        Fraction.Fraction128 memory Xcopy = X.copy();\n        if (Xcopy.num == 0) { // e^0 = 1\n            return ONE();\n        }\n\n        // get the integer value of the fraction (example: 9/4 is 2.25 so has integerValue of 2)\n        uint256 integerX = uint256(Xcopy.num).div(Xcopy.den);\n\n        // if X is less than 1, then just calculate X\n        if (integerX == 0) {\n            return expHybrid(Xcopy, precomputePrecision, maclaurinPrecision);\n        }\n\n        // get e^integerX\n        Fraction.Fraction128 memory expOfInt =\n            getPrecomputedEToThe(integerX % NUM_PRECOMPUTED_INTEGERS);\n        while (integerX >= NUM_PRECOMPUTED_INTEGERS) {\n            expOfInt = expOfInt.mul(getPrecomputedEToThe(NUM_PRECOMPUTED_INTEGERS));\n            integerX -= NUM_PRECOMPUTED_INTEGERS;\n        }\n\n        // multiply e^integerX by e^decimalX\n        Fraction.Fraction128 memory decimalX = Fraction.Fraction128({\n            num: Xcopy.num % Xcopy.den,\n            den: Xcopy.den\n        });\n        return expHybrid(decimalX, precomputePrecision, maclaurinPrecision).mul(expOfInt);\n    }\n\n    /**\n     * Returns e^X for any X < 1. Multiplies precomputed values to get close to the real value, then\n     * Maclaurin Series approximation to reduce error.\n     *\n     * @param  X                    Exponent\n     * @param  precomputePrecision  Accuracy of precomputed terms\n     * @param  maclaurinPrecision   Accuracy of Maclaurin terms\n     * @return                      e^X\n     */\n    function expHybrid(\n        Fraction.Fraction128 memory X,\n        uint256 precomputePrecision,\n        uint256 maclaurinPrecision\n    )\n        internal\n        pure\n        returns (Fraction.Fraction128 memory)\n    {\n        assert(precomputePrecision <= MAX_PRECOMPUTE_PRECISION);\n        assert(X.num < X.den);\n        // will also throw if precomputePrecision is larger than the array length in getDenominator\n\n        Fraction.Fraction128 memory Xtemp = X.copy();\n        if (Xtemp.num == 0) { // e^0 = 1\n            return ONE();\n        }\n\n        Fraction.Fraction128 memory result = ONE();\n\n        uint256 d = 1; // 2^i\n        for (uint256 i = 1; i <= precomputePrecision; i++) {\n            d *= 2;\n\n            // if Fraction > 1/d, subtract 1/d and multiply result by precomputed e^(1/d)\n            if (d.mul(Xtemp.num) >= Xtemp.den) {\n                Xtemp = Xtemp.sub1Over(uint128(d));\n                result = result.mul(getPrecomputedEToTheHalfToThe(i));\n            }\n        }\n        return result.mul(expMaclaurin(Xtemp, maclaurinPrecision));\n    }\n\n    /**\n     * Returns e^X for any X, using Maclaurin Series approximation\n     *\n     * e^X = SUM(X^n / n!) for n >= 0\n     * e^X = 1 + X/1! + X^2/2! + X^3/3! ...\n     *\n     * @param  X           Exponent\n     * @param  precision   Accuracy of Maclaurin terms\n     * @return             e^X\n     */\n    function expMaclaurin(\n        Fraction.Fraction128 memory X,\n        uint256 precision\n    )\n        internal\n        pure\n        returns (Fraction.Fraction128 memory)\n    {\n        Fraction.Fraction128 memory Xcopy = X.copy();\n        if (Xcopy.num == 0) { // e^0 = 1\n            return ONE();\n        }\n\n        Fraction.Fraction128 memory result = ONE();\n        Fraction.Fraction128 memory Xtemp = ONE();\n        for (uint256 i = 1; i <= precision; i++) {\n            Xtemp = Xtemp.mul(Xcopy.div(uint128(i)));\n            result = result.add(Xtemp);\n        }\n        return result;\n    }\n\n    /**\n     * Returns a fraction roughly equaling E^((1/2)^x) for integer x\n     */\n    function getPrecomputedEToTheHalfToThe(\n        uint256 x\n    )\n        internal\n        pure\n        returns (Fraction.Fraction128 memory)\n    {\n        assert(x <= MAX_PRECOMPUTE_PRECISION);\n\n        uint128 denominator = [\n            125182886983370532117250726298150828301,\n            206391688497133195273760705512282642279,\n            265012173823417992016237332255925138361,\n            300298134811882980317033350418940119802,\n            319665700530617779809390163992561606014,\n            329812979126047300897653247035862915816,\n            335006777809430963166468914297166288162,\n            337634268532609249517744113622081347950,\n            338955731696479810470146282672867036734,\n            339618401537809365075354109784799900812,\n            339950222128463181389559457827561204959,\n            340116253979683015278260491021941090650,\n            340199300311581465057079429423749235412,\n            340240831081268226777032180141478221816,\n            340261598367316729254995498374473399540,\n            340271982485676106947851156443492415142,\n            340277174663693808406010255284800906112,\n            340279770782412691177936847400746725466,\n            340281068849199706686796915841848278311,\n            340281717884450116236033378667952410919,\n            340282042402539547492367191008339680733,\n            340282204661700319870089970029119685699,\n            340282285791309720262481214385569134454,\n            340282326356121674011576912006427792656,\n            340282346638529464274601981200276914173,\n            340282356779733812753265346086924801364,\n            340282361850336100329388676752133324799,\n            340282364385637272451648746721404212564,\n            340282365653287865596328444437856608255,\n            340282366287113163939555716675618384724,\n            340282366604025813553891209601455838559,\n            340282366762482138471739420386372790954,\n            340282366841710300958333641874363209044\n        ][x];\n        return Fraction.Fraction128({\n            num: MAX_NUMERATOR,\n            den: denominator\n        });\n    }\n\n    /**\n     * Returns a fraction roughly equaling E^(x) for integer x\n     */\n    function getPrecomputedEToThe(\n        uint256 x\n    )\n        internal\n        pure\n        returns (Fraction.Fraction128 memory)\n    {\n        assert(x <= NUM_PRECOMPUTED_INTEGERS);\n\n        uint128 denominator = [\n            340282366920938463463374607431768211455,\n            125182886983370532117250726298150828301,\n            46052210507670172419625860892627118820,\n            16941661466271327126146327822211253888,\n            6232488952727653950957829210887653621,\n            2292804553036637136093891217529878878,\n            843475657686456657683449904934172134,\n            310297353591408453462393329342695980,\n            114152017036184782947077973323212575,\n            41994180235864621538772677139808695,\n            15448795557622704876497742989562086,\n            5683294276510101335127414470015662,\n            2090767122455392675095471286328463,\n            769150240628514374138961856925097,\n            282954560699298259527814398449860,\n            104093165666968799599694528310221,\n            38293735615330848145349245349513,\n            14087478058534870382224480725096,\n            5182493555688763339001418388912,\n            1906532833141383353974257736699,\n            701374233231058797338605168652,\n            258021160973090761055471434334,\n            94920680509187392077350434438,\n            34919366901332874995585576427,\n            12846117181722897538509298435,\n            4725822410035083116489797150,\n            1738532907279185132707372378,\n            639570514388029575350057932,\n            235284843422800231081973821,\n            86556456714490055457751527,\n            31842340925906738090071268,\n            11714142585413118080082437,\n            4309392228124372433711936\n        ][x];\n        return Fraction.Fraction128({\n            num: MAX_NUMERATOR,\n            den: denominator\n        });\n    }\n\n    // ============ Private Helper-Functions ============\n\n    function ONE()\n        private\n        pure\n        returns (Fraction.Fraction128 memory)\n    {\n        return Fraction.Fraction128({ num: 1, den: 1 });\n    }\n}\n\n// File: contracts/lib/MathHelpers.sol\n\n/**\n * @title MathHelpers\n * @author dYdX\n *\n * This library helps with common math functions in Solidity\n */\nlibrary MathHelpers {\n    using SafeMath for uint256;\n\n    /**\n     * Calculates partial value given a numerator and denominator.\n     *\n     * @param  numerator    Numerator\n     * @param  denominator  Denominator\n     * @param  target       Value to calculate partial of\n     * @return              target * numerator / denominator\n     */\n    function getPartialAmount(\n        uint256 numerator,\n        uint256 denominator,\n        uint256 target\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return numerator.mul(target).div(denominator);\n    }\n\n    /**\n     * Calculates partial value given a numerator and denominator, rounded up.\n     *\n     * @param  numerator    Numerator\n     * @param  denominator  Denominator\n     * @param  target       Value to calculate partial of\n     * @return              Rounded-up result of target * numerator / denominator\n     */\n    function getPartialAmountRoundedUp(\n        uint256 numerator,\n        uint256 denominator,\n        uint256 target\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return divisionRoundedUp(numerator.mul(target), denominator);\n    }\n\n    /**\n     * Calculates division given a numerator and denominator, rounded up.\n     *\n     * @param  numerator    Numerator.\n     * @param  denominator  Denominator.\n     * @return              Rounded-up result of numerator / denominator\n     */\n    function divisionRoundedUp(\n        uint256 numerator,\n        uint256 denominator\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        assert(denominator != 0); // coverage-enable-line\n        if (numerator == 0) {\n            return 0;\n        }\n        return numerator.sub(1).div(denominator).add(1);\n    }\n\n    /**\n     * Calculates and returns the maximum value for a uint256 in solidity\n     *\n     * @return  The maximum value for uint256\n     */\n    function maxUint256(\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return 2 ** 256 - 1;\n    }\n\n    /**\n     * Calculates and returns the maximum value for a uint256 in solidity\n     *\n     * @return  The maximum value for uint256\n     */\n    function maxUint32(\n    )\n        internal\n        pure\n        returns (uint32)\n    {\n        return 2 ** 32 - 1;\n    }\n\n    /**\n     * Returns the number of bits in a uint256. That is, the lowest number, x, such that n >> x == 0\n     *\n     * @param  n  The uint256 to get the number of bits in\n     * @return    The number of bits in n\n     */\n    function getNumBits(\n        uint256 n\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 first = 0;\n        uint256 last = 256;\n        while (first < last) {\n            uint256 check = (first + last) / 2;\n            if ((n >> check) == 0) {\n                last = check;\n            } else {\n                first = check + 1;\n            }\n        }\n        assert(first <= 256);\n        return first;\n    }\n}\n\n// File: contracts/margin/impl/InterestImpl.sol\n\n/**\n * @title InterestImpl\n * @author dYdX\n *\n * A library that calculates continuously compounded interest for principal, time period, and\n * interest rate.\n */\nlibrary InterestImpl {\n    using SafeMath for uint256;\n    using FractionMath for Fraction.Fraction128;\n\n    // ============ Constants ============\n\n    uint256 constant DEFAULT_PRECOMPUTE_PRECISION = 11;\n\n    uint256 constant DEFAULT_MACLAURIN_PRECISION = 5;\n\n    uint256 constant MAXIMUM_EXPONENT = 80;\n\n    uint128 constant E_TO_MAXIUMUM_EXPONENT = 55406223843935100525711733958316613;\n\n    // ============ Public Implementation Functions ============\n\n    /**\n     * Returns total tokens owed after accruing interest. Continuously compounding and accurate to\n     * roughly 10^18 decimal places. Continuously compounding interest follows the formula:\n     * I = P * e^(R*T)\n     *\n     * @param  principal           Principal of the interest calculation\n     * @param  interestRate        Annual nominal interest percentage times 10**6.\n     *                             (example: 5% = 5e6)\n     * @param  secondsOfInterest   Number of seconds that interest has been accruing\n     * @return                     Total amount of tokens owed. Greater than tokenAmount.\n     */\n    function getCompoundedInterest(\n        uint256 principal,\n        uint256 interestRate,\n        uint256 secondsOfInterest\n    )\n        public\n        pure\n        returns (uint256)\n    {\n        uint256 numerator = interestRate.mul(secondsOfInterest);\n        uint128 denominator = (10**8) * (365 * 1 days);\n\n        // interestRate and secondsOfInterest should both be uint32\n        assert(numerator < 2**128);\n\n        // fraction representing (Rate * Time)\n        Fraction.Fraction128 memory rt = Fraction.Fraction128({\n            num: uint128(numerator),\n            den: denominator\n        });\n\n        // calculate e^(RT)\n        Fraction.Fraction128 memory eToRT;\n        if (numerator.div(denominator) >= MAXIMUM_EXPONENT) {\n            // degenerate case: cap calculation\n            eToRT = Fraction.Fraction128({\n                num: E_TO_MAXIUMUM_EXPONENT,\n                den: 1\n            });\n        } else {\n            // normal case: calculate e^(RT)\n            eToRT = Exponent.exp(\n                rt,\n                DEFAULT_PRECOMPUTE_PRECISION,\n                DEFAULT_MACLAURIN_PRECISION\n            );\n        }\n\n        // e^X for positive X should be greater-than or equal to 1\n        assert(eToRT.num >= eToRT.den);\n\n        return safeMultiplyUint256ByFraction(principal, eToRT);\n    }\n\n    // ============ Private Helper-Functions ============\n\n    /**\n     * Returns n * f, trying to prevent overflow as much as possible. Assumes that the numerator\n     * and denominator of f are less than 2**128.\n     */\n    function safeMultiplyUint256ByFraction(\n        uint256 n,\n        Fraction.Fraction128 memory f\n    )\n        private\n        pure\n        returns (uint256)\n    {\n        uint256 term1 = n.div(2 ** 128); // first 128 bits\n        uint256 term2 = n % (2 ** 128); // second 128 bits\n\n        // uncommon scenario, requires n >= 2**128. calculates term1 = term1 * f\n        if (term1 > 0) {\n            term1 = term1.mul(f.num);\n            uint256 numBits = MathHelpers.getNumBits(term1);\n\n            // reduce rounding error by shifting all the way to the left before dividing\n            term1 = MathHelpers.divisionRoundedUp(\n                term1 << (uint256(256).sub(numBits)),\n                f.den);\n\n            // continue shifting or reduce shifting to get the right number\n            if (numBits > 128) {\n                term1 = term1 << (numBits.sub(128));\n            } else if (numBits < 128) {\n                term1 = term1 >> (uint256(128).sub(numBits));\n            }\n        }\n\n        // calculates term2 = term2 * f\n        term2 = MathHelpers.getPartialAmountRoundedUp(\n            f.num,\n            f.den,\n            term2\n        );\n\n        return term1.add(term2);\n    }\n}\n\n// File: contracts/margin/impl/MarginState.sol\n\n/**\n * @title MarginState\n * @author dYdX\n *\n * Contains state for the Margin contract. Also used by libraries that implement Margin functions.\n */\nlibrary MarginState {\n    struct State {\n        // Address of the Vault contract\n        address VAULT;\n\n        // Address of the TokenProxy contract\n        address TOKEN_PROXY;\n\n        // Mapping from loanHash -> amount, which stores the amount of a loan which has\n        // already been filled.\n        mapping (bytes32 => uint256) loanFills;\n\n        // Mapping from loanHash -> amount, which stores the amount of a loan which has\n        // already been canceled.\n        mapping (bytes32 => uint256) loanCancels;\n\n        // Mapping from positionId -> Position, which stores all the open margin positions.\n        mapping (bytes32 => MarginCommon.Position) positions;\n\n        // Mapping from positionId -> bool, which stores whether the position has previously been\n        // open, but is now closed.\n        mapping (bytes32 => bool) closedPositions;\n\n        // Mapping from positionId -> uint256, which stores the total amount of owedToken that has\n        // ever been repaid to the lender for each position. Does not reset.\n        mapping (bytes32 => uint256) totalOwedTokenRepaidToLender;\n    }\n}\n\n// File: contracts/margin/interfaces/lender/LoanOwner.sol\n\n/**\n * @title LoanOwner\n * @author dYdX\n *\n * Interface that smart contracts must implement in order to own loans on behalf of other accounts.\n *\n * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\n *       to these functions\n */\ninterface LoanOwner {\n\n    // ============ Public Interface functions ============\n\n    /**\n     * Function a contract must implement in order to receive ownership of a loan sell via the\n     * transferLoan function or the atomic-assign to the \"owner\" field in a loan offering.\n     *\n     * @param  from        Address of the previous owner\n     * @param  positionId  Unique ID of the position\n     * @return             This address to keep ownership, a different address to pass-on ownership\n     */\n    function receiveLoanOwnership(\n        address from,\n        bytes32 positionId\n    )\n        external\n        /* onlyMargin */\n        returns (address);\n}\n\n// File: contracts/margin/interfaces/owner/PositionOwner.sol\n\n/**\n * @title PositionOwner\n * @author dYdX\n *\n * Interface that smart contracts must implement in order to own position on behalf of other\n * accounts\n *\n * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\n *       to these functions\n */\ninterface PositionOwner {\n\n    // ============ Public Interface functions ============\n\n    /**\n     * Function a contract must implement in order to receive ownership of a position via the\n     * transferPosition function or the atomic-assign to the \"owner\" field when opening a position.\n     *\n     * @param  from        Address of the previous owner\n     * @param  positionId  Unique ID of the position\n     * @return             This address to keep ownership, a different address to pass-on ownership\n     */\n    function receivePositionOwnership(\n        address from,\n        bytes32 positionId\n    )\n        external\n        /* onlyMargin */\n        returns (address);\n}\n\n// File: contracts/margin/impl/TransferInternal.sol\n\n/**\n * @title TransferInternal\n * @author dYdX\n *\n * This library contains the implementation for transferring ownership of loans and positions.\n */\nlibrary TransferInternal {\n\n    // ============ Events ============\n\n    /**\n     * Ownership of a loan was transferred to a new address\n     */\n    event LoanTransferred(\n        bytes32 indexed positionId,\n        address indexed from,\n        address indexed to\n    );\n\n    /**\n     * Ownership of a postion was transferred to a new address\n     */\n    event PositionTransferred(\n        bytes32 indexed positionId,\n        address indexed from,\n        address indexed to\n    );\n\n    // ============ Internal Implementation Functions ============\n\n    /**\n     * Returns either the address of the new loan owner, or the address to which they wish to\n     * pass ownership of the loan. This function does not actually set the state of the position\n     *\n     * @param  positionId  The Unique ID of the position\n     * @param  oldOwner    The previous owner of the loan\n     * @param  newOwner    The intended owner of the loan\n     * @return             The address that the intended owner wishes to assign the loan to (may be\n     *                     the same as the intended owner).\n     */\n    function grantLoanOwnership(\n        bytes32 positionId,\n        address oldOwner,\n        address newOwner\n    )\n        internal\n        returns (address)\n    {\n        // log event except upon position creation\n        if (oldOwner != address(0)) {\n            emit LoanTransferred(positionId, oldOwner, newOwner);\n        }\n\n        if (AddressUtils.isContract(newOwner)) {\n            address nextOwner =\n                LoanOwner(newOwner).receiveLoanOwnership(oldOwner, positionId);\n            if (nextOwner != newOwner) {\n                return grantLoanOwnership(positionId, newOwner, nextOwner);\n            }\n        }\n\n        require(\n            newOwner != address(0),\n            \"TransferInternal#grantLoanOwnership: New owner did not consent to owning loan\"\n        );\n\n        return newOwner;\n    }\n\n    /**\n     * Returns either the address of the new position owner, or the address to which they wish to\n     * pass ownership of the position. This function does not actually set the state of the position\n     *\n     * @param  positionId  The Unique ID of the position\n     * @param  oldOwner    The previous owner of the position\n     * @param  newOwner    The intended owner of the position\n     * @return             The address that the intended owner wishes to assign the position to (may\n     *                     be the same as the intended owner).\n     */\n    function grantPositionOwnership(\n        bytes32 positionId,\n        address oldOwner,\n        address newOwner\n    )\n        internal\n        returns (address)\n    {\n        // log event except upon position creation\n        if (oldOwner != address(0)) {\n            emit PositionTransferred(positionId, oldOwner, newOwner);\n        }\n\n        if (AddressUtils.isContract(newOwner)) {\n            address nextOwner =\n                PositionOwner(newOwner).receivePositionOwnership(oldOwner, positionId);\n            if (nextOwner != newOwner) {\n                return grantPositionOwnership(positionId, newOwner, nextOwner);\n            }\n        }\n\n        require(\n            newOwner != address(0),\n            \"TransferInternal#grantPositionOwnership: New owner did not consent to owning position\"\n        );\n\n        return newOwner;\n    }\n}\n\n// File: contracts/lib/TimestampHelper.sol\n\n/**\n * @title TimestampHelper\n * @author dYdX\n *\n * Helper to get block timestamps in other formats\n */\nlibrary TimestampHelper {\n    function getBlockTimestamp32()\n        internal\n        view\n        returns (uint32)\n    {\n        // Should not still be in-use in the year 2106\n        assert(uint256(uint32(block.timestamp)) == block.timestamp);\n\n        assert(block.timestamp > 0);\n\n        return uint32(block.timestamp);\n    }\n}\n\n// File: contracts/margin/impl/MarginCommon.sol\n\n/**\n * @title MarginCommon\n * @author dYdX\n *\n * This library contains common functions for implementations of public facing Margin functions\n */\nlibrary MarginCommon {\n    using SafeMath for uint256;\n\n    // ============ Structs ============\n\n    struct Position {\n        address owedToken;       // Immutable\n        address heldToken;       // Immutable\n        address lender;\n        address owner;\n        uint256 principal;\n        uint256 requiredDeposit;\n        uint32  callTimeLimit;   // Immutable\n        uint32  startTimestamp;  // Immutable, cannot be 0\n        uint32  callTimestamp;\n        uint32  maxDuration;     // Immutable\n        uint32  interestRate;    // Immutable\n        uint32  interestPeriod;  // Immutable\n    }\n\n    struct LoanOffering {\n        address   owedToken;\n        address   heldToken;\n        address   payer;\n        address   owner;\n        address   taker;\n        address   positionOwner;\n        address   feeRecipient;\n        address   lenderFeeToken;\n        address   takerFeeToken;\n        LoanRates rates;\n        uint256   expirationTimestamp;\n        uint32    callTimeLimit;\n        uint32    maxDuration;\n        uint256   salt;\n        bytes32   loanHash;\n        bytes     signature;\n    }\n\n    struct LoanRates {\n        uint256 maxAmount;\n        uint256 minAmount;\n        uint256 minHeldToken;\n        uint256 lenderFee;\n        uint256 takerFee;\n        uint32  interestRate;\n        uint32  interestPeriod;\n    }\n\n    // ============ Internal Implementation Functions ============\n\n    function storeNewPosition(\n        MarginState.State storage state,\n        bytes32 positionId,\n        Position memory position,\n        address loanPayer\n    )\n        internal\n    {\n        assert(!positionHasExisted(state, positionId));\n        assert(position.owedToken != address(0));\n        assert(position.heldToken != address(0));\n        assert(position.owedToken != position.heldToken);\n        assert(position.owner != address(0));\n        assert(position.lender != address(0));\n        assert(position.maxDuration != 0);\n        assert(position.interestPeriod <= position.maxDuration);\n        assert(position.callTimestamp == 0);\n        assert(position.requiredDeposit == 0);\n\n        state.positions[positionId].owedToken = position.owedToken;\n        state.positions[positionId].heldToken = position.heldToken;\n        state.positions[positionId].principal = position.principal;\n        state.positions[positionId].callTimeLimit = position.callTimeLimit;\n        state.positions[positionId].startTimestamp = TimestampHelper.getBlockTimestamp32();\n        state.positions[positionId].maxDuration = position.maxDuration;\n        state.positions[positionId].interestRate = position.interestRate;\n        state.positions[positionId].interestPeriod = position.interestPeriod;\n\n        state.positions[positionId].owner = TransferInternal.grantPositionOwnership(\n            positionId,\n            (position.owner != msg.sender) ? msg.sender : address(0),\n            position.owner\n        );\n\n        state.positions[positionId].lender = TransferInternal.grantLoanOwnership(\n            positionId,\n            (position.lender != loanPayer) ? loanPayer : address(0),\n            position.lender\n        );\n    }\n\n    function getPositionIdFromNonce(\n        uint256 nonce\n    )\n        internal\n        view\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(msg.sender, nonce));\n    }\n\n    function getUnavailableLoanOfferingAmountImpl(\n        MarginState.State storage state,\n        bytes32 loanHash\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        return state.loanFills[loanHash].add(state.loanCancels[loanHash]);\n    }\n\n    function cleanupPosition(\n        MarginState.State storage state,\n        bytes32 positionId\n    )\n        internal\n    {\n        delete state.positions[positionId];\n        state.closedPositions[positionId] = true;\n    }\n\n    function calculateOwedAmount(\n        Position storage position,\n        uint256 closeAmount,\n        uint256 endTimestamp\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 timeElapsed = calculateEffectiveTimeElapsed(position, endTimestamp);\n\n        return InterestImpl.getCompoundedInterest(\n            closeAmount,\n            position.interestRate,\n            timeElapsed\n        );\n    }\n\n    /**\n     * Calculates time elapsed rounded up to the nearest interestPeriod\n     */\n    function calculateEffectiveTimeElapsed(\n        Position storage position,\n        uint256 timestamp\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 elapsed = timestamp.sub(position.startTimestamp);\n\n        // round up to interestPeriod\n        uint256 period = position.interestPeriod;\n        if (period > 1) {\n            elapsed = MathHelpers.divisionRoundedUp(elapsed, period).mul(period);\n        }\n\n        // bound by maxDuration\n        return Math.min256(\n            elapsed,\n            position.maxDuration\n        );\n    }\n\n    function calculateLenderAmountForIncreasePosition(\n        Position storage position,\n        uint256 principalToAdd,\n        uint256 endTimestamp\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 timeElapsed = calculateEffectiveTimeElapsedForNewLender(position, endTimestamp);\n\n        return InterestImpl.getCompoundedInterest(\n            principalToAdd,\n            position.interestRate,\n            timeElapsed\n        );\n    }\n\n    function getLoanOfferingHash(\n        LoanOffering loanOffering\n    )\n        internal\n        view\n        returns (bytes32)\n    {\n        return keccak256(\n            abi.encodePacked(\n                address(this),\n                loanOffering.owedToken,\n                loanOffering.heldToken,\n                loanOffering.payer,\n                loanOffering.owner,\n                loanOffering.taker,\n                loanOffering.positionOwner,\n                loanOffering.feeRecipient,\n                loanOffering.lenderFeeToken,\n                loanOffering.takerFeeToken,\n                getValuesHash(loanOffering)\n            )\n        );\n    }\n\n    function getPositionBalanceImpl(\n        MarginState.State storage state,\n        bytes32 positionId\n    )\n        internal\n        view\n        returns(uint256)\n    {\n        return Vault(state.VAULT).balances(positionId, state.positions[positionId].heldToken);\n    }\n\n    function containsPositionImpl(\n        MarginState.State storage state,\n        bytes32 positionId\n    )\n        internal\n        view\n        returns (bool)\n    {\n        return state.positions[positionId].startTimestamp != 0;\n    }\n\n    function positionHasExisted(\n        MarginState.State storage state,\n        bytes32 positionId\n    )\n        internal\n        view\n        returns (bool)\n    {\n        return containsPositionImpl(state, positionId) || state.closedPositions[positionId];\n    }\n\n    function getPositionFromStorage(\n        MarginState.State storage state,\n        bytes32 positionId\n    )\n        internal\n        view\n        returns (Position storage)\n    {\n        Position storage position = state.positions[positionId];\n\n        require(\n            position.startTimestamp != 0,\n            \"MarginCommon#getPositionFromStorage: The position does not exist\"\n        );\n\n        return position;\n    }\n\n    // ============ Private Helper-Functions ============\n\n    /**\n     * Calculates time elapsed rounded down to the nearest interestPeriod\n     */\n    function calculateEffectiveTimeElapsedForNewLender(\n        Position storage position,\n        uint256 timestamp\n    )\n        private\n        view\n        returns (uint256)\n    {\n        uint256 elapsed = timestamp.sub(position.startTimestamp);\n\n        // round down to interestPeriod\n        uint256 period = position.interestPeriod;\n        if (period > 1) {\n            elapsed = elapsed.div(period).mul(period);\n        }\n\n        // bound by maxDuration\n        return Math.min256(\n            elapsed,\n            position.maxDuration\n        );\n    }\n\n    function getValuesHash(\n        LoanOffering loanOffering\n    )\n        private\n        pure\n        returns (bytes32)\n    {\n        return keccak256(\n            abi.encodePacked(\n                loanOffering.rates.maxAmount,\n                loanOffering.rates.minAmount,\n                loanOffering.rates.minHeldToken,\n                loanOffering.rates.lenderFee,\n                loanOffering.rates.takerFee,\n                loanOffering.expirationTimestamp,\n                loanOffering.salt,\n                loanOffering.callTimeLimit,\n                loanOffering.maxDuration,\n                loanOffering.rates.interestRate,\n                loanOffering.rates.interestPeriod\n            )\n        );\n    }\n}\n\n// File: contracts/margin/interfaces/PayoutRecipient.sol\n\n/**\n * @title PayoutRecipient\n * @author dYdX\n *\n * Interface that smart contracts must implement in order to be the payoutRecipient in a\n * closePosition transaction.\n *\n * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\n *       to these functions\n */\ninterface PayoutRecipient {\n\n    // ============ Public Interface functions ============\n\n    /**\n     * Function a contract must implement in order to receive payout from being the payoutRecipient\n     * in a closePosition transaction. May redistribute any payout as necessary. Throws on error.\n     *\n     * @param  positionId         Unique ID of the position\n     * @param  closeAmount        Amount of the position that was closed\n     * @param  closer             Address of the account or contract that closed the position\n     * @param  positionOwner      Address of the owner of the position\n     * @param  heldToken          Address of the ERC20 heldToken\n     * @param  payout             Number of tokens received from the payout\n     * @param  totalHeldToken     Total amount of heldToken removed from vault during close\n     * @param  payoutInHeldToken  True if payout is in heldToken, false if in owedToken\n     * @return                    True if approved by the receiver\n     */\n    function receiveClosePositionPayout(\n        bytes32 positionId,\n        uint256 closeAmount,\n        address closer,\n        address positionOwner,\n        address heldToken,\n        uint256 payout,\n        uint256 totalHeldToken,\n        bool    payoutInHeldToken\n    )\n        external\n        /* onlyMargin */\n        returns (bool);\n}\n\n// File: contracts/margin/interfaces/lender/CloseLoanDelegator.sol\n\n/**\n * @title CloseLoanDelegator\n * @author dYdX\n *\n * Interface that smart contracts must implement in order to let other addresses close a loan\n * owned by the smart contract.\n *\n * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\n *       to these functions\n */\ninterface CloseLoanDelegator {\n\n    // ============ Public Interface functions ============\n\n    /**\n     * Function a contract must implement in order to let other addresses call\n     * closeWithoutCounterparty().\n     *\n     * NOTE: If not returning zero (or not reverting), this contract must assume that Margin will\n     * either revert the entire transaction or that (at most) the specified amount of the loan was\n     * successfully closed.\n     *\n     * @param  closer           Address of the caller of closeWithoutCounterparty()\n     * @param  payoutRecipient  Address of the recipient of tokens paid out from closing\n     * @param  positionId       Unique ID of the position\n     * @param  requestedAmount  Requested principal amount of the loan to close\n     * @return                  1) This address to accept, a different address to ask that contract\n     *                          2) The maximum amount that this contract is allowing\n     */\n    function closeLoanOnBehalfOf(\n        address closer,\n        address payoutRecipient,\n        bytes32 positionId,\n        uint256 requestedAmount\n    )\n        external\n        /* onlyMargin */\n        returns (address, uint256);\n}\n\n// File: contracts/margin/interfaces/owner/ClosePositionDelegator.sol\n\n/**\n * @title ClosePositionDelegator\n * @author dYdX\n *\n * Interface that smart contracts must implement in order to let other addresses close a position\n * owned by the smart contract, allowing more complex logic to control positions.\n *\n * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\n *       to these functions\n */\ninterface ClosePositionDelegator {\n\n    // ============ Public Interface functions ============\n\n    /**\n     * Function a contract must implement in order to let other addresses call closePosition().\n     *\n     * NOTE: If not returning zero (or not reverting), this contract must assume that Margin will\n     * either revert the entire transaction or that (at-most) the specified amount of the position\n     * was successfully closed.\n     *\n     * @param  closer           Address of the caller of the closePosition() function\n     * @param  payoutRecipient  Address of the recipient of tokens paid out from closing\n     * @param  positionId       Unique ID of the position\n     * @param  requestedAmount  Requested principal amount of the position to close\n     * @return                  1) This address to accept, a different address to ask that contract\n     *                          2) The maximum amount that this contract is allowing\n     */\n    function closeOnBehalfOf(\n        address closer,\n        address payoutRecipient,\n        bytes32 positionId,\n        uint256 requestedAmount\n    )\n        external\n        /* onlyMargin */\n        returns (address, uint256);\n}\n\n// File: contracts/margin/impl/ClosePositionShared.sol\n\n/**\n * @title ClosePositionShared\n * @author dYdX\n *\n * This library contains shared functionality between ClosePositionImpl and\n * CloseWithoutCounterpartyImpl\n */\nlibrary ClosePositionShared {\n    using SafeMath for uint256;\n\n    // ============ Structs ============\n\n    struct CloseTx {\n        bytes32 positionId;\n        uint256 originalPrincipal;\n        uint256 closeAmount;\n        uint256 owedTokenOwed;\n        uint256 startingHeldTokenBalance;\n        uint256 availableHeldToken;\n        address payoutRecipient;\n        address owedToken;\n        address heldToken;\n        address positionOwner;\n        address positionLender;\n        address exchangeWrapper;\n        bool    payoutInHeldToken;\n    }\n\n    // ============ Internal Implementation Functions ============\n\n    function closePositionStateUpdate(\n        MarginState.State storage state,\n        CloseTx memory transaction\n    )\n        internal\n    {\n        // Delete the position, or just decrease the principal\n        if (transaction.closeAmount == transaction.originalPrincipal) {\n            MarginCommon.cleanupPosition(state, transaction.positionId);\n        } else {\n            assert(\n                transaction.originalPrincipal == state.positions[transaction.positionId].principal\n            );\n            state.positions[transaction.positionId].principal =\n                transaction.originalPrincipal.sub(transaction.closeAmount);\n        }\n    }\n\n    function sendTokensToPayoutRecipient(\n        MarginState.State storage state,\n        ClosePositionShared.CloseTx memory transaction,\n        uint256 buybackCostInHeldToken,\n        uint256 receivedOwedToken\n    )\n        internal\n        returns (uint256)\n    {\n        uint256 payout;\n\n        if (transaction.payoutInHeldToken) {\n            // Send remaining heldToken to payoutRecipient\n            payout = transaction.availableHeldToken.sub(buybackCostInHeldToken);\n\n            Vault(state.VAULT).transferFromVault(\n                transaction.positionId,\n                transaction.heldToken,\n                transaction.payoutRecipient,\n                payout\n            );\n        } else {\n            assert(transaction.exchangeWrapper != address(0));\n\n            payout = receivedOwedToken.sub(transaction.owedTokenOwed);\n\n            TokenProxy(state.TOKEN_PROXY).transferTokens(\n                transaction.owedToken,\n                transaction.exchangeWrapper,\n                transaction.payoutRecipient,\n                payout\n            );\n        }\n\n        if (AddressUtils.isContract(transaction.payoutRecipient)) {\n            require(\n                PayoutRecipient(transaction.payoutRecipient).receiveClosePositionPayout(\n                    transaction.positionId,\n                    transaction.closeAmount,\n                    msg.sender,\n                    transaction.positionOwner,\n                    transaction.heldToken,\n                    payout,\n                    transaction.availableHeldToken,\n                    transaction.payoutInHeldToken\n                ),\n                \"ClosePositionShared#sendTokensToPayoutRecipient: Payout recipient does not consent\"\n            );\n        }\n\n        // The ending heldToken balance of the vault should be the starting heldToken balance\n        // minus the available heldToken amount\n        assert(\n            MarginCommon.getPositionBalanceImpl(state, transaction.positionId)\n            == transaction.startingHeldTokenBalance.sub(transaction.availableHeldToken)\n        );\n\n        return payout;\n    }\n\n    function createCloseTx(\n        MarginState.State storage state,\n        bytes32 positionId,\n        uint256 requestedAmount,\n        address payoutRecipient,\n        address exchangeWrapper,\n        bool payoutInHeldToken,\n        bool isWithoutCounterparty\n    )\n        internal\n        returns (CloseTx memory)\n    {\n        // Validate\n        require(\n            payoutRecipient != address(0),\n            \"ClosePositionShared#createCloseTx: Payout recipient cannot be 0\"\n        );\n        require(\n            requestedAmount > 0,\n            \"ClosePositionShared#createCloseTx: Requested close amount cannot be 0\"\n        );\n\n        MarginCommon.Position storage position =\n            MarginCommon.getPositionFromStorage(state, positionId);\n\n        uint256 closeAmount = getApprovedAmount(\n            position,\n            positionId,\n            requestedAmount,\n            payoutRecipient,\n            isWithoutCounterparty\n        );\n\n        return parseCloseTx(\n            state,\n            position,\n            positionId,\n            closeAmount,\n            payoutRecipient,\n            exchangeWrapper,\n            payoutInHeldToken,\n            isWithoutCounterparty\n        );\n    }\n\n    // ============ Private Helper-Functions ============\n\n    function getApprovedAmount(\n        MarginCommon.Position storage position,\n        bytes32 positionId,\n        uint256 requestedAmount,\n        address payoutRecipient,\n        bool requireLenderApproval\n    )\n        private\n        returns (uint256)\n    {\n        // Ensure enough principal\n        uint256 allowedAmount = Math.min256(requestedAmount, position.principal);\n\n        // Ensure owner consent\n        allowedAmount = closePositionOnBehalfOfRecurse(\n            position.owner,\n            msg.sender,\n            payoutRecipient,\n            positionId,\n            allowedAmount\n        );\n\n        // Ensure lender consent\n        if (requireLenderApproval) {\n            allowedAmount = closeLoanOnBehalfOfRecurse(\n                position.lender,\n                msg.sender,\n                payoutRecipient,\n                positionId,\n                allowedAmount\n            );\n        }\n\n        assert(allowedAmount > 0);\n        assert(allowedAmount <= position.principal);\n        assert(allowedAmount <= requestedAmount);\n\n        return allowedAmount;\n    }\n\n    function closePositionOnBehalfOfRecurse(\n        address contractAddr,\n        address closer,\n        address payoutRecipient,\n        bytes32 positionId,\n        uint256 closeAmount\n    )\n        private\n        returns (uint256)\n    {\n        // no need to ask for permission\n        if (closer == contractAddr) {\n            return closeAmount;\n        }\n\n        (\n            address newContractAddr,\n            uint256 newCloseAmount\n        ) = ClosePositionDelegator(contractAddr).closeOnBehalfOf(\n            closer,\n            payoutRecipient,\n            positionId,\n            closeAmount\n        );\n\n        require(\n            newCloseAmount <= closeAmount,\n            \"ClosePositionShared#closePositionRecurse: newCloseAmount is greater than closeAmount\"\n        );\n        require(\n            newCloseAmount > 0,\n            \"ClosePositionShared#closePositionRecurse: newCloseAmount is zero\"\n        );\n\n        if (newContractAddr != contractAddr) {\n            closePositionOnBehalfOfRecurse(\n                newContractAddr,\n                closer,\n                payoutRecipient,\n                positionId,\n                newCloseAmount\n            );\n        }\n\n        return newCloseAmount;\n    }\n\n    function closeLoanOnBehalfOfRecurse(\n        address contractAddr,\n        address closer,\n        address payoutRecipient,\n        bytes32 positionId,\n        uint256 closeAmount\n    )\n        private\n        returns (uint256)\n    {\n        // no need to ask for permission\n        if (closer == contractAddr) {\n            return closeAmount;\n        }\n\n        (\n            address newContractAddr,\n            uint256 newCloseAmount\n        ) = CloseLoanDelegator(contractAddr).closeLoanOnBehalfOf(\n                closer,\n                payoutRecipient,\n                positionId,\n                closeAmount\n            );\n\n        require(\n            newCloseAmount <= closeAmount,\n            \"ClosePositionShared#closeLoanRecurse: newCloseAmount is greater than closeAmount\"\n        );\n        require(\n            newCloseAmount > 0,\n            \"ClosePositionShared#closeLoanRecurse: newCloseAmount is zero\"\n        );\n\n        if (newContractAddr != contractAddr) {\n            closeLoanOnBehalfOfRecurse(\n                newContractAddr,\n                closer,\n                payoutRecipient,\n                positionId,\n                newCloseAmount\n            );\n        }\n\n        return newCloseAmount;\n    }\n\n    // ============ Parsing Functions ============\n\n    function parseCloseTx(\n        MarginState.State storage state,\n        MarginCommon.Position storage position,\n        bytes32 positionId,\n        uint256 closeAmount,\n        address payoutRecipient,\n        address exchangeWrapper,\n        bool payoutInHeldToken,\n        bool isWithoutCounterparty\n    )\n        private\n        view\n        returns (CloseTx memory)\n    {\n        uint256 startingHeldTokenBalance = MarginCommon.getPositionBalanceImpl(state, positionId);\n\n        uint256 availableHeldToken = MathHelpers.getPartialAmount(\n            closeAmount,\n            position.principal,\n            startingHeldTokenBalance\n        );\n        uint256 owedTokenOwed = 0;\n\n        if (!isWithoutCounterparty) {\n            owedTokenOwed = MarginCommon.calculateOwedAmount(\n                position,\n                closeAmount,\n                block.timestamp\n            );\n        }\n\n        return CloseTx({\n            positionId: positionId,\n            originalPrincipal: position.principal,\n            closeAmount: closeAmount,\n            owedTokenOwed: owedTokenOwed,\n            startingHeldTokenBalance: startingHeldTokenBalance,\n            availableHeldToken: availableHeldToken,\n            payoutRecipient: payoutRecipient,\n            owedToken: position.owedToken,\n            heldToken: position.heldToken,\n            positionOwner: position.owner,\n            positionLender: position.lender,\n            exchangeWrapper: exchangeWrapper,\n            payoutInHeldToken: payoutInHeldToken\n        });\n    }\n}\n\n// File: contracts/margin/interfaces/ExchangeWrapper.sol\n\n/**\n * @title ExchangeWrapper\n * @author dYdX\n *\n * Contract interface that Exchange Wrapper smart contracts must implement in order to interface\n * with other smart contracts through a common interface.\n */\ninterface ExchangeWrapper {\n\n    // ============ Public Functions ============\n\n    /**\n     * Exchange some amount of takerToken for makerToken.\n     *\n     * @param  tradeOriginator      Address of the initiator of the trade (however, this value\n     *                              cannot always be trusted as it is set at the discretion of the\n     *                              msg.sender)\n     * @param  receiver             Address to set allowance on once the trade has completed\n     * @param  makerToken           Address of makerToken, the token to receive\n     * @param  takerToken           Address of takerToken, the token to pay\n     * @param  requestedFillAmount  Amount of takerToken being paid\n     * @param  orderData            Arbitrary bytes data for any information to pass to the exchange\n     * @return                      The amount of makerToken received\n     */\n    function exchange(\n        address tradeOriginator,\n        address receiver,\n        address makerToken,\n        address takerToken,\n        uint256 requestedFillAmount,\n        bytes orderData\n    )\n        external\n        returns (uint256);\n\n    /**\n     * Get amount of takerToken required to buy a certain amount of makerToken for a given trade.\n     * Should match the takerToken amount used in exchangeForAmount. If the order cannot provide\n     * exactly desiredMakerToken, then it must return the price to buy the minimum amount greater\n     * than desiredMakerToken\n     *\n     * @param  makerToken         Address of makerToken, the token to receive\n     * @param  takerToken         Address of takerToken, the token to pay\n     * @param  desiredMakerToken  Amount of makerToken requested\n     * @param  orderData          Arbitrary bytes data for any information to pass to the exchange\n     * @return                    Amount of takerToken the needed to complete the transaction\n     */\n    function getExchangeCost(\n        address makerToken,\n        address takerToken,\n        uint256 desiredMakerToken,\n        bytes orderData\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// File: contracts/margin/impl/ClosePositionImpl.sol\n\n/**\n * @title ClosePositionImpl\n * @author dYdX\n *\n * This library contains the implementation for the closePosition function of Margin\n */\nlibrary ClosePositionImpl {\n    using SafeMath for uint256;\n\n    // ============ Events ============\n\n    /**\n     * A position was closed or partially closed\n     */\n    event PositionClosed(\n        bytes32 indexed positionId,\n        address indexed closer,\n        address indexed payoutRecipient,\n        uint256 closeAmount,\n        uint256 remainingAmount,\n        uint256 owedTokenPaidToLender,\n        uint256 payoutAmount,\n        uint256 buybackCostInHeldToken,\n        bool    payoutInHeldToken\n    );\n\n    // ============ Public Implementation Functions ============\n\n    function closePositionImpl(\n        MarginState.State storage state,\n        bytes32 positionId,\n        uint256 requestedCloseAmount,\n        address payoutRecipient,\n        address exchangeWrapper,\n        bool payoutInHeldToken,\n        bytes memory orderData\n    )\n        public\n        returns (uint256, uint256, uint256)\n    {\n        ClosePositionShared.CloseTx memory transaction = ClosePositionShared.createCloseTx(\n            state,\n            positionId,\n            requestedCloseAmount,\n            payoutRecipient,\n            exchangeWrapper,\n            payoutInHeldToken,\n            false\n        );\n\n        (\n            uint256 buybackCostInHeldToken,\n            uint256 receivedOwedToken\n        ) = returnOwedTokensToLender(\n            state,\n            transaction,\n            orderData\n        );\n\n        uint256 payout = ClosePositionShared.sendTokensToPayoutRecipient(\n            state,\n            transaction,\n            buybackCostInHeldToken,\n            receivedOwedToken\n        );\n\n        ClosePositionShared.closePositionStateUpdate(state, transaction);\n\n        logEventOnClose(\n            transaction,\n            buybackCostInHeldToken,\n            payout\n        );\n\n        return (\n            transaction.closeAmount,\n            payout,\n            transaction.owedTokenOwed\n        );\n    }\n\n    // ============ Private Helper-Functions ============\n\n    function returnOwedTokensToLender(\n        MarginState.State storage state,\n        ClosePositionShared.CloseTx memory transaction,\n        bytes memory orderData\n    )\n        private\n        returns (uint256, uint256)\n    {\n        uint256 buybackCostInHeldToken = 0;\n        uint256 receivedOwedToken = 0;\n        uint256 lenderOwedToken = transaction.owedTokenOwed;\n\n        // Setting exchangeWrapper to 0x000... indicates owedToken should be taken directly\n        // from msg.sender\n        if (transaction.exchangeWrapper == address(0)) {\n            require(\n                transaction.payoutInHeldToken,\n                \"ClosePositionImpl#returnOwedTokensToLender: Cannot payout in owedToken\"\n            );\n\n            // No DEX Order; send owedTokens directly from the closer to the lender\n            TokenProxy(state.TOKEN_PROXY).transferTokens(\n                transaction.owedToken,\n                msg.sender,\n                transaction.positionLender,\n                lenderOwedToken\n            );\n        } else {\n            // Buy back owedTokens using DEX Order and send to lender\n            (buybackCostInHeldToken, receivedOwedToken) = buyBackOwedToken(\n                state,\n                transaction,\n                orderData\n            );\n\n            // If no owedToken needed for payout: give lender all owedToken, even if more than owed\n            if (transaction.payoutInHeldToken) {\n                assert(receivedOwedToken >= lenderOwedToken);\n                lenderOwedToken = receivedOwedToken;\n            }\n\n            // Transfer owedToken from the exchange wrapper to the lender\n            TokenProxy(state.TOKEN_PROXY).transferTokens(\n                transaction.owedToken,\n                transaction.exchangeWrapper,\n                transaction.positionLender,\n                lenderOwedToken\n            );\n        }\n\n        state.totalOwedTokenRepaidToLender[transaction.positionId] =\n            state.totalOwedTokenRepaidToLender[transaction.positionId].add(lenderOwedToken);\n\n        return (buybackCostInHeldToken, receivedOwedToken);\n    }\n\n    function buyBackOwedToken(\n        MarginState.State storage state,\n        ClosePositionShared.CloseTx transaction,\n        bytes memory orderData\n    )\n        private\n        returns (uint256, uint256)\n    {\n        // Ask the exchange wrapper the cost in heldToken to buy back the close\n        // amount of owedToken\n        uint256 buybackCostInHeldToken;\n\n        if (transaction.payoutInHeldToken) {\n            buybackCostInHeldToken = ExchangeWrapper(transaction.exchangeWrapper)\n                .getExchangeCost(\n                    transaction.owedToken,\n                    transaction.heldToken,\n                    transaction.owedTokenOwed,\n                    orderData\n                );\n\n            // Require enough available heldToken to pay for the buyback\n            require(\n                buybackCostInHeldToken <= transaction.availableHeldToken,\n                \"ClosePositionImpl#buyBackOwedToken: Not enough available heldToken\"\n            );\n        } else {\n            buybackCostInHeldToken = transaction.availableHeldToken;\n        }\n\n        // Send the requisite heldToken to do the buyback from vault to exchange wrapper\n        Vault(state.VAULT).transferFromVault(\n            transaction.positionId,\n            transaction.heldToken,\n            transaction.exchangeWrapper,\n            buybackCostInHeldToken\n        );\n\n        // Trade the heldToken for the owedToken\n        uint256 receivedOwedToken = ExchangeWrapper(transaction.exchangeWrapper).exchange(\n            msg.sender,\n            state.TOKEN_PROXY,\n            transaction.owedToken,\n            transaction.heldToken,\n            buybackCostInHeldToken,\n            orderData\n        );\n\n        require(\n            receivedOwedToken >= transaction.owedTokenOwed,\n            \"ClosePositionImpl#buyBackOwedToken: Did not receive enough owedToken\"\n        );\n\n        return (buybackCostInHeldToken, receivedOwedToken);\n    }\n\n    function logEventOnClose(\n        ClosePositionShared.CloseTx transaction,\n        uint256 buybackCostInHeldToken,\n        uint256 payout\n    )\n        private\n    {\n        emit PositionClosed(\n            transaction.positionId,\n            msg.sender,\n            transaction.payoutRecipient,\n            transaction.closeAmount,\n            transaction.originalPrincipal.sub(transaction.closeAmount),\n            transaction.owedTokenOwed,\n            payout,\n            buybackCostInHeldToken,\n            transaction.payoutInHeldToken\n        );\n    }\n\n}\n\n// File: contracts/margin/impl/CloseWithoutCounterpartyImpl.sol\n\n/**\n * @title CloseWithoutCounterpartyImpl\n * @author dYdX\n *\n * This library contains the implementation for the closeWithoutCounterpartyImpl function of\n * Margin\n */\nlibrary CloseWithoutCounterpartyImpl {\n    using SafeMath for uint256;\n\n    // ============ Events ============\n\n    /**\n     * A position was closed or partially closed\n     */\n    event PositionClosed(\n        bytes32 indexed positionId,\n        address indexed closer,\n        address indexed payoutRecipient,\n        uint256 closeAmount,\n        uint256 remainingAmount,\n        uint256 owedTokenPaidToLender,\n        uint256 payoutAmount,\n        uint256 buybackCostInHeldToken,\n        bool payoutInHeldToken\n    );\n\n    // ============ Public Implementation Functions ============\n\n    function closeWithoutCounterpartyImpl(\n        MarginState.State storage state,\n        bytes32 positionId,\n        uint256 requestedCloseAmount,\n        address payoutRecipient\n    )\n        public\n        returns (uint256, uint256)\n    {\n        ClosePositionShared.CloseTx memory transaction = ClosePositionShared.createCloseTx(\n            state,\n            positionId,\n            requestedCloseAmount,\n            payoutRecipient,\n            address(0),\n            true,\n            true\n        );\n\n        uint256 heldTokenPayout = ClosePositionShared.sendTokensToPayoutRecipient(\n            state,\n            transaction,\n            0, // No buyback cost\n            0  // Did not receive any owedToken\n        );\n\n        ClosePositionShared.closePositionStateUpdate(state, transaction);\n\n        logEventOnCloseWithoutCounterparty(transaction);\n\n        return (\n            transaction.closeAmount,\n            heldTokenPayout\n        );\n    }\n\n    // ============ Private Helper-Functions ============\n\n    function logEventOnCloseWithoutCounterparty(\n        ClosePositionShared.CloseTx transaction\n    )\n        private\n    {\n        emit PositionClosed(\n            transaction.positionId,\n            msg.sender,\n            transaction.payoutRecipient,\n            transaction.closeAmount,\n            transaction.originalPrincipal.sub(transaction.closeAmount),\n            0,\n            transaction.availableHeldToken,\n            0,\n            true\n        );\n    }\n}\n\n// File: contracts/margin/interfaces/owner/DepositCollateralDelegator.sol\n\n/**\n * @title DepositCollateralDelegator\n * @author dYdX\n *\n * Interface that smart contracts must implement in order to let other addresses deposit heldTokens\n * into a position owned by the smart contract.\n *\n * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\n *       to these functions\n */\ninterface DepositCollateralDelegator {\n\n    // ============ Public Interface functions ============\n\n    /**\n     * Function a contract must implement in order to let other addresses call depositCollateral().\n     *\n     * @param  depositor   Address of the caller of the depositCollateral() function\n     * @param  positionId  Unique ID of the position\n     * @param  amount      Requested deposit amount\n     * @return             This address to accept, a different address to ask that contract\n     */\n    function depositCollateralOnBehalfOf(\n        address depositor,\n        bytes32 positionId,\n        uint256 amount\n    )\n        external\n        /* onlyMargin */\n        returns (address);\n}\n\n// File: contracts/margin/impl/DepositCollateralImpl.sol\n\n/**\n * @title DepositCollateralImpl\n * @author dYdX\n *\n * This library contains the implementation for the deposit function of Margin\n */\nlibrary DepositCollateralImpl {\n    using SafeMath for uint256;\n\n    // ============ Events ============\n\n    /**\n     * Additional collateral for a position was posted by the owner\n     */\n    event AdditionalCollateralDeposited(\n        bytes32 indexed positionId,\n        uint256 amount,\n        address depositor\n    );\n\n    /**\n     * A margin call was canceled\n     */\n    event MarginCallCanceled(\n        bytes32 indexed positionId,\n        address indexed lender,\n        address indexed owner,\n        uint256 depositAmount\n    );\n\n    // ============ Public Implementation Functions ============\n\n    function depositCollateralImpl(\n        MarginState.State storage state,\n        bytes32 positionId,\n        uint256 depositAmount\n    )\n        public\n    {\n        MarginCommon.Position storage position =\n            MarginCommon.getPositionFromStorage(state, positionId);\n\n        require(\n            depositAmount > 0,\n            \"DepositCollateralImpl#depositCollateralImpl: Deposit amount cannot be 0\"\n        );\n\n        // Ensure owner consent\n        depositCollateralOnBehalfOfRecurse(\n            position.owner,\n            msg.sender,\n            positionId,\n            depositAmount\n        );\n\n        Vault(state.VAULT).transferToVault(\n            positionId,\n            position.heldToken,\n            msg.sender,\n            depositAmount\n        );\n\n        // cancel margin call if applicable\n        bool marginCallCanceled = false;\n        uint256 requiredDeposit = position.requiredDeposit;\n        if (position.callTimestamp > 0 && requiredDeposit > 0) {\n            if (depositAmount >= requiredDeposit) {\n                position.requiredDeposit = 0;\n                position.callTimestamp = 0;\n                marginCallCanceled = true;\n            } else {\n                position.requiredDeposit = position.requiredDeposit.sub(depositAmount);\n            }\n        }\n\n        emit AdditionalCollateralDeposited(\n            positionId,\n            depositAmount,\n            msg.sender\n        );\n\n        if (marginCallCanceled) {\n            emit MarginCallCanceled(\n                positionId,\n                position.lender,\n                msg.sender,\n                depositAmount\n            );\n        }\n    }\n\n    // ============ Private Helper-Functions ============\n\n    function depositCollateralOnBehalfOfRecurse(\n        address contractAddr,\n        address depositor,\n        bytes32 positionId,\n        uint256 amount\n    )\n        private\n    {\n        // no need to ask for permission\n        if (depositor == contractAddr) {\n            return;\n        }\n\n        address newContractAddr =\n            DepositCollateralDelegator(contractAddr).depositCollateralOnBehalfOf(\n                depositor,\n                positionId,\n                amount\n            );\n\n        // if not equal, recurse\n        if (newContractAddr != contractAddr) {\n            depositCollateralOnBehalfOfRecurse(\n                newContractAddr,\n                depositor,\n                positionId,\n                amount\n            );\n        }\n    }\n}\n\n// File: contracts/margin/interfaces/lender/ForceRecoverCollateralDelegator.sol\n\n/**\n * @title ForceRecoverCollateralDelegator\n * @author dYdX\n *\n * Interface that smart contracts must implement in order to let other addresses\n * forceRecoverCollateral() a loan owned by the smart contract.\n *\n * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\n *       to these functions\n */\ninterface ForceRecoverCollateralDelegator {\n\n    // ============ Public Interface functions ============\n\n    /**\n     * Function a contract must implement in order to let other addresses call\n     * forceRecoverCollateral().\n     *\n     * NOTE: If not returning zero address (or not reverting), this contract must assume that Margin\n     * will either revert the entire transaction or that the collateral was forcibly recovered.\n     *\n     * @param  recoverer   Address of the caller of the forceRecoverCollateral() function\n     * @param  positionId  Unique ID of the position\n     * @param  recipient   Address to send the recovered tokens to\n     * @return             This address to accept, a different address to ask that contract\n     */\n    function forceRecoverCollateralOnBehalfOf(\n        address recoverer,\n        bytes32 positionId,\n        address recipient\n    )\n        external\n        /* onlyMargin */\n        returns (address);\n}\n\n// File: contracts/margin/impl/ForceRecoverCollateralImpl.sol\n\n/* solium-disable-next-line max-len*/\n\n/**\n * @title ForceRecoverCollateralImpl\n * @author dYdX\n *\n * This library contains the implementation for the forceRecoverCollateral function of Margin\n */\nlibrary ForceRecoverCollateralImpl {\n    using SafeMath for uint256;\n\n    // ============ Events ============\n\n    /**\n     * Collateral for a position was forcibly recovered\n     */\n    event CollateralForceRecovered(\n        bytes32 indexed positionId,\n        address indexed recipient,\n        uint256 amount\n    );\n\n    // ============ Public Implementation Functions ============\n\n    function forceRecoverCollateralImpl(\n        MarginState.State storage state,\n        bytes32 positionId,\n        address recipient\n    )\n        public\n        returns (uint256)\n    {\n        MarginCommon.Position storage position =\n            MarginCommon.getPositionFromStorage(state, positionId);\n\n        // Can only force recover after either:\n        // 1) The loan was called and the call period has elapsed\n        // 2) The maxDuration of the position has elapsed\n        require( /* solium-disable-next-line */\n            (\n                position.callTimestamp > 0\n                && block.timestamp >= uint256(position.callTimestamp).add(position.callTimeLimit)\n            ) || (\n                block.timestamp >= uint256(position.startTimestamp).add(position.maxDuration)\n            ),\n            \"ForceRecoverCollateralImpl#forceRecoverCollateralImpl: Cannot recover yet\"\n        );\n\n        // Ensure lender consent\n        forceRecoverCollateralOnBehalfOfRecurse(\n            position.lender,\n            msg.sender,\n            positionId,\n            recipient\n        );\n\n        // Send the tokens\n        uint256 heldTokenRecovered = MarginCommon.getPositionBalanceImpl(state, positionId);\n        Vault(state.VAULT).transferFromVault(\n            positionId,\n            position.heldToken,\n            recipient,\n            heldTokenRecovered\n        );\n\n        // Delete the position\n        // NOTE: Since position is a storage pointer, this will also set all fields on\n        //       the position variable to 0\n        MarginCommon.cleanupPosition(\n            state,\n            positionId\n        );\n\n        // Log an event\n        emit CollateralForceRecovered(\n            positionId,\n            recipient,\n            heldTokenRecovered\n        );\n\n        return heldTokenRecovered;\n    }\n\n    // ============ Private Helper-Functions ============\n\n    function forceRecoverCollateralOnBehalfOfRecurse(\n        address contractAddr,\n        address recoverer,\n        bytes32 positionId,\n        address recipient\n    )\n        private\n    {\n        // no need to ask for permission\n        if (recoverer == contractAddr) {\n            return;\n        }\n\n        address newContractAddr =\n            ForceRecoverCollateralDelegator(contractAddr).forceRecoverCollateralOnBehalfOf(\n                recoverer,\n                positionId,\n                recipient\n            );\n\n        if (newContractAddr != contractAddr) {\n            forceRecoverCollateralOnBehalfOfRecurse(\n                newContractAddr,\n                recoverer,\n                positionId,\n                recipient\n            );\n        }\n    }\n}\n\n// File: contracts/lib/TypedSignature.sol\n\n/**\n * @title TypedSignature\n * @author dYdX\n *\n * Allows for ecrecovery of signed hashes with three different prepended messages:\n * 1) \"\"\n * 2) \"\\x19Ethereum Signed Message:\\n32\"\n * 3) \"\\x19Ethereum Signed Message:\\n\\x20\"\n */\nlibrary TypedSignature {\n\n    // Solidity does not offer guarantees about enum values, so we define them explicitly\n    uint8 private constant SIGTYPE_INVALID = 0;\n    uint8 private constant SIGTYPE_ECRECOVER_DEC = 1;\n    uint8 private constant SIGTYPE_ECRECOVER_HEX = 2;\n    uint8 private constant SIGTYPE_UNSUPPORTED = 3;\n\n    // prepended message with the length of the signed hash in hexadecimal\n    bytes constant private PREPEND_HEX = \"\\x19Ethereum Signed Message:\\n\\x20\";\n\n    // prepended message with the length of the signed hash in decimal\n    bytes constant private PREPEND_DEC = \"\\x19Ethereum Signed Message:\\n32\";\n\n    /**\n     * Gives the address of the signer of a hash. Allows for three common prepended strings.\n     *\n     * @param  hash               Hash that was signed (does not include prepended message)\n     * @param  signatureWithType  Type and ECDSA signature with structure: {1:type}{1:v}{32:r}{32:s}\n     * @return                    address of the signer of the hash\n     */\n    function recover(\n        bytes32 hash,\n        bytes signatureWithType\n    )\n        internal\n        pure\n        returns (address)\n    {\n        require(\n            signatureWithType.length == 66,\n            \"SignatureValidator#validateSignature: invalid signature length\"\n        );\n\n        uint8 sigType = uint8(signatureWithType[0]);\n\n        require(\n            sigType > uint8(SIGTYPE_INVALID),\n            \"SignatureValidator#validateSignature: invalid signature type\"\n        );\n        require(\n            sigType < uint8(SIGTYPE_UNSUPPORTED),\n            \"SignatureValidator#validateSignature: unsupported signature type\"\n        );\n\n        uint8 v = uint8(signatureWithType[1]);\n        bytes32 r;\n        bytes32 s;\n\n        /* solium-disable-next-line security/no-inline-assembly */\n        assembly {\n            r := mload(add(signatureWithType, 34))\n            s := mload(add(signatureWithType, 66))\n        }\n\n        bytes32 signedHash;\n        if (sigType == SIGTYPE_ECRECOVER_DEC) {\n            signedHash = keccak256(abi.encodePacked(PREPEND_DEC, hash));\n        } else {\n            assert(sigType == SIGTYPE_ECRECOVER_HEX);\n            signedHash = keccak256(abi.encodePacked(PREPEND_HEX, hash));\n        }\n\n        return ecrecover(\n            signedHash,\n            v,\n            r,\n            s\n        );\n    }\n}\n\n// File: contracts/margin/interfaces/LoanOfferingVerifier.sol\n\n/**\n * @title LoanOfferingVerifier\n * @author dYdX\n *\n * Interface that smart contracts must implement to be able to make off-chain generated\n * loan offerings.\n *\n * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\n *       to these functions\n */\ninterface LoanOfferingVerifier {\n\n    /**\n     * Function a smart contract must implement to be able to consent to a loan. The loan offering\n     * will be generated off-chain. The \"loan owner\" address will own the loan-side of the resulting\n     * position.\n     *\n     * If true is returned, and no errors are thrown by the Margin contract, the loan will have\n     * occurred. This means that verifyLoanOffering can also be used to update internal contract\n     * state on a loan.\n     *\n     * @param  addresses    Array of addresses:\n     *\n     *  [0] = owedToken\n     *  [1] = heldToken\n     *  [2] = loan payer\n     *  [3] = loan owner\n     *  [4] = loan taker\n     *  [5] = loan positionOwner\n     *  [6] = loan fee recipient\n     *  [7] = loan lender fee token\n     *  [8] = loan taker fee token\n     *\n     * @param  values256    Values corresponding to:\n     *\n     *  [0] = loan maximum amount\n     *  [1] = loan minimum amount\n     *  [2] = loan minimum heldToken\n     *  [3] = loan lender fee\n     *  [4] = loan taker fee\n     *  [5] = loan expiration timestamp (in seconds)\n     *  [6] = loan salt\n     *\n     * @param  values32     Values corresponding to:\n     *\n     *  [0] = loan call time limit (in seconds)\n     *  [1] = loan maxDuration (in seconds)\n     *  [2] = loan interest rate (annual nominal percentage times 10**6)\n     *  [3] = loan interest update period (in seconds)\n     *\n     * @param  positionId   Unique ID of the position\n     * @param  signature    Arbitrary bytes; may or may not be an ECDSA signature\n     * @return              This address to accept, a different address to ask that contract\n     */\n    function verifyLoanOffering(\n        address[9] addresses,\n        uint256[7] values256,\n        uint32[4] values32,\n        bytes32 positionId,\n        bytes signature\n    )\n        external\n        /* onlyMargin */\n        returns (address);\n}\n\n// File: contracts/margin/impl/BorrowShared.sol\n\n/**\n * @title BorrowShared\n * @author dYdX\n *\n * This library contains shared functionality between OpenPositionImpl and IncreasePositionImpl.\n * Both use a Loan Offering and a DEX Order to open or increase a position.\n */\nlibrary BorrowShared {\n    using SafeMath for uint256;\n\n    // ============ Structs ============\n\n    struct Tx {\n        bytes32 positionId;\n        address owner;\n        uint256 principal;\n        uint256 lenderAmount;\n        MarginCommon.LoanOffering loanOffering;\n        address exchangeWrapper;\n        bool depositInHeldToken;\n        uint256 depositAmount;\n        uint256 collateralAmount;\n        uint256 heldTokenFromSell;\n    }\n\n    // ============ Internal Implementation Functions ============\n\n    /**\n     * Validate the transaction before exchanging heldToken for owedToken\n     */\n    function validateTxPreSell(\n        MarginState.State storage state,\n        Tx memory transaction\n    )\n        internal\n    {\n        assert(transaction.lenderAmount >= transaction.principal);\n\n        require(\n            transaction.principal > 0,\n            \"BorrowShared#validateTxPreSell: Positions with 0 principal are not allowed\"\n        );\n\n        // If the taker is 0x0 then any address can take it. Otherwise only the taker can use it.\n        if (transaction.loanOffering.taker != address(0)) {\n            require(\n                msg.sender == transaction.loanOffering.taker,\n                \"BorrowShared#validateTxPreSell: Invalid loan offering taker\"\n            );\n        }\n\n        // If the positionOwner is 0x0 then any address can be set as the position owner.\n        // Otherwise only the specified positionOwner can be set as the position owner.\n        if (transaction.loanOffering.positionOwner != address(0)) {\n            require(\n                transaction.owner == transaction.loanOffering.positionOwner,\n                \"BorrowShared#validateTxPreSell: Invalid position owner\"\n            );\n        }\n\n        // Require the loan offering to be approved by the payer\n        if (AddressUtils.isContract(transaction.loanOffering.payer)) {\n            getConsentFromSmartContractLender(transaction);\n        } else {\n            require(\n                transaction.loanOffering.payer == TypedSignature.recover(\n                    transaction.loanOffering.loanHash,\n                    transaction.loanOffering.signature\n                ),\n                \"BorrowShared#validateTxPreSell: Invalid loan offering signature\"\n            );\n        }\n\n        // Validate the amount is <= than max and >= min\n        uint256 unavailable = MarginCommon.getUnavailableLoanOfferingAmountImpl(\n            state,\n            transaction.loanOffering.loanHash\n        );\n        require(\n            transaction.lenderAmount.add(unavailable) <= transaction.loanOffering.rates.maxAmount,\n            \"BorrowShared#validateTxPreSell: Loan offering does not have enough available\"\n        );\n\n        require(\n            transaction.lenderAmount >= transaction.loanOffering.rates.minAmount,\n            \"BorrowShared#validateTxPreSell: Lender amount is below loan offering minimum amount\"\n        );\n\n        require(\n            transaction.loanOffering.owedToken != transaction.loanOffering.heldToken,\n            \"BorrowShared#validateTxPreSell: owedToken cannot be equal to heldToken\"\n        );\n\n        require(\n            transaction.owner != address(0),\n            \"BorrowShared#validateTxPreSell: Position owner cannot be 0\"\n        );\n\n        require(\n            transaction.loanOffering.owner != address(0),\n            \"BorrowShared#validateTxPreSell: Loan owner cannot be 0\"\n        );\n\n        require(\n            transaction.loanOffering.expirationTimestamp > block.timestamp,\n            \"BorrowShared#validateTxPreSell: Loan offering is expired\"\n        );\n\n        require(\n            transaction.loanOffering.maxDuration > 0,\n            \"BorrowShared#validateTxPreSell: Loan offering has 0 maximum duration\"\n        );\n\n        require(\n            transaction.loanOffering.rates.interestPeriod <= transaction.loanOffering.maxDuration,\n            \"BorrowShared#validateTxPreSell: Loan offering interestPeriod > maxDuration\"\n        );\n\n        // The minimum heldToken is validated after executing the sell\n        // Position and loan ownership is validated in TransferInternal\n    }\n\n    /**\n     * Validate the transaction after exchanging heldToken for owedToken, pay out fees, and store\n     * how much of the loan was used.\n     */\n    function doPostSell(\n        MarginState.State storage state,\n        Tx memory transaction\n    )\n        internal\n    {\n        validateTxPostSell(transaction);\n\n        // Transfer feeTokens from trader and lender\n        transferLoanFees(state, transaction);\n\n        // Update global amounts for the loan\n        state.loanFills[transaction.loanOffering.loanHash] =\n            state.loanFills[transaction.loanOffering.loanHash].add(transaction.lenderAmount);\n    }\n\n    /**\n     * Sells the owedToken from the lender (and from the deposit if in owedToken) using the\n     * exchangeWrapper, then puts the resulting heldToken into the vault. Only trades for\n     * maxHeldTokenToBuy of heldTokens at most.\n     */\n    function doSell(\n        MarginState.State storage state,\n        Tx transaction,\n        bytes orderData,\n        uint256 maxHeldTokenToBuy\n    )\n        internal\n        returns (uint256)\n    {\n        // Move owedTokens from lender to exchange wrapper\n        pullOwedTokensFromLender(state, transaction);\n\n        // Sell just the lender's owedToken (if trader deposit is in heldToken)\n        // Otherwise sell both the lender's owedToken and the trader's deposit in owedToken\n        uint256 sellAmount = transaction.depositInHeldToken ?\n            transaction.lenderAmount :\n            transaction.lenderAmount.add(transaction.depositAmount);\n\n        // Do the trade, taking only the maxHeldTokenToBuy if more is returned\n        uint256 heldTokenFromSell = Math.min256(\n            maxHeldTokenToBuy,\n            ExchangeWrapper(transaction.exchangeWrapper).exchange(\n                msg.sender,\n                state.TOKEN_PROXY,\n                transaction.loanOffering.heldToken,\n                transaction.loanOffering.owedToken,\n                sellAmount,\n                orderData\n            )\n        );\n\n        // Move the tokens to the vault\n        Vault(state.VAULT).transferToVault(\n            transaction.positionId,\n            transaction.loanOffering.heldToken,\n            transaction.exchangeWrapper,\n            heldTokenFromSell\n        );\n\n        // Update collateral amount\n        transaction.collateralAmount = transaction.collateralAmount.add(heldTokenFromSell);\n\n        return heldTokenFromSell;\n    }\n\n    /**\n     * Take the owedToken deposit from the trader and give it to the exchange wrapper so that it can\n     * be sold for heldToken.\n     */\n    function doDepositOwedToken(\n        MarginState.State storage state,\n        Tx transaction\n    )\n        internal\n    {\n        TokenProxy(state.TOKEN_PROXY).transferTokens(\n            transaction.loanOffering.owedToken,\n            msg.sender,\n            transaction.exchangeWrapper,\n            transaction.depositAmount\n        );\n    }\n\n    /**\n     * Take the heldToken deposit from the trader and move it to the vault.\n     */\n    function doDepositHeldToken(\n        MarginState.State storage state,\n        Tx transaction\n    )\n        internal\n    {\n        Vault(state.VAULT).transferToVault(\n            transaction.positionId,\n            transaction.loanOffering.heldToken,\n            msg.sender,\n            transaction.depositAmount\n        );\n\n        // Update collateral amount\n        transaction.collateralAmount = transaction.collateralAmount.add(transaction.depositAmount);\n    }\n\n    // ============ Private Helper-Functions ============\n\n    function validateTxPostSell(\n        Tx transaction\n    )\n        private\n        pure\n    {\n        uint256 expectedCollateral = transaction.depositInHeldToken ?\n            transaction.heldTokenFromSell.add(transaction.depositAmount) :\n            transaction.heldTokenFromSell;\n        assert(transaction.collateralAmount == expectedCollateral);\n\n        uint256 loanOfferingMinimumHeldToken = MathHelpers.getPartialAmountRoundedUp(\n            transaction.lenderAmount,\n            transaction.loanOffering.rates.maxAmount,\n            transaction.loanOffering.rates.minHeldToken\n        );\n        require(\n            transaction.collateralAmount >= loanOfferingMinimumHeldToken,\n            \"BorrowShared#validateTxPostSell: Loan offering minimum held token not met\"\n        );\n    }\n\n    function getConsentFromSmartContractLender(\n        Tx transaction\n    )\n        private\n    {\n        verifyLoanOfferingRecurse(\n            transaction.loanOffering.payer,\n            getLoanOfferingAddresses(transaction),\n            getLoanOfferingValues256(transaction),\n            getLoanOfferingValues32(transaction),\n            transaction.positionId,\n            transaction.loanOffering.signature\n        );\n    }\n\n    function verifyLoanOfferingRecurse(\n        address contractAddr,\n        address[9] addresses,\n        uint256[7] values256,\n        uint32[4] values32,\n        bytes32 positionId,\n        bytes signature\n    )\n        private\n    {\n        address newContractAddr = LoanOfferingVerifier(contractAddr).verifyLoanOffering(\n            addresses,\n            values256,\n            values32,\n            positionId,\n            signature\n        );\n\n        if (newContractAddr != contractAddr) {\n            verifyLoanOfferingRecurse(\n                newContractAddr,\n                addresses,\n                values256,\n                values32,\n                positionId,\n                signature\n            );\n        }\n    }\n\n    function pullOwedTokensFromLender(\n        MarginState.State storage state,\n        Tx transaction\n    )\n        private\n    {\n        // Transfer owedToken to the exchange wrapper\n        TokenProxy(state.TOKEN_PROXY).transferTokens(\n            transaction.loanOffering.owedToken,\n            transaction.loanOffering.payer,\n            transaction.exchangeWrapper,\n            transaction.lenderAmount\n        );\n    }\n\n    function transferLoanFees(\n        MarginState.State storage state,\n        Tx transaction\n    )\n        private\n    {\n        // 0 fee address indicates no fees\n        if (transaction.loanOffering.feeRecipient == address(0)) {\n            return;\n        }\n\n        TokenProxy proxy = TokenProxy(state.TOKEN_PROXY);\n\n        uint256 lenderFee = MathHelpers.getPartialAmount(\n            transaction.lenderAmount,\n            transaction.loanOffering.rates.maxAmount,\n            transaction.loanOffering.rates.lenderFee\n        );\n        uint256 takerFee = MathHelpers.getPartialAmount(\n            transaction.lenderAmount,\n            transaction.loanOffering.rates.maxAmount,\n            transaction.loanOffering.rates.takerFee\n        );\n\n        if (lenderFee > 0) {\n            proxy.transferTokens(\n                transaction.loanOffering.lenderFeeToken,\n                transaction.loanOffering.payer,\n                transaction.loanOffering.feeRecipient,\n                lenderFee\n            );\n        }\n\n        if (takerFee > 0) {\n            proxy.transferTokens(\n                transaction.loanOffering.takerFeeToken,\n                msg.sender,\n                transaction.loanOffering.feeRecipient,\n                takerFee\n            );\n        }\n    }\n\n    function getLoanOfferingAddresses(\n        Tx transaction\n    )\n        private\n        pure\n        returns (address[9])\n    {\n        return [\n            transaction.loanOffering.owedToken,\n            transaction.loanOffering.heldToken,\n            transaction.loanOffering.payer,\n            transaction.loanOffering.owner,\n            transaction.loanOffering.taker,\n            transaction.loanOffering.positionOwner,\n            transaction.loanOffering.feeRecipient,\n            transaction.loanOffering.lenderFeeToken,\n            transaction.loanOffering.takerFeeToken\n        ];\n    }\n\n    function getLoanOfferingValues256(\n        Tx transaction\n    )\n        private\n        pure\n        returns (uint256[7])\n    {\n        return [\n            transaction.loanOffering.rates.maxAmount,\n            transaction.loanOffering.rates.minAmount,\n            transaction.loanOffering.rates.minHeldToken,\n            transaction.loanOffering.rates.lenderFee,\n            transaction.loanOffering.rates.takerFee,\n            transaction.loanOffering.expirationTimestamp,\n            transaction.loanOffering.salt\n        ];\n    }\n\n    function getLoanOfferingValues32(\n        Tx transaction\n    )\n        private\n        pure\n        returns (uint32[4])\n    {\n        return [\n            transaction.loanOffering.callTimeLimit,\n            transaction.loanOffering.maxDuration,\n            transaction.loanOffering.rates.interestRate,\n            transaction.loanOffering.rates.interestPeriod\n        ];\n    }\n}\n\n// File: contracts/margin/interfaces/lender/IncreaseLoanDelegator.sol\n\n/**\n * @title IncreaseLoanDelegator\n * @author dYdX\n *\n * Interface that smart contracts must implement in order to own loans on behalf of other accounts.\n *\n * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\n *       to these functions\n */\ninterface IncreaseLoanDelegator {\n\n    // ============ Public Interface functions ============\n\n    /**\n     * Function a contract must implement in order to allow additional value to be added onto\n     * an owned loan. Margin will call this on the owner of a loan during increasePosition().\n     *\n     * NOTE: If not returning zero (or not reverting), this contract must assume that Margin will\n     * either revert the entire transaction or that the loan size was successfully increased.\n     *\n     * @param  payer           Lender adding additional funds to the position\n     * @param  positionId      Unique ID of the position\n     * @param  principalAdded  Principal amount to be added to the position\n     * @param  lentAmount      Amount of owedToken lent by the lender (principal plus interest, or\n     *                         zero if increaseWithoutCounterparty() is used).\n     * @return                 This address to accept, a different address to ask that contract\n     */\n    function increaseLoanOnBehalfOf(\n        address payer,\n        bytes32 positionId,\n        uint256 principalAdded,\n        uint256 lentAmount\n    )\n        external\n        /* onlyMargin */\n        returns (address);\n}\n\n// File: contracts/margin/interfaces/owner/IncreasePositionDelegator.sol\n\n/**\n * @title IncreasePositionDelegator\n * @author dYdX\n *\n * Interface that smart contracts must implement in order to own position on behalf of other\n * accounts\n *\n * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\n *       to these functions\n */\ninterface IncreasePositionDelegator {\n\n    // ============ Public Interface functions ============\n\n    /**\n     * Function a contract must implement in order to allow additional value to be added onto\n     * an owned position. Margin will call this on the owner of a position during increasePosition()\n     *\n     * NOTE: If not returning zero (or not reverting), this contract must assume that Margin will\n     * either revert the entire transaction or that the position size was successfully increased.\n     *\n     * @param  trader          Address initiating the addition of funds to the position\n     * @param  positionId      Unique ID of the position\n     * @param  principalAdded  Amount of principal to be added to the position\n     * @return                 This address to accept, a different address to ask that contract\n     */\n    function increasePositionOnBehalfOf(\n        address trader,\n        bytes32 positionId,\n        uint256 principalAdded\n    )\n        external\n        /* onlyMargin */\n        returns (address);\n}\n\n// File: contracts/margin/impl/IncreasePositionImpl.sol\n\n/**\n * @title IncreasePositionImpl\n * @author dYdX\n *\n * This library contains the implementation for the increasePosition function of Margin\n */\nlibrary IncreasePositionImpl {\n    using SafeMath for uint256;\n\n    // ============ Events ============\n\n    /*\n     * A position was increased\n     */\n    event PositionIncreased(\n        bytes32 indexed positionId,\n        address indexed trader,\n        address indexed lender,\n        address positionOwner,\n        address loanOwner,\n        bytes32 loanHash,\n        address loanFeeRecipient,\n        uint256 amountBorrowed,\n        uint256 principalAdded,\n        uint256 heldTokenFromSell,\n        uint256 depositAmount,\n        bool    depositInHeldToken\n    );\n\n    // ============ Public Implementation Functions ============\n\n    function increasePositionImpl(\n        MarginState.State storage state,\n        bytes32 positionId,\n        address[7] addresses,\n        uint256[8] values256,\n        uint32[2] values32,\n        bool depositInHeldToken,\n        bytes signature,\n        bytes orderData\n    )\n        public\n        returns (uint256)\n    {\n        // Also ensures that the position exists\n        MarginCommon.Position storage position =\n            MarginCommon.getPositionFromStorage(state, positionId);\n\n        BorrowShared.Tx memory transaction = parseIncreasePositionTx(\n            position,\n            positionId,\n            addresses,\n            values256,\n            values32,\n            depositInHeldToken,\n            signature\n        );\n\n        validateIncrease(state, transaction, position);\n\n        doBorrowAndSell(state, transaction, orderData);\n\n        updateState(\n            position,\n            transaction.positionId,\n            transaction.principal,\n            transaction.lenderAmount,\n            transaction.loanOffering.payer\n        );\n\n        // LOG EVENT\n        recordPositionIncreased(transaction, position);\n\n        return transaction.lenderAmount;\n    }\n\n    function increaseWithoutCounterpartyImpl(\n        MarginState.State storage state,\n        bytes32 positionId,\n        uint256 principalToAdd\n    )\n        public\n        returns (uint256)\n    {\n        MarginCommon.Position storage position =\n            MarginCommon.getPositionFromStorage(state, positionId);\n\n        // Disallow adding 0 principal\n        require(\n            principalToAdd > 0,\n            \"IncreasePositionImpl#increaseWithoutCounterpartyImpl: Cannot add 0 principal\"\n        );\n\n        // Disallow additions after maximum duration\n        require(\n            block.timestamp < uint256(position.startTimestamp).add(position.maxDuration),\n            \"IncreasePositionImpl#increaseWithoutCounterpartyImpl: Cannot increase after maxDuration\"\n        );\n\n        uint256 heldTokenAmount = getCollateralNeededForAddedPrincipal(\n            state,\n            position,\n            positionId,\n            principalToAdd\n        );\n\n        Vault(state.VAULT).transferToVault(\n            positionId,\n            position.heldToken,\n            msg.sender,\n            heldTokenAmount\n        );\n\n        updateState(\n            position,\n            positionId,\n            principalToAdd,\n            0, // lent amount\n            msg.sender\n        );\n\n        emit PositionIncreased(\n            positionId,\n            msg.sender,\n            msg.sender,\n            position.owner,\n            position.lender,\n            \"\",\n            address(0),\n            0,\n            principalToAdd,\n            0,\n            heldTokenAmount,\n            true\n        );\n\n        return heldTokenAmount;\n    }\n\n    // ============ Private Helper-Functions ============\n\n    function doBorrowAndSell(\n        MarginState.State storage state,\n        BorrowShared.Tx memory transaction,\n        bytes orderData\n    )\n        private\n    {\n        // Calculate the number of heldTokens to add\n        uint256 collateralToAdd = getCollateralNeededForAddedPrincipal(\n            state,\n            state.positions[transaction.positionId],\n            transaction.positionId,\n            transaction.principal\n        );\n\n        // Do pre-exchange validations\n        BorrowShared.validateTxPreSell(state, transaction);\n\n        // Calculate and deposit owedToken\n        uint256 maxHeldTokenFromSell = MathHelpers.maxUint256();\n        if (!transaction.depositInHeldToken) {\n            transaction.depositAmount =\n                getOwedTokenDeposit(transaction, collateralToAdd, orderData);\n            BorrowShared.doDepositOwedToken(state, transaction);\n            maxHeldTokenFromSell = collateralToAdd;\n        }\n\n        // Sell owedToken for heldToken using the exchange wrapper\n        transaction.heldTokenFromSell = BorrowShared.doSell(\n            state,\n            transaction,\n            orderData,\n            maxHeldTokenFromSell\n        );\n\n        // Calculate and deposit heldToken\n        if (transaction.depositInHeldToken) {\n            require(\n                transaction.heldTokenFromSell <= collateralToAdd,\n                \"IncreasePositionImpl#doBorrowAndSell: DEX order gives too much heldToken\"\n            );\n            transaction.depositAmount = collateralToAdd.sub(transaction.heldTokenFromSell);\n            BorrowShared.doDepositHeldToken(state, transaction);\n        }\n\n        // Make sure the actual added collateral is what is expected\n        assert(transaction.collateralAmount == collateralToAdd);\n\n        // Do post-exchange validations\n        BorrowShared.doPostSell(state, transaction);\n    }\n\n    function getOwedTokenDeposit(\n        BorrowShared.Tx transaction,\n        uint256 collateralToAdd,\n        bytes orderData\n    )\n        private\n        view\n        returns (uint256)\n    {\n        uint256 totalOwedToken = ExchangeWrapper(transaction.exchangeWrapper).getExchangeCost(\n            transaction.loanOffering.heldToken,\n            transaction.loanOffering.owedToken,\n            collateralToAdd,\n            orderData\n        );\n\n        require(\n            transaction.lenderAmount <= totalOwedToken,\n            \"IncreasePositionImpl#getOwedTokenDeposit: Lender amount is more than required\"\n        );\n\n        return totalOwedToken.sub(transaction.lenderAmount);\n    }\n\n    function validateIncrease(\n        MarginState.State storage state,\n        BorrowShared.Tx transaction,\n        MarginCommon.Position storage position\n    )\n        private\n        view\n    {\n        assert(MarginCommon.containsPositionImpl(state, transaction.positionId));\n\n        require(\n            position.callTimeLimit <= transaction.loanOffering.callTimeLimit,\n            \"IncreasePositionImpl#validateIncrease: Loan callTimeLimit is less than the position\"\n        );\n\n        // require the position to end no later than the loanOffering's maximum acceptable end time\n        uint256 positionEndTimestamp = uint256(position.startTimestamp).add(position.maxDuration);\n        uint256 offeringEndTimestamp = block.timestamp.add(transaction.loanOffering.maxDuration);\n        require(\n            positionEndTimestamp <= offeringEndTimestamp,\n            \"IncreasePositionImpl#validateIncrease: Loan end timestamp is less than the position\"\n        );\n\n        require(\n            block.timestamp < positionEndTimestamp,\n            \"IncreasePositionImpl#validateIncrease: Position has passed its maximum duration\"\n        );\n    }\n\n    function getCollateralNeededForAddedPrincipal(\n        MarginState.State storage state,\n        MarginCommon.Position storage position,\n        bytes32 positionId,\n        uint256 principalToAdd\n    )\n        private\n        view\n        returns (uint256)\n    {\n        uint256 heldTokenBalance = MarginCommon.getPositionBalanceImpl(state, positionId);\n\n        return MathHelpers.getPartialAmountRoundedUp(\n            principalToAdd,\n            position.principal,\n            heldTokenBalance\n        );\n    }\n\n    function updateState(\n        MarginCommon.Position storage position,\n        bytes32 positionId,\n        uint256 principalAdded,\n        uint256 owedTokenLent,\n        address loanPayer\n    )\n        private\n    {\n        position.principal = position.principal.add(principalAdded);\n\n        address owner = position.owner;\n        address lender = position.lender;\n\n        // Ensure owner consent\n        increasePositionOnBehalfOfRecurse(\n            owner,\n            msg.sender,\n            positionId,\n            principalAdded\n        );\n\n        // Ensure lender consent\n        increaseLoanOnBehalfOfRecurse(\n            lender,\n            loanPayer,\n            positionId,\n            principalAdded,\n            owedTokenLent\n        );\n    }\n\n    function increasePositionOnBehalfOfRecurse(\n        address contractAddr,\n        address trader,\n        bytes32 positionId,\n        uint256 principalAdded\n    )\n        private\n    {\n        // Assume owner approval if not a smart contract and they increased their own position\n        if (trader == contractAddr && !AddressUtils.isContract(contractAddr)) {\n            return;\n        }\n\n        address newContractAddr =\n            IncreasePositionDelegator(contractAddr).increasePositionOnBehalfOf(\n                trader,\n                positionId,\n                principalAdded\n            );\n\n        if (newContractAddr != contractAddr) {\n            increasePositionOnBehalfOfRecurse(\n                newContractAddr,\n                trader,\n                positionId,\n                principalAdded\n            );\n        }\n    }\n\n    function increaseLoanOnBehalfOfRecurse(\n        address contractAddr,\n        address payer,\n        bytes32 positionId,\n        uint256 principalAdded,\n        uint256 amountLent\n    )\n        private\n    {\n        // Assume lender approval if not a smart contract and they increased their own loan\n        if (payer == contractAddr && !AddressUtils.isContract(contractAddr)) {\n            return;\n        }\n\n        address newContractAddr =\n            IncreaseLoanDelegator(contractAddr).increaseLoanOnBehalfOf(\n                payer,\n                positionId,\n                principalAdded,\n                amountLent\n            );\n\n        if (newContractAddr != contractAddr) {\n            increaseLoanOnBehalfOfRecurse(\n                newContractAddr,\n                payer,\n                positionId,\n                principalAdded,\n                amountLent\n            );\n        }\n    }\n\n    function recordPositionIncreased(\n        BorrowShared.Tx transaction,\n        MarginCommon.Position storage position\n    )\n        private\n    {\n        emit PositionIncreased(\n            transaction.positionId,\n            msg.sender,\n            transaction.loanOffering.payer,\n            position.owner,\n            position.lender,\n            transaction.loanOffering.loanHash,\n            transaction.loanOffering.feeRecipient,\n            transaction.lenderAmount,\n            transaction.principal,\n            transaction.heldTokenFromSell,\n            transaction.depositAmount,\n            transaction.depositInHeldToken\n        );\n    }\n\n    // ============ Parsing Functions ============\n\n    function parseIncreasePositionTx(\n        MarginCommon.Position storage position,\n        bytes32 positionId,\n        address[7] addresses,\n        uint256[8] values256,\n        uint32[2] values32,\n        bool depositInHeldToken,\n        bytes signature\n    )\n        private\n        view\n        returns (BorrowShared.Tx memory)\n    {\n        uint256 principal = values256[7];\n\n        uint256 lenderAmount = MarginCommon.calculateLenderAmountForIncreasePosition(\n            position,\n            principal,\n            block.timestamp\n        );\n        assert(lenderAmount >= principal);\n\n        BorrowShared.Tx memory transaction = BorrowShared.Tx({\n            positionId: positionId,\n            owner: position.owner,\n            principal: principal,\n            lenderAmount: lenderAmount,\n            loanOffering: parseLoanOfferingFromIncreasePositionTx(\n                position,\n                addresses,\n                values256,\n                values32,\n                signature\n            ),\n            exchangeWrapper: addresses[6],\n            depositInHeldToken: depositInHeldToken,\n            depositAmount: 0, // set later\n            collateralAmount: 0, // set later\n            heldTokenFromSell: 0 // set later\n        });\n\n        return transaction;\n    }\n\n    function parseLoanOfferingFromIncreasePositionTx(\n        MarginCommon.Position storage position,\n        address[7] addresses,\n        uint256[8] values256,\n        uint32[2] values32,\n        bytes signature\n    )\n        private\n        view\n        returns (MarginCommon.LoanOffering memory)\n    {\n        MarginCommon.LoanOffering memory loanOffering = MarginCommon.LoanOffering({\n            owedToken: position.owedToken,\n            heldToken: position.heldToken,\n            payer: addresses[0],\n            owner: position.lender,\n            taker: addresses[1],\n            positionOwner: addresses[2],\n            feeRecipient: addresses[3],\n            lenderFeeToken: addresses[4],\n            takerFeeToken: addresses[5],\n            rates: parseLoanOfferingRatesFromIncreasePositionTx(position, values256),\n            expirationTimestamp: values256[5],\n            callTimeLimit: values32[0],\n            maxDuration: values32[1],\n            salt: values256[6],\n            loanHash: 0,\n            signature: signature\n        });\n\n        loanOffering.loanHash = MarginCommon.getLoanOfferingHash(loanOffering);\n\n        return loanOffering;\n    }\n\n    function parseLoanOfferingRatesFromIncreasePositionTx(\n        MarginCommon.Position storage position,\n        uint256[8] values256\n    )\n        private\n        view\n        returns (MarginCommon.LoanRates memory)\n    {\n        MarginCommon.LoanRates memory rates = MarginCommon.LoanRates({\n            maxAmount: values256[0],\n            minAmount: values256[1],\n            minHeldToken: values256[2],\n            lenderFee: values256[3],\n            takerFee: values256[4],\n            interestRate: position.interestRate,\n            interestPeriod: position.interestPeriod\n        });\n\n        return rates;\n    }\n}\n\n// File: contracts/margin/impl/MarginStorage.sol\n\n/**\n * @title MarginStorage\n * @author dYdX\n *\n * This contract serves as the storage for the entire state of MarginStorage\n */\ncontract MarginStorage {\n\n    MarginState.State state;\n\n}\n\n// File: contracts/margin/impl/LoanGetters.sol\n\n/**\n * @title LoanGetters\n * @author dYdX\n *\n * A collection of public constant getter functions that allows reading of the state of any loan\n * offering stored in the dYdX protocol.\n */\ncontract LoanGetters is MarginStorage {\n\n    // ============ Public Constant Functions ============\n\n    /**\n     * Gets the principal amount of a loan offering that is no longer available.\n     *\n     * @param  loanHash  Unique hash of the loan offering\n     * @return           The total unavailable amount of the loan offering, which is equal to the\n     *                   filled amount plus the canceled amount.\n     */\n    function getLoanUnavailableAmount(\n        bytes32 loanHash\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return MarginCommon.getUnavailableLoanOfferingAmountImpl(state, loanHash);\n    }\n\n    /**\n     * Gets the total amount of owed token lent for a loan.\n     *\n     * @param  loanHash  Unique hash of the loan offering\n     * @return           The total filled amount of the loan offering.\n     */\n    function getLoanFilledAmount(\n        bytes32 loanHash\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return state.loanFills[loanHash];\n    }\n\n    /**\n     * Gets the amount of a loan offering that has been canceled.\n     *\n     * @param  loanHash  Unique hash of the loan offering\n     * @return           The total canceled amount of the loan offering.\n     */\n    function getLoanCanceledAmount(\n        bytes32 loanHash\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return state.loanCancels[loanHash];\n    }\n}\n\n// File: contracts/margin/interfaces/lender/CancelMarginCallDelegator.sol\n\n/**\n * @title CancelMarginCallDelegator\n * @author dYdX\n *\n * Interface that smart contracts must implement in order to let other addresses cancel a\n * margin-call for a loan owned by the smart contract.\n *\n * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\n *       to these functions\n */\ninterface CancelMarginCallDelegator {\n\n    // ============ Public Interface functions ============\n\n    /**\n     * Function a contract must implement in order to let other addresses call cancelMarginCall().\n     *\n     * NOTE: If not returning zero (or not reverting), this contract must assume that Margin will\n     * either revert the entire transaction or that the margin-call was successfully canceled.\n     *\n     * @param  canceler    Address of the caller of the cancelMarginCall function\n     * @param  positionId  Unique ID of the position\n     * @return             This address to accept, a different address to ask that contract\n     */\n    function cancelMarginCallOnBehalfOf(\n        address canceler,\n        bytes32 positionId\n    )\n        external\n        /* onlyMargin */\n        returns (address);\n}\n\n// File: contracts/margin/interfaces/lender/MarginCallDelegator.sol\n\n/**\n * @title MarginCallDelegator\n * @author dYdX\n *\n * Interface that smart contracts must implement in order to let other addresses margin-call a loan\n * owned by the smart contract.\n *\n * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\n *       to these functions\n */\ninterface MarginCallDelegator {\n\n    // ============ Public Interface functions ============\n\n    /**\n     * Function a contract must implement in order to let other addresses call marginCall().\n     *\n     * NOTE: If not returning zero (or not reverting), this contract must assume that Margin will\n     * either revert the entire transaction or that the loan was successfully margin-called.\n     *\n     * @param  caller         Address of the caller of the marginCall function\n     * @param  positionId     Unique ID of the position\n     * @param  depositAmount  Amount of heldToken deposit that will be required to cancel the call\n     * @return                This address to accept, a different address to ask that contract\n     */\n    function marginCallOnBehalfOf(\n        address caller,\n        bytes32 positionId,\n        uint256 depositAmount\n    )\n        external\n        /* onlyMargin */\n        returns (address);\n}\n\n// File: contracts/margin/impl/LoanImpl.sol\n\n/**\n * @title LoanImpl\n * @author dYdX\n *\n * This library contains the implementation for the following functions of Margin:\n *\n *      - marginCall\n *      - cancelMarginCallImpl\n *      - cancelLoanOffering\n */\nlibrary LoanImpl {\n    using SafeMath for uint256;\n\n    // ============ Events ============\n\n    /**\n     * A position was margin-called\n     */\n    event MarginCallInitiated(\n        bytes32 indexed positionId,\n        address indexed lender,\n        address indexed owner,\n        uint256 requiredDeposit\n    );\n\n    /**\n     * A margin call was canceled\n     */\n    event MarginCallCanceled(\n        bytes32 indexed positionId,\n        address indexed lender,\n        address indexed owner,\n        uint256 depositAmount\n    );\n\n    /**\n     * A loan offering was canceled before it was used. Any amount less than the\n     * total for the loan offering can be canceled.\n     */\n    event LoanOfferingCanceled(\n        bytes32 indexed loanHash,\n        address indexed payer,\n        address indexed feeRecipient,\n        uint256 cancelAmount\n    );\n\n    // ============ Public Implementation Functions ============\n\n    function marginCallImpl(\n        MarginState.State storage state,\n        bytes32 positionId,\n        uint256 requiredDeposit\n    )\n        public\n    {\n        MarginCommon.Position storage position =\n            MarginCommon.getPositionFromStorage(state, positionId);\n\n        require(\n            position.callTimestamp == 0,\n            \"LoanImpl#marginCallImpl: The position has already been margin-called\"\n        );\n\n        // Ensure lender consent\n        marginCallOnBehalfOfRecurse(\n            position.lender,\n            msg.sender,\n            positionId,\n            requiredDeposit\n        );\n\n        position.callTimestamp = TimestampHelper.getBlockTimestamp32();\n        position.requiredDeposit = requiredDeposit;\n\n        emit MarginCallInitiated(\n            positionId,\n            position.lender,\n            position.owner,\n            requiredDeposit\n        );\n    }\n\n    function cancelMarginCallImpl(\n        MarginState.State storage state,\n        bytes32 positionId\n    )\n        public\n    {\n        MarginCommon.Position storage position =\n            MarginCommon.getPositionFromStorage(state, positionId);\n\n        require(\n            position.callTimestamp > 0,\n            \"LoanImpl#cancelMarginCallImpl: Position has not been margin-called\"\n        );\n\n        // Ensure lender consent\n        cancelMarginCallOnBehalfOfRecurse(\n            position.lender,\n            msg.sender,\n            positionId\n        );\n\n        state.positions[positionId].callTimestamp = 0;\n        state.positions[positionId].requiredDeposit = 0;\n\n        emit MarginCallCanceled(\n            positionId,\n            position.lender,\n            position.owner,\n            0\n        );\n    }\n\n    function cancelLoanOfferingImpl(\n        MarginState.State storage state,\n        address[9] addresses,\n        uint256[7] values256,\n        uint32[4]  values32,\n        uint256    cancelAmount\n    )\n        public\n        returns (uint256)\n    {\n        MarginCommon.LoanOffering memory loanOffering = parseLoanOffering(\n            addresses,\n            values256,\n            values32\n        );\n\n        require(\n            msg.sender == loanOffering.payer,\n            \"LoanImpl#cancelLoanOfferingImpl: Only loan offering payer can cancel\"\n        );\n        require(\n            loanOffering.expirationTimestamp > block.timestamp,\n            \"LoanImpl#cancelLoanOfferingImpl: Loan offering has already expired\"\n        );\n\n        uint256 remainingAmount = loanOffering.rates.maxAmount.sub(\n            MarginCommon.getUnavailableLoanOfferingAmountImpl(state, loanOffering.loanHash)\n        );\n        uint256 amountToCancel = Math.min256(remainingAmount, cancelAmount);\n\n        // If the loan was already fully canceled, then just return 0 amount was canceled\n        if (amountToCancel == 0) {\n            return 0;\n        }\n\n        state.loanCancels[loanOffering.loanHash] =\n            state.loanCancels[loanOffering.loanHash].add(amountToCancel);\n\n        emit LoanOfferingCanceled(\n            loanOffering.loanHash,\n            loanOffering.payer,\n            loanOffering.feeRecipient,\n            amountToCancel\n        );\n\n        return amountToCancel;\n    }\n\n    // ============ Private Helper-Functions ============\n\n    function marginCallOnBehalfOfRecurse(\n        address contractAddr,\n        address who,\n        bytes32 positionId,\n        uint256 requiredDeposit\n    )\n        private\n    {\n        // no need to ask for permission\n        if (who == contractAddr) {\n            return;\n        }\n\n        address newContractAddr =\n            MarginCallDelegator(contractAddr).marginCallOnBehalfOf(\n                msg.sender,\n                positionId,\n                requiredDeposit\n            );\n\n        if (newContractAddr != contractAddr) {\n            marginCallOnBehalfOfRecurse(\n                newContractAddr,\n                who,\n                positionId,\n                requiredDeposit\n            );\n        }\n    }\n\n    function cancelMarginCallOnBehalfOfRecurse(\n        address contractAddr,\n        address who,\n        bytes32 positionId\n    )\n        private\n    {\n        // no need to ask for permission\n        if (who == contractAddr) {\n            return;\n        }\n\n        address newContractAddr =\n            CancelMarginCallDelegator(contractAddr).cancelMarginCallOnBehalfOf(\n                msg.sender,\n                positionId\n            );\n\n        if (newContractAddr != contractAddr) {\n            cancelMarginCallOnBehalfOfRecurse(\n                newContractAddr,\n                who,\n                positionId\n            );\n        }\n    }\n\n    // ============ Parsing Functions ============\n\n    function parseLoanOffering(\n        address[9] addresses,\n        uint256[7] values256,\n        uint32[4]  values32\n    )\n        private\n        view\n        returns (MarginCommon.LoanOffering memory)\n    {\n        MarginCommon.LoanOffering memory loanOffering = MarginCommon.LoanOffering({\n            owedToken: addresses[0],\n            heldToken: addresses[1],\n            payer: addresses[2],\n            owner: addresses[3],\n            taker: addresses[4],\n            positionOwner: addresses[5],\n            feeRecipient: addresses[6],\n            lenderFeeToken: addresses[7],\n            takerFeeToken: addresses[8],\n            rates: parseLoanOfferRates(values256, values32),\n            expirationTimestamp: values256[5],\n            callTimeLimit: values32[0],\n            maxDuration: values32[1],\n            salt: values256[6],\n            loanHash: 0,\n            signature: new bytes(0)\n        });\n\n        loanOffering.loanHash = MarginCommon.getLoanOfferingHash(loanOffering);\n\n        return loanOffering;\n    }\n\n    function parseLoanOfferRates(\n        uint256[7] values256,\n        uint32[4] values32\n    )\n        private\n        pure\n        returns (MarginCommon.LoanRates memory)\n    {\n        MarginCommon.LoanRates memory rates = MarginCommon.LoanRates({\n            maxAmount: values256[0],\n            minAmount: values256[1],\n            minHeldToken: values256[2],\n            interestRate: values32[2],\n            lenderFee: values256[3],\n            takerFee: values256[4],\n            interestPeriod: values32[3]\n        });\n\n        return rates;\n    }\n}\n\n// File: contracts/margin/impl/MarginAdmin.sol\n\n/**\n * @title MarginAdmin\n * @author dYdX\n *\n * Contains admin functions for the Margin contract\n * The owner can put Margin into various close-only modes, which will disallow new position creation\n */\ncontract MarginAdmin is Ownable {\n    // ============ Enums ============\n\n    // All functionality enabled\n    uint8 private constant OPERATION_STATE_OPERATIONAL = 0;\n\n    // Only closing functions + cancelLoanOffering allowed (marginCall, closePosition,\n    // cancelLoanOffering, closePositionDirectly, forceRecoverCollateral)\n    uint8 private constant OPERATION_STATE_CLOSE_AND_CANCEL_LOAN_ONLY = 1;\n\n    // Only closing functions allowed (marginCall, closePosition, closePositionDirectly,\n    // forceRecoverCollateral)\n    uint8 private constant OPERATION_STATE_CLOSE_ONLY = 2;\n\n    // Only closing functions allowed (marginCall, closePositionDirectly, forceRecoverCollateral)\n    uint8 private constant OPERATION_STATE_CLOSE_DIRECTLY_ONLY = 3;\n\n    // This operation state (and any higher) is invalid\n    uint8 private constant OPERATION_STATE_INVALID = 4;\n\n    // ============ Events ============\n\n    /**\n     * Event indicating the operation state has changed\n     */\n    event OperationStateChanged(\n        uint8 from,\n        uint8 to\n    );\n\n    // ============ State Variables ============\n\n    uint8 public operationState;\n\n    // ============ Constructor ============\n\n    constructor()\n        public\n        Ownable()\n    {\n        operationState = OPERATION_STATE_OPERATIONAL;\n    }\n\n    // ============ Modifiers ============\n\n    modifier onlyWhileOperational() {\n        require(\n            operationState == OPERATION_STATE_OPERATIONAL,\n            \"MarginAdmin#onlyWhileOperational: Can only call while operational\"\n        );\n        _;\n    }\n\n    modifier cancelLoanOfferingStateControl() {\n        require(\n            operationState == OPERATION_STATE_OPERATIONAL\n            || operationState == OPERATION_STATE_CLOSE_AND_CANCEL_LOAN_ONLY,\n            \"MarginAdmin#cancelLoanOfferingStateControl: Invalid operation state\"\n        );\n        _;\n    }\n\n    modifier closePositionStateControl() {\n        require(\n            operationState == OPERATION_STATE_OPERATIONAL\n            || operationState == OPERATION_STATE_CLOSE_AND_CANCEL_LOAN_ONLY\n            || operationState == OPERATION_STATE_CLOSE_ONLY,\n            \"MarginAdmin#closePositionStateControl: Invalid operation state\"\n        );\n        _;\n    }\n\n    modifier closePositionDirectlyStateControl() {\n        _;\n    }\n\n    // ============ Owner-Only State-Changing Functions ============\n\n    function setOperationState(\n        uint8 newState\n    )\n        external\n        onlyOwner\n    {\n        require(\n            newState < OPERATION_STATE_INVALID,\n            \"MarginAdmin#setOperationState: newState is not a valid operation state\"\n        );\n\n        if (newState != operationState) {\n            emit OperationStateChanged(\n                operationState,\n                newState\n            );\n            operationState = newState;\n        }\n    }\n}\n\n// File: contracts/margin/impl/MarginEvents.sol\n\n/**\n * @title MarginEvents\n * @author dYdX\n *\n * Contains events for the Margin contract.\n *\n * NOTE: Any Margin function libraries that use events will need to both define the event here\n *       and copy the event into the library itself as libraries don't support sharing events\n */\ncontract MarginEvents {\n    // ============ Events ============\n\n    /**\n     * A position was opened\n     */\n    event PositionOpened(\n        bytes32 indexed positionId,\n        address indexed trader,\n        address indexed lender,\n        bytes32 loanHash,\n        address owedToken,\n        address heldToken,\n        address loanFeeRecipient,\n        uint256 principal,\n        uint256 heldTokenFromSell,\n        uint256 depositAmount,\n        uint256 interestRate,\n        uint32  callTimeLimit,\n        uint32  maxDuration,\n        bool    depositInHeldToken\n    );\n\n    /*\n     * A position was increased\n     */\n    event PositionIncreased(\n        bytes32 indexed positionId,\n        address indexed trader,\n        address indexed lender,\n        address positionOwner,\n        address loanOwner,\n        bytes32 loanHash,\n        address loanFeeRecipient,\n        uint256 amountBorrowed,\n        uint256 principalAdded,\n        uint256 heldTokenFromSell,\n        uint256 depositAmount,\n        bool    depositInHeldToken\n    );\n\n    /**\n     * A position was closed or partially closed\n     */\n    event PositionClosed(\n        bytes32 indexed positionId,\n        address indexed closer,\n        address indexed payoutRecipient,\n        uint256 closeAmount,\n        uint256 remainingAmount,\n        uint256 owedTokenPaidToLender,\n        uint256 payoutAmount,\n        uint256 buybackCostInHeldToken,\n        bool payoutInHeldToken\n    );\n\n    /**\n     * Collateral for a position was forcibly recovered\n     */\n    event CollateralForceRecovered(\n        bytes32 indexed positionId,\n        address indexed recipient,\n        uint256 amount\n    );\n\n    /**\n     * A position was margin-called\n     */\n    event MarginCallInitiated(\n        bytes32 indexed positionId,\n        address indexed lender,\n        address indexed owner,\n        uint256 requiredDeposit\n    );\n\n    /**\n     * A margin call was canceled\n     */\n    event MarginCallCanceled(\n        bytes32 indexed positionId,\n        address indexed lender,\n        address indexed owner,\n        uint256 depositAmount\n    );\n\n    /**\n     * A loan offering was canceled before it was used. Any amount less than the\n     * total for the loan offering can be canceled.\n     */\n    event LoanOfferingCanceled(\n        bytes32 indexed loanHash,\n        address indexed payer,\n        address indexed feeRecipient,\n        uint256 cancelAmount\n    );\n\n    /**\n     * Additional collateral for a position was posted by the owner\n     */\n    event AdditionalCollateralDeposited(\n        bytes32 indexed positionId,\n        uint256 amount,\n        address depositor\n    );\n\n    /**\n     * Ownership of a loan was transferred to a new address\n     */\n    event LoanTransferred(\n        bytes32 indexed positionId,\n        address indexed from,\n        address indexed to\n    );\n\n    /**\n     * Ownership of a position was transferred to a new address\n     */\n    event PositionTransferred(\n        bytes32 indexed positionId,\n        address indexed from,\n        address indexed to\n    );\n}\n\n// File: contracts/margin/impl/OpenPositionImpl.sol\n\n/**\n * @title OpenPositionImpl\n * @author dYdX\n *\n * This library contains the implementation for the openPosition function of Margin\n */\nlibrary OpenPositionImpl {\n    using SafeMath for uint256;\n\n    // ============ Events ============\n\n    /**\n     * A position was opened\n     */\n    event PositionOpened(\n        bytes32 indexed positionId,\n        address indexed trader,\n        address indexed lender,\n        bytes32 loanHash,\n        address owedToken,\n        address heldToken,\n        address loanFeeRecipient,\n        uint256 principal,\n        uint256 heldTokenFromSell,\n        uint256 depositAmount,\n        uint256 interestRate,\n        uint32  callTimeLimit,\n        uint32  maxDuration,\n        bool    depositInHeldToken\n    );\n\n    // ============ Public Implementation Functions ============\n\n    function openPositionImpl(\n        MarginState.State storage state,\n        address[11] addresses,\n        uint256[10] values256,\n        uint32[4] values32,\n        bool depositInHeldToken,\n        bytes signature,\n        bytes orderData\n    )\n        public\n        returns (bytes32)\n    {\n        BorrowShared.Tx memory transaction = parseOpenTx(\n            addresses,\n            values256,\n            values32,\n            depositInHeldToken,\n            signature\n        );\n\n        require(\n            !MarginCommon.positionHasExisted(state, transaction.positionId),\n            \"OpenPositionImpl#openPositionImpl: positionId already exists\"\n        );\n\n        doBorrowAndSell(state, transaction, orderData);\n\n        // Before doStoreNewPosition() so that PositionOpened event is before Transferred events\n        recordPositionOpened(\n            transaction\n        );\n\n        doStoreNewPosition(\n            state,\n            transaction\n        );\n\n        return transaction.positionId;\n    }\n\n    // ============ Private Helper-Functions ============\n\n    function doBorrowAndSell(\n        MarginState.State storage state,\n        BorrowShared.Tx memory transaction,\n        bytes orderData\n    )\n        private\n    {\n        BorrowShared.validateTxPreSell(state, transaction);\n\n        if (transaction.depositInHeldToken) {\n            BorrowShared.doDepositHeldToken(state, transaction);\n        } else {\n            BorrowShared.doDepositOwedToken(state, transaction);\n        }\n\n        transaction.heldTokenFromSell = BorrowShared.doSell(\n            state,\n            transaction,\n            orderData,\n            MathHelpers.maxUint256()\n        );\n\n        BorrowShared.doPostSell(state, transaction);\n    }\n\n    function doStoreNewPosition(\n        MarginState.State storage state,\n        BorrowShared.Tx memory transaction\n    )\n        private\n    {\n        MarginCommon.storeNewPosition(\n            state,\n            transaction.positionId,\n            MarginCommon.Position({\n                owedToken: transaction.loanOffering.owedToken,\n                heldToken: transaction.loanOffering.heldToken,\n                lender: transaction.loanOffering.owner,\n                owner: transaction.owner,\n                principal: transaction.principal,\n                requiredDeposit: 0,\n                callTimeLimit: transaction.loanOffering.callTimeLimit,\n                startTimestamp: 0,\n                callTimestamp: 0,\n                maxDuration: transaction.loanOffering.maxDuration,\n                interestRate: transaction.loanOffering.rates.interestRate,\n                interestPeriod: transaction.loanOffering.rates.interestPeriod\n            }),\n            transaction.loanOffering.payer\n        );\n    }\n\n    function recordPositionOpened(\n        BorrowShared.Tx transaction\n    )\n        private\n    {\n        emit PositionOpened(\n            transaction.positionId,\n            msg.sender,\n            transaction.loanOffering.payer,\n            transaction.loanOffering.loanHash,\n            transaction.loanOffering.owedToken,\n            transaction.loanOffering.heldToken,\n            transaction.loanOffering.feeRecipient,\n            transaction.principal,\n            transaction.heldTokenFromSell,\n            transaction.depositAmount,\n            transaction.loanOffering.rates.interestRate,\n            transaction.loanOffering.callTimeLimit,\n            transaction.loanOffering.maxDuration,\n            transaction.depositInHeldToken\n        );\n    }\n\n    // ============ Parsing Functions ============\n\n    function parseOpenTx(\n        address[11] addresses,\n        uint256[10] values256,\n        uint32[4] values32,\n        bool depositInHeldToken,\n        bytes signature\n    )\n        private\n        view\n        returns (BorrowShared.Tx memory)\n    {\n        BorrowShared.Tx memory transaction = BorrowShared.Tx({\n            positionId: MarginCommon.getPositionIdFromNonce(values256[9]),\n            owner: addresses[0],\n            principal: values256[7],\n            lenderAmount: values256[7],\n            loanOffering: parseLoanOffering(\n                addresses,\n                values256,\n                values32,\n                signature\n            ),\n            exchangeWrapper: addresses[10],\n            depositInHeldToken: depositInHeldToken,\n            depositAmount: values256[8],\n            collateralAmount: 0, // set later\n            heldTokenFromSell: 0 // set later\n        });\n\n        return transaction;\n    }\n\n    function parseLoanOffering(\n        address[11] addresses,\n        uint256[10] values256,\n        uint32[4]   values32,\n        bytes       signature\n    )\n        private\n        view\n        returns (MarginCommon.LoanOffering memory)\n    {\n        MarginCommon.LoanOffering memory loanOffering = MarginCommon.LoanOffering({\n            owedToken: addresses[1],\n            heldToken: addresses[2],\n            payer: addresses[3],\n            owner: addresses[4],\n            taker: addresses[5],\n            positionOwner: addresses[6],\n            feeRecipient: addresses[7],\n            lenderFeeToken: addresses[8],\n            takerFeeToken: addresses[9],\n            rates: parseLoanOfferRates(values256, values32),\n            expirationTimestamp: values256[5],\n            callTimeLimit: values32[0],\n            maxDuration: values32[1],\n            salt: values256[6],\n            loanHash: 0,\n            signature: signature\n        });\n\n        loanOffering.loanHash = MarginCommon.getLoanOfferingHash(loanOffering);\n\n        return loanOffering;\n    }\n\n    function parseLoanOfferRates(\n        uint256[10] values256,\n        uint32[4] values32\n    )\n        private\n        pure\n        returns (MarginCommon.LoanRates memory)\n    {\n        MarginCommon.LoanRates memory rates = MarginCommon.LoanRates({\n            maxAmount: values256[0],\n            minAmount: values256[1],\n            minHeldToken: values256[2],\n            lenderFee: values256[3],\n            takerFee: values256[4],\n            interestRate: values32[2],\n            interestPeriod: values32[3]\n        });\n\n        return rates;\n    }\n}\n\n// File: contracts/margin/impl/OpenWithoutCounterpartyImpl.sol\n\n/**\n * @title OpenWithoutCounterpartyImpl\n * @author dYdX\n *\n * This library contains the implementation for the openWithoutCounterparty\n * function of Margin\n */\nlibrary OpenWithoutCounterpartyImpl {\n\n    // ============ Structs ============\n\n    struct Tx {\n        bytes32 positionId;\n        address positionOwner;\n        address owedToken;\n        address heldToken;\n        address loanOwner;\n        uint256 principal;\n        uint256 deposit;\n        uint32 callTimeLimit;\n        uint32 maxDuration;\n        uint32 interestRate;\n        uint32 interestPeriod;\n    }\n\n    // ============ Events ============\n\n    /**\n     * A position was opened\n     */\n    event PositionOpened(\n        bytes32 indexed positionId,\n        address indexed trader,\n        address indexed lender,\n        bytes32 loanHash,\n        address owedToken,\n        address heldToken,\n        address loanFeeRecipient,\n        uint256 principal,\n        uint256 heldTokenFromSell,\n        uint256 depositAmount,\n        uint256 interestRate,\n        uint32  callTimeLimit,\n        uint32  maxDuration,\n        bool    depositInHeldToken\n    );\n\n    // ============ Public Implementation Functions ============\n\n    function openWithoutCounterpartyImpl(\n        MarginState.State storage state,\n        address[4] addresses,\n        uint256[3] values256,\n        uint32[4]  values32\n    )\n        public\n        returns (bytes32)\n    {\n        Tx memory openTx = parseTx(\n            addresses,\n            values256,\n            values32\n        );\n\n        validate(\n            state,\n            openTx\n        );\n\n        Vault(state.VAULT).transferToVault(\n            openTx.positionId,\n            openTx.heldToken,\n            msg.sender,\n            openTx.deposit\n        );\n\n        recordPositionOpened(\n            openTx\n        );\n\n        doStoreNewPosition(\n            state,\n            openTx\n        );\n\n        return openTx.positionId;\n    }\n\n    // ============ Private Helper-Functions ============\n\n    function doStoreNewPosition(\n        MarginState.State storage state,\n        Tx memory openTx\n    )\n        private\n    {\n        MarginCommon.storeNewPosition(\n            state,\n            openTx.positionId,\n            MarginCommon.Position({\n                owedToken: openTx.owedToken,\n                heldToken: openTx.heldToken,\n                lender: openTx.loanOwner,\n                owner: openTx.positionOwner,\n                principal: openTx.principal,\n                requiredDeposit: 0,\n                callTimeLimit: openTx.callTimeLimit,\n                startTimestamp: 0,\n                callTimestamp: 0,\n                maxDuration: openTx.maxDuration,\n                interestRate: openTx.interestRate,\n                interestPeriod: openTx.interestPeriod\n            }),\n            msg.sender\n        );\n    }\n\n    function validate(\n        MarginState.State storage state,\n        Tx memory openTx\n    )\n        private\n        view\n    {\n        require(\n            !MarginCommon.positionHasExisted(state, openTx.positionId),\n            \"openWithoutCounterpartyImpl#validate: positionId already exists\"\n        );\n\n        require(\n            openTx.principal > 0,\n            \"openWithoutCounterpartyImpl#validate: principal cannot be 0\"\n        );\n\n        require(\n            openTx.owedToken != address(0),\n            \"openWithoutCounterpartyImpl#validate: owedToken cannot be 0\"\n        );\n\n        require(\n            openTx.owedToken != openTx.heldToken,\n            \"openWithoutCounterpartyImpl#validate: owedToken cannot be equal to heldToken\"\n        );\n\n        require(\n            openTx.positionOwner != address(0),\n            \"openWithoutCounterpartyImpl#validate: positionOwner cannot be 0\"\n        );\n\n        require(\n            openTx.loanOwner != address(0),\n            \"openWithoutCounterpartyImpl#validate: loanOwner cannot be 0\"\n        );\n\n        require(\n            openTx.maxDuration > 0,\n            \"openWithoutCounterpartyImpl#validate: maxDuration cannot be 0\"\n        );\n\n        require(\n            openTx.interestPeriod <= openTx.maxDuration,\n            \"openWithoutCounterpartyImpl#validate: interestPeriod must be <= maxDuration\"\n        );\n    }\n\n    function recordPositionOpened(\n        Tx memory openTx\n    )\n        private\n    {\n        emit PositionOpened(\n            openTx.positionId,\n            msg.sender,\n            msg.sender,\n            bytes32(0),\n            openTx.owedToken,\n            openTx.heldToken,\n            address(0),\n            openTx.principal,\n            0,\n            openTx.deposit,\n            openTx.interestRate,\n            openTx.callTimeLimit,\n            openTx.maxDuration,\n            true\n        );\n    }\n\n    // ============ Parsing Functions ============\n\n    function parseTx(\n        address[4] addresses,\n        uint256[3] values256,\n        uint32[4]  values32\n    )\n        private\n        view\n        returns (Tx memory)\n    {\n        Tx memory openTx = Tx({\n            positionId: MarginCommon.getPositionIdFromNonce(values256[2]),\n            positionOwner: addresses[0],\n            owedToken: addresses[1],\n            heldToken: addresses[2],\n            loanOwner: addresses[3],\n            principal: values256[0],\n            deposit: values256[1],\n            callTimeLimit: values32[0],\n            maxDuration: values32[1],\n            interestRate: values32[2],\n            interestPeriod: values32[3]\n        });\n\n        return openTx;\n    }\n}\n\n// File: contracts/margin/impl/PositionGetters.sol\n\n/**\n * @title PositionGetters\n * @author dYdX\n *\n * A collection of public constant getter functions that allows reading of the state of any position\n * stored in the dYdX protocol.\n */\ncontract PositionGetters is MarginStorage {\n    using SafeMath for uint256;\n\n    // ============ Public Constant Functions ============\n\n    /**\n     * Gets if a position is currently open.\n     *\n     * @param  positionId  Unique ID of the position\n     * @return             True if the position is exists and is open\n     */\n    function containsPosition(\n        bytes32 positionId\n    )\n        external\n        view\n        returns (bool)\n    {\n        return MarginCommon.containsPositionImpl(state, positionId);\n    }\n\n    /**\n     * Gets if a position is currently margin-called.\n     *\n     * @param  positionId  Unique ID of the position\n     * @return             True if the position is margin-called\n     */\n    function isPositionCalled(\n        bytes32 positionId\n    )\n        external\n        view\n        returns (bool)\n    {\n        return (state.positions[positionId].callTimestamp > 0);\n    }\n\n    /**\n     * Gets if a position was previously open and is now closed.\n     *\n     * @param  positionId  Unique ID of the position\n     * @return             True if the position is now closed\n     */\n    function isPositionClosed(\n        bytes32 positionId\n    )\n        external\n        view\n        returns (bool)\n    {\n        return state.closedPositions[positionId];\n    }\n\n    /**\n     * Gets the total amount of owedToken ever repaid to the lender for a position.\n     *\n     * @param  positionId  Unique ID of the position\n     * @return             Total amount of owedToken ever repaid\n     */\n    function getTotalOwedTokenRepaidToLender(\n        bytes32 positionId\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return state.totalOwedTokenRepaidToLender[positionId];\n    }\n\n    /**\n     * Gets the amount of heldToken currently locked up in Vault for a particular position.\n     *\n     * @param  positionId  Unique ID of the position\n     * @return             The amount of heldToken\n     */\n    function getPositionBalance(\n        bytes32 positionId\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return MarginCommon.getPositionBalanceImpl(state, positionId);\n    }\n\n    /**\n     * Gets the time until the interest fee charged for the position will increase.\n     * Returns 1 if the interest fee increases every second.\n     * Returns 0 if the interest fee will never increase again.\n     *\n     * @param  positionId  Unique ID of the position\n     * @return             The number of seconds until the interest fee will increase\n     */\n    function getTimeUntilInterestIncrease(\n        bytes32 positionId\n    )\n        external\n        view\n        returns (uint256)\n    {\n        MarginCommon.Position storage position =\n            MarginCommon.getPositionFromStorage(state, positionId);\n\n        uint256 effectiveTimeElapsed = MarginCommon.calculateEffectiveTimeElapsed(\n            position,\n            block.timestamp\n        );\n\n        uint256 absoluteTimeElapsed = block.timestamp.sub(position.startTimestamp);\n        if (absoluteTimeElapsed > effectiveTimeElapsed) { // past maxDuration\n            return 0;\n        } else {\n            // nextStep is the final second at which the calculated interest fee is the same as it\n            // is currently, so add 1 to get the correct value\n            return effectiveTimeElapsed.add(1).sub(absoluteTimeElapsed);\n        }\n    }\n\n    /**\n     * Gets the amount of owedTokens currently needed to close the position completely, including\n     * interest fees.\n     *\n     * @param  positionId  Unique ID of the position\n     * @return             The number of owedTokens\n     */\n    function getPositionOwedAmount(\n        bytes32 positionId\n    )\n        external\n        view\n        returns (uint256)\n    {\n        MarginCommon.Position storage position =\n            MarginCommon.getPositionFromStorage(state, positionId);\n\n        return MarginCommon.calculateOwedAmount(\n            position,\n            position.principal,\n            block.timestamp\n        );\n    }\n\n    /**\n     * Gets the amount of owedTokens needed to close a given principal amount of the position at a\n     * given time, including interest fees.\n     *\n     * @param  positionId         Unique ID of the position\n     * @param  principalToClose   Amount of principal being closed\n     * @param  timestamp          Block timestamp in seconds of close\n     * @return                    The number of owedTokens owed\n     */\n    function getPositionOwedAmountAtTime(\n        bytes32 positionId,\n        uint256 principalToClose,\n        uint32  timestamp\n    )\n        external\n        view\n        returns (uint256)\n    {\n        MarginCommon.Position storage position =\n            MarginCommon.getPositionFromStorage(state, positionId);\n\n        require(\n            timestamp >= position.startTimestamp,\n            \"PositionGetters#getPositionOwedAmountAtTime: Requested time before position started\"\n        );\n\n        return MarginCommon.calculateOwedAmount(\n            position,\n            principalToClose,\n            timestamp\n        );\n    }\n\n    /**\n     * Gets the amount of owedTokens that can be borrowed from a lender to add a given principal\n     * amount to the position at a given time.\n     *\n     * @param  positionId      Unique ID of the position\n     * @param  principalToAdd  Amount being added to principal\n     * @param  timestamp       Block timestamp in seconds of addition\n     * @return                 The number of owedTokens that will be borrowed\n     */\n    function getLenderAmountForIncreasePositionAtTime(\n        bytes32 positionId,\n        uint256 principalToAdd,\n        uint32  timestamp\n    )\n        external\n        view\n        returns (uint256)\n    {\n        MarginCommon.Position storage position =\n            MarginCommon.getPositionFromStorage(state, positionId);\n\n        require(\n            timestamp >= position.startTimestamp,\n            \"PositionGetters#getLenderAmountForIncreasePositionAtTime: timestamp < position start\"\n        );\n\n        return MarginCommon.calculateLenderAmountForIncreasePosition(\n            position,\n            principalToAdd,\n            timestamp\n        );\n    }\n\n    // ============ All Properties ============\n\n    /**\n     * Get a Position by id. This does not validate the position exists. If the position does not\n     * exist, all 0's will be returned.\n     *\n     * @param  positionId  Unique ID of the position\n     * @return             Addresses corresponding to:\n     *\n     *                     [0] = owedToken\n     *                     [1] = heldToken\n     *                     [2] = lender\n     *                     [3] = owner\n     *\n     *                     Values corresponding to:\n     *\n     *                     [0] = principal\n     *                     [1] = requiredDeposit\n     *\n     *                     Values corresponding to:\n     *\n     *                     [0] = callTimeLimit\n     *                     [1] = startTimestamp\n     *                     [2] = callTimestamp\n     *                     [3] = maxDuration\n     *                     [4] = interestRate\n     *                     [5] = interestPeriod\n     */\n    function getPosition(\n        bytes32 positionId\n    )\n        external\n        view\n        returns (\n            address[4],\n            uint256[2],\n            uint32[6]\n        )\n    {\n        MarginCommon.Position storage position = state.positions[positionId];\n\n        return (\n            [\n                position.owedToken,\n                position.heldToken,\n                position.lender,\n                position.owner\n            ],\n            [\n                position.principal,\n                position.requiredDeposit\n            ],\n            [\n                position.callTimeLimit,\n                position.startTimestamp,\n                position.callTimestamp,\n                position.maxDuration,\n                position.interestRate,\n                position.interestPeriod\n            ]\n        );\n    }\n\n    // ============ Individual Properties ============\n\n    function getPositionLender(\n        bytes32 positionId\n    )\n        external\n        view\n        returns (address)\n    {\n        return state.positions[positionId].lender;\n    }\n\n    function getPositionOwner(\n        bytes32 positionId\n    )\n        external\n        view\n        returns (address)\n    {\n        return state.positions[positionId].owner;\n    }\n\n    function getPositionHeldToken(\n        bytes32 positionId\n    )\n        external\n        view\n        returns (address)\n    {\n        return state.positions[positionId].heldToken;\n    }\n\n    function getPositionOwedToken(\n        bytes32 positionId\n    )\n        external\n        view\n        returns (address)\n    {\n        return state.positions[positionId].owedToken;\n    }\n\n    function getPositionPrincipal(\n        bytes32 positionId\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return state.positions[positionId].principal;\n    }\n\n    function getPositionInterestRate(\n        bytes32 positionId\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return state.positions[positionId].interestRate;\n    }\n\n    function getPositionRequiredDeposit(\n        bytes32 positionId\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return state.positions[positionId].requiredDeposit;\n    }\n\n    function getPositionStartTimestamp(\n        bytes32 positionId\n    )\n        external\n        view\n        returns (uint32)\n    {\n        return state.positions[positionId].startTimestamp;\n    }\n\n    function getPositionCallTimestamp(\n        bytes32 positionId\n    )\n        external\n        view\n        returns (uint32)\n    {\n        return state.positions[positionId].callTimestamp;\n    }\n\n    function getPositionCallTimeLimit(\n        bytes32 positionId\n    )\n        external\n        view\n        returns (uint32)\n    {\n        return state.positions[positionId].callTimeLimit;\n    }\n\n    function getPositionMaxDuration(\n        bytes32 positionId\n    )\n        external\n        view\n        returns (uint32)\n    {\n        return state.positions[positionId].maxDuration;\n    }\n\n    function getPositioninterestPeriod(\n        bytes32 positionId\n    )\n        external\n        view\n        returns (uint32)\n    {\n        return state.positions[positionId].interestPeriod;\n    }\n}\n\n// File: contracts/margin/impl/TransferImpl.sol\n\n/**\n * @title TransferImpl\n * @author dYdX\n *\n * This library contains the implementation for the transferPosition and transferLoan functions of\n * Margin\n */\nlibrary TransferImpl {\n\n    // ============ Public Implementation Functions ============\n\n    function transferLoanImpl(\n        MarginState.State storage state,\n        bytes32 positionId,\n        address newLender\n    )\n        public\n    {\n        require(\n            MarginCommon.containsPositionImpl(state, positionId),\n            \"TransferImpl#transferLoanImpl: Position does not exist\"\n        );\n\n        address originalLender = state.positions[positionId].lender;\n\n        require(\n            msg.sender == originalLender,\n            \"TransferImpl#transferLoanImpl: Only lender can transfer ownership\"\n        );\n        require(\n            newLender != originalLender,\n            \"TransferImpl#transferLoanImpl: Cannot transfer ownership to self\"\n        );\n\n        // Doesn't change the state of positionId; figures out the final owner of loan.\n        // That is, newLender may pass ownership to a different address.\n        address finalLender = TransferInternal.grantLoanOwnership(\n            positionId,\n            originalLender,\n            newLender);\n\n        require(\n            finalLender != originalLender,\n            \"TransferImpl#transferLoanImpl: Cannot ultimately transfer ownership to self\"\n        );\n\n        // Set state only after resolving the new owner (to reduce the number of storage calls)\n        state.positions[positionId].lender = finalLender;\n    }\n\n    function transferPositionImpl(\n        MarginState.State storage state,\n        bytes32 positionId,\n        address newOwner\n    )\n        public\n    {\n        require(\n            MarginCommon.containsPositionImpl(state, positionId),\n            \"TransferImpl#transferPositionImpl: Position does not exist\"\n        );\n\n        address originalOwner = state.positions[positionId].owner;\n\n        require(\n            msg.sender == originalOwner,\n            \"TransferImpl#transferPositionImpl: Only position owner can transfer ownership\"\n        );\n        require(\n            newOwner != originalOwner,\n            \"TransferImpl#transferPositionImpl: Cannot transfer ownership to self\"\n        );\n\n        // Doesn't change the state of positionId; figures out the final owner of position.\n        // That is, newOwner may pass ownership to a different address.\n        address finalOwner = TransferInternal.grantPositionOwnership(\n            positionId,\n            originalOwner,\n            newOwner);\n\n        require(\n            finalOwner != originalOwner,\n            \"TransferImpl#transferPositionImpl: Cannot ultimately transfer ownership to self\"\n        );\n\n        // Set state only after resolving the new owner (to reduce the number of storage calls)\n        state.positions[positionId].owner = finalOwner;\n    }\n}\n\n// File: contracts/margin/Margin.sol\n\n/**\n * @title Margin\n * @author dYdX\n *\n * This contract is used to facilitate margin trading as per the dYdX protocol\n */\ncontract Margin is\n    ReentrancyGuard,\n    MarginStorage,\n    MarginEvents,\n    MarginAdmin,\n    LoanGetters,\n    PositionGetters\n{\n\n    using SafeMath for uint256;\n\n    // ============ Constructor ============\n\n    constructor(\n        address vault,\n        address proxy\n    )\n        public\n        MarginAdmin()\n    {\n        state = MarginState.State({\n            VAULT: vault,\n            TOKEN_PROXY: proxy\n        });\n    }\n\n    // ============ Public State Changing Functions ============\n\n    /**\n     * Open a margin position. Called by the margin trader who must provide both a\n     * signed loan offering as well as a DEX Order with which to sell the owedToken.\n     *\n     * @param  addresses           Addresses corresponding to:\n     *\n     *  [0]  = position owner\n     *  [1]  = owedToken\n     *  [2]  = heldToken\n     *  [3]  = loan payer\n     *  [4]  = loan owner\n     *  [5]  = loan taker\n     *  [6]  = loan position owner\n     *  [7]  = loan fee recipient\n     *  [8]  = loan lender fee token\n     *  [9]  = loan taker fee token\n     *  [10]  = exchange wrapper address\n     *\n     * @param  values256           Values corresponding to:\n     *\n     *  [0]  = loan maximum amount\n     *  [1]  = loan minimum amount\n     *  [2]  = loan minimum heldToken\n     *  [3]  = loan lender fee\n     *  [4]  = loan taker fee\n     *  [5]  = loan expiration timestamp (in seconds)\n     *  [6]  = loan salt\n     *  [7]  = position amount of principal\n     *  [8]  = deposit amount\n     *  [9]  = nonce (used to calculate positionId)\n     *\n     * @param  values32            Values corresponding to:\n     *\n     *  [0] = loan call time limit (in seconds)\n     *  [1] = loan maxDuration (in seconds)\n     *  [2] = loan interest rate (annual nominal percentage times 10**6)\n     *  [3] = loan interest update period (in seconds)\n     *\n     * @param  depositInHeldToken  True if the trader wishes to pay the margin deposit in heldToken.\n     *                             False if the margin deposit will be in owedToken\n     *                             and then sold along with the owedToken borrowed from the lender\n     * @param  signature           If loan payer is an account, then this must be the tightly-packed\n     *                             ECDSA V/R/S parameters from signing the loan hash. If loan payer\n     *                             is a smart contract, these are arbitrary bytes that the contract\n     *                             will recieve when choosing whether to approve the loan.\n     * @param  order               Order object to be passed to the exchange wrapper\n     * @return                     Unique ID for the new position\n     */\n    function openPosition(\n        address[11] addresses,\n        uint256[10] values256,\n        uint32[4]   values32,\n        bool        depositInHeldToken,\n        bytes       signature,\n        bytes       order\n    )\n        external\n        onlyWhileOperational\n        nonReentrant\n        returns (bytes32)\n    {\n        return OpenPositionImpl.openPositionImpl(\n            state,\n            addresses,\n            values256,\n            values32,\n            depositInHeldToken,\n            signature,\n            order\n        );\n    }\n\n    /**\n     * Open a margin position without a counterparty. The caller will serve as both the\n     * lender and the position owner\n     *\n     * @param  addresses    Addresses corresponding to:\n     *\n     *  [0]  = position owner\n     *  [1]  = owedToken\n     *  [2]  = heldToken\n     *  [3]  = loan owner\n     *\n     * @param  values256    Values corresponding to:\n     *\n     *  [0]  = principal\n     *  [1]  = deposit amount\n     *  [2]  = nonce (used to calculate positionId)\n     *\n     * @param  values32     Values corresponding to:\n     *\n     *  [0] = call time limit (in seconds)\n     *  [1] = maxDuration (in seconds)\n     *  [2] = interest rate (annual nominal percentage times 10**6)\n     *  [3] = interest update period (in seconds)\n     *\n     * @return              Unique ID for the new position\n     */\n    function openWithoutCounterparty(\n        address[4] addresses,\n        uint256[3] values256,\n        uint32[4]  values32\n    )\n        external\n        onlyWhileOperational\n        nonReentrant\n        returns (bytes32)\n    {\n        return OpenWithoutCounterpartyImpl.openWithoutCounterpartyImpl(\n            state,\n            addresses,\n            values256,\n            values32\n        );\n    }\n\n    /**\n     * Increase the size of a position. Funds will be borrowed from the loan payer and sold as per\n     * the position. The amount of owedToken borrowed from the lender will be >= the amount of\n     * principal added, as it will incorporate interest already earned by the position so far.\n     *\n     * @param  positionId          Unique ID of the position\n     * @param  addresses           Addresses corresponding to:\n     *\n     *  [0]  = loan payer\n     *  [1]  = loan taker\n     *  [2]  = loan position owner\n     *  [3]  = loan fee recipient\n     *  [4]  = loan lender fee token\n     *  [5]  = loan taker fee token\n     *  [6]  = exchange wrapper address\n     *\n     * @param  values256           Values corresponding to:\n     *\n     *  [0]  = loan maximum amount\n     *  [1]  = loan minimum amount\n     *  [2]  = loan minimum heldToken\n     *  [3]  = loan lender fee\n     *  [4]  = loan taker fee\n     *  [5]  = loan expiration timestamp (in seconds)\n     *  [6]  = loan salt\n     *  [7]  = amount of principal to add to the position (NOTE: the amount pulled from the lender\n     *                                                           will be >= this amount)\n     *\n     * @param  values32            Values corresponding to:\n     *\n     *  [0] = loan call time limit (in seconds)\n     *  [1] = loan maxDuration (in seconds)\n     *\n     * @param  depositInHeldToken  True if the trader wishes to pay the margin deposit in heldToken.\n     *                             False if the margin deposit will be pulled in owedToken\n     *                             and then sold along with the owedToken borrowed from the lender\n     * @param  signature           If loan payer is an account, then this must be the tightly-packed\n     *                             ECDSA V/R/S parameters from signing the loan hash. If loan payer\n     *                             is a smart contract, these are arbitrary bytes that the contract\n     *                             will recieve when choosing whether to approve the loan.\n     * @param  order               Order object to be passed to the exchange wrapper\n     * @return                     Amount of owedTokens pulled from the lender\n     */\n    function increasePosition(\n        bytes32    positionId,\n        address[7] addresses,\n        uint256[8] values256,\n        uint32[2]  values32,\n        bool       depositInHeldToken,\n        bytes      signature,\n        bytes      order\n    )\n        external\n        onlyWhileOperational\n        nonReentrant\n        returns (uint256)\n    {\n        return IncreasePositionImpl.increasePositionImpl(\n            state,\n            positionId,\n            addresses,\n            values256,\n            values32,\n            depositInHeldToken,\n            signature,\n            order\n        );\n    }\n\n    /**\n     * Increase a position directly by putting up heldToken. The caller will serve as both the\n     * lender and the position owner\n     *\n     * @param  positionId      Unique ID of the position\n     * @param  principalToAdd  Principal amount to add to the position\n     * @return                 Amount of heldToken pulled from the msg.sender\n     */\n    function increaseWithoutCounterparty(\n        bytes32 positionId,\n        uint256 principalToAdd\n    )\n        external\n        onlyWhileOperational\n        nonReentrant\n        returns (uint256)\n    {\n        return IncreasePositionImpl.increaseWithoutCounterpartyImpl(\n            state,\n            positionId,\n            principalToAdd\n        );\n    }\n\n    /**\n     * Close a position. May be called by the owner or with the approval of the owner. May provide\n     * an order and exchangeWrapper to facilitate the closing of the position. The payoutRecipient\n     * is sent the resulting payout.\n     *\n     * @param  positionId            Unique ID of the position\n     * @param  requestedCloseAmount  Principal amount of the position to close. The actual amount\n     *                               closed is also bounded by:\n     *                               1) The principal of the position\n     *                               2) The amount allowed by the owner if closer != owner\n     * @param  payoutRecipient       Address of the recipient of tokens paid out from closing\n     * @param  exchangeWrapper       Address of the exchange wrapper\n     * @param  payoutInHeldToken     True to pay out the payoutRecipient in heldToken,\n     *                               False to pay out the payoutRecipient in owedToken\n     * @param  order                 Order object to be passed to the exchange wrapper\n     * @return                       Values corresponding to:\n     *                               1) Principal of position closed\n     *                               2) Amount of tokens (heldToken if payoutInHeldtoken is true,\n     *                                  owedToken otherwise) received by the payoutRecipient\n     *                               3) Amount of owedToken paid (incl. interest fee) to the lender\n     */\n    function closePosition(\n        bytes32 positionId,\n        uint256 requestedCloseAmount,\n        address payoutRecipient,\n        address exchangeWrapper,\n        bool    payoutInHeldToken,\n        bytes   order\n    )\n        external\n        closePositionStateControl\n        nonReentrant\n        returns (uint256, uint256, uint256)\n    {\n        return ClosePositionImpl.closePositionImpl(\n            state,\n            positionId,\n            requestedCloseAmount,\n            payoutRecipient,\n            exchangeWrapper,\n            payoutInHeldToken,\n            order\n        );\n    }\n\n    /**\n     * Helper to close a position by paying owedToken directly rather than using an exchangeWrapper.\n     *\n     * @param  positionId            Unique ID of the position\n     * @param  requestedCloseAmount  Principal amount of the position to close. The actual amount\n     *                               closed is also bounded by:\n     *                               1) The principal of the position\n     *                               2) The amount allowed by the owner if closer != owner\n     * @param  payoutRecipient       Address of the recipient of tokens paid out from closing\n     * @return                       Values corresponding to:\n     *                               1) Principal amount of position closed\n     *                               2) Amount of heldToken received by the payoutRecipient\n     *                               3) Amount of owedToken paid (incl. interest fee) to the lender\n     */\n    function closePositionDirectly(\n        bytes32 positionId,\n        uint256 requestedCloseAmount,\n        address payoutRecipient\n    )\n        external\n        closePositionDirectlyStateControl\n        nonReentrant\n        returns (uint256, uint256, uint256)\n    {\n        return ClosePositionImpl.closePositionImpl(\n            state,\n            positionId,\n            requestedCloseAmount,\n            payoutRecipient,\n            address(0),\n            true,\n            new bytes(0)\n        );\n    }\n\n    /**\n     * Reduce the size of a position and withdraw a proportional amount of heldToken from the vault.\n     * Must be approved by both the position owner and lender.\n     *\n     * @param  positionId            Unique ID of the position\n     * @param  requestedCloseAmount  Principal amount of the position to close. The actual amount\n     *                               closed is also bounded by:\n     *                               1) The principal of the position\n     *                               2) The amount allowed by the owner if closer != owner\n     *                               3) The amount allowed by the lender if closer != lender\n     * @return                       Values corresponding to:\n     *                               1) Principal amount of position closed\n     *                               2) Amount of heldToken received by the msg.sender\n     */\n    function closeWithoutCounterparty(\n        bytes32 positionId,\n        uint256 requestedCloseAmount,\n        address payoutRecipient\n    )\n        external\n        closePositionStateControl\n        nonReentrant\n        returns (uint256, uint256)\n    {\n        return CloseWithoutCounterpartyImpl.closeWithoutCounterpartyImpl(\n            state,\n            positionId,\n            requestedCloseAmount,\n            payoutRecipient\n        );\n    }\n\n    /**\n     * Margin-call a position. Only callable with the approval of the position lender. After the\n     * call, the position owner will have time equal to the callTimeLimit of the position to close\n     * the position. If the owner does not close the position, the lender can recover the collateral\n     * in the position.\n     *\n     * @param  positionId       Unique ID of the position\n     * @param  requiredDeposit  Amount of deposit the position owner will have to put up to cancel\n     *                          the margin-call. Passing in 0 means the margin call cannot be\n     *                          canceled by depositing\n     */\n    function marginCall(\n        bytes32 positionId,\n        uint256 requiredDeposit\n    )\n        external\n        nonReentrant\n    {\n        LoanImpl.marginCallImpl(\n            state,\n            positionId,\n            requiredDeposit\n        );\n    }\n\n    /**\n     * Cancel a margin-call. Only callable with the approval of the position lender.\n     *\n     * @param  positionId  Unique ID of the position\n     */\n    function cancelMarginCall(\n        bytes32 positionId\n    )\n        external\n        onlyWhileOperational\n        nonReentrant\n    {\n        LoanImpl.cancelMarginCallImpl(state, positionId);\n    }\n\n    /**\n     * Used to recover the heldTokens held as collateral. Is callable after the maximum duration of\n     * the loan has expired or the loan has been margin-called for the duration of the callTimeLimit\n     * but remains unclosed. Only callable with the approval of the position lender.\n     *\n     * @param  positionId  Unique ID of the position\n     * @param  recipient   Address to send the recovered tokens to\n     * @return             Amount of heldToken recovered\n     */\n    function forceRecoverCollateral(\n        bytes32 positionId,\n        address recipient\n    )\n        external\n        nonReentrant\n        returns (uint256)\n    {\n        return ForceRecoverCollateralImpl.forceRecoverCollateralImpl(\n            state,\n            positionId,\n            recipient\n        );\n    }\n\n    /**\n     * Deposit additional heldToken as collateral for a position. Cancels margin-call if:\n     * 0 < position.requiredDeposit < depositAmount. Only callable by the position owner.\n     *\n     * @param  positionId       Unique ID of the position\n     * @param  depositAmount    Additional amount in heldToken to deposit\n     */\n    function depositCollateral(\n        bytes32 positionId,\n        uint256 depositAmount\n    )\n        external\n        onlyWhileOperational\n        nonReentrant\n    {\n        DepositCollateralImpl.depositCollateralImpl(\n            state,\n            positionId,\n            depositAmount\n        );\n    }\n\n    /**\n     * Cancel an amount of a loan offering. Only callable by the loan offering's payer.\n     *\n     * @param  addresses     Array of addresses:\n     *\n     *  [0] = owedToken\n     *  [1] = heldToken\n     *  [2] = loan payer\n     *  [3] = loan owner\n     *  [4] = loan taker\n     *  [5] = loan position owner\n     *  [6] = loan fee recipient\n     *  [7] = loan lender fee token\n     *  [8] = loan taker fee token\n     *\n     * @param  values256     Values corresponding to:\n     *\n     *  [0] = loan maximum amount\n     *  [1] = loan minimum amount\n     *  [2] = loan minimum heldToken\n     *  [3] = loan lender fee\n     *  [4] = loan taker fee\n     *  [5] = loan expiration timestamp (in seconds)\n     *  [6] = loan salt\n     *\n     * @param  values32      Values corresponding to:\n     *\n     *  [0] = loan call time limit (in seconds)\n     *  [1] = loan maxDuration (in seconds)\n     *  [2] = loan interest rate (annual nominal percentage times 10**6)\n     *  [3] = loan interest update period (in seconds)\n     *\n     * @param  cancelAmount  Amount to cancel\n     * @return               Amount that was canceled\n     */\n    function cancelLoanOffering(\n        address[9] addresses,\n        uint256[7]  values256,\n        uint32[4]   values32,\n        uint256     cancelAmount\n    )\n        external\n        cancelLoanOfferingStateControl\n        nonReentrant\n        returns (uint256)\n    {\n        return LoanImpl.cancelLoanOfferingImpl(\n            state,\n            addresses,\n            values256,\n            values32,\n            cancelAmount\n        );\n    }\n\n    /**\n     * Transfer ownership of a loan to a new address. This new address will be entitled to all\n     * payouts for this loan. Only callable by the lender for a position. If \"who\" is a contract, it\n     * must implement the LoanOwner interface.\n     *\n     * @param  positionId  Unique ID of the position\n     * @param  who         New owner of the loan\n     */\n    function transferLoan(\n        bytes32 positionId,\n        address who\n    )\n        external\n        nonReentrant\n    {\n        TransferImpl.transferLoanImpl(\n            state,\n            positionId,\n            who);\n    }\n\n    /**\n     * Transfer ownership of a position to a new address. This new address will be entitled to all\n     * payouts. Only callable by the owner of a position. If \"who\" is a contract, it must implement\n     * the PositionOwner interface.\n     *\n     * @param  positionId  Unique ID of the position\n     * @param  who         New owner of the position\n     */\n    function transferPosition(\n        bytes32 positionId,\n        address who\n    )\n        external\n        nonReentrant\n    {\n        TransferImpl.transferPositionImpl(\n            state,\n            positionId,\n            who);\n    }\n\n    // ============ Public Constant Functions ============\n\n    /**\n     * Gets the address of the Vault contract that holds and accounts for tokens.\n     *\n     * @return  The address of the Vault contract\n     */\n    function getVaultAddress()\n        external\n        view\n        returns (address)\n    {\n        return state.VAULT;\n    }\n\n    /**\n     * Gets the address of the TokenProxy contract that accounts must set allowance on in order to\n     * make loans or open/close positions.\n     *\n     * @return  The address of the TokenProxy contract\n     */\n    function getTokenProxyAddress()\n        external\n        view\n        returns (address)\n    {\n        return state.TOKEN_PROXY;\n    }\n}\n\n// File: contracts/margin/interfaces/OnlyMargin.sol\n\n/**\n * @title OnlyMargin\n * @author dYdX\n *\n * Contract to store the address of the main Margin contract and trust only that address to call\n * certain functions.\n */\ncontract OnlyMargin {\n\n    // ============ Constants ============\n\n    // Address of the known and trusted Margin contract on the blockchain\n    address public DYDX_MARGIN;\n\n    // ============ Constructor ============\n\n    constructor(\n        address margin\n    )\n        public\n    {\n        DYDX_MARGIN = margin;\n    }\n\n    // ============ Modifiers ============\n\n    modifier onlyMargin()\n    {\n        require(\n            msg.sender == DYDX_MARGIN,\n            \"OnlyMargin#onlyMargin: Only Margin can call\"\n        );\n\n        _;\n    }\n}\n\n// File: contracts/margin/external/lib/LoanOfferingParser.sol\n\n/**\n * @title LoanOfferingParser\n * @author dYdX\n *\n * Contract for LoanOfferingVerifiers to parse arguments\n */\ncontract LoanOfferingParser {\n\n    // ============ Parsing Functions ============\n\n    function parseLoanOffering(\n        address[9] addresses,\n        uint256[7] values256,\n        uint32[4] values32,\n        bytes signature\n    )\n        internal\n        pure\n        returns (MarginCommon.LoanOffering memory)\n    {\n        MarginCommon.LoanOffering memory loanOffering;\n\n        fillLoanOfferingAddresses(loanOffering, addresses);\n        fillLoanOfferingValues256(loanOffering, values256);\n        fillLoanOfferingValues32(loanOffering, values32);\n        loanOffering.signature = signature;\n\n        return loanOffering;\n    }\n\n    function fillLoanOfferingAddresses(\n        MarginCommon.LoanOffering memory loanOffering,\n        address[9] addresses\n    )\n        private\n        pure\n    {\n        loanOffering.owedToken = addresses[0];\n        loanOffering.heldToken = addresses[1];\n        loanOffering.payer = addresses[2];\n        loanOffering.owner = addresses[3];\n        loanOffering.taker = addresses[4];\n        loanOffering.positionOwner = addresses[5];\n        loanOffering.feeRecipient = addresses[6];\n        loanOffering.lenderFeeToken = addresses[7];\n        loanOffering.takerFeeToken = addresses[8];\n    }\n\n    function fillLoanOfferingValues256(\n        MarginCommon.LoanOffering memory loanOffering,\n        uint256[7] values256\n    )\n        private\n        pure\n    {\n        loanOffering.rates.maxAmount = values256[0];\n        loanOffering.rates.minAmount = values256[1];\n        loanOffering.rates.minHeldToken = values256[2];\n        loanOffering.rates.lenderFee = values256[3];\n        loanOffering.rates.takerFee = values256[4];\n        loanOffering.expirationTimestamp = values256[5];\n        loanOffering.salt = values256[6];\n    }\n\n    function fillLoanOfferingValues32(\n        MarginCommon.LoanOffering memory loanOffering,\n        uint32[4] values32\n    )\n        private\n        pure\n    {\n        loanOffering.callTimeLimit = values32[0];\n        loanOffering.maxDuration = values32[1];\n        loanOffering.rates.interestRate = values32[2];\n        loanOffering.rates.interestPeriod = values32[3];\n    }\n}\n\n// File: contracts/margin/external/lib/MarginHelper.sol\n\n/**\n * @title MarginHelper\n * @author dYdX\n *\n * This library contains helper functions for interacting with Margin\n */\nlibrary MarginHelper {\n    function getPosition(\n        address DYDX_MARGIN,\n        bytes32 positionId\n    )\n        internal\n        view\n        returns (MarginCommon.Position memory)\n    {\n        (\n            address[4] memory addresses,\n            uint256[2] memory values256,\n            uint32[6]  memory values32\n        ) = Margin(DYDX_MARGIN).getPosition(positionId);\n\n        return MarginCommon.Position({\n            owedToken: addresses[0],\n            heldToken: addresses[1],\n            lender: addresses[2],\n            owner: addresses[3],\n            principal: values256[0],\n            requiredDeposit: values256[1],\n            callTimeLimit: values32[0],\n            startTimestamp: values32[1],\n            callTimestamp: values32[2],\n            maxDuration: values32[3],\n            interestRate: values32[4],\n            interestPeriod: values32[5]\n        });\n    }\n}\n\n// File: contracts/margin/external/BucketLender/BucketLender.sol\n\n/* solium-disable-next-line max-len*/\n\n/**\n * @title BucketLender\n * @author dYdX\n *\n * On-chain shared lender that allows anyone to deposit tokens into this contract to be used to\n * lend tokens for a particular margin position.\n *\n * - Each bucket has three variables:\n *   - Available Amount\n *     - The available amount of tokens that the bucket has to lend out\n *   - Outstanding Principal\n *     - The amount of principal that the bucket is responsible for in the margin position\n *   - Weight\n *     - Used to keep track of each account's weighted ownership within a bucket\n *     - Relative weight between buckets is meaningless\n *     - Only accounts' relative weight within a bucket matters\n *\n * - Token Deposits:\n *   - Go into a particular bucket, determined by time since the start of the position\n *     - If the position has not started: bucket = 0\n *     - If the position has started:     bucket = ceiling(time_since_start / BUCKET_TIME)\n *     - This is always the highest bucket; no higher bucket yet exists\n *   - Increase the bucket's Available Amount\n *   - Increase the bucket's weight and the account's weight in that bucket\n *\n * - Token Withdrawals:\n *   - Can be from any bucket with available amount\n *   - Decrease the bucket's Available Amount\n *   - Decrease the bucket's weight and the account's weight in that bucket\n *\n * - Increasing the Position (Lending):\n *   - The lowest buckets with Available Amount are used first\n *   - Decreases Available Amount\n *   - Increases Outstanding Principal\n *\n * - Decreasing the Position (Being Paid-Back)\n *   - The highest buckets with Outstanding Principal are paid back first\n *   - Decreases Outstanding Principal\n *   - Increases Available Amount\n *\n *\n * - Over time, this gives highest interest rates to earlier buckets, but disallows withdrawals from\n *   those buckets for a longer period of time.\n * - Deposits in the same bucket earn the same interest rate.\n * - Lenders can withdraw their funds at any time if they are not being lent (and are therefore not\n *   making the maximum interest).\n * - The highest bucket with Outstanding Principal is always less-than-or-equal-to the lowest bucket\n     with Available Amount\n */\ncontract BucketLender is\n    Ownable,\n    OnlyMargin,\n    LoanOwner,\n    IncreaseLoanDelegator,\n    MarginCallDelegator,\n    CancelMarginCallDelegator,\n    ForceRecoverCollateralDelegator,\n    LoanOfferingParser,\n    LoanOfferingVerifier,\n    ReentrancyGuard\n{\n    using SafeMath for uint256;\n    using TokenInteract for address;\n\n    // ============ Events ============\n\n    event Deposit(\n        address indexed beneficiary,\n        uint256 bucket,\n        uint256 amount,\n        uint256 weight\n    );\n\n    event Withdraw(\n        address indexed withdrawer,\n        uint256 bucket,\n        uint256 weight,\n        uint256 owedTokenWithdrawn,\n        uint256 heldTokenWithdrawn\n    );\n\n    event PrincipalIncreased(\n        uint256 principalTotal,\n        uint256 bucketNumber,\n        uint256 principalForBucket,\n        uint256 amount\n    );\n\n    event PrincipalDecreased(\n        uint256 principalTotal,\n        uint256 bucketNumber,\n        uint256 principalForBucket,\n        uint256 amount\n    );\n\n    event AvailableIncreased(\n        uint256 availableTotal,\n        uint256 bucketNumber,\n        uint256 availableForBucket,\n        uint256 amount\n    );\n\n    event AvailableDecreased(\n        uint256 availableTotal,\n        uint256 bucketNumber,\n        uint256 availableForBucket,\n        uint256 amount\n    );\n\n    // ============ State Variables ============\n\n    /**\n     * Available Amount is the amount of tokens that is available to be lent by each bucket.\n     * These tokens are also available to be withdrawn by the accounts that have weight in the\n     * bucket.\n     */\n    // Available Amount for each bucket\n    mapping(uint256 => uint256) public availableForBucket;\n\n    // Total Available Amount\n    uint256 public availableTotal;\n\n    /**\n     * Outstanding Principal is the share of the margin position's principal that each bucket\n     * is responsible for. That is, each bucket with Outstanding Principal is owed\n     * (Outstanding Principal)*E^(RT) owedTokens in repayment.\n     */\n    // Outstanding Principal for each bucket\n    mapping(uint256 => uint256) public principalForBucket;\n\n    // Total Outstanding Principal\n    uint256 public principalTotal;\n\n    /**\n     * Weight determines an account's proportional share of a bucket. Relative weights have no\n     * meaning if they are not for the same bucket. Likewise, the relative weight of two buckets has\n     * no meaning. However, the relative weight of two accounts within the same bucket is equal to\n     * the accounts' shares in the bucket and are therefore proportional to the payout that they\n     * should expect from withdrawing from that bucket.\n     */\n    // Weight for each account in each bucket\n    mapping(uint256 => mapping(address => uint256)) public weightForBucketForAccount;\n\n    // Total Weight for each bucket\n    mapping(uint256 => uint256) public weightForBucket;\n\n    /**\n     * The critical bucket is:\n     * - Greater-than-or-equal-to The highest bucket with Outstanding Principal\n     * - Less-than-or-equal-to the lowest bucket with Available Amount\n     *\n     * It is equal to both of these values in most cases except in an edge cases where the two\n     * buckets are different. This value is cached to find such a bucket faster than looping through\n     * all possible buckets.\n     */\n    uint256 public criticalBucket = 0;\n\n    /**\n     * Latest cached value for totalOwedTokenRepaidToLender.\n     * This number updates on the dYdX Margin base protocol whenever the position is\n     * partially-closed, but this contract is not notified at that time. Therefore, it is updated\n     * upon increasing the position or when depositing/withdrawing\n     */\n    uint256 public cachedRepaidAmount = 0;\n\n    // True if the position was closed from force-recovering the collateral\n    bool public wasForceClosed = false;\n\n    // ============ Constants ============\n\n    // Unique ID of the position\n    bytes32 public POSITION_ID;\n\n    // Address of the token held in the position as collateral\n    address public HELD_TOKEN;\n\n    // Address of the token being lent\n    address public OWED_TOKEN;\n\n    // Time between new buckets\n    uint32 public BUCKET_TIME;\n\n    // Interest rate of the position\n    uint32 public INTEREST_RATE;\n\n    // Interest period of the position\n    uint32 public INTEREST_PERIOD;\n\n    // Maximum duration of the position\n    uint32 public MAX_DURATION;\n\n    // Margin-call time-limit of the position\n    uint32 public CALL_TIMELIMIT;\n\n    // (NUMERATOR/DENOMINATOR) denotes the minimum collateralization ratio of the position\n    uint32 public MIN_HELD_TOKEN_NUMERATOR;\n    uint32 public MIN_HELD_TOKEN_DENOMINATOR;\n\n    // Accounts that are permitted to margin-call positions (or cancel the margin call)\n    mapping(address => bool) public TRUSTED_MARGIN_CALLERS;\n\n    // Accounts that are permitted to withdraw on behalf of any address\n    mapping(address => bool) public TRUSTED_WITHDRAWERS;\n\n    // ============ Constructor ============\n\n    constructor(\n        address margin,\n        bytes32 positionId,\n        address heldToken,\n        address owedToken,\n        uint32[7] parameters,\n        address[] trustedMarginCallers,\n        address[] trustedWithdrawers\n    )\n        public\n        OnlyMargin(margin)\n    {\n        POSITION_ID = positionId;\n        HELD_TOKEN = heldToken;\n        OWED_TOKEN = owedToken;\n\n        require(\n            parameters[0] != 0,\n            \"BucketLender#constructor: BUCKET_TIME cannot be zero\"\n        );\n        BUCKET_TIME = parameters[0];\n        INTEREST_RATE = parameters[1];\n        INTEREST_PERIOD = parameters[2];\n        MAX_DURATION = parameters[3];\n        CALL_TIMELIMIT = parameters[4];\n        MIN_HELD_TOKEN_NUMERATOR = parameters[5];\n        MIN_HELD_TOKEN_DENOMINATOR = parameters[6];\n\n        // Initialize TRUSTED_MARGIN_CALLERS and TRUSTED_WITHDRAWERS\n        uint256 i = 0;\n        for (i = 0; i < trustedMarginCallers.length; i++) {\n            TRUSTED_MARGIN_CALLERS[trustedMarginCallers[i]] = true;\n        }\n        for (i = 0; i < trustedWithdrawers.length; i++) {\n            TRUSTED_WITHDRAWERS[trustedWithdrawers[i]] = true;\n        }\n\n        // Set maximum allowance on proxy\n        OWED_TOKEN.approve(\n            Margin(margin).getTokenProxyAddress(),\n            MathHelpers.maxUint256()\n        );\n    }\n\n    // ============ Modifiers ============\n\n    modifier onlyPosition(bytes32 positionId) {\n        require(\n            POSITION_ID == positionId,\n            \"BucketLender#onlyPosition: Incorrect position\"\n        );\n        _;\n    }\n\n    // ============ Margin-Only State-Changing Functions ============\n\n    /**\n     * Function a smart contract must implement to be able to consent to a loan. The loan offering\n     * will be generated off-chain. The \"loan owner\" address will own the loan-side of the resulting\n     * position.\n     *\n     * @param  addresses    Loan offering addresses\n     * @param  values256    Loan offering uint256s\n     * @param  values32     Loan offering uint32s\n     * @param  positionId   Unique ID of the position\n     * @param  signature    Arbitrary bytes\n     * @return              This address to accept, a different address to ask that contract\n     */\n    function verifyLoanOffering(\n        address[9] addresses,\n        uint256[7] values256,\n        uint32[4] values32,\n        bytes32 positionId,\n        bytes signature\n    )\n        external\n        onlyMargin\n        nonReentrant\n        onlyPosition(positionId)\n        returns (address)\n    {\n        require(\n            Margin(DYDX_MARGIN).containsPosition(POSITION_ID),\n            \"BucketLender#verifyLoanOffering: This contract should not open a new position\"\n        );\n\n        MarginCommon.LoanOffering memory loanOffering = parseLoanOffering(\n            addresses,\n            values256,\n            values32,\n            signature\n        );\n\n        // CHECK ADDRESSES\n        assert(loanOffering.owedToken == OWED_TOKEN);\n        assert(loanOffering.heldToken == HELD_TOKEN);\n        assert(loanOffering.payer == address(this));\n        assert(loanOffering.owner == address(this));\n        require(\n            loanOffering.taker == address(0),\n            \"BucketLender#verifyLoanOffering: loanOffering.taker is non-zero\"\n        );\n        require(\n            loanOffering.feeRecipient == address(0),\n            \"BucketLender#verifyLoanOffering: loanOffering.feeRecipient is non-zero\"\n        );\n        require(\n            loanOffering.positionOwner == address(0),\n            \"BucketLender#verifyLoanOffering: loanOffering.positionOwner is non-zero\"\n        );\n        require(\n            loanOffering.lenderFeeToken == address(0),\n            \"BucketLender#verifyLoanOffering: loanOffering.lenderFeeToken is non-zero\"\n        );\n        require(\n            loanOffering.takerFeeToken == address(0),\n            \"BucketLender#verifyLoanOffering: loanOffering.takerFeeToken is non-zero\"\n        );\n\n        // CHECK VALUES256\n        require(\n            loanOffering.rates.maxAmount == MathHelpers.maxUint256(),\n            \"BucketLender#verifyLoanOffering: loanOffering.maxAmount is incorrect\"\n        );\n        require(\n            loanOffering.rates.minAmount == 0,\n            \"BucketLender#verifyLoanOffering: loanOffering.minAmount is non-zero\"\n        );\n        require(\n            loanOffering.rates.minHeldToken == 0,\n            \"BucketLender#verifyLoanOffering: loanOffering.minHeldToken is non-zero\"\n        );\n        require(\n            loanOffering.rates.lenderFee == 0,\n            \"BucketLender#verifyLoanOffering: loanOffering.lenderFee is non-zero\"\n        );\n        require(\n            loanOffering.rates.takerFee == 0,\n            \"BucketLender#verifyLoanOffering: loanOffering.takerFee is non-zero\"\n        );\n        require(\n            loanOffering.expirationTimestamp == MathHelpers.maxUint256(),\n            \"BucketLender#verifyLoanOffering: expirationTimestamp is incorrect\"\n        );\n        require(\n            loanOffering.salt == 0,\n            \"BucketLender#verifyLoanOffering: loanOffering.salt is non-zero\"\n        );\n\n        // CHECK VALUES32\n        require(\n            loanOffering.callTimeLimit == MathHelpers.maxUint32(),\n            \"BucketLender#verifyLoanOffering: loanOffering.callTimelimit is incorrect\"\n        );\n        require(\n            loanOffering.maxDuration == MathHelpers.maxUint32(),\n            \"BucketLender#verifyLoanOffering: loanOffering.maxDuration is incorrect\"\n        );\n        assert(loanOffering.rates.interestRate == INTEREST_RATE);\n        assert(loanOffering.rates.interestPeriod == INTEREST_PERIOD);\n\n        // no need to require anything about loanOffering.signature\n\n        return address(this);\n    }\n\n    /**\n     * Called by the Margin contract when anyone transfers ownership of a loan to this contract.\n     * This function initializes this contract and returns this address to indicate to Margin\n     * that it is willing to take ownership of the loan.\n     *\n     * @param  from        Address of the previous owner\n     * @param  positionId  Unique ID of the position\n     * @return             This address on success, throw otherwise\n     */\n    function receiveLoanOwnership(\n        address from,\n        bytes32 positionId\n    )\n        external\n        onlyMargin\n        nonReentrant\n        onlyPosition(positionId)\n        returns (address)\n    {\n        MarginCommon.Position memory position = MarginHelper.getPosition(DYDX_MARGIN, POSITION_ID);\n        uint256 initialPrincipal = position.principal;\n        uint256 minHeldToken = MathHelpers.getPartialAmount(\n            uint256(MIN_HELD_TOKEN_NUMERATOR),\n            uint256(MIN_HELD_TOKEN_DENOMINATOR),\n            initialPrincipal\n        );\n\n        assert(initialPrincipal > 0);\n        assert(principalTotal == 0);\n        assert(from != address(this)); // position must be opened without lending from this position\n\n        require(\n            position.owedToken == OWED_TOKEN,\n            \"BucketLender#receiveLoanOwnership: Position owedToken mismatch\"\n        );\n        require(\n            position.heldToken == HELD_TOKEN,\n            \"BucketLender#receiveLoanOwnership: Position heldToken mismatch\"\n        );\n        require(\n            position.maxDuration == MAX_DURATION,\n            \"BucketLender#receiveLoanOwnership: Position maxDuration mismatch\"\n        );\n        require(\n            position.callTimeLimit == CALL_TIMELIMIT,\n            \"BucketLender#receiveLoanOwnership: Position callTimeLimit mismatch\"\n        );\n        require(\n            position.interestRate == INTEREST_RATE,\n            \"BucketLender#receiveLoanOwnership: Position interestRate mismatch\"\n        );\n        require(\n            position.interestPeriod == INTEREST_PERIOD,\n            \"BucketLender#receiveLoanOwnership: Position interestPeriod mismatch\"\n        );\n        require(\n            Margin(DYDX_MARGIN).getPositionBalance(POSITION_ID) >= minHeldToken,\n            \"BucketLender#receiveLoanOwnership: Not enough heldToken as collateral\"\n        );\n\n        // set relevant constants\n        principalForBucket[0] = initialPrincipal;\n        principalTotal = initialPrincipal;\n        weightForBucket[0] = weightForBucket[0].add(initialPrincipal);\n        weightForBucketForAccount[0][from] =\n            weightForBucketForAccount[0][from].add(initialPrincipal);\n\n        return address(this);\n    }\n\n    /**\n     * Called by Margin when additional value is added onto the position this contract\n     * is lending for. Balance is added to the address that loaned the additional tokens.\n     *\n     * @param  payer           Address that loaned the additional tokens\n     * @param  positionId      Unique ID of the position\n     * @param  principalAdded  Amount that was added to the position\n     * @param  lentAmount      Amount of owedToken lent\n     * @return                 This address to accept, a different address to ask that contract\n     */\n    function increaseLoanOnBehalfOf(\n        address payer,\n        bytes32 positionId,\n        uint256 principalAdded,\n        uint256 lentAmount\n    )\n        external\n        onlyMargin\n        nonReentrant\n        onlyPosition(positionId)\n        returns (address)\n    {\n        Margin margin = Margin(DYDX_MARGIN);\n\n        require(\n            payer == address(this),\n            \"BucketLender#increaseLoanOnBehalfOf: Other lenders cannot lend for this position\"\n        );\n        require(\n            !margin.isPositionCalled(POSITION_ID),\n            \"BucketLender#increaseLoanOnBehalfOf: No lending while the position is margin-called\"\n        );\n\n        // This function is only called after the state has been updated in the base protocol;\n        // thus, the principal in the base protocol will equal the principal after the increase\n        uint256 principalAfterIncrease = margin.getPositionPrincipal(POSITION_ID);\n        uint256 principalBeforeIncrease = principalAfterIncrease.sub(principalAdded);\n\n        // principalTotal was the principal after the previous increase\n        accountForClose(principalTotal.sub(principalBeforeIncrease));\n\n        accountForIncrease(principalAdded, lentAmount);\n\n        assert(principalTotal == principalAfterIncrease);\n\n        return address(this);\n    }\n\n    /**\n     * Function a contract must implement in order to let other addresses call marginCall().\n     *\n     * @param  caller         Address of the caller of the marginCall function\n     * @param  positionId     Unique ID of the position\n     * @param  depositAmount  Amount of heldToken deposit that will be required to cancel the call\n     * @return                This address to accept, a different address to ask that contract\n     */\n    function marginCallOnBehalfOf(\n        address caller,\n        bytes32 positionId,\n        uint256 depositAmount\n    )\n        external\n        onlyMargin\n        nonReentrant\n        onlyPosition(positionId)\n        returns (address)\n    {\n        require(\n            TRUSTED_MARGIN_CALLERS[caller],\n            \"BucketLender#marginCallOnBehalfOf: Margin-caller must be trusted\"\n        );\n        require(\n            depositAmount == 0, // prevents depositing from canceling the margin-call\n            \"BucketLender#marginCallOnBehalfOf: Deposit amount must be zero\"\n        );\n\n        return address(this);\n    }\n\n    /**\n     * Function a contract must implement in order to let other addresses call cancelMarginCall().\n     *\n     * @param  canceler    Address of the caller of the cancelMarginCall function\n     * @param  positionId  Unique ID of the position\n     * @return             This address to accept, a different address to ask that contract\n     */\n    function cancelMarginCallOnBehalfOf(\n        address canceler,\n        bytes32 positionId\n    )\n        external\n        onlyMargin\n        nonReentrant\n        onlyPosition(positionId)\n        returns (address)\n    {\n        require(\n            TRUSTED_MARGIN_CALLERS[canceler],\n            \"BucketLender#cancelMarginCallOnBehalfOf: Margin-call-canceler must be trusted\"\n        );\n\n        return address(this);\n    }\n\n    /**\n     * Function a contract must implement in order to let other addresses call\n     * forceRecoverCollateral().\n     *\n     *  param  recoverer   Address of the caller of the forceRecoverCollateral() function\n     * @param  positionId  Unique ID of the position\n     * @param  recipient   Address to send the recovered tokens to\n     * @return             This address to accept, a different address to ask that contract\n     */\n    function forceRecoverCollateralOnBehalfOf(\n        address /* recoverer */,\n        bytes32 positionId,\n        address recipient\n    )\n        external\n        onlyMargin\n        nonReentrant\n        onlyPosition(positionId)\n        returns (address)\n    {\n        return forceRecoverCollateralInternal(recipient);\n    }\n\n    // ============ Public State-Changing Functions ============\n\n    /**\n     * Allow anyone to recalculate the Outstanding Principal and Available Amount for the buckets if\n     * part of the position has been closed since the last position increase.\n     */\n    function rebalanceBuckets()\n        external\n        nonReentrant\n    {\n        rebalanceBucketsInternal();\n    }\n\n    /**\n     * Allows users to deposit owedToken into this contract. Allowance must be set on this contract\n     * for \"token\" in at least the amount \"amount\".\n     *\n     * @param  beneficiary  The account that will be entitled to this depoit\n     * @param  amount       The amount of owedToken to deposit\n     * @return              The bucket number that was deposited into\n     */\n    function deposit(\n        address beneficiary,\n        uint256 amount\n    )\n        external\n        nonReentrant\n        returns (uint256)\n    {\n        Margin margin = Margin(DYDX_MARGIN);\n        bytes32 positionId = POSITION_ID;\n\n        require(\n            beneficiary != address(0),\n            \"BucketLender#deposit: Beneficiary cannot be the zero address\"\n        );\n        require(\n            amount != 0,\n            \"BucketLender#deposit: Cannot deposit zero tokens\"\n        );\n        require(\n            !margin.isPositionClosed(positionId),\n            \"BucketLender#deposit: Cannot deposit after the position is closed\"\n        );\n        require(\n            !margin.isPositionCalled(positionId),\n            \"BucketLender#deposit: Cannot deposit while the position is margin-called\"\n        );\n\n        rebalanceBucketsInternal();\n\n        OWED_TOKEN.transferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        uint256 bucket = getCurrentBucket();\n\n        uint256 effectiveAmount = availableForBucket[bucket].add(getBucketOwedAmount(bucket));\n\n        uint256 weightToAdd = 0;\n        if (effectiveAmount == 0) {\n            weightToAdd = amount; // first deposit in bucket\n        } else {\n            weightToAdd = MathHelpers.getPartialAmount(\n                amount,\n                effectiveAmount,\n                weightForBucket[bucket]\n            );\n        }\n\n        require(\n            weightToAdd != 0,\n            \"BucketLender#deposit: Cannot deposit for zero weight\"\n        );\n\n        // update state\n        updateAvailable(bucket, amount, true);\n        weightForBucketForAccount[bucket][beneficiary] =\n            weightForBucketForAccount[bucket][beneficiary].add(weightToAdd);\n        weightForBucket[bucket] = weightForBucket[bucket].add(weightToAdd);\n\n        emit Deposit(\n            beneficiary,\n            bucket,\n            amount,\n            weightToAdd\n        );\n\n        return bucket;\n    }\n\n    /**\n     * Allows users to withdraw their lent funds. An account can withdraw its weighted share of the\n     * bucket.\n     *\n     * While the position is open, a bucket's share is equal to:\n     *   Owed Token: (Available Amount) + (Outstanding Principal) * (1 + interest)\n     *   Held Token: 0\n     *\n     * After the position is closed, a bucket's share is equal to:\n     *   Owed Token: (Available Amount)\n     *   Held Token: (Held Token Balance) * (Outstanding Principal) / (Total Outstanding Principal)\n     *\n     * @param  buckets      The bucket numbers to withdraw from\n     * @param  maxWeights   The maximum weight to withdraw from each bucket. The amount of tokens\n     *                      withdrawn will be at least this amount, but not necessarily more.\n     *                      Withdrawing the same weight from different buckets does not necessarily\n     *                      return the same amounts from those buckets. In order to withdraw as many\n     *                      tokens as possible, use the maximum uint256.\n     * @param  onBehalfOf   The address to withdraw on behalf of\n     * @return              1) The number of owedTokens withdrawn\n     *                      2) The number of heldTokens withdrawn\n     */\n    function withdraw(\n        uint256[] buckets,\n        uint256[] maxWeights,\n        address onBehalfOf\n    )\n        external\n        nonReentrant\n        returns (uint256, uint256)\n    {\n        require(\n            buckets.length == maxWeights.length,\n            \"BucketLender#withdraw: The lengths of the input arrays must match\"\n        );\n        if (onBehalfOf != msg.sender) {\n            require(\n                TRUSTED_WITHDRAWERS[msg.sender],\n                \"BucketLender#withdraw: Only trusted withdrawers can withdraw on behalf of others\"\n            );\n        }\n\n        rebalanceBucketsInternal();\n\n        // decide if some bucket is unable to be withdrawn from (is locked)\n        // the zero value represents no-lock\n        uint256 lockedBucket = 0;\n        if (\n            Margin(DYDX_MARGIN).containsPosition(POSITION_ID) &&\n            criticalBucket == getCurrentBucket()\n        ) {\n            lockedBucket = criticalBucket;\n        }\n\n        uint256[2] memory results; // [0] = totalOwedToken, [1] = totalHeldToken\n\n        uint256 maxHeldToken = 0;\n        if (wasForceClosed) {\n            maxHeldToken = HELD_TOKEN.balanceOf(address(this));\n        }\n\n        for (uint256 i = 0; i < buckets.length; i++) {\n            uint256 bucket = buckets[i];\n\n            // prevent withdrawing from the current bucket if it is also the critical bucket\n            if ((bucket != 0) && (bucket == lockedBucket)) {\n                continue;\n            }\n\n            (uint256 owedTokenForBucket, uint256 heldTokenForBucket) = withdrawSingleBucket(\n                onBehalfOf,\n                bucket,\n                maxWeights[i],\n                maxHeldToken\n            );\n\n            results[0] = results[0].add(owedTokenForBucket);\n            results[1] = results[1].add(heldTokenForBucket);\n        }\n\n        // Transfer share of owedToken\n        OWED_TOKEN.transfer(msg.sender, results[0]);\n        HELD_TOKEN.transfer(msg.sender, results[1]);\n\n        return (results[0], results[1]);\n    }\n\n    /**\n     * Allows the owner to withdraw any excess tokens sent to the vault by unconventional means,\n     * including (but not limited-to) token airdrops. Any tokens moved to this contract by calling\n     * deposit() will be accounted for and will not be withdrawable by this function.\n     *\n     * @param  token  ERC20 token address\n     * @param  to     Address to transfer tokens to\n     * @return        Amount of tokens withdrawn\n     */\n    function withdrawExcessToken(\n        address token,\n        address to\n    )\n        external\n        onlyOwner\n        returns (uint256)\n    {\n        rebalanceBucketsInternal();\n\n        uint256 amount = token.balanceOf(address(this));\n\n        if (token == OWED_TOKEN) {\n            amount = amount.sub(availableTotal);\n        } else if (token == HELD_TOKEN) {\n            require(\n                !wasForceClosed,\n                \"BucketLender#withdrawExcessToken: heldToken cannot be withdrawn if force-closed\"\n            );\n        }\n\n        token.transfer(to, amount);\n        return amount;\n    }\n\n    // ============ Public Getter Functions ============\n\n    /**\n     * Get the current bucket number that funds will be deposited into. This is also the highest\n     * bucket so far.\n     *\n     * @return The highest bucket and the one that funds will be deposited into\n     */\n    function getCurrentBucket()\n        public\n        view\n        returns (uint256)\n    {\n        // load variables from storage;\n        Margin margin = Margin(DYDX_MARGIN);\n        bytes32 positionId = POSITION_ID;\n        uint32 bucketTime = BUCKET_TIME;\n\n        assert(!margin.isPositionClosed(positionId));\n\n        // if position not created, allow deposits in the first bucket\n        if (!margin.containsPosition(positionId)) {\n            return 0;\n        }\n\n        // return the number of BUCKET_TIME periods elapsed since the position start, rounded-up\n        uint256 startTimestamp = margin.getPositionStartTimestamp(positionId);\n        return block.timestamp.sub(startTimestamp).div(bucketTime).add(1);\n    }\n\n    /**\n     * Gets the outstanding amount of owedToken owed to a bucket. This is the principal amount of\n     * the bucket multiplied by the interest accrued in the position. If the position is closed,\n     * then any outstanding principal will never be repaid in the form of owedToken.\n     *\n     * @param  bucket  The bucket number\n     * @return         The amount of owedToken that this bucket expects to be paid-back if the posi\n     */\n    function getBucketOwedAmount(\n        uint256 bucket\n    )\n        public\n        view\n        returns (uint256)\n    {\n        // if the position is completely closed, then the outstanding principal will never be repaid\n        if (Margin(DYDX_MARGIN).isPositionClosed(POSITION_ID)) {\n            return 0;\n        }\n\n        uint256 lentPrincipal = principalForBucket[bucket];\n\n        // the bucket has no outstanding principal\n        if (lentPrincipal == 0) {\n            return 0;\n        }\n\n        // get the total amount of owedToken that would be paid back at this time\n        uint256 owedAmount = Margin(DYDX_MARGIN).getPositionOwedAmountAtTime(\n            POSITION_ID,\n            principalTotal,\n            uint32(block.timestamp)\n        );\n\n        // return the bucket's share\n        return MathHelpers.getPartialAmount(\n            lentPrincipal,\n            principalTotal,\n            owedAmount\n        );\n    }\n\n    // ============ Internal Functions ============\n\n    function forceRecoverCollateralInternal(\n        address recipient\n    )\n        internal\n        returns (address)\n    {\n        require(\n            recipient == address(this),\n            \"BucketLender#forceRecoverCollateralOnBehalfOf: Recipient must be this contract\"\n        );\n\n        rebalanceBucketsInternal();\n\n        wasForceClosed = true;\n\n        return address(this);\n    }\n\n    // ============ Private Helper Functions ============\n\n    /**\n     * Recalculates the Outstanding Principal and Available Amount for the buckets. Only changes the\n     * state if part of the position has been closed since the last position increase.\n     */\n    function rebalanceBucketsInternal()\n        private\n    {\n        // if force-closed, don't update the outstanding principal values; they are needed to repay\n        // lenders with heldToken\n        if (wasForceClosed) {\n            return;\n        }\n\n        uint256 marginPrincipal = Margin(DYDX_MARGIN).getPositionPrincipal(POSITION_ID);\n\n        accountForClose(principalTotal.sub(marginPrincipal));\n\n        assert(principalTotal == marginPrincipal);\n    }\n\n    /**\n     * Updates the state variables at any time. Only does anything after the position has been\n     * closed or partially-closed since the last time this function was called.\n     *\n     * - Increases the available amount in the highest buckets with outstanding principal\n     * - Decreases the principal amount in those buckets\n     *\n     * @param  principalRemoved  Amount of principal closed since the last update\n     */\n    function accountForClose(\n        uint256 principalRemoved\n    )\n        private\n    {\n        if (principalRemoved == 0) {\n            return;\n        }\n\n        uint256 newRepaidAmount = Margin(DYDX_MARGIN).getTotalOwedTokenRepaidToLender(POSITION_ID);\n        assert(newRepaidAmount.sub(cachedRepaidAmount) >= principalRemoved);\n\n        uint256 principalToSub = principalRemoved;\n        uint256 availableToAdd = newRepaidAmount.sub(cachedRepaidAmount);\n        uint256 criticalBucketTemp = criticalBucket;\n\n        // loop over buckets in reverse order starting with the critical bucket\n        for (\n            uint256 bucket = criticalBucketTemp;\n            principalToSub > 0;\n            bucket--\n        ) {\n            assert(bucket <= criticalBucketTemp); // no underflow on bucket\n\n            uint256 principalTemp = Math.min256(principalToSub, principalForBucket[bucket]);\n            if (principalTemp == 0) {\n                continue;\n            }\n            uint256 availableTemp = MathHelpers.getPartialAmount(\n                principalTemp,\n                principalToSub,\n                availableToAdd\n            );\n\n            updateAvailable(bucket, availableTemp, true);\n            updatePrincipal(bucket, principalTemp, false);\n\n            principalToSub = principalToSub.sub(principalTemp);\n            availableToAdd = availableToAdd.sub(availableTemp);\n\n            criticalBucketTemp = bucket;\n        }\n\n        assert(principalToSub == 0);\n        assert(availableToAdd == 0);\n\n        setCriticalBucket(criticalBucketTemp);\n\n        cachedRepaidAmount = newRepaidAmount;\n    }\n\n    /**\n     * Updates the state variables when a position is increased.\n     *\n     * - Decreases the available amount in the lowest buckets with available token\n     * - Increases the principal amount in those buckets\n     *\n     * @param  principalAdded  Amount of principal added to the position\n     * @param  lentAmount      Amount of owedToken lent\n     */\n    function accountForIncrease(\n        uint256 principalAdded,\n        uint256 lentAmount\n    )\n        private\n    {\n        require(\n            lentAmount <= availableTotal,\n            \"BucketLender#accountForIncrease: No lending not-accounted-for funds\"\n        );\n\n        uint256 principalToAdd = principalAdded;\n        uint256 availableToSub = lentAmount;\n        uint256 criticalBucketTemp;\n\n        // loop over buckets in order starting from the critical bucket\n        uint256 lastBucket = getCurrentBucket();\n        for (\n            uint256 bucket = criticalBucket;\n            principalToAdd > 0;\n            bucket++\n        ) {\n            assert(bucket <= lastBucket); // should never go past the last bucket\n\n            uint256 availableTemp = Math.min256(availableToSub, availableForBucket[bucket]);\n            if (availableTemp == 0) {\n                continue;\n            }\n            uint256 principalTemp = MathHelpers.getPartialAmount(\n                availableTemp,\n                availableToSub,\n                principalToAdd\n            );\n\n            updateAvailable(bucket, availableTemp, false);\n            updatePrincipal(bucket, principalTemp, true);\n\n            principalToAdd = principalToAdd.sub(principalTemp);\n            availableToSub = availableToSub.sub(availableTemp);\n\n            criticalBucketTemp = bucket;\n        }\n\n        assert(principalToAdd == 0);\n        assert(availableToSub == 0);\n\n        setCriticalBucket(criticalBucketTemp);\n    }\n\n    /**\n     * Withdraw\n     *\n     * @param  onBehalfOf    The account for which to withdraw for\n     * @param  bucket        The bucket number to withdraw from\n     * @param  maxWeight     The maximum weight to withdraw\n     * @param  maxHeldToken  The total amount of heldToken that has been force-recovered\n     * @return               1) The number of owedTokens withdrawn\n     *                       2) The number of heldTokens withdrawn\n     */\n    function withdrawSingleBucket(\n        address onBehalfOf,\n        uint256 bucket,\n        uint256 maxWeight,\n        uint256 maxHeldToken\n    )\n        private\n        returns (uint256, uint256)\n    {\n        // calculate the user's share\n        uint256 bucketWeight = weightForBucket[bucket];\n        if (bucketWeight == 0) {\n            return (0, 0);\n        }\n\n        uint256 userWeight = weightForBucketForAccount[bucket][onBehalfOf];\n        uint256 weightToWithdraw = Math.min256(maxWeight, userWeight);\n        if (weightToWithdraw == 0) {\n            return (0, 0);\n        }\n\n        // update state\n        weightForBucket[bucket] = weightForBucket[bucket].sub(weightToWithdraw);\n        weightForBucketForAccount[bucket][onBehalfOf] = userWeight.sub(weightToWithdraw);\n\n        // calculate for owedToken\n        uint256 owedTokenToWithdraw = withdrawOwedToken(\n            bucket,\n            weightToWithdraw,\n            bucketWeight\n        );\n\n        // calculate for heldToken\n        uint256 heldTokenToWithdraw = withdrawHeldToken(\n            bucket,\n            weightToWithdraw,\n            bucketWeight,\n            maxHeldToken\n        );\n\n        emit Withdraw(\n            onBehalfOf,\n            bucket,\n            weightToWithdraw,\n            owedTokenToWithdraw,\n            heldTokenToWithdraw\n        );\n\n        return (owedTokenToWithdraw, heldTokenToWithdraw);\n    }\n\n    /**\n     * Helper function to withdraw earned owedToken from this contract.\n     *\n     * @param  bucket        The bucket number to withdraw from\n     * @param  userWeight    The amount of weight the user is using to withdraw\n     * @param  bucketWeight  The total weight of the bucket\n     * @return               The amount of owedToken being withdrawn\n     */\n    function withdrawOwedToken(\n        uint256 bucket,\n        uint256 userWeight,\n        uint256 bucketWeight\n    )\n        private\n        returns (uint256)\n    {\n        // amount to return for the bucket\n        uint256 owedTokenToWithdraw = MathHelpers.getPartialAmount(\n            userWeight,\n            bucketWeight,\n            availableForBucket[bucket].add(getBucketOwedAmount(bucket))\n        );\n\n        // check that there is enough token to give back\n        require(\n            owedTokenToWithdraw <= availableForBucket[bucket],\n            \"BucketLender#withdrawOwedToken: There must be enough available owedToken\"\n        );\n\n        // update amounts\n        updateAvailable(bucket, owedTokenToWithdraw, false);\n\n        return owedTokenToWithdraw;\n    }\n\n    /**\n     * Helper function to withdraw heldToken from this contract.\n     *\n     * @param  bucket        The bucket number to withdraw from\n     * @param  userWeight    The amount of weight the user is using to withdraw\n     * @param  bucketWeight  The total weight of the bucket\n     * @param  maxHeldToken  The total amount of heldToken available to withdraw\n     * @return               The amount of heldToken being withdrawn\n     */\n    function withdrawHeldToken(\n        uint256 bucket,\n        uint256 userWeight,\n        uint256 bucketWeight,\n        uint256 maxHeldToken\n    )\n        private\n        returns (uint256)\n    {\n        if (maxHeldToken == 0) {\n            return 0;\n        }\n\n        // user's principal for the bucket\n        uint256 principalForBucketForAccount = MathHelpers.getPartialAmount(\n            userWeight,\n            bucketWeight,\n            principalForBucket[bucket]\n        );\n\n        uint256 heldTokenToWithdraw = MathHelpers.getPartialAmount(\n            principalForBucketForAccount,\n            principalTotal,\n            maxHeldToken\n        );\n\n        updatePrincipal(bucket, principalForBucketForAccount, false);\n\n        return heldTokenToWithdraw;\n    }\n\n    // ============ Setter Functions ============\n\n    /**\n     * Changes the critical bucket variable\n     *\n     * @param  bucket  The value to set criticalBucket to\n     */\n    function setCriticalBucket(\n        uint256 bucket\n    )\n        private\n    {\n        // don't spend the gas to sstore unless we need to change the value\n        if (criticalBucket == bucket) {\n            return;\n        }\n\n        criticalBucket = bucket;\n    }\n\n    /**\n     * Changes the available owedToken amount. This changes both the variable to track the total\n     * amount as well as the variable to track a particular bucket.\n     *\n     * @param  bucket    The bucket number\n     * @param  amount    The amount to change the available amount by\n     * @param  increase  True if positive change, false if negative change\n     */\n    function updateAvailable(\n        uint256 bucket,\n        uint256 amount,\n        bool increase\n    )\n        private\n    {\n        if (amount == 0) {\n            return;\n        }\n\n        uint256 newTotal;\n        uint256 newForBucket;\n\n        if (increase) {\n            newTotal = availableTotal.add(amount);\n            newForBucket = availableForBucket[bucket].add(amount);\n            emit AvailableIncreased(newTotal, bucket, newForBucket, amount); // solium-disable-line\n        } else {\n            newTotal = availableTotal.sub(amount);\n            newForBucket = availableForBucket[bucket].sub(amount);\n            emit AvailableDecreased(newTotal, bucket, newForBucket, amount); // solium-disable-line\n        }\n\n        availableTotal = newTotal;\n        availableForBucket[bucket] = newForBucket;\n    }\n\n    /**\n     * Changes the principal amount. This changes both the variable to track the total\n     * amount as well as the variable to track a particular bucket.\n     *\n     * @param  bucket    The bucket number\n     * @param  amount    The amount to change the principal amount by\n     * @param  increase  True if positive change, false if negative change\n     */\n    function updatePrincipal(\n        uint256 bucket,\n        uint256 amount,\n        bool increase\n    )\n        private\n    {\n        if (amount == 0) {\n            return;\n        }\n\n        uint256 newTotal;\n        uint256 newForBucket;\n\n        if (increase) {\n            newTotal = principalTotal.add(amount);\n            newForBucket = principalForBucket[bucket].add(amount);\n            emit PrincipalIncreased(newTotal, bucket, newForBucket, amount); // solium-disable-line\n        } else {\n            newTotal = principalTotal.sub(amount);\n            newForBucket = principalForBucket[bucket].sub(amount);\n            emit PrincipalDecreased(newTotal, bucket, newForBucket, amount); // solium-disable-line\n        }\n\n        principalTotal = newTotal;\n        principalForBucket[bucket] = newForBucket;\n    }\n}\n\n// File: contracts/margin/external/BucketLender/BucketLenderWithRecoveryDelay.sol\n\n/**\n * @title BucketLenderWithRecoveryDelay\n * @author dYdX\n *\n * Extension of BucketLender that delays the force-recovery time\n */\ncontract BucketLenderWithRecoveryDelay is BucketLender\n{\n    // ============ State Variables ============\n\n    // number of seconds after position has closed that must be waited before force-recovering\n    uint256 public RECOVERY_DELAY;\n\n    // ============ Constructor ============\n\n    constructor(\n        address margin,\n        bytes32 positionId,\n        address heldToken,\n        address owedToken,\n        uint32[7] parameters,\n        address[] trustedMarginCallers,\n        address[] trustedWithdrawers,\n        uint256 recoveryDelay\n    )\n        public\n        BucketLender(\n            margin,\n            positionId,\n            heldToken,\n            owedToken,\n            parameters,\n            trustedMarginCallers,\n            trustedWithdrawers\n        )\n    {\n        RECOVERY_DELAY = recoveryDelay;\n    }\n\n    // ============ Margin-Only State-Changing Functions ============\n\n    // Overrides the function in BucketLender\n    function forceRecoverCollateralOnBehalfOf(\n        address /* recoverer */,\n        bytes32 positionId,\n        address recipient\n    )\n        external\n        onlyMargin\n        nonReentrant\n        onlyPosition(positionId)\n        returns (address)\n    {\n        MarginCommon.Position memory position = MarginHelper.getPosition(DYDX_MARGIN, positionId);\n        uint256 positionEnd = uint256(position.startTimestamp).add(position.maxDuration);\n        if (position.callTimestamp > 0) {\n            uint256 marginCallEnd = uint256(position.callTimestamp).add(position.callTimeLimit);\n            positionEnd = Math.min256(positionEnd, marginCallEnd);\n        }\n\n        require (\n            block.timestamp >= positionEnd.add(RECOVERY_DELAY),\n            \"BucketLenderWithRecoveryDelay#forceRecoverCollateralOnBehalfOf: Recovery too early\"\n        );\n\n        return forceRecoverCollateralInternal(recipient);\n    }\n}",
  "bytecode": "6080604052600160025560006009819055600a55600b805460ff191690553480156200002a57600080fd5b5060405162005e4738038062005e47833981016040908152815160208301519183015160608401516101608501516101808601516101a08701516000805433600160a060020a0319918216178255600180548216600160a060020a03808b1691909117909155600c8a9055600d80548316828a16179055600e805490921690871617905595979495939460808101949381019392019188908890889088908890889088908381602002015163ffffffff1615156200016f57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603460248201527f4275636b65744c656e64657223636f6e7374727563746f723a204255434b455460448201527f5f54494d452063616e6e6f74206265207a65726f000000000000000000000000606482015290519081900360840190fd5b508251600e80546020860151604087015163ffffffff9081167c010000000000000000000000000000000000000000000000000000000002918116780100000000000000000000000000000000000000000000000002948116740100000000000000000000000000000000000000000260a060020a63ffffffff02199093169290921760c060020a63ffffffff02191693909317600160e060020a03169290921790556060840151600f8054608087015160a088015160c089015186166c010000000000000000000000000290861668010000000000000000029186166401000000000263ffffffff19909316949095169390931767ffffffff00000000191617604060020a63ffffffff02191691909117606060020a63ffffffff02191691909117905560005b8251811015620002f1576001601060008584815181101515620002b657fe5b602090810291909101810151600160a060020a03168252810191909152604001600020805460ff191691151591909117905560010162000297565b5060005b81518110156200034f5760016011600084848151811015156200031457fe5b602090810291909101810151600160a060020a03168252810191909152604001600020805460ff1916911515919091179055600101620002f5565b6200041188600160a060020a031663ef339fc46040518163ffffffff167c010000000000000000000000000000000000000000000000000000000002815260040160206040518083038186803b158015620003a957600080fd5b505afa158015620003be573d6000803e3d6000fd5b505050506040513d6020811015620003d557600080fd5b5051620003ef6401000000006200505d6200042d82021704565b600e54600160a060020a03169190640100000000620056fd6200043382021704565b50505060129590955550620005b39a5050505050505050505050565b60001990565b82600160a060020a031663095ea7b383836040518363ffffffff167c01000000000000000000000000000000000000000000000000000000000281526004018083600160a060020a0316600160a060020a0316815260200182815260200192505050600060405180830381600087803b158015620004b057600080fd5b505af1158015620004c5573d6000803e3d6000fd5b50505050620004e26200057b640100000000026401000000009004565b15156200057657604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f546f6b656e496e74657261637423617070726f76653a20417070726f76616c2060448201527f6661696c65640000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b505050565b6000803d80156200059557602081146200059f57620005ab565b60019150620005ab565b60206000803e60005191505b501515919050565b61588480620005c36000396000f3006080604052600436106101d75763ffffffff7c01000000000000000000000000000000000000000000000000000000006000350416630dda60cc81146101dc578063168ed05c1461021a5780631752c065146102485780632cff585d1461025d5780632ee29dc8146102845780633a4bb778146102995780633fda1a1d146102b15780634120bcec146102c6578063456a09c8146102fe57806345a2556c1461035c57806347b456521461037457806347e7ef24146103895780634c3efd99146103ba5780634f3e98ab146103e35780634f8894a4146103fb578063501b0b18146104105780635451fb26146104415780635b72a33a146104785780636613d8711461048d5780636fa6de59146104a2578063715018a6146104b75780637995ba90146104ce5780637ce875691461050257806383253cfa146105175780638da5cb5b14610548578063a753b1a81461055d578063abb0522d1461058b578063abdd0c44146105bc578063b1724b46146105f0578063bc9e0da314610605578063bd7456e31461061a578063cd4c4c0c14610648578063d7ac71ff1461065d578063d92ed48d14610672578063ea51c34314610687578063eada7fad146106b4578063f2fde38b146106c9578063f783e11e146106f7575b600080fd5b3480156101e857600080fd5b506101f161070f565b6040805173ffffffffffffffffffffffffffffffffffffffff9092168252519081900360200190f35b34801561022657600080fd5b5061022f61072b565b6040805163ffffffff9092168252519081900360200190f35b34801561025457600080fd5b506101f161074f565b34801561026957600080fd5b5061027261076b565b60408051918252519081900360200190f35b34801561029057600080fd5b5061022f610771565b3480156102a557600080fd5b50610272600435610785565b3480156102bd57600080fd5b5061022f610797565b3480156102d257600080fd5b506101f173ffffffffffffffffffffffffffffffffffffffff60043581169060243590604435166107af565b34801561030a57600080fd5b50610343602460048035828101929082013591813591820191013573ffffffffffffffffffffffffffffffffffffffff60443516610afc565b6040805192835260208301919091528051918290030190f35b34801561036857600080fd5b50610272600435610f49565b34801561038057600080fd5b506102726110f4565b34801561039557600080fd5b5061027273ffffffffffffffffffffffffffffffffffffffff600435166024356110fa565b3480156103c657600080fd5b506103cf6117a7565b604080519115158252519081900360200190f35b3480156103ef57600080fd5b506102726004356117b0565b34801561040757600080fd5b5061022f6117c2565b34801561041c57600080fd5b506101f173ffffffffffffffffffffffffffffffffffffffff600435166024356117ee565b34801561044d57600080fd5b506101f173ffffffffffffffffffffffffffffffffffffffff60043516602435604435606435612189565b34801561048457600080fd5b5061022f61266f565b34801561049957600080fd5b50610272612697565b3480156104ae57600080fd5b5061027261269d565b3480156104c357600080fd5b506104cc6126a3565b005b3480156104da57600080fd5b5061027273ffffffffffffffffffffffffffffffffffffffff60043581169060243516612734565b34801561050e57600080fd5b5061022f6128dd565b34801561052357600080fd5b506101f173ffffffffffffffffffffffffffffffffffffffff600435166024356128f9565b34801561055457600080fd5b506101f1612ba1565b34801561056957600080fd5b506103cf73ffffffffffffffffffffffffffffffffffffffff60043516612bbd565b34801561059757600080fd5b5061027260043573ffffffffffffffffffffffffffffffffffffffff60243516612bd2565b3480156105c857600080fd5b506101f173ffffffffffffffffffffffffffffffffffffffff60043516602435604435612bef565b3480156105fc57600080fd5b5061022f612f0c565b34801561061157600080fd5b50610272612f18565b34801561062657600080fd5b506103cf73ffffffffffffffffffffffffffffffffffffffff60043516612f1e565b34801561065457600080fd5b50610272612f33565b34801561066957600080fd5b5061027261318c565b34801561067e57600080fd5b506104cc613192565b34801561069357600080fd5b506101f16004610124610204610284356102a4356024810190850135613218565b3480156106c057600080fd5b506101f16141c0565b3480156106d557600080fd5b506104cc73ffffffffffffffffffffffffffffffffffffffff600435166141dc565b34801561070357600080fd5b50610272600435614209565b60015473ffffffffffffffffffffffffffffffffffffffff1681565b600e5474010000000000000000000000000000000000000000900463ffffffff1681565b600d5473ffffffffffffffffffffffffffffffffffffffff1681565b600a5481565b600f54640100000000900463ffffffff1681565b60086020526000908152604090205481565b600f5468010000000000000000900463ffffffff1681565b60006107b9615561565b600154600090819073ffffffffffffffffffffffffffffffffffffffff16331461086a57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f4f6e6c794d617267696e236f6e6c794d617267696e3a204f6e6c79204d61726760448201527f696e2063616e2063616c6c000000000000000000000000000000000000000000606482015290519081900360840190fd5b6002805460010190819055600c548790811461090d57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602d60248201527f4275636b65744c656e646572236f6e6c79506f736974696f6e3a20496e636f7260448201527f7265637420706f736974696f6e00000000000000000000000000000000000000606482015290519081900360840190fd5b6001546109309073ffffffffffffffffffffffffffffffffffffffff168961421b565b945061095a85610120015163ffffffff168660e0015163ffffffff166143a990919063ffffffff16565b9350600085610100015163ffffffff1611156109a7576109988560c0015163ffffffff1686610100015163ffffffff166143a990919063ffffffff16565b92506109a484846143bc565b93505b6012546109bb90859063ffffffff6143a916565b421015610a7557604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152605260248201527f4275636b65744c656e646572576974685265636f7665727944656c617923666f60448201527f7263655265636f766572436f6c6c61746572616c4f6e426568616c664f663a2060648201527f5265636f7665727920746f6f206561726c790000000000000000000000000000608482015290519081900360a40190fd5b610a7e876143d4565b9550506002548114610af157604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f5265656e7472616e637920636865636b206661696c7572650000000000000000604482015290519081900360640190fd5b505050509392505050565b6000806000610b096155c5565b600280546001019081905560009081908190819081908d8c14610bd957604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152604160248201527f4275636b65744c656e6465722377697468647261773a20546865206c656e677460448201527f6873206f662074686520696e70757420617272617973206d757374206d61746360648201527f6800000000000000000000000000000000000000000000000000000000000000608482015290519081900360a40190fd5b73ffffffffffffffffffffffffffffffffffffffff8b163314610cc2573360009081526011602052604090205460ff161515610cc257604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152605060248201527f4275636b65744c656e6465722377697468647261773a204f6e6c79207472757360448201527f7465642077697468647261776572732063616e207769746864726177206f6e2060648201527f626568616c66206f66206f746865727300000000000000000000000000000000608482015290519081900360a40190fd5b610cca6144e0565b600154600c54604080517f6d8ab12400000000000000000000000000000000000000000000000000000000815260048101929092525160009a5073ffffffffffffffffffffffffffffffffffffffff90921691636d8ab12491602480820192602092909190829003018186803b158015610d4357600080fd5b505afa158015610d57573d6000803e3d6000fd5b505050506040513d6020811015610d6d57600080fd5b50518015610d835750610d7e612f33565b600954145b15610d8e5760095497505b600b546000965060ff1615610dc957600d54610dc69073ffffffffffffffffffffffffffffffffffffffff163063ffffffff6145b916565b95505b600094505b8d851015610e60578e8e86818110610de257fe5b90506020020135935083600014158015610dfb57508784145b15610e0557610e55565b610e238b858f8f89818110610e1657fe5b9050602002013589614687565b9093509150610e41838860005b60200201519063ffffffff6143a916565b8752610e4f82886001610e30565b60208801525b600190940193610dce565b8651600e54610e899173ffffffffffffffffffffffffffffffffffffffff909116903390614822565b610ebb338860016020020151600d5473ffffffffffffffffffffffffffffffffffffffff16919063ffffffff61482216565b86516020880151600254919b5099508114610f3757604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f5265656e7472616e637920636865636b206661696c7572650000000000000000604482015290519081900360640190fd5b50505050505050509550959350505050565b600154600c54604080517f640075f30000000000000000000000000000000000000000000000000000000081526004810192909252516000928392839273ffffffffffffffffffffffffffffffffffffffff9092169163640075f391602480820192602092909190829003018186803b158015610fc557600080fd5b505afa158015610fd9573d6000803e3d6000fd5b505050506040513d6020811015610fef57600080fd5b505115610fff57600092506110ed565b600084815260056020526040902054915081151561102057600092506110ed565b600154600c54600654604080517fa633f61f0000000000000000000000000000000000000000000000000000000081526004810193909352602483019190915263ffffffff421660448301525173ffffffffffffffffffffffffffffffffffffffff9092169163a633f61f91606480820192602092909190829003018186803b1580156110ac57600080fd5b505afa1580156110c0573d6000803e3d6000fd5b505050506040513d60208110156110d657600080fd5b50516006549091506110ea908390836149c1565b92505b5050919050565b60125481565b6002805460019081019182905554600c5460009273ffffffffffffffffffffffffffffffffffffffff9283169284918291829190891615156111c357604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603c60248201527f4275636b65744c656e646572236465706f7369743a2042656e6566696369617260448201527f792063616e6e6f7420626520746865207a65726f206164647265737300000000606482015290519081900360840190fd5b87151561125757604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603060248201527f4275636b65744c656e646572236465706f7369743a2043616e6e6f742064657060448201527f6f736974207a65726f20746f6b656e7300000000000000000000000000000000606482015290519081900360840190fd5b604080517f640075f300000000000000000000000000000000000000000000000000000000815260048101879052905173ffffffffffffffffffffffffffffffffffffffff88169163640075f3916024808301926020929190829003018186803b1580156112c457600080fd5b505afa1580156112d8573d6000803e3d6000fd5b505050506040513d60208110156112ee57600080fd5b5051156113a857604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152604160248201527f4275636b65744c656e646572236465706f7369743a2043616e6e6f742064657060448201527f6f7369742061667465722074686520706f736974696f6e20697320636c6f736560648201527f6400000000000000000000000000000000000000000000000000000000000000608482015290519081900360a40190fd5b604080517f6e0cd41500000000000000000000000000000000000000000000000000000000815260048101879052905173ffffffffffffffffffffffffffffffffffffffff881691636e0cd415916024808301926020929190829003018186803b15801561141557600080fd5b505afa158015611429573d6000803e3d6000fd5b505050506040513d602081101561143f57600080fd5b5051156114f957604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152604860248201527f4275636b65744c656e646572236465706f7369743a2043616e6e6f742064657060448201527f6f736974207768696c652074686520706f736974696f6e206973206d6172676960648201527f6e2d63616c6c6564000000000000000000000000000000000000000000000000608482015290519081900360a40190fd5b6115016144e0565b600e5461152c9073ffffffffffffffffffffffffffffffffffffffff1633308b63ffffffff6149df16565b611534612f33565b935061155d61154285610f49565b6000868152600360205260409020549063ffffffff6143a916565b92506000915082151561157257879150611591565b60008481526008602052604090205461158e90899085906149c1565b91505b81151561162557604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603460248201527f4275636b65744c656e646572236465706f7369743a2043616e6e6f742064657060448201527f6f73697420666f72207a65726f20776569676874000000000000000000000000606482015290519081900360840190fd5b61163184896001614b54565b600084815260076020908152604080832073ffffffffffffffffffffffffffffffffffffffff8d168452909152902054611671908363ffffffff6143a916565b600085815260076020908152604080832073ffffffffffffffffffffffffffffffffffffffff8e1684528252808320939093558682526008905220546116bd908363ffffffff6143a916565b6000858152600860209081526040918290209290925580518681529182018a90528181018490525173ffffffffffffffffffffffffffffffffffffffff8b16917f36af321ec8d3c75236829c5317affd40ddb308863a1236d2d277a4025cccee1e919081900360600190a2839650600254811461179b57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f5265656e7472616e637920636865636b206661696c7572650000000000000000604482015290519081900360640190fd5b50505050505092915050565b600b5460ff1681565b60056020526000908152604090205481565b600e547c0100000000000000000000000000000000000000000000000000000000900463ffffffff1681565b60006117f8615561565b600154600090819073ffffffffffffffffffffffffffffffffffffffff1633146118a957604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f4f6e6c794d617267696e236f6e6c794d617267696e3a204f6e6c79204d61726760448201527f696e2063616e2063616c6c000000000000000000000000000000000000000000606482015290519081900360840190fd5b6002805460010190819055600c548690811461194c57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602d60248201527f4275636b65744c656e646572236f6e6c79506f736974696f6e3a20496e636f7260448201527f7265637420706f736974696f6e00000000000000000000000000000000000000606482015290519081900360840190fd5b600154600c546119729173ffffffffffffffffffffffffffffffffffffffff169061421b565b6080810151600f5491965094506119ae9063ffffffff6801000000000000000082048116916c01000000000000000000000000900416866149c1565b9250600084116119ba57fe5b600654156119c457fe5b73ffffffffffffffffffffffffffffffffffffffff88163014156119e457fe5b600e54855173ffffffffffffffffffffffffffffffffffffffff908116911614611a9557604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603e60248201527f4275636b65744c656e64657223726563656976654c6f616e4f776e657273686960448201527f703a20506f736974696f6e206f776564546f6b656e206d69736d617463680000606482015290519081900360840190fd5b600d54602086015173ffffffffffffffffffffffffffffffffffffffff908116911614611b4957604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603e60248201527f4275636b65744c656e64657223726563656976654c6f616e4f776e657273686960448201527f703a20506f736974696f6e2068656c64546f6b656e206d69736d617463680000606482015290519081900360840190fd5b600f5461012086015163ffffffff908116911614611bee57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602481018290527f4275636b65744c656e64657223726563656976654c6f616e4f776e657273686960448201527f703a20506f736974696f6e206d61784475726174696f6e206d69736d61746368606482015290519081900360840190fd5b600f5460c086015163ffffffff9081166401000000009092041614611cc057604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152604260248201527f4275636b65744c656e64657223726563656976654c6f616e4f776e657273686960448201527f703a20506f736974696f6e2063616c6c54696d654c696d6974206d69736d617460648201527f6368000000000000000000000000000000000000000000000000000000000000608482015290519081900360a40190fd5b600e5461014086015163ffffffff90811678010000000000000000000000000000000000000000000000009092041614611da757604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152604160248201527f4275636b65744c656e64657223726563656976654c6f616e4f776e657273686960448201527f703a20506f736974696f6e20696e74657265737452617465206d69736d61746360648201527f6800000000000000000000000000000000000000000000000000000000000000608482015290519081900360a40190fd5b600e5461016086015163ffffffff9081167c01000000000000000000000000000000000000000000000000000000009092041614611e9257604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152604360248201527f4275636b65744c656e64657223726563656976654c6f616e4f776e657273686960448201527f703a20506f736974696f6e20696e746572657374506572696f64206d69736d6160648201527f7463680000000000000000000000000000000000000000000000000000000000608482015290519081900360a40190fd5b600154600c54604080517f54d79868000000000000000000000000000000000000000000000000000000008152600481019290925251859273ffffffffffffffffffffffffffffffffffffffff16916354d79868916024808301926020929190829003018186803b158015611f0657600080fd5b505afa158015611f1a573d6000803e3d6000fd5b505050506040513d6020811015611f3057600080fd5b50511015611feb57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152604560248201527f4275636b65744c656e64657223726563656976654c6f616e4f776e657273686960448201527f703a204e6f7420656e6f7567682068656c64546f6b656e20617320636f6c6c6160648201527f746572616c000000000000000000000000000000000000000000000000000000608482015290519081900360a40190fd5b600080527f05b8ccbb9d4d8fb16ea74ce3c29a41f1b461fbdaff4714a0d9a8eb05499746bc849055600684905560086020527f5eff886ea0ce6ca488a3d6e336d6c0f75f46d19b42c06ce5ee98e42c96d256c75461204f908563ffffffff6143a916565b7f5eff886ea0ce6ca488a3d6e336d6c0f75f46d19b42c06ce5ee98e42c96d256c75573ffffffffffffffffffffffffffffffffffffffff881660009081527f6d5257204ebe7d88fd91ae87941cb2dd9d8062b64ae5a2bd2d28ec40b9fbf6df60205260409020546120c6908563ffffffff6143a916565b73ffffffffffffffffffffffffffffffffffffffff891660009081527f6d5257204ebe7d88fd91ae87941cb2dd9d8062b64ae5a2bd2d28ec40b9fbf6df602052604090205530955050600254811461217f57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f5265656e7472616e637920636865636b206661696c7572650000000000000000604482015290519081900360640190fd5b5050505092915050565b60015460009081908190819073ffffffffffffffffffffffffffffffffffffffff16331461223e57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f4f6e6c794d617267696e236f6e6c794d617267696e3a204f6e6c79204d61726760448201527f696e2063616e2063616c6c000000000000000000000000000000000000000000606482015290519081900360840190fd5b6002805460010190819055600c54889081146122e157604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602d60248201527f4275636b65744c656e646572236f6e6c79506f736974696f6e3a20496e636f7260448201527f7265637420706f736974696f6e00000000000000000000000000000000000000606482015290519081900360840190fd5b60015473ffffffffffffffffffffffffffffffffffffffff90811695508a1630146123b957604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152605060248201527f4275636b65744c656e64657223696e6372656173654c6f616e4f6e426568616c60448201527f664f663a204f74686572206c656e646572732063616e6e6f74206c656e64206660648201527f6f72207468697320706f736974696f6e00000000000000000000000000000000608482015290519081900360a40190fd5b600c54604080517f6e0cd41500000000000000000000000000000000000000000000000000000000815260048101929092525173ffffffffffffffffffffffffffffffffffffffff871691636e0cd415916024808301926020929190829003018186803b15801561242957600080fd5b505afa15801561243d573d6000803e3d6000fd5b505050506040513d602081101561245357600080fd5b50511561250d57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152605360248201527f4275636b65744c656e64657223696e6372656173654c6f616e4f6e426568616c60448201527f664f663a204e6f206c656e64696e67207768696c652074686520706f7369746960648201527f6f6e206973206d617267696e2d63616c6c656400000000000000000000000000608482015290519081900360a40190fd5b600c54604080517f0e8a4ac700000000000000000000000000000000000000000000000000000000815260048101929092525173ffffffffffffffffffffffffffffffffffffffff871691630e8a4ac7916024808301926020929190829003018186803b15801561257d57600080fd5b505afa158015612591573d6000803e3d6000fd5b505050506040513d60208110156125a757600080fd5b505193506125bb848963ffffffff614c8d16565b92506125da6125d584600654614c8d90919063ffffffff16565b614c9f565b6125e48888614e72565b60065484146125ef57fe5b30955050600254811461266357604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f5265656e7472616e637920636865636b206661696c7572650000000000000000604482015290519081900360640190fd5b50505050949350505050565b600e547801000000000000000000000000000000000000000000000000900463ffffffff1681565b60065481565b60095481565b60005473ffffffffffffffffffffffffffffffffffffffff1633146126c757600080fd5b6000805460405173ffffffffffffffffffffffffffffffffffffffff909116917ff8df31144d9c2f0f6b59d69b8b98abd5459d07f2742c4df920b25aae33c6482091a2600080547fffffffffffffffffffffffff0000000000000000000000000000000000000000169055565b60008054819073ffffffffffffffffffffffffffffffffffffffff16331461275b57600080fd5b6127636144e0565b61278973ffffffffffffffffffffffffffffffffffffffff85163063ffffffff6145b916565b600e5490915073ffffffffffffffffffffffffffffffffffffffff858116911614156127ca576004546127c390829063ffffffff614c8d16565b90506128ab565b600d5473ffffffffffffffffffffffffffffffffffffffff858116911614156128ab57600b5460ff16156128ab57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152604f60248201527f4275636b65744c656e646572237769746864726177457863657373546f6b656e60448201527f3a2068656c64546f6b656e2063616e6e6f742062652077697468647261776e2060648201527f696620666f7263652d636c6f7365640000000000000000000000000000000000608482015290519081900360a40190fd5b6128d273ffffffffffffffffffffffffffffffffffffffff8516848363ffffffff61482216565b8091505b5092915050565b600f546c01000000000000000000000000900463ffffffff1681565b60015460009073ffffffffffffffffffffffffffffffffffffffff1633146129a857604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f4f6e6c794d617267696e236f6e6c794d617267696e3a204f6e6c79204d61726760448201527f696e2063616e2063616c6c000000000000000000000000000000000000000000606482015290519081900360840190fd5b6002805460010190819055600c5483908114612a4b57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602d60248201527f4275636b65744c656e646572236f6e6c79506f736974696f6e3a20496e636f7260448201527f7265637420706f736974696f6e00000000000000000000000000000000000000606482015290519081900360840190fd5b73ffffffffffffffffffffffffffffffffffffffff851660009081526010602052604090205460ff161515612b2d57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152604d60248201527f4275636b65744c656e6465722363616e63656c4d617267696e43616c6c4f6e4260448201527f6568616c664f663a204d617267696e2d63616c6c2d63616e63656c6572206d7560648201527f7374206265207472757374656400000000000000000000000000000000000000608482015290519081900360a40190fd5b3092505060025481146128d657604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f5265656e7472616e637920636865636b206661696c7572650000000000000000604482015290519081900360640190fd5b60005473ffffffffffffffffffffffffffffffffffffffff1681565b60106020526000908152604090205460ff1681565b600760209081526000928352604080842090915290825290205481565b60015460009073ffffffffffffffffffffffffffffffffffffffff163314612c9e57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f4f6e6c794d617267696e236f6e6c794d617267696e3a204f6e6c79204d61726760448201527f696e2063616e2063616c6c000000000000000000000000000000000000000000606482015290519081900360840190fd5b6002805460010190819055600c5484908114612d4157604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602d60248201527f4275636b65744c656e646572236f6e6c79506f736974696f6e3a20496e636f7260448201527f7265637420706f736974696f6e00000000000000000000000000000000000000606482015290519081900360840190fd5b73ffffffffffffffffffffffffffffffffffffffff861660009081526010602052604090205460ff161515612dfd57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602481018290527f4275636b65744c656e646572236d617267696e43616c6c4f6e426568616c664f60448201527f663a204d617267696e2d63616c6c6572206d7573742062652074727573746564606482015290519081900360840190fd5b8315612e9057604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603e60248201527f4275636b65744c656e646572236d617267696e43616c6c4f6e426568616c664f60448201527f663a204465706f73697420616d6f756e74206d757374206265207a65726f0000606482015290519081900360840190fd5b309250506002548114612f0457604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f5265656e7472616e637920636865636b206661696c7572650000000000000000604482015290519081900360640190fd5b509392505050565b600f5463ffffffff1681565b60045481565b60116020526000908152604090205460ff1681565b600154600c54600e54604080517f640075f300000000000000000000000000000000000000000000000000000000815260048101849052905160009473ffffffffffffffffffffffffffffffffffffffff16939274010000000000000000000000000000000000000000900463ffffffff16918591859163640075f3916024808301926020929190829003018186803b158015612fcf57600080fd5b505afa158015612fe3573d6000803e3d6000fd5b505050506040513d6020811015612ff957600080fd5b50511561300257fe5b604080517f6d8ab12400000000000000000000000000000000000000000000000000000000815260048101859052905173ffffffffffffffffffffffffffffffffffffffff861691636d8ab124916024808301926020929190829003018186803b15801561306f57600080fd5b505afa158015613083573d6000803e3d6000fd5b505050506040513d602081101561309957600080fd5b505115156130aa5760009450613185565b604080517f26ad8d1b00000000000000000000000000000000000000000000000000000000815260048101859052905173ffffffffffffffffffffffffffffffffffffffff8616916326ad8d1b916024808301926020929190829003018186803b15801561311757600080fd5b505afa15801561312b573d6000803e3d6000fd5b505050506040513d602081101561314157600080fd5b505163ffffffff908116915061318290600190613176908581169061316a9042908790614c8d16565b9063ffffffff61500916565b9063ffffffff6143a916565b94505b5050505090565b600c5481565b60028054600101908190556131a56144e0565b600254811461321557604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f5265656e7472616e637920636865636b206661696c7572650000000000000000604482015290519081900360640190fd5b50565b60006132226155e0565b60015473ffffffffffffffffffffffffffffffffffffffff1633146132ce57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f4f6e6c794d617267696e236f6e6c794d617267696e3a204f6e6c79204d61726760448201527f696e2063616e2063616c6c000000000000000000000000000000000000000000606482015290519081900360840190fd5b6002805460010190819055600c548690811461337157604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602d60248201527f4275636b65744c656e646572236f6e6c79506f736974696f6e3a20496e636f7260448201527f7265637420706f736974696f6e00000000000000000000000000000000000000606482015290519081900360840190fd5b600154600c54604080517f6d8ab12400000000000000000000000000000000000000000000000000000000815260048101929092525173ffffffffffffffffffffffffffffffffffffffff90921691636d8ab12491602480820192602092909190829003018186803b1580156133e657600080fd5b505afa1580156133fa573d6000803e3d6000fd5b505050506040513d602081101561341057600080fd5b505115156134cb57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152604d60248201527f4275636b65744c656e646572237665726966794c6f616e4f66666572696e673a60448201527f205468697320636f6e74726163742073686f756c64206e6f74206f70656e206160648201527f206e657720706f736974696f6e00000000000000000000000000000000000000608482015290519081900360a40190fd5b60408051610120818101909252613560918c90600990839083908082843750506040805160e081810190925293508e9250600791508390839080828437505060408051608081810190925293508e92506004915083908390808284375050604080516020601f8f018190048102820181019092528d815293508d92508c9150819084018382808284375061501e945050505050565b600e54815191945073ffffffffffffffffffffffffffffffffffffffff91821691161461358957fe5b600d54602084015173ffffffffffffffffffffffffffffffffffffffff9081169116146135b257fe5b604083015173ffffffffffffffffffffffffffffffffffffffff1630146135d557fe5b606083015173ffffffffffffffffffffffffffffffffffffffff1630146135f857fe5b608083015173ffffffffffffffffffffffffffffffffffffffff16156136a557604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603f60248201527f4275636b65744c656e646572237665726966794c6f616e4f66666572696e673a60448201527f206c6f616e4f66666572696e672e74616b6572206973206e6f6e2d7a65726f00606482015290519081900360840190fd5b60c083015173ffffffffffffffffffffffffffffffffffffffff161561377857604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152604660248201527f4275636b65744c656e646572237665726966794c6f616e4f66666572696e673a60448201527f206c6f616e4f66666572696e672e666565526563697069656e74206973206e6f60648201527f6e2d7a65726f0000000000000000000000000000000000000000000000000000608482015290519081900360a40190fd5b60a083015173ffffffffffffffffffffffffffffffffffffffff161561384b57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152604760248201527f4275636b65744c656e646572237665726966794c6f616e4f66666572696e673a60448201527f206c6f616e4f66666572696e672e706f736974696f6e4f776e6572206973206e60648201527f6f6e2d7a65726f00000000000000000000000000000000000000000000000000608482015290519081900360a40190fd5b60e083015173ffffffffffffffffffffffffffffffffffffffff161561391e57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152604860248201527f4275636b65744c656e646572237665726966794c6f616e4f66666572696e673a60448201527f206c6f616e4f66666572696e672e6c656e646572466565546f6b656e2069732060648201527f6e6f6e2d7a65726f000000000000000000000000000000000000000000000000608482015290519081900360a40190fd5b61010083015173ffffffffffffffffffffffffffffffffffffffff16156139f257604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152604760248201527f4275636b65744c656e646572237665726966794c6f616e4f66666572696e673a60448201527f206c6f616e4f66666572696e672e74616b6572466565546f6b656e206973206e60648201527f6f6e2d7a65726f00000000000000000000000000000000000000000000000000608482015290519081900360a40190fd5b6139fa61505d565b6101208401515114613aba57604080517f08c379a0000000000000000000000000000000000000000000000000000000008152602060048201526044602482018190527f4275636b65744c656e646572237665726966794c6f616e4f66666572696e673a908201527f206c6f616e4f66666572696e672e6d6178416d6f756e7420697320696e636f7260648201527f7265637400000000000000000000000000000000000000000000000000000000608482015290519081900360a40190fd5b6101208301516020015115613b7c57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152604360248201527f4275636b65744c656e646572237665726966794c6f616e4f66666572696e673a60448201527f206c6f616e4f66666572696e672e6d696e416d6f756e74206973206e6f6e2d7a60648201527f65726f0000000000000000000000000000000000000000000000000000000000608482015290519081900360a40190fd5b6101208301516040015115613c3e57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152604660248201527f4275636b65744c656e646572237665726966794c6f616e4f66666572696e673a60448201527f206c6f616e4f66666572696e672e6d696e48656c64546f6b656e206973206e6f60648201527f6e2d7a65726f0000000000000000000000000000000000000000000000000000608482015290519081900360a40190fd5b6101208301516060015115613d0057604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152604360248201527f4275636b65744c656e646572237665726966794c6f616e4f66666572696e673a60448201527f206c6f616e4f66666572696e672e6c656e646572466565206973206e6f6e2d7a60648201527f65726f0000000000000000000000000000000000000000000000000000000000608482015290519081900360a40190fd5b6101208301516080015115613dc257604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152604260248201527f4275636b65744c656e646572237665726966794c6f616e4f66666572696e673a60448201527f206c6f616e4f66666572696e672e74616b6572466565206973206e6f6e2d7a6560648201527f726f000000000000000000000000000000000000000000000000000000000000608482015290519081900360a40190fd5b613dca61505d565b61014084015114613e8857604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152604160248201527f4275636b65744c656e646572237665726966794c6f616e4f66666572696e673a60448201527f2065787069726174696f6e54696d657374616d7020697320696e636f7272656360648201527f7400000000000000000000000000000000000000000000000000000000000000608482015290519081900360a40190fd5b6101a083015115613f2057604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603e60248201527f4275636b65744c656e646572237665726966794c6f616e4f66666572696e673a60448201527f206c6f616e4f66666572696e672e73616c74206973206e6f6e2d7a65726f0000606482015290519081900360840190fd5b613f28615081565b63ffffffff1683610160015163ffffffff16141515613ff457604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152604860248201527f4275636b65744c656e646572237665726966794c6f616e4f66666572696e673a60448201527f206c6f616e4f66666572696e672e63616c6c54696d656c696d6974206973206960648201527f6e636f7272656374000000000000000000000000000000000000000000000000608482015290519081900360a40190fd5b613ffc615081565b63ffffffff1683610180015163ffffffff161415156140c857604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152604660248201527f4275636b65744c656e646572237665726966794c6f616e4f66666572696e673a60448201527f206c6f616e4f66666572696e672e6d61784475726174696f6e20697320696e6360648201527f6f72726563740000000000000000000000000000000000000000000000000000608482015290519081900360a40190fd5b600e5461012084015160a0015163ffffffff9081167801000000000000000000000000000000000000000000000000909204161461410257fe5b600e5461012084015160c0015163ffffffff9081167c0100000000000000000000000000000000000000000000000000000000909204161461414057fe5b3093505060025481146141b457604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f5265656e7472616e637920636865636b206661696c7572650000000000000000604482015290519081900360640190fd5b50509695505050505050565b600e5473ffffffffffffffffffffffffffffffffffffffff1681565b60005473ffffffffffffffffffffffffffffffffffffffff16331461420057600080fd5b61321581615089565b60036020526000908152604090205481565b614223615561565b61422b615675565b6142336155c5565b61423b615694565b604080517f1928b3cb00000000000000000000000000000000000000000000000000000000815260048101879052905173ffffffffffffffffffffffffffffffffffffffff881691631928b3cb91602480830192610180929190829003018186803b1580156142a957600080fd5b505afa1580156142bd573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052506101808110156142e357600080fd5b506040805161018081018252825173ffffffffffffffffffffffffffffffffffffffff908116825260208085015182169083015283830151811692820192909252606080840151909216918101919091526080808301519082015260a0808301519082015260c08083015163ffffffff9081169183019190915260e0808401518216908301526101008084015182169083015261012080840151821690830152610140808401518216908301526101609283015116918101919091529695505050505050565b818101828110156143b657fe5b92915050565b60008183106143cb57816143cd565b825b9392505050565b600073ffffffffffffffffffffffffffffffffffffffff821630146144a657604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152604e60248201527f4275636b65744c656e64657223666f7263655265636f766572436f6c6c61746560448201527f72616c4f6e426568616c664f663a20526563697069656e74206d75737420626560648201527f207468697320636f6e7472616374000000000000000000000000000000000000608482015290519081900360a40190fd5b6144ae6144e0565b50600b80547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016600117905530919050565b600b5460009060ff16156144f357613215565b600154600c54604080517f0e8a4ac700000000000000000000000000000000000000000000000000000000815260048101929092525173ffffffffffffffffffffffffffffffffffffffff90921691630e8a4ac791602480820192602092909190829003018186803b15801561456857600080fd5b505afa15801561457c573d6000803e3d6000fd5b505050506040513d602081101561459257600080fd5b50516006549091506145ae906125d5908363ffffffff614c8d16565b600654811461321557fe5b60008273ffffffffffffffffffffffffffffffffffffffff166370a08231836040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b15801561465457600080fd5b505afa158015614668573d6000803e3d6000fd5b505050506040513d602081101561467e57600080fd5b50519392505050565b6000838152600860205260408120548190818080808415156146af5760009650869550614814565b60008a815260076020908152604080832073ffffffffffffffffffffffffffffffffffffffff8f16845290915290205493506146eb89856143bc565b92508215156147005760009650869550614814565b60008a81526008602052604090205461471f908463ffffffff614c8d16565b60008b81526008602052604090205561473e848463ffffffff614c8d16565b600760008c815260200190815260200160002060008d73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555061479d8a8487615138565b91506147ab8a84878b615244565b604080518c81526020810186905280820185905260608101839052905191925073ffffffffffffffffffffffffffffffffffffffff8d16917fe08737ac48a1dab4b1a46c7dc9398bd5bfc6d7ad6fabb7cd8caa254de14def359181900360800190a28181965096505b505050505094509492505050565b3081158061485b57508273ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16145b15614865576149bb565b8373ffffffffffffffffffffffffffffffffffffffff1663a9059cbb84846040518363ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200182815260200192505050600060405180830381600087803b15801561490857600080fd5b505af115801561491c573d6000803e3d6000fd5b5050505061492861529f565b15156149bb57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602760248201527f546f6b656e496e746572616374237472616e736665723a205472616e7366657260448201527f206661696c656400000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b50505050565b60006149d78361316a868563ffffffff6152d316565b949350505050565b801580614a1757508173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff16145b15614a21576149bb565b604080517f23b872dd00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff85811660048301528481166024830152604482018490529151918616916323b872dd9160648082019260009290919082900301818387803b158015614aa157600080fd5b505af1158015614ab5573d6000803e3d6000fd5b50505050614ac161529f565b15156149bb57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602f60248201527f546f6b656e496e746572616374237472616e7366657246726f6d3a205472616e60448201527f7366657246726f6d206661696c65640000000000000000000000000000000000606482015290519081900360840190fd5b600080831515614b6357614c86565b8215614bee57600454614b7c908563ffffffff6143a916565b600086815260036020526040902054909250614b9e908563ffffffff6143a916565b60408051848152602081018890528082018390526060810187905290519192507fca6e648ae199ddefe590826a3fa1725537263712dc91de54fbe9265e8481bcb2919081900360800190a1614c6f565b600454614c01908563ffffffff614c8d16565b600086815260036020526040902054909250614c23908563ffffffff614c8d16565b60408051848152602081018890528082018390526060810187905290519192507f4f57952c4b465f787533606ee05864b1a98fc1d66e200cea50d06ffe2b911bc4919081900360800190a15b600482905560008581526003602052604090208190555b5050505050565b600082821115614c9957fe5b50900390565b6000808080808080871515614cb357614e68565b600154600c54604080517fbb39c85f00000000000000000000000000000000000000000000000000000000815260048101929092525173ffffffffffffffffffffffffffffffffffffffff9092169163bb39c85f91602480820192602092909190829003018186803b158015614d2857600080fd5b505afa158015614d3c573d6000803e3d6000fd5b505050506040513d6020811015614d5257600080fd5b5051600a549097508890614d6d90899063ffffffff614c8d16565b1015614d7557fe5b600a54889650614d8c90889063ffffffff614c8d16565b945060095493508392505b6000861115614e495783831115614daa57fe5b600083815260056020526040902054614dc49087906143bc565b9150811515614dd257614e1f565b614ddd8287876149c1565b9050614deb83826001614b54565b614df7838360006152fc565b614e07868363ffffffff614c8d16565b9550614e19858263ffffffff614c8d16565b94508293505b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff90920191614d97565b8515614e5157fe5b8415614e5957fe5b614e6284615434565b600a8790555b5050505050505050565b60008060008060008060006004548811151515614f3c57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152604360248201527f4275636b65744c656e646572236163636f756e74466f72496e6372656173653a60448201527f204e6f206c656e64696e67206e6f742d6163636f756e7465642d666f7220667560648201527f6e64730000000000000000000000000000000000000000000000000000000000608482015290519081900360a40190fd5b889650879550614f4a612f33565b935060095492505b6000871115614fe55783831115614f6557fe5b600083815260036020526040902054614f7f9087906143bc565b9150811515614f8d57614fda565b614f988287896149c1565b9050614fa683836000614b54565b614fb2838260016152fc565b614fc2878263ffffffff614c8d16565b9650614fd4868363ffffffff614c8d16565b95508294505b600190920191614f52565b8615614fed57fe5b8515614ff557fe5b614ffe85615434565b505050505050505050565b6000818381151561501657fe5b049392505050565b6150266155e0565b61502e6155e0565b6150388187615448565b61504281866154c5565b61504c8185615518565b6101e0810192909252509392505050565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff90565b63ffffffff90565b73ffffffffffffffffffffffffffffffffffffffff811615156150ab57600080fd5b6000805460405173ffffffffffffffffffffffffffffffffffffffff808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a3600080547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff92909216919091179055565b60008061516c848461516761514c89610f49565b60008a8152600360205260409020549063ffffffff6143a916565b6149c1565b60008681526003602052604090205490915081111561523857604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152604860248201527f4275636b65744c656e6465722377697468647261774f776564546f6b656e3a2060448201527f5468657265206d75737420626520656e6f75676820617661696c61626c65206f60648201527f776564546f6b656e000000000000000000000000000000000000000000000000608482015290519081900360a40190fd5b6149d785826000614b54565b600080808315156152585760009250615295565b60008781526005602052604090205461527490879087906149c1565b915061528382600654866149c1565b9050615291878360006152fc565b8092505b5050949350505050565b6000803d80156152b657602081146152bf576152cb565b600191506152cb565b60206000803e60005191505b501515919050565b60008215156152e4575060006143b6565b508181028183828115156152f457fe5b04146143b657fe5b60008083151561530b57614c86565b821561539657600654615324908563ffffffff6143a916565b600086815260056020526040902054909250615346908563ffffffff6143a916565b60408051848152602081018890528082018390526060810187905290519192507f58eef9f4832bc1f3b7dd73c274fd9d7c5fcbc32c73adc5b3020be3e03e7a139a919081900360800190a1615417565b6006546153a9908563ffffffff614c8d16565b6000868152600560205260409020549092506153cb908563ffffffff614c8d16565b60408051848152602081018890528082018390526060810187905290519192507f79a3ce3942e009744cca7547c0a7692ec2065556cc98bfd8f5cf9c367e23596b919081900360800190a15b600682905560008581526005602052604090208190555050505050565b80600954141561544357613215565b600955565b805173ffffffffffffffffffffffffffffffffffffffff908116835260208083015182169084015260408083015182169084015260608083015182169084015260808083015182169084015260a08083015182169084015260c08083015182169084015260e0808301518216908401526101009182015116910152565b805161012083018051919091526020808301518251909101526040808301518251909101526060808301518251909101526080808301519151015260a081015161014083015260c001516101a090910152565b805163ffffffff908116610160840152602082015181166101808401526040820151610120909301805193821660a0909401939093526060909101519151911660c09190910152565b6040805161018081018252600080825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e0810182905261010081018290526101208101829052610140810182905261016081019190915290565b60408051808201825290600290829080388339509192915050565b604080516102c081018252600080825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e0810182905261010081019190915261012081016156366156b3565b815260200160008152602001600063ffffffff168152602001600063ffffffff1681526020016000815260200160008019168152602001606081525090565b6080604051908101604052806004906020820280388339509192915050565b60c0604051908101604052806006906020820280388339509192915050565b60e0604051908101604052806000815260200160008152602001600081526020016000815260200160008152602001600063ffffffff168152602001600063ffffffff1681525090565b8273ffffffffffffffffffffffffffffffffffffffff1663095ea7b383836040518363ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200182815260200192505050600060405180830381600087803b1580156157a057600080fd5b505af11580156157b4573d6000803e3d6000fd5b505050506157c061529f565b151561585357604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f546f6b656e496e74657261637423617070726f76653a20417070726f76616c2060448201527f6661696c65640000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b5050505600a165627a7a723058206288949fe60b060ddb4836c65acd20733f5ff76e22409cba3a39d28c523511ff002900000000000000000000000036bf21c8e661b21e6166e4385f574941fdc6caffb7e66ec052db1c1d8e13c141f35aa1aa542bf1fbea43d0104c02f02229d61f85000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000089d24a6b4ccb1b6faa2625fe562bdd9a2326035900000000000000000000000000000000000000000000000000000000000151800000000000000000000000000000000000000000000000000000000000895440000000000000000000000000000000000000000000000000000000000001518000000000000000000000000000000000000000000000000000000000001669800000000000000000000000000000000000000000000000000000000000001c2000000000000000000000000000000000000000000000000000000000000003e400000000000000000000000000000000000000000000000000000000000186a000000000000000000000000000000000000000000000000000000000000001c0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000151800000000000000000000000000000000000000000000000000000000000000001000000000000000000000000bf7e615e440eebacfe15666b5bea774085f4bbed00000000000000000000000000000000000000000000000000000000000000010000000000000000000000004e28e1933d0d5ae3b1951b07648d245b2811cf14",
  "constructorArguments": "00000000000000000000000036bf21c8e661b21e6166e4385f574941fdc6caffb7e66ec052db1c1d8e13c141f35aa1aa542bf1fbea43d0104c02f02229d61f85000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000089d24a6b4ccb1b6faa2625fe562bdd9a2326035900000000000000000000000000000000000000000000000000000000000151800000000000000000000000000000000000000000000000000000000000895440000000000000000000000000000000000000000000000000000000000001518000000000000000000000000000000000000000000000000000000000001669800000000000000000000000000000000000000000000000000000000000001c2000000000000000000000000000000000000000000000000000000000000003e400000000000000000000000000000000000000000000000000000000000186a000000000000000000000000000000000000000000000000000000000000001c0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000151800000000000000000000000000000000000000000000000000000000000000001000000000000000000000000bf7e615e440eebacfe15666b5bea774085f4bbed00000000000000000000000000000000000000000000000000000000000000010000000000000000000000004e28e1933d0d5ae3b1951b07648d245b2811cf14"
}