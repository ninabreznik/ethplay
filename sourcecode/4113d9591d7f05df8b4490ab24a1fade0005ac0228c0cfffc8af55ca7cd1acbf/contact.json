{
  "address": "0x575d8909d7fef2561ef8c2114d80b736fb77cbb6",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "ABChainNetContract_v5",
  "compilerVersion": "v0.4.25+commit.59dbf8f1",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2018-12-11\n*/\n\npragma solidity ^0.4.25;\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  uint256 public totalSupply;\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  /**\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\ncontract MigrationAgent {\n    function migrateFrom(address _from, uint256 _value);\n}\n\ncontract ABChainRTBtoken is StandardToken {\n  using SafeMath for uint256;\n\n  string public name = \"AB-CHAIN RTB token\";\n  string public symbol = \"RTB\";\n  uint256 public decimals = 18;\n  uint256 public INITIAL_SUPPLY = 100000000 * 1 ether;\n  uint256 public burnedCount = 0;\n  uint256 public burnedAfterSaleCount = 0;\n  address public contractOwner = 0;\n  address public migrationAgent = 0;\n\n  event Burn(address indexed burner, uint256 value);\n  event Migrate(address indexed migrator, uint256 value);\n  \n  function ABChainRTBtoken() {\n      burnedCount = 0;\n      burnedAfterSaleCount = 0;\n      totalSupply = INITIAL_SUPPLY;\n      balances[msg.sender] = INITIAL_SUPPLY;\n      contractOwner = msg.sender;\n  }\n  \n  function migrate() {\n        require(migrationAgent != 0);\n        uint256 _value = balances[msg.sender];\n        require(_value > 0);\n        burn(_value);\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, _value);\n    }\n\n    function setMigrationAgent(address _agent) {\n        require(msg.sender == contractOwner);\n        migrationAgent = _agent;\n    }\n\n  /**\n   * @dev Burns a specific amount of tokens.\n   * @param _value The amount of token to be burned.\n   */\n  function burn(uint256 _value) public {\n    require(_value <= balances[msg.sender]);\n    // no need to require value <= totalSupply, since that would imply the\n    // sender's balance is greater than the totalSupply, which *should* be an assertion failure\n\n    address burner = msg.sender;\n    balances[burner] = balances[burner].sub(_value);\n    totalSupply = totalSupply.sub(_value);\n    burnedCount = burnedCount.add(_value);\n    Burn(burner, _value);\n    }\n  // only for burn after sale\n  function burnaftersale(uint256 _value) public {\n    require(_value <= balances[msg.sender]);\n    // no need to require value <= totalSupply, since that would imply the\n    // sender's balance is greater than the totalSupply, which *should* be an assertion failure\n    address burner = msg.sender;\n    balances[burner] = balances[burner].sub(_value);\n    totalSupply = totalSupply.sub(_value);\n    burnedAfterSaleCount = burnedAfterSaleCount.add(_value);\n    Burn(burner, _value);\n    }\n    \n    // only for lazy migration\n    function () payable {\n        require(migrationAgent != 0 && msg.value == 0);\n        migrate();\n    }\n}\n\n/* AB-CHAIN Network RTB payments processing smart-contract  */\ncontract ABChainNetContract_v5 {\n    using SafeMath for uint256;\n    \n    address public contractOwner = 0;\n    address public tokenAddress = 0xEC491c1088Eae992B7A214efB0a266AD0927A72A;\n    address public ABChainRevenueAddress = 0x651Ccecc133dEa9635c84FC2C17707Ee18729f62;\n    address public ABChainPBudgetsAddress = 0x5B16ce4534c1a746cffE95ae18083969e9e1F5e9;\n    uint256 public tokenBurningPercentage = 500; // 1 = 0.01%; 500 = 5% \n    uint256 public revenuePercentage = 500; // 1 = 0.01%; 500 = 5%\n    uint256 public processedRTBs = 0;\n    uint256 public burnedRTBs = 0;\n    uint256 public netRevenueRTBs = 0;\n    uint256 public publrsBudgRTBs = 0;\n    uint256 public processingCallsCount = 0;\n    \n    // RTBProcessing event\n    event RTBProcessing(\n        address indexed sender,\n        uint256 balanceBefore,\n        uint256 burned,\n        uint256 sendedToPBudgets,\n        uint256 sendedToRevenue,\n        address indexed curABChainRevenueAddress,\n        address indexed curABChainPBudgetsAddress,\n        uint256 curRevPerc,\n        uint256 curTokenBurningPerc,\n        address curContractOwner\n    );\n    \n    constructor () public {\n        contractOwner = msg.sender;\n    }\n    \n    function unprocessedRTBBalance() public view returns (uint256) {\n        return ABChainRTBtoken(tokenAddress).balanceOf(address(this));\n    }\n    \n    // change contract owner\n    function changeOwner(address _owner) public {\n        require(msg.sender == contractOwner);\n        contractOwner = _owner;\n    }\n    \n    // change the address of the token contract\n    function changeTokenAddress(address _tokenAddress) public {\n        require(msg.sender == contractOwner);\n        tokenAddress = _tokenAddress;\n    }\n    \n    // change ABChain Revenue Address\n    function changeABChainRevenueAddress(address _ABChainRevenueAddress) public {\n        require(msg.sender == contractOwner);\n        ABChainRevenueAddress = _ABChainRevenueAddress;\n    }\n    \n    // change ABChainPBudgetsAddress\n    function changeABChainPBudgetsAddress(address _ABChainPBudgetsAddress) public {\n        require(msg.sender == contractOwner);\n        ABChainPBudgetsAddress = _ABChainPBudgetsAddress;\n    }\n    \n    // change tokenBurningPercentage\n    function changeTokenBurningPercentage(uint256 _tokenBurningPercentage) public {\n        require(msg.sender == contractOwner);\n        tokenBurningPercentage = _tokenBurningPercentage;\n    }\n    \n    // change revenuePercentage\n    function changeRevenuePercentage(uint256 _revenuePercentage) public {\n        require(msg.sender == contractOwner);\n        revenuePercentage = _revenuePercentage;\n    }\n    \n    // RTB-payments processing\n    function rtbPaymentsProcessing() public {\n        uint256 _balance = ABChainRTBtoken(tokenAddress).balanceOf(address(this));\n        require(_balance > 0);\n        \n        processingCallsCount = processingCallsCount.add(1);\n        \n        uint256 _forBurning = uint256(_balance.div(10000)).mul(tokenBurningPercentage);\n        \n        uint256 _forRevenue = uint256(_balance.div(10000)).mul(revenuePercentage);\n        \n        uint256 _forPBudgets = uint256(_balance.sub(_forBurning)).sub(_forRevenue);\n        \n        ABChainRTBtoken(tokenAddress).transfer(ABChainPBudgetsAddress, _forPBudgets);\n        \n        ABChainRTBtoken(tokenAddress).transfer(ABChainRevenueAddress, _forRevenue);\n        \n        ABChainRTBtoken(tokenAddress).burn(_forBurning);\n        \n        processedRTBs = processedRTBs.add(_balance);\n        burnedRTBs = burnedRTBs.add(_forBurning);\n        publrsBudgRTBs = publrsBudgRTBs.add(_forPBudgets);\n        netRevenueRTBs = netRevenueRTBs.add(_forRevenue);\n\n        emit RTBProcessing(\n            msg.sender,\n            _balance,\n            _forBurning,\n            _forPBudgets,\n            _forRevenue,\n            ABChainRevenueAddress,\n            ABChainPBudgetsAddress,\n            revenuePercentage,\n            tokenBurningPercentage,\n            contractOwner\n        );\n    }\n\n    // current contract version does not accept ethereum. RTB processing only :)\n    function () payable public {\n        require(msg.value == 0);\n    }\n}",
  "bytecode": "608060405260008054600160a060020a0319908116825560018054821673ec491c1088eae992b7a214efb0a266ad0927a72a17905560028054821673651ccecc133dea9635c84fc2c17707ee18729f6217905560038054909116735b16ce4534c1a746cffe95ae18083969e9e1f5e91790556101f460048190556005556006819055600781905560088190556009819055600a5534801561009f57600080fd5b5060008054600160a060020a031916331790556109a7806100c16000396000f3006080604052600436106101065763ffffffff7c01000000000000000000000000000000000000000000000000000000006000350416630160149e811461011357806335e51483146101285780633a1a7ffd1461014f578063420a3b4814610167578063595b503f1461017c5780635f605d1c146101ad5780637796200e146101c2578063782fc2ab146101d75780637b7a7f4d146101ec57806392689f051461020d57806398eb4404146102225780639d76ea5814610237578063a6f9dae11461024c578063af4dee341461026d578063afb0ed8214610285578063c9cda91f1461029a578063cc0e86bf146102bb578063ce606ee0146102dc578063f4184613146102f1575b341561011157600080fd5b005b34801561011f57600080fd5b50610111610306565b34801561013457600080fd5b5061013d6106c1565b60408051918252519081900360200190f35b34801561015b57600080fd5b50610111600435610757565b34801561017357600080fd5b5061013d610773565b34801561018857600080fd5b50610191610779565b60408051600160a060020a039092168252519081900360200190f35b3480156101b957600080fd5b5061013d610788565b3480156101ce57600080fd5b5061013d61078e565b3480156101e357600080fd5b5061013d610794565b3480156101f857600080fd5b50610111600160a060020a036004351661079a565b34801561021957600080fd5b5061013d6107e0565b34801561022e57600080fd5b506101916107e6565b34801561024357600080fd5b506101916107f5565b34801561025857600080fd5b50610111600160a060020a0360043516610804565b34801561027957600080fd5b5061011160043561084a565b34801561029157600080fd5b5061013d610866565b3480156102a657600080fd5b50610111600160a060020a036004351661086c565b3480156102c757600080fd5b50610111600160a060020a03600435166108b2565b3480156102e857600080fd5b506101916108f8565b3480156102fd57600080fd5b5061013d610907565b600154604080517f70a082310000000000000000000000000000000000000000000000000000000081523060048201529051600092839283928392600160a060020a0316916370a0823191602480830192602092919082900301818787803b15801561037157600080fd5b505af1158015610385573d6000803e3d6000fd5b505050506040513d602081101561039b57600080fd5b50519350600084116103ac57600080fd5b600a546103c090600163ffffffff61090d16565b600a556004546103e8906103dc8661271063ffffffff61092716565b9063ffffffff61093e16565b600554909350610404906103dc8661271063ffffffff61092716565b91506104268261041a868663ffffffff61096916565b9063ffffffff61096916565b600154600354604080517fa9059cbb000000000000000000000000000000000000000000000000000000008152600160a060020a03928316600482015260248101859052905193945091169163a9059cbb916044808201926020929091908290030181600087803b15801561049a57600080fd5b505af11580156104ae573d6000803e3d6000fd5b505050506040513d60208110156104c457600080fd5b5050600154600254604080517fa9059cbb000000000000000000000000000000000000000000000000000000008152600160a060020a039283166004820152602481018690529051919092169163a9059cbb9160448083019260209291908290030181600087803b15801561053857600080fd5b505af115801561054c573d6000803e3d6000fd5b505050506040513d602081101561056257600080fd5b5050600154604080517f42966c68000000000000000000000000000000000000000000000000000000008152600481018690529051600160a060020a03909216916342966c689160248082019260009290919082900301818387803b1580156105ca57600080fd5b505af11580156105de573d6000803e3d6000fd5b50506006546105f6925090508563ffffffff61090d16565b60065560075461060c908463ffffffff61090d16565b600755600954610622908263ffffffff61090d16565b600955600854610638908363ffffffff61090d16565b600855600354600254600554600454600054604080518a8152602081018a905280820188905260608101899052608081019490945260a0840192909252600160a060020a0390811660c084015290519381169392169133917f2621b602522762beaf14a5d9b0eefffed05b4bb2a553872011b2beb0dff25e3a919081900360e00190a450505050565b600154604080517f70a082310000000000000000000000000000000000000000000000000000000081523060048201529051600092600160a060020a0316916370a0823191602480830192602092919082900301818787803b15801561072657600080fd5b505af115801561073a573d6000803e3d6000fd5b505050506040513d602081101561075057600080fd5b5051905090565b600054600160a060020a0316331461076e57600080fd5b600555565b60055481565b600254600160a060020a031681565b60065481565b60085481565b60045481565b600054600160a060020a031633146107b157600080fd5b6002805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b60095481565b600354600160a060020a031681565b600154600160a060020a031681565b600054600160a060020a0316331461081b57600080fd5b6000805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b600054600160a060020a0316331461086157600080fd5b600455565b60075481565b600054600160a060020a0316331461088357600080fd5b6001805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b600054600160a060020a031633146108c957600080fd5b6003805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b600054600160a060020a031681565b600a5481565b60008282018381101561091c57fe5b8091505b5092915050565b600080828481151561093557fe5b04949350505050565b6000808315156109515760009150610920565b5082820282848281151561096157fe5b041461091c57fe5b60008282111561097557fe5b509003905600a165627a7a723058202d64bb2fc696b0f6fcfac9e78592d98f15469e789e04d9947fcdf046aac1e6fd0029"
}