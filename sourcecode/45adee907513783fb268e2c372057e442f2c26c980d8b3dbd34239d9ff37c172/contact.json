{
  "address": "0x32c48ac7ba18a7d16e6d1be63a8ce0d122eadf7a",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "DataController",
  "compilerVersion": "v0.4.19+commit.c4cbbb05",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2018-07-08\n*/\n\npragma solidity ^0.4.18;\n\n/**\n* @title SafeMath\n* @dev Math operations with safety checks that throw on error\n*/\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a * b;\n        assert(a == 0 || c / a == b);\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\n/**\n * @title Owned contract with safe ownership pass.\n *\n * Note: all the non constant functions return false instead of throwing in case if state change\n * didn't happen yet.\n */\ncontract Owned {\n    /**\n     * Contract owner address\n     */\n    address public contractOwner;\n\n    /**\n     * Contract owner address\n     */\n    address public pendingContractOwner;\n\n    function Owned() {\n        contractOwner = msg.sender;\n    }\n\n    /**\n    * @dev Owner check modifier\n    */\n    modifier onlyContractOwner() {\n        if (contractOwner == msg.sender) {\n            _;\n        }\n    }\n\n    /**\n     * @dev Destroy contract and scrub a data\n     * @notice Only owner can call it\n     */\n    function destroy() onlyContractOwner {\n        suicide(msg.sender);\n    }\n\n    /**\n     * Prepares ownership pass.\n     *\n     * Can only be called by current owner.\n     *\n     * @param _to address of the next owner. 0x0 is not allowed.\n     *\n     * @return success.\n     */\n    function changeContractOwnership(address _to) onlyContractOwner() returns(bool) {\n        if (_to  == 0x0) {\n            return false;\n        }\n\n        pendingContractOwner = _to;\n        return true;\n    }\n\n    /**\n     * Finalize ownership pass.\n     *\n     * Can only be called by pending owner.\n     *\n     * @return success.\n     */\n    function claimContractOwnership() returns(bool) {\n        if (pendingContractOwner != msg.sender) {\n            return false;\n        }\n\n        contractOwner = pendingContractOwner;\n        delete pendingContractOwner;\n\n        return true;\n    }\n}\n\ncontract ERC20Interface {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed from, address indexed spender, uint256 value);\n    string public symbol;\n\n    function totalSupply() constant returns (uint256 supply);\n    function balanceOf(address _owner) constant returns (uint256 balance);\n    function transfer(address _to, uint256 _value) returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n    function approve(address _spender, uint256 _value) returns (bool success);\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n}\n\n/**\n * @title Generic owned destroyable contract\n */\ncontract Object is Owned {\n    /**\n    *  Common result code. Means everything is fine.\n    */\n    uint constant OK = 1;\n    uint constant OWNED_ACCESS_DENIED_ONLY_CONTRACT_OWNER = 8;\n\n    function withdrawnTokens(address[] tokens, address _to) onlyContractOwner returns(uint) {\n        for(uint i=0;i<tokens.length;i++) {\n            address token = tokens[i];\n            uint balance = ERC20Interface(token).balanceOf(this);\n            if(balance != 0)\n                ERC20Interface(token).transfer(_to,balance);\n        }\n        return OK;\n    }\n\n    function checkOnlyContractOwner() internal constant returns(uint) {\n        if (contractOwner == msg.sender) {\n            return OK;\n        }\n\n        return OWNED_ACCESS_DENIED_ONLY_CONTRACT_OWNER;\n    }\n}\n\ncontract OracleMethodAdapter is Object {\n\n    event OracleAdded(bytes4 _sig, address _oracle);\n    event OracleRemoved(bytes4 _sig, address _oracle);\n\n    mapping(bytes4 => mapping(address => bool)) public oracles;\n\n    /// @dev Allow access only for oracle\n    modifier onlyOracle {\n        if (oracles[msg.sig][msg.sender]) {\n            _;\n        }\n    }\n\n    modifier onlyOracleOrOwner {\n        if (oracles[msg.sig][msg.sender] || msg.sender == contractOwner) {\n            _;\n        }\n    }\n\n    function addOracles(\n        bytes4[] _signatures, \n        address[] _oracles\n    ) \n    onlyContractOwner \n    external \n    returns (uint) \n    {\n        require(_signatures.length == _oracles.length);\n        bytes4 _sig;\n        address _oracle;\n        for (uint _idx = 0; _idx < _signatures.length; ++_idx) {\n            (_sig, _oracle) = (_signatures[_idx], _oracles[_idx]);\n            if (_oracle != 0x0 \n                && _sig != bytes4(0) \n                && !oracles[_sig][_oracle]\n            ) {\n                oracles[_sig][_oracle] = true;\n                _emitOracleAdded(_sig, _oracle);\n            }\n        }\n        return OK;\n    }\n\n    function removeOracles(\n        bytes4[] _signatures, \n        address[] _oracles\n    ) \n    onlyContractOwner \n    external \n    returns (uint) \n    {\n        require(_signatures.length == _oracles.length);\n        bytes4 _sig;\n        address _oracle;\n        for (uint _idx = 0; _idx < _signatures.length; ++_idx) {\n            (_sig, _oracle) = (_signatures[_idx], _oracles[_idx]);\n            if (_oracle != 0x0 \n                && _sig != bytes4(0) \n                && oracles[_sig][_oracle]\n            ) {\n                delete oracles[_sig][_oracle];\n                _emitOracleRemoved(_sig, _oracle);\n            }\n        }\n        return OK;\n    }\n\n    function _emitOracleAdded(bytes4 _sig, address _oracle) internal {\n        OracleAdded(_sig, _oracle);\n    }\n\n    function _emitOracleRemoved(bytes4 _sig, address _oracle) internal {\n        OracleRemoved(_sig, _oracle);\n    }\n\n}\n\n/// @title Provides possibility manage holders? country limits and limits for holders.\ncontract DataControllerInterface {\n\n    /// @notice Checks user is holder.\n    /// @param _address - checking address.\n    /// @return `true` if _address is registered holder, `false` otherwise.\n    function isHolderAddress(address _address) public view returns (bool);\n\n    function allowance(address _user) public view returns (uint);\n\n    function changeAllowance(address _holder, uint _value) public returns (uint);\n}\n\n/// @title ServiceController\n///\n/// Base implementation\n/// Serves for managing service instances\ncontract ServiceControllerInterface {\n\n    /// @notice Check target address is service\n    /// @param _address target address\n    /// @return `true` when an address is a service, `false` otherwise\n    function isService(address _address) public view returns (bool);\n}\n\ncontract ATxAssetInterface {\n\n    DataControllerInterface public dataController;\n    ServiceControllerInterface public serviceController;\n\n    function __transferWithReference(address _to, uint _value, string _reference, address _sender) public returns (bool);\n    function __transferFromWithReference(address _from, address _to, uint _value, string _reference, address _sender) public returns (bool);\n    function __approve(address _spender, uint _value, address _sender) public returns (bool);\n    function __process(bytes /*_data*/, address /*_sender*/) payable public {\n        revert();\n    }\n}\n\n/// @title ServiceAllowance.\n///\n/// Provides a way to delegate operation allowance decision to a service contract\ncontract ServiceAllowance {\n    function isTransferAllowed(address _from, address _to, address _sender, address _token, uint _value) public view returns (bool);\n}\n\ncontract ERC20 {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed from, address indexed spender, uint256 value);\n    string public symbol;\n\n    function totalSupply() constant returns (uint256 supply);\n    function balanceOf(address _owner) constant returns (uint256 balance);\n    function transfer(address _to, uint256 _value) returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n    function approve(address _spender, uint256 _value) returns (bool success);\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n}\n\ncontract Platform {\n    mapping(bytes32 => address) public proxies;\n    function name(bytes32 _symbol) public view returns (string);\n    function setProxy(address _address, bytes32 _symbol) public returns (uint errorCode);\n    function isOwner(address _owner, bytes32 _symbol) public view returns (bool);\n    function totalSupply(bytes32 _symbol) public view returns (uint);\n    function balanceOf(address _holder, bytes32 _symbol) public view returns (uint);\n    function allowance(address _from, address _spender, bytes32 _symbol) public view returns (uint);\n    function baseUnit(bytes32 _symbol) public view returns (uint8);\n    function proxyTransferWithReference(address _to, uint _value, bytes32 _symbol, string _reference, address _sender) public returns (uint errorCode);\n    function proxyTransferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference, address _sender) public returns (uint errorCode);\n    function proxyApprove(address _spender, uint _value, bytes32 _symbol, address _sender) public returns (uint errorCode);\n    function issueAsset(bytes32 _symbol, uint _value, string _name, string _description, uint8 _baseUnit, bool _isReissuable) public returns (uint errorCode);\n    function reissueAsset(bytes32 _symbol, uint _value) public returns (uint errorCode);\n    function revokeAsset(bytes32 _symbol, uint _value) public returns (uint errorCode);\n    function isReissuable(bytes32 _symbol) public view returns (bool);\n    function changeOwnership(bytes32 _symbol, address _newOwner) public returns (uint errorCode);\n}\n\ncontract ATxAssetProxy is ERC20, Object, ServiceAllowance {\n\n    using SafeMath for uint;\n\n    /**\n     * Indicates an upgrade freeze-time start, and the next asset implementation contract.\n     */\n    event UpgradeProposal(address newVersion);\n\n    // Current asset implementation contract address.\n    address latestVersion;\n\n    // Assigned platform, immutable.\n    Platform public platform;\n\n    // Assigned symbol, immutable.\n    bytes32 public smbl;\n\n    // Assigned name, immutable.\n    string public name;\n\n    /**\n     * Only platform is allowed to call.\n     */\n    modifier onlyPlatform() {\n        if (msg.sender == address(platform)) {\n            _;\n        }\n    }\n\n    /**\n     * Only current asset owner is allowed to call.\n     */\n    modifier onlyAssetOwner() {\n        if (platform.isOwner(msg.sender, smbl)) {\n            _;\n        }\n    }\n\n    /**\n     * Only asset implementation contract assigned to sender is allowed to call.\n     */\n    modifier onlyAccess(address _sender) {\n        if (getLatestVersion() == msg.sender) {\n            _;\n        }\n    }\n\n    /**\n     * Resolves asset implementation contract for the caller and forwards there transaction data,\n     * along with the value. This allows for proxy interface growth.\n     */\n    function() public payable {\n        _getAsset().__process.value(msg.value)(msg.data, msg.sender);\n    }\n\n    /**\n     * Sets platform address, assigns symbol and name.\n     *\n     * Can be set only once.\n     *\n     * @param _platform platform contract address.\n     * @param _symbol assigned symbol.\n     * @param _name assigned name.\n     *\n     * @return success.\n     */\n    function init(Platform _platform, string _symbol, string _name) public returns (bool) {\n        if (address(platform) != 0x0) {\n            return false;\n        }\n        platform = _platform;\n        symbol = _symbol;\n        smbl = stringToBytes32(_symbol);\n        name = _name;\n        return true;\n    }\n\n    /**\n     * Returns asset total supply.\n     *\n     * @return asset total supply.\n     */\n    function totalSupply() public view returns (uint) {\n        return platform.totalSupply(smbl);\n    }\n\n    /**\n     * Returns asset balance for a particular holder.\n     *\n     * @param _owner holder address.\n     *\n     * @return holder balance.\n     */\n    function balanceOf(address _owner) public view returns (uint) {\n        return platform.balanceOf(_owner, smbl);\n    }\n\n    /**\n     * Returns asset allowance from one holder to another.\n     *\n     * @param _from holder that allowed spending.\n     * @param _spender holder that is allowed to spend.\n     *\n     * @return holder to spender allowance.\n     */\n    function allowance(address _from, address _spender) public view returns (uint) {\n        return platform.allowance(_from, _spender, smbl);\n    }\n\n    /**\n     * Returns asset decimals.\n     *\n     * @return asset decimals.\n     */\n    function decimals() public view returns (uint8) {\n        return platform.baseUnit(smbl);\n    }\n\n    /**\n     * Transfers asset balance from the caller to specified receiver.\n     *\n     * @param _to holder address to give to.\n     * @param _value amount to transfer.\n     *\n     * @return success.\n     */\n    function transfer(address _to, uint _value) public returns (bool) {\n        if (_to != 0x0) {\n            return _transferWithReference(_to, _value, \"\");\n        }\n        else {\n            return false;\n        }\n    }\n\n    /**\n     * Transfers asset balance from the caller to specified receiver adding specified comment.\n     *\n     * @param _to holder address to give to.\n     * @param _value amount to transfer.\n     * @param _reference transfer comment to be included in a platform's Transfer event.\n     *\n     * @return success.\n     */\n    function transferWithReference(address _to, uint _value, string _reference) public returns (bool) {\n        if (_to != 0x0) {\n            return _transferWithReference(_to, _value, _reference);\n        }\n        else {\n            return false;\n        }\n    }\n\n    /**\n     * Performs transfer call on the platform by the name of specified sender.\n     *\n     * Can only be called by asset implementation contract assigned to sender.\n     *\n     * @param _to holder address to give to.\n     * @param _value amount to transfer.\n     * @param _reference transfer comment to be included in a platform's Transfer event.\n     * @param _sender initial caller.\n     *\n     * @return success.\n     */\n    function __transferWithReference(address _to, uint _value, string _reference, address _sender) public onlyAccess(_sender) returns (bool) {\n        return platform.proxyTransferWithReference(_to, _value, smbl, _reference, _sender) == OK;\n    }\n\n    /**\n     * Prforms allowance transfer of asset balance between holders.\n     *\n     * @param _from holder address to take from.\n     * @param _to holder address to give to.\n     * @param _value amount to transfer.\n     *\n     * @return success.\n     */\n    function transferFrom(address _from, address _to, uint _value) public returns (bool) {\n        if (_to != 0x0) {\n            return _getAsset().__transferFromWithReference(_from, _to, _value, \"\", msg.sender);\n        }\n        else {\n            return false;\n        }\n    }\n\n    /**\n     * Performs allowance transfer call on the platform by the name of specified sender.\n     *\n     * Can only be called by asset implementation contract assigned to sender.\n     *\n     * @param _from holder address to take from.\n     * @param _to holder address to give to.\n     * @param _value amount to transfer.\n     * @param _reference transfer comment to be included in a platform's Transfer event.\n     * @param _sender initial caller.\n     *\n     * @return success.\n     */\n    function __transferFromWithReference(address _from, address _to, uint _value, string _reference, address _sender) public onlyAccess(_sender) returns (bool) {\n        return platform.proxyTransferFromWithReference(_from, _to, _value, smbl, _reference, _sender) == OK;\n    }\n\n    /**\n     * Sets asset spending allowance for a specified spender.\n     *\n     * @param _spender holder address to set allowance to.\n     * @param _value amount to allow.\n     *\n     * @return success.\n     */\n    function approve(address _spender, uint _value) public returns (bool) {\n        if (_spender != 0x0) {\n            return _getAsset().__approve(_spender, _value, msg.sender);\n        }\n        else {\n            return false;\n        }\n    }\n\n    /**\n     * Performs allowance setting call on the platform by the name of specified sender.\n     *\n     * Can only be called by asset implementation contract assigned to sender.\n     *\n     * @param _spender holder address to set allowance to.\n     * @param _value amount to allow.\n     * @param _sender initial caller.\n     *\n     * @return success.\n     */\n    function __approve(address _spender, uint _value, address _sender) public onlyAccess(_sender) returns (bool) {\n        return platform.proxyApprove(_spender, _value, smbl, _sender) == OK;\n    }\n\n    /**\n     * Emits ERC20 Transfer event on this contract.\n     *\n     * Can only be, and, called by assigned platform when asset transfer happens.\n     */\n    function emitTransfer(address _from, address _to, uint _value) public onlyPlatform() {\n        Transfer(_from, _to, _value);\n    }\n\n    /**\n     * Emits ERC20 Approval event on this contract.\n     *\n     * Can only be, and, called by assigned platform when asset allowance set happens.\n     */\n    function emitApprove(address _from, address _spender, uint _value) public onlyPlatform() {\n        Approval(_from, _spender, _value);\n    }\n\n    /**\n     * Returns current asset implementation contract address.\n     *\n     * @return asset implementation contract address.\n     */\n    function getLatestVersion() public view returns (address) {\n        return latestVersion;\n    }\n\n    /**\n     * Propose next asset implementation contract address.\n     *\n     * Can only be called by current asset owner.\n     *\n     * Note: freeze-time should not be applied for the initial setup.\n     *\n     * @param _newVersion asset implementation contract address.\n     *\n     * @return success.\n     */\n    function proposeUpgrade(address _newVersion) public onlyAssetOwner returns (bool) {\n        // New version address should be other than 0x0.\n        if (_newVersion == 0x0) {\n            return false;\n        }\n        \n        latestVersion = _newVersion;\n\n        UpgradeProposal(_newVersion); \n        return true;\n    }\n\n    function isTransferAllowed(address, address, address, address, uint) public view returns (bool) {\n        return true;\n    }\n\n    /**\n     * Returns asset implementation contract for current caller.\n     *\n     * @return asset implementation contract.\n     */\n    function _getAsset() internal view returns (ATxAssetInterface) {\n        return ATxAssetInterface(getLatestVersion());\n    }\n\n    /**\n     * Resolves asset implementation contract for the caller and forwards there arguments along with\n     * the caller address.\n     *\n     * @return success.\n     */\n    function _transferWithReference(address _to, uint _value, string _reference) internal returns (bool) {\n        return _getAsset().__transferWithReference(_to, _value, _reference, msg.sender);\n    }\n\n    function stringToBytes32(string memory source) private pure returns (bytes32 result) {\n        assembly {\n            result := mload(add(source, 32))\n        }\n    }\n}\n\ncontract DataControllerEmitter {\n\n    event CountryCodeAdded(uint _countryCode, uint _countryId, uint _maxHolderCount);\n    event CountryCodeChanged(uint _countryCode, uint _countryId, uint _maxHolderCount);\n\n    event HolderRegistered(bytes32 _externalHolderId, uint _accessIndex, uint _countryCode);\n    event HolderAddressAdded(bytes32 _externalHolderId, address _holderPrototype, uint _accessIndex);\n    event HolderAddressRemoved(bytes32 _externalHolderId, address _holderPrototype, uint _accessIndex);\n    event HolderOperationalChanged(bytes32 _externalHolderId, bool _operational);\n\n    event DayLimitChanged(bytes32 _externalHolderId, uint _from, uint _to);\n    event MonthLimitChanged(bytes32 _externalHolderId, uint _from, uint _to);\n\n    event Error(uint _errorCode);\n\n    function _emitHolderAddressAdded(bytes32 _externalHolderId, address _holderPrototype, uint _accessIndex) internal {\n        HolderAddressAdded(_externalHolderId, _holderPrototype, _accessIndex);\n    }\n\n    function _emitHolderAddressRemoved(bytes32 _externalHolderId, address _holderPrototype, uint _accessIndex) internal {\n        HolderAddressRemoved(_externalHolderId, _holderPrototype, _accessIndex);\n    }\n\n    function _emitHolderRegistered(bytes32 _externalHolderId, uint _accessIndex, uint _countryCode) internal {\n        HolderRegistered(_externalHolderId, _accessIndex, _countryCode);\n    }\n\n    function _emitHolderOperationalChanged(bytes32 _externalHolderId, bool _operational) internal {\n        HolderOperationalChanged(_externalHolderId, _operational);\n    }\n\n    function _emitCountryCodeAdded(uint _countryCode, uint _countryId, uint _maxHolderCount) internal {\n        CountryCodeAdded(_countryCode, _countryId, _maxHolderCount);\n    }\n\n    function _emitCountryCodeChanged(uint _countryCode, uint _countryId, uint _maxHolderCount) internal {\n        CountryCodeChanged(_countryCode, _countryId, _maxHolderCount);\n    }\n\n    function _emitDayLimitChanged(bytes32 _externalHolderId, uint _from, uint _to) internal {\n        DayLimitChanged(_externalHolderId, _from, _to);\n    }\n\n    function _emitMonthLimitChanged(bytes32 _externalHolderId, uint _from, uint _to) internal {\n        MonthLimitChanged(_externalHolderId, _from, _to);\n    }\n\n    function _emitError(uint _errorCode) internal returns (uint) {\n        Error(_errorCode);\n        return _errorCode;\n    }\n}\n\ncontract GroupsAccessManagerEmitter {\n\n    event UserCreated(address user);\n    event UserDeleted(address user);\n    event GroupCreated(bytes32 groupName);\n    event GroupActivated(bytes32 groupName);\n    event GroupDeactivated(bytes32 groupName);\n    event UserToGroupAdded(address user, bytes32 groupName);\n    event UserFromGroupRemoved(address user, bytes32 groupName);\n}\n\n/// @title Group Access Manager\n///\n/// Base implementation\n/// This contract serves as group manager\ncontract GroupsAccessManager is Object, GroupsAccessManagerEmitter {\n\n    uint constant USER_MANAGER_SCOPE = 111000;\n    uint constant USER_MANAGER_MEMBER_ALREADY_EXIST = USER_MANAGER_SCOPE + 1;\n    uint constant USER_MANAGER_GROUP_ALREADY_EXIST = USER_MANAGER_SCOPE + 2;\n    uint constant USER_MANAGER_OBJECT_ALREADY_SECURED = USER_MANAGER_SCOPE + 3;\n    uint constant USER_MANAGER_CONFIRMATION_HAS_COMPLETED = USER_MANAGER_SCOPE + 4;\n    uint constant USER_MANAGER_USER_HAS_CONFIRMED = USER_MANAGER_SCOPE + 5;\n    uint constant USER_MANAGER_NOT_ENOUGH_GAS = USER_MANAGER_SCOPE + 6;\n    uint constant USER_MANAGER_INVALID_INVOCATION = USER_MANAGER_SCOPE + 7;\n    uint constant USER_MANAGER_DONE = USER_MANAGER_SCOPE + 11;\n    uint constant USER_MANAGER_CANCELLED = USER_MANAGER_SCOPE + 12;\n\n    using SafeMath for uint;\n\n    struct Member {\n        address addr;\n        uint groupsCount;\n        mapping(bytes32 => uint) groupName2index;\n        mapping(uint => uint) index2globalIndex;\n    }\n\n    struct Group {\n        bytes32 name;\n        uint priority;\n        uint membersCount;\n        mapping(address => uint) memberAddress2index;\n        mapping(uint => uint) index2globalIndex;\n    }\n\n    uint public membersCount;\n    mapping(uint => address) index2memberAddress;\n    mapping(address => uint) memberAddress2index;\n    mapping(address => Member) address2member;\n\n    uint public groupsCount;\n    mapping(uint => bytes32) index2groupName;\n    mapping(bytes32 => uint) groupName2index;\n    mapping(bytes32 => Group) groupName2group;\n    mapping(bytes32 => bool) public groupsBlocked; // if groupName => true, then couldn't be used for confirmation\n\n    function() payable public {\n        revert();\n    }\n\n    /// @notice Register user\n    /// Can be called only by contract owner\n    ///\n    /// @param _user user address\n    ///\n    /// @return code\n    function registerUser(address _user) external onlyContractOwner returns (uint) {\n        require(_user != 0x0);\n\n        if (isRegisteredUser(_user)) {\n            return USER_MANAGER_MEMBER_ALREADY_EXIST;\n        }\n\n        uint _membersCount = membersCount.add(1);\n        membersCount = _membersCount;\n        memberAddress2index[_user] = _membersCount;\n        index2memberAddress[_membersCount] = _user;\n        address2member[_user] = Member(_user, 0);\n\n        UserCreated(_user);\n        return OK;\n    }\n\n    /// @notice Discard user registration\n    /// Can be called only by contract owner\n    ///\n    /// @param _user user address\n    ///\n    /// @return code\n    function unregisterUser(address _user) external onlyContractOwner returns (uint) {\n        require(_user != 0x0);\n\n        uint _memberIndex = memberAddress2index[_user];\n        if (_memberIndex == 0 || address2member[_user].groupsCount != 0) {\n            return USER_MANAGER_INVALID_INVOCATION;\n        }\n\n        uint _membersCount = membersCount;\n        delete memberAddress2index[_user];\n        if (_memberIndex != _membersCount) {\n            address _lastUser = index2memberAddress[_membersCount];\n            index2memberAddress[_memberIndex] = _lastUser;\n            memberAddress2index[_lastUser] = _memberIndex;\n        }\n        delete address2member[_user];\n        delete index2memberAddress[_membersCount];\n        delete memberAddress2index[_user];\n        membersCount = _membersCount.sub(1);\n\n        UserDeleted(_user);\n        return OK;\n    }\n\n    /// @notice Create group\n    /// Can be called only by contract owner\n    ///\n    /// @param _groupName group name\n    /// @param _priority group priority\n    ///\n    /// @return code\n    function createGroup(bytes32 _groupName, uint _priority) external onlyContractOwner returns (uint) {\n        require(_groupName != bytes32(0));\n\n        if (isGroupExists(_groupName)) {\n            return USER_MANAGER_GROUP_ALREADY_EXIST;\n        }\n\n        uint _groupsCount = groupsCount.add(1);\n        groupName2index[_groupName] = _groupsCount;\n        index2groupName[_groupsCount] = _groupName;\n        groupName2group[_groupName] = Group(_groupName, _priority, 0);\n        groupsCount = _groupsCount;\n\n        GroupCreated(_groupName);\n        return OK;\n    }\n\n    /// @notice Change group status\n    /// Can be called only by contract owner\n    ///\n    /// @param _groupName group name\n    /// @param _blocked block status\n    ///\n    /// @return code\n    function changeGroupActiveStatus(bytes32 _groupName, bool _blocked) external onlyContractOwner returns (uint) {\n        require(isGroupExists(_groupName));\n        groupsBlocked[_groupName] = _blocked;\n        return OK;\n    }\n\n    /// @notice Add users in group\n    /// Can be called only by contract owner\n    ///\n    /// @param _groupName group name\n    /// @param _users user array\n    ///\n    /// @return code\n    function addUsersToGroup(bytes32 _groupName, address[] _users) external onlyContractOwner returns (uint) {\n        require(isGroupExists(_groupName));\n\n        Group storage _group = groupName2group[_groupName];\n        uint _groupMembersCount = _group.membersCount;\n\n        for (uint _userIdx = 0; _userIdx < _users.length; ++_userIdx) {\n            address _user = _users[_userIdx];\n            uint _memberIndex = memberAddress2index[_user];\n            require(_memberIndex != 0);\n\n            if (_group.memberAddress2index[_user] != 0) {\n                continue;\n            }\n\n            _groupMembersCount = _groupMembersCount.add(1);\n            _group.memberAddress2index[_user] = _groupMembersCount;\n            _group.index2globalIndex[_groupMembersCount] = _memberIndex;\n\n            _addGroupToMember(_user, _groupName);\n\n            UserToGroupAdded(_user, _groupName);\n        }\n        _group.membersCount = _groupMembersCount;\n\n        return OK;\n    }\n\n    /// @notice Remove users in group\n    /// Can be called only by contract owner\n    ///\n    /// @param _groupName group name\n    /// @param _users user array\n    ///\n    /// @return code\n    function removeUsersFromGroup(bytes32 _groupName, address[] _users) external onlyContractOwner returns (uint) {\n        require(isGroupExists(_groupName));\n\n        Group storage _group = groupName2group[_groupName];\n        uint _groupMembersCount = _group.membersCount;\n\n        for (uint _userIdx = 0; _userIdx < _users.length; ++_userIdx) {\n            address _user = _users[_userIdx];\n            uint _memberIndex = memberAddress2index[_user];\n            uint _groupMemberIndex = _group.memberAddress2index[_user];\n\n            if (_memberIndex == 0 || _groupMemberIndex == 0) {\n                continue;\n            }\n\n            if (_groupMemberIndex != _groupMembersCount) {\n                uint _lastUserGlobalIndex = _group.index2globalIndex[_groupMembersCount];\n                address _lastUser = index2memberAddress[_lastUserGlobalIndex];\n                _group.index2globalIndex[_groupMemberIndex] = _lastUserGlobalIndex;\n                _group.memberAddress2index[_lastUser] = _groupMemberIndex;\n            }\n            delete _group.memberAddress2index[_user];\n            delete _group.index2globalIndex[_groupMembersCount];\n            _groupMembersCount = _groupMembersCount.sub(1);\n\n            _removeGroupFromMember(_user, _groupName);\n\n            UserFromGroupRemoved(_user, _groupName);\n        }\n        _group.membersCount = _groupMembersCount;\n\n        return OK;\n    }\n\n    /// @notice Check is user registered\n    ///\n    /// @param _user user address\n    ///\n    /// @return status\n    function isRegisteredUser(address _user) public view returns (bool) {\n        return memberAddress2index[_user] != 0;\n    }\n\n    /// @notice Check is user in group\n    ///\n    /// @param _groupName user array\n    /// @param _user user array\n    ///\n    /// @return status\n    function isUserInGroup(bytes32 _groupName, address _user) public view returns (bool) {\n        return isRegisteredUser(_user) && address2member[_user].groupName2index[_groupName] != 0;\n    }\n\n    /// @notice Check is group exist\n    ///\n    /// @param _groupName group name\n    ///\n    /// @return status\n    function isGroupExists(bytes32 _groupName) public view returns (bool) {\n        return groupName2index[_groupName] != 0;\n    }\n\n    /// @notice Get current group names\n    ///\n    /// @return group names\n    function getGroups() public view returns (bytes32[] _groups) {\n        uint _groupsCount = groupsCount;\n        _groups = new bytes32[](_groupsCount);\n        for (uint _groupIdx = 0; _groupIdx < _groupsCount; ++_groupIdx) {\n            _groups[_groupIdx] = index2groupName[_groupIdx + 1];\n        }\n    }\n\n    // PRIVATE\n\n    function _removeGroupFromMember(address _user, bytes32 _groupName) private {\n        Member storage _member = address2member[_user];\n        uint _memberGroupsCount = _member.groupsCount;\n        uint _memberGroupIndex = _member.groupName2index[_groupName];\n        if (_memberGroupIndex != _memberGroupsCount) {\n            uint _lastGroupGlobalIndex = _member.index2globalIndex[_memberGroupsCount];\n            bytes32 _lastGroupName = index2groupName[_lastGroupGlobalIndex];\n            _member.index2globalIndex[_memberGroupIndex] = _lastGroupGlobalIndex;\n            _member.groupName2index[_lastGroupName] = _memberGroupIndex;\n        }\n        delete _member.groupName2index[_groupName];\n        delete _member.index2globalIndex[_memberGroupsCount];\n        _member.groupsCount = _memberGroupsCount.sub(1);\n    }\n\n    function _addGroupToMember(address _user, bytes32 _groupName) private {\n        Member storage _member = address2member[_user];\n        uint _memberGroupsCount = _member.groupsCount.add(1);\n        _member.groupName2index[_groupName] = _memberGroupsCount;\n        _member.index2globalIndex[_memberGroupsCount] = groupName2index[_groupName];\n        _member.groupsCount = _memberGroupsCount;\n    }\n}\n\ncontract PendingManagerEmitter {\n\n    event PolicyRuleAdded(bytes4 sig, address contractAddress, bytes32 key, bytes32 groupName, uint acceptLimit, uint declinesLimit);\n    event PolicyRuleRemoved(bytes4 sig, address contractAddress, bytes32 key, bytes32 groupName);\n\n    event ProtectionTxAdded(bytes32 key, bytes32 sig, uint blockNumber);\n    event ProtectionTxAccepted(bytes32 key, address indexed sender, bytes32 groupNameVoted);\n    event ProtectionTxDone(bytes32 key);\n    event ProtectionTxDeclined(bytes32 key, address indexed sender, bytes32 groupNameVoted);\n    event ProtectionTxCancelled(bytes32 key);\n    event ProtectionTxVoteRevoked(bytes32 key, address indexed sender, bytes32 groupNameVoted);\n    event TxDeleted(bytes32 key);\n\n    event Error(uint errorCode);\n\n    function _emitError(uint _errorCode) internal returns (uint) {\n        Error(_errorCode);\n        return _errorCode;\n    }\n}\n\ncontract PendingManagerInterface {\n\n    function signIn(address _contract) external returns (uint);\n    function signOut(address _contract) external returns (uint);\n\n    function addPolicyRule(\n        bytes4 _sig, \n        address _contract, \n        bytes32 _groupName, \n        uint _acceptLimit, \n        uint _declineLimit \n        ) \n        external returns (uint);\n        \n    function removePolicyRule(\n        bytes4 _sig, \n        address _contract, \n        bytes32 _groupName\n        ) \n        external returns (uint);\n\n    function addTx(bytes32 _key, bytes4 _sig, address _contract) external returns (uint);\n    function deleteTx(bytes32 _key) external returns (uint);\n\n    function accept(bytes32 _key, bytes32 _votingGroupName) external returns (uint);\n    function decline(bytes32 _key, bytes32 _votingGroupName) external returns (uint);\n    function revoke(bytes32 _key) external returns (uint);\n\n    function hasConfirmedRecord(bytes32 _key) public view returns (uint);\n    function getPolicyDetails(bytes4 _sig, address _contract) public view returns (\n        bytes32[] _groupNames,\n        uint[] _acceptLimits,\n        uint[] _declineLimits,\n        uint _totalAcceptedLimit,\n        uint _totalDeclinedLimit\n        );\n}\n\n/// @title PendingManager\n///\n/// Base implementation\n/// This contract serves as pending manager for transaction status\ncontract PendingManager is Object, PendingManagerEmitter, PendingManagerInterface {\n\n    uint constant NO_RECORDS_WERE_FOUND = 4;\n    uint constant PENDING_MANAGER_SCOPE = 4000;\n    uint constant PENDING_MANAGER_INVALID_INVOCATION = PENDING_MANAGER_SCOPE + 1;\n    uint constant PENDING_MANAGER_HASNT_VOTED = PENDING_MANAGER_SCOPE + 2;\n    uint constant PENDING_DUPLICATE_TX = PENDING_MANAGER_SCOPE + 3;\n    uint constant PENDING_MANAGER_CONFIRMED = PENDING_MANAGER_SCOPE + 4;\n    uint constant PENDING_MANAGER_REJECTED = PENDING_MANAGER_SCOPE + 5;\n    uint constant PENDING_MANAGER_IN_PROCESS = PENDING_MANAGER_SCOPE + 6;\n    uint constant PENDING_MANAGER_TX_DOESNT_EXIST = PENDING_MANAGER_SCOPE + 7;\n    uint constant PENDING_MANAGER_TX_WAS_DECLINED = PENDING_MANAGER_SCOPE + 8;\n    uint constant PENDING_MANAGER_TX_WAS_NOT_CONFIRMED = PENDING_MANAGER_SCOPE + 9;\n    uint constant PENDING_MANAGER_INSUFFICIENT_GAS = PENDING_MANAGER_SCOPE + 10;\n    uint constant PENDING_MANAGER_POLICY_NOT_FOUND = PENDING_MANAGER_SCOPE + 11;\n\n    using SafeMath for uint;\n\n    enum GuardState {\n        Decline, Confirmed, InProcess\n    }\n\n    struct Requirements {\n        bytes32 groupName;\n        uint acceptLimit;\n        uint declineLimit;\n    }\n\n    struct Policy {\n        uint groupsCount;\n        mapping(uint => Requirements) participatedGroups; // index => globalGroupIndex\n        mapping(bytes32 => uint) groupName2index; // groupName => localIndex\n        \n        uint totalAcceptedLimit;\n        uint totalDeclinedLimit;\n\n        uint securesCount;\n        mapping(uint => uint) index2txIndex;\n        mapping(uint => uint) txIndex2index;\n    }\n\n    struct Vote {\n        bytes32 groupName;\n        bool accepted;\n    }\n\n    struct Guard {\n        GuardState state;\n        uint basePolicyIndex;\n\n        uint alreadyAccepted;\n        uint alreadyDeclined;\n        \n        mapping(address => Vote) votes; // member address => vote\n        mapping(bytes32 => uint) acceptedCount; // groupName => how many from group has already accepted\n        mapping(bytes32 => uint) declinedCount; // groupName => how many from group has already declined\n    }\n\n    address public accessManager;\n\n    mapping(address => bool) public authorized;\n\n    uint public policiesCount;\n    mapping(uint => bytes32) index2PolicyId; // index => policy hash\n    mapping(bytes32 => uint) policyId2Index; // policy hash => index\n    mapping(bytes32 => Policy) policyId2policy; // policy hash => policy struct\n\n    uint public txCount;\n    mapping(uint => bytes32) index2txKey;\n    mapping(bytes32 => uint) txKey2index; // tx key => index\n    mapping(bytes32 => Guard) txKey2guard;\n\n    /// @dev Execution is allowed only by authorized contract\n    modifier onlyAuthorized {\n        if (authorized[msg.sender] || address(this) == msg.sender) {\n            _;\n        }\n    }\n\n    /// @dev Pending Manager's constructor\n    ///\n    /// @param _accessManager access manager's address\n    function PendingManager(address _accessManager) public {\n        require(_accessManager != 0x0);\n        accessManager = _accessManager;\n    }\n\n    function() payable public {\n        revert();\n    }\n\n    /// @notice Update access manager address\n    ///\n    /// @param _accessManager access manager's address\n    function setAccessManager(address _accessManager) external onlyContractOwner returns (uint) {\n        require(_accessManager != 0x0);\n        accessManager = _accessManager;\n        return OK;\n    }\n\n    /// @notice Sign in contract\n    ///\n    /// @param _contract contract's address\n    function signIn(address _contract) external onlyContractOwner returns (uint) {\n        require(_contract != 0x0);\n        authorized[_contract] = true;\n        return OK;\n    }\n\n    /// @notice Sign out contract\n    ///\n    /// @param _contract contract's address\n    function signOut(address _contract) external onlyContractOwner returns (uint) {\n        require(_contract != 0x0);\n        delete authorized[_contract];\n        return OK;\n    }\n\n    /// @notice Register new policy rule\n    /// Can be called only by contract owner\n    ///\n    /// @param _sig target method signature\n    /// @param _contract target contract address\n    /// @param _groupName group's name\n    /// @param _acceptLimit accepted vote limit\n    /// @param _declineLimit decline vote limit\n    ///\n    /// @return code\n    function addPolicyRule(\n        bytes4 _sig,\n        address _contract,\n        bytes32 _groupName,\n        uint _acceptLimit,\n        uint _declineLimit\n    )\n    onlyContractOwner\n    external\n    returns (uint)\n    {\n        require(_sig != 0x0);\n        require(_contract != 0x0);\n        require(GroupsAccessManager(accessManager).isGroupExists(_groupName));\n        require(_acceptLimit != 0);\n        require(_declineLimit != 0);\n\n        bytes32 _policyHash = keccak256(_sig, _contract);\n        \n        if (policyId2Index[_policyHash] == 0) {\n            uint _policiesCount = policiesCount.add(1);\n            index2PolicyId[_policiesCount] = _policyHash;\n            policyId2Index[_policyHash] = _policiesCount;\n            policiesCount = _policiesCount;\n        }\n\n        Policy storage _policy = policyId2policy[_policyHash];\n        uint _policyGroupsCount = _policy.groupsCount;\n\n        if (_policy.groupName2index[_groupName] == 0) {\n            _policyGroupsCount += 1;\n            _policy.groupName2index[_groupName] = _policyGroupsCount;\n            _policy.participatedGroups[_policyGroupsCount].groupName = _groupName;\n            _policy.groupsCount = _policyGroupsCount;\n        }\n\n        uint _previousAcceptLimit = _policy.participatedGroups[_policyGroupsCount].acceptLimit;\n        uint _previousDeclineLimit = _policy.participatedGroups[_policyGroupsCount].declineLimit;\n        _policy.participatedGroups[_policyGroupsCount].acceptLimit = _acceptLimit;\n        _policy.participatedGroups[_policyGroupsCount].declineLimit = _declineLimit;\n        _policy.totalAcceptedLimit = _policy.totalAcceptedLimit.sub(_previousAcceptLimit).add(_acceptLimit);\n        _policy.totalDeclinedLimit = _policy.totalDeclinedLimit.sub(_previousDeclineLimit).add(_declineLimit);\n\n        PolicyRuleAdded(_sig, _contract, _policyHash, _groupName, _acceptLimit, _declineLimit);\n        return OK;\n    }\n\n    /// @notice Remove policy rule\n    /// Can be called only by contract owner\n    ///\n    /// @param _groupName group's name\n    ///\n    /// @return code\n    function removePolicyRule(\n        bytes4 _sig,\n        address _contract,\n        bytes32 _groupName\n    ) \n    onlyContractOwner \n    external \n    returns (uint) \n    {\n        require(_sig != bytes4(0));\n        require(_contract != 0x0);\n        require(GroupsAccessManager(accessManager).isGroupExists(_groupName));\n\n        bytes32 _policyHash = keccak256(_sig, _contract);\n        Policy storage _policy = policyId2policy[_policyHash];\n        uint _policyGroupNameIndex = _policy.groupName2index[_groupName];\n\n        if (_policyGroupNameIndex == 0) {\n            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\n        }\n\n        uint _policyGroupsCount = _policy.groupsCount;\n        if (_policyGroupNameIndex != _policyGroupsCount) {\n            Requirements storage _requirements = _policy.participatedGroups[_policyGroupsCount];\n            _policy.participatedGroups[_policyGroupNameIndex] = _requirements;\n            _policy.groupName2index[_requirements.groupName] = _policyGroupNameIndex;\n        }\n\n        _policy.totalAcceptedLimit = _policy.totalAcceptedLimit.sub(_policy.participatedGroups[_policyGroupsCount].acceptLimit);\n        _policy.totalDeclinedLimit = _policy.totalDeclinedLimit.sub(_policy.participatedGroups[_policyGroupsCount].declineLimit);\n\n        delete _policy.groupName2index[_groupName];\n        delete _policy.participatedGroups[_policyGroupsCount];\n        _policy.groupsCount = _policyGroupsCount.sub(1);\n\n        PolicyRuleRemoved(_sig, _contract, _policyHash, _groupName);\n        return OK;\n    }\n\n    /// @notice Add transaction\n    ///\n    /// @param _key transaction id\n    ///\n    /// @return code\n    function addTx(bytes32 _key, bytes4 _sig, address _contract) external onlyAuthorized returns (uint) {\n        require(_key != bytes32(0));\n        require(_sig != bytes4(0));\n        require(_contract != 0x0);\n\n        bytes32 _policyHash = keccak256(_sig, _contract);\n        require(isPolicyExist(_policyHash));\n\n        if (isTxExist(_key)) {\n            return _emitError(PENDING_DUPLICATE_TX);\n        }\n\n        if (_policyHash == bytes32(0)) {\n            return _emitError(PENDING_MANAGER_POLICY_NOT_FOUND);\n        }\n\n        uint _index = txCount.add(1);\n        txCount = _index;\n        index2txKey[_index] = _key;\n        txKey2index[_key] = _index;\n\n        Guard storage _guard = txKey2guard[_key];\n        _guard.basePolicyIndex = policyId2Index[_policyHash];\n        _guard.state = GuardState.InProcess;\n\n        Policy storage _policy = policyId2policy[_policyHash];\n        uint _counter = _policy.securesCount.add(1);\n        _policy.securesCount = _counter;\n        _policy.index2txIndex[_counter] = _index;\n        _policy.txIndex2index[_index] = _counter;\n\n        ProtectionTxAdded(_key, _policyHash, block.number);\n        return OK;\n    }\n\n    /// @notice Delete transaction\n    /// @param _key transaction id\n    /// @return code\n    function deleteTx(bytes32 _key) external onlyContractOwner returns (uint) {\n        require(_key != bytes32(0));\n\n        if (!isTxExist(_key)) {\n            return _emitError(PENDING_MANAGER_TX_DOESNT_EXIST);\n        }\n\n        uint _txsCount = txCount;\n        uint _txIndex = txKey2index[_key];\n        if (_txIndex != _txsCount) {\n            bytes32 _last = index2txKey[txCount];\n            index2txKey[_txIndex] = _last;\n            txKey2index[_last] = _txIndex;\n        }\n\n        delete txKey2index[_key];\n        delete index2txKey[_txsCount];\n        txCount = _txsCount.sub(1);\n\n        uint _basePolicyIndex = txKey2guard[_key].basePolicyIndex;\n        Policy storage _policy = policyId2policy[index2PolicyId[_basePolicyIndex]];\n        uint _counter = _policy.securesCount;\n        uint _policyTxIndex = _policy.txIndex2index[_txIndex];\n        if (_policyTxIndex != _counter) {\n            uint _movedTxIndex = _policy.index2txIndex[_counter];\n            _policy.index2txIndex[_policyTxIndex] = _movedTxIndex;\n            _policy.txIndex2index[_movedTxIndex] = _policyTxIndex;\n        }\n\n        delete _policy.index2txIndex[_counter];\n        delete _policy.txIndex2index[_txIndex];\n        _policy.securesCount = _counter.sub(1);\n\n        TxDeleted(_key);\n        return OK;\n    }\n\n    /// @notice Accept transaction\n    /// Can be called only by registered user in GroupsAccessManager\n    ///\n    /// @param _key transaction id\n    ///\n    /// @return code\n    function accept(bytes32 _key, bytes32 _votingGroupName) external returns (uint) {\n        if (!isTxExist(_key)) {\n            return _emitError(PENDING_MANAGER_TX_DOESNT_EXIST);\n        }\n\n        if (!GroupsAccessManager(accessManager).isUserInGroup(_votingGroupName, msg.sender)) {\n            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\n        }\n\n        Guard storage _guard = txKey2guard[_key];\n        if (_guard.state != GuardState.InProcess) {\n            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\n        }\n\n        if (_guard.votes[msg.sender].groupName != bytes32(0) && _guard.votes[msg.sender].accepted) {\n            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\n        }\n\n        Policy storage _policy = policyId2policy[index2PolicyId[_guard.basePolicyIndex]];\n        uint _policyGroupIndex = _policy.groupName2index[_votingGroupName];\n        uint _groupAcceptedVotesCount = _guard.acceptedCount[_votingGroupName];\n        if (_groupAcceptedVotesCount == _policy.participatedGroups[_policyGroupIndex].acceptLimit) {\n            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\n        }\n\n        _guard.votes[msg.sender] = Vote(_votingGroupName, true);\n        _guard.acceptedCount[_votingGroupName] = _groupAcceptedVotesCount + 1;\n        uint _alreadyAcceptedCount = _guard.alreadyAccepted + 1;\n        _guard.alreadyAccepted = _alreadyAcceptedCount;\n\n        ProtectionTxAccepted(_key, msg.sender, _votingGroupName);\n\n        if (_alreadyAcceptedCount == _policy.totalAcceptedLimit) {\n            _guard.state = GuardState.Confirmed;\n            ProtectionTxDone(_key);\n        }\n\n        return OK;\n    }\n\n    /// @notice Decline transaction\n    /// Can be called only by registered user in GroupsAccessManager\n    ///\n    /// @param _key transaction id\n    ///\n    /// @return code\n    function decline(bytes32 _key, bytes32 _votingGroupName) external returns (uint) {\n        if (!isTxExist(_key)) {\n            return _emitError(PENDING_MANAGER_TX_DOESNT_EXIST);\n        }\n\n        if (!GroupsAccessManager(accessManager).isUserInGroup(_votingGroupName, msg.sender)) {\n            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\n        }\n\n        Guard storage _guard = txKey2guard[_key];\n        if (_guard.state != GuardState.InProcess) {\n            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\n        }\n\n        if (_guard.votes[msg.sender].groupName != bytes32(0) && !_guard.votes[msg.sender].accepted) {\n            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\n        }\n\n        Policy storage _policy = policyId2policy[index2PolicyId[_guard.basePolicyIndex]];\n        uint _policyGroupIndex = _policy.groupName2index[_votingGroupName];\n        uint _groupDeclinedVotesCount = _guard.declinedCount[_votingGroupName];\n        if (_groupDeclinedVotesCount == _policy.participatedGroups[_policyGroupIndex].declineLimit) {\n            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\n        }\n\n        _guard.votes[msg.sender] = Vote(_votingGroupName, false);\n        _guard.declinedCount[_votingGroupName] = _groupDeclinedVotesCount + 1;\n        uint _alreadyDeclinedCount = _guard.alreadyDeclined + 1;\n        _guard.alreadyDeclined = _alreadyDeclinedCount;\n\n\n        ProtectionTxDeclined(_key, msg.sender, _votingGroupName);\n\n        if (_alreadyDeclinedCount == _policy.totalDeclinedLimit) {\n            _guard.state = GuardState.Decline;\n            ProtectionTxCancelled(_key);\n        }\n\n        return OK;\n    }\n\n    /// @notice Revoke user votes for transaction\n    /// Can be called only by contract owner\n    ///\n    /// @param _key transaction id\n    /// @param _user target user address\n    ///\n    /// @return code\n    function forceRejectVotes(bytes32 _key, address _user) external onlyContractOwner returns (uint) {\n        return _revoke(_key, _user);\n    }\n\n    /// @notice Revoke vote for transaction\n    /// Can be called only by authorized user\n    /// @param _key transaction id\n    /// @return code\n    function revoke(bytes32 _key) external returns (uint) {\n        return _revoke(_key, msg.sender);\n    }\n\n    /// @notice Check transaction status\n    /// @param _key transaction id\n    /// @return code\n    function hasConfirmedRecord(bytes32 _key) public view returns (uint) {\n        require(_key != bytes32(0));\n\n        if (!isTxExist(_key)) {\n            return NO_RECORDS_WERE_FOUND;\n        }\n\n        Guard storage _guard = txKey2guard[_key];\n        return _guard.state == GuardState.InProcess\n        ? PENDING_MANAGER_IN_PROCESS\n        : _guard.state == GuardState.Confirmed\n        ? OK\n        : PENDING_MANAGER_REJECTED;\n    }\n\n\n    /// @notice Check policy details\n    ///\n    /// @return _groupNames group names included in policies\n    /// @return _acceptLimits accept limit for group\n    /// @return _declineLimits decline limit for group\n    function getPolicyDetails(bytes4 _sig, address _contract)\n    public\n    view\n    returns (\n        bytes32[] _groupNames,\n        uint[] _acceptLimits,\n        uint[] _declineLimits,\n        uint _totalAcceptedLimit,\n        uint _totalDeclinedLimit\n    ) {\n        require(_sig != bytes4(0));\n        require(_contract != 0x0);\n        \n        bytes32 _policyHash = keccak256(_sig, _contract);\n        uint _policyIdx = policyId2Index[_policyHash];\n        if (_policyIdx == 0) {\n            return;\n        }\n\n        Policy storage _policy = policyId2policy[_policyHash];\n        uint _policyGroupsCount = _policy.groupsCount;\n        _groupNames = new bytes32[](_policyGroupsCount);\n        _acceptLimits = new uint[](_policyGroupsCount);\n        _declineLimits = new uint[](_policyGroupsCount);\n\n        for (uint _idx = 0; _idx < _policyGroupsCount; ++_idx) {\n            Requirements storage _requirements = _policy.participatedGroups[_idx + 1];\n            _groupNames[_idx] = _requirements.groupName;\n            _acceptLimits[_idx] = _requirements.acceptLimit;\n            _declineLimits[_idx] = _requirements.declineLimit;\n        }\n\n        (_totalAcceptedLimit, _totalDeclinedLimit) = (_policy.totalAcceptedLimit, _policy.totalDeclinedLimit);\n    }\n\n    /// @notice Check policy include target group\n    /// @param _policyHash policy hash (sig, contract address)\n    /// @param _groupName group id\n    /// @return bool\n    function isGroupInPolicy(bytes32 _policyHash, bytes32 _groupName) public view returns (bool) {\n        Policy storage _policy = policyId2policy[_policyHash];\n        return _policy.groupName2index[_groupName] != 0;\n    }\n\n    /// @notice Check is policy exist\n    /// @param _policyHash policy hash (sig, contract address)\n    /// @return bool\n    function isPolicyExist(bytes32 _policyHash) public view returns (bool) {\n        return policyId2Index[_policyHash] != 0;\n    }\n\n    /// @notice Check is transaction exist\n    /// @param _key transaction id\n    /// @return bool\n    function isTxExist(bytes32 _key) public view returns (bool){\n        return txKey2index[_key] != 0;\n    }\n\n    function _updateTxState(Policy storage _policy, Guard storage _guard, uint confirmedAmount, uint declineAmount) private {\n        if (declineAmount != 0 && _guard.state != GuardState.Decline) {\n            _guard.state = GuardState.Decline;\n        } else if (confirmedAmount >= _policy.groupsCount && _guard.state != GuardState.Confirmed) {\n            _guard.state = GuardState.Confirmed;\n        } else if (_guard.state != GuardState.InProcess) {\n            _guard.state = GuardState.InProcess;\n        }\n    }\n\n    function _revoke(bytes32 _key, address _user) private returns (uint) {\n        require(_key != bytes32(0));\n        require(_user != 0x0);\n\n        if (!isTxExist(_key)) {\n            return _emitError(PENDING_MANAGER_TX_DOESNT_EXIST);\n        }\n\n        Guard storage _guard = txKey2guard[_key];\n        if (_guard.state != GuardState.InProcess) {\n            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\n        }\n\n        bytes32 _votedGroupName = _guard.votes[_user].groupName;\n        if (_votedGroupName == bytes32(0)) {\n            return _emitError(PENDING_MANAGER_HASNT_VOTED);\n        }\n\n        bool isAcceptedVote = _guard.votes[_user].accepted;\n        if (isAcceptedVote) {\n            _guard.acceptedCount[_votedGroupName] = _guard.acceptedCount[_votedGroupName].sub(1);\n            _guard.alreadyAccepted = _guard.alreadyAccepted.sub(1);\n        } else {\n            _guard.declinedCount[_votedGroupName] = _guard.declinedCount[_votedGroupName].sub(1);\n            _guard.alreadyDeclined = _guard.alreadyDeclined.sub(1);\n\n        }\n\n        delete _guard.votes[_user];\n\n        ProtectionTxVoteRevoked(_key, _user, _votedGroupName);\n        return OK;\n    }\n}\n\n/// @title MultiSigAdapter\n///\n/// Abstract implementation\n/// This contract serves as transaction signer\ncontract MultiSigAdapter is Object {\n\n    uint constant MULTISIG_ADDED = 3;\n    uint constant NO_RECORDS_WERE_FOUND = 4;\n\n    modifier isAuthorized {\n        if (msg.sender == contractOwner || msg.sender == getPendingManager()) {\n            _;\n        }\n    }\n\n    /// @notice Get pending address\n    /// @dev abstract. Needs child implementation\n    ///\n    /// @return pending address\n    function getPendingManager() public view returns (address);\n\n    /// @notice Sign current transaction and add it to transaction pending queue\n    ///\n    /// @return code\n    function _multisig(bytes32 _args, uint _block) internal returns (uint _code) {\n        bytes32 _txHash = _getKey(_args, _block);\n        address _manager = getPendingManager();\n\n        _code = PendingManager(_manager).hasConfirmedRecord(_txHash);\n        if (_code != NO_RECORDS_WERE_FOUND) {\n            return _code;\n        }\n\n        if (OK != PendingManager(_manager).addTx(_txHash, msg.sig, address(this))) {\n            revert();\n        }\n\n        return MULTISIG_ADDED;\n    }\n\n    function _isTxExistWithArgs(bytes32 _args, uint _block) internal view returns (bool) {\n        bytes32 _txHash = _getKey(_args, _block);\n        address _manager = getPendingManager();\n        return PendingManager(_manager).isTxExist(_txHash);\n    }\n\n    function _getKey(bytes32 _args, uint _block) private view returns (bytes32 _txHash) {\n        _block = _block != 0 ? _block : block.number;\n        _txHash = keccak256(msg.sig, _args, _block);\n    }\n}\n\n/// @title ServiceController\n///\n/// Base implementation\n/// Serves for managing service instances\ncontract ServiceController is MultiSigAdapter {\n\n    event Error(uint _errorCode);\n\n    uint constant SERVICE_CONTROLLER = 350000;\n    uint constant SERVICE_CONTROLLER_EMISSION_EXIST = SERVICE_CONTROLLER + 1;\n    uint constant SERVICE_CONTROLLER_BURNING_MAN_EXIST = SERVICE_CONTROLLER + 2;\n    uint constant SERVICE_CONTROLLER_ALREADY_INITIALIZED = SERVICE_CONTROLLER + 3;\n    uint constant SERVICE_CONTROLLER_SERVICE_EXIST = SERVICE_CONTROLLER + 4;\n\n    address public profiterole;\n    address public treasury;\n    address public pendingManager;\n    address public proxy;\n\n    uint public sideServicesCount;\n    mapping(uint => address) public index2sideService;\n    mapping(address => uint) public sideService2index;\n    mapping(address => bool) public sideServices;\n\n    uint public emissionProvidersCount;\n    mapping(uint => address) public index2emissionProvider;\n    mapping(address => uint) public emissionProvider2index;\n    mapping(address => bool) public emissionProviders;\n\n    uint public burningMansCount;\n    mapping(uint => address) public index2burningMan;\n    mapping(address => uint) public burningMan2index;\n    mapping(address => bool) public burningMans;\n\n    /// @notice Default ServiceController's constructor\n    ///\n    /// @param _pendingManager pending manager address\n    /// @param _proxy ERC20 proxy address\n    /// @param _profiterole profiterole address\n    /// @param _treasury treasury address\n    function ServiceController(address _pendingManager, address _proxy, address _profiterole, address _treasury) public {\n        require(_pendingManager != 0x0);\n        require(_proxy != 0x0);\n        require(_profiterole != 0x0);\n        require(_treasury != 0x0);\n        pendingManager = _pendingManager;\n        proxy = _proxy;\n        profiterole = _profiterole;\n        treasury = _treasury;\n    }\n\n    /// @notice Return pending manager address\n    ///\n    /// @return code\n    function getPendingManager() public view returns (address) {\n        return pendingManager;\n    }\n\n    /// @notice Add emission provider\n    ///\n    /// @param _provider emission provider address\n    ///\n    /// @return code\n    function addEmissionProvider(address _provider, uint _block) public returns (uint _code) {\n        if (emissionProviders[_provider]) {\n            return _emitError(SERVICE_CONTROLLER_EMISSION_EXIST);\n        }\n        _code = _multisig(keccak256(_provider), _block);\n        if (OK != _code) {\n            return _code;\n        }\n\n        emissionProviders[_provider] = true;\n        uint _count = emissionProvidersCount + 1;\n        index2emissionProvider[_count] = _provider;\n        emissionProvider2index[_provider] = _count;\n        emissionProvidersCount = _count;\n\n        return OK;\n    }\n\n    /// @notice Remove emission provider\n    ///\n    /// @param _provider emission provider address\n    ///\n    /// @return code\n    function removeEmissionProvider(address _provider, uint _block) public returns (uint _code) {\n        _code = _multisig(keccak256(_provider), _block);\n        if (OK != _code) {\n            return _code;\n        }\n\n        uint _idx = emissionProvider2index[_provider];\n        uint _lastIdx = emissionProvidersCount;\n        if (_idx != 0) {\n            if (_idx != _lastIdx) {\n                address _lastEmissionProvider = index2emissionProvider[_lastIdx];\n                index2emissionProvider[_idx] = _lastEmissionProvider;\n                emissionProvider2index[_lastEmissionProvider] = _idx;\n            }\n\n            delete emissionProvider2index[_provider];\n            delete index2emissionProvider[_lastIdx];\n            delete emissionProviders[_provider];\n            emissionProvidersCount = _lastIdx - 1;\n        }\n\n        return OK;\n    }\n\n    /// @notice Add burning man\n    ///\n    /// @param _burningMan burning man address\n    ///\n    /// @return code\n    function addBurningMan(address _burningMan, uint _block) public returns (uint _code) {\n        if (burningMans[_burningMan]) {\n            return _emitError(SERVICE_CONTROLLER_BURNING_MAN_EXIST);\n        }\n\n        _code = _multisig(keccak256(_burningMan), _block);\n        if (OK != _code) {\n            return _code;\n        }\n\n        burningMans[_burningMan] = true;\n        uint _count = burningMansCount + 1;\n        index2burningMan[_count] = _burningMan;\n        burningMan2index[_burningMan] = _count;\n        burningMansCount = _count;\n\n        return OK;\n    }\n\n    /// @notice Remove burning man\n    ///\n    /// @param _burningMan burning man address\n    ///\n    /// @return code\n    function removeBurningMan(address _burningMan, uint _block) public returns (uint _code) {\n        _code = _multisig(keccak256(_burningMan), _block);\n        if (OK != _code) {\n            return _code;\n        }\n\n        uint _idx = burningMan2index[_burningMan];\n        uint _lastIdx = burningMansCount;\n        if (_idx != 0) {\n            if (_idx != _lastIdx) {\n                address _lastBurningMan = index2burningMan[_lastIdx];\n                index2burningMan[_idx] = _lastBurningMan;\n                burningMan2index[_lastBurningMan] = _idx;\n            }\n            \n            delete burningMan2index[_burningMan];\n            delete index2burningMan[_lastIdx];\n            delete burningMans[_burningMan];\n            burningMansCount = _lastIdx - 1;\n        }\n\n        return OK;\n    }\n\n    /// @notice Update a profiterole address\n    ///\n    /// @param _profiterole profiterole address\n    ///\n    /// @return result code of an operation\n    function updateProfiterole(address _profiterole, uint _block) public returns (uint _code) {\n        _code = _multisig(keccak256(_profiterole), _block);\n        if (OK != _code) {\n            return _code;\n        }\n\n        profiterole = _profiterole;\n        return OK;\n    }\n\n    /// @notice Update a treasury address\n    ///\n    /// @param _treasury treasury address\n    ///\n    /// @return result code of an operation\n    function updateTreasury(address _treasury, uint _block) public returns (uint _code) {\n        _code = _multisig(keccak256(_treasury), _block);\n        if (OK != _code) {\n            return _code;\n        }\n\n        treasury = _treasury;\n        return OK;\n    }\n\n    /// @notice Update pending manager address\n    ///\n    /// @param _pendingManager pending manager address\n    ///\n    /// @return result code of an operation\n    function updatePendingManager(address _pendingManager, uint _block) public returns (uint _code) {\n        _code = _multisig(keccak256(_pendingManager), _block);\n        if (OK != _code) {\n            return _code;\n        }\n\n        pendingManager = _pendingManager;\n        return OK;\n    }\n\n    function addSideService(address _service, uint _block) public returns (uint _code) {\n        if (sideServices[_service]) {\n            return SERVICE_CONTROLLER_SERVICE_EXIST;\n        }\n        _code = _multisig(keccak256(_service), _block);\n        if (OK != _code) {\n            return _code;\n        }\n\n        sideServices[_service] = true;\n        uint _count = sideServicesCount + 1;\n        index2sideService[_count] = _service;\n        sideService2index[_service] = _count;\n        sideServicesCount = _count;\n\n        return OK;\n    }\n\n    function removeSideService(address _service, uint _block) public returns (uint _code) {\n        _code = _multisig(keccak256(_service), _block);\n        if (OK != _code) {\n            return _code;\n        }\n\n        uint _idx = sideService2index[_service];\n        uint _lastIdx = sideServicesCount;\n        if (_idx != 0) {\n            if (_idx != _lastIdx) {\n                address _lastSideService = index2sideService[_lastIdx];\n                index2sideService[_idx] = _lastSideService;\n                sideService2index[_lastSideService] = _idx;\n            }\n            \n            delete sideService2index[_service];\n            delete index2sideService[_lastIdx];\n            delete sideServices[_service];\n            sideServicesCount = _lastIdx - 1;\n        }\n\n        return OK;\n    }\n\n    function getEmissionProviders()\n    public\n    view\n    returns (address[] _emissionProviders)\n    {\n        _emissionProviders = new address[](emissionProvidersCount);\n        for (uint _idx = 0; _idx < _emissionProviders.length; ++_idx) {\n            _emissionProviders[_idx] = index2emissionProvider[_idx + 1];\n        }\n    }\n\n    function getBurningMans()\n    public\n    view\n    returns (address[] _burningMans)\n    {\n        _burningMans = new address[](burningMansCount);\n        for (uint _idx = 0; _idx < _burningMans.length; ++_idx) {\n            _burningMans[_idx] = index2burningMan[_idx + 1];\n        }\n    }\n\n    function getSideServices()\n    public\n    view\n    returns (address[] _sideServices)\n    {\n        _sideServices = new address[](sideServicesCount);\n        for (uint _idx = 0; _idx < _sideServices.length; ++_idx) {\n            _sideServices[_idx] = index2sideService[_idx + 1];\n        }\n    }\n\n    /// @notice Check target address is service\n    ///\n    /// @param _address target address\n    ///\n    /// @return `true` when an address is a service, `false` otherwise\n    function isService(address _address) public view returns (bool check) {\n        return _address == profiterole ||\n            _address == treasury || \n            _address == proxy || \n            _address == pendingManager || \n            emissionProviders[_address] || \n            burningMans[_address] ||\n            sideServices[_address];\n    }\n\n    function _emitError(uint _errorCode) internal returns (uint) {\n        Error(_errorCode);\n        return _errorCode;\n    }\n}\n\n/// @title Provides possibility manage holders? country limits and limits for holders.\ncontract DataController is OracleMethodAdapter, DataControllerEmitter {\n\n    /* CONSTANTS */\n\n    uint constant DATA_CONTROLLER = 109000;\n    uint constant DATA_CONTROLLER_ERROR = DATA_CONTROLLER + 1;\n    uint constant DATA_CONTROLLER_CURRENT_WRONG_LIMIT = DATA_CONTROLLER + 2;\n    uint constant DATA_CONTROLLER_WRONG_ALLOWANCE = DATA_CONTROLLER + 3;\n    uint constant DATA_CONTROLLER_COUNTRY_CODE_ALREADY_EXISTS = DATA_CONTROLLER + 4;\n\n    uint constant MAX_TOKEN_HOLDER_NUMBER = 2 ** 256 - 1;\n\n    using SafeMath for uint;\n\n    /* STRUCTS */\n\n    /// @title HoldersData couldn't be public because of internal structures, so needed to provide getters for different parts of _holderData\n    struct HoldersData {\n        uint countryCode;\n        uint sendLimPerDay;\n        uint sendLimPerMonth;\n        bool operational;\n        bytes text;\n        uint holderAddressCount;\n        mapping(uint => address) index2Address;\n        mapping(address => uint) address2Index;\n    }\n\n    struct CountryLimits {\n        uint countryCode;\n        uint maxTokenHolderNumber;\n        uint currentTokenHolderNumber;\n    }\n\n    /* FIELDS */\n\n    address public withdrawal;\n    address assetAddress;\n    address public serviceController;\n\n    mapping(address => uint) public allowance;\n\n    // Iterable mapping pattern is used for holders.\n    /// @dev This is an access address mapping. Many addresses may have access to a single holder.\n    uint public holdersCount;\n    mapping(uint => HoldersData) holders;\n    mapping(address => bytes32) holderAddress2Id;\n    mapping(bytes32 => uint) public holderIndex;\n\n    // This is an access address mapping. Many addresses may have access to a single holder.\n    uint public countriesCount;\n    mapping(uint => CountryLimits) countryLimitsList;\n    mapping(uint => uint) countryIndex;\n\n    /* MODIFIERS */\n\n    modifier onlyWithdrawal {\n        if (msg.sender != withdrawal) {\n            revert();\n        }\n        _;\n    }\n\n    modifier onlyAsset {\n        if (msg.sender == _getATxToken().getLatestVersion()) {\n            _;\n        }\n    }\n\n    modifier onlyContractOwner {\n        if (msg.sender == contractOwner) {\n            _;\n        }\n    }\n\n    /// @notice Constructor for _holderData controller.\n    /// @param _serviceController service controller\n    function DataController(address _serviceController) public {\n        require(_serviceController != 0x0);\n\n        serviceController = _serviceController;\n    }\n\n    function() payable public {\n        revert();\n    }\n\n    function setWithdraw(address _withdrawal) onlyContractOwner external returns (uint) {\n        require(_withdrawal != 0x0);\n        withdrawal = _withdrawal;\n        return OK;\n    }\n\n    function setServiceController(address _serviceController) \n    onlyContractOwner\n    external\n    returns (uint)\n    {\n        require(_serviceController != 0x0);\n        \n        serviceController = _serviceController;\n        return OK;\n    }\n\n\n    function getPendingManager() public view returns (address) {\n        return ServiceController(serviceController).getPendingManager();\n    }\n\n    function getHolderInfo(bytes32 _externalHolderId) public view returns (\n        uint _countryCode,\n        uint _limPerDay,\n        uint _limPerMonth,\n        bool _operational,\n        bytes _text\n    ) {\n        HoldersData storage _data = holders[holderIndex[_externalHolderId]];\n        return (_data.countryCode, _data.sendLimPerDay, _data.sendLimPerMonth, _data.operational, _data.text);\n    }\n\n    function getHolderAddresses(bytes32 _externalHolderId) public view returns (address[] _addresses) {\n        HoldersData storage _holderData = holders[holderIndex[_externalHolderId]];\n        uint _addressesCount = _holderData.holderAddressCount;\n        _addresses = new address[](_addressesCount);\n        for (uint _holderAddressIdx = 0; _holderAddressIdx < _addressesCount; ++_holderAddressIdx) {\n            _addresses[_holderAddressIdx] = _holderData.index2Address[_holderAddressIdx + 1];\n        }\n    }\n\n    function getHolderCountryCode(bytes32 _externalHolderId) public view returns (uint) {\n        return holders[holderIndex[_externalHolderId]].countryCode;\n    }\n\n    function getHolderExternalIdByAddress(address _address) public view returns (bytes32) {\n        return holderAddress2Id[_address];\n    }\n\n    /// @notice Checks user is holder.\n    /// @param _address checking address.\n    /// @return `true` if _address is registered holder, `false` otherwise.\n    function isRegisteredAddress(address _address) public view returns (bool) {\n        return holderIndex[holderAddress2Id[_address]] != 0;\n    }\n\n    function isHolderOwnAddress(\n        bytes32 _externalHolderId, \n        address _address\n    ) \n    public \n    view \n    returns (bool) \n    {\n        uint _holderIndex = holderIndex[_externalHolderId];\n        if (_holderIndex == 0) {\n            return false;\n        }\n        return holders[_holderIndex].address2Index[_address] != 0;\n    }\n\n    function getCountryInfo(uint _countryCode) \n    public \n    view \n    returns (\n        uint _maxHolderNumber, \n        uint _currentHolderCount\n    ) {\n        CountryLimits storage _data = countryLimitsList[countryIndex[_countryCode]];\n        return (_data.maxTokenHolderNumber, _data.currentTokenHolderNumber);\n    }\n\n    function getCountryLimit(uint _countryCode) public view returns (uint limit) {\n        uint _index = countryIndex[_countryCode];\n        require(_index != 0);\n        return countryLimitsList[_index].maxTokenHolderNumber;\n    }\n\n    function addCountryCode(uint _countryCode) onlyContractOwner public returns (uint) {\n        var (,_created) = _createCountryId(_countryCode);\n        if (!_created) {\n            return _emitError(DATA_CONTROLLER_COUNTRY_CODE_ALREADY_EXISTS);\n        }\n        return OK;\n    }\n\n    /// @notice Returns holder id for the specified address, creates it if needed.\n    /// @param _externalHolderId holder address.\n    /// @param _countryCode country code.\n    /// @return error code.\n    function registerHolder(\n        bytes32 _externalHolderId, \n        address _holderAddress, \n        uint _countryCode\n    ) \n    onlyOracleOrOwner \n    external \n    returns (uint) \n    {\n        require(_holderAddress != 0x0);\n        require(holderIndex[_externalHolderId] == 0);\n        uint _holderIndex = holderIndex[holderAddress2Id[_holderAddress]];\n        require(_holderIndex == 0);\n\n        _createCountryId(_countryCode);\n        _holderIndex = holdersCount.add(1);\n        holdersCount = _holderIndex;\n\n        HoldersData storage _holderData = holders[_holderIndex];\n        _holderData.countryCode = _countryCode;\n        _holderData.operational = true;\n        _holderData.sendLimPerDay = MAX_TOKEN_HOLDER_NUMBER;\n        _holderData.sendLimPerMonth = MAX_TOKEN_HOLDER_NUMBER;\n        uint _firstAddressIndex = 1;\n        _holderData.holderAddressCount = _firstAddressIndex;\n        _holderData.address2Index[_holderAddress] = _firstAddressIndex;\n        _holderData.index2Address[_firstAddressIndex] = _holderAddress;\n        holderIndex[_externalHolderId] = _holderIndex;\n        holderAddress2Id[_holderAddress] = _externalHolderId;\n\n        _emitHolderRegistered(_externalHolderId, _holderIndex, _countryCode);\n        return OK;\n    }\n\n    /// @notice Adds new address equivalent to holder.\n    /// @param _externalHolderId external holder identifier.\n    /// @param _newAddress adding address.\n    /// @return error code.\n    function addHolderAddress(\n        bytes32 _externalHolderId, \n        address _newAddress\n    ) \n    onlyOracleOrOwner \n    external \n    returns (uint) \n    {\n        uint _holderIndex = holderIndex[_externalHolderId];\n        require(_holderIndex != 0);\n\n        uint _newAddressId = holderIndex[holderAddress2Id[_newAddress]];\n        require(_newAddressId == 0);\n\n        HoldersData storage _holderData = holders[_holderIndex];\n\n        if (_holderData.address2Index[_newAddress] == 0) {\n            _holderData.holderAddressCount = _holderData.holderAddressCount.add(1);\n            _holderData.address2Index[_newAddress] = _holderData.holderAddressCount;\n            _holderData.index2Address[_holderData.holderAddressCount] = _newAddress;\n        }\n\n        holderAddress2Id[_newAddress] = _externalHolderId;\n\n        _emitHolderAddressAdded(_externalHolderId, _newAddress, _holderIndex);\n        return OK;\n    }\n\n    /// @notice Remove an address owned by a holder.\n    /// @param _externalHolderId external holder identifier.\n    /// @param _address removing address.\n    /// @return error code.\n    function removeHolderAddress(\n        bytes32 _externalHolderId, \n        address _address\n    ) \n    onlyOracleOrOwner \n    external \n    returns (uint) \n    {\n        uint _holderIndex = holderIndex[_externalHolderId];\n        require(_holderIndex != 0);\n\n        HoldersData storage _holderData = holders[_holderIndex];\n\n        uint _tempIndex = _holderData.address2Index[_address];\n        require(_tempIndex != 0);\n\n        address _lastAddress = _holderData.index2Address[_holderData.holderAddressCount];\n        _holderData.address2Index[_lastAddress] = _tempIndex;\n        _holderData.index2Address[_tempIndex] = _lastAddress;\n        delete _holderData.address2Index[_address];\n        _holderData.holderAddressCount = _holderData.holderAddressCount.sub(1);\n\n        delete holderAddress2Id[_address];\n\n        _emitHolderAddressRemoved(_externalHolderId, _address, _holderIndex);\n        return OK;\n    }\n\n    /// @notice Change operational status for holder.\n    /// Can be accessed by contract owner or oracle only.\n    ///\n    /// @param _externalHolderId external holder identifier.\n    /// @param _operational operational status.\n    ///\n    /// @return result code.\n    function changeOperational(\n        bytes32 _externalHolderId, \n        bool _operational\n    ) \n    onlyOracleOrOwner \n    external \n    returns (uint) \n    {\n        uint _holderIndex = holderIndex[_externalHolderId];\n        require(_holderIndex != 0);\n\n        holders[_holderIndex].operational = _operational;\n\n        _emitHolderOperationalChanged(_externalHolderId, _operational);\n        return OK;\n    }\n\n    /// @notice Changes text for holder.\n    /// Can be accessed by contract owner or oracle only.\n    ///\n    /// @param _externalHolderId external holder identifier.\n    /// @param _text changing text.\n    ///\n    /// @return result code.\n    function updateTextForHolder(\n        bytes32 _externalHolderId, \n        bytes _text\n    ) \n    onlyOracleOrOwner \n    external \n    returns (uint) \n    {\n        uint _holderIndex = holderIndex[_externalHolderId];\n        require(_holderIndex != 0);\n\n        holders[_holderIndex].text = _text;\n        return OK;\n    }\n\n    /// @notice Updates limit per day for holder.\n    ///\n    /// Can be accessed by contract owner only.\n    ///\n    /// @param _externalHolderId external holder identifier.\n    /// @param _limit limit value.\n    ///\n    /// @return result code.\n    function updateLimitPerDay(\n        bytes32 _externalHolderId, \n        uint _limit\n    ) \n    onlyOracleOrOwner \n    external \n    returns (uint) \n    {\n        uint _holderIndex = holderIndex[_externalHolderId];\n        require(_holderIndex != 0);\n\n        uint _currentLimit = holders[_holderIndex].sendLimPerDay;\n        holders[_holderIndex].sendLimPerDay = _limit;\n\n        _emitDayLimitChanged(_externalHolderId, _currentLimit, _limit);\n        return OK;\n    }\n\n    /// @notice Updates limit per month for holder.\n    /// Can be accessed by contract owner or oracle only.\n    ///\n    /// @param _externalHolderId external holder identifier.\n    /// @param _limit limit value.\n    ///\n    /// @return result code.\n    function updateLimitPerMonth(\n        bytes32 _externalHolderId, \n        uint _limit\n    ) \n    onlyOracleOrOwner \n    external \n    returns (uint) \n    {\n        uint _holderIndex = holderIndex[_externalHolderId];\n        require(_holderIndex != 0);\n\n        uint _currentLimit = holders[_holderIndex].sendLimPerDay;\n        holders[_holderIndex].sendLimPerMonth = _limit;\n\n        _emitMonthLimitChanged(_externalHolderId, _currentLimit, _limit);\n        return OK;\n    }\n\n    /// @notice Change country limits.\n    /// Can be accessed by contract owner or oracle only.\n    ///\n    /// @param _countryCode country code.\n    /// @param _limit limit value.\n    ///\n    /// @return result code.\n    function changeCountryLimit(\n        uint _countryCode, \n        uint _limit\n    ) \n    onlyOracleOrOwner \n    external \n    returns (uint) \n    {\n        uint _countryIndex = countryIndex[_countryCode];\n        require(_countryIndex != 0);\n\n        uint _currentTokenHolderNumber = countryLimitsList[_countryIndex].currentTokenHolderNumber;\n        if (_currentTokenHolderNumber > _limit) {\n            return _emitError(DATA_CONTROLLER_CURRENT_WRONG_LIMIT);\n        }\n\n        countryLimitsList[_countryIndex].maxTokenHolderNumber = _limit;\n        \n        _emitCountryCodeChanged(_countryIndex, _countryCode, _limit);\n        return OK;\n    }\n\n    function withdrawFrom(\n        address _holderAddress, \n        uint _value\n    ) \n    onlyAsset \n    public \n    returns (uint) \n    {\n        bytes32 _externalHolderId = holderAddress2Id[_holderAddress];\n        HoldersData storage _holderData = holders[holderIndex[_externalHolderId]];\n        _holderData.sendLimPerDay = _holderData.sendLimPerDay.sub(_value);\n        _holderData.sendLimPerMonth = _holderData.sendLimPerMonth.sub(_value);\n        return OK;\n    }\n\n    function depositTo(\n        address _holderAddress, \n        uint _value\n    ) \n    onlyAsset \n    public \n    returns (uint) \n    {\n        bytes32 _externalHolderId = holderAddress2Id[_holderAddress];\n        HoldersData storage _holderData = holders[holderIndex[_externalHolderId]];\n        _holderData.sendLimPerDay = _holderData.sendLimPerDay.add(_value);\n        _holderData.sendLimPerMonth = _holderData.sendLimPerMonth.add(_value);\n        return OK;\n    }\n\n    function updateCountryHoldersCount(\n        uint _countryCode, \n        uint _updatedHolderCount\n    ) \n    public \n    onlyAsset \n    returns (uint) \n    {\n        CountryLimits storage _data = countryLimitsList[countryIndex[_countryCode]];\n        assert(_data.maxTokenHolderNumber >= _updatedHolderCount);\n        _data.currentTokenHolderNumber = _updatedHolderCount;\n        return OK;\n    }\n\n    function changeAllowance(address _from, uint _value) public onlyWithdrawal returns (uint) {\n        ATxAssetProxy token = _getATxToken();\n        if (token.balanceOf(_from) < _value) {\n            return _emitError(DATA_CONTROLLER_WRONG_ALLOWANCE);\n        }\n        allowance[_from] = _value;\n        return OK;\n    }\n\n    function _createCountryId(uint _countryCode) internal returns (uint, bool _created) {\n        uint countryId = countryIndex[_countryCode];\n        if (countryId == 0) {\n            uint _countriesCount = countriesCount;\n            countryId = _countriesCount.add(1);\n            countriesCount = countryId;\n            CountryLimits storage limits = countryLimitsList[countryId];\n            limits.countryCode = _countryCode;\n            limits.maxTokenHolderNumber = MAX_TOKEN_HOLDER_NUMBER;\n\n            countryIndex[_countryCode] = countryId;\n            _emitCountryCodeAdded(countryIndex[_countryCode], _countryCode, MAX_TOKEN_HOLDER_NUMBER);\n\n            _created = true;\n        }\n\n        return (countryId, _created);\n    }\n\n    function _getATxToken() private view returns (ATxAssetProxy) {\n        ServiceController _serviceController = ServiceController(serviceController);\n        return ATxAssetProxy(_serviceController.proxy());\n    }\n}",
  "bytecode": "6060604052341561000f57600080fd5b6040516020806121138339810160405280805160008054600160a060020a03191633600160a060020a039081169190911790915590925082161515905061005557600080fd5b60058054600160a060020a031916600160a060020a039290921691909117905561208f806100846000396000f3006060604052600436106101c95763ffffffff60e060020a6000350416630302263a81146101ce578063079a193b146101fd5780630eabdab6146102315780631b1665ca1461025b5780633e5beab9146102745780634592cd1d146102935780634e9cf5b1146102ba5780634ea9a27a146102d55780635447fab0146102fa578063557f4bc91461030d5780635aa77d3c1461032c5780635d7188181461033f5780636b4ed21b1461035557806375151f6b1461036857806383197ef01461037e5780638a3a5724146103935780639008d64f146103b25780639470b0bd1461045f57806397db48bd146104815780639d471837146104a3578063a339aaf7146104c5578063acf7aea7146104ef578063afe8b65214610505578063baee193d14610518578063bf98199514610531578063c07bcfdc1461055f578063c5313bc114610578578063ce0086f61461058e578063ce606ee0146105b0578063d4e93292146105c3578063d5ad3ad0146105d6578063d8f9659b146105f5578063db0c7ca81461064f578063dcdd6d381461066e578063e47dea1d146106d7578063e65f0246146106f6578063e7d29e381461070f578063f150b8ee14610731578063ffaad6a51461075d575b600080fd5b34156101d957600080fd5b6101e161077f565b604051600160a060020a03909116815260200160405180910390f35b341561020857600080fd5b61021f600160a060020a03600435166024356107e9565b60405190815260200160405180910390f35b341561023c57600080fd5b61021f60246004803582810192908201359181359182019101356108c6565b341561026657600080fd5b61021f6004356024356109ff565b341561027f57600080fd5b61021f600160a060020a0360043516610aa3565b341561029e57600080fd5b6102a6610ab5565b604051901515815260200160405180910390f35b34156102c557600080fd5b61021f6004356024351515610aff565b34156102e057600080fd5b61021f600435600160a060020a0360243516604435610b9d565b341561030557600080fd5b6101e1610d23565b341561031857600080fd5b6102a6600160a060020a0360043516610d32565b341561033757600080fd5b6101e1610d84565b341561034a57600080fd5b61021f600435610d93565b341561036057600080fd5b61021f610db2565b341561037357600080fd5b61021f600435610db8565b341561038957600080fd5b610391610e03565b005b341561039e57600080fd5b61021f600160a060020a0360043516610e28565b34156103bd57600080fd5b6103c8600435610e43565b6040518581526020810185905260408101849052821515606082015260a06080820181815290820183818151815260200191508051906020019080838360005b83811015610420578082015183820152602001610408565b50505050905090810190601f16801561044d5780820380516001836020036101000a031916815260200191505b50965050505050505060405180910390f35b341561046a57600080fd5b61021f600160a060020a0360043516602435610f41565b341561048c57600080fd5b6102a6600435600160a060020a036024351661103a565b34156104ae57600080fd5b61021f60048035906024803590810191013561108a565b34156104d057600080fd5b61021f6024600480358281019290820135918135918201910135611121565b34156104fa57600080fd5b61021f60043561124e565b341561051057600080fd5b61021f611281565b341561052357600080fd5b61021f600435602435611287565b341561053c57600080fd5b610547600435611344565b60405191825260208201526040908101905180910390f35b341561056a57600080fd5b61021f60043560243561136e565b341561058357600080fd5b61021f600435611401565b341561059957600080fd5b61021f600435600160a060020a0360243516611413565b34156105bb57600080fd5b6101e1611569565b34156105ce57600080fd5b6101e1611578565b34156105e157600080fd5b61021f600160a060020a0360043516611587565b341561060057600080fd5b61021f600460248135818101908301358060208181020160405190810160405280939291908181526020018383602002808284375094965050509235600160a060020a031692506115d9915050565b341561065a57600080fd5b6102a6600160a060020a0360043516611728565b341561067957600080fd5b610684600435611752565b60405160208082528190810183818151815260200191508051906020019060200280838360005b838110156106c35780820151838201526020016106ab565b505050509050019250505060405180910390f35b34156106e257600080fd5b61021f600160a060020a03600435166117fd565b341561070157600080fd5b61021f60043560243561184f565b341561071a57600080fd5b61021f600435600160a060020a036024351661190d565b341561073c57600080fd5b6102a6600160e060020a031960043516600160a060020a0360243516611a63565b341561076857600080fd5b61021f600160a060020a0360043516602435611a83565b600554600090600160a060020a0316630302263a82604051602001526040518163ffffffff1660e060020a028152600401602060405180830381600087803b15156107c957600080fd5b6102c65a03f115156107da57600080fd5b50505060405180519150505b90565b600354600090819033600160a060020a0390811691161461080957600080fd5b610811611b6b565b90508281600160a060020a03166370a082318660006040516020015260405160e060020a63ffffffff8416028152600160a060020a039091166004820152602401602060405180830381600087803b151561086b57600080fd5b6102c65a03f1151561087c57600080fd5b50505060405180519050101561089f576108986201a9cb611bd7565b91506108bf565b600160a060020a0384166000908152600660205260409020839055600191505b5092915050565b6000805481908190819033600160a060020a03908116911614156109f4578685146108f057600080fd5b5060005b868110156109ef5787878281811061090857fe5b905060200201357bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916868683818110151561093c57fe5b92955050600160a060020a0360209092020135169150811580159061096a5750600160e060020a0319831615155b80156109a35750600160e060020a031983166000908152600260209081526040808320600160a060020a038616845290915290205460ff165b156109e757600160e060020a031983166000908152600260209081526040808320600160a060020a03861684529091529020805460ff191690556109e78383611c10565b6001016108f4565b600193505b505050949350505050565b60008035600160e060020a031916815260026020908152604080832033600160a060020a031684529091528120548190819060ff1680610a4d575060005433600160a060020a039081169116145b15610a9b576000858152600a60205260409020549150811515610a6f57600080fd5b50600081815260086020526040902060018101546002909101849055610a96858286611c62565b600192505b505092915050565b60066020526000908152604090205481565b60015460009033600160a060020a03908116911614610ad6575060006107e6565b506001805460008054600160a060020a0319908116600160a060020a0384161790915516815590565b60008035600160e060020a031916815260026020908152604080832033600160a060020a03168452909152812054819060ff1680610b4b575060005433600160a060020a039081169116145b156108bf57506000838152600a6020526040902054801515610b6c57600080fd5b6000818152600860205260409020600301805460ff1916841515179055610b938484611cae565b5060019392505050565b60008035600160e060020a031916815260026020908152604080832033600160a060020a0316845290915281205481908190819060ff1680610bed575060005433600160a060020a039081169116145b15610d1957600160a060020a0386161515610c0757600080fd5b6000878152600a602052604090205415610c2057600080fd5b600160a060020a0386166000908152600960209081526040808320548352600a90915290205492508215610c5357600080fd5b610c5c85611cee565b5050600754610c7290600163ffffffff611d7116565b600781815560008281526008602090815260408083208a815560038101805460ff19166001908117909155600019818301819055600283015560058201819055600160a060020a038d1680865295820184528285208190558085526006820184528285208054600160a060020a031916871790558d8552600a845282852087905594845260099092529091208a90559194509092509050610d14878487611d87565b600193505b5050509392505050565b600554600160a060020a031681565b6000805433600160a060020a0390811691161415610d7f57600160a060020a0382161515610d6257506000610d7f565b5060018054600160a060020a031916600160a060020a0383161781555b919050565b600154600160a060020a031681565b6000908152600a60209081526040808320548352600890915290205490565b60075481565b60008054819033600160a060020a0390811691161415610dfd57610ddb83611cee565b915050801515610df857610df16201a9cc611bd7565b9150610dfd565b600191505b50919050565b60005433600160a060020a0390811691161415610e265733600160a060020a0316ff5b565b600160a060020a031660009081526009602052604090205490565b600080600080610e51611fc3565b6000868152600a60209081526040808320548352600882529182902080546001808301546002808501546003860154600487018054979996989497929660ff90921695909485949184161561010002600019019093160491601f830181900481020190519081016040528092919081815260200182805460018160011615610100020316600290048015610f265780601f10610efb57610100808354040283529160200191610f26565b820191906000526020600020905b815481529060010190602001808311610f0957829003601f168201915b50505050509050955095509550955095505091939590929450565b6000806000610f4e611b6b565b600160a060020a0316630e6d1de96000604051602001526040518163ffffffff1660e060020a028152600401602060405180830381600087803b1515610f9357600080fd5b6102c65a03f11515610fa457600080fd5b50505060405180519050600160a060020a031633600160a060020a03161415610a9b575050600160a060020a038316600090815260096020908152604080832054808452600a83528184205484526008909252909120600181015461100f908563ffffffff611dd316565b60018201556002810154611029908563ffffffff611dd316565b600282015560019250505092915050565b6000828152600a602052604081205480151561105957600091506108bf565b6000818152600860209081526040808320600160a060020a0387168452600701909152902054151591505092915050565b60008035600160e060020a031916815260026020908152604080832033600160a060020a03168452909152812054819060ff16806110d6575060005433600160a060020a039081169116145b1561111957506000848152600a60205260409020548015156110f757600080fd5b6000818152600860205260409020611113906004018585611fd5565b50600191505b509392505050565b6000805481908190819033600160a060020a03908116911614156109f45786851461114b57600080fd5b5060005b868110156109ef5787878281811061116357fe5b905060200201357bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916868683818110151561119757fe5b92955050600160a060020a036020909202013516915081158015906111c55750600160e060020a0319831615155b80156111ff5750600160e060020a031983166000908152600260209081526040808320600160a060020a038616845290915290205460ff16155b1561124657600160e060020a031983166000908152600260209081526040808320600160a060020a03861684529091529020805460ff191660011790556112468383611de5565b60010161114f565b6000818152600d602052604081205480151561126957600080fd5b6000908152600c602052604090206001015492915050565b600b5481565b60008035600160e060020a031916815260026020908152604080832033600160a060020a031684529091528120548190819060ff16806112d5575060005433600160a060020a039081169116145b15610a9b576000858152600d602052604090205491508115156112f757600080fd5b506000818152600c6020526040902060020154838111156113255761131e6201a9ca611bd7565b9250610a9b565b6000828152600c60205260409020600101849055610a96828686611e37565b6000908152600d60209081526040808320548352600c909152902060018101546002909101549091565b60008035600160e060020a031916815260026020908152604080832033600160a060020a031684529091528120548190819060ff16806113bc575060005433600160a060020a039081169116145b15610a9b576000858152600a602052604090205491508115156113de57600080fd5b506000818152600860205260409020600101805490849055610a96858286611e83565b600a6020526000908152604090205481565b60008035600160e060020a031916815260026020908152604080832033600160a060020a03168452909152812054819081908190819060ff1680611465575060005433600160a060020a039081169116145b1561155f576000878152600a6020526040902054935083151561148757600080fd5b6000848152600860209081526040808320600160a060020a038a168452600781019092529091205490935091508115156114c057600080fd5b506005820180546000908152600684016020818152604080842054600160a060020a03908116808652600789018085528387208990558887529484528286208054600160a060020a03191682179055908b16855292909152822091909155905461153190600163ffffffff611dd316565b6005840155600160a060020a03861660009081526009602052604081205561155a878786611ecf565b600194505b5050505092915050565b600054600160a060020a031681565b600354600160a060020a031681565b6000805433600160a060020a0390811691161415610d7f57600160a060020a03821615156115b457600080fd5b5060058054600160a060020a038316600160a060020a03199091161790556001919050565b6000805481908190819033600160a060020a039081169116141561171f57600092505b855183101561171a5785838151811061161157fe5b90602001906020020151915081600160a060020a03166370a082313060006040516020015260405160e060020a63ffffffff8416028152600160a060020a039091166004820152602401602060405180830381600087803b151561167457600080fd5b6102c65a03f1151561168557600080fd5b5050506040518051915050801561170f5781600160a060020a031663a9059cbb868360006040516020015260405160e060020a63ffffffff8516028152600160a060020a0390921660048301526024820152604401602060405180830381600087803b15156116f357600080fd5b6102c65a03f1151561170457600080fd5b505050604051805150505b6001909201916115fc565b600193505b50505092915050565b600160a060020a03166000908152600960209081526040808320548352600a909152902054151590565b61175a611fc3565b6000828152600a60209081526040808320548352600890915280822060058101549092909182905180591061178c5750595b90808252806020026020018201604052509350600090505b818110156117f557600181016000908152600684016020526040902054600160a060020a03168482815181106117d657fe5b600160a060020a039092166020928302909101909101526001016117a4565b505050919050565b6000805433600160a060020a0390811691161415610d7f57600160a060020a038216151561182a57600080fd5b5060038054600160a060020a038316600160a060020a03199091161790556001919050565b60008061185a611b6b565b600160a060020a0316630e6d1de96000604051602001526040518163ffffffff1660e060020a028152600401602060405180830381600087803b151561189f57600080fd5b6102c65a03f115156118b057600080fd5b50505060405180519050600160a060020a031633600160a060020a031614156108bf57506000838152600d60209081526040808320548352600c90915290206001810154839010156118fe57fe5b60020191909155506001919050565b60008035600160e060020a031916815260026020908152604080832033600160a060020a0316845290915281205481908190819060ff168061195d575060005433600160a060020a039081169116145b1561171f576000868152600a6020526040902054925082151561197f57600080fd5b600160a060020a0385166000908152600960209081526040808320548352600a909152902054915081156119b257600080fd5b506000828152600860209081526040808320600160a060020a038816845260078101909252909120541515611a3d5760058101546119f790600163ffffffff611d7116565b60058201819055600160a060020a03861660008181526007840160209081526040808320859055938252600685019052919091208054600160a060020a03191690911790555b600160a060020a038516600090815260096020526040902086905561171a868685611f23565b600260209081526000928352604080842090915290825290205460ff1681565b6000806000611a90611b6b565b600160a060020a0316630e6d1de96000604051602001526040518163ffffffff1660e060020a028152600401602060405180830381600087803b1515611ad557600080fd5b6102c65a03f11515611ae657600080fd5b50505060405180519050600160a060020a031633600160a060020a03161415610a9b575050600160a060020a038316600090815260096020908152604080832054808452600a835281842054845260089092529091206001810154611b51908563ffffffff611d7116565b60018201556002810154611029908563ffffffff611d7116565b600554600090600160a060020a03168063ec55688983604051602001526040518163ffffffff1660e060020a028152600401602060405180830381600087803b1515611bb657600080fd5b6102c65a03f11515611bc757600080fd5b50505060405180519250505b5090565b60007f2e36a7093f25f22bd4cbdeb6040174c3ba4c5fe8f1abc04e7c3c48f26c7413e08260405190815260200160405180910390a15090565b7f58ab7e894587d9a059ec25934fa355b55642e740bd373f7a71231a214090fe328282604051600160e060020a03199092168252600160a060020a031660208201526040908101905180910390a15050565b7fa075dd547911a51cf6070e18d21c182144ea40164ab3c0e9788742d9ec98e24283838360405192835260208301919091526040808301919091526060909101905180910390a1505050565b7fe5036c56a7d359935326c74e9955ab98c771f16853b0bc339f084493fd1a610c8282604051918252151560208201526040908101905180910390a15050565b6000818152600d602052604081205481908180821515611d6557600b549150611d1e82600163ffffffff611d7116565b600b8190556000818152600c602090815260408083208a8155600019600182018190558b8552600d90935292208390559194509150611d609084908890611f77565b600193505b50909491935090915050565b600082820183811015611d8057fe5b9392505050565b7f9cd042e2515b9431d9da31709d4b4154802349764402903cb82cbce1f86213fa83838360405192835260208301919091526040808301919091526060909101905180910390a1505050565b600082821115611ddf57fe5b50900390565b7f8aa5aa415d6f8f9e548c5bcd912c81c6618bb4c3313b550cdfac866e8ac2a8d88282604051600160e060020a03199092168252600160a060020a031660208201526040908101905180910390a15050565b7feb4906568ff53a8690469b1049050dee2025091e489d23affe6b777d62018a2883838360405180848152602001838152602001828152602001935050505060405180910390a1505050565b7ffb64751f28440527d4cfff4fa311ed4aa4e1d6b7e753bf0a19fd62086487331c83838360405192835260208301919091526040808301919091526060909101905180910390a1505050565b7fedcf58fedc2609456ecd723fbcc975416903af22a93310c9d8916d9bf6490a56838383604051928352600160a060020a0390911660208301526040808301919091526060909101905180910390a1505050565b7fa2b25b91022dab25679ae753878654f2409a6a6233455ef9ac9559e5b400b7f4838383604051928352600160a060020a0390911660208301526040808301919091526060909101905180910390a1505050565b7f49d5bb0cb6d2601739bdb544f8674ea2d033ad3916299b0fa2ef5b61d0274dd183838360405180848152602001838152602001828152602001935050505060405180910390a1505050565b60206040519081016040526000815290565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f106120165782800160ff19823516178555612043565b82800160010185558215612043579182015b82811115612043578235825591602001919060010190612028565b50611bd3926107e69250905b80821115611bd3576000815560010161204f5600a165627a7a723058209983d93200cc6bea4bc4af81e13f9f160b12267c1c950ae0eef7c0bc28d339ce002900000000000000000000000051e4df17bf380ab4f9d810cef89eabc9842ff1fa",
  "constructorArguments": "00000000000000000000000051e4df17bf380ab4f9d810cef89eabc9842ff1fa"
}