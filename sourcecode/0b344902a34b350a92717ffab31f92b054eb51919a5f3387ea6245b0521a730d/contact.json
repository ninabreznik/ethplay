{
  "address": "0x17a03553719001e05dc19a20f5e82ee76923a985",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "SaleAuction",
  "compilerVersion": "v0.4.24+commit.e67f0147",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2019-01-08\n*/\n\npragma solidity ^0.4.24;\n\ncontract ERC165Interface {\n    /**\n     * @notice Query if a contract implements an interface\n     * @param interfaceID The interface identifier, as specified in ERC-165\n     * @dev Interface identification is specified in ERC-165. This function\n     *  uses less than 30,000 gas.\n     * @return `true` if the contract implements `interfaceID` and\n     *  `interfaceID` is not 0xffffffff, `false` otherwise\n     */\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n\ncontract ERC165 is ERC165Interface {\n    /**\n     * @dev a mapping of interface id to whether or not it's supported\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    /**\n     * @dev implement supportsInterface(bytes4) using a lookup table\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev internal method for registering an interface\n     */\n    function _registerInterface(bytes4 interfaceId) internal {\n        require(interfaceId != 0xffffffff);\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n\n// Every ERC-721 compliant contract must implement the ERC721 and ERC165 interfaces.\n/** \n * @title ERC-721 Non-Fungible Token Standard\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n * Note: the ERC-165 identifier for this interface is 0x80ac58cd.\n */\ncontract ERC721Basic is ERC165 {\n    // Below is MUST\n\n    /**\n     * @dev This emits when ownership of any NFT changes by any mechanism.\n     *  This event emits when NFTs are created (`from` == 0) and destroyed\n     *  (`to` == 0). Exception: during contract creation, any number of NFTs\n     *  may be created and assigned without emitting Transfer. At the time of\n     *  any transfer, the approved address for that NFT (if any) is reset to none.\n     */\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n\n    /**\n     * @dev This emits when the approved address for an NFT is changed or\n     *  reaffirmed. The zero address indicates there is no approved address.\n     *  When a Transfer event emits, this also indicates that the approved\n     *  address for that NFT (if any) is reset to none.\n     */\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n\n    /**\n     * @dev This emits when an operator is enabled or disabled for an owner.\n     *  The operator can manage all NFTs of the owner.\n     */\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n    /**\n     * @notice Count all NFTs assigned to an owner\n     * @dev NFTs assigned to the zero address are considered invalid, and this\n     *  function throws for queries about the zero address.\n     * @param _owner An address for whom to query the balance\n     * @return The number of NFTs owned by `_owner`, possibly zero\n     */\n    function balanceOf(address _owner) public view returns (uint256);\n\n    /**\n     * @notice Find the owner of an NFT\n     * @dev NFTs assigned to zero address are considered invalid, and queries\n     *  about them do throw.\n     * @param _tokenId The identifier for an NFT\n     * @return The address of the owner of the NFT\n     */\n    function ownerOf(uint256 _tokenId) public view returns (address);\n\n    /**\n     * @notice Transfers the ownership of an NFT from one address to another address\n     * @dev Throws unless `msg.sender` is the current owner, an authorized\n     *  operator, or the approved address for this NFT. Throws if `_from` is\n     *  not the current owner. Throws if `_to` is the zero address. Throws if\n     *  `_tokenId` is not a valid NFT. When transfer is complete, this function\n     *  checks if `_to` is a smart contract (code size > 0). If so, it calls\n     *  `onERC721Received` on `_to` and throws if the return value is not\n     *  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n     * @param _from The current owner of the NFT\n     * @param _to The new owner\n     * @param _tokenId The NFT to transfer\n     * @param data Additional data with no specified format, sent in call to `_to`\n     */\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) public;\n\n    /**\n     * @notice Transfers the ownership of an NFT from one address to another address\n     * @dev This works identically to the other function with an extra data parameter,\n     *  except this function just sets data to \"\".\n     * @param _from The current owner of the NFT\n     * @param _to The new owner\n     * @param _tokenId The NFT to transfer\n     */\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) public;\n\n    /**\n     * @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n     *  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n     *  THEY MAY BE PERMANENTLY LOST\n     * @dev Throws unless `msg.sender` is the current owner, an authorized\n     *  operator, or the approved address for this NFT. Throws if `_from` is\n     *  not the current owner. Throws if `_to` is the zero address. Throws if\n     *  `_tokenId` is not a valid NFT.\n     * @param _from The current owner of the NFT\n     * @param _to The new owner\n     * @param _tokenId The NFT to transfer\n     */\n    function transferFrom(address _from, address _to, uint256 _tokenId) public;\n\n    /**\n     * @notice Change or reaffirm the approved address for an NFT\n     * @dev The zero address indicates there is no approved address.\n     *  Throws unless `msg.sender` is the current NFT owner, or an authorized\n     *  operator of the current owner.\n     * @param _approved The new approved NFT controller\n     * @param _tokenId The NFT to approve\n     */\n    function approve(address _approved, uint256 _tokenId) external;\n\n    /**\n     * @notice Enable or disable approval for a third party (\"operator\") to manage\n     *  all of `msg.sender`'s assets\n     * @dev Emits the ApprovalForAll event. The contract MUST allow\n     *  multiple operators per owner.\n     * @param _operator Address to add to the set of authorized operators\n     * @param _approved True if the operator is approved, false to revoke approval\n     */\n    function setApprovalForAll(address _operator, bool _approved) external;\n\n    /**\n     * @notice Get the approved address for a single NFT\n     * @dev Throws if `_tokenId` is not a valid NFT.\n     * @param _tokenId The NFT to find the approved address for\n     * @return The approved address for this NFT, or the zero address if there is none\n     */\n    function getApproved(uint256 _tokenId) public view returns (address);\n\n    /**\n     * @notice Query if an address is an authorized operator for another address\n     * @param _owner The address that owns the NFTs\n     * @param _operator The address that acts on behalf of the owner\n     * @return True if `_operator` is an approved operator for `_owner`, false otherwise\n     */\n    function isApprovedForAll(address _owner, address _operator) public view returns (bool);\n\n    // Below is OPTIONAL\n\n    // ERC721Metadata\n    // The metadata extension is OPTIONAL for ERC-721 smart contracts (see \"caveats\", below). This allows your smart contract to be interrogated for its name and for details about the assets which your NFTs represent.\n    \n    /**\n     * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n     * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n     *  Note: the ERC-165 identifier for this interface is 0x5b5e139f.\n     */\n\n    /// @notice A descriptive name for a collection of NFTs in this contract\n    function name() external view returns (string _name);\n\n    /// @notice An abbreviated name for NFTs in this contract\n    function symbol() external view returns (string _symbol);\n\n    /**\n     * @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n     * @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n     *  3986. The URI may point to a JSON file that conforms to the \"ERC721\n     *  Metadata JSON Schema\".\n     */\n    function tokenURI(uint256 _tokenId) external view returns (string);\n\n    // ERC721Enumerable\n    // The enumeration extension is OPTIONAL for ERC-721 smart contracts (see \"caveats\", below). This allows your contract to publish its full list of NFTs and make them discoverable.\n\n    /**\n     * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n     * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n     *  Note: the ERC-165 identifier for this interface is 0x780e9d63.\n     */\n\n    /**\n     * @notice Count NFTs tracked by this contract\n     * @return A count of valid NFTs tracked by this contract, where each one of\n     *  them has an assigned and queryable owner not equal to the zero address\n     */\n    function totalSupply() public view returns (uint256);\n}\n\n/**\n * @notice This is MUST to be implemented.\n *  A wallet/broker/auction application MUST implement the wallet interface if it will accept safe transfers.\n * @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\n */\ncontract ERC721TokenReceiver {\n    /**\n     * @notice Handle the receipt of an NFT\n     * @dev The ERC721 smart contract calls this function on the recipient\n     *  after a `transfer`. This function MAY throw to revert and reject the\n     *  transfer. Return of other than the magic value MUST result in the\n     *  transaction being reverted.\n     *  Note: the contract address is always the message sender.\n     * @param _operator The address which called `safeTransferFrom` function\n     * @param _from The address which previously owned the token\n     * @param _tokenId The NFT identifier which is being transferred\n     * @param _data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n     *  unless throwing\n     */\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes _data) public returns (bytes4);\n}\n\ncontract ERC721Holder is ERC721TokenReceiver {\n    function onERC721Received(address, address, uint256, bytes) public returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    /**\n    * @dev Multiplies two numbers, reverts on overflow.\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n    * @dev Adds two numbers, reverts on overflow.\n    */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n    * reverts when dividing by zero.\n    */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n\n/**\n * @title Base auction contract of the Dyverse\n * @author VREX Lab Co., Ltd\n * @dev Contains necessary functions and variables for the auction.\n *  Inherits `ERC721Holder` contract which is the implementation of the `ERC721TokenReceiver`.\n *  This is to accept safe transfers.\n */\ncontract AuctionBase is ERC721Holder {\n    using SafeMath for uint256;\n\n    // Represents an auction on an NFT\n    struct Auction {\n        // Current owner of NFT\n        address seller;\n        // Price (in wei) of NFT\n        uint128 price;\n        // Time when the auction started\n        // NOTE: 0 if this auction has been concluded\n        uint64 startedAt;\n    }\n\n    // Reference to contract tracking NFT ownership\n    ERC721Basic public nonFungibleContract;\n\n    // The amount owner takes from the sale, (in basis points, which are 1/100 of a percent).\n    uint256 public ownerCut;\n\n    // Maps token ID to it's corresponding auction.\n    mapping (uint256 => Auction) tokenIdToAuction;\n\n    event AuctionCreated(uint256 tokenId, uint256 price);\n    event AuctionSuccessful(uint256 tokenId, uint256 totalPrice, address bidder);\n    event AuctionCanceled(uint256 tokenId);\n\n    /// @dev Disables sending funds to this contract.\n    function() external {}\n\n    /// @dev A modifier to check if the given value can fit in 64-bits.\n    modifier canBeStoredWith64Bits(uint256 _value) {\n        require(_value <= (2**64 - 1));\n        _;\n    }\n\n    /// @dev A modifier to check if the given value can fit in 128-bits.\n    modifier canBeStoredWith128Bits(uint256 _value) {\n        require(_value <= (2**128 - 1));\n        _;\n    }\n\n    /**\n     * @dev Returns true if the claimant owns the token.\n     * @param _claimant An address which to query the ownership of the token.\n     * @param _tokenId ID of the token to query the owner of.\n     */\n    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\n        return (nonFungibleContract.ownerOf(_tokenId) == _claimant);\n    }\n\n    /**\n     * @dev Escrows the NFT. Grants the ownership of the NFT to this contract safely.\n     *  Throws if the escrow fails.\n     * @param _owner Current owner of the token.\n     * @param _tokenId ID of the token to escrow.\n     */\n    function _escrow(address _owner, uint256 _tokenId) internal {\n        nonFungibleContract.safeTransferFrom(_owner, this, _tokenId);\n    }\n\n    /**\n     * @dev Transfers an NFT owned by this contract to another address safely.\n     * @param _receiver The receiving address of NFT.\n     * @param _tokenId ID of the token to transfer.\n     */\n    function _transfer(address _receiver, uint256 _tokenId) internal {\n        nonFungibleContract.safeTransferFrom(this, _receiver, _tokenId);\n    }\n\n    /**\n     * @dev Adds an auction to the list of open auctions. \n     * @param _tokenId ID of the token to be put on auction.\n     * @param _auction Auction information of this token to open.\n     */\n    function _addAuction(uint256 _tokenId, Auction _auction) internal {\n        tokenIdToAuction[_tokenId] = _auction;\n\n        emit AuctionCreated(\n            uint256(_tokenId),\n            uint256(_auction.price)\n        );\n    }\n\n    /// @dev Cancels the auction which the _seller wants.\n    function _cancelAuction(uint256 _tokenId, address _seller) internal {\n        _removeAuction(_tokenId);\n        _transfer(_seller, _tokenId);\n        emit AuctionCanceled(_tokenId);\n    }\n\n    /**\n     * @dev Computes the price and sends it to the seller.\n     *  Note that this does NOT transfer the ownership of the token.\n     */\n    function _bid(uint256 _tokenId, uint256 _bidAmount)\n        internal\n        returns (uint256)\n    {\n        // Gets a reference of the token from auction storage.\n        Auction storage auction = tokenIdToAuction[_tokenId];\n\n        // Checks that this auction is currently open\n        require(_isOnAuction(auction));\n\n        // Checks that the bid is greater than or equal to the current token price.\n        uint256 price = _currentPrice(auction);\n        require(_bidAmount >= price);\n\n        // Gets a reference of the seller before the auction gets deleted.\n        address seller = auction.seller;\n\n        // Removes the auction before sending the proceeds to the sender\n        _removeAuction(_tokenId);\n\n        // Transfers proceeds to the seller.\n        if (price > 0) {\n            uint256 auctioneerCut = _computeCut(price);\n            uint256 sellerProceeds = price.sub(auctioneerCut);\n\n            seller.transfer(sellerProceeds);\n        }\n\n        // Computes the excess funds included with the bid and transfers it back to bidder. \n        uint256 bidExcess = _bidAmount - price;\n\n        // Returns the exceeded funds.\n        msg.sender.transfer(bidExcess);\n\n        // Emits the AuctionSuccessful event.\n        emit AuctionSuccessful(_tokenId, price, msg.sender);\n\n        return price;\n    }\n\n    /**\n     * @dev Removes an auction from the list of open auctions.\n     * @param _tokenId ID of the NFT on auction to be removed.\n     */\n    function _removeAuction(uint256 _tokenId) internal {\n        delete tokenIdToAuction[_tokenId];\n    }\n\n    /**\n     * @dev Returns true if the NFT is on auction.\n     * @param _auction An auction to check if it exists.\n     */\n    function _isOnAuction(Auction storage _auction) internal view returns (bool) {\n        return (_auction.startedAt > 0);\n    }\n\n    /// @dev Returns the current price of an NFT on auction.\n    function _currentPrice(Auction storage _auction)\n        internal\n        view\n        returns (uint256)\n    {\n        return _auction.price;\n    }\n\n    /**\n     * @dev Computes the owner's receiving amount from the sale.\n     * @param _price Sale price of the NFT.\n     */\n    function _computeCut(uint256 _price) internal view returns (uint256) {\n        return _price * ownerCut / 10000;\n    }\n}\n\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n}\n\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n\n/**\n * @title Auction for NFT.\n * @author VREX Lab Co., Ltd\n */\ncontract Auction is Pausable, AuctionBase {\n\n    /**\n     * @dev Removes all Ether from the contract to the NFT contract.\n     */\n    function withdrawBalance() external {\n        address nftAddress = address(nonFungibleContract);\n\n        require(\n            msg.sender == owner ||\n            msg.sender == nftAddress\n        );\n        nftAddress.transfer(address(this).balance);\n    }\n\n    /**\n     * @dev Creates and begins a new auction.\n     * @param _tokenId ID of the token to creat an auction, caller must be it's owner.\n     * @param _price Price of the token (in wei).\n     * @param _seller Seller of this token.\n     */\n    function createAuction(\n        uint256 _tokenId,\n        uint256 _price,\n        address _seller\n    )\n        external\n        whenNotPaused\n        canBeStoredWith128Bits(_price)\n    {\n        require(_owns(msg.sender, _tokenId));\n        _escrow(msg.sender, _tokenId);\n        Auction memory auction = Auction(\n            _seller,\n            uint128(_price),\n            uint64(now)\n        );\n        _addAuction(_tokenId, auction);\n    }\n\n    /**\n     * @dev Bids on an open auction, completing the auction and transferring\n     *  ownership of the NFT if enough Ether is supplied.\n     * @param _tokenId - ID of token to bid on.\n     */\n    function bid(uint256 _tokenId)\n        external\n        payable\n        whenNotPaused\n    {\n        _bid(_tokenId, msg.value);\n        _transfer(msg.sender, _tokenId);\n    }\n\n    /**\n     * @dev Cancels an auction and returns the NFT to the current owner.\n     * @param _tokenId ID of the token on auction to cancel.\n     * @param _seller The seller's address.\n     */\n    function cancelAuction(uint256 _tokenId, address _seller)\n        external\n    {\n        // Requires that this function should only be called from the\n        // `cancelSaleAuction()` of NFT ownership contract. This function gets\n        // the _seller directly from it's arguments, so if this check doesn't\n        // exist, then anyone can cancel the auction! OMG!\n        require(msg.sender == address(nonFungibleContract));\n        Auction storage auction = tokenIdToAuction[_tokenId];\n        require(_isOnAuction(auction));\n        address seller = auction.seller;\n        require(_seller == seller);\n        _cancelAuction(_tokenId, seller);\n    }\n\n    /**\n     * @dev Cancels an auction when the contract is paused.\n     * Only the owner may do this, and NFTs are returned to the seller. \n     * @param _tokenId ID of the token on auction to cancel.\n     */\n    function cancelAuctionWhenPaused(uint256 _tokenId)\n        external\n        whenPaused\n        onlyOwner\n    {\n        Auction storage auction = tokenIdToAuction[_tokenId];\n        require(_isOnAuction(auction));\n        _cancelAuction(_tokenId, auction.seller);\n    }\n\n    /**\n     * @dev Returns the auction information for an NFT\n     * @param _tokenId ID of the NFT on auction\n     */\n    function getAuction(uint256 _tokenId)\n        external\n        view\n        returns\n    (\n        address seller,\n        uint256 price,\n        uint256 startedAt\n    ) {\n        Auction storage auction = tokenIdToAuction[_tokenId];\n        require(_isOnAuction(auction));\n        return (\n            auction.seller,\n            auction.price,\n            auction.startedAt\n        );\n    }\n\n    /**\n     * @dev Returns the current price of the token on auction.\n     * @param _tokenId ID of the token\n     */\n    function getCurrentPrice(uint256 _tokenId)\n        external\n        view\n        returns (uint256)\n    {\n        Auction storage auction = tokenIdToAuction[_tokenId];\n        require(_isOnAuction(auction));\n        return _currentPrice(auction);\n    }\n}\n\n/**\n * @title Auction for sale of Kydys.\n * @author VREX Lab Co., Ltd\n */\ncontract SaleAuction is Auction {\n\n    /**\n     * @dev To make sure we are addressing to the right auction. \n     */\n    bool public isSaleAuction = true;\n\n    // Last 5 sale price of Generation 0 Kydys.\n    uint256[5] public lastGen0SalePrices;\n    \n    // Total number of Generation 0 Kydys sold.\n    uint256 public gen0SaleCount;\n\n    /**\n     * @dev Creates a reference to the NFT ownership contract and checks the owner cut is valid\n     * @param _nftAddress Address of a deployed NFT interface contract\n     * @param _cut Percent cut which the owner takes on each auction, between 0-10,000.\n     */\n    constructor(address _nftAddress, uint256 _cut) public {\n        require(_cut <= 10000);\n        ownerCut = _cut;\n\n        ERC721Basic candidateContract = ERC721Basic(_nftAddress);\n        nonFungibleContract = candidateContract;\n    }\n\n    /**\n     * @dev Creates and begins a new auction.\n     * @param _tokenId ID of token to auction, sender must be it's owner.\n     * @param _price Price of the token (in wei).\n     * @param _seller Seller of this token.\n     */\n    function createAuction(\n        uint256 _tokenId,\n        uint256 _price,\n        address _seller\n    )\n        external\n        canBeStoredWith128Bits(_price)\n    {\n        require(msg.sender == address(nonFungibleContract));\n        _escrow(_seller, _tokenId);\n        Auction memory auction = Auction(\n            _seller,\n            uint128(_price),\n            uint64(now)\n        );\n        _addAuction(_tokenId, auction);\n    }\n\n    /**\n     * @dev Updates lastSalePrice only if the seller is nonFungibleContract. \n     */\n    function bid(uint256 _tokenId)\n        external\n        payable\n    {\n        // _bid verifies token ID\n        address seller = tokenIdToAuction[_tokenId].seller;\n        uint256 price = _bid(_tokenId, msg.value);\n        _transfer(msg.sender, _tokenId);\n\n        // If the last sale was not Generation 0 Kydy's, the lastSalePrice doesn't change.\n        if (seller == address(nonFungibleContract)) {\n            // Tracks gen0's latest sale prices.\n            lastGen0SalePrices[gen0SaleCount % 5] = price;\n            gen0SaleCount++;\n        }\n    }\n\n    /// @dev Gives the new average Generation 0 sale price after each Generation 0 Kydy sale.\n    function averageGen0SalePrice() external view returns (uint256) {\n        uint256 sum = 0;\n        for (uint256 i = 0; i < 5; i++) {\n            sum = sum.add(lastGen0SalePrices[i]);\n        }\n        return sum / 5;\n    }\n}",
  "bytecode": "60806040526000805460a060020a60ff02191690556004805460ff1916600117905534801561002d57600080fd5b50604051604080610e2283398101604052805160209091015160008054600160a060020a0319163317815561271082111561006757600080fd5b5060025560018054600160a060020a031916600160a060020a0392909216919091179055610d888061009a6000396000f3006080604052600436106101065763ffffffff7c0100000000000000000000000000000000000000000000000000000000600035041663150b7a0281146101155780633f4ba83a146101b9578063454a2ab3146101d0578063484eccb4146101db5780634e8eaa131461020557806354279bdd146102295780635c975abb146102505780635fd8c7101461027957806378bd79351461028e57806383b5ff8b146102ce5780638456cb59146102e3578063878eb368146102f85780638a98a9cc146103105780638da5cb5b14610325578063c55d0f5614610356578063d25c07671461036e578063dd1b7a0f14610383578063eac9d94c14610398578063f2fde38b146103ad575b34801561011257600080fd5b50005b34801561012157600080fd5b50604080516020601f60643560048181013592830184900484028501840190955281845261018494600160a060020a0381358116956024803590921695604435953695608494019181908401838280828437509497506103ce9650505050505050565b604080517fffffffff000000000000000000000000000000000000000000000000000000009092168252519081900360200190f35b3480156101c557600080fd5b506101ce6103f7565b005b6101ce60043561046d565b3480156101e757600080fd5b506101f36004356104de565b60408051918252519081900360200190f35b34801561021157600080fd5b506101ce600435600160a060020a03602435166104f1565b34801561023557600080fd5b506101ce600435602435600160a060020a036044351661055d565b34801561025c57600080fd5b506102656105f8565b604080519115158252519081900360200190f35b34801561028557600080fd5b506101ce610608565b34801561029a57600080fd5b506102a6600435610675565b60408051600160a060020a039094168452602084019290925282820152519081900360600190f35b3480156102da57600080fd5b506101f36106ea565b3480156102ef57600080fd5b506101ce6106f0565b34801561030457600080fd5b506101ce60043561076b565b34801561031c57600080fd5b506101f36107d4565b34801561033157600080fd5b5061033a6107da565b60408051600160a060020a039092168252519081900360200190f35b34801561036257600080fd5b506101f36004356107e9565b34801561037a57600080fd5b5061026561081b565b34801561038f57600080fd5b5061033a610824565b3480156103a457600080fd5b506101f3610833565b3480156103b957600080fd5b506101ce600160a060020a0360043516610873565b7f150b7a0200000000000000000000000000000000000000000000000000000000949350505050565b600054600160a060020a0316331461040e57600080fd5b60005460a060020a900460ff16151561042657600080fd5b6000805474ff0000000000000000000000000000000000000000191681556040517f7805862f689e2f13df9f062ff482ad3ad112aca9e0847911ed832e158c525b339190a1565b600081815260036020526040812054600160a060020a0316906104908334610907565b905061049c3384610a3a565b600154600160a060020a03838116911614156104d95780600580600a548115156104c257fe5b06600581106104cd57fe5b0155600a805460010190555b505050565b6005818181106104ea57fe5b0154905081565b6001546000908190600160a060020a0316331461050d57600080fd5b6000848152600360205260409020915061052682610aca565b151561053157600080fd5b508054600160a060020a03908116908316811461054d57600080fd5b6105578482610af3565b50505050565b610565610d3c565b826fffffffffffffffffffffffffffffffff81111561058357600080fd5b600154600160a060020a0316331461059a57600080fd5b6105a48386610b3d565b60606040519081016040528084600160a060020a03168152602001856fffffffffffffffffffffffffffffffff1681526020014267ffffffffffffffff1681525091506105f18583610bb1565b5050505050565b60005460a060020a900460ff1681565b600154600054600160a060020a039182169116331480610630575033600160a060020a038216145b151561063b57600080fd5b604051600160a060020a03821690303180156108fc02916000818181858888f19350505050158015610671573d6000803e3d6000fd5b5050565b60008181526003602052604081208190819061069081610aca565b151561069b57600080fd5b8054600190910154600160a060020a03909116956fffffffffffffffffffffffffffffffff8216955070010000000000000000000000000000000090910467ffffffffffffffff169350915050565b60025481565b600054600160a060020a0316331461070757600080fd5b60005460a060020a900460ff161561071e57600080fd5b6000805474ff0000000000000000000000000000000000000000191660a060020a1781556040517f6985a02210a168e66602d3235cb6db0e70f92b3ba4d376a33c0f3d9434bff6259190a1565b6000805460a060020a900460ff16151561078457600080fd5b600054600160a060020a0316331461079b57600080fd5b5060008181526003602052604090206107b381610aca565b15156107be57600080fd5b8054610671908390600160a060020a0316610af3565b600a5481565b600054600160a060020a031681565b600081815260036020526040812061080081610aca565b151561080b57600080fd5b61081481610ca1565b9392505050565b60045460ff1681565b600154600160a060020a031681565b600080805b60058110156108695761085f60058281811061085057fe5b0154839063ffffffff610cba16565b9150600101610838565b5060059004919050565b600054600160a060020a0316331461088a57600080fd5b600160a060020a038116151561089f57600080fd5b60008054604051600160a060020a03808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a36000805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b6000828152600360205260408120818080808061092386610aca565b151561092e57600080fd5b61093786610ca1565b94508488101561094657600080fd5b8554600160a060020a0316935061095c89610ccc565b60008511156109bb5761096e85610d19565b9250610980858463ffffffff610d2516565b604051909250600160a060020a0385169083156108fc029084906000818181858888f193505050501580156109b9573d6000803e3d6000fd5b505b5060405184880390339082156108fc029083906000818181858888f193505050501580156109ed573d6000803e3d6000fd5b50604080518a815260208101879052338183015290517f4fcc30d90a842164dd58501ab874a101a3749c3d4747139cefe7c876f4ccebd29181900360600190a15092979650505050505050565b600154604080517f42842e0e000000000000000000000000000000000000000000000000000000008152306004820152600160a060020a03858116602483015260448201859052915191909216916342842e0e91606480830192600092919082900301818387803b158015610aae57600080fd5b505af1158015610ac2573d6000803e3d6000fd5b505050505050565b60010154600070010000000000000000000000000000000090910467ffffffffffffffff161190565b610afc82610ccc565b610b068183610a3a565b6040805183815290517f28601d865dccc9f113e15a7185c1b38c085d598c71250d3337916a428536d7719181900360200190a15050565b600154604080517f42842e0e000000000000000000000000000000000000000000000000000000008152600160a060020a03858116600483015230602483015260448201859052915191909216916342842e0e91606480830192600092919082900301818387803b158015610aae57600080fd5b6000828152600360209081526040918290208351815473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a039091161781558382015160019091018054858501516fffffffffffffffffffffffffffffffff199091166fffffffffffffffffffffffffffffffff90931692831777ffffffffffffffff00000000000000000000000000000000191670010000000000000000000000000000000067ffffffffffffffff9092169190910217905582518581529182015281517fe00a2da3a0f34a566402a244ab7ec63f8ab7472591cb18edf3269aa00461a410929181900390910190a15050565b600101546fffffffffffffffffffffffffffffffff1690565b60008282018381101561081457600080fd5b6000908152600360205260409020805473ffffffffffffffffffffffffffffffffffffffff19168155600101805477ffffffffffffffffffffffffffffffffffffffffffffffff19169055565b60025461271091020490565b60008083831115610d3557600080fd5b5050900390565b6040805160608101825260008082526020820181905291810191909152905600a165627a7a723058206636a35892d078c9fdf173c2e1f3be963f978bd35bab0e66cfcd934ef61d98b40029000000000000000000000000d90f5ebc01914bbd357b754956aafb199f4d162400000000000000000000000000000000000000000000000000000000000001f4",
  "constructorArguments": "000000000000000000000000d90f5ebc01914bbd357b754956aafb199f4d162400000000000000000000000000000000000000000000000000000000000001f4"
}