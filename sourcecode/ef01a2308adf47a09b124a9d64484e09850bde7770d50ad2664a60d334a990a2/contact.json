{
  "address": "0x2cb4b49c0d6e9db2164d94ce48853bf77c4d883e",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "Hydro: Old Exchange Contract",
  "contractName": "HybridExchange",
  "compilerVersion": "v0.4.24+commit.e67f0147",
  "optimization": true,
  "runs": "1000000",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2018-12-14\n*/\n\n/*\n\n    Copyright 2018 The Hydro Protocol Foundation\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n        http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity ^0.4.24;\npragma experimental ABIEncoderV2;\n\n/// @title Ownable\n/// @dev The Ownable contract has an owner address, and provides basic authorization control\n/// functions, this simplifies the implementation of \"user permissions\".\ncontract LibOwnable {\n    address private _owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /// @dev The Ownable constructor sets the original `owner` of the contract to the sender account.\n    constructor() internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /// @return the address of the owner.\n    function owner() public view returns(address) {\n        return _owner;\n    }\n\n    /// @dev Throws if called by any account other than the owner.\n    modifier onlyOwner() {\n        require(isOwner(), \"NOT_OWNER\");\n        _;\n    }\n\n    /// @return true if `msg.sender` is the owner of the contract.\n    function isOwner() public view returns(bool) {\n        return msg.sender == _owner;\n    }\n\n    /// @dev Allows the current owner to relinquish control of the contract.\n    /// @notice Renouncing to ownership will leave the contract without an owner.\n    /// It will not be possible to call the functions with the `onlyOwner`\n    /// modifier anymore.\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /// @dev Allows the current owner to transfer control of the contract to a newOwner.\n    /// @param newOwner The address to transfer ownership to.\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0), \"INVALID_OWNER\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n/// @dev Math operations with safety checks that revert on error\nlibrary SafeMath {\n\n    /// @dev Multiplies two numbers, reverts on overflow.\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"MUL_ERROR\");\n\n        return c;\n    }\n\n    /// @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"DIVIDING_ERROR\");\n        uint256 c = a / b;\n        return c;\n    }\n\n    /// @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SUB_ERROR\");\n        uint256 c = a - b;\n        return c;\n    }\n\n    /// @dev Adds two numbers, reverts on overflow.\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"ADD_ERROR\");\n        return c;\n    }\n\n    /// @dev Divides two numbers and returns the remainder (unsigned integer modulo), reverts when dividing by zero.\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"MOD_ERROR\");\n        return a % b;\n    }\n}\n\n/**\n * EIP712 Ethereum typed structured data hashing and signing\n */\ncontract EIP712 {\n    string internal constant DOMAIN_NAME = \"Hydro Protocol\";\n    string internal constant DOMAIN_VERSION = \"1\";\n\n    /**\n     * Hash of the EIP712 Domain Separator Schema\n     */\n    bytes32 public constant EIP712_DOMAIN_TYPEHASH = keccak256(\n        abi.encodePacked(\"EIP712Domain(string name,string version,address verifyingContract)\")\n    );\n\n    bytes32 public DOMAIN_SEPARATOR;\n\n    constructor () public {\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encodePacked(\n                EIP712_DOMAIN_TYPEHASH,\n                keccak256(bytes(DOMAIN_NAME)),\n                keccak256(bytes(DOMAIN_VERSION)),\n                bytes32(address(this))\n            )\n        );\n    }\n\n    /**\n     * Calculates EIP712 encoding for a hash struct in this EIP712 Domain.\n     *\n     * @param eip712hash The EIP712 hash struct.\n     * @return EIP712 hash applied to this EIP712 Domain.\n     */\n    function hashEIP712Message(bytes32 eip712hash) internal view returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR, eip712hash));\n    }\n}\n\ncontract LibSignature {\n\n    enum SignatureMethod {\n        EthSign,\n        EIP712\n    }\n\n    /**\n     * OrderSignature struct contains typical signature data as v, r, and s with the signature\n     * method encoded in as well.\n     */\n    struct OrderSignature {\n        /**\n         * Config contains the following values packed into 32 bytes\n         * ╔════════════════════╤═══════════════════════════════════════════════════════════╗\n         * ║                    │ length(bytes)   desc                                      ║\n         * ╟────────────────────┼───────────────────────────────────────────────────────────╢\n         * ║ v                  │ 1               the v parameter of a signature            ║\n         * ║ signatureMethod    │ 1               SignatureMethod enum value                ║\n         * ╚════════════════════╧═══════════════════════════════════════════════════════════╝\n         */\n        bytes32 config;\n        bytes32 r;\n        bytes32 s;\n    }\n    \n    /**\n     * Validate a signature given a hash calculated from the order data, the signer, and the\n     * signature data passed in with the order.\n     *\n     * This function will revert the transaction if the signature method is invalid.\n     *\n     * @param hash Hash bytes calculated by taking the EIP712 hash of the passed order data\n     * @param signerAddress The address of the signer\n     * @param signature The signature data passed along with the order to validate against\n     * @return True if the calculated signature matches the order signature data, false otherwise.\n     */\n    function isValidSignature(bytes32 hash, address signerAddress, OrderSignature memory signature)\n        internal\n        pure\n        returns (bool)\n    {\n        uint8 method = uint8(signature.config[1]);\n        address recovered;\n        uint8 v = uint8(signature.config[0]);\n\n        if (method == uint8(SignatureMethod.EthSign)) {\n            recovered = ecrecover(\n                keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)),\n                v,\n                signature.r,\n                signature.s\n            );\n        } else if (method == uint8(SignatureMethod.EIP712)) {\n            recovered = ecrecover(hash, v, signature.r, signature.s);\n        } else {\n            revert(\"INVALID_SIGN_METHOD\");\n        }\n\n        return signerAddress == recovered;\n    }\n}\n\ncontract LibOrder is EIP712, LibSignature {\n    struct Order {\n        address trader;\n        address relayer;\n        address baseToken;\n        address quoteToken;\n        uint256 baseTokenAmount;\n        uint256 quoteTokenAmount;\n        uint256 gasTokenAmount;\n\n        /**\n         * Data contains the following values packed into 32 bytes\n         * ╔════════════════════╤═══════════════════════════════════════════════════════════╗\n         * ║                    │ length(bytes)   desc                                      ║\n         * ╟────────────────────┼───────────────────────────────────────────────────────────╢\n         * ║ version            │ 1               order version                             ║\n         * ║ side               │ 1               0: buy, 1: sell                           ║\n         * ║ isMarketOrder      │ 1               0: limitOrder, 1: marketOrder             ║\n         * ║ expiredAt          │ 5               order expiration time in seconds          ║\n         * ║ asMakerFeeRate     │ 2               maker fee rate (base 100,000)             ║\n         * ║ asTakerFeeRate     │ 2               taker fee rate (base 100,000)             ║\n         * ║ makerRebateRate    │ 2               rebate rate for maker (base 100,000)      ║\n         * ║ salt               │ 8               salt                                      ║\n         * ║                    │ 10              reserved                                  ║\n         * ╚════════════════════╧═══════════════════════════════════════════════════════════╝\n         */\n        bytes32 data;\n    }\n\n    enum OrderStatus {\n        EXPIRED,\n        CANCELLED,\n        FILLABLE,\n        FULLY_FILLED\n    }\n\n    bytes32 public constant EIP712_ORDER_TYPE = keccak256(\n        abi.encodePacked(\n            \"Order(address trader,address relayer,address baseToken,address quoteToken,uint256 baseTokenAmount,uint256 quoteTokenAmount,uint256 gasTokenAmount,bytes32 data)\"\n        )\n    );\n\n    /**\n     * Calculates the Keccak-256 EIP712 hash of the order using the Hydro Protocol domain.\n     *\n     * @param order The order data struct.\n     * @return Fully qualified EIP712 hash of the order in the Hydro Protocol domain.\n     */\n    function getOrderHash(Order memory order) internal view returns (bytes32 orderHash) {\n        orderHash = hashEIP712Message(hashOrder(order));\n        return orderHash;\n    }\n\n    /**\n     * Calculates the EIP712 hash of the order.\n     *\n     * @param order The order data struct.\n     * @return Hash of the order.\n     */\n    function hashOrder(Order memory order) internal pure returns (bytes32 result) {\n        /**\n         * Calculate the following hash in solidity assembly to save gas.\n         *\n         * keccak256(\n         *     abi.encodePacked(\n         *         EIP712_ORDER_TYPE,\n         *         bytes32(order.trader),\n         *         bytes32(order.relayer),\n         *         bytes32(order.baseToken),\n         *         bytes32(order.quoteToken),\n         *         order.baseTokenAmount,\n         *         order.quoteTokenAmount,\n         *         order.gasTokenAmount,\n         *         order.data\n         *     )\n         * );\n         */\n\n        bytes32 orderType = EIP712_ORDER_TYPE;\n\n        assembly {\n            let start := sub(order, 32)\n            let tmp := mload(start)\n\n            // 288 = (1 + 8) * 32\n            //\n            // [0...32)   bytes: EIP712_ORDER_TYPE\n            // [32...288) bytes: order\n            mstore(start, orderType)\n            result := keccak256(start, 288)\n\n            mstore(start, tmp)\n        }\n\n        return result;\n    }\n\n    /* Functions to extract info from data bytes in Order struct */\n\n    function getExpiredAtFromOrderData(bytes32 data) internal pure returns (uint256) {\n        return uint256(bytes5(data << (8*3)));\n    }\n\n    function isSell(bytes32 data) internal pure returns (bool) {\n        return data[1] == 1;\n    }\n\n    function isMarketOrder(bytes32 data) internal pure returns (bool) {\n        return data[2] == 1;\n    }\n\n    function isMarketBuy(bytes32 data) internal pure returns (bool) {\n        return !isSell(data) && isMarketOrder(data);\n    }\n\n    function getAsMakerFeeRateFromOrderData(bytes32 data) internal pure returns (uint256) {\n        return uint256(bytes2(data << (8*8)));\n    }\n\n    function getAsTakerFeeRateFromOrderData(bytes32 data) internal pure returns (uint256) {\n        return uint256(bytes2(data << (8*10)));\n    }\n\n    function getMakerRebateRateFromOrderData(bytes32 data) internal pure returns (uint256) {\n        return uint256(bytes2(data << (8*12)));\n    }\n}\n\ncontract LibMath {\n    using SafeMath for uint256;\n\n    /**\n     * Check the amount of precision lost by calculating multiple * (numerator / denominator). To\n     * do this, we check the remainder and make sure it's proportionally less than 0.1%. So we have:\n     *\n     *     ((numerator * multiple) % denominator)     1\n     *     -------------------------------------- < ----\n     *              numerator * multiple            1000\n     *\n     * To avoid further division, we can move the denominators to the other sides and we get:\n     *\n     *     ((numerator * multiple) % denominator) * 1000 < numerator * multiple\n     *\n     * Since we want to return true if there IS a rounding error, we simply flip the sign and our\n     * final equation becomes:\n     *\n     *     ((numerator * multiple) % denominator) * 1000 >= numerator * multiple\n     *\n     * @param numerator The numerator of the proportion\n     * @param denominator The denominator of the proportion\n     * @param multiple The amount we want a proportion of\n     * @return Boolean indicating if there is a rounding error when calculating the proportion\n     */\n    function isRoundingError(uint256 numerator, uint256 denominator, uint256 multiple)\n        internal\n        pure\n        returns (bool)\n    {\n        return numerator.mul(multiple).mod(denominator).mul(1000) >= numerator.mul(multiple);\n    }\n\n    /// @dev calculate \"multiple * (numerator / denominator)\", rounded down.\n    /// revert when there is a rounding error.\n    /**\n     * Takes an amount (multiple) and calculates a proportion of it given a numerator/denominator\n     * pair of values. The final value will be rounded down to the nearest integer value.\n     *\n     * This function will revert the transaction if rounding the final value down would lose more\n     * than 0.1% precision.\n     *\n     * @param numerator The numerator of the proportion\n     * @param denominator The denominator of the proportion\n     * @param multiple The amount we want a proportion of\n     * @return The final proportion of multiple rounded down\n     */\n    function getPartialAmountFloor(uint256 numerator, uint256 denominator, uint256 multiple)\n        internal\n        pure\n        returns (uint256)\n    {\n        require(!isRoundingError(numerator, denominator, multiple), \"ROUNDING_ERROR\");\n        return numerator.mul(multiple).div(denominator);\n    }\n\n    /**\n     * Returns the smaller integer of the two passed in.\n     *\n     * @param a Unsigned integer\n     * @param b Unsigned integer\n     * @return The smaller of the two integers\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n}\n\n/**\n * @title LibRelayer provides two distinct features for relayers. \n *\n * First, Relayers can opt into or out of the Hydro liquidity incentive system.\n *\n * Second, a relayer can register a delegate address.\n * Delegates can send matching requests on behalf of relayers.\n * The delegate scheme allows additional possibilities for smart contract interaction.\n * on behalf of the relayer.\n */\ncontract LibRelayer {\n\n    /**\n     * Mapping of relayerAddress => delegateAddress\n     */\n    mapping (address => mapping (address => bool)) public relayerDelegates;\n\n    /**\n     * Mapping of relayerAddress => whether relayer is opted out of the liquidity incentive system\n     */\n    mapping (address => bool) hasExited;\n\n    event RelayerApproveDelegate(address indexed relayer, address indexed delegate);\n    event RelayerRevokeDelegate(address indexed relayer, address indexed delegate);\n\n    event RelayerExit(address indexed relayer);\n    event RelayerJoin(address indexed relayer);\n\n    /**\n     * Approve an address to match orders on behalf of msg.sender\n     */\n    function approveDelegate(address delegate) external {\n        relayerDelegates[msg.sender][delegate] = true;\n        emit RelayerApproveDelegate(msg.sender, delegate);\n    }\n\n    /**\n     * Revoke an existing delegate\n     */\n    function revokeDelegate(address delegate) external {\n        relayerDelegates[msg.sender][delegate] = false;\n        emit RelayerRevokeDelegate(msg.sender, delegate);\n    }\n\n    /**\n     * @return true if msg.sender is allowed to match orders which belong to relayer\n     */\n    function canMatchOrdersFrom(address relayer) public view returns(bool) {\n        return msg.sender == relayer || relayerDelegates[relayer][msg.sender] == true;\n    }\n\n    /**\n     * Join the Hydro incentive system.\n     */\n    function joinIncentiveSystem() external {\n        delete hasExited[msg.sender];\n        emit RelayerJoin(msg.sender);\n    }\n\n    /**\n     * Exit the Hydro incentive system.\n     * For relayers that choose to opt-out, the Hydro Protocol\n     * effective becomes a tokenless protocol.\n     */\n    function exitIncentiveSystem() external {\n        hasExited[msg.sender] = true;\n        emit RelayerExit(msg.sender);\n    }\n\n    /**\n     * @return true if relayer is participating in the Hydro incentive system.\n     */\n    function isParticipant(address relayer) public view returns(bool) {\n        return !hasExited[relayer];\n    }\n}\n\n/**\n * Library to handle fee discount calculation\n */\ncontract LibDiscount is LibOwnable {\n    using SafeMath for uint256;\n    \n    // The base discounted rate is 100% of the current rate, or no discount.\n    uint256 public constant DISCOUNT_RATE_BASE = 100;\n\n    address public hotTokenAddress;\n\n    constructor(address _hotTokenAddress) internal {\n        hotTokenAddress = _hotTokenAddress;\n    }\n\n    /**\n     * Get the HOT token balance of an address.\n     *\n     * @param owner The address to check.\n     * @return The HOT balance for the owner address.\n     */\n    function getHotBalance(address owner) internal view returns (uint256 result) {\n        address hotToken = hotTokenAddress;\n\n        // IERC20(hotTokenAddress).balanceOf(owner)\n\n        /**\n         * We construct calldata for the `balanceOf` ABI.\n         * The layout of this calldata is in the table below.\n         * \n         * ╔════════╤════════╤════════╤═══════════════════╗\n         * ║ Area   │ Offset │ Length │ Contents          ║\n         * ╟────────┼────────┼────────┼───────────────────╢\n         * ║ Header │ 0      │ 4      │ function selector ║\n         * ║ Params │ 4      │ 32     │ owner address     ║\n         * ╚════════╧════════╧════════╧═══════════════════╝\n         */\n        assembly {\n            // Keep these so we can restore stack memory upon completion\n            let tmp1 := mload(0)\n            let tmp2 := mload(4)\n\n            // keccak256('balanceOf(address)') bitmasked to 4 bytes\n            mstore(0, 0x70a0823100000000000000000000000000000000000000000000000000000000)\n            mstore(4, owner)\n\n            // No need to check the return value because hotToken is a trustworthy contract\n            result := call(\n                gas,      // Forward all gas\n                hotToken, // HOT token deployment address\n                0,        // Don't send any ETH\n                0,        // Pointer to start of calldata\n                36,       // Length of calldata\n                0,        // Overwrite calldata with output\n                32        // Expecting uint256 output, the token balance\n            )\n            result := mload(0)\n\n            // Restore stack memory\n            mstore(0, tmp1)\n            mstore(4, tmp2)\n        }\n    }\n\n    bytes32 public discountConfig = 0x043c000027106400004e205a000075305000009c404600000000000000000000;\n\n    /**\n     * Calculate and return the rate at which fees will be charged for an address. The discounted\n     * rate depends on how much HOT token is owned by the user. Values returned will be a percentage\n     * used to calculate how much of the fee is paid, so a return value of 100 means there is 0\n     * discount, and a return value of 70 means a 30% rate reduction.\n     *\n     * The discountConfig is defined as such:\n     * ╔═══════════════════╤════════════════════════════════════════════╗\n     * ║                   │ length(bytes)   desc                       ║\n     * ╟───────────────────┼────────────────────────────────────────────╢\n     * ║ count             │ 1               the count of configs       ║\n     * ║ maxDiscountedRate │ 1               the max discounted rate    ║\n     * ║ config            │ 5 each                                     ║\n     * ╚═══════════════════╧════════════════════════════════════════════╝\n     *\n     * The default discount structure as defined in code would give the following result:\n     *\n     * Fee discount table\n     * ╔════════════════════╤══════════╗\n     * ║     HOT BALANCE    │ DISCOUNT ║\n     * ╠════════════════════╪══════════╣\n     * ║     0 <= x < 10000 │     0%   ║\n     * ╟────────────────────┼──────────╢\n     * ║ 10000 <= x < 20000 │    10%   ║\n     * ╟────────────────────┼──────────╢\n     * ║ 20000 <= x < 30000 │    20%   ║\n     * ╟────────────────────┼──────────╢\n     * ║ 30000 <= x < 40000 │    30%   ║\n     * ╟────────────────────┼──────────╢\n     * ║ 40000 <= x         │    40%   ║\n     * ╚════════════════════╧══════════╝\n     *\n     * Breaking down the bytes of 0x043c000027106400004e205a000075305000009c404600000000000000000000\n     *\n     * 0x  04           3c          0000271064  00004e205a  0000753050  00009c4046  0000000000  0000000000;\n     *     ~~           ~~          ~~~~~~~~~~  ~~~~~~~~~~  ~~~~~~~~~~  ~~~~~~~~~~  ~~~~~~~~~~  ~~~~~~~~~~\n     *      |            |               |           |           |           |           |           |\n     *    count  maxDiscountedRate       1           2           3           4           5           6\n     *\n     * The first config breaks down as follows:  00002710   64\n     *                                           ~~~~~~~~   ~~\n     *                                               |      |\n     *                                              bar    rate\n     *\n     * Meaning if a user has less than 10000 (0x00002710) HOT, they will pay 100%(0x64) of the\n     * standard fee.\n     *\n     * @param user The user address to calculate a fee discount for.\n     * @return The percentage of the regular fee this user will pay.\n     */\n    function getDiscountedRate(address user) public view returns (uint256 result) {\n        uint256 hotBalance = getHotBalance(user);\n\n        if (hotBalance == 0) {\n            return DISCOUNT_RATE_BASE;\n        }\n\n        bytes32 config = discountConfig;\n        uint256 count = uint256(byte(config));\n        uint256 bar;\n\n        // HOT Token has 18 decimals\n        hotBalance = hotBalance.div(10**18);\n\n        for (uint256 i = 0; i < count; i++) {\n            bar = uint256(bytes4(config << (2 + i * 5) * 8));\n\n            if (hotBalance < bar) {\n                result = uint256(byte(config << (2 + i * 5 + 4) * 8));\n                break;\n            }\n        }\n\n        // If we haven't found a rate in the config yet, use the maximum rate.\n        if (result == 0) {\n            result = uint256(config[1]);\n        }\n\n        // Make sure our discount algorithm never returns a higher rate than the base.\n        require(result <= DISCOUNT_RATE_BASE, \"DISCOUNT_ERROR\");\n    }\n\n    /**\n     * Owner can modify discount configuration.\n     *\n     * @param newConfig A data blob representing the new discount config. Details on format above.\n     */\n    function changeDiscountConfig(bytes32 newConfig) external onlyOwner {\n        discountConfig = newConfig;\n    }\n}\n\ncontract LibExchangeErrors {\n    string constant INVALID_TRADER = \"INVALID_TRADER\";\n    string constant INVALID_SENDER = \"INVALID_SENDER\";\n    // Taker order and maker order can't be matched\n    string constant INVALID_MATCH = \"INVALID_MATCH\";\n    string constant INVALID_SIDE = \"INVALID_SIDE\";\n    // Signature validation failed\n    string constant INVALID_ORDER_SIGNATURE = \"INVALID_ORDER_SIGNATURE\";\n    // Taker order is not valid\n    string constant INVALID_TAKER_ORDER = \"INVALID_TAKER_ORDER\";\n    string constant ORDER_IS_NOT_FILLABLE = \"ORDER_IS_NOT_FILLABLE\";\n    string constant MAKER_ORDER_CAN_NOT_BE_MARKET_ORDER = \"MAKER_ORDER_CAN_NOT_BE_MARKET_ORDER\";\n    string constant COMPLETE_MATCH_FAILED = \"COMPLETE_MATCH_FAILED\";\n    // Taker sells more than expected base tokens\n    string constant TAKER_SELL_BASE_EXCEEDED = \"TAKER_SELL_BASE_EXCEEDED\";\n    // Taker used more than expected quote tokens in market buy\n    string constant TAKER_MARKET_BUY_QUOTE_EXCEEDED = \"TAKER_MARKET_BUY_QUOTE_EXCEEDED\";\n    // Taker buys more than expected base tokens\n    string constant TAKER_LIMIT_BUY_BASE_EXCEEDED = \"TAKER_LIMIT_BUY_BASE_EXCEEDED\";\n    string constant TRANSFER_FROM_FAILED = \"TRANSFER_FROM_FAILED\";\n    string constant RECORD_ADDRESSES_ERROR = \"RECORD_ADDRESSES_ERROR\";\n    string constant PERIOD_NOT_COMPLETED_ERROR = \"PERIOD_NOT_COMPLETED_ERROR\";\n    string constant CLAIM_HOT_TOKEN_ERROR = \"CLAIM_HOT_TOKEN_ERROR\";\n    string constant INVALID_PERIOD = \"INVALID_PERIOD\";\n}\n\ncontract HybridExchange is LibOrder, LibMath, LibRelayer, LibDiscount, LibExchangeErrors {\n    using SafeMath for uint256;\n\n    uint256 public constant FEE_RATE_BASE = 100000;\n\n    /**\n     * Address of the proxy responsible for asset transfer.\n     */\n    address public proxyAddress;\n\n    /**\n     * Mapping of orderHash => amount\n     * Generally the amount will be specified in base token units, however in the case of a market\n     * buy order the amount is specified in quote token units.\n     */\n    mapping (bytes32 => uint256) public filled;\n    /**\n     * Mapping of orderHash => whether order has been cancelled.\n     */\n    mapping (bytes32 => bool) public cancelled;\n\n    event Cancel(bytes32 indexed orderHash);\n    event Match(\n        address baseToken,\n        address quoteToken,\n        address relayer,\n        address maker,\n        address taker,\n        uint256 baseTokenAmount,\n        uint256 quoteTokenAmount,\n        uint256 makerFee,\n        uint256 takerFee,\n        uint256 makerGasFee,\n        uint256 makerRebate,\n        uint256 takerGasFee\n    );\n\n    struct TotalMatchResult {\n        uint256 baseTokenFilledAmount;\n        uint256 quoteTokenFilledAmount;\n    }\n\n    struct MatchResult {\n        address maker;\n        address taker;\n        uint256 makerFee;\n        uint256 makerRebate;\n        uint256 takerFee;\n        uint256 makerGasFee;\n        uint256 takerGasFee;\n        uint256 baseTokenFilledAmount;\n        uint256 quoteTokenFilledAmount;\n    }\n\n    /**\n     * When orders are being matched, they will always contain the exact same base token,\n     * quote token, and relayer. Since excessive call data is very expensive, we choose\n     * to create a stripped down OrderParam struct containing only data that may vary between\n     * Order objects, and separate out the common elements into a set of addresses that will\n     * be shared among all of the OrderParam items. This is meant to eliminate redundancy in\n     * the call data, reducing it's size, and hence saving gas.\n     */\n    struct OrderParam {\n        address trader;\n        uint256 baseTokenAmount;\n        uint256 quoteTokenAmount;\n        uint256 gasTokenAmount;\n        bytes32 data;\n        OrderSignature signature;\n    }\n\n    struct OrderAddressSet {\n        address baseToken;\n        address quoteToken;\n        address relayer;\n    }\n\n    /**\n     * Calculated data about an order object.\n     * Generally the filledAmount is specified in base token units, however in the case of a market\n     * buy order the filledAmount is specified in quote token units.\n     */\n    struct OrderInfo {\n        bytes32 orderHash;\n        uint256 filledAmount;\n    }\n\n    constructor(address _proxyAddress, address hotTokenAddress)\n        LibDiscount(hotTokenAddress)\n        public\n    {\n        proxyAddress = _proxyAddress;\n    }\n\n    /**\n     * Match taker order to a list of maker orders. Common addresses are passed in\n     * separately as an OrderAddressSet to reduce call size data and save gas.\n     *\n     * @param takerOrderParam A OrderParam object representing the order from the taker.\n     * @param makerOrderParams An array of OrderParam objects representing orders from a list of makers.\n     * @param orderAddressSet An object containing addresses common across each order.\n     */\n    function matchOrders(\n        OrderParam memory takerOrderParam,\n        OrderParam[] memory makerOrderParams,\n        OrderAddressSet memory orderAddressSet\n    ) public {\n        require(canMatchOrdersFrom(orderAddressSet.relayer), INVALID_SENDER);\n\n        bool isParticipantRelayer = isParticipant(orderAddressSet.relayer);\n        uint256 takerFeeRate = getTakerFeeRate(takerOrderParam, isParticipantRelayer);\n        OrderInfo memory takerOrderInfo = getOrderInfo(takerOrderParam, orderAddressSet);\n\n        // Calculate which orders match for settlement.\n        MatchResult[] memory results = new MatchResult[](makerOrderParams.length);\n        TotalMatchResult memory totalMatch;\n        for (uint256 i = 0; i < makerOrderParams.length; i++) {\n            require(!isMarketOrder(makerOrderParams[i].data), MAKER_ORDER_CAN_NOT_BE_MARKET_ORDER);\n            require(isSell(takerOrderParam.data) != isSell(makerOrderParams[i].data), INVALID_SIDE);\n            validatePrice(takerOrderParam, makerOrderParams[i]);\n\n            OrderInfo memory makerOrderInfo = getOrderInfo(makerOrderParams[i], orderAddressSet);\n\n            results[i] = getMatchResult(\n                takerOrderParam,\n                takerOrderInfo,\n                makerOrderParams[i],\n                makerOrderInfo,\n                takerFeeRate,\n                isParticipantRelayer\n            );\n\n            // Update TotalMatchResult with new fill amounts\n            totalMatch.baseTokenFilledAmount = totalMatch.baseTokenFilledAmount.add(\n                results[i].baseTokenFilledAmount\n            );\n            totalMatch.quoteTokenFilledAmount = totalMatch.quoteTokenFilledAmount.add(\n                results[i].quoteTokenFilledAmount\n            );\n\n            // Update amount filled for this maker order.\n            filled[makerOrderInfo.orderHash] = makerOrderInfo.filledAmount.add(\n                results[i].baseTokenFilledAmount\n            );\n        }\n\n        validateMatchResult(takerOrderParam, totalMatch);\n        settleResults(results, takerOrderParam, orderAddressSet);\n\n        // Update amount filled for this taker order.\n        filled[takerOrderInfo.orderHash] = takerOrderInfo.filledAmount;\n    }\n\n    /**\n     * Cancels an order, preventing it from being matched. In practice, matching mode relayers will\n     * generally handle cancellation off chain by removing the order from their system, however if\n     * the trader wants to ensure the order never goes through, or they no longer trust the relayer,\n     * this function may be called to block it from ever matching at the contract level.\n     *\n     * Emits a Cancel event on success.\n     *\n     * @param order The order to be cancelled.\n     */\n    function cancelOrder(Order memory order) public {\n        require(order.trader == msg.sender, INVALID_TRADER);\n\n        bytes32 orderHash = getOrderHash(order);\n        cancelled[orderHash] = true;\n\n        emit Cancel(orderHash);\n    }\n\n    /**\n     * Calculates current state of the order. Will revert transaction if this order is not\n     * fillable for any reason, or if the order signature is invalid.\n     *\n     * @param orderParam The OrderParam object containing Order data.\n     * @param orderAddressSet An object containing addresses common across each order.\n     * @return An OrderInfo object containing the hash and current amount filled\n     */\n    function getOrderInfo(OrderParam memory orderParam, OrderAddressSet memory orderAddressSet)\n        internal\n        view\n        returns (OrderInfo memory orderInfo)\n    {\n        Order memory order = getOrderFromOrderParam(orderParam, orderAddressSet);\n        orderInfo.orderHash = getOrderHash(order);\n        orderInfo.filledAmount = filled[orderInfo.orderHash];\n        uint8 status = uint8(OrderStatus.FILLABLE);\n\n        if (!isMarketBuy(order.data) && orderInfo.filledAmount >= order.baseTokenAmount) {\n            status = uint8(OrderStatus.FULLY_FILLED);\n        } else if (isMarketBuy(order.data) && orderInfo.filledAmount >= order.quoteTokenAmount) {\n            status = uint8(OrderStatus.FULLY_FILLED);\n        } else if (block.timestamp >= getExpiredAtFromOrderData(order.data)) {\n            status = uint8(OrderStatus.EXPIRED);\n        } else if (cancelled[orderInfo.orderHash]) {\n            status = uint8(OrderStatus.CANCELLED);\n        }\n\n        require(status == uint8(OrderStatus.FILLABLE), ORDER_IS_NOT_FILLABLE);\n        require(\n            isValidSignature(orderInfo.orderHash, orderParam.trader, orderParam.signature),\n            INVALID_ORDER_SIGNATURE\n        );\n\n        return orderInfo;\n    }\n\n    /**\n     * Reconstruct an Order object from the given OrderParam and OrderAddressSet objects.\n     *\n     * @param orderParam The OrderParam object containing the Order data.\n     * @param orderAddressSet An object containing addresses common across each order.\n     * @return The reconstructed Order object.\n     */\n    function getOrderFromOrderParam(OrderParam memory orderParam, OrderAddressSet memory orderAddressSet)\n        internal\n        pure\n        returns (Order memory order)\n    {\n        order.trader = orderParam.trader;\n        order.baseTokenAmount = orderParam.baseTokenAmount;\n        order.quoteTokenAmount = orderParam.quoteTokenAmount;\n        order.gasTokenAmount = orderParam.gasTokenAmount;\n        order.data = orderParam.data;\n        order.baseToken = orderAddressSet.baseToken;\n        order.quoteToken = orderAddressSet.quoteToken;\n        order.relayer = orderAddressSet.relayer;\n    }\n\n    /**\n     * Validates that the maker and taker orders can be matched based on the listed prices.\n     *\n     * If the taker submitted a sell order, the matching maker order must have a price greater than\n     * or equal to the price the taker is willing to sell for.\n     *\n     * Since the price of an order is computed by order.quoteTokenAmount / order.baseTokenAmount\n     * we can establish the following formula:\n     *\n     *    takerOrder.quoteTokenAmount        makerOrder.quoteTokenAmount\n     *   -----------------------------  <=  -----------------------------\n     *     takerOrder.baseTokenAmount        makerOrder.baseTokenAmount\n     *\n     * To avoid precision loss from division, we modify the formula to avoid division entirely.\n     * In shorthand, this becomes:\n     *\n     *   takerOrder.quote * makerOrder.base <= takerOrder.base * makerOrder.quote\n     *\n     * We can apply this same process to buy orders - if the taker submitted a buy order then\n     * the matching maker order must have a price less than or equal to the price the taker is\n     * willing to pay. This means we can use the same result as above, but simply flip the\n     * sign of the comparison operator.\n     *\n     * The function will revert the transaction if the orders cannot be matched.\n     *\n     * @param takerOrderParam The OrderParam object representing the taker's order data\n     * @param makerOrderParam The OrderParam object representing the maker's order data\n     */\n    function validatePrice(OrderParam memory takerOrderParam, OrderParam memory makerOrderParam)\n        internal\n        pure\n    {\n        uint256 left = takerOrderParam.quoteTokenAmount.mul(makerOrderParam.baseTokenAmount);\n        uint256 right = takerOrderParam.baseTokenAmount.mul(makerOrderParam.quoteTokenAmount);\n        require(isSell(takerOrderParam.data) ? left <= right : left >= right, INVALID_MATCH);\n    }\n\n    /**\n     * Construct a MatchResult from matching taker and maker order data, which will be used when\n     * settling the orders and transferring token.\n     *\n     * @param takerOrderParam The OrderParam object representing the taker's order data\n     * @param takerOrderInfo The OrderInfo object representing the current taker order state\n     * @param makerOrderParam The OrderParam object representing the maker's order data\n     * @param makerOrderInfo The OrderInfo object representing the current maker order state\n     * @param takerFeeRate The rate used to calculate the fee charged to the taker\n     * @param isParticipantRelayer Whether this relayer is participating in hot discount\n     * @return MatchResult object containing data that will be used during order settlement.\n     */\n    function getMatchResult(\n        OrderParam memory takerOrderParam,\n        OrderInfo memory takerOrderInfo,\n        OrderParam memory makerOrderParam,\n        OrderInfo memory makerOrderInfo,\n        uint256 takerFeeRate,\n        bool isParticipantRelayer\n    )\n        internal\n        view\n        returns (MatchResult memory result)\n    {\n        // This will represent the amount we will be filling in this match. In most cases this will\n        // be represented in base token units, but in the market buy case this will be quote token\n        // units.\n        uint256 filledAmount;\n\n        // Determine the amount of token that will be filled by this match, in both base and quote\n        // token units. This is done by checking which order has the least amount of token available\n        // to fill or be filled and using that as the base fill amount.\n        if(!isMarketBuy(takerOrderParam.data)) {\n            filledAmount = min(\n                takerOrderParam.baseTokenAmount.sub(takerOrderInfo.filledAmount),\n                makerOrderParam.baseTokenAmount.sub(makerOrderInfo.filledAmount)\n            );\n            result.quoteTokenFilledAmount = convertBaseToQuote(makerOrderParam, filledAmount);\n            result.baseTokenFilledAmount = filledAmount;\n        } else {\n            // In the market buy order case, we have to compare the amount of quote token left in\n            // the taker order with the amount of base token left in the maker order. In order to do\n            // that we convert from base to quote units in our comparison.\n            filledAmount = min(\n                takerOrderParam.quoteTokenAmount.sub(takerOrderInfo.filledAmount),\n                convertBaseToQuote(\n                    makerOrderParam,\n                    makerOrderParam.baseTokenAmount.sub(makerOrderInfo.filledAmount)\n                )\n            );\n            result.baseTokenFilledAmount = convertQuoteToBase(makerOrderParam, filledAmount);\n            result.quoteTokenFilledAmount = filledAmount;\n        }\n\n        // Each order only pays gas once, so only pay gas when nothing has been filled yet.\n        if (takerOrderInfo.filledAmount == 0) {\n            result.takerGasFee = takerOrderParam.gasTokenAmount;\n        }\n\n        if (makerOrderInfo.filledAmount == 0) {\n            result.makerGasFee = makerOrderParam.gasTokenAmount;\n        }\n\n        // Update filled amount. The filledAmount variable will always be in the correct base or\n        // quote unit.\n        takerOrderInfo.filledAmount = takerOrderInfo.filledAmount.add(filledAmount);\n\n        result.maker = makerOrderParam.trader;\n        result.taker = takerOrderParam.trader;\n\n        // rebateRate uses the same base as fee rates, so can be directly compared\n        uint256 rebateRate = getMakerRebateRateFromOrderData(makerOrderParam.data);\n        uint256 makerRawFeeRate = getAsMakerFeeRateFromOrderData(makerOrderParam.data);\n\n        if (rebateRate > makerRawFeeRate) {\n            // Cap the rebate so it will never exceed the fees paid by the taker.\n            uint256 makerRebateRate = min(\n                // Don't want to apply discounts to the rebase, so simply multiply by\n                // DISCOUNT_RATE_BASE to get it to the correct units.\n                rebateRate.sub(makerRawFeeRate).mul(DISCOUNT_RATE_BASE),\n                takerFeeRate\n            );\n            result.makerRebate = result.quoteTokenFilledAmount.mul(makerRebateRate).div(\n                FEE_RATE_BASE.mul(DISCOUNT_RATE_BASE)\n            );\n            // If the rebate rate is higher, maker pays no fees.\n            result.makerFee = 0;\n        } else {\n            // maker fee will be reduced, but still >= 0\n            uint256 makerFeeRate = getFinalFeeRate(\n                makerOrderParam.trader,\n                makerRawFeeRate.sub(rebateRate),\n                isParticipantRelayer\n            );\n            result.makerFee = result.quoteTokenFilledAmount.mul(makerFeeRate).div(\n                FEE_RATE_BASE.mul(DISCOUNT_RATE_BASE)\n            );\n            result.makerRebate = 0;\n        }\n\n        result.takerFee = result.quoteTokenFilledAmount.mul(takerFeeRate).div(\n            FEE_RATE_BASE.mul(DISCOUNT_RATE_BASE)\n        );\n    }\n\n    /**\n     * Get the rate used to calculate the taker fee.\n     *\n     * @param orderParam The OrderParam object representing the taker order data.\n     * @param isParticipantRelayer Whether this relayer is participating in hot discount.\n     * @return The final potentially discounted rate to use for the taker fee.\n     */\n    function getTakerFeeRate(OrderParam memory orderParam, bool isParticipantRelayer)\n        internal\n        view\n        returns(uint256)\n    {\n        uint256 rawRate = getAsTakerFeeRateFromOrderData(orderParam.data);\n        return getFinalFeeRate(orderParam.trader, rawRate, isParticipantRelayer);\n    }\n\n    /**\n     * Take a fee rate and calculate the potentially discounted rate for this trader based on\n     * HOT token ownership.\n     *\n     * @param trader The address of the trader who made the order.\n     * @param rate The raw rate which we will discount if needed.\n     * @param isParticipantRelayer Whether this relayer is participating in hot discount.\n     * @return The final potentially discounted rate.\n     */\n    function getFinalFeeRate(address trader, uint256 rate, bool isParticipantRelayer)\n        internal\n        view\n        returns(uint256)\n    {\n        if (isParticipantRelayer) {\n            return rate.mul(getDiscountedRate(trader));\n        } else {\n            return rate.mul(DISCOUNT_RATE_BASE);\n        }\n    }\n\n    /**\n     * Take an amount and convert it from base token units to quote token units based on the price\n     * in the order param.\n     *\n     * @param orderParam The OrderParam object containing the Order data.\n     * @param amount An amount of base token.\n     * @return The converted amount in quote token units.\n     */\n    function convertBaseToQuote(OrderParam memory orderParam, uint256 amount)\n        internal\n        pure\n        returns (uint256)\n    {\n        return getPartialAmountFloor(\n            orderParam.quoteTokenAmount,\n            orderParam.baseTokenAmount,\n            amount\n        );\n    }\n\n    /**\n     * Take an amount and convert it from quote token units to base token units based on the price\n     * in the order param.\n     *\n     * @param orderParam The OrderParam object containing the Order data.\n     * @param amount An amount of quote token.\n     * @return The converted amount in base token units.\n     */\n    function convertQuoteToBase(OrderParam memory orderParam, uint256 amount)\n        internal\n        pure\n        returns (uint256)\n    {\n        return getPartialAmountFloor(\n            orderParam.baseTokenAmount,\n            orderParam.quoteTokenAmount,\n            amount\n        );\n    }\n\n    /**\n     * Validates sanity of match results.\n     *\n     * This function will revert the transaction if the results cannot be validated.\n     *\n     * @param takerOrderParam The OrderParam object representing the taker's order data\n     * @param totalMatch Accumlated match result data representing how much token will be filled\n     */\n    function validateMatchResult(OrderParam memory takerOrderParam, TotalMatchResult memory totalMatch)\n        internal\n        pure\n    {\n        if (isSell(takerOrderParam.data)) {\n            // Ensure we don't attempt to sell more tokens than the taker wished to sell\n            require(\n                totalMatch.baseTokenFilledAmount <= takerOrderParam.baseTokenAmount,\n                TAKER_SELL_BASE_EXCEEDED\n            );\n        } else {\n            // Ensure we don't attempt to buy more tokens than the taker wished to buy\n            require(\n                totalMatch.quoteTokenFilledAmount <= takerOrderParam.quoteTokenAmount,\n                TAKER_MARKET_BUY_QUOTE_EXCEEDED\n            );\n\n            // If this isn't a market order, there may be maker orders with a better price. Ensure\n            // we use exactly the taker's price in this case (as it is a limit order) by validating\n            // that the amount of base token filled also matches.\n            if (!isMarketOrder(takerOrderParam.data)) {\n                require(\n                    totalMatch.baseTokenFilledAmount <= takerOrderParam.baseTokenAmount,\n                    TAKER_LIMIT_BUY_BASE_EXCEEDED\n                );\n            }\n        }\n    }\n\n    /**\n     * Take a list of matches and settle them with the taker order, transferring tokens all tokens\n     * and paying all fees necessary to complete the transaction.\n     *\n     * @param results List of MatchResult objects representing each individual trade to settle.\n     * @param takerOrderParam The OrderParam object representing the taker order data.\n     * @param orderAddressSet An object containing addresses common across each order.\n     */\n    function settleResults(\n        MatchResult[] memory results,\n        OrderParam memory takerOrderParam,\n        OrderAddressSet memory orderAddressSet\n    )\n        internal\n    {\n        if (isSell(takerOrderParam.data)) {\n            settleTakerSell(results, orderAddressSet);\n        } else {\n            settleTakerBuy(results, orderAddressSet);\n        }\n    }\n\n    /**\n     * Settles a sell order given a list of MatchResult objects. A naive approach would be to take\n     * each result, have the taker and maker transfer the appropriate tokens, and then have them\n     * each send the appropriate fees to the relayer, meaning that for n makers there would be 4n\n     * transactions. Additionally the taker would have to have an allowance set for the quote token\n     * in order to pay the fees to the relayer.\n     *\n     * Instead we do the following:\n     *  - Taker transfers the required base token to each maker\n     *  - Each maker sends an amount of quote token to the relayer equal to:\n     *    [Amount owed to taker] + [Maker fee] + [Maker gas cost] - [Maker rebate amount]\n     *  - The relayer will then take all of this quote token and in a single batch transaction\n     *    send the appropriate amount to the taker, equal to:\n     *    [Total amount owed to taker] - [All taker fees] - [All taker gas costs]\n     *\n     * Thus in the end the taker will have the full amount of quote token, sans the fee and cost of\n     * their share of gas. Each maker will have their share of base token, sans the fee and cost of\n     * their share of gas, and will keep their rebate in quote token. The relayer will end up with\n     * the fees from the taker and each maker (sans rebate), and the gas costs will pay for the\n     * transactions. In this scenario, with n makers there will be 2n + 1 transactions, which will\n     * be a significant gas savings over the original method.\n     *\n     * @param results A list of MatchResult objects representing each individual trade to settle.\n     * @param orderAddressSet An object containing addresses common across each order.\n     */\n    function settleTakerSell(MatchResult[] memory results, OrderAddressSet memory orderAddressSet) internal {\n        uint256 totalTakerBaseTokenFilledAmount = 0;\n\n        for (uint256 i = 0; i < results.length; i++) {\n            transferFrom(\n                orderAddressSet.baseToken,\n                results[i].taker,\n                results[i].maker,\n                results[i].baseTokenFilledAmount\n            );\n\n            transferFrom(\n                orderAddressSet.quoteToken,\n                results[i].maker,\n                orderAddressSet.relayer,\n                results[i].quoteTokenFilledAmount.\n                    add(results[i].makerFee).\n                    add(results[i].makerGasFee).\n                    sub(results[i].makerRebate)\n            );\n\n            totalTakerBaseTokenFilledAmount = totalTakerBaseTokenFilledAmount.add(\n                results[i].quoteTokenFilledAmount.sub(results[i].takerFee)\n            );\n\n            emitMatchEvent(results[i], orderAddressSet);\n        }\n\n        transferFrom(\n            orderAddressSet.quoteToken,\n            orderAddressSet.relayer,\n            results[0].taker,\n            totalTakerBaseTokenFilledAmount.sub(results[0].takerGasFee)\n        );\n    }\n\n    /**\n     * Settles a buy order given a list of MatchResult objects. A naive approach would be to take\n     * each result, have the taker and maker transfer the appropriate tokens, and then have them\n     * each send the appropriate fees to the relayer, meaning that for n makers there would be 4n\n     * transactions. Additionally each maker would have to have an allowance set for the quote token\n     * in order to pay the fees to the relayer.\n     *\n     * Instead we do the following:\n     *  - Each maker transfers base tokens to the taker\n     *  - The taker sends an amount of quote tokens to each maker equal to:\n     *    [Amount owed to maker] + [Maker rebate amount] - [Maker fee] - [Maker gas cost]\n     *  - Since the taker saved all the maker fees and gas costs, it can then send them as a single\n     *    batch transaction to the relayer, equal to:\n     *    [All maker and taker fees] + [All maker and taker gas costs] - [All maker rebates]\n     *\n     * Thus in the end the taker will have the full amount of base token, sans the fee and cost of\n     * their share of gas. Each maker will have their share of quote token, including their rebate,\n     * but sans the fee and cost of their share of gas. The relayer will end up with the fees from\n     * the taker and each maker (sans rebates), and the gas costs will pay for the transactions. In\n     * this scenario, with n makers there will be 2n + 1 transactions, which will be a significant\n     * gas savings over the original method.\n     *\n     * @param results A list of MatchResult objects representing each individual trade to settle.\n     * @param orderAddressSet An object containing addresses common across each order.\n     */\n    function settleTakerBuy(MatchResult[] memory results, OrderAddressSet memory orderAddressSet) internal {\n        uint256 totalFee = 0;\n\n        for (uint256 i = 0; i < results.length; i++) {\n            transferFrom(\n                orderAddressSet.baseToken,\n                results[i].maker,\n                results[i].taker,\n                results[i].baseTokenFilledAmount\n            );\n\n            transferFrom(\n                orderAddressSet.quoteToken,\n                results[i].taker,\n                results[i].maker,\n                results[i].quoteTokenFilledAmount.\n                    sub(results[i].makerFee).\n                    sub(results[i].makerGasFee).\n                    add(results[i].makerRebate)\n            );\n\n            totalFee = totalFee.\n                add(results[i].takerFee).\n                add(results[i].makerFee).\n                add(results[i].makerGasFee).\n                add(results[i].takerGasFee).\n                sub(results[i].makerRebate);\n\n            emitMatchEvent(results[i], orderAddressSet);\n        }\n\n        transferFrom(\n            orderAddressSet.quoteToken,\n            results[0].taker,\n            orderAddressSet.relayer,\n            totalFee\n        );\n    }\n\n    /**\n     * A helper function to call the transferFrom function in Proxy.sol with solidity assembly.\n     * Copying the data in order to make an external call can be expensive, but performing the\n     * operations in assembly seems to reduce gas cost.\n     *\n     * The function will revert the transaction if the transfer fails.\n     *\n     * @param token The address of the ERC20 token we will be transferring, 0 for ETH.\n     * @param from The address we will be transferring from.\n     * @param to The address we will be transferring to.\n     * @param value The amount of token we will be transferring.\n     */\n    function transferFrom(address token, address from, address to, uint256 value) internal {\n        if (value == 0) {\n            return;\n        }\n\n        address proxy = proxyAddress;\n        uint256 result;\n\n        /**\n         * We construct calldata for the `Proxy.transferFrom` ABI.\n         * The layout of this calldata is in the table below.\n         *\n         * ╔════════╤════════╤════════╤═══════════════════╗\n         * ║ Area   │ Offset │ Length │ Contents          ║\n         * ╟────────┼────────┼────────┼───────────────────╢\n         * ║ Header │ 0      │ 4      │ function selector ║\n         * ║ Params │ 4      │ 32     │ token address     ║\n         * ║        │ 36     │ 32     │ from address      ║\n         * ║        │ 68     │ 32     │ to address        ║\n         * ║        │ 100    │ 32     │ amount of token   ║\n         * ╚════════╧════════╧════════╧═══════════════════╝\n         */\n        assembly {\n            // Keep these so we can restore stack memory upon completion\n            let tmp1 := mload(0)\n            let tmp2 := mload(4)\n            let tmp3 := mload(36)\n            let tmp4 := mload(68)\n            let tmp5 := mload(100)\n\n            // keccak256('transferFrom(address,address,address,uint256)') bitmasked to 4 bytes\n            mstore(0, 0x15dacbea00000000000000000000000000000000000000000000000000000000)\n            mstore(4, token)\n            mstore(36, from)\n            mstore(68, to)\n            mstore(100, value)\n\n            // Call Proxy contract transferFrom function using constructed calldata\n            result := call(\n                gas,   // Forward all gas\n                proxy, // Proxy.sol deployment address\n                0,     // Don't send any ETH\n                0,     // Pointer to start of calldata\n                132,   // Length of calldata\n                0,     // Output location\n                0      // We don't expect any output\n            )\n\n            // Restore stack memory\n            mstore(0, tmp1)\n            mstore(4, tmp2)\n            mstore(36, tmp3)\n            mstore(68, tmp4)\n            mstore(100, tmp5)\n        }\n\n        if (result == 0) {\n            revert(TRANSFER_FROM_FAILED);\n        }\n    }\n\n    function emitMatchEvent(MatchResult memory result, OrderAddressSet memory orderAddressSet) internal {\n        emit Match(\n            orderAddressSet.baseToken,\n            orderAddressSet.quoteToken,\n            orderAddressSet.relayer,\n            result.maker,\n            result.taker,\n            result.baseTokenFilledAmount,\n            result.quoteTokenFilledAmount,\n            result.makerFee,\n            result.takerFee,\n            result.makerGasFee,\n            result.makerRebate,\n            result.takerGasFee\n        );\n    }\n}",
  "abi": "[{\"constant\":false,\"inputs\":[{\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"approveDelegate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newConfig\",\"type\":\"bytes32\"}],\"name\":\"changeDiscountConfig\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxyAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"filled\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"cancelled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"relayerDelegates\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"exitIncentiveSystem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"discountConfig\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"relayer\",\"type\":\"address\"}],\"name\":\"canMatchOrdersFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getDiscountedRate\",\"outputs\":[{\"name\":\"result\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"EIP712_ORDER_TYPE\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FEE_RATE_BASE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DISCOUNT_RATE_BASE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"trader\",\"type\":\"address\"},{\"name\":\"baseTokenAmount\",\"type\":\"uint256\"},{\"name\":\"quoteTokenAmount\",\"type\":\"uint256\"},{\"name\":\"gasTokenAmount\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes32\"},{\"components\":[{\"name\":\"config\",\"type\":\"bytes32\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"signature\",\"type\":\"tuple\"}],\"name\":\"takerOrderParam\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"trader\",\"type\":\"address\"},{\"name\":\"baseTokenAmount\",\"type\":\"uint256\"},{\"name\":\"quoteTokenAmount\",\"type\":\"uint256\"},{\"name\":\"gasTokenAmount\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes32\"},{\"components\":[{\"name\":\"config\",\"type\":\"bytes32\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"signature\",\"type\":\"tuple\"}],\"name\":\"makerOrderParams\",\"type\":\"tuple[]\"},{\"components\":[{\"name\":\"baseToken\",\"type\":\"address\"},{\"name\":\"quoteToken\",\"type\":\"address\"},{\"name\":\"relayer\",\"type\":\"address\"}],\"name\":\"orderAddressSet\",\"type\":\"tuple\"}],\"name\":\"matchOrders\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"relayer\",\"type\":\"address\"}],\"name\":\"isParticipant\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"trader\",\"type\":\"address\"},{\"name\":\"relayer\",\"type\":\"address\"},{\"name\":\"baseToken\",\"type\":\"address\"},{\"name\":\"quoteToken\",\"type\":\"address\"},{\"name\":\"baseTokenAmount\",\"type\":\"uint256\"},{\"name\":\"quoteTokenAmount\",\"type\":\"uint256\"},{\"name\":\"gasTokenAmount\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes32\"}],\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"joinIncentiveSystem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"EIP712_DOMAIN_TYPEHASH\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hotTokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"revokeDelegate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_proxyAddress\",\"type\":\"address\"},{\"name\":\"hotTokenAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"Cancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"baseToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"quoteToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"relayer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"taker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"baseTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"quoteTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"makerFee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"takerFee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"makerGasFee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"makerRebate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"takerGasFee\",\"type\":\"uint256\"}],\"name\":\"Match\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"relayer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"RelayerApproveDelegate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"relayer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"RelayerRevokeDelegate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"relayer\",\"type\":\"address\"}],\"name\":\"RelayerExit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"relayer\",\"type\":\"address\"}],\"name\":\"RelayerJoin\",\"type\":\"event\"}]",
  "bytecode": "60806040527f043c000027106400004e205a000075305000009c4046000000000000000000006005553480156200003557600080fd5b5060405160408062003482833981018060405262000057919081019062000376565b8060405160200180807f454950373132446f6d61696e28737472696e67206e616d652c737472696e672081526020017f76657273696f6e2c6164647265737320766572696679696e67436f6e7472616381526020017f742900000000000000000000000000000000000000000000000000000000000081525060420190506040516020818303038152906040526040518082805190602001908083835b60208310620001155780518252601f199092019160209182019101620000f4565b51815160209384036101000a6000190180199092169116179052604080519290940182900382208285018552600e8084527f487964726f2050726f746f636f6c000000000000000000000000000000000000928401928352945190965091945090928392508083835b602083106200019f5780518252601f1990920191602091820191016200017e565b51815160209384036101000a600019018019909216911617905260408051929094018290038220828501855260018084527f3100000000000000000000000000000000000000000000000000000000000000928401928352945190965091945090928392508083835b60208310620002295780518252601f19909201916020918201910162000208565b51815160209384036101000a6000190180199092169116179052604080519290940182900382208282019890985281840196909652606081019690965250306080808701919091528151808703909101815260a09095019081905284519093849350850191508083835b60208310620002b45780518252601f19909201916020918201910162000293565b5181516000196020949094036101000a9390930192831692191691909117905260405192018290038220600090815560038054600160a060020a031916331790819055600160a060020a0316945092507f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091839150a360048054600160a060020a03928316600160a060020a031991821617909155600680549490921693169290921790915550620003c1565b60006200036f8251620003b5565b9392505050565b600080604083850312156200038a57600080fd5b600062000398858562000361565b9250506020620003ab8582860162000361565b9150509250929050565b600160a060020a031690565b6130b180620003d16000396000f3006080604052600436106101485763ffffffff7c010000000000000000000000000000000000000000000000000000000060003504166306df453e811461014d578063156066e41461016f57806323f5c02d1461018f578063288cdc91146101ba5780632ac12622146101e757806331d48447146102145780633560c5cd146102345780633644e5151461024957806337e607511461025e5780633e5893be146102735780634376abf1146102935780635373a191146102b357806361c3efb1146102c8578063715018a6146102dd5780637add89fb146102f25780638d10883d146103075780638da5cb5b146103275780638f32d59b1461033c578063929066f514610351578063b6b3618e14610371578063b875bdf114610391578063c7977be7146103a6578063cdfcc984146103bb578063f2fde38b146103d0578063fa352c00146103f0575b600080fd5b34801561015957600080fd5b5061016d610168366004612a09565b610410565b005b34801561017b57600080fd5b5061016d61018a366004612a61565b610496565b34801561019b57600080fd5b506101a46104e4565b6040516101b19190612d45565b60405180910390f35b3480156101c657600080fd5b506101da6101d5366004612a61565b610500565b6040516101b19190612e14565b3480156101f357600080fd5b50610207610202366004612a61565b610512565b6040516101b19190612e06565b34801561022057600080fd5b5061020761022f366004612a27565b610527565b34801561024057600080fd5b5061016d610547565b34801561025557600080fd5b506101da6105a7565b34801561026a57600080fd5b506101da6105ad565b34801561027f57600080fd5b5061020761028e366004612a09565b6105b3565b34801561029f57600080fd5b506101da6102ae366004612a09565b610613565b3480156102bf57600080fd5b506101da610799565b3480156102d457600080fd5b506101da610838565b3480156102e957600080fd5b5061016d61083f565b3480156102fe57600080fd5b506101da6108ee565b34801561031357600080fd5b5061016d610322366004612a7f565b6108f3565b34801561033357600080fd5b506101a4610cd0565b34801561034857600080fd5b50610207610cec565b34801561035d57600080fd5b5061020761036c366004612a09565b610d0a565b34801561037d57600080fd5b5061016d61038c366004612ae7565b610d36565b34801561039d57600080fd5b5061016d610e2e565b3480156103b257600080fd5b506101da610e8b565b3480156103c757600080fd5b506101a4610f63565b3480156103dc57600080fd5b5061016d6103eb366004612a09565b610f7f565b3480156103fc57600080fd5b5061016d61040b366004612a09565b61109c565b33600081815260016020818152604080842073ffffffffffffffffffffffffffffffffffffffff8716808652925280842080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001690931790925590519092917f7fa92f6e23fcdb0b7a7001ea137560a8ebee9b8302d16e3b37c64ae7116b69ad91a350565b61049e610cec565b15156104df576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104d690612ed1565b60405180910390fd5b600555565b60065473ffffffffffffffffffffffffffffffffffffffff1681565b60076020526000908152604090205481565b60086020526000908152604090205460ff1681565b600160209081526000928352604080842090915290825290205460ff1681565b3360008181526002602052604080822080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00166001179055517f9bdfcd96a99ab6dad403b4ef4562bb3471fdeaab5e699160abf7c3f2cbe668059190a2565b60005481565b60055481565b60003373ffffffffffffffffffffffffffffffffffffffff8316148061060d575073ffffffffffffffffffffffffffffffffffffffff821660009081526001602081815260408084203385529091529091205460ff161515145b92915050565b6000806000806000806106258761111d565b9450841515610637576064955061078f565b60055493507f01000000000000000000000000000000000000000000000000000000000000008404925061067985670de0b6b3a764000063ffffffff61118516565b9450600090505b82811015610701577c0100000000000000000000000000000000000000000000000000000000600582026002908101600802900a8502049150818510156106f9577f01000000000000000000000000000000000000000000000000000000000000006008600660058402010260020a8502049550610701565b600101610680565b851515610754578360011a7f0100000000000000000000000000000000000000000000000000000000000000027f0100000000000000000000000000000000000000000000000000000000000000900495505b606486111561078f576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104d690612e71565b5050505050919050565b60405160200180609f612fd98239609f0190506040516020818303038152906040526040518082805190602001908083835b6020831061080857805182527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe090920191602091820191016107cb565b6001836020036101000a038019825116818451168082178552505050505050905001915050604051809103902081565b620186a081565b610847610cec565b151561087f576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104d690612ed1565b60035460405160009173ffffffffffffffffffffffffffffffffffffffff16907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0908390a3600380547fffffffffffffffffffffffff0000000000000000000000000000000000000000169055565b606481565b6000806108fe612697565b6060610908612697565b6000610912612697565b61091f88604001516105b3565b60408051808201909152600e81527f494e56414c49445f53454e444552000000000000000000000000000000000000602082015290151561098d576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104d69190612e60565b5061099b8860400151610d0a565b96506109a78a886111da565b95506109b38a89611203565b945088516040519080825280602002602001820160405280156109f057816020015b6109dd6126ae565b8152602001906001900390816109d55790505b509350600091505b8851821015610c9957610a258983815181101515610a1257fe5b90602001906020020151608001516113da565b60408051606081018252602381527f4d414b45525f4f524445525f43414e5f4e4f545f42455f4d41524b45545f4f5260208201527f4445520000000000000000000000000000000000000000000000000000000000918101919091529015610aba576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104d69190612e60565b50610adf8983815181101515610acc57fe5b906020019060200201516080015161142e565b1515610aee8b6080015161142e565b60408051808201909152600c81527f494e56414c49445f5349444500000000000000000000000000000000000000006020820152919015151415610b5f576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104d69190612e60565b50610b818a8a84815181101515610b7257fe5b90602001906020020151611438565b610ba28983815181101515610b9257fe5b9060200190602002015189611203565b9050610bc98a868b85815181101515610bb757fe5b90602001906020020151848a8c611509565b8483815181101515610bd757fe5b602090810290910101528351610c0f90859084908110610bf357fe5b6020908102909101015160e0015184519063ffffffff61178616565b83528351610c4590859084908110610c2357fe5b906020019060200201516101000151846020015161178690919063ffffffff16565b60208401528351610c7d90859084908110610c5c57fe5b9060200190602002015160e00151826020015161178690919063ffffffff16565b81516000908152600760205260409020556001909101906109f8565b610ca38a846117cc565b610cae848b8a611968565b5050505060208181015191516000908152600790915260409020555050505050565b60035473ffffffffffffffffffffffffffffffffffffffff1690565b60035473ffffffffffffffffffffffffffffffffffffffff16331490565b73ffffffffffffffffffffffffffffffffffffffff1660009081526002602052604090205460ff161590565b805160408051808201909152600e81527f494e56414c49445f545241444552000000000000000000000000000000000000602082015260009173ffffffffffffffffffffffffffffffffffffffff163314610dbe576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104d69190612e60565b50610dc882611993565b60008181526008602052604080822080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001660011790555191925082917fe8d9861dbc9c663ed3accd261bbe2fe01e0d3d9e5f51fa38523b265c7757a93a9190a25050565b3360008181526002602052604080822080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00169055517fc3dd8edec722273de2ffd31b47b4f106689ae891ac1bfddf7ae6190589ab0f679190a2565b60405160200180807f454950373132446f6d61696e28737472696e67206e616d652c737472696e672081526020017f76657273696f6e2c6164647265737320766572696679696e67436f6e7472616381526020017f742900000000000000000000000000000000000000000000000000000000000081525060420190506040516020818303038152906040526040518082805190602001908083836020831061080857805182527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe090920191602091820191016107cb565b60045473ffffffffffffffffffffffffffffffffffffffff1681565b610f87610cec565b1515610fbf576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104d690612ed1565b73ffffffffffffffffffffffffffffffffffffffff8116151561100e576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104d690612ec1565b60035460405173ffffffffffffffffffffffffffffffffffffffff8084169216907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a3600380547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff92909216919091179055565b33600081815260016020908152604080832073ffffffffffffffffffffffffffffffffffffffff8616808552925280832080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00169055519092917fa6568d7ca1ae4c87043ca12f90308b8ef94330ee3a047c2101e1a40812d26c9891a350565b600480546000805183517f70a0823100000000000000000000000000000000000000000000000000000000835293859052909273ffffffffffffffffffffffffffffffffffffffff9092169160208460248180875af150600080519290526004529392505050565b6000808083116111c1576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104d690612e91565b82848115156111cc57fe5b0490508091505b5092915050565b6000806111ea84608001516119a6565b90506111fb846000015182856119da565b949350505050565b61120b612697565b611213612727565b600061121f8585611a13565b915061122a82611993565b80845260009081526007602090815260409091205490840152600290506112548260e00151611a87565b15801561126957508160800151836020015110155b156112785760035b90506112dc565b6112858260e00151611a87565b801561129957508160a00151836020015110155b156112a5576003611271565b6112b28260e00151611aa3565b42106112bf576000611271565b825160009081526008602052604090205460ff16156112dc575060015b60408051808201909152601581527f4f524445525f49535f4e4f545f46494c4c41424c450000000000000000000000602082015260ff821660021461134e576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104d69190612e60565b508251855160a0870151611363929190611acd565b60408051808201909152601781527f494e56414c49445f4f524445525f5349474e415455524500000000000000000060208201529015156113d1576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104d69190612e60565b50505092915050565b60008160025b1a7f01000000000000000000000000000000000000000000000000000000000000009081027fff00000000000000000000000000000000000000000000000000000000000000161492915050565b60008160016113e0565b60008061145683602001518560400151611ce990919063ffffffff16565b915061147383604001518560200151611ce990919063ffffffff16565b9050611482846080015161142e565b61148f5780821015611494565b808211155b60408051808201909152600d81527f494e56414c49445f4d41544348000000000000000000000000000000000000006020820152901515611502576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104d69190612e60565b5050505050565b6115116126ae565b60008060008060006115268c60800151611a87565b15156115865761156861154a8c602001518e60200151611d4490919063ffffffff16565b6020808c0151908d01516115639163ffffffff611d4416565b611d88565b94506115748a86611d9e565b61010087015260e086018590526115e2565b6115c86115a48c602001518e60400151611d4490919063ffffffff16565b6115638c6115c38d602001518f60200151611d4490919063ffffffff16565b611d9e565b94506115d48a86611db3565b60e087015261010086018590525b60208b015115156115f85760608c015160c08701525b6020890151151561160e5760608a015160a08701525b60208b0151611623908663ffffffff61178616565b6020808d01919091528a5173ffffffffffffffffffffffffffffffffffffffff90811688528d51169087015260808a015161165d90611dc8565b935061166c8a60800151611dfe565b9250828411156116ec576116a061169a606461168e878763ffffffff611d4416565b9063ffffffff611ce916565b89611d88565b91506116db6116b9620186a0606463ffffffff611ce916565b6101008801516116cf908563ffffffff611ce916565b9063ffffffff61118516565b606087015260006040870152611744565b895161170890611702858763ffffffff611d4416565b896119da565b9050611737611721620186a0606463ffffffff611ce916565b6101008801516116cf908463ffffffff611ce916565b6040870152600060608701525b61177161175b620186a0606463ffffffff611ce916565b6101008801516116cf908b63ffffffff611ce916565b608087015250939a9950505050505050505050565b6000828201838110156117c5576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104d690612ee1565b9392505050565b6117d9826080015161142e565b1561185b57602080830151825160408051808201909152601881527f54414b45525f53454c4c5f424153455f45584345454445440000000000000000938101939093521115611855576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104d69190612e60565b50611964565b8160400151816020015111156040805190810160405280601f81526020017f54414b45525f4d41524b45545f4255595f51554f54455f4558434545444544008152509015156118d7576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104d69190612e60565b506118e582608001516113da565b151561196457602080830151825160408051808201909152601d81527f54414b45525f4c494d49545f4255595f424153455f4558434545444544000000938101939093521115611962576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104d69190612e60565b505b5050565b611975826080015161142e565b15611989576119848382611e30565b611962565b6119628382612047565b600061060d6119a18361223d565b612333565b7e010000000000000000000000000000000000000000000000000000000000006a0100000000000000000000820204919050565b60008115611a02576119fb6119ee85610613565b849063ffffffff611ce916565b90506117c5565b6119fb83606463ffffffff611ce916565b611a1b612727565b825173ffffffffffffffffffffffffffffffffffffffff908116825260208085015160808085019190915260408087015160a086015260608088015160c0870152919096015160e085015284518316868501528482015183169084015292909301519092169082015290565b6000611a928261142e565b15801561060d575061060d826113da565b7b010000000000000000000000000000000000000000000000000000006301000000820204919050565b80516000907f0100000000000000000000000000000000000000000000000000000000000000600182901a810281900491839190821a81020460ff83161515611c4557604080517f19457468657265756d205369676e6564204d6573736167653a0a333200000000602080830191909152603c8083018b905283518084039091018152605c909201928390528151600193918291908401908083835b60208310611ba657805182527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe09092019160209182019101611b69565b51815160209384036101000a7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0180199092169116179052604080519290940182900382208c8201518d860151600085529390920194859052611c10965094508793909250612e22565b60206040516020810390808403906000865af1158015611c34573d6000803e3d6000fd5b505050602060405103519150611cae565b60ff831660011415611c7c57600187828760200151886040015160405160008152602001604052604051611c109493929190612e22565b6040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104d690612e81565b8173ffffffffffffffffffffffffffffffffffffffff168673ffffffffffffffffffffffffffffffffffffffff161493505050509392505050565b600080831515611cfc57600091506111d3565b50828202828482811515611d0c57fe5b04146117c5576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104d690612ef1565b60008083831115611d81576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104d690612eb1565b5050900390565b6000818310611d9757816117c5565b5090919050565b60006117c58360400151846020015184612423565b60006117c58360200151846040015184612423565b7e010000000000000000000000000000000000000000000000000000000000006c01000000000000000000000000820204919050565b7e0100000000000000000000000000000000000000000000000000000000000068010000000000000000820204919050565b6000805b8351811015611fea57611e9b83600001518583815181101515611e5357fe5b90602001906020020151602001518684815181101515611e6f57fe5b60209081029091010151518751889086908110611e8857fe5b9060200190602002015160e0015161247b565b611f6783602001518583815181101515611eb157fe5b90602001906020020151600001518560400151611f628886815181101515611ed557fe5b9060200190602002015160600151611f568a88815181101515611ef457fe5b9060200190602002015160a00151611f4a8c8a815181101515611f1357fe5b90602001906020020151604001518d8b815181101515611f2f57fe5b6020908102909101015161010001519063ffffffff61178616565b9063ffffffff61178616565b9063ffffffff611d4416565b61247b565b611fbf611fb28583815181101515611f7b57fe5b90602001906020020151608001518684815181101515611f9757fe5b6020908102909101015161010001519063ffffffff611d4416565b839063ffffffff61178616565b9150611fe28482815181101515611fd257fe5b906020019060200201518461258b565b600101611e34565b6120418360200151846040015186600081518110151561200657fe5b9060200190602002015160200151611f6288600081518110151561202657fe5b6020908102909101015160c00151879063ffffffff611d4416565b50505050565b6000805b835181101561220d5761209f8360000151858381518110151561206a57fe5b6020908102909101015151865187908590811061208357fe5b90602001906020020151602001518785815181101515611e8857fe5b61214a836020015185838151811015156120b557fe5b906020019060200201516020015186848151811015156120d157fe5b9060200190602002015160000151611f6288868151811015156120f057fe5b9060200190602002015160600151611f4a8a8881518110151561210f57fe5b9060200190602002015160a00151611f568c8a81518110151561212e57fe5b90602001906020020151604001518d8b815181101515611f9757fe5b6121f2848281518110151561215b57fe5b9060200190602002015160600151611f56868481518110151561217a57fe5b9060200190602002015160c00151611f4a888681518110151561219957fe5b9060200190602002015160a00151611f4a8a888151811015156121b857fe5b9060200190602002015160400151611f4a8c8a8151811015156121d757fe5b60209081029091010151608001518b9063ffffffff61178616565b91506122058482815181101515611fd257fe5b60010161204b565b612041836020015185600081518110151561222457fe5b906020019060200201516020015185604001518561247b565b6000806040516020018080612fd9609f9139609f0190506040516020818303038152906040526040518082805190602001908083835b602083106122b057805182527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe09092019160209182019101612273565b5181516020939093036101000a7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff018019909116921691909117905260405192018290039091207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe096909601805196815261012081209690525093949350505050565b60008054604080517f19010000000000000000000000000000000000000000000000000000000000006020808301919091526022820193909352604280820186905282518083039091018152606290910191829052805190928291908401908083835b602083106123d357805182527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe09092019160209182019101612396565b5181516020939093036101000a7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0180199091169216919091179052604051920182900390912095945050505050565b6000612430848484612607565b15612467576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104d690612ea1565b6111fb836116cf868563ffffffff611ce916565b60008082151561248a57612583565b600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1691506000516004516024516044516064517f15dacbea000000000000000000000000000000000000000000000000000000006000528a60045289602452886044528760645260008060846000808b5af1600095909552600493909352602491909152604452606452905080151561258357604080518082018252601481527f5452414e534645525f46524f4d5f4641494c4544000000000000000000000000602082015290517f08c379a00000000000000000000000000000000000000000000000000000000081526104d69190600401612e60565b505050505050565b805160208083015160408085015186519387015160e08801516101008901518985015160808b015160a08c015160608d015160c08e015198517fdcc6682c66bde605a9e21caeb0cb8f1f6fbd5bbfb2250c3b8d1f43bb9b06df3f9c6125fb9c909b9a909897969594939291612d53565b60405180910390a15050565b6000612619848363ffffffff611ce916565b61263f6103e861168e86612633898863ffffffff611ce916565b9063ffffffff61264916565b1015949350505050565b6000811515612684576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104d690612f01565b818381151561268f57fe5b069392505050565b604080518082019091526000808252602082015290565b61012060405190810160405280600073ffffffffffffffffffffffffffffffffffffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff168152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b6040805161010081018252600080825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e081019190915290565b60006117c58235612f5d565b6000601f8201831361278857600080fd5b813561279b61279682612f38565b612f11565b91508181835260208401935060208101905083856101008402820111156127c157600080fd5b60005b838110156127f057816127d78882612861565b84525060209092019161010091909101906001016127c4565b5050505092915050565b60006117c58235612f7b565b60006060828403121561281857600080fd5b6128226060612f11565b90506000612830848461276b565b82525060206128418484830161276b565b60208301525060406128558482850161276b565b60408301525092915050565b6000610100828403121561287457600080fd5b61287e60c0612f11565b9050600061288c848461276b565b825250602061289d848483016127fa565b60208301525060406128b1848285016127fa565b60408301525060606128c5848285016127fa565b60608301525060806128d9848285016127fa565b60808301525060a06128ed848285016128f9565b60a08301525092915050565b60006060828403121561290b57600080fd5b6129156060612f11565b9050600061292384846127fa565b8252506020612934848483016127fa565b6020830152506040612855848285016127fa565b6000610100828403121561295b57600080fd5b612966610100612f11565b90506000612974848461276b565b82525060206129858484830161276b565b60208301525060406129998482850161276b565b60408301525060606129ad8482850161276b565b60608301525060806129c1848285016127fa565b60808301525060a06129d5848285016127fa565b60a08301525060c06129e9848285016127fa565b60c08301525060e06129fd848285016127fa565b60e08301525092915050565b600060208284031215612a1b57600080fd5b60006111fb848461276b565b60008060408385031215612a3a57600080fd5b6000612a46858561276b565b9250506020612a578582860161276b565b9150509250929050565b600060208284031215612a7357600080fd5b60006111fb84846127fa565b60008060006101808486031215612a9557600080fd5b6000612aa18686612861565b93505061010084013567ffffffffffffffff811115612abf57600080fd5b612acb86828701612777565b925050610120612add86828701612806565b9150509250925092565b60006101008284031215612afa57600080fd5b60006111fb8484612948565b612b0f81612f5d565b82525050565b612b0f81612f76565b612b0f81612f7b565b6000612b3282612f59565b808452612b46816020860160208601612f84565b612b4f81612fb0565b9093016020019392505050565b600e81527f444953434f554e545f4552524f52000000000000000000000000000000000000602082015260400190565b601381527f494e56414c49445f5349474e5f4d4554484f4400000000000000000000000000602082015260400190565b600e81527f4449564944494e475f4552524f52000000000000000000000000000000000000602082015260400190565b600e81527f524f554e44494e475f4552524f52000000000000000000000000000000000000602082015260400190565b600981527f5355425f4552524f520000000000000000000000000000000000000000000000602082015260400190565b600d81527f494e56414c49445f4f574e455200000000000000000000000000000000000000602082015260400190565b600981527f4e4f545f4f574e45520000000000000000000000000000000000000000000000602082015260400190565b600981527f4144445f4552524f520000000000000000000000000000000000000000000000602082015260400190565b600981527f4d554c5f4552524f520000000000000000000000000000000000000000000000602082015260400190565b600981527f4d4f445f4552524f520000000000000000000000000000000000000000000000602082015260400190565b612b0f81612f7e565b6020810161060d8284612b06565b6101808101612d62828f612b06565b612d6f602083018e612b06565b612d7c604083018d612b06565b612d89606083018c612b06565b612d96608083018b612b06565b612da360a083018a612b1e565b612db060c0830189612b1e565b612dbd60e0830188612b1e565b612dcb610100830187612b1e565b612dd9610120830186612b1e565b612de7610140830185612b1e565b612df5610160830184612b1e565b9d9c50505050505050505050505050565b6020810161060d8284612b15565b6020810161060d8284612b1e565b60808101612e308287612b1e565b612e3d6020830186612d3c565b612e4a6040830185612b1e565b612e576060830184612b1e565b95945050505050565b602080825281016117c58184612b27565b6020808252810161060d81612b5c565b6020808252810161060d81612b8c565b6020808252810161060d81612bbc565b6020808252810161060d81612bec565b6020808252810161060d81612c1c565b6020808252810161060d81612c4c565b6020808252810161060d81612c7c565b6020808252810161060d81612cac565b6020808252810161060d81612cdc565b6020808252810161060d81612d0c565b60405181810167ffffffffffffffff81118282101715612f3057600080fd5b604052919050565b600067ffffffffffffffff821115612f4f57600080fd5b5060209081020190565b5190565b73ffffffffffffffffffffffffffffffffffffffff1690565b151590565b90565b60ff1690565b60005b83811015612f9f578181015183820152602001612f87565b838111156120415750506000910152565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169056004f726465722861646472657373207472616465722c616464726573732072656c617965722c616464726573732062617365546f6b656e2c616464726573732071756f7465546f6b656e2c75696e743235362062617365546f6b656e416d6f756e742c75696e743235362071756f7465546f6b656e416d6f756e742c75696e7432353620676173546f6b656e416d6f756e742c62797465733332206461746129a265627a7a723058201e0aec110d55e4485b21af254e011a7ac22297f6396db3a7e903c5c863798b136c6578706572696d656e74616cf5003700000000000000000000000074622073a4821dbfd046e9aa2ccf691341a076e10000000000000000000000009af839687f6c94542ac5ece2e317daae355493a1",
  "constructorArguments": "00000000000000000000000074622073a4821dbfd046e9aa2ccf691341a076e10000000000000000000000009af839687f6c94542ac5ece2e317daae355493a1"
}