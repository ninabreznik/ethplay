{
  "address": "0x679f601f0deb53c2db0c8c26369fdcba5fd753cf",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "SmartToken",
  "compilerVersion": "v0.4.18+commit.9cf6e910",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2018-02-22\n*/\n\npragma solidity ^0.4.18;\n\n\n/*\n    Bancor Converter Extensions interface\n*/\ncontract IBancorConverterExtensions {\n    function formula() public view returns (IBancorFormula) {}\n    function gasPriceLimit() public view returns (IBancorGasPriceLimit) {}\n    function quickConverter() public view returns (IBancorQuickConverter) {}\n}\n\n\ncontract IBancorFormula {\n    function calculatePurchaseReturn(uint256 _supply, uint256 _connectorBalance, uint32 _connectorWeight, uint256 _depositAmount) public view returns (uint256);\n    function calculateSaleReturn(uint256 _supply, uint256 _connectorBalance, uint32 _connectorWeight, uint256 _sellAmount) public view returns (uint256);\n}\n\n\ncontract IBancorGasPriceLimit {\n    function gasPrice() public view returns (uint256) {}\n}\n\n\ncontract IBancorQuickConverter {\n    function convert(IERC20Token[] _path, uint256 _amount, uint256 _minReturn) public payable returns (uint256);\n    function convertFor(IERC20Token[] _path, uint256 _amount, uint256 _minReturn, address _for) public payable returns (uint256);\n}\n\n\ncontract IERC20Token {\n    // these functions aren't abstract since the compiler emits automatically generated getter functions as external\n    function name() public view returns (string) {}\n    function symbol() public view returns (string) {}\n    function decimals() public view returns (uint8) {}\n    function totalSupply() public view returns (uint256) {}\n    function balanceOf(address _owner) public view returns (uint256) { _owner; }\n    function allowance(address _owner, address _spender) public view returns (uint256) { _owner; _spender; }\n\n    function transfer(address _to, uint256 _value) public returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n    function approve(address _spender, uint256 _value) public returns (bool success);\n}\n\n\ncontract IOwned {\n    // this function isn't abstract since the compiler emits automatically generated getter functions as external\n    function owner() public view returns (address) {}\n\n    function transferOwnership(address _newOwner) public;\n    function acceptOwnership() public;\n}\n\n\ncontract ITokenHolder is IOwned {\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) public;\n}\n\n\ncontract IEtherToken is ITokenHolder, IERC20Token {\n    function deposit() public payable;\n    function withdraw(uint256 _amount) public;\n    function withdrawTo(address _to, uint256 _amount) public;\n}\n\n\n\ncontract ISmartToken is IOwned, IERC20Token {\n    function disableTransfers(bool _disable) public;\n    function issue(address _to, uint256 _amount) public;\n    function destroy(address _from, uint256 _amount) public;\n}\n\n\ncontract ITokenConverter {\n    function convertibleTokenCount() public view returns (uint16);\n    function convertibleToken(uint16 _tokenIndex) public view returns (address);\n    function getReturn(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount) public view returns (uint256);\n    function convert(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256);\n    // deprecated, backward compatibility\n    function change(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256);\n}\n\n\ncontract Owned is IOwned {\n    address public owner;\n    address public newOwner;\n\n    event OwnerUpdate(address indexed _prevOwner, address indexed _newOwner);\n\n    /**\n        @dev constructor\n    */\n    function Owned() public {\n        owner = msg.sender;\n    }\n\n    // allows execution by the owner only\n    modifier ownerOnly {\n        assert(msg.sender == owner);\n        _;\n    }\n\n    /**\n        @dev allows transferring the contract ownership\n        the new owner still needs to accept the transfer\n        can only be called by the contract owner\n\n        @param _newOwner    new contract owner\n    */\n    function transferOwnership(address _newOwner) public ownerOnly {\n        require(_newOwner != owner);\n        newOwner = _newOwner;\n    }\n\n    /**\n        @dev used by a new owner to accept an ownership transfer\n    */\n    function acceptOwnership() public {\n        require(msg.sender == newOwner);\n        OwnerUpdate(owner, newOwner);\n        owner = newOwner;\n        newOwner = address(0);\n    }\n}\n\n\n\ncontract Utils {\n    /**\n        constructor\n    */\n    function Utils() public {\n    }\n\n    // verifies that an amount is greater than zero\n    modifier greaterThanZero(uint256 _amount) {\n        require(_amount > 0);\n        _;\n    }\n\n    // validates an address - currently only checks that it isn't null\n    modifier validAddress(address _address) {\n        require(_address != address(0));\n        _;\n    }\n\n    // verifies that the address is different than this contract address\n    modifier notThis(address _address) {\n        require(_address != address(this));\n        _;\n    }\n\n    // Overflow protected math functions\n\n    /**\n        @dev returns the sum of _x and _y, asserts if the calculation overflows\n\n        @param _x   value 1\n        @param _y   value 2\n\n        @return sum\n    */\n    function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) {\n        uint256 z = _x + _y;\n        assert(z >= _x);\n        return z;\n    }\n\n    /**\n        @dev returns the difference of _x minus _y, asserts if the subtraction results in a negative number\n\n        @param _x   minuend\n        @param _y   subtrahend\n\n        @return difference\n    */\n    function safeSub(uint256 _x, uint256 _y) internal pure returns (uint256) {\n        assert(_x >= _y);\n        return _x - _y;\n    }\n\n    /**\n        @dev returns the product of multiplying _x by _y, asserts if the calculation overflows\n\n        @param _x   factor 1\n        @param _y   factor 2\n\n        @return product\n    */\n    function safeMul(uint256 _x, uint256 _y) internal pure returns (uint256) {\n        uint256 z = _x * _y;\n        assert(_x == 0 || z / _x == _y);\n        return z;\n    }\n}\n\n\ncontract TokenHolder is ITokenHolder, Owned, Utils {\n    /**\n        @dev constructor\n    */\n    function TokenHolder() public {\n    }\n\n    /**\n        @dev withdraws tokens held by the contract and sends them to an account\n        can only be called by the owner\n\n        @param _token   ERC20 token contract address\n        @param _to      account to receive the new amount\n        @param _amount  amount to withdraw\n    */\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount)\n        public\n        ownerOnly\n        validAddress(_token)\n        validAddress(_to)\n        notThis(_to)\n    {\n        assert(_token.transfer(_to, _amount));\n    }\n}\n\n\ncontract SmartTokenController is TokenHolder {\n    ISmartToken public token;   // smart token\n\n    /**\n        @dev constructor\n    */\n    function SmartTokenController(ISmartToken _token)\n        public\n        validAddress(_token)\n    {\n        token = _token;\n    }\n\n    // ensures that the controller is the token's owner\n    modifier active() {\n        assert(token.owner() == address(this));\n        _;\n    }\n\n    // ensures that the controller is not the token's owner\n    modifier inactive() {\n        assert(token.owner() != address(this));\n        _;\n    }\n\n    /**\n        @dev allows transferring the token ownership\n        the new owner still need to accept the transfer\n        can only be called by the contract owner\n\n        @param _newOwner    new token owner\n    */\n    function transferTokenOwnership(address _newOwner) public ownerOnly {\n        token.transferOwnership(_newOwner);\n    }\n\n    /**\n        @dev used by a new owner to accept a token ownership transfer\n        can only be called by the contract owner\n    */\n    function acceptTokenOwnership() public ownerOnly {\n        token.acceptOwnership();\n    }\n\n    /**\n        @dev disables/enables token transfers\n        can only be called by the contract owner\n\n        @param _disable    true to disable transfers, false to enable them\n    */\n    function disableTokenTransfers(bool _disable) public ownerOnly {\n        token.disableTransfers(_disable);\n    }\n\n    /**\n        @dev withdraws tokens held by the controller and sends them to an account\n        can only be called by the owner\n\n        @param _token   ERC20 token contract address\n        @param _to      account to receive the new amount\n        @param _amount  amount to withdraw\n    */\n    function withdrawFromToken(\n        IERC20Token _token, \n        address _to, \n        uint256 _amount\n    ) \n        public\n        ownerOnly\n    {\n        ITokenHolder(token).withdrawTokens(_token, _to, _amount);\n    }\n}\n\ncontract Managed {\n    address public manager;\n    address public newManager;\n\n    event ManagerUpdate(address indexed _prevManager, address indexed _newManager);\n\n    /**\n        @dev constructor\n    */\n    function Managed() public {\n        manager = msg.sender;\n    }\n\n    // allows execution by the manager only\n    modifier managerOnly {\n        assert(msg.sender == manager);\n        _;\n    }\n\n    /**\n        @dev allows transferring the contract management\n        the new manager still needs to accept the transfer\n        can only be called by the contract manager\n\n        @param _newManager    new contract manager\n    */\n    function transferManagement(address _newManager) public managerOnly {\n        require(_newManager != manager);\n        newManager = _newManager;\n    }\n\n    /**\n        @dev used by a new manager to accept a management transfer\n    */\n    function acceptManagement() public {\n        require(msg.sender == newManager);\n        ManagerUpdate(manager, newManager);\n        manager = newManager;\n        newManager = address(0);\n    }\n}\n\n\ncontract BancorConverter is ITokenConverter, SmartTokenController, Managed {\n    uint32 private constant MAX_WEIGHT = 1000000;\n    uint32 private constant MAX_CONVERSION_FEE = 1000000;\n\n    struct Connector {\n        uint256 virtualBalance;         // connector virtual balance\n        uint32 weight;                  // connector weight, represented in ppm, 1-1000000\n        bool isVirtualBalanceEnabled;   // true if virtual balance is enabled, false if not\n        bool isPurchaseEnabled;         // is purchase of the smart token enabled with the connector, can be set by the owner\n        bool isSet;                     // used to tell if the mapping element is defined\n    }\n\n    string public version = '0.7';\n    string public converterType = 'bancor';\n\n    IBancorConverterExtensions public extensions;       // bancor converter extensions contract\n    IERC20Token[] public connectorTokens;               // ERC20 standard token addresses\n    IERC20Token[] public quickBuyPath;                  // conversion path that's used in order to buy the token with ETH\n    mapping (address => Connector) public connectors;   // connector token addresses -> connector data\n    uint32 private totalConnectorWeight = 0;            // used to efficiently prevent increasing the total connector weight above 100%\n    uint32 public maxConversionFee = 0;                 // maximum conversion fee for the lifetime of the contract, represented in ppm, 0...1000000 (0 = no fee, 100 = 0.01%, 1000000 = 100%)\n    uint32 public conversionFee = 0;                    // current conversion fee, represented in ppm, 0...maxConversionFee\n    bool public conversionsEnabled = true;              // true if token conversions is enabled, false if not\n\n    // triggered when a conversion between two tokens occurs (TokenConverter event)\n    event Conversion(address indexed _fromToken, address indexed _toToken, address indexed _trader, uint256 _amount, uint256 _return,\n                     int256 _conversionFee, uint256 _currentPriceN, uint256 _currentPriceD);\n    // triggered when the conversion fee is updated\n    event ConversionFeeUpdate(uint32 _prevFee, uint32 _newFee);\n\n    /**\n        @dev constructor\n\n        @param  _token              smart token governed by the converter\n        @param  _extensions         address of a bancor converter extensions contract\n        @param  _maxConversionFee   maximum conversion fee, represented in ppm\n        @param  _connectorToken     optional, initial connector, allows defining the first connector at deployment time\n        @param  _connectorWeight    optional, weight for the initial connector\n    */\n    function BancorConverter(ISmartToken _token, IBancorConverterExtensions _extensions, uint32 _maxConversionFee, IERC20Token _connectorToken, uint32 _connectorWeight)\n        public\n        SmartTokenController(_token)\n        validAddress(_extensions)\n        validMaxConversionFee(_maxConversionFee)\n    {\n        extensions = _extensions;\n        maxConversionFee = _maxConversionFee;\n\n        if (_connectorToken != address(0))\n            addConnector(_connectorToken, _connectorWeight, false);\n    }\n\n    // validates a connector token address - verifies that the address belongs to one of the connector tokens\n    modifier validConnector(IERC20Token _address) {\n        require(connectors[_address].isSet);\n        _;\n    }\n\n    // validates a token address - verifies that the address belongs to one of the convertible tokens\n    modifier validToken(IERC20Token _address) {\n        require(_address == token || connectors[_address].isSet);\n        _;\n    }\n\n    // verifies that the gas price is lower than the universal limit\n    modifier validGasPrice() {\n        assert(tx.gasprice <= extensions.gasPriceLimit().gasPrice());\n        _;\n    }\n\n    // validates maximum conversion fee\n    modifier validMaxConversionFee(uint32 _conversionFee) {\n        require(_conversionFee >= 0 && _conversionFee <= MAX_CONVERSION_FEE);\n        _;\n    }\n\n    // validates conversion fee\n    modifier validConversionFee(uint32 _conversionFee) {\n        require(_conversionFee >= 0 && _conversionFee <= maxConversionFee);\n        _;\n    }\n\n    // validates connector weight range\n    modifier validConnectorWeight(uint32 _weight) {\n        require(_weight > 0 && _weight <= MAX_WEIGHT);\n        _;\n    }\n\n    // validates a conversion path - verifies that the number of elements is odd and that maximum number of 'hops' is 10\n    modifier validConversionPath(IERC20Token[] _path) {\n        require(_path.length > 2 && _path.length <= (1 + 2 * 10) && _path.length % 2 == 1);\n        _;\n    }\n\n    // allows execution only when conversions aren't disabled\n    modifier conversionsAllowed {\n        assert(conversionsEnabled);\n        _;\n    }\n\n    // allows execution only for owner or manager\n    modifier ownerOrManagerOnly {\n        require(msg.sender == owner || msg.sender == manager);\n        _;\n    }\n\n    /**\n        @dev returns the number of connector tokens defined\n\n        @return number of connector tokens\n    */\n    function connectorTokenCount() public view returns (uint16) {\n        return uint16(connectorTokens.length);\n    }\n\n    /**\n        @dev returns the number of convertible tokens supported by the contract\n        note that the number of convertible tokens is the number of connector token, plus 1 (that represents the smart token)\n\n        @return number of convertible tokens\n    */\n    function convertibleTokenCount() public view returns (uint16) {\n        return connectorTokenCount() + 1;\n    }\n\n    /**\n        @dev given a convertible token index, returns its contract address\n\n        @param _tokenIndex  convertible token index\n\n        @return convertible token address\n    */\n    function convertibleToken(uint16 _tokenIndex) public view returns (address) {\n        if (_tokenIndex == 0)\n            return token;\n        return connectorTokens[_tokenIndex - 1];\n    }\n\n    /*\n        @dev allows the owner to update the extensions contract address\n\n        @param _extensions    address of a bancor converter extensions contract\n    */\n    function setExtensions(IBancorConverterExtensions _extensions)\n        public\n        ownerOnly\n        validAddress(_extensions)\n        notThis(_extensions)\n    {\n        extensions = _extensions;\n    }\n\n    /*\n        @dev allows the manager to update the quick buy path\n\n        @param _path    new quick buy path, see conversion path format in the BancorQuickConverter contract\n    */\n    function setQuickBuyPath(IERC20Token[] _path)\n        public\n        ownerOnly\n        validConversionPath(_path)\n    {\n        quickBuyPath = _path;\n    }\n\n    /*\n        @dev allows the manager to clear the quick buy path\n    */\n    function clearQuickBuyPath() public ownerOnly {\n        quickBuyPath.length = 0;\n    }\n\n    /**\n        @dev returns the length of the quick buy path array\n\n        @return quick buy path length\n    */\n    function getQuickBuyPathLength() public view returns (uint256) {\n        return quickBuyPath.length;\n    }\n\n    /**\n        @dev disables the entire conversion functionality\n        this is a safety mechanism in case of a emergency\n        can only be called by the manager\n\n        @param _disable true to disable conversions, false to re-enable them\n    */\n    function disableConversions(bool _disable) public ownerOrManagerOnly {\n        conversionsEnabled = !_disable;\n    }\n\n    /**\n        @dev updates the current conversion fee\n        can only be called by the manager\n\n        @param _conversionFee new conversion fee, represented in ppm\n    */\n    function setConversionFee(uint32 _conversionFee)\n        public\n        ownerOrManagerOnly\n        validConversionFee(_conversionFee)\n    {\n        ConversionFeeUpdate(conversionFee, _conversionFee);\n        conversionFee = _conversionFee;\n    }\n\n    /*\n        @dev returns the conversion fee amount for a given return amount\n\n        @return conversion fee amount\n    */\n    function getConversionFeeAmount(uint256 _amount) public view returns (uint256) {\n        return safeMul(_amount, conversionFee) / MAX_CONVERSION_FEE;\n    }\n\n    /**\n        @dev defines a new connector for the token\n        can only be called by the owner while the converter is inactive\n\n        @param _token                  address of the connector token\n        @param _weight                 constant connector weight, represented in ppm, 1-1000000\n        @param _enableVirtualBalance   true to enable virtual balance for the connector, false to disable it\n    */\n    function addConnector(IERC20Token _token, uint32 _weight, bool _enableVirtualBalance)\n        public\n        ownerOnly\n        inactive\n        validAddress(_token)\n        notThis(_token)\n        validConnectorWeight(_weight)\n    {\n        require(_token != token && !connectors[_token].isSet && totalConnectorWeight + _weight <= MAX_WEIGHT); // validate input\n\n        connectors[_token].virtualBalance = 0;\n        connectors[_token].weight = _weight;\n        connectors[_token].isVirtualBalanceEnabled = _enableVirtualBalance;\n        connectors[_token].isPurchaseEnabled = true;\n        connectors[_token].isSet = true;\n        connectorTokens.push(_token);\n        totalConnectorWeight += _weight;\n    }\n\n    /**\n        @dev updates one of the token connectors\n        can only be called by the owner\n\n        @param _connectorToken         address of the connector token\n        @param _weight                 constant connector weight, represented in ppm, 1-1000000\n        @param _enableVirtualBalance   true to enable virtual balance for the connector, false to disable it\n        @param _virtualBalance         new connector's virtual balance\n    */\n    function updateConnector(IERC20Token _connectorToken, uint32 _weight, bool _enableVirtualBalance, uint256 _virtualBalance)\n        public\n        ownerOnly\n        validConnector(_connectorToken)\n        validConnectorWeight(_weight)\n    {\n        Connector storage connector = connectors[_connectorToken];\n        require(totalConnectorWeight - connector.weight + _weight <= MAX_WEIGHT); // validate input\n\n        totalConnectorWeight = totalConnectorWeight - connector.weight + _weight;\n        connector.weight = _weight;\n        connector.isVirtualBalanceEnabled = _enableVirtualBalance;\n        connector.virtualBalance = _virtualBalance;\n    }\n\n    /**\n        @dev disables purchasing with the given connector token in case the connector token got compromised\n        can only be called by the owner\n        note that selling is still enabled regardless of this flag and it cannot be disabled by the owner\n\n        @param _connectorToken  connector token contract address\n        @param _disable         true to disable the token, false to re-enable it\n    */\n    function disableConnectorPurchases(IERC20Token _connectorToken, bool _disable)\n        public\n        ownerOnly\n        validConnector(_connectorToken)\n    {\n        connectors[_connectorToken].isPurchaseEnabled = !_disable;\n    }\n\n    /**\n        @dev returns the connector's virtual balance if one is defined, otherwise returns the actual balance\n\n        @param _connectorToken  connector token contract address\n\n        @return connector balance\n    */\n    function getConnectorBalance(IERC20Token _connectorToken)\n        public\n        view\n        validConnector(_connectorToken)\n        returns (uint256)\n    {\n        Connector storage connector = connectors[_connectorToken];\n        return connector.isVirtualBalanceEnabled ? connector.virtualBalance : _connectorToken.balanceOf(this);\n    }\n\n    /**\n        @dev returns the expected return for converting a specific amount of _fromToken to _toToken\n\n        @param _fromToken  ERC20 token to convert from\n        @param _toToken    ERC20 token to convert to\n        @param _amount     amount to convert, in fromToken\n\n        @return expected conversion return amount\n    */\n    function getReturn(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount) public view returns (uint256) {\n        require(_fromToken != _toToken); // validate input\n\n        // conversion between the token and one of its connectors\n        if (_toToken == token)\n            return getPurchaseReturn(_fromToken, _amount);\n        else if (_fromToken == token)\n            return getSaleReturn(_toToken, _amount);\n\n        // conversion between 2 connectors\n        uint256 purchaseReturnAmount = getPurchaseReturn(_fromToken, _amount);\n        return getSaleReturn(_toToken, purchaseReturnAmount, safeAdd(token.totalSupply(), purchaseReturnAmount));\n    }\n\n    /**\n        @dev returns the expected return for buying the token for a connector token\n\n        @param _connectorToken  connector token contract address\n        @param _depositAmount   amount to deposit (in the connector token)\n\n        @return expected purchase return amount\n    */\n    function getPurchaseReturn(IERC20Token _connectorToken, uint256 _depositAmount)\n        public\n        view\n        active\n        validConnector(_connectorToken)\n        returns (uint256)\n    {\n        Connector storage connector = connectors[_connectorToken];\n        require(connector.isPurchaseEnabled); // validate input\n\n        uint256 tokenSupply = token.totalSupply();\n        uint256 connectorBalance = getConnectorBalance(_connectorToken);\n        uint256 amount = extensions.formula().calculatePurchaseReturn(tokenSupply, connectorBalance, connector.weight, _depositAmount);\n\n        // deduct the fee from the return amount\n        uint256 feeAmount = getConversionFeeAmount(amount);\n        return safeSub(amount, feeAmount);\n    }\n\n    /**\n        @dev returns the expected return for selling the token for one of its connector tokens\n\n        @param _connectorToken  connector token contract address\n        @param _sellAmount      amount to sell (in the smart token)\n\n        @return expected sale return amount\n    */\n    function getSaleReturn(IERC20Token _connectorToken, uint256 _sellAmount) public view returns (uint256) {\n        return getSaleReturn(_connectorToken, _sellAmount, token.totalSupply());\n    }\n\n    /**\n        @dev converts a specific amount of _fromToken to _toToken\n\n        @param _fromToken  ERC20 token to convert from\n        @param _toToken    ERC20 token to convert to\n        @param _amount     amount to convert, in fromToken\n        @param _minReturn  if the conversion results in an amount smaller than the minimum return - it is cancelled, must be nonzero\n\n        @return conversion return amount\n    */\n    function convert(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256) {\n        require(_fromToken != _toToken); // validate input\n\n        // conversion between the token and one of its connectors\n        if (_toToken == token)\n            return buy(_fromToken, _amount, _minReturn);\n        else if (_fromToken == token)\n            return sell(_toToken, _amount, _minReturn);\n\n        // conversion between 2 connectors\n        uint256 purchaseAmount = buy(_fromToken, _amount, 1);\n        return sell(_toToken, purchaseAmount, _minReturn);\n    }\n\n    /**\n        @dev buys the token by depositing one of its connector tokens\n\n        @param _connectorToken  connector token contract address\n        @param _depositAmount   amount to deposit (in the connector token)\n        @param _minReturn       if the conversion results in an amount smaller than the minimum return - it is cancelled, must be nonzero\n\n        @return buy return amount\n    */\n    function buy(IERC20Token _connectorToken, uint256 _depositAmount, uint256 _minReturn)\n        public\n        conversionsAllowed\n        validGasPrice\n        greaterThanZero(_minReturn)\n        returns (uint256)\n    {\n        uint256 amount = getPurchaseReturn(_connectorToken, _depositAmount);\n        require(amount != 0 && amount >= _minReturn); // ensure the trade gives something in return and meets the minimum requested amount\n\n        // update virtual balance if relevant\n        Connector storage connector = connectors[_connectorToken];\n        if (connector.isVirtualBalanceEnabled)\n            connector.virtualBalance = safeAdd(connector.virtualBalance, _depositAmount);\n\n        // transfer _depositAmount funds from the caller in the connector token\n        assert(_connectorToken.transferFrom(msg.sender, this, _depositAmount));\n        // issue new funds to the caller in the smart token\n        token.issue(msg.sender, amount);\n\n        dispatchConversionEvent(_connectorToken, _depositAmount, amount, true);\n        return amount;\n    }\n\n    /**\n        @dev sells the token by withdrawing from one of its connector tokens\n\n        @param _connectorToken  connector token contract address\n        @param _sellAmount      amount to sell (in the smart token)\n        @param _minReturn       if the conversion results in an amount smaller the minimum return - it is cancelled, must be nonzero\n\n        @return sell return amount\n    */\n    function sell(IERC20Token _connectorToken, uint256 _sellAmount, uint256 _minReturn)\n        public\n        conversionsAllowed\n        validGasPrice\n        greaterThanZero(_minReturn)\n        returns (uint256)\n    {\n        require(_sellAmount <= token.balanceOf(msg.sender)); // validate input\n\n        uint256 amount = getSaleReturn(_connectorToken, _sellAmount);\n        require(amount != 0 && amount >= _minReturn); // ensure the trade gives something in return and meets the minimum requested amount\n\n        uint256 tokenSupply = token.totalSupply();\n        uint256 connectorBalance = getConnectorBalance(_connectorToken);\n        // ensure that the trade will only deplete the connector if the total supply is depleted as well\n        assert(amount < connectorBalance || (amount == connectorBalance && _sellAmount == tokenSupply));\n\n        // update virtual balance if relevant\n        Connector storage connector = connectors[_connectorToken];\n        if (connector.isVirtualBalanceEnabled)\n            connector.virtualBalance = safeSub(connector.virtualBalance, amount);\n\n        // destroy _sellAmount from the caller's balance in the smart token\n        token.destroy(msg.sender, _sellAmount);\n        // transfer funds to the caller in the connector token\n        // the transfer might fail if the actual connector balance is smaller than the virtual balance\n        assert(_connectorToken.transfer(msg.sender, amount));\n\n        dispatchConversionEvent(_connectorToken, _sellAmount, amount, false);\n        return amount;\n    }\n\n    /**\n        @dev converts the token to any other token in the bancor network by following a predefined conversion path\n        note that when converting from an ERC20 token (as opposed to a smart token), allowance must be set beforehand\n\n        @param _path        conversion path, see conversion path format in the BancorQuickConverter contract\n        @param _amount      amount to convert from (in the initial source token)\n        @param _minReturn   if the conversion results in an amount smaller than the minimum return - it is cancelled, must be nonzero\n\n        @return tokens issued in return\n    */\n    function quickConvert(IERC20Token[] _path, uint256 _amount, uint256 _minReturn)\n        public\n        payable\n        validConversionPath(_path)\n        returns (uint256)\n    {\n        IERC20Token fromToken = _path[0];\n        IBancorQuickConverter quickConverter = extensions.quickConverter();\n\n        // we need to transfer the source tokens from the caller to the quick converter,\n        // so it can execute the conversion on behalf of the caller\n        if (msg.value == 0) {\n            // not ETH, send the source tokens to the quick converter\n            // if the token is the smart token, no allowance is required - destroy the tokens from the caller and issue them to the quick converter\n            if (fromToken == token) {\n                token.destroy(msg.sender, _amount); // destroy _amount tokens from the caller's balance in the smart token\n                token.issue(quickConverter, _amount); // issue _amount new tokens to the quick converter\n            }\n            else {\n                // otherwise, we assume we already have allowance, transfer the tokens directly to the quick converter\n                assert(fromToken.transferFrom(msg.sender, quickConverter, _amount));\n            }\n        }\n\n        // execute the conversion and pass on the ETH with the call\n        return quickConverter.convertFor.value(msg.value)(_path, _amount, _minReturn, msg.sender);\n    }\n\n    // deprecated, backward compatibility\n    function change(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256) {\n        return convert(_fromToken, _toToken, _amount, _minReturn);\n    }\n\n    /**\n        @dev utility, returns the expected return for selling the token for one of its connector tokens, given a total supply override\n\n        @param _connectorToken  connector token contract address\n        @param _sellAmount      amount to sell (in the smart token)\n        @param _totalSupply     total token supply, overrides the actual token total supply when calculating the return\n\n        @return sale return amount\n    */\n    function getSaleReturn(IERC20Token _connectorToken, uint256 _sellAmount, uint256 _totalSupply)\n        private\n        view\n        active\n        validConnector(_connectorToken)\n        greaterThanZero(_totalSupply)\n        returns (uint256)\n    {\n        Connector storage connector = connectors[_connectorToken];\n        uint256 connectorBalance = getConnectorBalance(_connectorToken);\n        uint256 amount = extensions.formula().calculateSaleReturn(_totalSupply, connectorBalance, connector.weight, _sellAmount);\n\n        // deduct the fee from the return amount\n        uint256 feeAmount = getConversionFeeAmount(amount);\n        return safeSub(amount, feeAmount);\n    }\n\n    /**\n        @dev helper, dispatches the Conversion event\n        The function also takes the tokens' decimals into account when calculating the current price\n\n        @param _connectorToken  connector token contract address\n        @param _amount          amount purchased/sold (in the source token)\n        @param _returnAmount    amount returned (in the target token)\n        @param isPurchase       true if it's a purchase, false if it's a sale\n    */\n    function dispatchConversionEvent(IERC20Token _connectorToken, uint256 _amount, uint256 _returnAmount, bool isPurchase) private {\n        Connector storage connector = connectors[_connectorToken];\n\n        // calculate the new price using the simple price formula\n        // price = connector balance / (supply * weight)\n        // weight is represented in ppm, so multiplying by 1000000\n        uint256 connectorAmount = safeMul(getConnectorBalance(_connectorToken), MAX_WEIGHT);\n        uint256 tokenAmount = safeMul(token.totalSupply(), connector.weight);\n\n        // normalize values\n        uint8 tokenDecimals = token.decimals();\n        uint8 connectorTokenDecimals = _connectorToken.decimals();\n        if (tokenDecimals != connectorTokenDecimals) {\n            if (tokenDecimals > connectorTokenDecimals)\n                connectorAmount = safeMul(connectorAmount, 10 ** uint256(tokenDecimals - connectorTokenDecimals));\n            else\n                tokenAmount = safeMul(tokenAmount, 10 ** uint256(connectorTokenDecimals - tokenDecimals));\n        }\n\n        uint256 feeAmount = getConversionFeeAmount(_returnAmount);\n        // ensure that the fee is capped at 255 bits to prevent overflow when converting it to a signed int\n        assert(feeAmount <= 2 ** 255);\n\n        if (isPurchase)\n            Conversion(_connectorToken, token, msg.sender, _amount, _returnAmount, int256(feeAmount), connectorAmount, tokenAmount);\n        else\n            Conversion(token, _connectorToken, msg.sender, _amount, _returnAmount, int256(feeAmount), tokenAmount, connectorAmount);\n    }\n\n    /**\n        @dev fallback, buys the smart token with ETH\n        note that the purchase will use the price at the time of the purchase\n    */\n    function() payable public {\n        quickConvert(quickBuyPath, msg.value, 1);\n    }\n}\n\ncontract BancorConverterExtensions is IBancorConverterExtensions, TokenHolder {\n    IBancorFormula public formula;  // bancor calculation formula contract\n    IBancorGasPriceLimit public gasPriceLimit; // bancor universal gas price limit contract\n    IBancorQuickConverter public quickConverter; // bancor quick converter contract\n\n    /**\n        @dev constructor\n\n        @param _formula         address of a bancor formula contract\n        @param _gasPriceLimit   address of a bancor gas price limit contract\n        @param _quickConverter  address of a bancor quick converter contract\n    */\n    function BancorConverterExtensions(IBancorFormula _formula, IBancorGasPriceLimit _gasPriceLimit, IBancorQuickConverter _quickConverter)\n        public\n        validAddress(_formula)\n        validAddress(_gasPriceLimit)\n        validAddress(_quickConverter)\n    {\n        formula = _formula;\n        gasPriceLimit = _gasPriceLimit;\n        quickConverter = _quickConverter;\n    }\n\n    /*\n        @dev allows the owner to update the formula contract address\n\n        @param _formula    address of a bancor formula contract\n    */\n    function setFormula(IBancorFormula _formula)\n        public\n        ownerOnly\n        validAddress(_formula)\n        notThis(_formula)\n    {\n        formula = _formula;\n    }\n\n    /*\n        @dev allows the owner to update the gas price limit contract address\n\n        @param _gasPriceLimit   address of a bancor gas price limit contract\n    */\n    function setGasPriceLimit(IBancorGasPriceLimit _gasPriceLimit)\n        public\n        ownerOnly\n        validAddress(_gasPriceLimit)\n        notThis(_gasPriceLimit)\n    {\n        gasPriceLimit = _gasPriceLimit;\n    }\n\n    /*\n        @dev allows the owner to update the quick converter contract address\n\n        @param _quickConverter  address of a bancor quick converter contract\n    */\n    function setQuickConverter(IBancorQuickConverter _quickConverter)\n        public\n        ownerOnly\n        validAddress(_quickConverter)\n        notThis(_quickConverter)\n    {\n        quickConverter = _quickConverter;\n    }\n}\n\ncontract BancorFormula is IBancorFormula, Utils {\n    string public version = '0.3';\n\n    uint256 private constant ONE = 1;\n    uint32 private constant MAX_WEIGHT = 1000000;\n    uint8 private constant MIN_PRECISION = 32;\n    uint8 private constant MAX_PRECISION = 127;\n\n    /**\n        The values below depend on MAX_PRECISION. If you choose to change it:\n        Apply the same change in file 'PrintIntScalingFactors.py', run it and paste the results below.\n    */\n    uint256 private constant FIXED_1 = 0x080000000000000000000000000000000;\n    uint256 private constant FIXED_2 = 0x100000000000000000000000000000000;\n    uint256 private constant MAX_NUM = 0x1ffffffffffffffffffffffffffffffff;\n\n    /**\n        The values below depend on MAX_PRECISION. If you choose to change it:\n        Apply the same change in file 'PrintLn2ScalingFactors.py', run it and paste the results below.\n    */\n    uint256 private constant LN2_NUMERATOR   = 0x3f80fe03f80fe03f80fe03f80fe03f8;\n    uint256 private constant LN2_DENOMINATOR = 0x5b9de1d10bf4103d647b0955897ba80;\n\n    /**\n        The values below depend on MIN_PRECISION and MAX_PRECISION. If you choose to change either one of them:\n        Apply the same change in file 'PrintFunctionBancorFormula.py', run it and paste the results below.\n    */\n    uint256[128] private maxExpArray;\n\n    function BancorFormula() public {\n    //  maxExpArray[  0] = 0x6bffffffffffffffffffffffffffffffff;\n    //  maxExpArray[  1] = 0x67ffffffffffffffffffffffffffffffff;\n    //  maxExpArray[  2] = 0x637fffffffffffffffffffffffffffffff;\n    //  maxExpArray[  3] = 0x5f6fffffffffffffffffffffffffffffff;\n    //  maxExpArray[  4] = 0x5b77ffffffffffffffffffffffffffffff;\n    //  maxExpArray[  5] = 0x57b3ffffffffffffffffffffffffffffff;\n    //  maxExpArray[  6] = 0x5419ffffffffffffffffffffffffffffff;\n    //  maxExpArray[  7] = 0x50a2ffffffffffffffffffffffffffffff;\n    //  maxExpArray[  8] = 0x4d517fffffffffffffffffffffffffffff;\n    //  maxExpArray[  9] = 0x4a233fffffffffffffffffffffffffffff;\n    //  maxExpArray[ 10] = 0x47165fffffffffffffffffffffffffffff;\n    //  maxExpArray[ 11] = 0x4429afffffffffffffffffffffffffffff;\n    //  maxExpArray[ 12] = 0x415bc7ffffffffffffffffffffffffffff;\n    //  maxExpArray[ 13] = 0x3eab73ffffffffffffffffffffffffffff;\n    //  maxExpArray[ 14] = 0x3c1771ffffffffffffffffffffffffffff;\n    //  maxExpArray[ 15] = 0x399e96ffffffffffffffffffffffffffff;\n    //  maxExpArray[ 16] = 0x373fc47fffffffffffffffffffffffffff;\n    //  maxExpArray[ 17] = 0x34f9e8ffffffffffffffffffffffffffff;\n    //  maxExpArray[ 18] = 0x32cbfd5fffffffffffffffffffffffffff;\n    //  maxExpArray[ 19] = 0x30b5057fffffffffffffffffffffffffff;\n    //  maxExpArray[ 20] = 0x2eb40f9fffffffffffffffffffffffffff;\n    //  maxExpArray[ 21] = 0x2cc8340fffffffffffffffffffffffffff;\n    //  maxExpArray[ 22] = 0x2af09481ffffffffffffffffffffffffff;\n    //  maxExpArray[ 23] = 0x292c5bddffffffffffffffffffffffffff;\n    //  maxExpArray[ 24] = 0x277abdcdffffffffffffffffffffffffff;\n    //  maxExpArray[ 25] = 0x25daf6657fffffffffffffffffffffffff;\n    //  maxExpArray[ 26] = 0x244c49c65fffffffffffffffffffffffff;\n    //  maxExpArray[ 27] = 0x22ce03cd5fffffffffffffffffffffffff;\n    //  maxExpArray[ 28] = 0x215f77c047ffffffffffffffffffffffff;\n    //  maxExpArray[ 29] = 0x1fffffffffffffffffffffffffffffffff;\n    //  maxExpArray[ 30] = 0x1eaefdbdabffffffffffffffffffffffff;\n    //  maxExpArray[ 31] = 0x1d6bd8b2ebffffffffffffffffffffffff;\n        maxExpArray[ 32] = 0x1c35fedd14ffffffffffffffffffffffff;\n        maxExpArray[ 33] = 0x1b0ce43b323fffffffffffffffffffffff;\n        maxExpArray[ 34] = 0x19f0028ec1ffffffffffffffffffffffff;\n        maxExpArray[ 35] = 0x18ded91f0e7fffffffffffffffffffffff;\n        maxExpArray[ 36] = 0x17d8ec7f0417ffffffffffffffffffffff;\n        maxExpArray[ 37] = 0x16ddc6556cdbffffffffffffffffffffff;\n        maxExpArray[ 38] = 0x15ecf52776a1ffffffffffffffffffffff;\n        maxExpArray[ 39] = 0x15060c256cb2ffffffffffffffffffffff;\n        maxExpArray[ 40] = 0x1428a2f98d72ffffffffffffffffffffff;\n        maxExpArray[ 41] = 0x13545598e5c23fffffffffffffffffffff;\n        maxExpArray[ 42] = 0x1288c4161ce1dfffffffffffffffffffff;\n        maxExpArray[ 43] = 0x11c592761c666fffffffffffffffffffff;\n        maxExpArray[ 44] = 0x110a688680a757ffffffffffffffffffff;\n        maxExpArray[ 45] = 0x1056f1b5bedf77ffffffffffffffffffff;\n        maxExpArray[ 46] = 0x0faadceceeff8bffffffffffffffffffff;\n        maxExpArray[ 47] = 0x0f05dc6b27edadffffffffffffffffffff;\n        maxExpArray[ 48] = 0x0e67a5a25da4107fffffffffffffffffff;\n        maxExpArray[ 49] = 0x0dcff115b14eedffffffffffffffffffff;\n        maxExpArray[ 50] = 0x0d3e7a392431239fffffffffffffffffff;\n        maxExpArray[ 51] = 0x0cb2ff529eb71e4fffffffffffffffffff;\n        maxExpArray[ 52] = 0x0c2d415c3db974afffffffffffffffffff;\n        maxExpArray[ 53] = 0x0bad03e7d883f69bffffffffffffffffff;\n        maxExpArray[ 54] = 0x0b320d03b2c343d5ffffffffffffffffff;\n        maxExpArray[ 55] = 0x0abc25204e02828dffffffffffffffffff;\n        maxExpArray[ 56] = 0x0a4b16f74ee4bb207fffffffffffffffff;\n        maxExpArray[ 57] = 0x09deaf736ac1f569ffffffffffffffffff;\n        maxExpArray[ 58] = 0x0976bd9952c7aa957fffffffffffffffff;\n        maxExpArray[ 59] = 0x09131271922eaa606fffffffffffffffff;\n        maxExpArray[ 60] = 0x08b380f3558668c46fffffffffffffffff;\n        maxExpArray[ 61] = 0x0857ddf0117efa215bffffffffffffffff;\n        maxExpArray[ 62] = 0x07ffffffffffffffffffffffffffffffff;\n        maxExpArray[ 63] = 0x07abbf6f6abb9d087fffffffffffffffff;\n        maxExpArray[ 64] = 0x075af62cbac95f7dfa7fffffffffffffff;\n        maxExpArray[ 65] = 0x070d7fb7452e187ac13fffffffffffffff;\n        maxExpArray[ 66] = 0x06c3390ecc8af379295fffffffffffffff;\n        maxExpArray[ 67] = 0x067c00a3b07ffc01fd6fffffffffffffff;\n        maxExpArray[ 68] = 0x0637b647c39cbb9d3d27ffffffffffffff;\n        maxExpArray[ 69] = 0x05f63b1fc104dbd39587ffffffffffffff;\n        maxExpArray[ 70] = 0x05b771955b36e12f7235ffffffffffffff;\n        maxExpArray[ 71] = 0x057b3d49dda84556d6f6ffffffffffffff;\n        maxExpArray[ 72] = 0x054183095b2c8ececf30ffffffffffffff;\n        maxExpArray[ 73] = 0x050a28be635ca2b888f77fffffffffffff;\n        maxExpArray[ 74] = 0x04d5156639708c9db33c3fffffffffffff;\n        maxExpArray[ 75] = 0x04a23105873875bd52dfdfffffffffffff;\n        maxExpArray[ 76] = 0x0471649d87199aa990756fffffffffffff;\n        maxExpArray[ 77] = 0x04429a21a029d4c1457cfbffffffffffff;\n        maxExpArray[ 78] = 0x0415bc6d6fb7dd71af2cb3ffffffffffff;\n        maxExpArray[ 79] = 0x03eab73b3bbfe282243ce1ffffffffffff;\n        maxExpArray[ 80] = 0x03c1771ac9fb6b4c18e229ffffffffffff;\n        maxExpArray[ 81] = 0x0399e96897690418f785257fffffffffff;\n        maxExpArray[ 82] = 0x0373fc456c53bb779bf0ea9fffffffffff;\n        maxExpArray[ 83] = 0x034f9e8e490c48e67e6ab8bfffffffffff;\n        maxExpArray[ 84] = 0x032cbfd4a7adc790560b3337ffffffffff;\n        maxExpArray[ 85] = 0x030b50570f6e5d2acca94613ffffffffff;\n        maxExpArray[ 86] = 0x02eb40f9f620fda6b56c2861ffffffffff;\n        maxExpArray[ 87] = 0x02cc8340ecb0d0f520a6af58ffffffffff;\n        maxExpArray[ 88] = 0x02af09481380a0a35cf1ba02ffffffffff;\n        maxExpArray[ 89] = 0x0292c5bdd3b92ec810287b1b3fffffffff;\n        maxExpArray[ 90] = 0x0277abdcdab07d5a77ac6d6b9fffffffff;\n        maxExpArray[ 91] = 0x025daf6654b1eaa55fd64df5efffffffff;\n        maxExpArray[ 92] = 0x0244c49c648baa98192dce88b7ffffffff;\n        maxExpArray[ 93] = 0x022ce03cd5619a311b2471268bffffffff;\n        maxExpArray[ 94] = 0x0215f77c045fbe885654a44a0fffffffff;\n        maxExpArray[ 95] = 0x01ffffffffffffffffffffffffffffffff;\n        maxExpArray[ 96] = 0x01eaefdbdaaee7421fc4d3ede5ffffffff;\n        maxExpArray[ 97] = 0x01d6bd8b2eb257df7e8ca57b09bfffffff;\n        maxExpArray[ 98] = 0x01c35fedd14b861eb0443f7f133fffffff;\n        maxExpArray[ 99] = 0x01b0ce43b322bcde4a56e8ada5afffffff;\n        maxExpArray[100] = 0x019f0028ec1fff007f5a195a39dfffffff;\n        maxExpArray[101] = 0x018ded91f0e72ee74f49b15ba527ffffff;\n        maxExpArray[102] = 0x017d8ec7f04136f4e5615fd41a63ffffff;\n        maxExpArray[103] = 0x016ddc6556cdb84bdc8d12d22e6fffffff;\n        maxExpArray[104] = 0x015ecf52776a1155b5bd8395814f7fffff;\n        maxExpArray[105] = 0x015060c256cb23b3b3cc3754cf40ffffff;\n        maxExpArray[106] = 0x01428a2f98d728ae223ddab715be3fffff;\n        maxExpArray[107] = 0x013545598e5c23276ccf0ede68034fffff;\n        maxExpArray[108] = 0x01288c4161ce1d6f54b7f61081194fffff;\n        maxExpArray[109] = 0x011c592761c666aa641d5a01a40f17ffff;\n        maxExpArray[110] = 0x0110a688680a7530515f3e6e6cfdcdffff;\n        maxExpArray[111] = 0x01056f1b5bedf75c6bcb2ce8aed428ffff;\n        maxExpArray[112] = 0x00faadceceeff8a0890f3875f008277fff;\n        maxExpArray[113] = 0x00f05dc6b27edad306388a600f6ba0bfff;\n        maxExpArray[114] = 0x00e67a5a25da41063de1495d5b18cdbfff;\n        maxExpArray[115] = 0x00dcff115b14eedde6fc3aa5353f2e4fff;\n        maxExpArray[116] = 0x00d3e7a3924312399f9aae2e0f868f8fff;\n        maxExpArray[117] = 0x00cb2ff529eb71e41582cccd5a1ee26fff;\n        maxExpArray[118] = 0x00c2d415c3db974ab32a51840c0b67edff;\n        maxExpArray[119] = 0x00bad03e7d883f69ad5b0a186184e06bff;\n        maxExpArray[120] = 0x00b320d03b2c343d4829abd6075f0cc5ff;\n        maxExpArray[121] = 0x00abc25204e02828d73c6e80bcdb1a95bf;\n        maxExpArray[122] = 0x00a4b16f74ee4bb2040a1ec6c15fbbf2df;\n        maxExpArray[123] = 0x009deaf736ac1f569deb1b5ae3f36c130f;\n        maxExpArray[124] = 0x00976bd9952c7aa957f5937d790ef65037;\n        maxExpArray[125] = 0x009131271922eaa6064b73a22d0bd4f2bf;\n        maxExpArray[126] = 0x008b380f3558668c46c91c49a2f8e967b9;\n        maxExpArray[127] = 0x00857ddf0117efa215952912839f6473e6;\n    }\n\n    /**\n        @dev given a token supply, connector balance, weight and a deposit amount (in the connector token),\n        calculates the return for a given conversion (in the main token)\n\n        Formula:\n        Return = _supply * ((1 + _depositAmount / _connectorBalance) ^ (_connectorWeight / 1000000) - 1)\n\n        @param _supply              token total supply\n        @param _connectorBalance    total connector balance\n        @param _connectorWeight     connector weight, represented in ppm, 1-1000000\n        @param _depositAmount       deposit amount, in connector token\n\n        @return purchase return amount\n    */\n    function calculatePurchaseReturn(uint256 _supply, uint256 _connectorBalance, uint32 _connectorWeight, uint256 _depositAmount) public view returns (uint256) {\n        // validate input\n        require(_supply > 0 && _connectorBalance > 0 && _connectorWeight > 0 && _connectorWeight <= MAX_WEIGHT);\n\n        // special case for 0 deposit amount\n        if (_depositAmount == 0)\n            return 0;\n\n        // special case if the weight = 100%\n        if (_connectorWeight == MAX_WEIGHT)\n            return safeMul(_supply, _depositAmount) / _connectorBalance;\n\n        uint256 result;\n        uint8 precision;\n        uint256 baseN = safeAdd(_depositAmount, _connectorBalance);\n        (result, precision) = power(baseN, _connectorBalance, _connectorWeight, MAX_WEIGHT);\n        uint256 temp = safeMul(_supply, result) >> precision;\n        return temp - _supply;\n    }\n\n    /**\n        @dev given a token supply, connector balance, weight and a sell amount (in the main token),\n        calculates the return for a given conversion (in the connector token)\n\n        Formula:\n        Return = _connectorBalance * (1 - (1 - _sellAmount / _supply) ^ (1 / (_connectorWeight / 1000000)))\n\n        @param _supply              token total supply\n        @param _connectorBalance    total connector\n        @param _connectorWeight     constant connector Weight, represented in ppm, 1-1000000\n        @param _sellAmount          sell amount, in the token itself\n\n        @return sale return amount\n    */\n    function calculateSaleReturn(uint256 _supply, uint256 _connectorBalance, uint32 _connectorWeight, uint256 _sellAmount) public view returns (uint256) {\n        // validate input\n        require(_supply > 0 && _connectorBalance > 0 && _connectorWeight > 0 && _connectorWeight <= MAX_WEIGHT && _sellAmount <= _supply);\n\n        // special case for 0 sell amount\n        if (_sellAmount == 0)\n            return 0;\n\n        // special case for selling the entire supply\n        if (_sellAmount == _supply)\n            return _connectorBalance;\n\n        // special case if the weight = 100%\n        if (_connectorWeight == MAX_WEIGHT)\n            return safeMul(_connectorBalance, _sellAmount) / _supply;\n\n        uint256 result;\n        uint8 precision;\n        uint256 baseD = _supply - _sellAmount;\n        (result, precision) = power(_supply, baseD, MAX_WEIGHT, _connectorWeight);\n        uint256 temp1 = safeMul(_connectorBalance, result);\n        uint256 temp2 = _connectorBalance << precision;\n        return (temp1 - temp2) / result;\n    }\n\n    /**\n        General Description:\n            Determine a value of precision.\n            Calculate an integer approximation of (_baseN / _baseD) ^ (_expN / _expD) * 2 ^ precision.\n            Return the result along with the precision used.\n\n        Detailed Description:\n            Instead of calculating \"base ^ exp\", we calculate \"e ^ (ln(base) * exp)\".\n            The value of \"ln(base)\" is represented with an integer slightly smaller than \"ln(base) * 2 ^ precision\".\n            The larger \"precision\" is, the more accurately this value represents the real value.\n            However, the larger \"precision\" is, the more bits are required in order to store this value.\n            And the exponentiation function, which takes \"x\" and calculates \"e ^ x\", is limited to a maximum exponent (maximum value of \"x\").\n            This maximum exponent depends on the \"precision\" used, and it is given by \"maxExpArray[precision] >> (MAX_PRECISION - precision)\".\n            Hence we need to determine the highest precision which can be used for the given input, before calling the exponentiation function.\n            This allows us to compute \"base ^ exp\" with maximum accuracy and without exceeding 256 bits in any of the intermediate computations.\n            This functions assumes that \"_expN < (1 << 256) / ln(MAX_NUM, 1)\", otherwise the multiplication should be replaced with a \"safeMul\".\n    */\n    function power(uint256 _baseN, uint256 _baseD, uint32 _expN, uint32 _expD) internal view returns (uint256, uint8) {\n        uint256 lnBaseTimesExp = ln(_baseN, _baseD) * _expN / _expD;\n        uint8 precision = findPositionInMaxExpArray(lnBaseTimesExp);\n        return (fixedExp(lnBaseTimesExp >> (MAX_PRECISION - precision), precision), precision);\n    }\n\n    /**\n        Return floor(ln(numerator / denominator) * 2 ^ MAX_PRECISION), where:\n        - The numerator   is a value between 1 and 2 ^ (256 - MAX_PRECISION) - 1\n        - The denominator is a value between 1 and 2 ^ (256 - MAX_PRECISION) - 1\n        - The output      is a value between 0 and floor(ln(2 ^ (256 - MAX_PRECISION) - 1) * 2 ^ MAX_PRECISION)\n        This functions assumes that the numerator is larger than or equal to the denominator, because the output would be negative otherwise.\n    */\n    function ln(uint256 _numerator, uint256 _denominator) internal pure returns (uint256) {\n        assert(_numerator <= MAX_NUM);\n\n        uint256 res = 0;\n        uint256 x = _numerator * FIXED_1 / _denominator;\n\n        // If x >= 2, then we compute the integer part of log2(x), which is larger than 0.\n        if (x >= FIXED_2) {\n            uint8 count = floorLog2(x / FIXED_1);\n            x >>= count; // now x < 2\n            res = count * FIXED_1;\n        }\n\n        // If x > 1, then we compute the fraction part of log2(x), which is larger than 0.\n        if (x > FIXED_1) {\n            for (uint8 i = MAX_PRECISION; i > 0; --i) {\n                x = (x * x) / FIXED_1; // now 1 < x < 4\n                if (x >= FIXED_2) {\n                    x >>= 1; // now 1 < x < 2\n                    res += ONE << (i - 1);\n                }\n            }\n        }\n\n        return res * LN2_NUMERATOR / LN2_DENOMINATOR;\n    }\n\n    /**\n        Compute the largest integer smaller than or equal to the binary logarithm of the input.\n    */\n    function floorLog2(uint256 _n) internal pure returns (uint8) {\n        uint8 res = 0;\n\n        if (_n < 256) {\n            // At most 8 iterations\n            while (_n > 1) {\n                _n >>= 1;\n                res += 1;\n            }\n        }\n        else {\n            // Exactly 8 iterations\n            for (uint8 s = 128; s > 0; s >>= 1) {\n                if (_n >= (ONE << s)) {\n                    _n >>= s;\n                    res |= s;\n                }\n            }\n        }\n\n        return res;\n    }\n\n    /**\n        The global \"maxExpArray\" is sorted in descending order, and therefore the following statements are equivalent:\n        - This function finds the position of [the smallest value in \"maxExpArray\" larger than or equal to \"x\"]\n        - This function finds the highest position of [a value in \"maxExpArray\" larger than or equal to \"x\"]\n    */\n    function findPositionInMaxExpArray(uint256 _x) internal view returns (uint8) {\n        uint8 lo = MIN_PRECISION;\n        uint8 hi = MAX_PRECISION;\n\n        while (lo + 1 < hi) {\n            uint8 mid = (lo + hi) / 2;\n            if (maxExpArray[mid] >= _x)\n                lo = mid;\n            else\n                hi = mid;\n        }\n\n        if (maxExpArray[hi] >= _x)\n            return hi;\n        if (maxExpArray[lo] >= _x)\n            return lo;\n\n        assert(false);\n        return 0;\n    }\n\n    /**\n        This function can be auto-generated by the script 'PrintFunctionFixedExp.py'.\n        It approximates \"e ^ x\" via maclaurin summation: \"(x^0)/0! + (x^1)/1! + ... + (x^n)/n!\".\n        It returns \"e ^ (x / 2 ^ precision) * 2 ^ precision\", that is, the result is upshifted for accuracy.\n        The global \"maxExpArray\" maps each \"precision\" to \"((maximumExponent + 1) << (MAX_PRECISION - precision)) - 1\".\n        The maximum permitted value for \"x\" is therefore given by \"maxExpArray[precision] >> (MAX_PRECISION - precision)\".\n    */\n    function fixedExp(uint256 _x, uint8 _precision) internal pure returns (uint256) {\n        uint256 xi = _x;\n        uint256 res = 0;\n\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x03442c4e6074a82f1797f72ac0000000; // add x^2 * (33! / 2!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0116b96f757c380fb287fd0e40000000; // add x^3 * (33! / 3!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0045ae5bdd5f0e03eca1ff4390000000; // add x^4 * (33! / 4!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000defabf91302cd95b9ffda50000000; // add x^5 * (33! / 5!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0002529ca9832b22439efff9b8000000; // add x^6 * (33! / 6!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000054f1cf12bd04e516b6da88000000; // add x^7 * (33! / 7!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000a9e39e257a09ca2d6db51000000; // add x^8 * (33! / 8!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000012e066e7b839fa050c309000000; // add x^9 * (33! / 9!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000001e33d7d926c329a1ad1a800000; // add x^10 * (33! / 10!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000002bee513bdb4a6b19b5f800000; // add x^11 * (33! / 11!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000003a9316fa79b88eccf2a00000; // add x^12 * (33! / 12!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000048177ebe1fa812375200000; // add x^13 * (33! / 13!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000005263fe90242dcbacf00000; // add x^14 * (33! / 14!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000057e22099c030d94100000; // add x^15 * (33! / 15!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000057e22099c030d9410000; // add x^16 * (33! / 16!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000000052b6b54569976310000; // add x^17 * (33! / 17!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000000004985f67696bf748000; // add x^18 * (33! / 18!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000003dea12ea99e498000; // add x^19 * (33! / 19!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000000000031880f2214b6e000; // add x^20 * (33! / 20!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000025bcff56eb36000; // add x^21 * (33! / 21!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000001b722e10ab1000; // add x^22 * (33! / 22!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000000000001317c70077000; // add x^23 * (33! / 23!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000000000000000cba84aafa00; // add x^24 * (33! / 24!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000000000000000082573a0a00; // add x^25 * (33! / 25!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000000000000000005035ad900; // add x^26 * (33! / 26!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000000000002f881b00; // add x^27 * (33! / 27!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000000000000000001b29340; // add x^28 * (33! / 28!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000000000000000000000efc40; // add x^29 * (33! / 29!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000000000000000000007fe0; // add x^30 * (33! / 30!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000000000000000000000420; // add x^31 * (33! / 31!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000000000000000000000021; // add x^32 * (33! / 32!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000000000000000000000001; // add x^33 * (33! / 33!)\n\n        return res / 0x688589cc0e9505e2f2fee5580000000 + _x + (ONE << _precision); // divide by 33! and then add x^1 / 1! + x^0 / 0!\n    }\n}\n\ncontract BancorGasPriceLimit is IBancorGasPriceLimit, Owned, Utils {\n    uint256 public gasPrice = 0 wei;    // maximum gas price for bancor transactions\n\n    /**\n        @dev constructor\n\n        @param _gasPrice    gas price limit\n    */\n    function BancorGasPriceLimit(uint256 _gasPrice)\n        public\n        greaterThanZero(_gasPrice)\n    {\n        gasPrice = _gasPrice;\n    }\n\n    /*\n        @dev allows the owner to update the gas price limit\n\n        @param _gasPrice    new gas price limit\n    */\n    function setGasPrice(uint256 _gasPrice)\n        public\n        ownerOnly\n        greaterThanZero(_gasPrice)\n    {\n        gasPrice = _gasPrice;\n    }\n}\n\ncontract BancorPriceFloor is Owned, TokenHolder {\n    uint256 public constant TOKEN_PRICE_N = 1;      // crowdsale price in wei (numerator)\n    uint256 public constant TOKEN_PRICE_D = 100;    // crowdsale price in wei (denominator)\n\n    string public version = '0.1';\n    ISmartToken public token; // smart token the contract allows selling\n\n    /**\n        @dev constructor\n\n        @param _token   smart token the contract allows selling\n    */\n    function BancorPriceFloor(ISmartToken _token)\n        public\n        validAddress(_token)\n    {\n        token = _token;\n    }\n\n    /**\n        @dev sells the smart token for ETH\n        note that the function will sell the full allowance amount\n\n        @return ETH sent in return\n    */\n    function sell() public returns (uint256 amount) {\n        uint256 allowance = token.allowance(msg.sender, this); // get the full allowance amount\n        assert(token.transferFrom(msg.sender, this, allowance)); // transfer all tokens from the sender to the contract\n        uint256 etherValue = safeMul(allowance, TOKEN_PRICE_N) / TOKEN_PRICE_D; // calculate ETH value of the tokens\n        msg.sender.transfer(etherValue); // send the ETH amount to the seller\n        return etherValue;\n    }\n\n    /**\n        @dev withdraws ETH from the contract\n\n        @param _amount  amount of ETH to withdraw\n    */\n    function withdraw(uint256 _amount) public ownerOnly {\n        msg.sender.transfer(_amount); // send the amount\n    }\n\n    /**\n        @dev deposits ETH in the contract\n    */\n    function() public payable {\n    }\n}\n\ncontract BancorQuickConverter is IBancorQuickConverter, TokenHolder {\n    mapping (address => bool) public etherTokens;   // list of all supported ether tokens\n\n    /**\n        @dev constructor\n    */\n    function BancorQuickConverter() public {\n    }\n\n    // validates a conversion path - verifies that the number of elements is odd and that maximum number of 'hops' is 10\n    modifier validConversionPath(IERC20Token[] _path) {\n        require(_path.length > 2 && _path.length <= (1 + 2 * 10) && _path.length % 2 == 1);\n        _;\n    }\n\n    /**\n        @dev allows the owner to register/unregister ether tokens\n\n        @param _token       ether token contract address\n        @param _register    true to register, false to unregister\n    */\n    function registerEtherToken(IEtherToken _token, bool _register)\n        public\n        ownerOnly\n        validAddress(_token)\n        notThis(_token)\n    {\n        etherTokens[_token] = _register;\n    }\n\n    /**\n        @dev converts the token to any other token in the bancor network by following\n        a predefined conversion path and transfers the result tokens to a target account\n        note that the converter should already own the source tokens\n\n        @param _path        conversion path, see conversion path format above\n        @param _amount      amount to convert from (in the initial source token)\n        @param _minReturn   if the conversion results in an amount smaller than the minimum return - it is cancelled, must be nonzero\n        @param _for         account that will receive the conversion result\n\n        @return tokens issued in return\n    */\n    function convertFor(IERC20Token[] _path, uint256 _amount, uint256 _minReturn, address _for)\n        public\n        payable\n        validConversionPath(_path)\n        returns (uint256)\n    {\n        // if ETH is provided, ensure that the amount is identical to _amount and verify that the source token is an ether token\n        IERC20Token fromToken = _path[0];\n        require(msg.value == 0 || (_amount == msg.value && etherTokens[fromToken]));\n\n        ISmartToken smartToken;\n        IERC20Token toToken;\n        ITokenConverter converter;\n        uint256 pathLength = _path.length;\n\n        // if ETH was sent with the call, the source is an ether token - deposit the ETH in it\n        // otherwise, we assume we already have the tokens\n        if (msg.value > 0)\n            IEtherToken(fromToken).deposit.value(msg.value)();\n\n        // iterate over the conversion path\n        for (uint256 i = 1; i < pathLength; i += 2) {\n            smartToken = ISmartToken(_path[i]);\n            toToken = _path[i + 1];\n            converter = ITokenConverter(smartToken.owner());\n\n            // if the smart token isn't the source (from token), the converter doesn't have control over it and thus we need to approve the request\n            if (smartToken != fromToken)\n                ensureAllowance(fromToken, converter, _amount);\n\n            // make the conversion - if it's the last one, also provide the minimum return value\n            _amount = converter.change(fromToken, toToken, _amount, i == pathLength - 2 ? _minReturn : 1);\n            fromToken = toToken;\n        }\n\n        // finished the conversion, transfer the funds to the target account\n        // if the target token is an ether token, withdraw the tokens and send them as ETH\n        // otherwise, transfer the tokens as is\n        if (etherTokens[toToken])\n            IEtherToken(toToken).withdrawTo(_for, _amount);\n        else\n            assert(toToken.transfer(_for, _amount));\n\n        return _amount;\n    }\n\n    /**\n        @dev claims the caller's tokens, converts them to any other token in the bancor network\n        by following a predefined conversion path and transfers the result tokens to a target account\n        note that allowance must be set beforehand\n\n        @param _path        conversion path, see conversion path format above\n        @param _amount      amount to convert from (in the initial source token)\n        @param _minReturn   if the conversion results in an amount smaller than the minimum return - it is cancelled, must be nonzero\n        @param _for         account that will receive the conversion result\n\n        @return tokens issued in return\n    */\n    function claimAndConvertFor(IERC20Token[] _path, uint256 _amount, uint256 _minReturn, address _for) public returns (uint256) {\n        // we need to transfer the tokens from the caller to the converter before we follow\n        // the conversion path, to allow it to execute the conversion on behalf of the caller\n        // note: we assume we already have allowance\n        IERC20Token fromToken = _path[0];\n        assert(fromToken.transferFrom(msg.sender, this, _amount));\n        return convertFor(_path, _amount, _minReturn, _for);\n    }\n\n    /**\n        @dev converts the token to any other token in the bancor network by following\n        a predefined conversion path and transfers the result tokens back to the sender\n        note that the converter should already own the source tokens\n\n        @param _path        conversion path, see conversion path format above\n        @param _amount      amount to convert from (in the initial source token)\n        @param _minReturn   if the conversion results in an amount smaller than the minimum return - it is cancelled, must be nonzero\n\n        @return tokens issued in return\n    */\n    function convert(IERC20Token[] _path, uint256 _amount, uint256 _minReturn) public payable returns (uint256) {\n        return convertFor(_path, _amount, _minReturn, msg.sender);\n    }\n\n    /**\n        @dev claims the caller's tokens, converts them to any other token in the bancor network\n        by following a predefined conversion path and transfers the result tokens back to the sender\n        note that allowance must be set beforehand\n\n        @param _path        conversion path, see conversion path format above\n        @param _amount      amount to convert from (in the initial source token)\n        @param _minReturn   if the conversion results in an amount smaller than the minimum return - it is cancelled, must be nonzero\n\n        @return tokens issued in return\n    */\n    function claimAndConvert(IERC20Token[] _path, uint256 _amount, uint256 _minReturn) public returns (uint256) {\n        return claimAndConvertFor(_path, _amount, _minReturn, msg.sender);\n    }\n\n    /**\n        @dev utility, checks whether allowance for the given spender exists and approves one if it doesn't\n\n        @param _token   token to check the allowance in\n        @param _spender approved address\n        @param _value   allowance amount\n    */\n    function ensureAllowance(IERC20Token _token, address _spender, uint256 _value) private {\n        // check if allowance for the given amount already exists\n        if (_token.allowance(this, _spender) >= _value)\n            return;\n\n        // if the allowance is nonzero, must reset it to 0 first\n        if (_token.allowance(this, _spender) != 0)\n            assert(_token.approve(_spender, 0));\n\n        // approve the new allowance\n        assert(_token.approve(_spender, _value));\n    }\n}\n\ncontract CrowdsaleController is SmartTokenController {\n    uint256 public constant DURATION = 14 days;                 // crowdsale duration\n    uint256 public constant TOKEN_PRICE_N = 1;                  // initial price in wei (numerator)\n    uint256 public constant TOKEN_PRICE_D = 100;                // initial price in wei (denominator)\n    uint256 public constant BTCS_ETHER_CAP = 50000 ether;       // maximum bitcoin suisse ether contribution\n    uint256 public constant MAX_GAS_PRICE = 50000000000 wei;    // maximum gas price for contribution transactions\n\n    string public version = '0.1';\n\n    uint256 public startTime = 0;                   // crowdsale start time (in seconds)\n    uint256 public endTime = 0;                     // crowdsale end time (in seconds)\n    uint256 public totalEtherCap = 1000000 ether;   // current ether contribution cap, initialized with a temp value as a safety mechanism until the real cap is revealed\n    uint256 public totalEtherContributed = 0;       // ether contributed so far\n    bytes32 public realEtherCapHash;                // ensures that the real cap is predefined on deployment and cannot be changed later\n    address public beneficiary = address(0);        // address to receive all ether contributions\n    address public btcs = address(0);               // bitcoin suisse address\n\n    // triggered on each contribution\n    event Contribution(address indexed _contributor, uint256 _amount, uint256 _return);\n\n    /**\n        @dev constructor\n\n        @param _token          smart token the crowdsale is for\n        @param _startTime      crowdsale start time\n        @param _beneficiary    address to receive all ether contributions\n        @param _btcs           bitcoin suisse address\n    */\n    function CrowdsaleController(ISmartToken _token, uint256 _startTime, address _beneficiary, address _btcs, bytes32 _realEtherCapHash)\n        public\n        SmartTokenController(_token)\n        validAddress(_beneficiary)\n        validAddress(_btcs)\n        earlierThan(_startTime)\n        greaterThanZero(uint256(_realEtherCapHash))\n    {\n        startTime = _startTime;\n        endTime = startTime + DURATION;\n        beneficiary = _beneficiary;\n        btcs = _btcs;\n        realEtherCapHash = _realEtherCapHash;\n    }\n\n    // verifies that the gas price is lower than 50 gwei\n    modifier validGasPrice() {\n        assert(tx.gasprice <= MAX_GAS_PRICE);\n        _;\n    }\n\n    // verifies that the ether cap is valid based on the key provided\n    modifier validEtherCap(uint256 _cap, uint256 _key) {\n        require(computeRealCap(_cap, _key) == realEtherCapHash);\n        _;\n    }\n\n    // ensures that it's earlier than the given time\n    modifier earlierThan(uint256 _time) {\n        assert(now < _time);\n        _;\n    }\n\n    // ensures that the current time is between _startTime (inclusive) and _endTime (exclusive)\n    modifier between(uint256 _startTime, uint256 _endTime) {\n        assert(now >= _startTime && now < _endTime);\n        _;\n    }\n\n    // ensures that the sender is bitcoin suisse\n    modifier btcsOnly() {\n        assert(msg.sender == btcs);\n        _;\n    }\n\n    // ensures that we didn't reach the ether cap\n    modifier etherCapNotReached(uint256 _contribution) {\n        assert(safeAdd(totalEtherContributed, _contribution) <= totalEtherCap);\n        _;\n    }\n\n    // ensures that we didn't reach the bitcoin suisse ether cap\n    modifier btcsEtherCapNotReached(uint256 _ethContribution) {\n        assert(safeAdd(totalEtherContributed, _ethContribution) <= BTCS_ETHER_CAP);\n        _;\n    }\n\n    /**\n        @dev computes the real cap based on the given cap & key\n\n        @param _cap    cap\n        @param _key    key used to compute the cap hash\n\n        @return computed real cap hash\n    */\n    function computeRealCap(uint256 _cap, uint256 _key) public pure returns (bytes32) {\n        return keccak256(_cap, _key);\n    }\n\n    /**\n        @dev enables the real cap defined on deployment\n\n        @param _cap    predefined cap\n        @param _key    key used to compute the cap hash\n    */\n    function enableRealCap(uint256 _cap, uint256 _key)\n        public\n        ownerOnly\n        active\n        between(startTime, endTime)\n        validEtherCap(_cap, _key)\n    {\n        require(_cap < totalEtherCap); // validate input\n        totalEtherCap = _cap;\n    }\n\n    /**\n        @dev computes the number of tokens that should be issued for a given contribution\n\n        @param _contribution    contribution amount\n\n        @return computed number of tokens\n    */\n    function computeReturn(uint256 _contribution) public pure returns (uint256) {\n        return safeMul(_contribution, TOKEN_PRICE_D) / TOKEN_PRICE_N;\n    }\n\n    /**\n        @dev ETH contribution\n        can only be called during the crowdsale\n\n        @return tokens issued in return\n    */\n    function contributeETH()\n        public\n        payable\n        between(startTime, endTime)\n        returns (uint256 amount)\n    {\n        return processContribution();\n    }\n\n    /**\n        @dev Contribution through BTCs (Bitcoin Suisse only)\n        can only be called before the crowdsale started\n\n        @return tokens issued in return\n    */\n    function contributeBTCs()\n        public\n        payable\n        btcsOnly\n        btcsEtherCapNotReached(msg.value)\n        earlierThan(startTime)\n        returns (uint256 amount)\n    {\n        return processContribution();\n    }\n\n    /**\n        @dev handles contribution logic\n        note that the Contribution event is triggered using the sender as the contributor, regardless of the actual contributor\n\n        @return tokens issued in return\n    */\n    function processContribution() private\n        active\n        etherCapNotReached(msg.value)\n        validGasPrice\n        returns (uint256 amount)\n    {\n        uint256 tokenAmount = computeReturn(msg.value);\n        beneficiary.transfer(msg.value); // transfer the ether to the beneficiary account\n        totalEtherContributed = safeAdd(totalEtherContributed, msg.value); // update the total contribution amount\n        token.issue(msg.sender, tokenAmount); // issue new funds to the contributor in the smart token\n        token.issue(beneficiary, tokenAmount); // issue tokens to the beneficiary\n\n        Contribution(msg.sender, msg.value, tokenAmount);\n        return tokenAmount;\n    }\n\n    // fallback\n    function() payable public {\n        contributeETH();\n    }\n}\n\ncontract ERC20Token is IERC20Token, Utils {\n    string public standard = 'Token 0.1';\n    string public name = '';\n    string public symbol = '';\n    uint8 public decimals = 0;\n    uint256 public totalSupply = 0;\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    /**\n        @dev constructor\n\n        @param _name        token name\n        @param _symbol      token symbol\n        @param _decimals    decimal points, for display purposes\n    */\n    function ERC20Token(string _name, string _symbol, uint8 _decimals) public {\n        require(bytes(_name).length > 0 && bytes(_symbol).length > 0); // validate input\n\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n    }\n\n    /**\n        @dev send coins\n        throws on any error rather then return a false flag to minimize user errors\n\n        @param _to      target address\n        @param _value   transfer amount\n\n        @return true if the transfer was successful, false if it wasn't\n    */\n    function transfer(address _to, uint256 _value)\n        public\n        validAddress(_to)\n        returns (bool success)\n    {\n        balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], _value);\n        balanceOf[_to] = safeAdd(balanceOf[_to], _value);\n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    /**\n        @dev an account/contract attempts to get the coins\n        throws on any error rather then return a false flag to minimize user errors\n\n        @param _from    source address\n        @param _to      target address\n        @param _value   transfer amount\n\n        @return true if the transfer was successful, false if it wasn't\n    */\n    function transferFrom(address _from, address _to, uint256 _value)\n        public\n        validAddress(_from)\n        validAddress(_to)\n        returns (bool success)\n    {\n        allowance[_from][msg.sender] = safeSub(allowance[_from][msg.sender], _value);\n        balanceOf[_from] = safeSub(balanceOf[_from], _value);\n        balanceOf[_to] = safeAdd(balanceOf[_to], _value);\n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n        @dev allow another account/contract to spend some tokens on your behalf\n        throws on any error rather then return a false flag to minimize user errors\n\n        also, to minimize the risk of the approve/transferFrom attack vector\n        (see https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/), approve has to be called twice\n        in 2 separate transactions - once to change the allowance to 0 and secondly to change it to the new allowance value\n\n        @param _spender approved address\n        @param _value   allowance amount\n\n        @return true if the approval was successful, false if it wasn't\n    */\n    function approve(address _spender, uint256 _value)\n        public\n        validAddress(_spender)\n        returns (bool success)\n    {\n        // if the allowance isn't 0, it can only be updated to 0 to prevent an allowance change immediately after withdrawal\n        require(_value == 0 || allowance[msg.sender][_spender] == 0);\n\n        allowance[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n}\n\ncontract EtherToken is IEtherToken, Owned, ERC20Token, TokenHolder {\n    // triggered when the total supply is increased\n    event Issuance(uint256 _amount);\n    // triggered when the total supply is decreased\n    event Destruction(uint256 _amount);\n\n    /**\n        @dev constructor\n    */\n    function EtherToken()\n        public\n        ERC20Token('Ether Token', 'ETH', 18) {\n    }\n\n    /**\n        @dev deposit ether in the account\n    */\n    function deposit() public payable {\n        balanceOf[msg.sender] = safeAdd(balanceOf[msg.sender], msg.value); // add the value to the account balance\n        totalSupply = safeAdd(totalSupply, msg.value); // increase the total supply\n\n        Issuance(msg.value);\n        Transfer(this, msg.sender, msg.value);\n    }\n\n    /**\n        @dev withdraw ether from the account\n\n        @param _amount  amount of ether to withdraw\n    */\n    function withdraw(uint256 _amount) public {\n        withdrawTo(msg.sender, _amount);\n    }\n\n    /**\n        @dev withdraw ether from the account to a target account\n\n        @param _to      account to receive the ether\n        @param _amount  amount of ether to withdraw\n    */\n    function withdrawTo(address _to, uint256 _amount)\n        public\n        notThis(_to)\n    {\n        balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], _amount); // deduct the amount from the account balance\n        totalSupply = safeSub(totalSupply, _amount); // decrease the total supply\n        _to.transfer(_amount); // send the amount to the target account\n\n        Transfer(msg.sender, this, _amount);\n        Destruction(_amount);\n    }\n\n    // ERC20 standard method overrides with some extra protection\n\n    /**\n        @dev send coins\n        throws on any error rather then return a false flag to minimize user errors\n\n        @param _to      target address\n        @param _value   transfer amount\n\n        @return true if the transfer was successful, false if it wasn't\n    */\n    function transfer(address _to, uint256 _value)\n        public\n        notThis(_to)\n        returns (bool success)\n    {\n        assert(super.transfer(_to, _value));\n        return true;\n    }\n\n    /**\n        @dev an account/contract attempts to get the coins\n        throws on any error rather then return a false flag to minimize user errors\n\n        @param _from    source address\n        @param _to      target address\n        @param _value   transfer amount\n\n        @return true if the transfer was successful, false if it wasn't\n    */\n    function transferFrom(address _from, address _to, uint256 _value)\n        public\n        notThis(_to)\n        returns (bool success)\n    {\n        assert(super.transferFrom(_from, _to, _value));\n        return true;\n    }\n\n    /**\n        @dev deposit ether in the account\n    */\n    function() public payable {\n        deposit();\n    }\n}\n\ncontract SmartToken is ISmartToken, Owned, ERC20Token, TokenHolder {\n    string public version = '0.3';\n\n    bool public transfersEnabled = true;    // true if transfer/transferFrom are enabled, false if not\n\n    // triggered when a smart token is deployed - the _token address is defined for forward compatibility, in case we want to trigger the event from a factory\n    event NewSmartToken(address _token);\n    // triggered when the total supply is increased\n    event Issuance(uint256 _amount);\n    // triggered when the total supply is decreased\n    event Destruction(uint256 _amount);\n\n    /**\n        @dev constructor\n\n        @param _name       token name\n        @param _symbol     token short symbol, minimum 1 character\n        @param _decimals   for display purposes only\n    */\n    function SmartToken(string _name, string _symbol, uint8 _decimals)\n        public\n        ERC20Token(_name, _symbol, _decimals)\n    {\n        NewSmartToken(address(this));\n    }\n\n    // allows execution only when transfers aren't disabled\n    modifier transfersAllowed {\n        assert(transfersEnabled);\n        _;\n    }\n\n    /**\n        @dev disables/enables transfers\n        can only be called by the contract owner\n\n        @param _disable    true to disable transfers, false to enable them\n    */\n    function disableTransfers(bool _disable) public ownerOnly {\n        transfersEnabled = !_disable;\n    }\n\n    /**\n        @dev increases the token supply and sends the new tokens to an account\n        can only be called by the contract owner\n\n        @param _to         account to receive the new amount\n        @param _amount     amount to increase the supply by\n    */\n    function issue(address _to, uint256 _amount)\n        public\n        ownerOnly\n        validAddress(_to)\n        notThis(_to)\n    {\n        totalSupply = safeAdd(totalSupply, _amount);\n        balanceOf[_to] = safeAdd(balanceOf[_to], _amount);\n\n        Issuance(_amount);\n        Transfer(this, _to, _amount);\n    }\n\n    /**\n        @dev removes tokens from an account and decreases the token supply\n        can be called by the contract owner to destroy tokens from any account or by any holder to destroy tokens from his/her own account\n\n        @param _from       account to remove the amount from\n        @param _amount     amount to decrease the supply by\n    */\n    function destroy(address _from, uint256 _amount) public {\n        require(msg.sender == _from || msg.sender == owner); // validate input\n\n        balanceOf[_from] = safeSub(balanceOf[_from], _amount);\n        totalSupply = safeSub(totalSupply, _amount);\n\n        Transfer(_from, this, _amount);\n        Destruction(_amount);\n    }\n\n    // ERC20 standard method overrides with some extra functionality\n\n    /**\n        @dev send coins\n        throws on any error rather then return a false flag to minimize user errors\n        in addition to the standard checks, the function throws if transfers are disabled\n\n        @param _to      target address\n        @param _value   transfer amount\n\n        @return true if the transfer was successful, false if it wasn't\n    */\n    function transfer(address _to, uint256 _value) public transfersAllowed returns (bool success) {\n        assert(super.transfer(_to, _value));\n        return true;\n    }\n\n    /**\n        @dev an account/contract attempts to get the coins\n        throws on any error rather then return a false flag to minimize user errors\n        in addition to the standard checks, the function throws if transfers are disabled\n\n        @param _from    source address\n        @param _to      target address\n        @param _value   transfer amount\n\n        @return true if the transfer was successful, false if it wasn't\n    */\n    function transferFrom(address _from, address _to, uint256 _value) public transfersAllowed returns (bool success) {\n        assert(super.transferFrom(_from, _to, _value));\n        return true;\n    }\n}",
  "bytecode": "606060405260408051908101604052600981527f546f6b656e20302e310000000000000000000000000000000000000000000000602082015260029080516200004d929160200190620001ff565b50602060405190810160405260008152600390805162000072929160200190620001ff565b50602060405190810160405260008152600490805162000097929160200190620001ff565b506005805460ff19169055600060065560408051908101604052600381527f302e33000000000000000000000000000000000000000000000000000000000060208201526009908051620000f0929160200190620001ff565b50600a805460ff1916600117905534156200010a57600080fd5b6040516200106f3803806200106f8339810160405280805182019190602001805182019190602001805160008054600160a060020a03191633600160a060020a03161781559092508491508390839083511180156200016a575060008251115b15156200017657600080fd5b60038380516200018b929160200190620001ff565b506004828051620001a1929160200190620001ff565b506005805460ff191660ff92909216919091179055507ff4cd1f8571e8d9c97ffcb81558807ab73f9803d54de5da6a0420593c82a4a9f0905030604051600160a060020a03909116815260200160405180910390a1505050620002a4565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f106200024257805160ff191683800117855562000272565b8280016001018555821562000272579182015b828111156200027257825182559160200191906001019062000255565b506200028092915062000284565b5090565b620002a191905b808211156200028057600081556001016200028b565b90565b610dbb80620002b46000396000f3006060604052600436106101115763ffffffff7c010000000000000000000000000000000000000000000000000000000060003504166306fdde038114610116578063095ea7b3146101a05780631608f18f146101d657806318160ddd146101f057806323b872dd14610215578063313ce5671461023d57806354fd4d50146102665780635a3b7e42146102795780635e35359e1461028c57806370a08231146102b457806379ba5097146102d3578063867904b4146102e65780638da5cb5b1461030857806395d89b4114610337578063a24835d11461034a578063a9059cbb1461036c578063bef97c871461038e578063d4ee1d90146103a1578063dd62ed3e146103b4578063f2fde38b146103d9575b600080fd5b341561012157600080fd5b6101296103f8565b60405160208082528190810183818151815260200191508051906020019080838360005b8381101561016557808201518382015260200161014d565b50505050905090810190601f1680156101925780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b34156101ab57600080fd5b6101c2600160a060020a0360043516602435610496565b604051901515815260200160405180910390f35b34156101e157600080fd5b6101ee6004351515610553565b005b34156101fb57600080fd5b61020361057d565b60405190815260200160405180910390f35b341561022057600080fd5b6101c2600160a060020a0360043581169060243516604435610583565b341561024857600080fd5b6102506105b1565b60405160ff909116815260200160405180910390f35b341561027157600080fd5b6101296105ba565b341561028457600080fd5b610129610625565b341561029757600080fd5b6101ee600160a060020a0360043581169060243516604435610690565b34156102bf57600080fd5b610203600160a060020a0360043516610797565b34156102de57600080fd5b6101ee6107a9565b34156102f157600080fd5b6101ee600160a060020a0360043516602435610837565b341561031357600080fd5b61031b610945565b604051600160a060020a03909116815260200160405180910390f35b341561034257600080fd5b610129610954565b341561035557600080fd5b6101ee600160a060020a03600435166024356109bf565b341561037757600080fd5b6101c2600160a060020a0360043516602435610aaa565b341561039957600080fd5b6101c2610ad6565b34156103ac57600080fd5b61031b610adf565b34156103bf57600080fd5b610203600160a060020a0360043581169060243516610aee565b34156103e457600080fd5b6101ee600160a060020a0360043516610b0b565b60038054600181600116156101000203166002900480601f01602080910402602001604051908101604052809291908181526020018280546001816001161561010002031660029004801561048e5780601f106104635761010080835404028352916020019161048e565b820191906000526020600020905b81548152906001019060200180831161047157829003601f168201915b505050505081565b600082600160a060020a03811615156104ae57600080fd5b8215806104de5750600160a060020a03338116600090815260086020908152604080832093881683529290522054155b15156104e957600080fd5b600160a060020a03338116600081815260086020908152604080832094891680845294909152908190208690557f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b9259086905190815260200160405180910390a35060019392505050565b60005433600160a060020a0390811691161461056b57fe5b600a805460ff19169115919091179055565b60065481565b600a5460009060ff16151561059457fe5b61059f848484610b6d565b15156105a757fe5b5060019392505050565b60055460ff1681565b60098054600181600116156101000203166002900480601f01602080910402602001604051908101604052809291908181526020018280546001816001161561010002031660029004801561048e5780601f106104635761010080835404028352916020019161048e565b60028054600181600116156101000203166002900480601f01602080910402602001604051908101604052809291908181526020018280546001816001161561010002031660029004801561048e5780601f106104635761010080835404028352916020019161048e565b60005433600160a060020a039081169116146106a857fe5b82600160a060020a03811615156106be57600080fd5b82600160a060020a03811615156106d457600080fd5b8330600160a060020a031681600160a060020a0316141515156106f657600080fd5b85600160a060020a031663a9059cbb86866000604051602001526040517c010000000000000000000000000000000000000000000000000000000063ffffffff8516028152600160a060020a0390921660048301526024820152604401602060405180830381600087803b151561076c57600080fd5b6102c65a03f1151561077d57600080fd5b50505060405180519050151561078f57fe5b505050505050565b60076020526000908152604090205481565b60015433600160a060020a039081169116146107c457600080fd5b600154600054600160a060020a0391821691167f343765429aea5a34b3ff6a3785a98a5abb2597aca87bfbb58632c173d585373a60405160405180910390a3600180546000805473ffffffffffffffffffffffffffffffffffffffff19908116600160a060020a03841617909155169055565b60005433600160a060020a0390811691161461084f57fe5b81600160a060020a038116151561086557600080fd5b8230600160a060020a031681600160a060020a03161415151561088757600080fd5b61089360065484610c8d565b600655600160a060020a0384166000908152600760205260409020546108b99084610c8d565b600160a060020a03851660009081526007602052604090819020919091557f9386c90217c323f58030f9dadcbc938f807a940f4ff41cd4cead9562f5da7dc39084905190815260200160405180910390a183600160a060020a031630600160a060020a0316600080516020610d708339815191528560405190815260200160405180910390a350505050565b600054600160a060020a031681565b60048054600181600116156101000203166002900480601f01602080910402602001604051908101604052809291908181526020018280546001816001161561010002031660029004801561048e5780601f106104635761010080835404028352916020019161048e565b81600160a060020a031633600160a060020a031614806109ed575060005433600160a060020a039081169116145b15156109f857600080fd5b600160a060020a038216600090815260076020526040902054610a1b9082610ca3565b600160a060020a038316600090815260076020526040902055600654610a419082610ca3565b600655600160a060020a03308116908316600080516020610d708339815191528360405190815260200160405180910390a37f9a1b418bc061a5d80270261562e6986a35d995f8051145f277be16103abd34538160405190815260200160405180910390a15050565b600a5460009060ff161515610abb57fe5b610ac58383610cb5565b1515610acd57fe5b50600192915050565b600a5460ff1681565b600154600160a060020a031681565b600860209081526000928352604080842090915290825290205481565b60005433600160a060020a03908116911614610b2357fe5b600054600160a060020a0382811691161415610b3e57600080fd5b6001805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b600083600160a060020a0381161515610b8557600080fd5b83600160a060020a0381161515610b9b57600080fd5b600160a060020a0380871660009081526008602090815260408083203390941683529290522054610bcc9085610ca3565b600160a060020a038088166000818152600860209081526040808320339095168352938152838220949094559081526007909252902054610c0d9085610ca3565b600160a060020a038088166000908152600760205260408082209390935590871681522054610c3c9085610c8d565b600160a060020a0380871660008181526007602052604090819020939093559190881690600080516020610d708339815191529087905190815260200160405180910390a350600195945050505050565b600082820183811015610c9c57fe5b9392505050565b600081831015610caf57fe5b50900390565b600082600160a060020a0381161515610ccd57600080fd5b600160a060020a033316600090815260076020526040902054610cf09084610ca3565b600160a060020a033381166000908152600760205260408082209390935590861681522054610d1f9084610c8d565b600160a060020a038086166000818152600760205260409081902093909355913390911690600080516020610d708339815191529086905190815260200160405180910390a350600193925050505600ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa165627a7a7230582063810f0f98db38451a7bfadfd00ef8a70ba8a5cbc99d44293a06f3395abc02f90029000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000001543565420536d61727420546f6b656e2052656c617900000000000000000000000000000000000000000000000000000000000000000000000000000000000006435654424e540000000000000000000000000000000000000000000000000000",
  "constructorArguments": "000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000001543565420536d61727420546f6b656e2052656c617900000000000000000000000000000000000000000000000000000000000000000000000000000000000006435654424e540000000000000000000000000000000000000000000000000000"
}