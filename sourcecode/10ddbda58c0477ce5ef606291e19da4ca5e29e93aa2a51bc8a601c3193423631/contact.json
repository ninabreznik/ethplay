{
  "address": "0xae33185575973ee122793b5703273e502caee424",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "ClashHash",
  "compilerVersion": "v0.4.24+commit.e67f0147",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2018-12-21\n*/\n\npragma solidity ^0.4.24;\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, reverts on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b);\n\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n  /**\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  /**\n  * @dev Adds two numbers, reverts on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a);\n\n    return c;\n  }\n\n  /**\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n  * reverts when dividing by zero.\n  */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0);\n    return a % b;\n  }\n}\n\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address private _owner;\n\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  constructor() internal {\n    _owner = msg.sender;\n    emit OwnershipTransferred(address(0), _owner);\n  }\n\n  /**\n   * @return the address of the owner.\n   */\n  function owner() public view returns(address) {\n    return _owner;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(isOwner());\n    _;\n  }\n\n  /**\n   * @return true if `msg.sender` is the owner of the contract.\n   */\n  function isOwner() public view returns(bool) {\n    return msg.sender == _owner;\n  }\n\n  /**\n   * @dev Allows the current owner to relinquish control of the contract.\n   * @notice Renouncing to ownership will leave the contract without an owner.\n   * It will not be possible to call the functions with the `onlyOwner`\n   * modifier anymore.\n   */\n  function renounceOwnership() public onlyOwner {\n    emit OwnershipTransferred(_owner, address(0));\n    _owner = address(0);\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    _transferOwnership(newOwner);\n  }\n\n  /**\n   * @dev Transfers control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function _transferOwnership(address newOwner) internal {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(_owner, newOwner);\n    _owner = newOwner;\n  }\n}\n\n// File: solidity-rlp/contracts/RLPReader.sol\n\n/*\n* @author Hamdi Allam [emailÂ protected]\n* Please reach out with any questions or concerns\n*/\npragma solidity ^0.4.24;\n\nlibrary RLPReader {\n    uint8 constant STRING_SHORT_START = 0x80;\n    uint8 constant STRING_LONG_START  = 0xb8;\n    uint8 constant LIST_SHORT_START   = 0xc0;\n    uint8 constant LIST_LONG_START    = 0xf8;\n\n    uint8 constant WORD_SIZE = 32;\n\n    struct RLPItem {\n        uint len;\n        uint memPtr;\n    }\n\n    /*\n    * @param item RLP encoded bytes\n    */\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n        if (item.length == 0) \n            return RLPItem(0, 0);\n\n        uint memPtr;\n        assembly {\n            memPtr := add(item, 0x20)\n        }\n\n        return RLPItem(item.length, memPtr);\n    }\n\n    /*\n    * @param item RLP encoded list in bytes\n    */\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory result) {\n        require(isList(item));\n\n        uint items = numItems(item);\n        result = new RLPItem[](items);\n\n        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint dataLen;\n        for (uint i = 0; i < items; i++) {\n            dataLen = _itemLength(memPtr);\n            result[i] = RLPItem(dataLen, memPtr); \n            memPtr = memPtr + dataLen;\n        }\n    }\n\n    /*\n    * Helpers\n    */\n\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\n    function isList(RLPItem memory item) internal pure returns (bool) {\n        uint8 byte0;\n        uint memPtr = item.memPtr;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < LIST_SHORT_START)\n            return false;\n        return true;\n    }\n\n    // @return number of payload items inside an encoded list.\n    function numItems(RLPItem memory item) internal pure returns (uint) {\n        uint count = 0;\n        uint currPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint endPtr = item.memPtr + item.len;\n        while (currPtr < endPtr) {\n           currPtr = currPtr + _itemLength(currPtr); // skip over an item\n           count++;\n        }\n\n        return count;\n    }\n\n    // @return entire rlp item byte length\n    function _itemLength(uint memPtr) internal pure returns (uint len) {\n        uint byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START)\n            return 1;\n        \n        else if (byte0 < STRING_LONG_START)\n            return byte0 - STRING_SHORT_START + 1;\n\n        else if (byte0 < LIST_SHORT_START) {\n            assembly {\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\n                memPtr := add(memPtr, 1) // skip over the first byte\n                \n                /* 32 byte word size */\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\n                len := add(dataLen, add(byteLen, 1))\n            }\n        }\n\n        else if (byte0 < LIST_LONG_START) {\n            return byte0 - LIST_SHORT_START + 1;\n        } \n\n        else {\n            assembly {\n                let byteLen := sub(byte0, 0xf7)\n                memPtr := add(memPtr, 1)\n\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\n                len := add(dataLen, add(byteLen, 1))\n            }\n        }\n    }\n\n    // @return number of bytes until the data\n    function _payloadOffset(uint memPtr) internal pure returns (uint) {\n        uint byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) \n            return 0;\n        else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START))\n            return 1;\n        else if (byte0 < LIST_SHORT_START)  // being explicit\n            return byte0 - (STRING_LONG_START - 1) + 1;\n        else\n            return byte0 - (LIST_LONG_START - 1) + 1;\n    }\n\n    /** RLPItem conversions into data types **/\n\n    // @returns raw rlp encoding in bytes\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes) {\n        bytes memory result = new bytes(item.len);\n        \n        uint ptr;\n        assembly {\n            ptr := add(0x20, result)\n        }\n\n        copy(item.memPtr, ptr, item.len);\n        return result;\n    }\n\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\n        require(item.len == 1, \"Invalid RLPItem. Booleans are encoded in 1 byte\");\n        uint result;\n        uint memPtr = item.memPtr;\n        assembly {\n            result := byte(0, mload(memPtr))\n        }\n\n        return result == 0 ? false : true;\n    }\n\n    function toAddress(RLPItem memory item) internal pure returns (address) {\n        // 1 byte for the length prefix according to RLP spec\n        require(item.len <= 21, \"Invalid RLPItem. Addresses are encoded in 20 bytes or less\");\n\n        return address(toUint(item));\n    }\n\n    function toUint(RLPItem memory item) internal pure returns (uint) {\n        uint offset = _payloadOffset(item.memPtr);\n        uint len = item.len - offset;\n        uint memPtr = item.memPtr + offset;\n\n        uint result;\n        assembly {\n            result := div(mload(memPtr), exp(256, sub(32, len))) // shift to the correct location\n        }\n\n        return result;\n    }\n\n    function toBytes(RLPItem memory item) internal pure returns (bytes) {\n        uint offset = _payloadOffset(item.memPtr);\n        uint len = item.len - offset; // data length\n        bytes memory result = new bytes(len);\n\n        uint destPtr;\n        assembly {\n            destPtr := add(0x20, result)\n        }\n\n        copy(item.memPtr + offset, destPtr, len);\n        return result;\n    }\n\n\n    /*\n    * @param src Pointer to source\n    * @param dest Pointer to destination\n    * @param len Amount of memory to copy from the source\n    */\n    function copy(uint src, uint dest, uint len) internal pure {\n        // copy as many word sizes as possible\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n\n            src += WORD_SIZE;\n            dest += WORD_SIZE;\n        }\n\n        // left over bytes. Mask is used to remove unwanted bytes from the word\n        uint mask = 256 ** (WORD_SIZE - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask)) // zero out src\n            let destpart := and(mload(dest), mask) // retrieve the bytes\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n}\n\n// File: contracts/BetStorage.sol\n\n/**\n * @title ClashHash\n * This product is protected under license.  Any unauthorized copy, modification, or use without\n * express written consent from the creators is prohibited.\n */\n\n\n\n\ncontract BetStorage is Ownable {\n    using SafeMath for uint256;\n\n    mapping(address => mapping(address => uint256)) public bets;\n    mapping(address => uint256) public betsSumByOption;\n    address public wonOption;\n\n    event BetAdded(address indexed user, address indexed option, uint256 value);\n    event Finalized(address indexed option);\n    event RewardClaimed(address indexed user, uint256 reward);\n\n    function addBet(address user, address option) public payable onlyOwner {\n        require(msg.value > 0, \"Empty bet is not allowed\");\n        require(option != address(0), \"Option should not be zero\");\n\n        bets[user][option] = bets[user][option].add(msg.value);\n        betsSumByOption[option] = betsSumByOption[option].add(msg.value);\n        emit BetAdded(user, option, msg.value);\n    }\n\n    function finalize(address option, address admin) public onlyOwner {\n        require(wonOption == address(0), \"Finalization could be called only once\");\n        require(option != address(0), \"Won option should not be zero\");\n\n        wonOption = option;\n        emit Finalized(option);\n\n        if (betsSumByOption[option] == 0) {\t\t\n            selfdestruct(admin);\t\t\n        }\t\t\n    }\n\n    function rewardFor(address user) public view returns(uint256 reward) {\n        if (bets[user][wonOption] > 0) {\n            reward = address(this).balance\n                .mul(bets[user][wonOption])\n                .div(betsSumByOption[wonOption]);\n        }\n    }\n\n    function rewards(\n        address user,\n        address referrer,\n        uint256 referrerFee,\n        uint256 adminFee\n    )\n        public\n        view\n        returns(uint256 userReward, uint256 referrerReward, uint256 adminReward)\n    {\n        userReward = rewardFor(user);\n        adminReward = userReward.sub(bets[user][wonOption]).mul(adminFee).div(100);\n\n        if (referrer != address(0)) {\n            referrerReward = adminReward.mul(referrerFee).div(100);\n            adminReward = adminReward.sub(referrerReward);\n        }\n\n        userReward = userReward.sub(adminReward).sub(referrerReward);\n    }\n\n    function claimReward(\n        address user,\n        address admin,\n        uint256 adminFee,\n        address referrer,\n        uint256 referrerFee\n    )\n        public\n        onlyOwner\n    {\n        require(wonOption != address(0), \"Round not yet finalized\");\n\n        (uint256 userReward, uint256 referrerReward, uint256 adminReward) = rewards(\n            user,\n            referrer,\n            referrerFee,\n            adminFee\n        );\n        require(userReward > 0, \"Reward was claimed previously or never existed\");\n        \n        betsSumByOption[wonOption] = betsSumByOption[wonOption].sub(bets[user][wonOption]);\n        bets[user][wonOption] = 0;\n\n        if (referrerReward > 0) {\n            referrer.send(referrerReward);\n        }\n\n        if (adminReward > 0) {\n            admin.send(adminReward);\n        }\n\n        user.transfer(userReward);\n        emit RewardClaimed(user, userReward);\n\n        if (betsSumByOption[wonOption] == 0) {\n            selfdestruct(admin);\n        }\n    }\n}\n\n// File: contracts/BlockHash.sol\n\ncontract BlockHash {\n    using SafeMath for uint256;\n    using RLPReader for RLPReader.RLPItem;\n\n    mapping (uint256 => bytes32) private _hashes;\n\n    function blockhashes(\n        uint256 blockNumber\n    )\n        public\n        view\n        returns(bytes32)\n    {\n        if (blockNumber >= block.number.sub(256)) {\n            return blockhash(blockNumber);\n        }\n\n        return _hashes[blockNumber];\n    }\n\n    function addBlocks(\n        uint256 blockNumber,\n        bytes blocksData,\n        uint256[] starts\n    )\n        public\n    {\n        require(starts.length > 0 && starts[starts.length - 1] == blocksData.length, \"Wrong starts argument\");\n\n        bytes32 expectedHash = blockhashes(blockNumber);\n        for (uint i = 0; i < starts.length - 1; i++) {\n            uint256 offset = starts[i];\n            uint256 length = starts[i + 1].sub(starts[i]);\n            bytes32 result;\n            uint256 ptr;\n            assembly {\n                ptr := add(add(blocksData, 0x20), offset)\n                result := keccak256(ptr, length)\n            }\n\n            require(result == expectedHash, \"Blockhash didn't match\");\n            expectedHash = bytes32(RLPReader.RLPItem({len: length, memPtr: ptr}).toList()[0].toUint());\n        }\n        \n        uint256 index = blockNumber.add(1).sub(starts.length);\n        if (_hashes[index] == 0) {\n            _hashes[index] = expectedHash;\n        }\n    }\n}\n\n// File: contracts/ClashHash.sol\n\n/**\n * @title ClashHash\n * This product is protected under license.  Any unauthorized copy, modification, or use without\n * express written consent from the creators is prohibited.\n */\n\ncontract ClashHash is Ownable {\n    using SafeMath for uint256;\n    using RLPReader for bytes;\n    using RLPReader for RLPReader.RLPItem;\n\n    struct Round {\n        BetStorage records;\n        uint256 betsCount;\n        uint256 totalReward;\n        address winner;\n    }\n\n    uint256 public minBet = 0.001 ether;\n    uint256 constant public MIN_BLOCKS_BEFORE_ROUND = 10;\n    uint256 constant public MIN_BLOCKS_AFTER_ROUND = 10;\n    uint256 constant public MAX_BLOCKS_AFTER_ROUND = 256;\n\n    uint256 public adminFee = 5;\n    uint256 public referrerFee = 50;\n\n    mapping(address => address) public referrers;\n    mapping(uint256 => Round) public rounds;\n    BlockHash public _blockStorage;\n\n    //\n\n    event RoundCreated(uint256 indexed blockNumber, address contractAddress);\n    event RoundBetAdded(uint256 indexed blockNumber, address indexed user, address indexed option, uint256 value);\n    event RoundFinalized(uint256 indexed blockNumber, address indexed option);\n    event RewardClaimed(uint256 indexed blockNumber, address indexed user, address indexed winner, uint256 reward);\n\n    event NewReferral(address indexed user, address indexed referrer);\n    event ReferralReward(address indexed user, address indexed referrer, uint256 value);\n\n    event AdminFeeUpdate(uint256 oldFee, uint256 newFee);\n    event ReferrerFeeUpdate(uint256 oldFee, uint256 newFee);\n    event MinBetUpdate(uint256 oldMinBet, uint256 newMinBet);\n\n    //\n\n    constructor (BlockHash blockStorage) public {\n        _blockStorage = blockStorage;\n    }\n\n    //\n\n    function setReferrerFee(uint256 newFee) public onlyOwner {\n        emit ReferrerFeeUpdate(referrerFee, newFee);\n        referrerFee = newFee;\n    }\n\n    function setAdminFee(uint256 newFee) public onlyOwner {\n        emit AdminFeeUpdate(adminFee, newFee);\n        adminFee = newFee;\n    }\n\n    function setMinBet(uint256 newMinBet) public onlyOwner {\n        emit MinBetUpdate(minBet, newMinBet);\n        minBet = newMinBet;\n    }\n\n    /**\n     * @param referrer Who has invited the user.\n     */\n    function addReferral(address referrer) public {\n        require(referrer != address(0), \"Invalid referrer address\");\n        require(referrer != msg.sender, \"Different addresses required\");\n        require(referrers[msg.sender] == address(0), \"User has referrer already\");\n\n        referrers[msg.sender] = referrer;\n        emit NewReferral(msg.sender, referrer);\n    }\n\n    function addBet(uint256 blockNumber, address option) public payable {\n        require(msg.value >= minBet, \"Bet amount is too low\");\n        require(block.number <= blockNumber.sub(MIN_BLOCKS_BEFORE_ROUND), \"It's too late\");\n\n        Round storage round = rounds[blockNumber];\n        if (round.records == address(0)) {\n            round.records = new BetStorage();\n            emit RoundCreated(blockNumber, round.records);\n        }\n\n        round.betsCount += 1;\n        round.totalReward = round.totalReward.add(msg.value);\n        round.records.addBet.value(msg.value)(msg.sender, option);\n\n        emit RoundBetAdded(\n            blockNumber,\n            msg.sender,\n            option,\n            msg.value\n        );\n    }\n\n    function addBetWithReferrer(\n        uint256 blockNumber,\n        address option,\n        address referrer\n    )\n        public\n        payable\n    {\n        addReferral(referrer);\n        addBet(blockNumber, option);\n    }\n\n    function claimRewardWithBlockData(uint256 blockNumber, bytes blockData) public {\n        if (blockData.length > 0 && rounds[blockNumber].winner == address(0)) {\n            addBlockData(blockNumber, blockData);\n        }\n\n        claimRewardForUser(blockNumber, msg.sender);\n    }\n\n    function claimRewardForUser(uint256 blockNumber, address user) public {\n        Round storage round = rounds[blockNumber];\n        require(round.winner != address(0), \"Round not yet finished\");\n        require(address(round.records).balance > 0, \"Round prizes are already distributed\");\n\n        (uint256 userReward, uint256 referrerReward,) = round.records.rewards(\n            user,\n            referrers[user],\n            referrerFee,\n            adminFee\n        );\n        round.records.claimReward(user, owner(), adminFee, referrers[user], referrerFee);\n\n        emit RewardClaimed(blockNumber, user, round.winner, userReward);\n\n        if (referrerReward > 0) {\n            emit ReferralReward(user, referrers[user], referrerReward);\n        }\n    }\n\n    function addBlockData(uint256 blockNumber, bytes blockData) public {\n        Round storage round = rounds[blockNumber];\n\n        require(round.winner == address(0), \"Winner was already submitted\");\n        require(block.number <= blockNumber.add(MAX_BLOCKS_AFTER_ROUND), \"It's too late, 256 blocks gone\");\n        require(block.number >= blockNumber.add(MIN_BLOCKS_AFTER_ROUND), \"Wait at least 10 blocks\");\n\n        address blockBeneficiary = _readBlockBeneficiary(blockNumber, blockData);\n\n        round.winner = blockBeneficiary;\n        round.records.finalize(blockBeneficiary, owner());\n        emit RoundFinalized(blockNumber, blockBeneficiary);\n    }\n\n    function _readBlockBeneficiary(\n        uint256 blockNumber,\n        bytes blockData\n    )\n        internal\n        view\n        returns(address)\n    {\n        require(keccak256(blockData) == _blockStorage.blockhashes(blockNumber), \"Block data isn't valid\");\n        RLPReader.RLPItem[] memory items = blockData.toRlpItem().toList();\n        return items[2].toAddress();\n    }\n}",
  "bytecode": "608060405266038d7ea4c680006001556005600255603260035534801561002557600080fd5b506040516020806122bc833981016040819052905160008054600160a060020a03191633178082559192600160a060020a0392909216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0908290a360068054600160a060020a031916600160a060020a039290921691909117905561220c806100b06000396000f30060806040526004361061010e5763ffffffff60e060020a6000350416630cf56f3f81146101135780630eb15f0f146101325780631483fc8c14610190578063312a1294146101ee578063473f1803146102155780634a3b68cc146102395780636e88a7bd14610276578063715018a61461028b57806383f69eed146101ee57806388ea41b9146102a05780638beb60b6146102b85780638c65c81f146102d05780638da5cb5b1461031c5780638f32d59b146103315780639619367d1461035a5780639eb038311461036f578063a0be06f914610384578063b7acdca614610399578063b8f3c22f146103b0578063e8aca46a146103c5578063f2fde38b146103e6578063f81a95db14610407575b600080fd5b610130600435600160a060020a036024358116906044351661041f565b005b34801561013e57600080fd5b5060408051602060046024803582810135601f81018590048502860185019096528585526101309583359536956044949193909101919081908401838280828437509497506104379650505050505050565b34801561019c57600080fd5b5060408051602060046024803582810135601f810185900485028601850190965285855261013095833595369560449491939091019190819084018382808284375094975061047d9650505050505050565b3480156101fa57600080fd5b506102036106c7565b60408051918252519081900360200190f35b34801561022157600080fd5b50610130600435600160a060020a03602435166106cc565b34801561024557600080fd5b5061025a600160a060020a03600435166109f2565b60408051600160a060020a039092168252519081900360200190f35b34801561028257600080fd5b50610203610a0d565b34801561029757600080fd5b50610130610a13565b3480156102ac57600080fd5b50610130600435610a7d565b3480156102c457600080fd5b50610130600435610ad2565b3480156102dc57600080fd5b506102e8600435610b27565b60408051600160a060020a039586168152602081019490945283810192909252909216606082015290519081900360800190f35b34801561032857600080fd5b5061025a610b59565b34801561033d57600080fd5b50610346610b68565b604080519115158252519081900360200190f35b34801561036657600080fd5b50610203610b79565b34801561037b57600080fd5b50610203610b7f565b34801561039057600080fd5b50610203610b85565b610130600435600160a060020a0360243516610b8b565b3480156103bc57600080fd5b5061025a610dee565b3480156103d157600080fd5b50610130600160a060020a0360043516610dfd565b3480156103f257600080fd5b50610130600160a060020a0360043516610f90565b34801561041357600080fd5b50610130600435610faf565b61042881610dfd565b6104328383610b8b565b505050565b600081511180156104605750600082815260056020526040902060030154600160a060020a0316155b1561046f5761046f828261047d565b61047982336106cc565b5050565b60008281526005602052604081206003810154909190600160a060020a0316156104f1576040805160e560020a62461bcd02815260206004820152601c60248201527f57696e6e65722077617320616c7265616479207375626d697474656400000000604482015290519081900360640190fd5b6105038461010063ffffffff61100416565b43111561055a576040805160e560020a62461bcd02815260206004820152601e60248201527f4974277320746f6f206c6174652c2032353620626c6f636b7320676f6e650000604482015290519081900360640190fd5b61056b84600a63ffffffff61100416565b4310156105c2576040805160e560020a62461bcd02815260206004820152601760248201527f57616974206174206c6561737420313020626c6f636b73000000000000000000604482015290519081900360640190fd5b6105cc848461101d565b60038301805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a038381169190911790915583549192501663bcdf569b8261060f610b59565b6040518363ffffffff1660e060020a0281526004018083600160a060020a0316600160a060020a0316815260200182600160a060020a0316600160a060020a0316815260200192505050600060405180830381600087803b15801561067357600080fd5b505af1158015610687573d6000803e3d6000fd5b5050604051600160a060020a03841692508691507f9ca7bb3ddcb08cddff325383cad687ad15d36fdc27ac79d8a580cd8aa7c4dacc90600090a350505050565b600a81565b600082815260056020526040812060038101549091908190600160a060020a03161515610743576040805160e560020a62461bcd02815260206004820152601660248201527f526f756e64206e6f74207965742066696e697368656400000000000000000000604482015290519081900360640190fd5b82546000600160a060020a0390911631116107cd576040805160e560020a62461bcd028152602060048201526024808201527f526f756e64207072697a65732061726520616c7265616479206469737472696260448201527f7574656400000000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b8254600160a060020a0385811660008181526004602081905260408083205460035460025483517f47f3dde500000000000000000000000000000000000000000000000000000000815294850196909652908616602484015260448301526064820193909352915192909316926347f3dde5926084808401936060939083900390910190829087803b15801561086257600080fd5b505af1158015610876573d6000803e3d6000fd5b505050506040513d606081101561088c57600080fd5b50805160209091015184549193509150600160a060020a031663464d1208856108b3610b59565b600254600160a060020a03808a16600090815260046020819052604080832054600354825160e060020a63ffffffff8c16028152988616938901939093529584166024880152604487019490945293909116606485015260848401929092525160a48084019382900301818387803b15801561092e57600080fd5b505af1158015610942573d6000803e3d6000fd5b505050506003830154604080518481529051600160a060020a039283169287169188917fd7566a1f449b7ee89a6af29f319e117c231ea862057eb65395ca2bf70283b1c89181900360200190a460008111156109eb57600160a060020a0380851660008181526004602090815260409182902054825186815292519416937f53958b9c644a1d5529da7c36929d59417eb9a996f08e02a52632bfe20c92ef489281900390910190a35b5050505050565b600460205260009081526040902054600160a060020a031681565b60035481565b610a1b610b68565b1515610a2657600080fd5b60008054604051600160a060020a03909116907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0908390a36000805473ffffffffffffffffffffffffffffffffffffffff19169055565b610a85610b68565b1515610a9057600080fd5b600154604080519182526020820183905280517f1a28909f8219e79c83c8bfa182dc104f7bc7864a120924952afe956c07374d2b9281900390910190a1600155565b610ada610b68565b1515610ae557600080fd5b600254604080519182526020820183905280517fef692ea50bf7088692060ccd423bffe68aae228c457cfc564910d36e556875e19281900390910190a1600255565b6005602052600090815260409020805460018201546002830154600390930154600160a060020a039283169391921684565b600054600160a060020a031690565b600054600160a060020a0316331490565b60015481565b61010081565b60025481565b600154600090341015610be8576040805160e560020a62461bcd02815260206004820152601560248201527f42657420616d6f756e7420697320746f6f206c6f770000000000000000000000604482015290519081900360640190fd5b610bf983600a63ffffffff6111ab16565b431115610c50576040805160e560020a62461bcd02815260206004820152600d60248201527f4974277320746f6f206c61746500000000000000000000000000000000000000604482015290519081900360640190fd5b5060008281526005602052604090208054600160a060020a03161515610cf957610c7861159e565b604051809103906000f080158015610c94573d6000803e3d6000fd5b508154600160a060020a0391821673ffffffffffffffffffffffffffffffffffffffff199091161780835560408051919092168152905184917f238eeac651d649604615173573d5b8a916ef1f91e8e7a556b442d5f6284dd21d919081900360200190a25b6001818101805490910190556002810154610d1a903463ffffffff61100416565b60028201558054604080517f12dd9b94000000000000000000000000000000000000000000000000000000008152336004820152600160a060020a038581166024830152915191909216916312dd9b9491349160448082019260009290919082900301818588803b158015610d8e57600080fd5b505af1158015610da2573d6000803e3d6000fd5b5050604080513481529051600160a060020a03871694503393508792507f614f1f83c920769190e84c46afa11c89f75926d8acc5efcccb5d9f4c26e607189181900360200190a4505050565b600654600160a060020a031681565b600160a060020a0381161515610e5d576040805160e560020a62461bcd02815260206004820152601860248201527f496e76616c696420726566657272657220616464726573730000000000000000604482015290519081900360640190fd5b600160a060020a038116331415610ebe576040805160e560020a62461bcd02815260206004820152601c60248201527f446966666572656e742061646472657373657320726571756972656400000000604482015290519081900360640190fd5b33600090815260046020526040902054600160a060020a031615610f2c576040805160e560020a62461bcd02815260206004820152601960248201527f557365722068617320726566657272657220616c726561647900000000000000604482015290519081900360640190fd5b33600081815260046020526040808220805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a03861690811790915590519092917f965e581fd2224ce85185c5f48cfbcc00e17fa216f970b274fc724888f6b8994a91a350565b610f98610b68565b1515610fa357600080fd5b610fac816111c2565b50565b610fb7610b68565b1515610fc257600080fd5b600354604080519182526020820183905280517f6df0d8e0d09e2d9fcf7e36a5c54c6d21d8867f77a40fae28354ab435cf242a369281900390910190a1600355565b60008282018381101561101657600080fd5b9392505050565b600654604080517fbb95d992000000000000000000000000000000000000000000000000000000008152600481018590529051600092606092600160a060020a039091169163bb95d9929160248082019260209290919082900301818887803b15801561108957600080fd5b505af115801561109d573d6000803e3d6000fd5b505050506040513d60208110156110b357600080fd5b50516040518451859190819060208401908083835b602083106110e75780518252601f1990920191602091820191016110c8565b6001836020036101000a03801982511681845116808217855250505050505090500191505060405180910390206000191614151561116f576040805160e560020a62461bcd02815260206004820152601660248201527f426c6f636b20646174612069736e27742076616c696400000000000000000000604482015290519081900360640190fd5b61118061117b8461123f565b611290565b90506111a381600281518110151561119457fe5b90602001906020020151611363565b949350505050565b600080838311156111bb57600080fd5b5050900390565b600160a060020a03811615156111d757600080fd5b60008054604051600160a060020a03808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a36000805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b6112476115ae565b600082516000141561126e576040805180820190915260008082526020820152915061128a565b5050604080518082019091528151815260208281019082018190525b50919050565b60606000806000806112a1866113f5565b15156112ac57600080fd5b6112b586611424565b9350836040519080825280602002602001820160405280156112f157816020015b6112de6115ae565b8152602001906001900390816112d65790505b5094506113018660200151611474565b8660200151019250600090505b8381101561135a5761131f836114d7565b9150604080519081016040528083815260200184815250858281518110151561134457fe5b602090810290910101529181019160010161130e565b50505050919050565b8051600090601510156113e6576040805160e560020a62461bcd02815260206004820152603a60248201527f496e76616c696420524c504974656d2e2041646472657373657320617265206560448201527f6e636f64656420696e203230206279746573206f72206c657373000000000000606482015290519081900360840190fd5b6113ef82611568565b92915050565b6020810151805160009190821a9060c060ff83161015611418576000925061141d565b600192505b5050919050565b6000806000806000925061143b8560200151611474565b6020860151865191810193500190505b8082101561146b5761145c826114d7565b6001909301929091019061144b565b50909392505050565b8051600090811a608081101561148d576000915061128a565b60b88110806114a8575060c081108015906114a8575060f881105b156114b6576001915061128a565b60c08110156114cb5760b5198101915061128a565b60f5198101915061128a565b8051600090811a60808110156114f0576001915061128a565b60b881101561150557607e198101915061128a565b60c08110156115325760b78103600184019350806020036101000a8451046001820181019350505061128a565b60f88110156115475760be198101915061128a565b60019290920151602083900360f7016101000a900490910160f51901919050565b600080600080600061157d8660200151611474565b86516020978801518201519190039096036101000a90950495945050505050565b604051610c1b806115c683390190565b60408051808201909152600080825260208201529056006080604081905260008054600160a060020a0319163317808255600160a060020a0316917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0908290a3610bc4806100576000396000f3006080604052600436106100b95763ffffffff7c010000000000000000000000000000000000000000000000000000000060003504166312dd9b9481146100be57806320bf7d9b146100da578063401748d91461010d578063464d12081461013457806347f3dde5146101685780634a008d5c146101b3578063661edfee146101e4578063715018a6146102055780638da5cb5b1461021a5780638f32d59b1461022f578063bcdf569b14610258578063f2fde38b1461027f575b600080fd5b6100d8600160a060020a03600435811690602435166102a0565b005b3480156100e657600080fd5b506100fb600160a060020a036004351661043f565b60408051918252519081900360200190f35b34801561011957600080fd5b506100fb600160a060020a0360043581169060243516610451565b34801561014057600080fd5b506100d8600160a060020a03600435811690602435811690604435906064351660843561046e565b34801561017457600080fd5b50610195600160a060020a0360043581169060243516604435606435610705565b60408051938452602084019290925282820152519081900360600190f35b3480156101bf57600080fd5b506101c86107dc565b60408051600160a060020a039092168252519081900360200190f35b3480156101f057600080fd5b506100fb600160a060020a03600435166107eb565b34801561021157600080fd5b506100d8610870565b34801561022657600080fd5b506101c86108da565b34801561023b57600080fd5b506102446108e9565b604080519115158252519081900360200190f35b34801561026457600080fd5b506100d8600160a060020a03600435811690602435166108fa565b34801561028b57600080fd5b506100d8600160a060020a0360043516610a77565b6102a86108e9565b15156102b357600080fd5b6000341161030b576040805160e560020a62461bcd02815260206004820152601860248201527f456d70747920626574206973206e6f7420616c6c6f7765640000000000000000604482015290519081900360640190fd5b600160a060020a038116151561036b576040805160e560020a62461bcd02815260206004820152601960248201527f4f7074696f6e2073686f756c64206e6f74206265207a65726f00000000000000604482015290519081900360640190fd5b600160a060020a038083166000908152600160209081526040808320938516835292905220546103a1903463ffffffff610a9616565b600160a060020a03808416600090815260016020908152604080832093861683529281528282209390935560029092529020546103e4903463ffffffff610a9616565b600160a060020a0380831660008181526002602090815260409182902094909455805134815290519193928616927f014952e2ce3b8fa83537611793c762bcbc39f3ab3d68b71721aa4ffdada2fb3e92918290030190a35050565b60026020526000908152604090205481565b600160209081526000928352604080842090915290825290205481565b600080600061047b6108e9565b151561048657600080fd5b600354600160a060020a031615156104e8576040805160e560020a62461bcd02815260206004820152601760248201527f526f756e64206e6f74207965742066696e616c697a6564000000000000000000604482015290519081900360640190fd5b6104f488868689610705565b9194509250905060008311610579576040805160e560020a62461bcd02815260206004820152602e60248201527f5265776172642077617320636c61696d65642070726576696f75736c79206f7260448201527f206e657665722065786973746564000000000000000000000000000000000000606482015290519081900360840190fd5b600160a060020a0380891660009081526001602090815260408083206003549094168352928152828220546002909152919020546105bc9163ffffffff610ab316565b60038054600160a060020a039081166000908152600260209081526040808320959095558c83168252600181528482209354909216815291905290812081905582111561062957604051600160a060020a0386169083156108fc029084906000818181858888f150505050505b600081111561065857604051600160a060020a0388169082156108fc029083906000818181858888f150505050505b604051600160a060020a0389169084156108fc029085906000818181858888f1935050505015801561068e573d6000803e3d6000fd5b50604080518481529051600160a060020a038a16917f106f923f993c2149d49b4255ff723acafa1f2d94393f561d3eda32ae348f7241919081900360200190a2600354600160a060020a031660009081526002602052604090205415156106fb5786600160a060020a0316ff5b5050505050505050565b6000806000610713876107eb565b600160a060020a038089166000908152600160209081526040808320600354909416835292905220549093506107759060649061076990879061075d90889063ffffffff610ab316565b9063ffffffff610aca16565b9063ffffffff610af816565b9050600160a060020a038616156107b05761079b6064610769838863ffffffff610aca16565b91506107ad818363ffffffff610ab316565b90505b6107d0826107c4858463ffffffff610ab316565b9063ffffffff610ab316565b92509450945094915050565b600354600160a060020a031681565b600160a060020a03808216600090815260016020908152604080832060035490941683529290529081205481101561086b57600354600160a060020a03908116600081815260026020908152604080832054948716835260018252808320938352929052205461086891906107699030319063ffffffff610aca16565b90505b919050565b6108786108e9565b151561088357600080fd5b60008054604051600160a060020a03909116907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0908390a36000805473ffffffffffffffffffffffffffffffffffffffff19169055565b600054600160a060020a031690565b600054600160a060020a0316331490565b6109026108e9565b151561090d57600080fd5b600354600160a060020a031615610994576040805160e560020a62461bcd02815260206004820152602660248201527f46696e616c697a6174696f6e20636f756c642062652063616c6c6564206f6e6c60448201527f79206f6e63650000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b600160a060020a03821615156109f4576040805160e560020a62461bcd02815260206004820152601d60248201527f576f6e206f7074696f6e2073686f756c64206e6f74206265207a65726f000000604482015290519081900360640190fd5b6003805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0384169081179091556040517f8e500951de09bcc6854e88c0810bafb819503505895751e657a92df6578d3d9990600090a2600160a060020a0382166000908152600260205260409020541515610a735780600160a060020a0316ff5b5050565b610a7f6108e9565b1515610a8a57600080fd5b610a9381610b1b565b50565b600082820183811015610aa857600080fd5b8091505b5092915050565b60008083831115610ac357600080fd5b5050900390565b600080831515610add5760009150610aac565b50828202828482811515610aed57fe5b0414610aa857600080fd5b600080808311610b0757600080fd5b8284811515610b1257fe5b04949350505050565b600160a060020a0381161515610b3057600080fd5b60008054604051600160a060020a03808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a36000805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a03929092169190911790555600a165627a7a72305820e56540b51bbb63f85eb22ef2d202b7529c76498398ae7da6c582d2993bca04240029a165627a7a72305820d7b0a9bb3763d1813b8eac112910f1367699099fcf9b3b3472c262d91a3267a60029000000000000000000000000cd0ba5c1a81782ed5c01e9959e6bfdb7e9344067",
  "constructorArguments": "000000000000000000000000cd0ba5c1a81782ed5c01e9959e6bfdb7e9344067"
}