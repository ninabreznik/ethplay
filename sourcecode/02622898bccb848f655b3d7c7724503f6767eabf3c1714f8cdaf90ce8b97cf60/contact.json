{
  "address": "0xcbcaf05388ac89cf34ebacdffafe9e42539e6c02",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "PPFFactory",
  "compilerVersion": "v0.4.24+commit.e67f0147",
  "optimization": true,
  "runs": "10000",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2019-04-25\n*/\n\n// File: contracts/IFeed.sol\n\npragma solidity ^0.4.18;\n\ninterface IFeed {\n    function get(address base, address quote) external view returns (uint128 xrt, uint64 when);\n}\n\n// File: contracts/open-zeppelin/ECRecovery.sol\n\npragma solidity 0.4.24;\n\n// Using ECRecovery from [emailÂ protected] + added personalRecover function\n// See https://github.com/OpenZeppelin/openzeppelin-solidity/blob/ad12381549c4c0711c2f3310e9fb1f65d51c299c/contracts/ECRecovery.sol\n\nlibrary ECRecovery {\n  /**\n   * @dev Recover signer address from a personal signed message by using his signature\n   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\n   * @param sig bytes signature, the signature is generated using web3.personal.sign()\n   */\n  function personalRecover(bytes32 hash, bytes sig) internal pure returns (address) {\n    return recover(toEthSignedMessageHash(hash), sig);\n  }\n\n  /**\n   * @dev Recover signer address from a message by using his signature\n   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\n   * @param sig bytes signature, the signature is generated using web3.eth.sign()\n   */\n  function recover(bytes32 hash, bytes sig) internal pure returns (address) {\n    bytes32 r;\n    bytes32 s;\n    uint8 v;\n\n    //Check the signature length\n    if (sig.length != 65) {\n      return (address(0));\n    }\n\n    // Divide the signature in r, s and v variables\n    assembly {\n      r := mload(add(sig, 32))\n      s := mload(add(sig, 64))\n      v := byte(0, mload(add(sig, 96)))\n    }\n\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n    if (v < 27) {\n      v += 27;\n    }\n\n    // If the version is correct return the signer address\n    if (v != 27 && v != 28) {\n      return (address(0));\n    } else {\n      return ecrecover(hash, v, r, s);\n    }\n  }\n\n  /**\n   * toEthSignedMessageHash\n   * @dev prefix a bytes32 value with \"\\x19Ethereum Signed Message:\"\n   * @dev and hash the result\n   */\n  function toEthSignedMessageHash(bytes32 hash)\n    internal\n    pure\n    returns (bytes32)\n  {\n    // 32 is the length in bytes of hash,\n    // enforced by the type signature above\n    return keccak256(abi.encodePacked(\n      \"\\x19Ethereum Signed Message:\\n32\",\n      hash\n    ));\n  }\n}\n\n// File: @aragon/os/contracts/common/Uint256Helpers.sol\n\npragma solidity ^0.4.24;\n\n\nlibrary Uint256Helpers {\n    uint256 private constant MAX_UINT64 = uint64(-1);\n\n    string private constant ERROR_NUMBER_TOO_BIG = \"UINT64_NUMBER_TOO_BIG\";\n\n    function toUint64(uint256 a) internal pure returns (uint64) {\n        require(a <= MAX_UINT64, ERROR_NUMBER_TOO_BIG);\n        return uint64(a);\n    }\n}\n\n// File: @aragon/os/contracts/common/TimeHelpers.sol\n\n/*\n * SPDX-License-Identitifer:    MIT\n */\n\npragma solidity ^0.4.24;\n\n\n\ncontract TimeHelpers {\n    using Uint256Helpers for uint256;\n\n    /**\n    * @dev Returns the current block number.\n    *      Using a function rather than `block.number` allows us to easily mock the block number in\n    *      tests.\n    */\n    function getBlockNumber() internal view returns (uint256) {\n        return block.number;\n    }\n\n    /**\n    * @dev Returns the current block number, converted to uint64.\n    *      Using a function rather than `block.number` allows us to easily mock the block number in\n    *      tests.\n    */\n    function getBlockNumber64() internal view returns (uint64) {\n        return getBlockNumber().toUint64();\n    }\n\n    /**\n    * @dev Returns the current timestamp.\n    *      Using a function rather than `block.timestamp` allows us to easily mock it in\n    *      tests.\n    */\n    function getTimestamp() internal view returns (uint256) {\n        return block.timestamp; // solium-disable-line security/no-block-members\n    }\n\n    /**\n    * @dev Returns the current timestamp, converted to uint64.\n    *      Using a function rather than `block.timestamp` allows us to easily mock it in\n    *      tests.\n    */\n    function getTimestamp64() internal view returns (uint64) {\n        return getTimestamp().toUint64();\n    }\n}\n\n// File: contracts/PPF.sol\n\npragma solidity 0.4.24;\n\n\n\n\n\ncontract PPF is IFeed, TimeHelpers {\n    using ECRecovery for bytes32;\n\n    uint256 constant public ONE = 10 ** 18; // 10^18 is considered 1 in the price feed to allow for decimal calculations\n    bytes32 constant public PPF_v1_ID = 0x33a8ba7202230fa1cee2aac7bac322939edc7ba0a48b0989335a5f87a5770369; // keccak256(\"PPF-v1\");\n\n    string private constant ERROR_BAD_SIGNATURE = \"PPF_BAD_SIGNATURE\";\n    string private constant ERROR_BAD_RATE_TIMESTAMP = \"PPF_BAD_RATE_TIMESTAMP\";\n    string private constant ERROR_INVALID_RATE_VALUE = \"PPF_INVALID_RATE_VALUE\";\n    string private constant ERROR_EQUAL_BASE_QUOTE_ADDRESSES = \"PPF_EQUAL_BASE_QUOTE_ADDRESSES\";\n    string private constant ERROR_BASE_ADDRESSES_LENGTH_ZERO = \"PPF_BASE_ADDRESSES_LEN_ZERO\";\n    string private constant ERROR_QUOTE_ADDRESSES_LENGTH_MISMATCH = \"PPF_QUOTE_ADDRESSES_LEN_MISMATCH\";\n    string private constant ERROR_RATE_VALUES_LENGTH_MISMATCH = \"PPF_RATE_VALUES_LEN_MISMATCH\";\n    string private constant ERROR_RATE_TIMESTAMPS_LENGTH_MISMATCH = \"PPF_RATE_TIMESTAMPS_LEN_MISMATCH\";\n    string private constant ERROR_SIGNATURES_LENGTH_MISMATCH = \"PPF_SIGNATURES_LEN_MISMATCH\";\n    string private constant ERROR_CAN_NOT_SET_OPERATOR = \"PPF_CAN_NOT_SET_OPERATOR\";\n    string private constant ERROR_CAN_NOT_SET_OPERATOR_OWNER = \"PPF_CAN_NOT_SET_OPERATOR_OWNER\";\n    string private constant ERROR_OPERATOR_ADDRESS_ZERO = \"PPF_OPERATOR_ADDRESS_ZERO\";\n    string private constant ERROR_OPERATOR_OWNER_ADDRESS_ZERO = \"PPF_OPERATOR_OWNER_ADDRESS_ZERO\";\n\n    struct Price {\n        uint128 xrt;\n        uint64 when;\n    }\n\n    mapping (bytes32 => Price) internal feed;\n    address public operator;\n    address public operatorOwner;\n\n    event SetRate(address indexed base, address indexed quote, uint256 xrt, uint64 when);\n    event SetOperator(address indexed operator);\n    event SetOperatorOwner(address indexed operatorOwner);\n\n    /**\n    * @param _operator Public key allowed to sign messages to update the pricefeed\n    * @param _operatorOwner Address of an account that can change the operator\n    */\n    constructor (address _operator, address _operatorOwner) public {\n        _setOperator(_operator);\n        _setOperatorOwner(_operatorOwner);\n    }\n\n    /**\n    * @notice Update the price for the `base + ':' + quote` feed with an exchange rate of `xrt / ONE` for time `when`\n    * @dev If the number representation of base is lower than the one for quote, and update is cheaper, as less manipulation is required.\n    * @param base Address for the base token in the feed\n    * @param quote Address for the quote token the base is denominated in\n    * @param xrt Exchange rate for base denominated in quote. 10^18 is considered 1 to allow for decimal calculations\n    * @param when Timestamp for the exchange rate value\n    * @param sig Signature payload (EIP191) from operator, concatenated [  r  ][  s  ][v]. See setHash function for the hash calculation.\n    */\n    function update(address base, address quote, uint128 xrt, uint64 when, bytes sig) public {\n        bytes32 pair = pairId(base, quote);\n\n        // Ensure it is more recent than the current value (implicit check for > 0) and not a future date\n        require(when > feed[pair].when && when <= getTimestamp(), ERROR_BAD_RATE_TIMESTAMP);\n        require(xrt > 0, ERROR_INVALID_RATE_VALUE); // Make sure xrt is not 0, as the math would break (Dividing by 0 sucks big time)\n        require(base != quote, ERROR_EQUAL_BASE_QUOTE_ADDRESSES); // Assumption that currency units are fungible and xrt should always be 1\n\n        bytes32 h = setHash(base, quote, xrt, when);\n        require(h.personalRecover(sig) == operator, ERROR_BAD_SIGNATURE); // Make sure the update was signed by the operator\n\n        feed[pair] = Price(pairXRT(base, quote, xrt), when);\n\n        emit SetRate(base, quote, xrt, when);\n    }\n\n    /**\n    * @notice Update the price for many pairs\n    * @dev If the number representation of bases is lower than the one for quotes, and update is cheaper, as less manipulation is required.\n    * @param bases Array of addresses for the base tokens in the feed\n    * @param quotes Array of addresses for the quote tokens bases are denominated in\n    * @param xrts Array of the exchange rates for bases denominated in quotes. 10^18 is considered 1 to allow for decimal calculations\n    * @param whens Array of timestamps for the exchange rate value\n    * @param sigs Bytes array with the ordered concatenated signatures for the updates\n    */\n    function updateMany(address[] bases, address[] quotes, uint128[] xrts, uint64[] whens, bytes sigs) public {\n        require(bases.length != 0, ERROR_BASE_ADDRESSES_LENGTH_ZERO);\n        require(bases.length == quotes.length, ERROR_QUOTE_ADDRESSES_LENGTH_MISMATCH);\n        require(bases.length == xrts.length, ERROR_RATE_VALUES_LENGTH_MISMATCH);\n        require(bases.length == whens.length, ERROR_RATE_TIMESTAMPS_LENGTH_MISMATCH);\n        require(bases.length == sigs.length / 65, ERROR_SIGNATURES_LENGTH_MISMATCH);\n        require(sigs.length % 65 == 0, ERROR_SIGNATURES_LENGTH_MISMATCH);\n\n        for (uint256 i = 0; i < bases.length; i++) {\n            // Extract the signature for the update from the concatenated sigs\n            bytes memory sig = new bytes(65);\n            uint256 needle = 32 + 65 * i; // where to start copying from sigs\n            assembly {\n                // copy 32 bytes at a time and just the last byte at the end\n                mstore(add(sig, 0x20), mload(add(sigs, needle)))\n                mstore(add(sig, 0x40), mload(add(sigs, add(needle, 0x20))))\n                // we have to mload the last 32 bytes of the sig, and mstore8 just gets the LSB for the word\n                mstore8(add(sig, 0x60), mload(add(sigs, add(needle, 0x21))))\n            }\n\n            update(bases[i], quotes[i], xrts[i], whens[i], sig);\n        }\n    }\n\n    /**\n    * @param base Address for the base token in the feed\n    * @param quote Address for the quote token the base is denominated in\n    * @return XRT for base:quote and the timestamp when it was updated\n    */\n    function get(address base, address quote) public view returns (uint128, uint64) {\n        if (base == quote) {\n            return (uint128(ONE), getTimestamp64());\n        }\n\n        Price storage price = feed[pairId(base, quote)];\n\n        // if never set, return 0.\n        if (price.when == 0) {\n            return (0, 0);\n        }\n\n        return (pairXRT(base, quote, price.xrt), price.when);\n    }\n\n    /**\n    * @notice Set operator public key to `_operator`\n    * @param _operator Public key allowed to sign messages to update the pricefeed\n    */\n    function setOperator(address _operator) external {\n        // Allow the current operator to change the operator to avoid having to hassle the\n        // operatorOwner in cases where a node just wants to rotate its public key\n        require(msg.sender == operator || msg.sender == operatorOwner, ERROR_CAN_NOT_SET_OPERATOR);\n        _setOperator(_operator);\n    }\n\n    /**\n    * @notice Set operator owner to `_operatorOwner`\n    * @param _operatorOwner Address of an account that can change the operator\n    */\n    function setOperatorOwner(address _operatorOwner) external {\n        require(msg.sender == operatorOwner, ERROR_CAN_NOT_SET_OPERATOR_OWNER);\n        _setOperatorOwner(_operatorOwner);\n    }\n\n    function _setOperator(address _operator) internal {\n        require(_operator != address(0), ERROR_OPERATOR_ADDRESS_ZERO);\n        operator = _operator;\n        emit SetOperator(_operator);\n    }\n\n    function _setOperatorOwner(address _operatorOwner) internal {\n        require(_operatorOwner != address(0), ERROR_OPERATOR_OWNER_ADDRESS_ZERO);\n        operatorOwner = _operatorOwner;\n        emit SetOperatorOwner(_operatorOwner);\n    }\n\n    /**\n    * @dev pairId returns a unique id for each pair, regardless of the order of base and quote\n    */\n    function pairId(address base, address quote) internal pure returns (bytes32) {\n        bool pairOrdered = isPairOrdered(base, quote);\n        address orderedBase = pairOrdered ? base : quote;\n        address orderedQuote = pairOrdered ? quote : base;\n\n        return keccak256(abi.encodePacked(orderedBase, orderedQuote));\n    }\n\n    /**\n    * @dev Compute xrt depending on base and quote order.\n    */\n    function pairXRT(address base, address quote, uint128 xrt) internal pure returns (uint128) {\n        bool pairOrdered = isPairOrdered(base, quote);\n\n        return pairOrdered ? xrt : uint128((ONE**2 / uint256(xrt))); // If pair is not ordered, return the inverse\n    }\n\n    function setHash(address base, address quote, uint128 xrt, uint64 when) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PPF_v1_ID, base, quote, xrt, when));\n    }\n\n    function isPairOrdered(address base, address quote) private pure returns (bool) {\n        return base < quote;\n    }\n}\n\n// File: contracts/IPPFFactory.sol\n\npragma solidity ^0.4.18;\n\n\n\ninterface IPPFFactory {\n  event NewPPF(address ppf, address indexed operator, address indexed operatorOwner);\n\n  function newPPF(address operator, address operatorOwner) external returns (IFeed);\n}\n\n// File: contracts/PPFFactory.sol\n\npragma solidity 0.4.24;\n\n\n\n\ncontract PPFFactory is IPPFFactory {\n    function newPPF(address operator, address operatorOwner) external returns (IFeed) {\n        PPF ppf = new PPF(operator, operatorOwner);\n        emit NewPPF(address(ppf), operator, operatorOwner);\n\n        return IFeed(ppf);\n    }\n}",
  "bytecode": "608060405234801561001057600080fd5b50611ca2806100206000396000f3006080604052600436106100405763ffffffff7c010000000000000000000000000000000000000000000000000000000060003504166370c9d3e38114610045575b600080fd5b34801561005157600080fd5b5061007973ffffffffffffffffffffffffffffffffffffffff600435811690602435166100a2565b6040805173ffffffffffffffffffffffffffffffffffffffff9092168252519081900360200190f35b60008083836100af61014c565b73ffffffffffffffffffffffffffffffffffffffff928316815291166020820152604080519182900301906000f0801580156100ef573d6000803e3d6000fd5b506040805173ffffffffffffffffffffffffffffffffffffffff8084168252915192935081861692918716917fd9e62ab99ad90aaedba82b833d8f49c665ca71701fb655e5b599d037cf023a4b9181900360200190a39392505050565b604051611b1a8061015d83390190560060806040523480156200001157600080fd5b5060405160408062001b1a8339810160405280516020909101516200003f826401000000006200005b810204565b62000053816401000000006200018c810204565b505062000280565b60408051808201909152601981527f5050465f4f50455241544f525f414444524553535f5a45524f000000000000006020820152600160a060020a038216151562000141576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825283818151815260200191508051906020019080838360005b8381101562000105578181015183820152602001620000eb565b50505050905090810190601f168015620001335780820380516001836020036101000a031916815260200191505b509250505060405180910390fd5b5060018054600160a060020a031916600160a060020a0383169081179091556040517fdbebfba65bd6398fb722063efc10c99f624f9cd8ba657201056af918a676d5ee90600090a250565b60408051808201909152601f81527f5050465f4f50455241544f525f4f574e45525f414444524553535f5a45524f006020820152600160a060020a038216151562000235576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825283818151815260200191508051906020019080838360008381101562000105578181015183820152602001620000eb565b5060028054600160a060020a031916600160a060020a0383169081179091556040517f99ac3391bcaac6e04578cbac2efd183c665745adeb1ad37989376c39f137177a90600090a250565b61188a80620002906000396000f3006080604052600436106100985763ffffffff7c01000000000000000000000000000000000000000000000000000000006000350416630cc893e2811461009d5780630dfcdb07146100db578063570ca7351461021b57806377bb136114610230578063b3ab15fb14610257578063b800919e14610285578063c2ee3a08146102b3578063d81e8423146102c8578063fdadbbb614610331575b600080fd5b3480156100a957600080fd5b506100b26103d1565b6040805173ffffffffffffffffffffffffffffffffffffffff9092168252519081900360200190f35b3480156100e757600080fd5b506040805160206004803580820135838102808601850190965280855261021995369593946024949385019291829185019084908082843750506040805187358901803560208181028481018201909552818452989b9a998901989297509082019550935083925085019084908082843750506040805187358901803560208181028481018201909552818452989b9a998901989297509082019550935083925085019084908082843750506040805187358901803560208181028481018201909552818452989b9a99890198929750908201955093508392508501908490808284375050604080516020601f89358b018035918201839004830284018301909452808352979a9998810197919650918201945092508291508401838280828437509497506103ed9650505050505050565b005b34801561022757600080fd5b506100b26108d3565b34801561023c57600080fd5b506102456108ef565b60408051918252519081900360200190f35b34801561026357600080fd5b5061021973ffffffffffffffffffffffffffffffffffffffff60043516610913565b34801561029157600080fd5b5061021973ffffffffffffffffffffffffffffffffffffffff600435166109fa565b3480156102bf57600080fd5b50610245610aba565b3480156102d457600080fd5b506102fc73ffffffffffffffffffffffffffffffffffffffff60043581169060243516610ac6565b604080516fffffffffffffffffffffffffffffffff909316835267ffffffffffffffff90911660208301528051918290030190f35b34801561033d57600080fd5b50604080516020601f6084356004818101359283018490048402850184019095528184526102199473ffffffffffffffffffffffffffffffffffffffff813581169560248035909216956fffffffffffffffffffffffffffffffff604435169567ffffffffffffffff606435169536959460a49493910191908190840183828082843750949750610bba9650505050505050565b60025473ffffffffffffffffffffffffffffffffffffffff1681565b845160408051808201909152601b81527f5050465f424153455f4144445245535345535f4c454e5f5a45524f00000000006020820152600091606091839115156104cf576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825283818151815260200191508051906020019080838360005b8381101561049457818101518382015260200161047c565b50505050905090810190601f1680156104c15780820380516001836020036101000a031916815260200191505b509250505060405180910390fd5b50865188516040805180820190915260208082527f5050465f51554f54455f4144445245535345535f4c454e5f4d49534d41544348908201529114610570576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825283818151815260200191508051906020019080838360008381101561049457818101518382015260200161047c565b508551885160408051808201909152601c81527f5050465f524154455f56414c5545535f4c454e5f4d49534d415443480000000060208201529114610611576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825283818151815260200191508051906020019080838360008381101561049457818101518382015260200161047c565b50845188516040805180820190915260208082527f5050465f524154455f54494d455354414d50535f4c454e5f4d49534d415443489082015291146106b2576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825283818151815260200191508051906020019080838360008381101561049457818101518382015260200161047c565b508351885160408051808201909152601b81527f5050465f5349474e4154555245535f4c454e5f4d49534d4154434800000000006020820152916041900414610757576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825283818151815260200191508051906020019080838360008381101561049457818101518382015260200161047c565b50835160408051808201909152601b81527f5050465f5349474e4154555245535f4c454e5f4d49534d41544348000000000060208201529060419006156107fa576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825283818151815260200191508051906020019080838360008381101561049457818101518382015260200161047c565b50600092505b87518310156108c957604080516041808252608082019092529060208201610820803883390190505091508260410260200190508084015160208301526020810184015160408301526021810184015160608301536108be888481518110151561086657fe5b90602001906020020151888581518110151561087e57fe5b90602001906020020151888681518110151561089657fe5b9060200190602002015188878151811015156108ae57fe5b9060200190602002015186610bba565b600190920191610800565b5050505050505050565b60015473ffffffffffffffffffffffffffffffffffffffff1681565b7f33a8ba7202230fa1cee2aac7bac322939edc7ba0a48b0989335a5f87a577036981565b60015473ffffffffffffffffffffffffffffffffffffffff16331480610950575060025473ffffffffffffffffffffffffffffffffffffffff1633145b60408051808201909152601881527f5050465f43414e5f4e4f545f5345545f4f50455241544f52000000000000000060208201529015156109ed576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825283818151815260200191508051906020019080838360008381101561049457818101518382015260200161047c565b506109f781611030565b50565b60025460408051808201909152601e81527f5050465f43414e5f4e4f545f5345545f4f50455241544f525f4f574e4552000060208201529073ffffffffffffffffffffffffffffffffffffffff163314610ab0576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825283818151815260200191508051906020019080838360008381101561049457818101518382015260200161047c565b506109f781611153565b670de0b6b3a764000081565b60008060008373ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff161415610b1957670de0b6b3a7640000610b10611276565b92509250610bb2565b600080610b26878761128d565b815260208101919091526040016000208054909150700100000000000000000000000000000000900467ffffffffffffffff161515610b6b5760009250829150610bb2565b8054610b8c90869086906fffffffffffffffffffffffffffffffff166113e1565b8154909350700100000000000000000000000000000000900467ffffffffffffffff1691505b509250929050565b600080610bc7878761128d565b60008181526020819052604090205490925067ffffffffffffffff7001000000000000000000000000000000009091048116908516118015610c1a5750610c0c611432565b8467ffffffffffffffff1611155b60408051808201909152601681527f5050465f4241445f524154455f54494d455354414d50000000000000000000006020820152901515610cb7576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825283818151815260200191508051906020019080838360008381101561049457818101518382015260200161047c565b5060408051808201909152601681527f5050465f494e56414c49445f524154455f56414c554500000000000000000000602082015260006fffffffffffffffffffffffffffffffff871611610d68576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825283818151815260200191508051906020019080838360008381101561049457818101518382015260200161047c565b5060408051808201909152601e81527f5050465f455155414c5f424153455f51554f54455f4144445245535345530000602082015273ffffffffffffffffffffffffffffffffffffffff8881169088161415610e20576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825283818151815260200191508051906020019080838360008381101561049457818101518382015260200161047c565b50610e2d87878787611436565b60015490915073ffffffffffffffffffffffffffffffffffffffff16610e59828563ffffffff6115a116565b73ffffffffffffffffffffffffffffffffffffffff16146040805190810160405280601181526020017f5050465f4241445f5349474e4154555245000000000000000000000000000000815250901515610f0f576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825283818151815260200191508051906020019080838360008381101561049457818101518382015260200161047c565b506040805190810160405280610f268989896113e1565b6fffffffffffffffffffffffffffffffff908116825267ffffffffffffffff8781166020938401819052600087815280855260409081902086518154978701517fffffffffffffffffffffffffffffffff00000000000000000000000000000000909816908616177fffffffffffffffff0000000000000000ffffffffffffffffffffffffffffffff167001000000000000000000000000000000009790941696909602929092179094558051918916825291810192909252805173ffffffffffffffffffffffffffffffffffffffff89811693908b16927fdc3cf748498d22cc47e2d62e2a7216a21f3e47de73ea3d4a9b2a7ccd976ff84d92918290030190a350505050505050565b60408051808201909152601981527f5050465f4f50455241544f525f414444524553535f5a45524f00000000000000602082015273ffffffffffffffffffffffffffffffffffffffff821615156110e3576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825283818151815260200191508051906020019080838360008381101561049457818101518382015260200161047c565b50600180547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff83169081179091556040517fdbebfba65bd6398fb722063efc10c99f624f9cd8ba657201056af918a676d5ee90600090a250565b60408051808201909152601f81527f5050465f4f50455241544f525f4f574e45525f414444524553535f5a45524f00602082015273ffffffffffffffffffffffffffffffffffffffff82161515611206576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825283818151815260200191508051906020019080838360008381101561049457818101518382015260200161047c565b50600280547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff83169081179091556040517f99ac3391bcaac6e04578cbac2efd183c665745adeb1ad37989376c39f137177a90600090a250565b6000611288611283611432565b6115bc565b905090565b60008060008061129d868661166c565b9250826112aa57846112ac565b855b9150826112b957856112bb565b845b90508181604051602001808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166c010000000000000000000000000281526014018273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166c01000000000000000000000000028152601401925050506040516020818303038152906040526040518082805190602001908083835b602083106113a857805182527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0909201916020918201910161136b565b6001836020036101000a038019825116818451168082178552505050505050905001915050604051809103902093505b50505092915050565b6000806113ee858561166c565b905080611427576fffffffffffffffffffffffffffffffff83166ec097ce7bc90715b34b9f100000000081151561142157fe5b04611429565b825b95945050505050565b4290565b604080517f33a8ba7202230fa1cee2aac7bac322939edc7ba0a48b0989335a5f87a57703696020808301919091526c0100000000000000000000000073ffffffffffffffffffffffffffffffffffffffff80891682028486015287160260548301527001000000000000000000000000000000006fffffffffffffffffffffffffffffffff8616026068830152780100000000000000000000000000000000000000000000000067ffffffffffffffff8516026078830152825160608184030181526080909201928390528151600093918291908401908083835b6020831061154e57805182527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe09092019160209182019101611511565b5181516020939093036101000a7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0180199091169216919091179052604051920182900390912098975050505050505050565b60006115b56115af8461168a565b83611770565b9392505050565b60408051808201909152601581527f55494e5436345f4e554d4245525f544f4f5f4249470000000000000000000000602082015260009067ffffffffffffffff831115611665576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825283818151815260200191508051906020019080838360008381101561049457818101518382015260200161047c565b5090919050565b73ffffffffffffffffffffffffffffffffffffffff90811691161090565b604080517f19457468657265756d205369676e6564204d6573736167653a0a333200000000602080830191909152603c80830185905283518084039091018152605c909201928390528151600093918291908401908083835b6020831061172057805182527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe090920191602091820191016116e3565b5181516020939093036101000a7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0180199091169216919091179052604051920182900390912095945050505050565b6000806000808451604114151561178a57600093506113d8565b50505060208201516040830151606084015160001a601b60ff821610156117af57601b015b8060ff16601b141580156117c757508060ff16601c14155b156117d557600093506113d8565b60408051600080825260208083018085528a905260ff8516838501526060830187905260808301869052925160019360a08085019491937fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0840193928390039091019190865af115801561184d573d6000803e3d6000fd5b5050506020604051035193506113d85600a165627a7a72305820e829ae20310525dbeb301acd3de82f04dda2158eb3f1a23d34cd05e4dfc052ca0029a165627a7a72305820f20523b7bd9c7abe03973912df26eb67d317dace370dc336b73d47b7727c87840029"
}