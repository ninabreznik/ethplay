{
  "address": "0xc735000293cb6790d8b9cc978f4dcce7018d8f7f",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "Countdown3D",
  "compilerVersion": "v0.5.0+commit.1d4f565a",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2019-01-05\n*/\n\npragma solidity 0.5.0;\n\n/*\n* In Contracts We Trust\n*\n* Countdown3D is a provably-fair multi tier lottery played using Ether\n*\n* ======================== *\n*     CRYPTO COUNTDOWN     *\n*          3 2 1           *\n* ======================== *\n* [x] Provably Fair\n* [x] Open Source\n* [x] Multi Tier Rewards\n* [x] Battle Tested with the Team Just community!\n*\n*/\n\n// Invest in Hourglass Contract Interface\n// 0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe\ninterface HourglassInterface {\n    // Invest in dividends for bigger better shinier future jackpots\n    function buy(address _playerAddress) external payable returns(uint256);\n    // Withdraw hourglass dividends to the round pot\n    function withdraw() external;\n    // Would you look at all those divs\n    function dividendsOf(address _playerAddress) external view returns(uint256);\n    // Check out that hourglass balance\n    function balanceOf(address _playerAddress) external view returns(uint256);\n}\n\n\ncontract Countdown3D {\n\n    /* ==== INTERFACE ==== */\n    HourglassInterface internal hourglass;\n\n    /* ==== EVENTS ==== */\n    // Emit event onBuy\n    event OnBuy(address indexed _playerAddress, uint indexed _roundId, uint _tickets, uint _value);\n    // Emit event when round is capped\n    event OnRoundCap(uint _roundId);\n    // Emit event when new round starts\n    event OnRoundStart(uint _roundId);\n\n    /* ==== GLOBALS ==== */\n    // Crypto Countdown timer\n    uint256 constant public COOLDOWN = 7 days;\n\n    // Cost per ticket\n    uint256 constant public COST = 0.01 ether;\n\n    // Claim your winnings within 5 rounds\n    uint256 constant public EXPIRATION = 5;\n\n    // Minimum number of tickets needed to build a pyramid\n    uint256 constant public QUORUM = 21;\n\n    // Maximum tickets an account can hold at any given time\n    uint256 constant public TICKET_MAX = 101;\n\n    // The Current Round\n    uint256 public currentRoundId;\n\n    // Developers\n    address private dev1;\n    address private dev2;\n\n    /* ==== STRUCT ==== */\n    struct Round {\n        // Balance set after the round is capped\n        uint256 balance;\n        // Block number that caps this round\n        uint256 blockCap;\n        // Ether claimed from this round\n        uint256 claimed;\n        // Pot is composed of tickets, donations, unclaimed winnings, percent of previous round, and hourglass dividends\n        uint256 pot;\n        // Random index from the future\n        uint256 random;\n        // Timestamp when this round kicks off\n        uint256 startTime;\n        // Total tickets in this round\n        uint256 tickets;\n        // Value of a ticket in each winning tier\n        mapping (uint256 => uint256) caste;\n        // Validate a round to score a reward\n        mapping (address => uint256) reward;\n    }\n\n    struct Account {\n        // Store each round an account holds tickets\n        uint256[] roundsActive;\n        // Store each round an account holds validation rewards\n        uint256[] rewards;\n        // Map Round id to ticket sets\n        mapping(uint256 => TicketSet[]) ticketSets;\n        // Total tickets held by account\n        uint256 tickets;\n    }\n\n    // A set of tickets\n    struct TicketSet {\n        // Index of first ticket in set\n        uint256 start;\n        // Index of last ticket in the set\n        uint256 end;\n    }\n\n    // Map a round id to a round\n    mapping (uint256 => Round) internal rounds;\n    // Map an address to an account\n    mapping (address => Account) internal accounts;\n\n    /* ==== CONSTRUCTOR ==== */\n    constructor(address hourglassAddress, address dev1Address, address dev2Address) public {\n        // Set round 0 start time here\n        rounds[0].startTime = now + 7 days;\n        // Set hourglass interface\n        hourglass = HourglassInterface(hourglassAddress);\n        // Set dev1\n        dev1 = dev1Address;\n        // Set dev2\n        dev2 = dev2Address;\n    }\n    /* ==== PUBLIC WRITE ==== */\n\n    // Ether sent directly to contract gets donated to the pot\n    function ()\n        external\n        payable\n    {\n        // Donate ETH sent directly to contract as long as the sender is not the hourglass contract\n        if (msg.sender != address(hourglass)) {\n            donateToPot();\n        }\n    }\n\n    // Buy a ticket or tickets\n    function buy()\n        public\n        payable\n    {\n        // Current round or next round\n        (Round storage round, uint256 roundId) = getRoundInProgress();\n\n        // Calculate number of tickets and any change\n        (uint256 tickets, uint256 change) = processTickets();\n\n        // Send change to the round pot\n        round.pot = round.pot + change;\n\n        // Allocate tickets to account\n        if (tickets > 0) {\n            // Give player their tickets\n            pushTicketSetToAccount(roundId, tickets);\n            // Increment tickets in the round\n            round.tickets = round.tickets + tickets;\n        }\n        // Broadcast an event when a ticket set is purchased\n        emit OnBuy(msg.sender, roundId, tickets, msg.value);\n    }\n\n    // Support a good cause, invest in dividends\n    function donateToDivs()\n        public\n        payable\n    {\n        // Buys investment tokens from hourglass contract\n        hourglass.buy.value(msg.value)(msg.sender);\n    }\n\n    // Support a good cause, donate to the round pot\n    function donateToPot()\n        public\n        payable\n    {\n        if (msg.value > 0) {\n            // Current round or next round\n            (Round storage round,) = getRoundInProgress();\n            round.pot = round.pot + msg.value;\n        }\n    }\n\n    // Complete and Secure the round\n    function validate()\n        public\n    {\n        // Current Round\n        Round storage round = rounds[currentRoundId];\n\n        // First check if round was already validated\n        require(round.random == 0);\n\n        // Require minimum number of tickets to build a pyramid\n        require(round.tickets >= QUORUM);\n\n        // Require cooldown between rounds\n        require(round.startTime + COOLDOWN <= now);\n\n        // If blockcap is not set yet, cap the round\n        if (round.blockCap == 0) {\n            allocateToPot(round);\n            allocateFromPot(round);\n\n            // Set blockcap\n            round.blockCap = block.number;\n            emit OnRoundCap(currentRoundId);\n        } else {\n            // Require a future block\n            require(block.number > round.blockCap);\n\n            // Get blockhash from the blockcap block\n            uint32 blockhash_ = uint32(bytes4(blockhash(round.blockCap)));\n\n            // Confirm blockhash has not expired on network\n            if (blockhash_ != 0) {\n                closeTheRound(round, blockhash_);\n            } else {\n                // Cap round again\n                round.blockCap = block.number;\n                emit OnRoundCap(currentRoundId);\n            }\n        }\n    }\n\n    // Withdraw ticket winnings\n    function withdraw()\n        public\n    {\n        // Total amount to withdraw\n        uint256 total;\n        // Flag to check if account holds current or next round tickets\n        bool withholdRounds;\n        // Player account\n        Account storage account = accounts[msg.sender];\n        // Total number of rounds a player holds tickets\n        uint256 accountRoundsActiveLength = account.roundsActive.length;\n\n        // Loop through each round the player holds tickets\n        for (uint256 i = 0; i < accountRoundsActiveLength; i++) {\n            uint256 roundId = account.roundsActive[i];\n\n            // Only check if round was already validated\n            if (roundId < currentRoundId) {\n                // Get amount won in the round\n                (uint256 amount, uint256 totalTickets) = getRoundWinnings(msg.sender, roundId);\n\n                // Subtract tickets from account\n                account.tickets = account.tickets - totalTickets;\n\n                // Delete round from player's account\n                delete account.ticketSets[roundId];\n\n                // If the player won during the round\n                if (amount > 0) {\n                    // Increment amount claimed\n                    rounds[roundId].claimed = rounds[roundId].claimed + amount;\n                    // Add to total withdraw\n                    total = total + amount;\n                }\n            } else {\n                // Flag to check if account holds current or next round tickets\n                withholdRounds = true;\n            }\n        }\n\n        // Delete processed rounds\n        sweepRoundsActive(withholdRounds);\n\n        // Last but not least, send ticket winnings\n        if (total > 0) {\n            msg.sender.transfer(total);\n        }\n    }\n\n    // Did you validate a round, claim your rewards here\n    function claimRewards()\n        public\n    {\n        // Total amount to withdraw\n        uint256 total;\n        // Player account\n        Account storage account = accounts[msg.sender];\n        // Total number of rounds with rewards\n        uint256 accountRewardsLength = account.rewards.length;\n\n        // Loop through each round the player holds rewards\n        for (uint256 i = 0; i < accountRewardsLength; i++) {\n            // Round with a reward\n            uint256 roundId = account.rewards[i];\n            // Get reward amount won in the round\n            uint256 amount = getRewardWinnings(msg.sender, roundId);\n            // Delete reward from round\n            delete rounds[roundId].reward[msg.sender];\n\n            // If player has rewards in the round\n            if (amount > 0) {\n                // Increment amount claimed\n                rounds[roundId].claimed = rounds[roundId].claimed + amount;\n                // Add to total withdraw\n                total = total + amount;\n            }\n        }\n\n        // Delete processed rewards\n        delete accounts[msg.sender].rewards;\n\n        // Transfer rewards to player\n        if (total > 0) {\n            msg.sender.transfer(total);\n        }\n    }\n\n    /* ==== PUBLIC READ ==== */\n    // Get global game constants\n    function getConfig()\n        public\n        pure\n        returns(uint256 cooldown, uint256 cost, uint256 expiration, uint256 quorum, uint256 ticketMax)\n    {\n        return(COOLDOWN, COST, EXPIRATION, QUORUM, TICKET_MAX);\n    }\n\n    // Get info for a given Round\n    function getRound(uint256 roundId)\n        public\n        view\n        returns(\n            uint256 balance, \n            uint256 blockCap, \n            uint256 claimed, \n            uint256 pot, \n            uint256 random, \n            uint256 startTime, \n            uint256 tickets)\n    {\n        Round storage round = rounds[roundId];\n\n        return(round.balance, round.blockCap, round.claimed, round.pot, round.random, round.startTime, round.tickets);\n    }\n\n    // Get total number of tickets held by account\n    function getTotalTickets(address accountAddress)\n        public\n        view\n        returns(uint256 tickets)\n    {\n        return accounts[accountAddress].tickets;\n    }\n\n    // Get value of ticket held in each winning caste\n    function getRoundCasteValues(uint256 roundId)\n        public\n        view\n        returns(uint256 caste0, uint256 caste1, uint256 caste2)\n    {\n        return(rounds[roundId].caste[0], rounds[roundId].caste[1], rounds[roundId].caste[2]);\n    }\n\n    // Get rounds account is active\n    function getRoundsActive(address accountAddress)\n        public\n        view\n        returns(uint256[] memory)\n    {\n        return accounts[accountAddress].roundsActive;\n    }\n\n    // Get the rounds an account has unclaimed rewards\n    function getRewards(address accountAddress)\n        public\n        view\n        returns(uint256[] memory)\n    {\n        return accounts[accountAddress].rewards;\n    }\n\n    // Get the total number of ticket sets an account holds for a given round\n    function getTotalTicketSetsForRound(address accountAddress, uint256 roundId)\n        public\n        view\n        returns(uint256 ticketSets)\n    {\n        return accounts[accountAddress].ticketSets[roundId].length;\n    }\n\n    // Get an account's individual ticket set from a round\n    function getTicketSet(address accountAddress, uint256 roundId, uint256 index)\n        public\n        view\n        returns(uint256 start, uint256 end)\n    {\n        TicketSet storage ticketSet = accounts[accountAddress].ticketSets[roundId][index];\n\n        // Starting ticket and ending ticket in set\n        return (ticketSet.start, ticketSet.end);\n    }\n\n    // Get the value of a ticket\n    function getTicketValue(uint256 roundId, uint256 ticketIndex)\n        public\n        view\n        returns(uint256 ticketValue)\n    {\n        // Check if the round expired\n        if (currentRoundId > roundId && (currentRoundId - roundId) >= EXPIRATION) {\n            return 0;\n        }\n\n        Round storage round = rounds[roundId];\n        // Set which tier the ticket is in\n        uint256 tier = getTier(roundId, ticketIndex);\n\n        // Return ticket value based on tier\n        if (tier == 5) {\n            return 0;\n        } else if (tier == 4) {\n            return COST / 2;\n        } else if (tier == 3) {\n            return COST;\n        } else {\n            return round.caste[tier];\n        }\n    }\n\n    // Get which tier a ticket is in\n    function getTier(uint256 roundId, uint256 ticketIndex)\n        public\n        view\n        returns(uint256 tier)\n    {\n        Round storage round = rounds[roundId];\n        // Distance from random index\n        uint256 distance = Math.distance(round.random, ticketIndex, round.tickets);\n        // Tier based on ticket index\n        uint256 ticketTier = Caste.tier(distance, round.tickets - 1);\n\n        return ticketTier;\n    }\n\n    // Get the amount won in a round\n    function getRoundWinnings(address accountAddress, uint256 roundId)\n        public\n        view\n        returns(uint256 totalWinnings, uint256 totalTickets)\n    {\n        // Player account\n        Account storage account = accounts[accountAddress];\n        // Ticket sets an account holds in a given round\n        TicketSet[] storage ticketSets = account.ticketSets[roundId];\n\n        // Holds total winnings in a round\n        uint256 total;\n        // Total number of ticket sets\n        uint256 ticketSetLength = ticketSets.length;\n        // Holds total individual tickets in a round\n        uint256 totalTicketsInRound;\n\n        // Check if round expired\n        if (currentRoundId > roundId && (currentRoundId - roundId) >= EXPIRATION) {\n            // Round expired\n            // Loop through each ticket set\n            for (uint256 i = 0; i < ticketSetLength; i++) {\n                // Calculate the total number of tickets in a set\n                uint256 totalTicketsInSet = (ticketSets[i].end - ticketSets[i].start) + 1;\n                // Add the total number of tickets to the total number of tickets in the round\n                totalTicketsInRound = totalTicketsInRound + totalTicketsInSet;\n            }\n\n            // After looping through all of the tickets, return total winnings and total tickets in round\n            return (total, totalTicketsInRound);\n        }\n\n        // If the round has not expired, Loop through each ticket set\n        for (uint256 i = 0; i < ticketSetLength; i++) {\n            // Subtract one to get true ticket index\n            uint256 startIndex = ticketSets[i].start - 1;\n            uint256 endIndex = ticketSets[i].end - 1;\n            // Loop through each ticket\n            for (uint256 j = startIndex; j <= endIndex; j++) {\n                // Add the ticket value to total round winnings\n                total = total + getTicketWinnings(roundId, j);\n            }\n            // Calculate the total number of tickets in a set\n            uint256 totalTicketsInSet = (ticketSets[i].end - ticketSets[i].start) + 1;\n            // Set the total number of tickets in a round\n            totalTicketsInRound = totalTicketsInRound + totalTicketsInSet;\n        }\n        // After looping through all of the tickets, return total winnings and total tickets in round\n        return (total, totalTicketsInRound);\n    }\n\n    // Get the value of a reward in a round such as validator reward\n    function getRewardWinnings(address accountAddress, uint256 roundId)\n        public\n        view\n        returns(uint256 reward)\n    {\n        // Check if round expired\n        if (currentRoundId > roundId && (currentRoundId - roundId) >= EXPIRATION) {\n            // Reward expired\n            return 0;\n        }\n        // Reward did not expire\n        return rounds[roundId].reward[accountAddress];\n    }\n\n    // Get dividends from hourglass contract\n    function getDividends()\n        public\n        view\n        returns(uint256 dividends)\n    {\n        return hourglass.dividendsOf(address(this));\n    }\n\n    // Get total amount of tokens owned by contract\n    function getHourglassBalance()\n        public\n        view\n        returns(uint256 hourglassBalance)\n    {\n        return hourglass.balanceOf(address(this));\n    }\n\n    /* ==== PRIVATE ==== */\n    // At the end of the round, distribute percentages from the pot\n    function allocateFromPot(Round storage round)\n        private\n    {\n        // 75% to winning Castes\n        (round.caste[0], round.caste[1], round.caste[2]) = Caste.values((round.tickets - 1), round.pot, COST);\n\n        // 15% to next generation\n        rounds[currentRoundId + 1].pot = (round.pot * 15) / 100;\n\n        // 2% to each dev\n        uint256 percent2 = (round.pot * 2) / 100;\n        round.reward[dev1] = percent2;\n        round.reward[dev2] = percent2;\n\n        // Cleanup unclaimed dev rewards\n        if (accounts[dev1].rewards.length == TICKET_MAX) {\n            delete accounts[dev1].rewards;\n        }\n        if (accounts[dev2].rewards.length == TICKET_MAX) {\n            delete accounts[dev2].rewards;\n        }\n        // Store round with reward\n        accounts[dev1].rewards.push(currentRoundId);\n        accounts[dev2].rewards.push(currentRoundId);\n\n        // 5% buys hourglass token\n        hourglass.buy.value((round.pot * 5) / 100)(msg.sender);\n\n        // 20% of round pot claimed from 15% to next round and 5% investment in hourglass token\n        round.claimed = (round.pot * 20) / 100;\n    }\n\n    // At the end of the round, allocate investment dividends and bottom tiers to the pot\n    function allocateToPot(Round storage round)\n        private\n    {\n        // Balance is seed pot combined with total tickets\n        round.balance = round.pot + (round.tickets * COST);\n\n        // Bottom tiers to the pot\n        round.pot = round.pot + Caste.pool(round.tickets - 1, COST);\n\n        // Check investment dividends accrued\n        uint256 dividends = getDividends();\n        // If there are dividends available\n        if (dividends > 0) {\n            // Withdraw dividends from hourglass contract\n            hourglass.withdraw();\n            // Allocate dividends to the round pot\n            round.pot = round.pot + dividends;\n        }\n    }\n\n    // Close the round\n    function closeTheRound(Round storage round, uint32 blockhash_)\n        private\n    {\n        // Prevent devs from validating round since they already get a reward\n        require(round.reward[msg.sender] == 0);\n        // Reward the validator\n        round.reward[msg.sender] = round.pot / 100;\n        // If validator hits a limit without withdrawing their rewards\n        if (accounts[msg.sender].rewards.length == TICKET_MAX) {\n            delete accounts[msg.sender].rewards;\n        }\n\n        // Store round id validator holds a reward\n        accounts[msg.sender].rewards.push(currentRoundId);\n\n        // Set random number\n        round.random = Math.random(blockhash_, round.tickets);\n\n        // Set current round id\n        currentRoundId = currentRoundId + 1;\n\n        // New Round\n        Round storage newRound = rounds[currentRoundId];\n\n        // Set next round start time\n        newRound.startTime = now;\n\n        // Start expiring rounds at Round 5\n        if (currentRoundId >= EXPIRATION) {\n            // Set expired round\n            Round storage expired = rounds[currentRoundId - EXPIRATION];\n            // Check if expired round has a balance\n            if (expired.balance > expired.claimed) {\n                // Allocate expired funds to next round\n                newRound.pot = newRound.pot + (expired.balance - expired.claimed);\n            }\n        }\n\n        // Broadcast a new round is starting\n        emit OnRoundStart(currentRoundId);\n    }\n\n    // Get Current round or next round depending on whether blockcap is set\n    function getRoundInProgress()\n        private\n        view\n        returns(Round storage, uint256 roundId)\n    {\n        // Current Round if blockcap not set yet\n        if (rounds[currentRoundId].blockCap == 0) {\n            return (rounds[currentRoundId], currentRoundId);\n        }\n        // Next round if blockcap is set\n        return (rounds[currentRoundId + 1], currentRoundId + 1);\n    }\n\n    // Get the value of an individual ticket in a given round\n    function getTicketWinnings(uint256 roundId, uint256 index)\n        private\n        view\n        returns(uint256 ticketValue)\n    {\n        Round storage round = rounds[roundId];\n        // Set which tier the ticket is in\n        uint256 tier = getTier(roundId, index);\n\n        // Return ticket value based on tier\n        if (tier == 5) {\n            return 0;\n        } else if (tier == 4) {\n            return COST / 2;\n        } else if (tier == 3) {\n            return COST;\n        } else {\n            return round.caste[tier];\n        }\n    }\n\n    // Calculate total tickets and remainder based on message value\n    function processTickets()\n        private\n        view\n        returns(uint256 totalTickets, uint256 totalRemainder)\n    {\n        // Calculate total tickets based on msg.value and ticket cost\n        uint256 tickets = Math.divide(msg.value, COST);\n        // Calculate remainder based on msg.value and ticket cost\n        uint256 remainder = Math.remainder(msg.value, COST);\n\n        return (tickets, remainder);\n    }\n\n    // Stores ticket set in player account\n    function pushTicketSetToAccount(uint256 roundId, uint256 tickets)\n        private\n    {\n        // Player account\n        Account storage account = accounts[msg.sender];\n        // Round to add tickets\n        Round storage round = rounds[roundId];\n\n        // Store which rounds the player buys tickets in\n        if (account.ticketSets[roundId].length == 0) {\n            account.roundsActive.push(roundId);\n        }\n\n        // Require existing tickets plus new tickets\n        // Is less than maximum allowable tickets an account can hold\n        require((account.tickets + tickets) < TICKET_MAX);\n        account.tickets = account.tickets + tickets;\n\n        // Store ticket set\n        account.ticketSets[roundId].push(TicketSet(round.tickets + 1, round.tickets + tickets));\n    }\n\n    // Delete unused state after withdrawing to lower gas cost for the player\n    function sweepRoundsActive(bool withholdRounds)\n        private\n    {\n        // Delete any rounds that are not current or next round\n        if (withholdRounds != true) {\n            // Remove active rounds from player account\n            delete accounts[msg.sender].roundsActive;\n        } else {\n            bool current;\n            bool next;\n            // Total number of active rounds\n            uint256 roundActiveLength = accounts[msg.sender].roundsActive.length;\n\n            // Loop each round account was active\n            for (uint256 i = 0; i < roundActiveLength; i++) {\n                uint256 roundId = accounts[msg.sender].roundsActive[i];\n\n                // Flag if account has tickets in current round\n                if (roundId == currentRoundId) {\n                    current = true;\n                }\n                // Flag if account has tickets in next round\n                if (roundId > currentRoundId) {\n                    next = true;\n                }\n            }\n\n            // Remove active rounds from player account\n            delete accounts[msg.sender].roundsActive;\n\n            // Add back current round if player holds tickets in current round\n            if (current == true) {\n                accounts[msg.sender].roundsActive.push(currentRoundId);\n            }\n            // Add back current round if player holds tickets in next round\n            if (next == true) {\n                accounts[msg.sender].roundsActive.push(currentRoundId + 1);\n            }\n        }\n    }\n}\n\n\n/**\n * @title Math\n * @dev Math operations with safety checks that throw on error\n */\nlibrary Math {\n    /**\n    * @dev Calculates a distance between start and finish wrapping around total\n    */\n    function distance(uint256 start, uint256 finish, uint256 total)\n        internal\n        pure\n        returns(uint256)\n    {\n        if (start < finish) {\n            return finish - start;\n        }\n        if (start > finish) {\n            return (total - start) + finish;\n        }\n        if (start == finish) {\n            return 0;\n        }\n    }\n\n    /**\n    * @dev Calculates the quotient between the numerator and denominator.\n    */\n    function divide(uint256 numerator, uint256 denominator)\n        internal\n        pure\n        returns (uint256)\n    {\n        // EVM does not allow division by zero\n        return numerator / denominator;\n    }\n\n    /**\n    * @dev Generate random number from blockhash\n    */\n    function random(uint32 blockhash_, uint256 max)\n        internal\n        pure\n        returns(uint256)\n    {\n        // encoded blockhash as uint256\n        uint256 encodedBlockhash = uint256(keccak256(abi.encodePacked(blockhash_)));\n        // random number from 0 to (max - 1)\n        return (encodedBlockhash % max);\n    }\n\n    /**\n    * @dev Calculates the remainder between the numerator and denominator.\n    */\n    function remainder(uint256 numerator, uint256 denominator)\n        internal\n        pure\n        returns (uint256)\n    {\n        // EVM does not allow division by zero\n        return numerator % denominator;\n    }\n}\n\n\n/**\n * @title Caste\n * @dev Caste operations\n */\nlibrary Caste {\n\n    /**\n    * @dev Calculates amount of ether to transfer to the pot from the caste pool\n    * total is 1 less than total number of tickets to take 0 index into account\n    */\n    function pool(uint256 total, uint256 cost)\n        internal\n        pure\n        returns(uint256)\n    {\n        uint256 tier4 = ((total * 70) / 100) - ((total * 45) / 100);\n        uint256 tier5 = total - ((total * 70) / 100);\n\n        return (tier5 * cost) + ((tier4 * cost) / 2);\n    }\n\n    /**\n    * @dev Provides the tier based on an index and total in the caste pool\n    */\n    function tier(uint256 distance, uint256 total)\n        internal\n        pure\n        returns(uint256)\n    {\n        uint256 percent = (distance * (10**18)) / total;\n\n        if (percent > 700000000000000000) {\n            return 5;\n        }\n        if (percent > 450000000000000000) {\n            return 4;\n        }\n        if (percent > 250000000000000000) {\n            return 3;\n        }\n        if (percent > 100000000000000000) {\n            return 2;\n        }\n        if (percent > 0) {\n            return 1;\n        }\n        if (distance == 0) {\n            return 0;\n        } else {\n            return 1;\n        }\n    }\n\n    /**\n    * @dev Calculates value per winning caste\n    */\n    function values(uint256 total, uint256 pot, uint256 cost)\n        internal\n        pure\n        returns(uint256, uint256, uint256)\n    {\n        uint256 percent10 = (total * 10) / 100;\n        uint256 percent25 = (total * 25) / 100;\n        uint256 caste0 = (pot * 25) / 100;\n        uint256 caste1 = cost + (caste0 / percent10);\n        uint256 caste2 = cost + (caste0 / (percent25 - percent10));\n\n        return (caste0 + cost, caste1, caste2);\n    }\n}",
  "abi": "[{\"constant\":true,\"inputs\":[{\"name\":\"accountAddress\",\"type\":\"address\"}],\"name\":\"getRoundsActive\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"QUORUM\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimRewards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TICKET_MAX\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"getRoundCasteValues\",\"outputs\":[{\"name\":\"caste0\",\"type\":\"uint256\"},{\"name\":\"caste1\",\"type\":\"uint256\"},{\"name\":\"caste2\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"donateToPot\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"roundId\",\"type\":\"uint256\"},{\"name\":\"ticketIndex\",\"type\":\"uint256\"}],\"name\":\"getTier\",\"outputs\":[{\"name\":\"tier\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"validate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"accountAddress\",\"type\":\"address\"}],\"name\":\"getRewards\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"accountAddress\",\"type\":\"address\"},{\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"getTotalTicketSetsForRound\",\"outputs\":[{\"name\":\"ticketSets\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"roundId\",\"type\":\"uint256\"},{\"name\":\"ticketIndex\",\"type\":\"uint256\"}],\"name\":\"getTicketValue\",\"outputs\":[{\"name\":\"ticketValue\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"getRound\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"blockCap\",\"type\":\"uint256\"},{\"name\":\"claimed\",\"type\":\"uint256\"},{\"name\":\"pot\",\"type\":\"uint256\"},{\"name\":\"random\",\"type\":\"uint256\"},{\"name\":\"startTime\",\"type\":\"uint256\"},{\"name\":\"tickets\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentRoundId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getHourglassBalance\",\"outputs\":[{\"name\":\"hourglassBalance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COOLDOWN\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"EXPIRATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"accountAddress\",\"type\":\"address\"},{\"name\":\"roundId\",\"type\":\"uint256\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getTicketSet\",\"outputs\":[{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"end\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COST\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getConfig\",\"outputs\":[{\"name\":\"cooldown\",\"type\":\"uint256\"},{\"name\":\"cost\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"quorum\",\"type\":\"uint256\"},{\"name\":\"ticketMax\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"accountAddress\",\"type\":\"address\"}],\"name\":\"getTotalTickets\",\"outputs\":[{\"name\":\"tickets\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"accountAddress\",\"type\":\"address\"},{\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"getRewardWinnings\",\"outputs\":[{\"name\":\"reward\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDividends\",\"outputs\":[{\"name\":\"dividends\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"donateToDivs\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"accountAddress\",\"type\":\"address\"},{\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"getRoundWinnings\",\"outputs\":[{\"name\":\"totalWinnings\",\"type\":\"uint256\"},{\"name\":\"totalTickets\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"hourglassAddress\",\"type\":\"address\"},{\"name\":\"dev1Address\",\"type\":\"address\"},{\"name\":\"dev2Address\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_roundId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_tickets\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"OnBuy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_roundId\",\"type\":\"uint256\"}],\"name\":\"OnRoundCap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_roundId\",\"type\":\"uint256\"}],\"name\":\"OnRoundStart\",\"type\":\"event\"}]",
  "bytecode": "608060405234801561001057600080fd5b506040516060806119f08339810180604052606081101561003057600080fd5b5080516020808301516040909301516000808052600490925262093a8042017f17ef568e3e12ab5b9c7254a8d58478811de00f9e6eb34345acd53bf8fd09d3f1558154600160a060020a03938416600160a060020a031991821617909255600280549484169483169490941790935560038054929093169116179055611935806100bb6000396000f3fe60806040526004361061013a5763ffffffff60e060020a6000350416630733b88881146101565780632e80d9b6146101d9578063372500ab1461020057806338274b5d146102155780633ccfd60b1461022a5780633d4311e21461023f57806349e1432c1461028757806351355cfb1461028f5780636901f668146102bf57806379ee54f7146102d457806387afe179146103075780638e0eef8e146103405780638f1327c0146103705780639cbe5efd146103d2578063a1b86605146103e7578063a2724a4d146103fc578063a6f2ae3a14610411578063bb4b573414610419578063bc28cfe41461042e578063bf8fbbd214610486578063c3f909d41461049b578063c737b7c6146104db578063e592f95a1461050e578063ed442e1414610547578063f999eead1461055c578063f9ef66f514610564575b600054600160a060020a031633146101545761015461059d565b005b34801561016257600080fd5b506101896004803603602081101561017957600080fd5b5035600160a060020a03166105be565b60408051602080825283518183015283519192839290830191858101910280838360005b838110156101c55781810151838201526020016101ad565b505050509050019250505060405180910390f35b3480156101e557600080fd5b506101ee61062a565b60408051918252519081900360200190f35b34801561020c57600080fd5b5061015461062f565b34801561022157600080fd5b506101ee610724565b34801561023657600080fd5b50610154610729565b34801561024b57600080fd5b506102696004803603602081101561026257600080fd5b5035610828565b60408051938452602084019290925282820152519081900360600190f35b61015461059d565b34801561029b57600080fd5b506101ee600480360360408110156102b257600080fd5b508035906020013561085e565b3480156102cb57600080fd5b506101546108a5565b3480156102e057600080fd5b50610189600480360360208110156102f757600080fd5b5035600160a060020a03166109cb565b34801561031357600080fd5b506101ee6004803603604081101561032a57600080fd5b50600160a060020a038135169060200135610a38565b34801561034c57600080fd5b506101ee6004803603604081101561036357600080fd5b5080359060200135610a64565b34801561037c57600080fd5b5061039a6004803603602081101561039357600080fd5b5035610b06565b604080519788526020880196909652868601949094526060860192909252608085015260a084015260c0830152519081900360e00190f35b3480156103de57600080fd5b506101ee610b43565b3480156103f357600080fd5b506101ee610b49565b34801561040857600080fd5b506101ee610be0565b610154610be7565b34801561042557600080fd5b506101ee610c72565b34801561043a57600080fd5b5061046d6004803603606081101561045157600080fd5b50600160a060020a038135169060208101359060400135610c77565b6040805192835260208301919091528051918290030190f35b34801561049257600080fd5b506101ee610cd4565b3480156104a757600080fd5b506104b0610cdf565b6040805195865260208601949094528484019290925260608401526080830152519081900360a00190f35b3480156104e757600080fd5b506101ee600480360360208110156104fe57600080fd5b5035600160a060020a0316610cf8565b34801561051a57600080fd5b506101ee6004803603604081101561053157600080fd5b50600160a060020a038135169060200135610d16565b34801561055357600080fd5b506101ee610d67565b610154610dca565b34801561057057600080fd5b5061046d6004803603604081101561058757600080fd5b50600160a060020a038135169060200135610e5b565b60003411156105bc5760006105b0611009565b50600301805434019055505b565b600160a060020a03811660009081526005602090815260409182902080548351818402810184019094528084526060939283018282801561061e57602002820191906000526020600020905b81548152602001906001019080831161060a575b50505050509050919050565b601581565b3360009081526005602052604081206001810154825b818110156106c8576000836001018281548110151561066057fe5b9060005260206000200154905060006106793383610d16565b600083815260046020908152604080832033845260080190915281208190559091508111156106be576000828152600460205260409020600201805482019055948501945b5050600101610645565b503360009081526005602052604081206106e79160019091019061188c565b600083111561071f57604051339084156108fc029085906000818181858888f1935050505015801561071d573d6000803e3d6000fd5b505b505050565b606581565b3360009081526005602052604081208054829190825b818110156107e157825460009084908390811061075857fe5b906000526020600020015490506001548110156107d35760008061077c3384610e5b565b6003880180548290039055600085815260028901602052604081209294509092506107a791906118aa565b60008211156107cc576000838152600460205260409020600201805483019055968101965b50506107d8565b600194505b5060010161073f565b506107eb8361105b565b600084111561071d57604051339085156108fc029086906000818181858888f19350505050158015610821573d6000803e3d6000fd5b5050505050565b60009081526004602090815260408083208380526007019091528082205460018352818320546002845291909220549192909190565b600082815260046020819052604082209081015460068201548391610884918690611172565b905060006108998260018560060154036111ab565b93505050505b92915050565b600154600090815260046020819052604090912090810154156108c757600080fd5b6006810154601511156108d957600080fd5b4262093a80826005015401111515156108f157600080fd5b60018101541515610950576109058161125c565b61090e81611325565b436001808301919091555460408051918252517f39e5eb472b703c2231ccecb0dc1ac73ab5f40570c4897859b78e034f5d4e76659181900360200190a16109c8565b6001810154431161096057600080fd5b600181015460e060020a90400463ffffffff811615610988576109838282611555565b6109c6565b436001808401919091555460408051918252517f39e5eb472b703c2231ccecb0dc1ac73ab5f40570c4897859b78e034f5d4e76659181900360200190a15b505b50565b600160a060020a03811660009081526005602090815260409182902060010180548351818402810184019094528084526060939283018282801561061e576020028201919060005260206000209081548152602001906001019080831161060a5750505050509050919050565b600160a060020a0391909116600090815260056020908152604080832093835260029093019052205490565b600082600154118015610a7c57506005836001540310155b15610a895750600061089f565b600083815260046020526040812090610aa2858561085e565b90508060051415610ab85760009250505061089f565b8060041415610ad357506611c37937e08000915061089f9050565b8060031415610aed57662386f26fc100009250505061089f565b600090815260079091016020526040902054905061089f565b6000908152600460208190526040909120805460018201546002830154600384015494840154600585015460069095015493969295919491939092565b60015481565b60008054604080517f70a082310000000000000000000000000000000000000000000000000000000081523060048201529051600160a060020a03909216916370a0823191602480820192602092909190829003018186803b158015610bae57600080fd5b505afa158015610bc2573d6000803e3d6000fd5b505050506040513d6020811015610bd857600080fd5b505190505b90565b62093a8081565b600080610bf2611009565b91509150600080610c016116a5565b6003860180548201905590925090506000821115610c2e57610c2383836116db565b600684018054830190555b604080518381523460208201528151859233927f2ee1adcdbeae91f0a3dd5297f1cf478c665b25583945e188cf1b65a5e0aeccf3929081900390910190a350505050565b600581565b600160a060020a0383166000908152600560209081526040808320858452600201909152812080548291829185908110610cad57fe5b90600052602060002090600202019050806000015481600101549250925050935093915050565b662386f26fc1000081565b62093a80662386f26fc100006005601560659091929394565b600160a060020a031660009081526005602052604090206003015490565b600081600154118015610d2e57506005826001540310155b15610d3b5750600061089f565b506000908152600460209081526040808320600160a060020a0394909416835260089093019052205490565b60008054604080517e65318b0000000000000000000000000000000000000000000000000000000081523060048201529051600160a060020a03909216916265318b91602480820192602092909190829003018186803b158015610bae57600080fd5b600054604080517ff088d5470000000000000000000000000000000000000000000000000000000081523360048201529051600160a060020a039092169163f088d547913491602480830192602092919082900301818588803b158015610e3057600080fd5b505af1158015610e44573d6000803e3d6000fd5b50505050506040513d60208110156109c657600080fd5b600160a060020a03821660009081526005602090815260408083208484526002810190925282208054600154849392918491829088108015610ea257506005886001540310155b15610f1d5760005b82811015610f0d5760008582815481101515610ec257fe5b9060005260206000209060020201600001548683815481101515610ee257fe5b9060005260206000209060020201600101540360010190508083019250508080600101915050610eaa565b5091955090935061100292505050565b60005b82811015610ff757600060018683815481101515610f3a57fe5b906000526020600020906002020160000154039050600060018784815481101515610f6157fe5b90600052602060002090600202016001015403905060008290505b818111610f9957610f8d8c8261178c565b90960195600101610f7c565b5060008784815481101515610faa57fe5b9060005260206000209060020201600001548885815481101515610fca57fe5b90600052602060002090600202016001015403600101905080850194505050508080600101915050610f20565b509195509093505050505b9250929050565b6001805460009081526004602052604081209091015481901515611040575050600154600081815260046020526040902090611057565b505060018054016000818152600460205260409020905b9091565b6001811515146110825733600090815260056020526040812061107d9161188c565b6109c8565b336000908152600560205260408120548190815b818110156110ed573360009081526005602052604081208054839081106110b957fe5b906000526020600020015490506001548114156110d557600194505b6001548111156110e457600193505b50600101611096565b503360009081526005602052604081206111069161188c565b6001831515141561113757336000908152600560209081526040822060018054825491820183559184529190922001555b6001821515141561071d5733600090815260056020908152604082206001805482548083018455928552929093209190920191015550505050565b60008284101561118557508282036111a4565b82841115611198575082810382016111a4565b828414156111a4575060005b9392505050565b6000808284670de0b6b3a7640000028115156111c357fe5b0490506709b6e64a8ec600008111156111e057600591505061089f565b67063eb89da4ed00008111156111fa57600491505061089f565b6703782dace9d9000081111561121457600391505061089f565b67016345785d8a000081111561122e57600291505061089f565b600081111561124157600191505061089f565b83151561125257600091505061089f565b600191505061089f565b60068101546003820154662386f26fc1000080830290910183556112849160001901906117a5565b600382018054919091019055600061129a610d67565b905060008111156109c65760008054604080517f3ccfd60b0000000000000000000000000000000000000000000000000000000081529051600160a060020a0390921692633ccfd60b9260048084019382900301818387803b1580156112ff57600080fd5b505af1158015611313573d6000803e3d6000fd5b50505060038301805483019055505050565b61134260018260060154038260030154662386f26fc100006117c8565b600080805260078501602090815260408083206001808552828520600280875284872097909755969096559590955560038087018054865487018552600484528785206064600f9092028290049084015590548554600160a060020a03908116865260088a018552888620918702929092049081905591548116845286842082905593549093168252600590529290922001546065141561140657600254600160a060020a031660009081526005602052604081206114069160019091019061188c565b600354600160a060020a03166000908152600560205260409020600101546065141561145557600354600160a060020a031660009081526005602052604081206114559160019091019061188c565b600254600160a060020a03908116600090815260056020818152604080842060018054918101805480830182559087528487200191909155600380548716865282862082549083018054938401815587528487209092019190915593549387015481517ff088d5470000000000000000000000000000000000000000000000000000000081523360048201529151949095169463f088d5479460649190940204926024808301939282900301818588803b15801561151257600080fd5b505af1158015611526573d6000803e3d6000fd5b50505050506040513d602081101561153d57600080fd5b50505060038101546064601490910204600290910155565b3360009081526008830160205260409020541561157157600080fd5b600382015433600090815260088401602090815260408083206064909404909355600590522060010154606514156115c1573360009081526005602052604081206115c19160019091019061188c565b33600090815260056020908152604082206001805491810180549182018155845291909220015560068201546115f890829061181a565b6004808401919091556001805481018082556000908152602092909252604090912042600580830191909155915490911161166b5760015460041901600090815260046020526040902060028101548154111561166957806002015481600001540382600301540182600301819055505b505b60015460408051918252517f8d3ba48e66b7c6bb4202cadc004a007bca0b3b2a0caf613e5b612caa6e69f1ea9181900360200190a1505050565b60008060006116bb34662386f26fc10000611862565b905060006116d034662386f26fc10000611877565b919350909150509091565b3360009081526005602090815260408083208584526004835281842060028201909352922054151561171d578154600181018355600083815260209020018490555b600382015460659084011061173157600080fd5b6003820180548401905560009384526002918201602090815260408086208151808301909252600690930154600181810183529501818301908152835480870185559387529190952094519190920290930192835551910155565b600082815260046020526040812081610aa2858561085e565b60026064602d840281900460468502919091049081038302919091049203020190565b600080806064600a870281900490601980890282900491908802048383828115156117ef57fe5b048801905060008484038381151561180357fe5b938a019c929b509092049097019750505050505050565b6040805160e060020a63ffffffff8516026020808301919091528251808303600401815260249092019092528051910120600090828181151561185957fe5b06949350505050565b6000818381151561186f57fe5b049392505050565b6000818381151561188457fe5b069392505050565b50805460008255906000526020600020908101906109c891906118cb565b50805460008255600202906000526020600020908101906109c891906118e9565b610bdd91905b808211156118e557600081556001016118d1565b5090565b610bdd91905b808211156118e557600080825560018201556002016118ef56fea165627a7a72305820cf2f34ee8f79aae81c2c76bae851446a4666763e8b67f074f0c001ac569185250029000000000000000000000000b3775fb83f7d12a36e0475abdd1fca35c091efbe00000000000000000000000044a654cbed14a8b3d9ec6bd8df9eb86e19b2c3bb000000000000000000000000aa83ad367892cee155ab3f4af52e18dc9f0d78dd",
  "constructorArguments": "000000000000000000000000b3775fb83f7d12a36e0475abdd1fca35c091efbe00000000000000000000000044a654cbed14a8b3d9ec6bd8df9eb86e19b2c3bb000000000000000000000000aa83ad367892cee155ab3f4af52e18dc9f0d78dd"
}