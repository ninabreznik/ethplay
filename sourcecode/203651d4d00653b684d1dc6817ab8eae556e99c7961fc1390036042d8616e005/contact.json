{
  "address": "0x2cc69caaaaa6114ddf48f4ddb2adb9c5d5d3e048",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "OnChainOrderBookV012b",
  "compilerVersion": "v0.4.24+commit.e67f0147",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2018-09-04\n*/\n\npragma solidity ^0.4.24;\n\n// Amis Dex OnChainOrderBook follows ERC20 Standards\ncontract ERC20 {\n  function totalSupply() constant returns (uint);\n  function balanceOf(address _owner) constant returns (uint balance);\n  function transfer(address _to, uint _value) returns (bool success);\n  function transferFrom(address _from, address _to, uint _value) returns (bool success);\n  function approve(address _spender, uint _value) returns (bool success);\n  function allowance(address _owner, address _spender) constant returns (uint remaining);\n  event Transfer(address indexed _from, address indexed _to, uint _value);\n  event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\n\n// Amis Dex on-chain order book matching engine Version 0.1.2.\n// https://github.com/amisolution/ERC20-AMIS/contracts/OnChainOrderBookV012b.sol\n// This smart contract is a variation of a neat ERC20 token as base, ETH as quoted, \n// and standard fees with incentivized reward token.\n// This contract allows minPriceExponent, baseMinInitialSize, and baseMinRemainingSize\n// to be set at init() time appropriately for the token decimals and likely value.\n//\ncontract OnChainOrderBookV012b {\n\n  enum BookType {\n    ERC20EthV1\n  }\n\n  enum Direction {\n    Invalid,\n    Buy,\n    Sell\n  }\n\n  enum Status {\n    Unknown,\n    Rejected,\n    Open,\n    Done,\n    NeedsGas,\n    Sending,    // not used by contract - web UI only\n    FailedSend, // not used by contract - web UI only\n    FailedTxn   // not used by contract - web UI only\n  }\n\n  enum ReasonCode {\n    None,\n    InvalidPrice,\n    InvalidSize,\n    InvalidTerms,\n    InsufficientFunds,\n    WouldTake,\n    Unmatched,\n    TooManyMatches,\n    ClientCancel\n  }\n\n  enum Terms {\n    GTCNoGasTopup,\n    GTCWithGasTopup,\n    ImmediateOrCancel,\n    MakerOnly\n  }\n\n  struct Order {\n    // these are immutable once placed:\n\n    address client;\n    uint16 price;              // packed representation of side + price\n    uint sizeBase;\n    Terms terms;\n\n    // these are mutable until Done or Rejected:\n    \n    Status status;\n    ReasonCode reasonCode;\n    uint128 executedBase;      // gross amount executed in base currency (before fee deduction)\n    uint128 executedCntr;      // gross amount executed in quoted currency (before fee deduction)\n    uint128 feesBaseOrCntr;    // base for buy, cntr for sell\n    uint128 feesRwrd;\n  }\n  \n  struct OrderChain {\n    uint128 firstOrderId;\n    uint128 lastOrderId;\n  }\n\n  struct OrderChainNode {\n    uint128 nextOrderId;\n    uint128 prevOrderId;\n  }\n  \n  // Rebuild the expected state of the contract given:\n  //  - ClientPaymentEvent log history\n  //  - ClientOrderEvent log history\n  //  - Calling getOrder for the other immutable order fields of orders referenced by ClientOrderEvent\n  \n  enum ClientPaymentEventType {\n    Deposit,\n    Withdraw,\n    TransferFrom,\n    Transfer\n  }\n\n  enum BalanceType {\n    Base,\n    Cntr,\n    Rwrd\n  }\n\n  event ClientPaymentEvent(\n    address indexed client,\n    ClientPaymentEventType clientPaymentEventType,\n    BalanceType balanceType,\n    int clientBalanceDelta\n  );\n\n  enum ClientOrderEventType {\n    Create,\n    Continue,\n    Cancel\n  }\n\n  event ClientOrderEvent(\n    address indexed client,\n    ClientOrderEventType clientOrderEventType,\n    uint128 orderId,\n    uint maxMatches\n  );\n\n  enum MarketOrderEventType {\n    // orderCount++, depth += depthBase\n    Add,\n    // orderCount--, depth -= depthBase\n    Remove,\n    // orderCount--, depth -= depthBase, traded += tradeBase\n    // (depth change and traded change differ when tiny remaining amount refunded)\n    CompleteFill,\n    // orderCount unchanged, depth -= depthBase, traded += tradeBase\n    PartialFill\n  }\n\n  // Technically not needed but these events can be used to maintain an order book or\n  // watch for fills. Note that the orderId and price are those of the maker.\n\n  event MarketOrderEvent(\n    uint256 indexed eventTimestamp,\n    uint128 indexed orderId,\n    MarketOrderEventType marketOrderEventType,\n    uint16 price,\n    uint depthBase,\n    uint tradeBase\n  );\n\n  // the base token (e.g. AMIS)\n  \n  ERC20 baseToken;\n\n  // minimum order size (inclusive)\n  uint baseMinInitialSize; // set at init\n\n  // if following partial match, the remaining gets smaller than this, remove from Order Book and refund:\n  // generally we make this 10% of baseMinInitialSize\n  uint baseMinRemainingSize; // set at init\n\n  // maximum order size (exclusive)\n  // chosen so that even multiplied by the max price (or divided by the min price),\n  // and then multiplied by ethRwrdRate, it still fits in 2^127, allowing us to save\n  // some gas by storing executed + fee fields as uint128.\n  // even with 18 decimals, this still allows order sizes up to 1,000,000,000.\n  // if we encounter a token with e.g. 36 decimals we'll have to revisit ...\n  uint constant baseMaxSize = 10 ** 30;\n\n  // the counter currency or ETH traded pair\n  // (no address because it is ETH)\n\n  // avoid the book getting cluttered up with tiny amounts not worth the gas\n  uint constant cntrMinInitialSize = 10 finney;\n\n  // see comments for baseMaxSize\n  uint constant cntrMaxSize = 10 ** 30;\n\n  // the reward token that can be used to pay fees (AMIS / ORA / CRSW)\n\n  ERC20 rwrdToken; // set at init\n\n  // used to convert ETH amount to reward tokens when paying fee with reward tokens\n  uint constant ethRwrdRate = 1000;\n  \n  // funds that belong to clients (base, counter, and reward)\n\n  mapping (address => uint) balanceBaseForClient;\n  mapping (address => uint) balanceCntrForClient;\n  mapping (address => uint) balanceRwrdForClient;\n\n  // fee charged on liquidity taken, expressed as a divisor\n  // (e.g. 2000 means 1/2000, or 0.05%)\n\n  uint constant feeDivisor = 2000;\n  \n  // fees charged are given to:\n  \n  address feeCollector; // set at init\n\n  // all orders ever created\n  \n  mapping (uint128 => Order) orderForOrderId;\n\n  // Effectively a compact mapping from price to whether there are any open orders at that price.\n  // See \"Price Calculation Constants\" below as to why 85.\n\n  uint256[85] occupiedPriceBitmaps;\n\n  // These allow us to walk over the orders in the book at a given price level (and add more).\n\n  mapping (uint16 => OrderChain) orderChainForOccupiedPrice;\n  mapping (uint128 => OrderChainNode) orderChainNodeForOpenOrderId;\n\n  // These allow a client to (reasonably) efficiently find their own orders\n  // without relying on events (which even indexed are a bit expensive to search\n  // and cannot be accessed from smart contracts). See walkOrders.\n\n  mapping (address => uint128) mostRecentOrderIdForClient;\n  mapping (uint128 => uint128) clientPreviousOrderIdBeforeOrderId;\n\n  // Price Calculation Constants.\n  //\n  // We pack direction and price into a crafty decimal floating point representation\n  // for efficient indexing by price, the main thing we lose by doing so is precision -\n  // we only have 3 significant figures in our prices.\n  //\n  // An unpacked price consists of:\n  //\n  //   direction - invalid / buy / sell\n  //   mantissa  - ranges from 100 to 999 representing 0.100 to 0.999\n  //   exponent  - ranges from minimumPriceExponent to minimumPriceExponent + 11\n  //               (e.g. -5 to +6 for a typical pair where minPriceExponent = -5)\n  //\n  // The packed representation has 21601 different price values:\n  //\n  //      0  = invalid (can be used as marker value)\n  //      1  = buy at maximum price (0.999 * 10 ** 6)\n  //    ...  = other buy prices in descending order\n  //   5400  = buy at 1.00\n  //    ...  = other buy prices in descending order\n  //  10800  = buy at minimum price (0.100 * 10 ** -5)\n  //  10801  = sell at minimum price (0.100 * 10 ** -5)\n  //    ...  = other sell prices in descending order\n  //  16201  = sell at 1.00\n  //    ...  = other sell prices in descending order\n  //  21600  = sell at maximum price (0.999 * 10 ** 6)\n  //  21601+ = do not use\n  //\n  // If we want to map each packed price to a boolean value (which we do),\n  // we require 85 256-bit words. Or 42.5 for each side of the book.\n  \n  int8 minPriceExponent; // set at init\n\n  uint constant invalidPrice = 0;\n\n  // careful: max = largest unpacked value, not largest packed value\n  uint constant maxBuyPrice = 1; \n  uint constant minBuyPrice = 10800;\n  uint constant minSellPrice = 10801;\n  uint constant maxSellPrice = 21600;\n\n  // Constructor.\n  //\n  // Sets feeCollector to the creator. Creator needs to call init() to finish setup.\n  //\n  function OnChainOrderBookV012b() {\n    address creator = msg.sender;\n    feeCollector = creator;\n  }\n\n  // \"Public\" Management - set address of base and reward tokens.\n  //\n  // Can only be done once (normally immediately after creation) by the fee collector.\n  //\n  // Used instead of a constructor to make deployment easier.\n  //\n  // baseMinInitialSize is the minimum order size in token-wei;\n  // the minimum resting size will be one tenth of that.\n  //\n  // minPriceExponent controls the range of prices supported by the contract;\n  // the range will be 0.100*10**minPriceExponent to 0.999*10**(minPriceExponent + 11)\n  // but careful; this is in token-wei : wei, ignoring the number of decimals of the token\n  // e.g. -5 implies 1 token-wei worth between 0.100e-5 to 0.999e+6 wei\n  // which implies same token:eth exchange rate if token decimals are 18 like eth,\n  // but if token decimals are 8, that would imply 1 token worth 10 wei to 0.000999 ETH.\n  //\n  function init(ERC20 _baseToken, ERC20 _rwrdToken, uint _baseMinInitialSize, int8 _minPriceExponent) public {\n    require(msg.sender == feeCollector);\n    require(address(baseToken) == 0);\n    require(address(_baseToken) != 0);\n    require(address(rwrdToken) == 0);\n    require(address(_rwrdToken) != 0);\n    require(_baseMinInitialSize >= 10);\n    require(_baseMinInitialSize < baseMaxSize / 1000000);\n    require(_minPriceExponent >= -20 && _minPriceExponent <= 20);\n    if (_minPriceExponent < 2) {\n      require(_baseMinInitialSize >= 10 ** uint(3-int(minPriceExponent)));\n    }\n    baseMinInitialSize = _baseMinInitialSize;\n    // dust prevention. truncation ok, know >= 10\n    baseMinRemainingSize = _baseMinInitialSize / 10;\n    minPriceExponent = _minPriceExponent;\n    // attempt to catch bad tokens:\n    require(_baseToken.totalSupply() > 0);\n    baseToken = _baseToken;\n    require(_rwrdToken.totalSupply() > 0);\n    rwrdToken = _rwrdToken;\n  }\n\n  // \"Public\" Management - change fee collector\n  //\n  // The new fee collector only gets fees charged after this point.\n  //\n  function changeFeeCollector(address newFeeCollector) public {\n    address oldFeeCollector = feeCollector;\n    require(msg.sender == oldFeeCollector);\n    require(newFeeCollector != oldFeeCollector);\n    feeCollector = newFeeCollector;\n  }\n  \n  // Public Info View - what is being traded here, what are the limits?\n  //\n  function getBookInfo() public constant returns (\n      BookType _bookType, address _baseToken, address _rwrdToken,\n      uint _baseMinInitialSize, uint _cntrMinInitialSize, int8 _minPriceExponent,\n      uint _feeDivisor, address _feeCollector\n    ) {\n    return (\n      BookType.ERC20EthV1,\n      address(baseToken),\n      address(rwrdToken),\n      baseMinInitialSize, // can assume min resting size is one tenth of this\n      cntrMinInitialSize,\n      minPriceExponent,\n      feeDivisor,\n      feeCollector\n    );\n  }\n\n  // Public Funds View - get balances held by contract on behalf of the client,\n  // or balances approved for deposit but not yet claimed by the contract.\n  //\n  // Excludes funds in open orders.\n  //\n  // Helps a web ui get a consistent snapshot of balances.\n  //\n  // It would be nice to return the off-exchange ETH balance too but there's a\n  // bizarre bug in geth (and apparently as a result via MetaMask) that leads\n  // to unpredictable behaviour when looking up client balances in constant\n  // functions - see e.g. https://github.com/ethereum/solidity/issues/2325 .\n  //\n  function getClientBalances(address client) public constant returns (\n      uint bookBalanceBase,\n      uint bookBalanceCntr,\n      uint bookBalanceRwrd,\n      uint approvedBalanceBase,\n      uint approvedBalanceRwrd,\n      uint ownBalanceBase,\n      uint ownBalanceRwrd\n    ) {\n    bookBalanceBase = balanceBaseForClient[client];\n    bookBalanceCntr = balanceCntrForClient[client];\n    bookBalanceRwrd = balanceRwrdForClient[client];\n    approvedBalanceBase = baseToken.allowance(client, address(this));\n    approvedBalanceRwrd = rwrdToken.allowance(client, address(this));\n    ownBalanceBase = baseToken.balanceOf(client);\n    ownBalanceRwrd = rwrdToken.balanceOf(client);\n  }\n\n  // Public Funds moves - deposit previously-approved base tokens.\n  //\n  function transferFromBase() public {\n    address client = msg.sender;\n    address book = address(this);\n    // we trust the ERC20 token contract not to do nasty things like call back into us -\n    // if we cannot trust the token then why are we allowing it to be traded?\n    uint amountBase = baseToken.allowance(client, book);\n    require(amountBase > 0);\n    // NB: needs change for older ERC20 tokens that don't return bool\n    require(baseToken.transferFrom(client, book, amountBase));\n    // belt and braces\n    assert(baseToken.allowance(client, book) == 0);\n    balanceBaseForClient[client] += amountBase;\n    ClientPaymentEvent(client, ClientPaymentEventType.TransferFrom, BalanceType.Base, int(amountBase));\n  }\n\n  // Public Funds moves - withdraw base tokens (as a transfer).\n  //\n  function transferBase(uint amountBase) public {\n    address client = msg.sender;\n    require(amountBase > 0);\n    require(amountBase <= balanceBaseForClient[client]);\n    // overflow safe since we checked less than balance above\n    balanceBaseForClient[client] -= amountBase;\n    // we trust the ERC20 token contract not to do nasty things like call back into us -\n    require(baseToken.transfer(client, amountBase));\n    ClientPaymentEvent(client, ClientPaymentEventType.Transfer, BalanceType.Base, -int(amountBase));\n  }\n\n  // Public Funds moves - deposit counter quoted currency (ETH or DAI).\n  //\n  function depositCntr() public payable {\n    address client = msg.sender;\n    uint amountCntr = msg.value;\n    require(amountCntr > 0);\n    // overflow safe - if someone owns pow(2,255) ETH we have bigger problems\n    balanceCntrForClient[client] += amountCntr;\n    ClientPaymentEvent(client, ClientPaymentEventType.Deposit, BalanceType.Cntr, int(amountCntr));\n  }\n\n  // Public Funds Move - withdraw counter quoted currency (ETH or DAI).\n  //\n  function withdrawCntr(uint amountCntr) public {\n    address client = msg.sender;\n    require(amountCntr > 0);\n    require(amountCntr <= balanceCntrForClient[client]);\n    // overflow safe - checked less than balance above\n    balanceCntrForClient[client] -= amountCntr;\n    // safe - not enough gas to do anything interesting in fallback, already adjusted balance\n    client.transfer(amountCntr);\n    ClientPaymentEvent(client, ClientPaymentEventType.Withdraw, BalanceType.Cntr, -int(amountCntr));\n  }\n\n  // Public Funds Move - deposit previously-approved incentivized reward tokens.\n  //\n  function transferFromRwrd() public {\n    address client = msg.sender;\n    address book = address(this);\n    uint amountRwrd = rwrdToken.allowance(client, book);\n    require(amountRwrd > 0);\n    // we created the incentivized reward token so we know it supports ERC20 properly and is not evil\n    require(rwrdToken.transferFrom(client, book, amountRwrd));\n    // belt and braces\n    assert(rwrdToken.allowance(client, book) == 0);\n    balanceRwrdForClient[client] += amountRwrd;\n    ClientPaymentEvent(client, ClientPaymentEventType.TransferFrom, BalanceType.Rwrd, int(amountRwrd));\n  }\n\n  // Public Funds Manipulation - withdraw base tokens (as a transfer).\n  //\n  function transferRwrd(uint amountRwrd) public {\n    address client = msg.sender;\n    require(amountRwrd > 0);\n    require(amountRwrd <= balanceRwrdForClient[client]);\n    // overflow safe - checked less than balance above\n    balanceRwrdForClient[client] -= amountRwrd;\n    // we created the incentivized reward token so we know it supports ERC20 properly and is not evil\n    require(rwrdToken.transfer(client, amountRwrd));\n    ClientPaymentEvent(client, ClientPaymentEventType.Transfer, BalanceType.Rwrd, -int(amountRwrd));\n  }\n\n  // Public Order View - get full details of an order.\n  //\n  // If the orderId does not exist, status will be Unknown.\n  //\n  function getOrder(uint128 orderId) public constant returns (\n    address client, uint16 price, uint sizeBase, Terms terms,\n    Status status, ReasonCode reasonCode, uint executedBase, uint executedCntr,\n    uint feesBaseOrCntr, uint feesRwrd) {\n    Order storage order = orderForOrderId[orderId];\n    return (order.client, order.price, order.sizeBase, order.terms,\n            order.status, order.reasonCode, order.executedBase, order.executedCntr,\n            order.feesBaseOrCntr, order.feesRwrd);\n  }\n\n  // Public Order View - get mutable details of an order.\n  //\n  // If the orderId does not exist, status will be Unknown.\n  //\n  function getOrderState(uint128 orderId) public constant returns (\n    Status status, ReasonCode reasonCode, uint executedBase, uint executedCntr,\n    uint feesBaseOrCntr, uint feesRwrd) {\n    Order storage order = orderForOrderId[orderId];\n    return (order.status, order.reasonCode, order.executedBase, order.executedCntr,\n            order.feesBaseOrCntr, order.feesRwrd);\n  }\n  \n  // Public Order View - enumerate all recent orders + all open orders for one client.\n  //\n  // Not really designed for use from a smart contract transaction.\n  // Baseline concept:\n  //  - client ensures order ids are generated so that most-signficant part is time-based;\n  //  - client decides they want all orders after a certain point-in-time,\n  //    and chooses minClosedOrderIdCutoff accordingly;\n  //  - before that point-in-time they just get open and needs gas orders\n  //  - client calls walkClientOrders with maybeLastOrderIdReturned = 0 initially;\n  //  - then repeats with the orderId returned by walkClientOrders;\n  //  - (and stops if it returns a zero orderId);\n  //\n  // Note that client is only used when maybeLastOrderIdReturned = 0.\n  //\n  function walkClientOrders(\n      address client, uint128 maybeLastOrderIdReturned, uint128 minClosedOrderIdCutoff\n    ) public constant returns (\n      uint128 orderId, uint16 price, uint sizeBase, Terms terms,\n      Status status, ReasonCode reasonCode, uint executedBase, uint executedCntr,\n      uint feesBaseOrCntr, uint feesRwrd) {\n    if (maybeLastOrderIdReturned == 0) {\n      orderId = mostRecentOrderIdForClient[client];\n    } else {\n      orderId = clientPreviousOrderIdBeforeOrderId[maybeLastOrderIdReturned];\n    }\n    while (true) {\n      if (orderId == 0) return;\n      Order storage order = orderForOrderId[orderId];\n      if (orderId >= minClosedOrderIdCutoff) break;\n      if (order.status == Status.Open || order.status == Status.NeedsGas) break;\n      orderId = clientPreviousOrderIdBeforeOrderId[orderId];\n    }\n    return (orderId, order.price, order.sizeBase, order.terms,\n            order.status, order.reasonCode, order.executedBase, order.executedCntr,\n            order.feesBaseOrCntr, order.feesRwrd);\n  }\n \n  // Internal Price Calculation - turn packed price into a friendlier unpacked price.\n  //\n  function unpackPrice(uint16 price) internal constant returns (\n      Direction direction, uint16 mantissa, int8 exponent\n    ) {\n    uint sidedPriceIndex = uint(price);\n    uint priceIndex;\n    if (sidedPriceIndex < 1 || sidedPriceIndex > maxSellPrice) {\n      direction = Direction.Invalid;\n      mantissa = 0;\n      exponent = 0;\n      return;\n    } else if (sidedPriceIndex <= minBuyPrice) {\n      direction = Direction.Buy;\n      priceIndex = minBuyPrice - sidedPriceIndex;\n    } else {\n      direction = Direction.Sell;\n      priceIndex = sidedPriceIndex - minSellPrice;\n    }\n    uint zeroBasedMantissa = priceIndex % 900;\n    uint zeroBasedExponent = priceIndex / 900;\n    mantissa = uint16(zeroBasedMantissa + 100);\n    exponent = int8(zeroBasedExponent) + minPriceExponent;\n    return;\n  }\n  \n  // Internal Price Calculation - is a packed price on the buy side?\n  //\n  // Throws an error if price is invalid.\n  //\n  function isBuyPrice(uint16 price) internal constant returns (bool isBuy) {\n    // yes, this looks odd, but max here is highest _unpacked_ price\n    return price >= maxBuyPrice && price <= minBuyPrice;\n  }\n  \n  // Internal Price Calculation - turn a packed buy price into a packed sell price.\n  //\n  // Invalid price remains invalid.\n  //\n  function computeOppositePrice(uint16 price) internal constant returns (uint16 opposite) {\n    if (price < maxBuyPrice || price > maxSellPrice) {\n      return uint16(invalidPrice);\n    } else if (price <= minBuyPrice) {\n      return uint16(maxSellPrice - (price - maxBuyPrice));\n    } else {\n      return uint16(maxBuyPrice + (maxSellPrice - price));\n    }\n  }\n  \n  // Internal Price Calculation - compute amount in counter currency that would\n  // be obtained by selling baseAmount at the given unpacked price (if no fees).\n  //\n  // Notes:\n  //  - Does not validate price - caller must ensure valid.\n  //  - Could overflow producing very unexpected results if baseAmount very\n  //    large - caller must check this.\n  //  - This rounds the amount towards zero.\n  //  - May truncate to zero if baseAmount very small - potentially allowing\n  //    zero-cost buys or pointless sales - caller must check this.\n  //\n  function computeCntrAmountUsingUnpacked(\n      uint baseAmount, uint16 mantissa, int8 exponent\n    ) internal constant returns (uint cntrAmount) {\n    if (exponent < 0) {\n      return baseAmount * uint(mantissa) / 1000 / 10 ** uint(-exponent);\n    } else {\n      return baseAmount * uint(mantissa) / 1000 * 10 ** uint(exponent);\n    }\n  }\n\n  // Internal Price Calculation - compute amount in counter currency that would\n  // be obtained by selling baseAmount at the given packed price (if no fees).\n  //\n  // Notes:\n  //  - Does not validate price - caller must ensure valid.\n  //  - Direction of the packed price is ignored.\n  //  - Could overflow producing very unexpected results if baseAmount very\n  //    large - caller must check this.\n  //  - This rounds the amount towards zero (regardless of Buy or Sell).\n  //  - May truncate to zero if baseAmount very small - potentially allowing\n  //    zero-cost buys or pointless sales - caller must check this.\n  //\n  function computeCntrAmountUsingPacked(\n      uint baseAmount, uint16 price\n    ) internal constant returns (uint) {\n    var (, mantissa, exponent) = unpackPrice(price);\n    return computeCntrAmountUsingUnpacked(baseAmount, mantissa, exponent);\n  }\n\n  // Public Order Placement - create order and try to match it and/or add it to the book.\n  //\n  function createOrder(\n      uint128 orderId, uint16 price, uint sizeBase, Terms terms, uint maxMatches\n    ) public {\n    address client = msg.sender;\n    require(orderId != 0 && orderForOrderId[orderId].client == 0);\n    ClientOrderEvent(client, ClientOrderEventType.Create, orderId, maxMatches);\n    orderForOrderId[orderId] =\n      Order(client, price, sizeBase, terms, Status.Unknown, ReasonCode.None, 0, 0, 0, 0);\n    uint128 previousMostRecentOrderIdForClient = mostRecentOrderIdForClient[client];\n    mostRecentOrderIdForClient[client] = orderId;\n    clientPreviousOrderIdBeforeOrderId[orderId] = previousMostRecentOrderIdForClient;\n    Order storage order = orderForOrderId[orderId];\n    var (direction, mantissa, exponent) = unpackPrice(price);\n    if (direction == Direction.Invalid) {\n      order.status = Status.Rejected;\n      order.reasonCode = ReasonCode.InvalidPrice;\n      return;\n    }\n    if (sizeBase < baseMinInitialSize || sizeBase > baseMaxSize) {\n      order.status = Status.Rejected;\n      order.reasonCode = ReasonCode.InvalidSize;\n      return;\n    }\n    uint sizeCntr = computeCntrAmountUsingUnpacked(sizeBase, mantissa, exponent);\n    if (sizeCntr < cntrMinInitialSize || sizeCntr > cntrMaxSize) {\n      order.status = Status.Rejected;\n      order.reasonCode = ReasonCode.InvalidSize;\n      return;\n    }\n    if (terms == Terms.MakerOnly && maxMatches != 0) {\n      order.status = Status.Rejected;\n      order.reasonCode = ReasonCode.InvalidTerms;\n      return;\n    }\n    if (!debitFunds(client, direction, sizeBase, sizeCntr)) {\n      order.status = Status.Rejected;\n      order.reasonCode = ReasonCode.InsufficientFunds;\n      return;\n    }\n    processOrder(orderId, maxMatches);\n  }\n\n  // Public Order Placement - cancel order\n  //\n  function cancelOrder(uint128 orderId) public {\n    address client = msg.sender;\n    Order storage order = orderForOrderId[orderId];\n    require(order.client == client);\n    Status status = order.status;\n    if (status != Status.Open && status != Status.NeedsGas) {\n      return;\n    }\n    ClientOrderEvent(client, ClientOrderEventType.Cancel, orderId, 0);\n    if (status == Status.Open) {\n      removeOpenOrderFromBook(orderId);\n      MarketOrderEvent(block.timestamp, orderId, MarketOrderEventType.Remove, order.price,\n        order.sizeBase - order.executedBase, 0);\n    }\n    refundUnmatchedAndFinish(orderId, Status.Done, ReasonCode.ClientCancel);\n  }\n\n  // Public Order Placement - continue placing an order in 'NeedsGas' state\n  //\n  function continueOrder(uint128 orderId, uint maxMatches) public {\n    address client = msg.sender;\n    Order storage order = orderForOrderId[orderId];\n    require(order.client == client);\n    if (order.status != Status.NeedsGas) {\n      return;\n    }\n    ClientOrderEvent(client, ClientOrderEventType.Continue, orderId, maxMatches);\n    order.status = Status.Unknown;\n    processOrder(orderId, maxMatches);\n  }\n\n  // Internal Order Placement - remove a still-open order from the book.\n  //\n  // Caller's job to update/refund the order + raise event, this just\n  // updates the order chain and bitmask.\n  //\n  // Too expensive to do on each resting order match - we only do this for an\n  // order being cancelled. See matchWithOccupiedPrice for similar logic.\n  //\n  function removeOpenOrderFromBook(uint128 orderId) internal {\n    Order storage order = orderForOrderId[orderId];\n    uint16 price = order.price;\n    OrderChain storage orderChain = orderChainForOccupiedPrice[price];\n    OrderChainNode storage orderChainNode = orderChainNodeForOpenOrderId[orderId];\n    uint128 nextOrderId = orderChainNode.nextOrderId;\n    uint128 prevOrderId = orderChainNode.prevOrderId;\n    if (nextOrderId != 0) {\n      OrderChainNode storage nextOrderChainNode = orderChainNodeForOpenOrderId[nextOrderId];\n      nextOrderChainNode.prevOrderId = prevOrderId;\n    } else {\n      orderChain.lastOrderId = prevOrderId;\n    }\n    if (prevOrderId != 0) {\n      OrderChainNode storage prevOrderChainNode = orderChainNodeForOpenOrderId[prevOrderId];\n      prevOrderChainNode.nextOrderId = nextOrderId;\n    } else {\n      orderChain.firstOrderId = nextOrderId;\n    }\n    if (nextOrderId == 0 && prevOrderId == 0) {\n      uint bmi = price / 256;  // index into array of bitmaps\n      uint bti = price % 256;  // bit position within bitmap\n      // we know was previously occupied so XOR clears\n      occupiedPriceBitmaps[bmi] ^= 2 ** bti;\n    }\n  }\n\n  // Internal Order Placement - credit funds received when taking liquidity from book\n  //\n  function creditExecutedFundsLessFees(uint128 orderId, uint originalExecutedBase, uint originalExecutedCntr) internal {\n    Order storage order = orderForOrderId[orderId];\n    uint liquidityTakenBase = order.executedBase - originalExecutedBase;\n    uint liquidityTakenCntr = order.executedCntr - originalExecutedCntr;\n    // Normally we deduct the fee from the currency bought (base for buy, cntr for sell),\n    // however we also accept reward tokens from the reward balance if it covers the fee,\n    // with the reward amount converted from the ETH amount (the counter currency here)\n    // at a fixed exchange rate.\n    // Overflow safe since we ensure order size < 10^30 in both currencies (see baseMaxSize).\n    // Can truncate to zero, which is fine.\n    uint feesRwrd = liquidityTakenCntr / feeDivisor * ethRwrdRate;\n    uint feesBaseOrCntr;\n    address client = order.client;\n    uint availRwrd = balanceRwrdForClient[client];\n    if (feesRwrd <= availRwrd) {\n      balanceRwrdForClient[client] = availRwrd - feesRwrd;\n      balanceRwrdForClient[feeCollector] = feesRwrd;\n      // Need += rather than = because could have paid some fees earlier in NeedsGas situation.\n      // Overflow safe since we ensure order size < 10^30 in both currencies (see baseMaxSize).\n      // Can truncate to zero, which is fine.\n      order.feesRwrd += uint128(feesRwrd);\n      if (isBuyPrice(order.price)) {\n        balanceBaseForClient[client] += liquidityTakenBase;\n      } else {\n        balanceCntrForClient[client] += liquidityTakenCntr;\n      }\n    } else if (isBuyPrice(order.price)) {\n      // See comments in branch above re: use of += and overflow safety.\n      feesBaseOrCntr = liquidityTakenBase / feeDivisor;\n      balanceBaseForClient[order.client] += (liquidityTakenBase - feesBaseOrCntr);\n      order.feesBaseOrCntr += uint128(feesBaseOrCntr);\n      balanceBaseForClient[feeCollector] += feesBaseOrCntr;\n    } else {\n      // See comments in branch above re: use of += and overflow safety.\n      feesBaseOrCntr = liquidityTakenCntr / feeDivisor;\n      balanceCntrForClient[order.client] += (liquidityTakenCntr - feesBaseOrCntr);\n      order.feesBaseOrCntr += uint128(feesBaseOrCntr);\n      balanceCntrForClient[feeCollector] += feesBaseOrCntr;\n    }\n  }\n\n  // Internal Order Placement - process a created and sanity checked order.\n  //\n  // Used both for new orders and for gas topup.\n  //\n  function processOrder(uint128 orderId, uint maxMatches) internal {\n    Order storage order = orderForOrderId[orderId];\n\n    uint ourOriginalExecutedBase = order.executedBase;\n    uint ourOriginalExecutedCntr = order.executedCntr;\n\n    var (ourDirection,) = unpackPrice(order.price);\n    uint theirPriceStart = (ourDirection == Direction.Buy) ? minSellPrice : maxBuyPrice;\n    uint theirPriceEnd = computeOppositePrice(order.price);\n   \n    MatchStopReason matchStopReason =\n      matchAgainstBook(orderId, theirPriceStart, theirPriceEnd, maxMatches);\n\n    creditExecutedFundsLessFees(orderId, ourOriginalExecutedBase, ourOriginalExecutedCntr);\n\n    if (order.terms == Terms.ImmediateOrCancel) {\n      if (matchStopReason == MatchStopReason.Satisfied) {\n        refundUnmatchedAndFinish(orderId, Status.Done, ReasonCode.None);\n        return;\n      } else if (matchStopReason == MatchStopReason.MaxMatches) {\n        refundUnmatchedAndFinish(orderId, Status.Done, ReasonCode.TooManyMatches);\n        return;\n      } else if (matchStopReason == MatchStopReason.BookExhausted) {\n        refundUnmatchedAndFinish(orderId, Status.Done, ReasonCode.Unmatched);\n        return;\n      }\n    } else if (order.terms == Terms.MakerOnly) {\n      if (matchStopReason == MatchStopReason.MaxMatches) {\n        refundUnmatchedAndFinish(orderId, Status.Rejected, ReasonCode.WouldTake);\n        return;\n      } else if (matchStopReason == MatchStopReason.BookExhausted) {\n        enterOrder(orderId);\n        return;\n      }\n    } else if (order.terms == Terms.GTCNoGasTopup) {\n      if (matchStopReason == MatchStopReason.Satisfied) {\n        refundUnmatchedAndFinish(orderId, Status.Done, ReasonCode.None);\n        return;\n      } else if (matchStopReason == MatchStopReason.MaxMatches) {\n        refundUnmatchedAndFinish(orderId, Status.Done, ReasonCode.TooManyMatches);\n        return;\n      } else if (matchStopReason == MatchStopReason.BookExhausted) {\n        enterOrder(orderId);\n        return;\n      }\n    } else if (order.terms == Terms.GTCWithGasTopup) {\n      if (matchStopReason == MatchStopReason.Satisfied) {\n        refundUnmatchedAndFinish(orderId, Status.Done, ReasonCode.None);\n        return;\n      } else if (matchStopReason == MatchStopReason.MaxMatches) {\n        order.status = Status.NeedsGas;\n        return;\n      } else if (matchStopReason == MatchStopReason.BookExhausted) {\n        enterOrder(orderId);\n        return;\n      }\n    }\n    assert(false); // should not be possible to reach here\n  }\n \n  // Used internally to indicate why we stopped matching an order against the book.\n\n  enum MatchStopReason {\n    None,\n    MaxMatches,\n    Satisfied,\n    PriceExhausted,\n    BookExhausted\n  }\n \n  // Internal Order Placement - Match the given order against the book.\n  //\n  // Resting orders matched will be updated, removed from book and funds credited to their owners.\n  //\n  // Only updates the executedBase and executedCntr of the given order - caller is responsible\n  // for crediting matched funds, charging fees, marking order as done / entering it into the book.\n  //\n  // matchStopReason returned will be one of MaxMatches, Satisfied or BookExhausted.\n  //\n  // Calling with maxMatches == 0 is ok - and expected when the order is a maker-only order.\n  //\n  function matchAgainstBook(\n      uint128 orderId, uint theirPriceStart, uint theirPriceEnd, uint maxMatches\n    ) internal returns (\n      MatchStopReason matchStopReason\n    ) {\n    Order storage order = orderForOrderId[orderId];\n    \n    uint bmi = theirPriceStart / 256;  // index into array of bitmaps\n    uint bti = theirPriceStart % 256;  // bit position within bitmap\n    uint bmiEnd = theirPriceEnd / 256; // last bitmap to search\n    uint btiEnd = theirPriceEnd % 256; // stop at this bit in the last bitmap\n\n    uint cbm = occupiedPriceBitmaps[bmi]; // original copy of current bitmap\n    uint dbm = cbm; // dirty version of current bitmap where we may have cleared bits\n    uint wbm = cbm >> bti; // working copy of current bitmap which we keep shifting\n    \n    // Optimized loops could render a better matching engine yet!\n\n    bool removedLastAtPrice;\n    matchStopReason = MatchStopReason.None;\n\n    while (bmi < bmiEnd) {\n      if (wbm == 0 || bti == 256) {\n        if (dbm != cbm) {\n          occupiedPriceBitmaps[bmi] = dbm;\n        }\n        bti = 0;\n        bmi++;\n        cbm = occupiedPriceBitmaps[bmi];\n        wbm = cbm;\n        dbm = cbm;\n      } else {\n        if ((wbm & 1) != 0) {\n          // careful - copy-and-pasted in loop below ...\n          (removedLastAtPrice, maxMatches, matchStopReason) =\n            matchWithOccupiedPrice(order, uint16(bmi * 256 + bti), maxMatches);\n          if (removedLastAtPrice) {\n            dbm ^= 2 ** bti;\n          }\n          if (matchStopReason == MatchStopReason.PriceExhausted) {\n            matchStopReason = MatchStopReason.None;\n          } else if (matchStopReason != MatchStopReason.None) {\n            // we might still have changes in dbm to write back - see later\n            break;\n          }\n        }\n        bti += 1;\n        wbm /= 2;\n      }\n    }\n    if (matchStopReason == MatchStopReason.None) {\n      // we've reached the last bitmap we need to search,\n      // we'll stop at btiEnd not 256 this time.\n      while (bti <= btiEnd && wbm != 0) {\n        if ((wbm & 1) != 0) {\n          // careful - copy-and-pasted in loop above ...\n          (removedLastAtPrice, maxMatches, matchStopReason) =\n            matchWithOccupiedPrice(order, uint16(bmi * 256 + bti), maxMatches);\n          if (removedLastAtPrice) {\n            dbm ^= 2 ** bti;\n          }\n          if (matchStopReason == MatchStopReason.PriceExhausted) {\n            matchStopReason = MatchStopReason.None;\n          } else if (matchStopReason != MatchStopReason.None) {\n            break;\n          }\n        }\n        bti += 1;\n        wbm /= 2;\n      }\n    }\n    // Careful - if we exited the first loop early, or we went into the second loop,\n    // (luckily can't both happen) then we haven't flushed the dirty bitmap back to\n    // storage - do that now if we need to.\n    if (dbm != cbm) {\n      occupiedPriceBitmaps[bmi] = dbm;\n    }\n    if (matchStopReason == MatchStopReason.None) {\n      matchStopReason = MatchStopReason.BookExhausted;\n    }\n  }\n\n  // Internal Order Placement.\n  //\n  // Match our order against up to maxMatches resting orders at the given price (which\n  // is known by the caller to have at least one resting order).\n  //\n  // The matches (partial or complete) of the resting orders are recorded, and their\n  // funds are credited.\n  //\n  // The on chain orderbook with resting orders is updated, but the occupied price bitmap is NOT -\n  // the caller must clear the relevant bit if removedLastAtPrice = true is returned.\n  //\n  // Only updates the executedBase and executedCntr of our order - caller is responsible\n  // for e.g. crediting our matched funds, updating status.\n  //\n  // Calling with maxMatches == 0 is ok - and expected when the order is a maker-only order.\n  //\n  // Returns:\n  //   removedLastAtPrice:\n  //     true iff there are no longer any resting orders at this price - caller will need\n  //     to update the occupied price bitmap.\n  //\n  //   matchesLeft:\n  //     maxMatches passed in minus the number of matches made by this call\n  //\n  //   matchStopReason:\n  //     If our order is completely matched, matchStopReason will be Satisfied.\n  //     If our order is not completely matched, matchStopReason will be either:\n  //        MaxMatches (we are not allowed to match any more times)\n  //     or:\n  //        PriceExhausted (nothing left on the book at this exact price)\n  //\n  function matchWithOccupiedPrice(\n      Order storage ourOrder, uint16 theirPrice, uint maxMatches\n    ) internal returns (\n    bool removedLastAtPrice, uint matchesLeft, MatchStopReason matchStopReason) {\n    matchesLeft = maxMatches;\n    uint workingOurExecutedBase = ourOrder.executedBase;\n    uint workingOurExecutedCntr = ourOrder.executedCntr;\n    uint128 theirOrderId = orderChainForOccupiedPrice[theirPrice].firstOrderId;\n    matchStopReason = MatchStopReason.None;\n    while (true) {\n      if (matchesLeft == 0) {\n        matchStopReason = MatchStopReason.MaxMatches;\n        break;\n      }\n      uint matchBase;\n      uint matchCntr;\n      (theirOrderId, matchBase, matchCntr, matchStopReason) =\n        matchWithTheirs((ourOrder.sizeBase - workingOurExecutedBase), theirOrderId, theirPrice);\n      workingOurExecutedBase += matchBase;\n      workingOurExecutedCntr += matchCntr;\n      matchesLeft -= 1;\n      if (matchStopReason != MatchStopReason.None) {\n        break;\n      }\n    }\n    ourOrder.executedBase = uint128(workingOurExecutedBase);\n    ourOrder.executedCntr = uint128(workingOurExecutedCntr);\n    if (theirOrderId == 0) {\n      orderChainForOccupiedPrice[theirPrice].firstOrderId = 0;\n      orderChainForOccupiedPrice[theirPrice].lastOrderId = 0;\n      removedLastAtPrice = true;\n    } else {\n      // NB: in some cases (e.g. maxMatches == 0) this is a no-op.\n      orderChainForOccupiedPrice[theirPrice].firstOrderId = theirOrderId;\n      orderChainNodeForOpenOrderId[theirOrderId].prevOrderId = 0;\n      removedLastAtPrice = false;\n    }\n  }\n  \n  // Internal Order Placement.\n  //\n  // Match up to our remaining amount against a resting order in the book.\n  //\n  // The match (partial, complete or effectively-complete) of the resting order\n  // is recorded, and their funds are credited.\n  //\n  // Their order is NOT removed from the book by this call - the caller must do that\n  // if the nextTheirOrderId returned is not equal to the theirOrderId passed in.\n  //\n  // Returns:\n  //\n  //   nextTheirOrderId:\n  //     If we did not completely match their order, will be same as theirOrderId.\n  //     If we completely matched their order, will be orderId of next order at the\n  //     same price - or zero if this was the last order and we've now filled it.\n  //\n  //   matchStopReason:\n  //     If our order is completely matched, matchStopReason will be Satisfied.\n  //     If our order is not completely matched, matchStopReason will be either\n  //     PriceExhausted (if nothing left at this exact price) or None (if can continue).\n  // \n  function matchWithTheirs(\n    uint ourRemainingBase, uint128 theirOrderId, uint16 theirPrice) internal returns (\n    uint128 nextTheirOrderId, uint matchBase, uint matchCntr, MatchStopReason matchStopReason) {\n    Order storage theirOrder = orderForOrderId[theirOrderId];\n    uint theirRemainingBase = theirOrder.sizeBase - theirOrder.executedBase;\n    if (ourRemainingBase < theirRemainingBase) {\n      matchBase = ourRemainingBase;\n    } else {\n      matchBase = theirRemainingBase;\n    }\n    matchCntr = computeCntrAmountUsingPacked(matchBase, theirPrice);\n    // It may seem a bit odd to stop here if our remaining amount is very small -\n    // there could still be resting orders we can match it against. During network congestion gas\n    // cost of matching each order can become quite high - potentially high enough to\n    // wipe out the profit the taker hopes for from trading the tiny amount left.\n    if ((ourRemainingBase - matchBase) < baseMinRemainingSize) {\n      matchStopReason = MatchStopReason.Satisfied;\n    } else {\n      matchStopReason = MatchStopReason.None;\n    }\n    bool theirsDead = recordTheirMatch(theirOrder, theirOrderId, theirPrice, matchBase, matchCntr);\n    if (theirsDead) {\n      nextTheirOrderId = orderChainNodeForOpenOrderId[theirOrderId].nextOrderId;\n      if (matchStopReason == MatchStopReason.None && nextTheirOrderId == 0) {\n        matchStopReason = MatchStopReason.PriceExhausted;\n      }\n    } else {\n      nextTheirOrderId = theirOrderId;\n    }\n  }\n\n  // Internal Order Placement.\n  //\n  // Record match (partial or complete) of resting order, and credit them their funds.\n  //\n  // If their order is completely matched, the order is marked as done,\n  // and \"theirsDead\" is returned as true.\n  //\n  // The order is NOT removed from the book by this call - the caller\n  // must do that if theirsDead is true.\n  //\n  // No sanity checks are made - the caller must be sure the order is\n  // not already done and has sufficient remaining. (Yes, we'd like to\n  // check here too but we cannot afford the gas).\n  //\n  function recordTheirMatch(\n      Order storage theirOrder, uint128 theirOrderId, uint16 theirPrice, uint matchBase, uint matchCntr\n    ) internal returns (bool theirsDead) {\n    // they are a maker so no fees\n    // overflow safe - see comments about baseMaxSize\n    // executedBase cannot go > sizeBase due to logic in matchWithTheirs\n    theirOrder.executedBase += uint128(matchBase);\n    theirOrder.executedCntr += uint128(matchCntr);\n    if (isBuyPrice(theirPrice)) {\n      // they have bought base (using the counter they already paid when creating the order)\n      balanceBaseForClient[theirOrder.client] += matchBase;\n    } else {\n      // they have bought counter (using the base they already paid when creating the order)\n      balanceCntrForClient[theirOrder.client] += matchCntr;\n    }\n    uint stillRemainingBase = theirOrder.sizeBase - theirOrder.executedBase;\n    // avoid leaving tiny amounts in the book - refund remaining if too small\n    if (stillRemainingBase < baseMinRemainingSize) {\n      refundUnmatchedAndFinish(theirOrderId, Status.Done, ReasonCode.None);\n      // someone building an UI on top needs to know how much was match and how much was refund\n      MarketOrderEvent(block.timestamp, theirOrderId, MarketOrderEventType.CompleteFill,\n        theirPrice, matchBase + stillRemainingBase, matchBase);\n      return true;\n    } else {\n      MarketOrderEvent(block.timestamp, theirOrderId, MarketOrderEventType.PartialFill,\n        theirPrice, matchBase, matchBase);\n      return false;\n    }\n  }\n\n  // Internal Order Placement.\n  //\n  // Refund any unmatched funds in an order (based on executed vs size) and move to a final state.\n  //\n  // The order is NOT removed from the book by this call and no event is raised.\n  //\n  // No sanity checks are made - the caller must be sure the order has not already been refunded.\n  //\n  function refundUnmatchedAndFinish(uint128 orderId, Status status, ReasonCode reasonCode) internal {\n    Order storage order = orderForOrderId[orderId];\n    uint16 price = order.price;\n    if (isBuyPrice(price)) {\n      uint sizeCntr = computeCntrAmountUsingPacked(order.sizeBase, price);\n      balanceCntrForClient[order.client] += sizeCntr - order.executedCntr;\n    } else {\n      balanceBaseForClient[order.client] += order.sizeBase - order.executedBase;\n    }\n    order.status = status;\n    order.reasonCode = reasonCode;\n  }\n\n  // Internal Order Placement.\n  //\n  // Enter a not completely matched order into the book, marking the order as open.\n  //\n  // This updates the occupied price bitmap and chain.\n  //\n  // No sanity checks are made - the caller must be sure the order\n  // has some unmatched amount and has been paid for!\n  //\n  function enterOrder(uint128 orderId) internal {\n    Order storage order = orderForOrderId[orderId];\n    uint16 price = order.price;\n    OrderChain storage orderChain = orderChainForOccupiedPrice[price];\n    OrderChainNode storage orderChainNode = orderChainNodeForOpenOrderId[orderId];\n    if (orderChain.firstOrderId == 0) {\n      orderChain.firstOrderId = orderId;\n      orderChain.lastOrderId = orderId;\n      orderChainNode.nextOrderId = 0;\n      orderChainNode.prevOrderId = 0;\n      uint bitmapIndex = price / 256;\n      uint bitIndex = price % 256;\n      occupiedPriceBitmaps[bitmapIndex] |= (2 ** bitIndex);\n    } else {\n      uint128 existingLastOrderId = orderChain.lastOrderId;\n      OrderChainNode storage existingLastOrderChainNode = orderChainNodeForOpenOrderId[existingLastOrderId];\n      orderChainNode.nextOrderId = 0;\n      orderChainNode.prevOrderId = existingLastOrderId;\n      existingLastOrderChainNode.nextOrderId = orderId;\n      orderChain.lastOrderId = orderId;\n    }\n    MarketOrderEvent(block.timestamp, orderId, MarketOrderEventType.Add,\n      price, order.sizeBase - order.executedBase, 0);\n    order.status = Status.Open;\n  }\n\n  // Internal Order Placement.\n  //\n  // Charge the client for the cost of placing an order in the given direction.\n  //\n  // Return true if successful, false otherwise.\n  //\n  function debitFunds(\n      address client, Direction direction, uint sizeBase, uint sizeCntr\n    ) internal returns (bool success) {\n    if (direction == Direction.Buy) {\n      uint availableCntr = balanceCntrForClient[client];\n      if (availableCntr < sizeCntr) {\n        return false;\n      }\n      balanceCntrForClient[client] = availableCntr - sizeCntr;\n      return true;\n    } else if (direction == Direction.Sell) {\n      uint availableBase = balanceBaseForClient[client];\n      if (availableBase < sizeBase) {\n        return false;\n      }\n      balanceBaseForClient[client] = availableBase - sizeBase;\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  // Public Book View\n  // \n  // Intended for public book depth enumeration from web3 (or similar).\n  //\n  // Not suitable for use from a smart contract transaction - gas usage\n  // could be very high if we have many orders at the same price.\n  //\n  // Start at the given inclusive price (and side) and walk down the book\n  // (getting less aggressive) until we find some open orders or reach the\n  // least aggressive price.\n  //\n  // Returns the price where we found the order(s), the depth at that price\n  // (zero if none found), order count there, and the current blockNumber.\n  //\n  // (The blockNumber is handy if you're taking a snapshot which you intend\n  //  to keep up-to-date with the market order events).\n  //\n  // To walk through the on-chain orderbook, the caller should start by calling walkBook with the\n  // most aggressive buy price (Buy @ 999000).\n  // If the price returned is the least aggressive buy price (Buy @ 0.000001),\n  // the side is complete.\n  // Otherwise, call walkBook again with the (packed) price returned + 1.\n  // Then repeat for the sell side, starting with Sell @ 0.000001 and stopping\n  // when Sell @ 999000 is returned.\n  //\n  function walkBook(uint16 fromPrice) public constant returns (\n      uint16 price, uint depthBase, uint orderCount, uint blockNumber\n    ) {\n    uint priceStart = fromPrice;\n    uint priceEnd = (isBuyPrice(fromPrice)) ? minBuyPrice : maxSellPrice;\n    \n    // See comments in matchAgainstBook re: how these crazy loops work.\n    \n    uint bmi = priceStart / 256;\n    uint bti = priceStart % 256;\n    uint bmiEnd = priceEnd / 256;\n    uint btiEnd = priceEnd % 256;\n\n    uint wbm = occupiedPriceBitmaps[bmi] >> bti;\n    \n    while (bmi < bmiEnd) {\n      if (wbm == 0 || bti == 256) {\n        bti = 0;\n        bmi++;\n        wbm = occupiedPriceBitmaps[bmi];\n      } else {\n        if ((wbm & 1) != 0) {\n          // careful - copy-pasted in below loop\n          price = uint16(bmi * 256 + bti);\n          (depthBase, orderCount) = sumDepth(orderChainForOccupiedPrice[price].firstOrderId);\n          return (price, depthBase, orderCount, block.number);\n        }\n        bti += 1;\n        wbm /= 2;\n      }\n    }\n    // we've reached the last bitmap we need to search, stop at btiEnd not 256 this time.\n    while (bti <= btiEnd && wbm != 0) {\n      if ((wbm & 1) != 0) {\n        // careful - copy-pasted in above loop\n        price = uint16(bmi * 256 + bti);\n        (depthBase, orderCount) = sumDepth(orderChainForOccupiedPrice[price].firstOrderId);\n        return (price, depthBase, orderCount, block.number);\n      }\n      bti += 1;\n      wbm /= 2;\n    }\n    return (uint16(priceEnd), 0, 0, block.number);\n  }\n\n  // Internal Book View.\n  //\n  // See walkBook - adds up open depth at a price starting from an\n  // order which is assumed to be open. Careful - unlimited gas use.\n  //\n  function sumDepth(uint128 orderId) internal constant returns (uint depth, uint orderCount) {\n    while (true) {\n      Order storage order = orderForOrderId[orderId];\n      depth += order.sizeBase - order.executedBase;\n      orderCount++;\n      orderId = orderChainNodeForOpenOrderId[orderId].nextOrderId;\n      if (orderId == 0) {\n        return (depth, orderCount);\n      }\n    }\n  }\n}\n\n// helper for automating book creation\ncontract OnChainOrderBookV012bFactory {\n\n    event BookCreated (address bookAddress);\n\n    function OnChainOrderBookV012bFactory() {\n    }\n\n    function createBook(ERC20 _baseToken, ERC20 _rwrdToken, address _feeCollector, uint _baseMinInitialSize, int8 _minPriceExponent) public {\n        OnChainOrderBookV012b book = new OnChainOrderBookV012b();\n        book.init(_baseToken, _rwrdToken, _baseMinInitialSize, _minPriceExponent);\n        book.changeFeeCollector(_feeCollector);\n        BookCreated(address(book));\n    }\n}",
  "bytecode": "608060405234801561001057600080fd5b5060078054600160a060020a03191633179055612f77806100326000396000f3006080604052600436106100f05763ffffffff7c010000000000000000000000000000000000000000000000000000000060003504166303adcbd281146100f5578063117d41281461013c578063199f0791146101ea57806322ea2d961461020457806331f9a211146102835780633c13fc33146102f95780633e325589146103115780634dc7d31b14610341578063604451421461035957806361ea6ed7146103615780636f03e4f9146103765780639245290d146103cf578063929ba8bf146103f0578063a87d8b6b14610405578063bbec376814610468578063bd5acbd61461049c578063dbc91396146104c0575b600080fd5b34801561010157600080fd5b5061011161ffff600435166104e1565b6040805161ffff90951685526020850193909352838301919091526060830152519081900360800190f35b34801561014857600080fd5b5061015d6001608060020a036004351661064e565b60408051600160a060020a038c16815261ffff8b1660208201529081018990526060810188600381111561018d57fe5b60ff1681526020018760078111156101a157fe5b60ff1681526020018660088111156101b557fe5b60ff1681526020018581526020018481526020018381526020018281526020019a505050505050505050505060405180910390f35b3480156101f657600080fd5b506102026004356106cc565b005b34801561021057600080fd5b506102196107ab565b6040518089600081111561022957fe5b60ff168152600160a060020a0398891660208201529688166040808901919091526060880196909652506080860193909352600091820b90910b60a085015260c084015290921660e0820152905190819003610100019150f35b34801561028f57600080fd5b506102a46001608060020a03600435166107e5565b604051808760078111156102b457fe5b60ff1681526020018660088111156102c857fe5b60ff168152602001858152602001848152602001838152602001828152602001965050505050505060405180910390f35b34801561030557600080fd5b50610202600435610840565b34801561031d57600080fd5b50610202600160a060020a036004358116906024351660443560643560000b610960565b34801561034d57600080fd5b50610202600435610bd9565b610202610cf6565b34801561036d57600080fd5b50610202610d42565b34801561038257600080fd5b50610397600160a060020a0360043516610f85565b604080519788526020880196909652868601949094526060860192909252608085015260a084015260c0830152519081900360e00190f35b3480156103db57600080fd5b50610202600160a060020a03600435166111f5565b3480156103fc57600080fd5b50610202611256565b34801561041157600080fd5b50610438600160a060020a03600435166001608060020a0360243581169060443516611469565b604080516001608060020a038c16815261ffff8b1660208201529081018990526060810188600381111561018d57fe5b34801561047457600080fd5b506102026001608060020a036004351661ffff6024351660443560ff606435166084356115eb565b3480156104a857600080fd5b506102026001608060020a0360043516602435611b49565b3480156104cc57600080fd5b506102026001608060020a0360043516611c24565b600080808061ffff85168180808080806104fa8c611d8e565b6105065761546061050a565b612a305b955061010087049450610100870693506101008604925061010086069150836009866055811061053657fe5b01549060020a900490505b828510156105d357801580610557575083610100145b1561057c57600190940193600093506009856055811061057357fe5b015490506105ce565b60018116156105c2576101008502840161ffff81166000908152605e6020526040902054909b506105b5906001608060020a0316611db3565b909a509850439750610640565b60019390930192600290045b610541565b8184111580156105e257508015155b15610630576001811615610620576101008502840161ffff81166000908152605e6020526040902054909b506105b5906001608060020a0316611db3565b60019390930192600290046105d3565b9499506000985088975043965089945b505050505050509193509193565b6001608060020a0390811660009081526008602052604090208054600182015460028301546003840154600490940154600160a060020a0384169660a060020a90940461ffff1695929460ff808416956101008504821695620100008604909216946301000000900482169383831693608060020a90048316921690565b33600082116106da57600080fd5b600160a060020a0381166000908152600560205260409020548211156106ff57600080fd5b600160a060020a038116600081815260056020526040808220805486900390555184156108fc0291859190818181858888f19350505050158015610747573d6000803e3d6000fd5b5080600160a060020a0316600080516020612f0c833981519152600180856000036040518084600381111561077857fe5b60ff16815260200183600281111561078c57fe5b60ff168152602001828152602001935050505060405180910390a25050565b600080546003546001546062546007549495600160a060020a0394851695938516949293662386f26fc100009392880b926107d092911690565b6001608060020a0390811660009081526008602052604090206002810154600382015460049092015460ff610100830481169562010000840490911694630100000090930483169380841693608060020a9091048116921690565b336000821161084e57600080fd5b600160a060020a03811660009081526004602052604090205482111561087357600080fd5b600160a060020a03808216600081815260046020818152604080842080548990039055835481517fa9059cbb000000000000000000000000000000000000000000000000000000008152938401959095526024830188905251939094169363a9059cbb9360448084019492939192918390030190829087803b1580156108f857600080fd5b505af115801561090c573d6000803e3d6000fd5b505050506040513d602081101561092257600080fd5b5051151561092f57600080fd5b80600160a060020a0316600080516020612f0c83398151915260036000856000036040518084600381111561077857fe5b600754600160a060020a0316331461097757600080fd5b600054600160a060020a03161561098d57600080fd5b600160a060020a03841615156109a257600080fd5b600354600160a060020a0316156109b857600080fd5b600160a060020a03831615156109cd57600080fd5b600a8210156109db57600080fd5b69d3c21bcecceda100000082106109f157600080fd5b6013198160000b12158015610a0a575060148160000b13155b1515610a1557600080fd5b60028160000b1215610a3d57606254600090810b900b600303600a0a821015610a3d57600080fd5b6001829055600a820460025560628054600083810b60ff1660ff1990921691909117909155604080517f18160ddd0000000000000000000000000000000000000000000000000000000081529051600160a060020a038716916318160ddd91600480830192602092919082900301818787803b158015610abc57600080fd5b505af1158015610ad0573d6000803e3d6000fd5b505050506040513d6020811015610ae657600080fd5b505111610af257600080fd5b836000806101000a815481600160a060020a030219169083600160a060020a03160217905550600083600160a060020a03166318160ddd6040518163ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401602060405180830381600087803b158015610b7157600080fd5b505af1158015610b85573d6000803e3d6000fd5b505050506040513d6020811015610b9b57600080fd5b505111610ba757600080fd5b50506003805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a039290921691909117905550565b3360008211610be757600080fd5b600160a060020a038116600090815260066020526040902054821115610c0c57600080fd5b600160a060020a0380821660008181526006602090815260408083208054889003905560035481517fa9059cbb000000000000000000000000000000000000000000000000000000008152600481019590955260248501889052905194169363a9059cbb93604480820194918390030190829087803b158015610c8e57600080fd5b505af1158015610ca2573d6000803e3d6000fd5b505050506040513d6020811015610cb857600080fd5b50511515610cc557600080fd5b80600160a060020a0316600080516020612f0c83398151915260036002856000036040518084600381111561077857fe5b333460008111610d0557600080fd5b600160a060020a03821660008181526005602052604080822080548501905551600080516020612f0c833981519152919060019085908084610778565b600080546040805160e160020a636eb1769f02815233600482018190523060248301819052925190949293600160a060020a03169163dd62ed3e91604480830192602092919082900301818787803b158015610d9d57600080fd5b505af1158015610db1573d6000803e3d6000fd5b505050506040513d6020811015610dc757600080fd5b5051905060008111610dd857600080fd5b60008054604080517f23b872dd000000000000000000000000000000000000000000000000000000008152600160a060020a038781166004830152868116602483015260448201869052915191909216926323b872dd92606480820193602093909283900390910190829087803b158015610e5257600080fd5b505af1158015610e66573d6000803e3d6000fd5b505050506040513d6020811015610e7c57600080fd5b50511515610e8957600080fd5b600080546040805160e160020a636eb1769f028152600160a060020a03878116600483015286811660248301529151919092169263dd62ed3e92604480820193602093909283900390910190829087803b158015610ee657600080fd5b505af1158015610efa573d6000803e3d6000fd5b505050506040513d6020811015610f1057600080fd5b505115610f1957fe5b600160a060020a03831660008181526004602052604080822080548501905551600080516020612f0c83398151915291600291859080845b60ff168152602001836002811115610f6557fe5b60ff168152602001828152602001935050505060405180910390a2505050565b600160a060020a03808216600081815260046020818152604080842054600583528185205460068452828620548654845160e160020a636eb1769f0281529687019890985230602487015292519197909692959485948594859493169263dd62ed3e92604480820193929182900301818787803b15801561100557600080fd5b505af1158015611019573d6000803e3d6000fd5b505050506040513d602081101561102f57600080fd5b50516003546040805160e160020a636eb1769f028152600160a060020a038c81166004830152306024830152915193975091169163dd62ed3e916044808201926020929091908290030181600087803b15801561108b57600080fd5b505af115801561109f573d6000803e3d6000fd5b505050506040513d60208110156110b557600080fd5b505160008054604080517f70a08231000000000000000000000000000000000000000000000000000000008152600160a060020a038d8116600483015291519497509116926370a0823192602480840193602093929083900390910190829087803b15801561112357600080fd5b505af1158015611137573d6000803e3d6000fd5b505050506040513d602081101561114d57600080fd5b5051600354604080517f70a08231000000000000000000000000000000000000000000000000000000008152600160a060020a038c8116600483015291519395509116916370a08231916024808201926020929091908290030181600087803b1580156111b957600080fd5b505af11580156111cd573d6000803e3d6000fd5b505050506040513d60208110156111e357600080fd5b50519698959750939592949193509190565b600754600160a060020a031633811461120d57600080fd5b600160a060020a03828116908216141561122657600080fd5b506007805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b6003546040805160e160020a636eb1769f0281523360048201819052306024830181905292519093600092600160a060020a039091169163dd62ed3e9160448082019260209290919082900301818787803b1580156112b457600080fd5b505af11580156112c8573d6000803e3d6000fd5b505050506040513d60208110156112de57600080fd5b50519050600081116112ef57600080fd5b600354604080517f23b872dd000000000000000000000000000000000000000000000000000000008152600160a060020a038681166004830152858116602483015260448201859052915191909216916323b872dd9160648083019260209291908290030181600087803b15801561136657600080fd5b505af115801561137a573d6000803e3d6000fd5b505050506040513d602081101561139057600080fd5b5051151561139d57600080fd5b6003546040805160e160020a636eb1769f028152600160a060020a03868116600483015285811660248301529151919092169163dd62ed3e9160448083019260209291908290030181600087803b1580156113f757600080fd5b505af115801561140b573d6000803e3d6000fd5b505050506040513d602081101561142157600080fd5b50511561142a57fe5b600160a060020a0383166000818152600660205260409081902080548401905551600080516020612f0c83398151915290600290819085908083610f51565b6000808080808080808080806001608060020a038d1615156114ae57600160a060020a038e166000908152606060205260409020546001608060020a03169a506114cc565b6001608060020a03808e16600090815260616020526040902054169a505b6001608060020a038b1615156114e1576115da565b506001608060020a03808b166000818152600860205260409020918d161161150857611571565b600280820154610100900460ff16600781111561152157fe5b1480611544575060046002820154610100900460ff16600781111561154257fe5b145b1561154e57611571565b6001608060020a039a8b16600090815260616020526040902054909a16996114cc565b8054600182015460028301546003840154600485015460a060020a90940461ffff169d50919b5060ff8082169b50610100820481169a50620100008204169850630100000090046001608060020a0390811697508082169650608060020a909104811694501691505b5093979b5093979b91959950939750565b33600080808080806001608060020a038c161580159061162a57506001608060020a038c16600090815260086020526040902054600160a060020a0316155b151561163557600080fd5b86600160a060020a03167f98f28571fb2c7cab95fb6ca13908a1ba4a08e2b417317f72037ea2fafd2bca4760008e8b6040518084600281111561167457fe5b60ff1681526001608060020a0390931660208401525060408083019190915251908190036060019150a26101406040519081016040528088600160a060020a031681526020018c61ffff1681526020018b81526020018a60038111156116d657fe5b8152602001600081526020016000815260200160006001608060020a0316815260200160006001608060020a0316815260200160006001608060020a0316815260200160006001608060020a0316815250600860008e6001608060020a03166001608060020a0316815260200190815260200160002060008201518160000160006101000a815481600160a060020a030219169083600160a060020a0316021790555060208201518160000160146101000a81548161ffff021916908361ffff1602179055506040820151816001015560608201518160020160006101000a81548160ff021916908360038111156117ca57fe5b0217905550608082015160028201805461ff0019166101008360078111156117ee57fe5b021790555060a082015160028201805462ff000019166201000083600881111561181457fe5b021790555060c08201518160020160036101000a8154816001608060020a0302191690836001608060020a0316021790555060e08201518160030160006101000a8154816001608060020a0302191690836001608060020a031602179055506101008201518160030160106101000a8154816001608060020a0302191690836001608060020a031602179055506101208201518160040160006101000a8154816001608060020a0302191690836001608060020a031602179055509050506060600088600160a060020a0316600160a060020a0316815260200190815260200160002060009054906101000a90046001608060020a031695508b6060600089600160a060020a0316600160a060020a0316815260200190815260200160002060006101000a8154816001608060020a0302191690836001608060020a0316021790555085606160008e6001608060020a03166001608060020a0316815260200190815260200160002060006101000a8154816001608060020a0302191690836001608060020a03160217905550600860008d6001608060020a03166001608060020a0316815260200190815260200160002094506119d18b611e1d565b9195509350915060008460028111156119e657fe5b1415611a185760028501805461ff001916610100178082556001919062ff0000191662010000835b0217905550611b3b565b6001548a1080611a3457506c0c9f2c9cd04674edea400000008a115b15611a69576002850180546001919061ff001916610100835b02179055506002858101805462ff000019166201000083611a0e565b611a748a8484611ea1565b9050662386f26fc10000811080611a9757506c0c9f2c9cd04674edea4000000081115b15611ab4576002850180546001919061ff00191661010083611a4d565b6003896003811115611ac257fe5b148015611ace57508715155b15611af95760028501805461ff001916610100178082556003919062ff000019166201000083611a0e565b611b0587858c84611ef1565b1515611b315760028501805461ff001916610100178082556004919062ff000019166201000083611a0e565b611b3b8c89611fcf565b505050505050505050505050565b6001608060020a03821660009081526008602052604090208054339190600160a060020a03168214611b7a57600080fd5b60046002820154610100900460ff166007811115611b9457fe5b14611b9e57611c1e565b81600160a060020a03167f98f28571fb2c7cab95fb6ca13908a1ba4a08e2b417317f72037ea2fafd2bca476001868660405180846002811115611bdd57fe5b60ff1681526001608060020a0390931660208401525060408083019190915251908190036060019150a260028101805461ff0019169055611c1e8484611fcf565b50505050565b6001608060020a03811660009081526008602052604081208054339290600160a060020a03168314611c5557600080fd5b50600281810154610100900460ff1690816007811115611c7157fe5b14158015611c8b57506004816007811115611c8857fe5b14155b15611c9557611c1e565b82600160a060020a03167f98f28571fb2c7cab95fb6ca13908a1ba4a08e2b417317f72037ea2fafd2bca47600286600060405180846002811115611cd557fe5b60ff1681526001608060020a0390931660208401525060408083019190915251908190036060019150a26002816007811115611d0d57fe5b1415611d8157611d1c84612247565b815460028301546001808501546040805192835260a060020a90940461ffff1660208301526001608060020a0363010000009093048316900381840152600060608201529151908616914291600080516020612f2c8339815191529181900360800190a35b611c1e84600360086123bf565b600060018261ffff1610158015611dab5750612a308261ffff1611155b90505b919050565b60008060005b506001608060020a0392831660009081526008602090815260408083206002810154600180830154605f9095529290942054871696630100000090940490931690910393909301929190910190831515611e1257611e17565b611db9565b50915091565b6000808061ffff84168180806001841080611e39575061546084115b15611e4f57600096506000955060009450611e96565b612a308411611e68576001965083612a30039250611e74565b60029650612a31840392505b610384830691506103848360625460648501985060000b919004908101955090505b505050509193909250565b6000808260000b1215611ed4576000828103900b600a0a6103e861ffff8516860204811515611ecc57fe5b049050611eea565b506103e861ffff8316840204600082900b600a0a025b9392505050565b600080806001866002811115611f0357fe5b1415611f5b57600160a060020a038716600090815260056020526040902054915083821015611f355760009250611fc5565b600160a060020a0387166000908152600560205260409020848303905560019250611fc5565b6002866002811115611f6957fe5b1415611fc05750600160a060020a03861660009081526004602052604090205484811015611f9a5760009250611fc5565b600160a060020a0387166000908152600460205260409020858203905560019250611fc5565b600092505b5050949350505050565b6001608060020a0382811660009081526008602052604081206002810154600382015482549294630100000090920482169391169181908190819061201e9060a060020a900461ffff16611e1d565b509094506001905084600281111561203257fe5b1461203e576001612042565b612a315b875490935061205b9060a060020a900461ffff166124ca565b61ffff16915061206d8984848b612522565b905061207a898787612725565b60028088015460ff16600381111561208e57fe5b14156121015760028160048111156120a257fe5b14156120ba576120b589600360006123bf565b61223c565b60018160048111156120c857fe5b14156120db576120b589600360076123bf565b60048160048111156120e957fe5b14156120fc576120b589600360066123bf565b61223a565b6003600288015460ff16600381111561211657fe5b141561215a57600181600481111561212a57fe5b141561213d576120b589600160056123bf565b600481600481111561214b57fe5b14156120fc576120b589612937565b6000600288015460ff16600381111561216f57fe5b14156121b757600281600481111561218357fe5b1415612196576120b589600360006123bf565b60018160048111156121a457fe5b141561213d576120b589600360076123bf565b6001600288015460ff1660038111156121cc57fe5b141561223a5760028160048111156121e057fe5b14156121f3576120b589600360006123bf565b600181600481111561220157fe5b141561221d5760028701805461ff00191661040017905561223c565b600481600481111561222b57fe5b141561223a576120b589612937565bfe5b505050505050505050565b6001608060020a038181166000818152600860209081526040808320805460a060020a900461ffff16808552605e8452828520958552605f90935290832080549195929493909282811692608060020a9004169080808085156122d7576001608060020a038087166000908152605f602052604090208054878316608060020a02921691909117815593506122f0565b87546001608060020a03808716608060020a0291161788555b6001608060020a0385161561233d576001608060020a038581166000908152605f6020526040902080546fffffffffffffffffffffffffffffffff19169188169190911781559250612360565b87546fffffffffffffffffffffffffffffffff19166001608060020a0387161788555b6001608060020a03861615801561237e57506001608060020a038516155b156123b257505061010061ffff888116919091041660ff8816600281900a600983605581106123a957fe5b01805490911890555b5050505050505050505050565b6001608060020a03831660009081526008602052604081208054909160a060020a90910461ffff16906123f182611d8e565b1561243d57612404836001015483612acc565b60038401548454600160a060020a0316600090815260056020526040902080546001608060020a0390921683039091019055905061247c565b600283015460018401548454600160a060020a03166000908152600460205260409020805463010000009093046001608060020a031690910390910190555b60028301805486919061ff00191661010083600781111561249957fe5b021790555060028301805485919062ff00001916620100008360088111156124bd57fe5b0217905550505050505050565b600060018261ffff1610806124e457506154608261ffff16115b156124f157506000611dae565b612a3061ffff831611612510575061ffff811661546003600101611dae565b50600161ffff82166154600301611dae565b6001608060020a03841660009081526008602052604081206101008086049060ff808816918704908716858080806009886055811061255d57fe5b015460009a509350839250600287900a830491505b8588101561264357811580612588575086610100145b156125cb578284146125a55782600989605581106125a257fe5b01555b60019097019660009650600988605581106125bc57fe5b0154935083915083925061263e565b6001821615612630576125e589888a61010002018d612af3565b909c509a50905080156125fb578660020a831892505b60038a600481111561260957fe5b14156126185760009950612630565b60008a600481111561262657fe5b1461263057612643565b600196909601956002820491505b612572565b60008a600481111561265157fe5b14156126e3575b84871115801561266757508115155b156126e35760018216156126d15761268689888a61010002018d612af3565b909c509a509050801561269c578660020a831892505b60038a60048111156126aa57fe5b14156126b957600099506126d1565b60008a60048111156126c757fe5b146126d1576126e3565b60019690960195600282049150612658565b8284146126fb5782600989605581106126f857fe5b01555b60008a600481111561270957fe5b141561271457600499505b505050505050505050949350505050565b6001608060020a038381166000908152600860209081526040808320600281015460038201548254600160a060020a0316808752600690955292852054919563010000009091048116889003949216869003926107d084046103e802929180841161284457600160a060020a0380831660009081526006602052604080822087850390556007549092168152208490556004870180546001608060020a038082168701166fffffffffffffffffffffffffffffffff1990911617905586546127f89061ffff60a060020a90910416611d8e565b1561282057600160a060020a038216600090815260046020526040902080548701905561283f565b600160a060020a03821660009081526005602052604090208054860190555b61292b565b865461285a9060a060020a900461ffff16611d8e565b156128c7576107d0868854600160a060020a03908116600090815260046020526040808220805495909404808c039590950190935560038b0180546001608060020a03608060020a808304821688018216029116179055600754909116815220805482019055925061292b565b6107d0858854600160a060020a03908116600090815260056020526040808220805495909404808b039590950190935560038b0180546001608060020a03608060020a80830482168801821602911617905560075490911681522080548201905592505b50505050505050505050565b6001608060020a038181166000818152600860209081526040808320805460a060020a900461ffff16808552605e8452828520958552605f90935290832084549195929493909290918291829182911615156129f95785546fffffffffffffffffffffffffffffffff19166001608060020a038a811691821716608060020a919091021786556000855561010061ffff88811682810490911695500661ffff1692508260020a6009856055811015156129ec57fe5b0180549091179055612a51565b505083546001608060020a03608060020a9182900481166000818152605f60205260409020818402875580548b84166fffffffffffffffffffffffffffffffff19919091168117825588549402939092169290921786555b6002880154600189015460408051600080825261ffff8c1660208301526001608060020a036301000000909504851690930381830152606081019290925251918b16914291600080516020612f2c833981519152919081900360800190a350505050600293909301805461ff00191661020017905550505050565b6000806000612ada84611e1d565b9250925050612aea858383611ea1565b95945050505050565b6002830154600384015461ffff84166000908152605e60205260408120549092849284926001608060020a036301000000909304831692918216911683805b861515612b425760019550612b88565b612b53858c6001015403848c612c60565b600019909a019998509681019695860195919450925090506000866004811115612b7957fe5b14612b8357612b88565b612b32565b60028b01805472ffffffffffffffffffffffffffffffff000000191663010000006001608060020a03888116919091029190911790915560038c0180546fffffffffffffffffffffffffffffffff191686831617905583161515612c035761ffff8a166000908152605e602052604081205560019750612c52565b61ffff8a166000908152605e6020908152604080832080546fffffffffffffffffffffffffffffffff19166001608060020a038881169182179092558452605f90925282208054909116905597505b505050505093509350939050565b6001608060020a0380831660009081526008602052604081206002810154600182015492938493849384939092630100000090910416900382818a1015612ca957899550612cad565b8195505b612cb78689612acc565b9450600254868b031015612cce5760029350612cd3565b600093505b612ce0838a8a8989612d46565b90508015612d36576001608060020a03808a166000908152605f60205260408120549091169750846004811115612d1357fe5b148015612d2757506001608060020a038716155b15612d3157600393505b612d3a565b8896505b50505093509350935093565b60028501805472ffffffffffffffffffffffffffffffff0000001981166301000000918290046001608060020a0390811686018116909202179091556003860180546fffffffffffffffffffffffffffffffff1981169083168401909216919091179055600080612db685611d8e565b15612ddf578654600160a060020a03166000908152600460205260409020805485019055612dff565b8654600160a060020a031660009081526005602052604090208054840190555b8660020160039054906101000a90046001608060020a03166001608060020a03168760010154039050600254811015612ea357612e3f86600360006123bf565b856001608060020a031642600080516020612f2c8339815191526002888589018960405180856003811115612e7057fe5b60ff16815261ffff909416602085015250604080840192909252606083015251908190036080019150a360019150612f01565b856001608060020a031642600080516020612f2c833981519152600388888960405180856003811115612ed257fe5b60ff16815261ffff909416602085015250604080840192909252606083015251908190036080019150a3600091505b50959450505050505600caa7be131f5091d6ed32c02b2ba1f45c6721442175b1c8e1a9a5b453e54efe7540d0a103f9440846844f8f9a0d6968bb70b1a10f7ce225d40eb8796c4993258da165627a7a7230582097d957adeb4a6862c2ca0e86e2e0be3c01838597be98a70147b97903e4694c0e0029"
}