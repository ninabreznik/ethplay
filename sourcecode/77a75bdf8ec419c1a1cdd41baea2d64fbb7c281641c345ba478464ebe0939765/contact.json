{
  "address": "0x27ccda67fd7319efe097d0b562db96e9969433ba",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "Dinngo",
  "compilerVersion": "v0.5.6+commit.b259423e",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2019-04-25\n*/\n\ncontract SerializableOrder {\n    using SafeMath for uint256;\n    using BytesLib for bytes;\n\n    uint constant public ORDER_SIZE = 206;\n    uint constant public UNSIGNED_ORDER_SIZE = 141;\n    uint8 constant internal _MASK_IS_BUY = 0x01;\n    uint8 constant internal _MASK_IS_MAIN = 0x02;\n\n    /**\n     * @notice Get user ID from the serialized order data\n     * @param ser_data Serialized order data\n     * @return userID User ID\n     */\n    function _getOrderUserID(bytes memory ser_data) internal pure returns (uint256 userID) {\n        userID = ser_data.toUint32(ORDER_SIZE - 4);\n    }\n\n    /**\n     * @notice Get target token ID from the serialized order data\n     * @param ser_data Serialized order data\n     * @return tokenTarget Target token ID\n     */\n    function _getOrderTokenIDTarget(bytes memory ser_data) internal pure returns (uint256 tokenTarget) {\n        tokenTarget = ser_data.toUint16(ORDER_SIZE - 6);\n    }\n\n    /**\n     * @notice Get target token amount from the serialized order data\n     * @param ser_data Serialized order data\n     * @return amountTarget Target token amount\n     */\n    function _getOrderAmountTarget(bytes memory ser_data) internal pure returns (uint256 amountTarget) {\n        amountTarget = ser_data.toUint(ORDER_SIZE - 38);\n    }\n\n    /**\n     * @notice Get trade token ID from the serialized order data\n     * @param ser_data Serialized order data\n     * @return tokenTrade Trade token ID\n     */\n    function _getOrderTokenIDTrade(bytes memory ser_data) internal pure returns (uint256 tokenTrade) {\n        tokenTrade = ser_data.toUint16(ORDER_SIZE - 40);\n    }\n\n    /**\n     * @notice Get trade token amount from the serialized order data\n     * @param ser_data Serialized order data\n     * @return amountTrade Trade token amount\n     */\n    function _getOrderAmountTrade(bytes memory ser_data) internal pure returns (uint256 amountTrade) {\n        amountTrade = ser_data.toUint(ORDER_SIZE - 72);\n    }\n\n    /**\n     * @notice Check if the order is a buy order\n     * @param ser_data Serialized order data\n     * @return fBuy Is buy order or not\n     */\n    function _isOrderBuy(bytes memory ser_data) internal pure returns (bool fBuy) {\n        fBuy = (ser_data.toUint8(ORDER_SIZE - 73) & _MASK_IS_BUY != 0);\n    }\n\n    /**\n     * @notice Check if the fee is paid by main token\n     * @param ser_data Serialized order data\n     * @return fMain Is the fee paid in main token or not\n     */\n    function _isOrderFeeMain(bytes memory ser_data) internal pure returns (bool fMain) {\n        fMain = (ser_data.toUint8(ORDER_SIZE - 73) & _MASK_IS_MAIN != 0);\n    }\n\n    /**\n     * @notice Get nonce from the serialized order data\n     * @param ser_data Serialized order data\n     * @return nonce Nonce\n     */\n    function _getOrderNonce(bytes memory ser_data) internal pure returns (uint256 nonce) {\n        nonce = ser_data.toUint32(ORDER_SIZE - 77);\n    }\n\n    /**\n     * @notice Get trading fee from the serialized order data\n     * @param ser_data Serialized order data\n     * @return fee Fee amount\n     */\n    function _getOrderTradeFee(bytes memory ser_data) internal pure returns (uint256 tradeFee) {\n        tradeFee = ser_data.toUint(ORDER_SIZE - 109);\n    }\n\n    /**\n     * @notice Get gas fee from the serialized order data\n     * @param ser_data Serialized order data\n     * @return fee Fee amount\n     */\n    function _getOrderGasFee(bytes memory ser_data) internal pure returns (uint256 gasFee) {\n        gasFee = ser_data.toUint(ORDER_SIZE - 141);\n    }\n\n    /**\n     * @notice Get v from the serialized order data\n     * @param ser_data Serialized order data\n     * @return v Signature v\n     */\n    function _getOrderV(bytes memory ser_data) internal pure returns (uint8 v) {\n        v = ser_data.toUint8(ORDER_SIZE - 142);\n    }\n\n    /**\n     * @notice Get r from the serialized order data\n     * @param ser_data Serialized order data\n     * @return r Signature r\n     */\n    function _getOrderR(bytes memory ser_data) internal pure returns (bytes32 r) {\n        r = ser_data.toBytes32(ORDER_SIZE - 174);\n    }\n\n    /**\n     * @notice Get s from the serialized order data\n     * @param ser_data Serialized order data\n     * @return s Signature s\n     */\n    function _getOrderS(bytes memory ser_data) internal pure returns (bytes32 s) {\n        s = ser_data.toBytes32(ORDER_SIZE - 206);\n    }\n\n    /**\n     * @notice Get hash from the serialized order data\n     * @param ser_data Serialized order data\n     * @return hash Order hash without signature\n     */\n    function _getOrderHash(bytes memory ser_data) internal pure returns (bytes32 hash) {\n        hash = keccak256(ser_data.slice(65, UNSIGNED_ORDER_SIZE));\n    }\n\n    /**\n     * @notice Fetch the serialized order data with the given index\n     * @param ser_data Serialized order data\n     * @param index The index of order to be fetched\n     * @return order_data The fetched order data\n     */\n    function _getOrder(bytes memory ser_data, uint index) internal pure returns (bytes memory order_data) {\n        require(index < _getOrderCount(ser_data));\n        order_data = ser_data.slice(ORDER_SIZE.mul(index), ORDER_SIZE);\n    }\n\n    /**\n     * @notice Count the order amount\n     * @param ser_data Serialized order data\n     * @return amount Order amount\n     */\n    function _getOrderCount(bytes memory ser_data) internal pure returns (uint256 amount) {\n        amount = ser_data.length.div(ORDER_SIZE);\n    }\n}\n\ncontract SerializableWithdrawal {\n    using SafeMath for uint256;\n    using BytesLib for bytes;\n\n    uint constant public WITHDRAWAL_SIZE = 140;\n    uint constant public UNSIGNED_WITHDRAWAL_SIZE = 75;\n    uint8 constant internal _MASK_IS_ETH = 0x01;\n\n    /**\n     * @notice Get user ID from the serialized withdrawal data\n     * @param ser_data Serialized withdrawal data\n     * @return userID User ID\n     */\n    function _getWithdrawalUserID(bytes memory ser_data) internal pure returns (uint256 userID) {\n        userID = ser_data.toUint32(WITHDRAWAL_SIZE - 4);\n    }\n\n    /**\n     * @notice Get token ID from the serialized withdrawal data\n     * @param ser_data Serialized withdrawal data\n     * @return tokenID Withdrawal token ID\n     */\n    function _getWithdrawalTokenID(bytes memory ser_data) internal pure returns (uint256 tokenID) {\n        tokenID = ser_data.toUint16(WITHDRAWAL_SIZE - 6);\n    }\n\n    /**\n     * @notice Get amount from the serialized withdrawal data\n     * @param ser_data Serialized withdrawal data\n     * @return amount Withdrawal token amount\n     */\n    function _getWithdrawalAmount(bytes memory ser_data) internal pure returns (uint256 amount) {\n        amount = ser_data.toUint(WITHDRAWAL_SIZE - 38);\n    }\n\n    /**\n     * @notice Check if the fee is paid by main token\n     * @param ser_data Serialized withdrawal data\n     * @return fETH Is the fee paid in ETH or DGO\n     */\n    function _isWithdrawalFeeETH(bytes memory ser_data) internal pure returns (bool fFeeETH) {\n        fFeeETH = (ser_data.toUint8(WITHDRAWAL_SIZE - 39) & _MASK_IS_ETH != 0);\n    }\n\n    /**\n     * @notice Get nonce from the serialized withrawal data\n     * @param ser_data Serialized withdrawal data\n     * @return nonce Nonce\n     */\n    function _getWithdrawalNonce(bytes memory ser_data) internal pure returns (uint256 nonce) {\n        nonce = ser_data.toUint32(WITHDRAWAL_SIZE - 43);\n    }\n\n    /**\n     * @notice Get fee amount from the serialized withdrawal data\n     * @param ser_data Serialized withdrawal data\n     * @return fee Fee amount\n     */\n    function _getWithdrawalFee(bytes memory ser_data) internal pure returns (uint256 fee) {\n        fee = ser_data.toUint(WITHDRAWAL_SIZE - 75);\n    }\n\n    /**\n     * @notice Get v from the serialized withdrawal data\n     * @param ser_data Serialized withdrawal data\n     * @return v Signature v\n     */\n    function _getWithdrawalV(bytes memory ser_data) internal pure returns (uint8 v) {\n        v = ser_data.toUint8(WITHDRAWAL_SIZE - 76);\n    }\n\n    /**\n     * @notice Get r from the serialized withdrawal data\n     * @param ser_data Serialized withdrawal data\n     * @return r Signature r\n     */\n    function _getWithdrawalR(bytes memory ser_data) internal pure returns (bytes32 r) {\n        r = ser_data.toBytes32(WITHDRAWAL_SIZE - 108);\n    }\n\n    /**\n     * @notice Get s from the serialized withdrawal data\n     * @param ser_data Serialized withdrawal data\n     * @return s Signature s\n     */\n    function _getWithdrawalS(bytes memory ser_data) internal pure returns (bytes32 s) {\n        s = ser_data.toBytes32(WITHDRAWAL_SIZE - 140);\n    }\n\n    /**\n     * @notice Get hash from the serialized withdrawal data\n     * @param ser_data Serialized withdrawal data\n     * @return hash Withdrawal hash without signature\n     */\n    function _getWithdrawalHash(bytes memory ser_data) internal pure returns (bytes32 hash) {\n        hash = keccak256(ser_data.slice(65, UNSIGNED_WITHDRAWAL_SIZE));\n    }\n}\n\ncontract Dinngo is SerializableOrder, SerializableWithdrawal {\n    // Storage alignment\n    address private _owner;\n    mapping (address => bool) private admins;\n    uint256 private _nAdmin;\n    uint256 private _nLimit;\n    // end\n    using ECDSA for bytes32;\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    uint256 public processTime;\n\n    mapping (address => mapping (address => uint256)) public balances;\n    mapping (bytes32 => uint256) public orderFills;\n    mapping (uint256 => address payable) public userID_Address;\n    mapping (uint256 => address) public tokenID_Address;\n    mapping (address => uint256) public userRanks;\n    mapping (address => uint256) public tokenRanks;\n    mapping (address => uint256) public lockTimes;\n\n    event AddUser(uint256 userID, address indexed user);\n    event AddToken(uint256 tokenID, address indexed token);\n    event Deposit(address token, address indexed user, uint256 amount, uint256 balance);\n    event Withdraw(address token, address indexed user, uint256 amount, uint256 balance);\n    event Trade(\n        address indexed user,\n        bool isBuy,\n        address indexed tokenTarget,\n        uint256 amountTarget,\n        address indexed tokenTrade,\n        uint256 amountTrade\n    );\n    event Lock(address indexed user, uint256 lockTime);\n    event Unlock(address indexed user);\n\n    /**\n     * @dev All ether directly sent to contract will be refunded\n     */\n    function() external payable {\n        revert();\n    }\n\n    /**\n     * @notice Add the address to the user list. Event AddUser will be emitted\n     * after execution.\n     * @dev Record the user list to map the user address to a specific user ID, in\n     * order to compact the data size when transferring user address information\n     * @dev id should be less than 2**32\n     * @param id The user id to be assigned\n     * @param user The user address to be added\n     */\n    function addUser(uint256 id, address payable user) external {\n        require(user != address(0));\n        require(userRanks[user] == 0);\n        require(id < 2**32);\n        if (userID_Address[id] == address(0))\n            userID_Address[id] = user;\n        else\n            require(userID_Address[id] == user);\n        userRanks[user] = 1;\n        emit AddUser(id, user);\n    }\n\n    /**\n     * @notice Remove the address from the user list.\n     * @dev The user rank is set to 0 to remove the user.\n     * @param user The user address to be added\n     */\n    function removeUser(address user) external {\n        require(user != address(0));\n        require(userRanks[user] != 0);\n        userRanks[user] = 0;\n    }\n\n    /**\n     * @notice Update the rank of user. Can only be called by owner.\n     * @param user The user address\n     * @param rank The rank to be assigned\n     */\n    function updateUserRank(address user, uint256 rank) external {\n        require(user != address(0));\n        require(rank != 0);\n        require(userRanks[user] != 0);\n        require(userRanks[user] != rank);\n        userRanks[user] = rank;\n    }\n\n    /**\n     * @notice Add the token to the token list. Event AddToken will be emitted\n     * after execution.\n     * @dev Record the token list to map the token contract address to a specific\n     * token ID, in order to compact the data size when transferring token contract\n     * address information\n     * @dev id should be less than 2**16\n     * @param id The token id to be assigned\n     * @param token The token contract address to be added\n     */\n    function addToken(uint256 id, address token) external {\n        require(token != address(0));\n        require(tokenRanks[token] == 0);\n        require(id < 2**16);\n        if (tokenID_Address[id] == address(0))\n            tokenID_Address[id] = token;\n        else\n            require(tokenID_Address[id] == token);\n        tokenRanks[token] = 1;\n        emit AddToken(id, token);\n    }\n\n    /**\n     * @notice Remove the token to the token list.\n     * @dev The token rank is set to 0 to remove the token.\n     * @param token The token contract address to be removed.\n     */\n    function removeToken(address token) external {\n        require(token != address(0));\n        require(tokenRanks[token] != 0);\n        tokenRanks[token] = 0;\n    }\n\n    /**\n     * @notice Update the rank of token. Can only be called by owner.\n     * @param token The token contract address.\n     * @param rank The rank to be assigned.\n     */\n    function updateTokenRank(address token, uint256 rank) external {\n        require(token != address(0));\n        require(rank != 0);\n        require(tokenRanks[token] != 0);\n        require(tokenRanks[token] != rank);\n        tokenRanks[token] = rank;\n    }\n\n    /**\n     * @notice The deposit function for ether. The ether that is sent with the function\n     * call will be deposited. The first time user will be added to the user list.\n     * Event Deposit will be emitted after execution.\n     */\n    function deposit() external payable {\n        require(!_isLocking(msg.sender));\n        require(msg.value > 0);\n        balances[address(0)][msg.sender] = balances[address(0)][msg.sender].add(msg.value);\n        emit Deposit(address(0), msg.sender, msg.value, balances[address(0)][msg.sender]);\n    }\n\n    /**\n     * @notice The deposit function for tokens. The first time user will be added to\n     * the user list. Event Deposit will be emitted after execution.\n     * @param token Address of the token contract to be deposited\n     * @param amount Amount of the token to be depositied\n     */\n    function depositToken(address token, uint256 amount) external {\n        require(token != address(0));\n        require(!_isLocking(msg.sender));\n        require(_isValidToken(token));\n        require(amount > 0);\n        balances[token][msg.sender] = balances[token][msg.sender].add(amount);\n        emit Deposit(token, msg.sender, amount, balances[token][msg.sender]);\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n    }\n\n    /**\n     * @notice The withdraw function for ether. Event Withdraw will be emitted\n     * after execution. User needs to be locked before calling withdraw.\n     * @param amount The amount to be withdrawn.\n     */\n    function withdraw(uint256 amount) external {\n        require(_isLocked(msg.sender));\n        require(_isValidUser(msg.sender));\n        require(amount > 0);\n        balances[address(0)][msg.sender] = balances[address(0)][msg.sender].sub(amount);\n        emit Withdraw(address(0), msg.sender, amount, balances[address(0)][msg.sender]);\n        msg.sender.transfer(amount);\n    }\n\n    /**\n     * @notice The withdraw function for tokens. Event Withdraw will be emitted\n     * after execution. User needs to be locked before calling withdraw.\n     * @param token The token contract address to be withdrawn.\n     * @param amount The token amount to be withdrawn.\n     */\n    function withdrawToken(address token, uint256 amount) external {\n        require(token != address(0));\n        require(_isLocked(msg.sender));\n        require(_isValidUser(msg.sender));\n        require(_isValidToken(token));\n        require(amount > 0);\n        balances[token][msg.sender] = balances[token][msg.sender].sub(amount);\n        emit Withdraw(token, msg.sender, amount, balances[token][msg.sender]);\n        IERC20(token).safeTransfer(msg.sender, amount);\n    }\n\n    /**\n     * @notice The withdraw function that can only be triggered by owner.\n     * Event Withdraw will be emitted after execution.\n     * @param withdrawal The serialized withdrawal data\n     */\n    function withdrawByAdmin(bytes calldata withdrawal) external {\n        address payable user = userID_Address[_getWithdrawalUserID(withdrawal)];\n        address token = tokenID_Address[_getWithdrawalTokenID(withdrawal)];\n        uint256 amount = _getWithdrawalAmount(withdrawal);\n        uint256 amountFee = _getWithdrawalFee(withdrawal);\n        address tokenFee = _isWithdrawalFeeETH(withdrawal)? address(0) : tokenID_Address[1];\n        uint256 balance = balances[token][user].sub(amount);\n        require(_isValidUser(user));\n        _verifySig(\n            user,\n            _getWithdrawalHash(withdrawal),\n            _getWithdrawalR(withdrawal),\n            _getWithdrawalS(withdrawal),\n            _getWithdrawalV(withdrawal)\n        );\n        if (tokenFee == token) {\n            balance = balance.sub(amountFee);\n        } else {\n            balances[tokenFee][user] = balances[tokenFee][user].sub(amountFee);\n        }\n        balances[tokenFee][userID_Address[0]] =\n            balances[tokenFee][userID_Address[0]].add(amountFee);\n        balances[token][user] = balance;\n        emit Withdraw(token, user, amount, balance);\n        if (token == address(0)) {\n            user.transfer(amount);\n        } else {\n            IERC20(token).safeTransfer(user, amount);\n        }\n    }\n\n    /**\n     * @notice The settle function for orders. First order is taker order and the followings\n     * are maker orders.\n     * @param orders The serialized orders.\n     */\n    function settle(bytes calldata orders) external {\n        // Deal with the order list\n        uint256 nOrder = _getOrderCount(orders);\n        // Get the first order as the taker order\n        bytes memory takerOrder = _getOrder(orders, 0);\n        bytes32 takerHash = _getOrderHash(takerOrder);\n        uint256 takerAmountTarget = _getOrderAmountTarget(takerOrder).sub(orderFills[takerHash]);\n        uint256 fillAmountTrade = 0;\n        uint256 restAmountTarget = takerAmountTarget;\n        // Parse maker orders\n        for (uint i = 1; i < nOrder; i++) {\n            // Get ith order as the maker order\n            bytes memory makerOrder = _getOrder(orders, i);\n            require(_isOrderBuy(takerOrder) != _isOrderBuy(makerOrder));\n            uint256 makerAmountTrade = _getOrderAmountTrade(makerOrder);\n            uint256 makerAmountTarget = _getOrderAmountTarget(makerOrder);\n            bytes32 makerHash = _getOrderHash(makerOrder);\n            // Calculate the amount to be executed\n            uint256 amountTarget = makerAmountTarget.sub(orderFills[makerHash]);\n            amountTarget = amountTarget <= restAmountTarget? amountTarget : restAmountTarget;\n            uint256 amountTrade = makerAmountTrade.mul(amountTarget).div(makerAmountTarget);\n            restAmountTarget = restAmountTarget.sub(amountTarget);\n            fillAmountTrade = fillAmountTrade.add(amountTrade);\n            // Trade amountTarget and amountTrade for maker order\n            _trade(amountTarget, amountTrade, makerOrder);\n        }\n        // Sum the trade amount and check\n        restAmountTarget = takerAmountTarget.sub(restAmountTarget);\n        if (_isOrderBuy(takerOrder)) {\n            require(fillAmountTrade.mul(_getOrderAmountTarget(takerOrder))\n                <= _getOrderAmountTrade(takerOrder).mul(restAmountTarget));\n        } else {\n            require(fillAmountTrade.mul(_getOrderAmountTarget(takerOrder))\n                >= _getOrderAmountTrade(takerOrder).mul(restAmountTarget));\n        }\n        // Trade amountTarget and amountTrade for taker order\n        _trade(restAmountTarget, fillAmountTrade, takerOrder);\n    }\n\n    /**\n     * @notice Announce lock of the sender\n     */\n    function lock() external {\n        require(!_isLocking(msg.sender));\n        lockTimes[msg.sender] = now.add(processTime);\n        emit Lock(msg.sender, lockTimes[msg.sender]);\n    }\n\n    /**\n     * @notice Unlock the sender\n     */\n    function unlock() external {\n        require(_isLocking(msg.sender));\n        lockTimes[msg.sender] = 0;\n        emit Unlock(msg.sender);\n    }\n\n    /**\n     * @notice Change the processing time of locking the user address\n     */\n    function changeProcessTime(uint256 time) external {\n        require(processTime != time);\n        processTime = time;\n    }\n\n    /**\n     * @notice Process the trade by the providing information\n     * @dev Price equal amountTrade/amountTarget\n     * @param amountTarget The provided amount to be traded\n     * @param amountTrade The amount to be requested\n     * @param order The order that triggered the trading\n     */\n    function _trade(uint256 amountTarget, uint256 amountTrade, bytes memory order) internal {\n        require(amountTarget != 0);\n        // Get parameters\n        address user = userID_Address[_getOrderUserID(order)];\n        bytes32 hash = _getOrderHash(order);\n        address tokenTrade = tokenID_Address[_getOrderTokenIDTrade(order)];\n        address tokenTarget = tokenID_Address[_getOrderTokenIDTarget(order)];\n        uint256 balanceTrade;\n        uint256 balanceTarget;\n        require(_isValidUser(user));\n        // Trade\n        if (_isOrderBuy(order)) {\n            balanceTrade = balances[tokenTrade][user].sub(amountTrade);\n            balanceTarget = balances[tokenTarget][user].add(amountTarget);\n        } else {\n            balanceTrade = balances[tokenTrade][user].add(amountTrade);\n            balanceTarget = balances[tokenTarget][user].sub(amountTarget);\n        }\n        // Get fee\n        address tokenFee = _isOrderFeeMain(order)? tokenTrade : tokenID_Address[1];\n        uint256 amountFee = _getOrderTradeFee(order).mul(amountTarget).div(_getOrderAmountTarget(order));\n        // Order fill\n        if (orderFills[hash] == 0) {\n            _verifySig(user, hash, _getOrderR(order), _getOrderS(order), _getOrderV(order));\n            amountFee = amountFee.add(_getOrderGasFee(order));\n        }\n        orderFills[hash] = orderFills[hash].add(amountTarget);\n        if (tokenFee == tokenTarget) {\n            balanceTarget = balanceTarget.sub(amountFee);\n        } else if (tokenFee == tokenTrade) {\n            balanceTrade = balanceTrade.sub(amountFee);\n        } else {\n            balances[tokenFee][user] = balances[tokenFee][user].sub(amountFee);\n        }\n        balances[tokenFee][userID_Address[0]] = balances[tokenFee][userID_Address[0]].add(amountFee);\n        balances[tokenTarget][user] = balanceTarget;\n        balances[tokenTrade][user] = balanceTrade;\n        emit Trade\n        (\n            user,\n            _isOrderBuy(order),\n            tokenTarget,\n            amountTarget,\n            tokenTrade,\n            amountTrade\n        );\n    }\n\n    /**\n     * @dev Check if the user is valid\n     * @param user The user address to be checked.\n     */\n    function _isValidUser(address user) internal view returns (bool) {\n        return userRanks[user] != 0;\n    }\n\n    /**\n     * @dev Check if the token is valid\n     * @param token The token address to be checked.\n     */\n\n    function _isValidToken(address token) internal view returns (bool) {\n        return tokenRanks[token] != 0;\n    }\n\n    /**\n     * @notice Verify if the data is signed by the given user and signature\n     * @param user The signing user\n     * @param hash The data hash to be verified\n     * @param r The signature R\n     * @param s The signature S\n     * @param v The signature V\n     */\n    function _verifySig(address user, bytes32 hash, bytes32 r, bytes32 s, uint8 v) internal pure {\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n        if (v < 27) {\n            v += 27;\n        }\n        require(v == 27 || v == 28);\n\n        address sigAddr = ecrecover(hash.toEthSignedMessageHash(), v, r, s);\n        require(user == sigAddr);\n    }\n\n    /**\n     * @notice Return if the give user has announced lock\n     * @param user The user address to be queried\n     * @return Query result\n     */\n    function _isLocking(address user) internal view returns (bool) {\n        return lockTimes[user] > 0;\n    }\n\n    /**\n     * @notice Return if the user is locked\n     * @param user The user address to be queried\n     */\n    function _isLocked(address user) internal view returns (bool) {\n        return _isLocking(user) && lockTimes[user] < now;\n    }\n}\n\nlibrary BytesLib {\n    function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes memory) {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add \n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(0x40, and(\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n              not(31) // Round down to the nearest 32 bytes.\n            ))\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n            // Read the first 32 bytes of _preBytes storage, which is the length\n            // of the array. (We don't need to use the offset into the slot\n            // because arrays use the entire slot.)\n            let fslot := sload(_preBytes_slot)\n            // Arrays of 31 bytes or less have an even value in their slot,\n            // while longer arrays have an odd value. The actual length is\n            // the slot divided by two for odd values, and the lowest order\n            // byte divided by two for even values.\n            // If the slot is even, bitwise and the slot with 255 and divide by\n            // two to get the length. If the slot is odd, bitwise and the slot\n            // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let's prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n                // Since the new array still fits in the slot, we just need to\n                // update the contents of the slot.\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                    _preBytes_slot,\n                    // all the modifications to the slot are inside this\n                    // next block\n                    add(\n                        // we can just add to the slot contents because the\n                        // bytes we want to change are the LSBs\n                        fslot,\n                        add(\n                            mul(\n                                div(\n                                    // load the bytes from memory\n                                    mload(add(_postBytes, 0x20)),\n                                    // zero all bytes to the right\n                                    exp(0x100, sub(32, mlength))\n                                ),\n                                // and now shift left the number of bytes to\n                                // leave space for the length in the slot\n                                exp(0x100, sub(32, newlength))\n                            ),\n                            // increase length by the double of the memory\n                            // bytes length\n                            mul(mlength, 2)\n                        )\n                    )\n                )\n            }\n            case 1 {\n                // The stored value fits in the slot, but the combined value\n                // will exceed it.\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes_slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\n\n                // The contents of the _postBytes array start 32 bytes into\n                // the structure. Our first read should obtain the `submod`\n                // bytes that can fit into the unused space in the last word\n                // of the stored array. To get this, we read 32 bytes starting\n                // from `submod`, so the data we read overlaps with the array\n                // contents by `submod` bytes. Masking the lowest-order\n                // `submod` bytes allows us to add that value directly to the\n                // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                    sc,\n                    add(\n                        and(\n                            fslot,\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                        ),\n                        and(mload(mc), mask)\n                    )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes_slot)\n                // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\n\n                // Copy over the first `submod` bytes of the new data as in\n                // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n                \n                for { \n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(bytes memory _bytes, uint _start, uint _length) internal  pure returns (bytes memory) {\n        require(_bytes.length >= (_start + _length));\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint _start) internal  pure returns (address) {\n        require(_bytes.length >= (_start + 20));\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint _start) internal  pure returns (uint8) {\n        require(_bytes.length >= (_start + 1));\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint _start) internal  pure returns (uint16) {\n        require(_bytes.length >= (_start + 2));\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint _start) internal  pure returns (uint32) {\n        require(_bytes.length >= (_start + 4));\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint(bytes memory _bytes, uint _start) internal  pure returns (uint256) {\n        require(_bytes.length >= (_start + 32));\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint _start) internal  pure returns (bytes32) {\n        require(_bytes.length >= (_start + 32));\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n                // cb is a circuit breaker in the for loop since there's\n                //  no said feature for inline assembly loops\n                // cb = 1 - don't breaker\n                // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                // the next line is the loop condition:\n                // while(uint(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                        // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n        bool success = true;\n\n        assembly {\n            // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes_slot)\n            // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n                // slength can contain both the length and contents of the array\n                // if length < 32 bytes so let's prepare for that\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                        // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                            // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                        // cb is a circuit breaker in the for loop since there's\n                        //  no said feature for inline assembly loops\n                        // cb = 1 - don't breaker\n                        // cb = 0 - break\n                        let cb := 1\n\n                        // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes_slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                        // the next line is the loop condition:\n                        // while(uint(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                                // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}\n\nlibrary ECDSA {\n    /**\n     * @dev Recover signer address from a message by using their signature\n     * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\n     * @param signature bytes signature, the signature is generated using web3.eth.sign()\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Check the signature length\n        if (signature.length != 65) {\n            return (address(0));\n        }\n\n        // Divide the signature in r, s and v variables\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return address(0);\n        }\n\n        if (v != 27 && v != 28) {\n            return address(0);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        return ecrecover(hash, v, r, s);\n    }\n\n    /**\n     * toEthSignedMessageHash\n     * @dev prefix a bytes32 value with \"\\x19Ethereum Signed Message:\"\n     * and hash the result\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n}\n\nlibrary SafeMath {\n    /**\n     * @dev Multiplies two unsigned integers, reverts on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two unsigned integers, reverts on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n     * reverts when dividing by zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n\ninterface IERC20 {\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address who) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require((value == 0) || (token.allowance(address(this), spender) == 0));\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must equal true).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves.\n\n        // A Solidity high level call has three parts:\n        //  1. The target address is checked to verify it contains contract code\n        //  2. The call itself is made, and success asserted\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\n\n        require(address(token).isContract());\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success);\n\n        if (returndata.length > 0) { // Return data is optional\n            require(abi.decode(returndata, (bool)));\n        }\n    }\n}\n\nlibrary Address {\n    /**\n     * Returns whether the target address is a contract\n     * @dev This function will return false if invoked during the constructor of a contract,\n     * as the code is not actually created until after the constructor finishes.\n     * @param account address of the account to check\n     * @return whether the target address is a contract\n     */\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        // XXX Currently there is no better way to check if there is a contract in an address\n        // than to check the size of the code at that address.\n        // See https://ethereum.stackexchange.com/a/14016/36603\n        // for more details about how this works.\n        // TODO Check this again before the Serenity release, because all addresses will be\n        // contracts then.\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n}",
  "bytecode": "608060405234801561001057600080fd5b506122a3806100206000396000f3fe60806040526004361061019c5760003560e01c806390c3832d116100ec578063d0322fbf1161008a578063e8b93ad711610064578063e8b93ad714610635578063f1c5f1e21461065f578063f7213db614610689578063f83d08ba146106b35761019c565b8063d0322fbf1461059b578063d0e30db014610618578063dd41250f146106205761019c565b8063a69df4b5116100c6578063a69df4b5146104fd578063b46b791914610512578063b66860f41461054b578063c23f001f146105605761019c565b806390c3832d1461047c57806398575188146104915780639e281a98146104c45761019c565b806356c7c1b3116101595780635fa7b584116101335780635fa7b584146103d957806361959f851461040c578063829f2afc146104525780638c3508d8146104675761019c565b806356c7c1b31461033457806357016b0a1461036757806358d9fa04146103a05761019c565b806314e0c71f146101a15780632123cb78146102205780632e1a7d4d14610259578063338b5dea146102835780634a184239146102bc5780634d5edd2814610301575b600080fd5b3480156101ad57600080fd5b5061021e600480360360208110156101c457600080fd5b8101906020810181356401000000008111156101df57600080fd5b8201836020820111156101f157600080fd5b8035906020019184600183028401116401000000008311171561021357600080fd5b5090925090506106c8565b005b34801561022c57600080fd5b5061021e6004803603604081101561024357600080fd5b506001600160a01b038135169060200135610bce565b34801561026557600080fd5b5061021e6004803603602081101561027c57600080fd5b5035610c4e565b34801561028f57600080fd5b5061021e600480360360408110156102a657600080fd5b506001600160a01b038135169060200135610d40565b3480156102c857600080fd5b506102ef600480360360208110156102df57600080fd5b50356001600160a01b0316610e3b565b60408051918252519081900360200190f35b34801561030d57600080fd5b506102ef6004803603602081101561032457600080fd5b50356001600160a01b0316610e4d565b34801561034057600080fd5b506102ef6004803603602081101561035757600080fd5b50356001600160a01b0316610e5f565b34801561037357600080fd5b5061021e6004803603604081101561038a57600080fd5b50803590602001356001600160a01b0316610e71565b3480156103ac57600080fd5b5061021e600480360360408110156103c357600080fd5b50803590602001356001600160a01b0316610f79565b3480156103e557600080fd5b5061021e600480360360208110156103fc57600080fd5b50356001600160a01b0316611083565b34801561041857600080fd5b506104366004803603602081101561042f57600080fd5b50356110d2565b604080516001600160a01b039092168252519081900360200190f35b34801561045e57600080fd5b506102ef6110ed565b34801561047357600080fd5b506102ef6110f2565b34801561048857600080fd5b506102ef6110f7565b34801561049d57600080fd5b5061021e600480360360208110156104b457600080fd5b50356001600160a01b03166110fc565b3480156104d057600080fd5b5061021e600480360360408110156104e757600080fd5b506001600160a01b03813516906020013561114b565b34801561050957600080fd5b5061021e611256565b34801561051e57600080fd5b5061021e6004803603604081101561053557600080fd5b506001600160a01b0381351690602001356112a2565b34801561055757600080fd5b506102ef611322565b34801561056c57600080fd5b506102ef6004803603604081101561058357600080fd5b506001600160a01b0381358116916020013516611327565b3480156105a757600080fd5b5061021e600480360360208110156105be57600080fd5b8101906020810181356401000000008111156105d957600080fd5b8201836020820111156105eb57600080fd5b8035906020019184600183028401116401000000008311171561060d57600080fd5b509092509050611344565b61021e6115cb565b34801561062c57600080fd5b506102ef611682565b34801561064157600080fd5b506104366004803603602081101561065857600080fd5b5035611688565b34801561066b57600080fd5b5061021e6004803603602081101561068257600080fd5b50356116a3565b34801561069557600080fd5b506102ef600480360360208110156106ac57600080fd5b50356116b7565b3480156106bf57600080fd5b5061021e6116c9565b60006007600061070d85858080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061173c92505050565b815260200190815260200160002060009054906101000a90046001600160a01b0316905060006008600061077686868080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061175b92505050565b815260200190815260200160002060009054906101000a90046001600160a01b0316905060006107db85858080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061177892505050565b9050600061081e86868080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061179192505050565b9050600061086187878080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152506117a492505050565b61089f57600160005260086020527fad67d757c34507f157cacfa2e3153e9f260a2244f30428821be7be64587ac55f546001600160a01b03166108a2565b60005b6001600160a01b038086166000908152600560209081526040808320938a16835292905290812054919250906108de908563ffffffff6117c516565b90506108e9866117da565b6108f257600080fd5b6109f7866109358a8a8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152506117f792505050565b6109748b8b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061181a92505050565b6109b38c8c8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061182d92505050565b6109f28d8d8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061183f92505050565b611852565b846001600160a01b0316826001600160a01b03161415610a2857610a21818463ffffffff6117c516565b9050610a85565b6001600160a01b038083166000908152600560209081526040808320938a1683529290522054610a5e908463ffffffff6117c516565b6001600160a01b038084166000908152600560209081526040808320938b16835292905220555b6001600160a01b0380831660009081526005602090815260408083206000805160206122588339815191525490941683529290522054610acb908463ffffffff61191916565b6001600160a01b0380841660009081526005602081815260408084206000805160206122588339815191525486168552825280842095909555898416808452918152848320938b16808452938152918490208590558351908152908101879052808301849052915190917ff341246adaac6f497bc2a656f546ab9e182111d630394f0c57c710a59a2cb567919081900360600190a26001600160a01b038516610baa576040516001600160a01b0387169085156108fc029086906000818181858888f19350505050158015610ba4573d6000803e3d6000fd5b50610bc4565b610bc46001600160a01b038616878663ffffffff61193216565b5050505050505050565b6001600160a01b038216610be157600080fd5b80610beb57600080fd5b6001600160a01b0382166000908152600a6020526040902054610c0d57600080fd5b6001600160a01b0382166000908152600a6020526040902054811415610c3257600080fd5b6001600160a01b039091166000908152600a6020526040902055565b610c573361198c565b610c6057600080fd5b610c69336117da565b610c7257600080fd5b60008111610c7f57600080fd5b3360009081526000805160206122388339815191526020526040902054610cac908263ffffffff6117c516565b33600081815260008051602061223883398151915260209081526040808320859055805192835290820185905281810193909352915190917ff341246adaac6f497bc2a656f546ab9e182111d630394f0c57c710a59a2cb567919081900360600190a2604051339082156108fc029083906000818181858888f19350505050158015610d3c573d6000803e3d6000fd5b5050565b6001600160a01b038216610d5357600080fd5b610d5c336119bc565b15610d6657600080fd5b610d6f826119d9565b610d7857600080fd5b60008111610d8557600080fd5b6001600160a01b0382166000908152600560209081526040808320338452909152902054610db9908263ffffffff61191916565b6001600160a01b0383166000818152600560209081526040808320338085529083529281902085905580519384529083018590528281019390935291517fdcbc1c05240f31ff3ad067ef1ee35ce4997762752e3a095284754544f4c709d79181900360600190a2610d3c6001600160a01b03831633308463ffffffff6119f616565b600a6020526000908152604090205481565b60096020526000908152604090205481565b600b6020526000908152604090205481565b6001600160a01b038116610e8457600080fd5b6001600160a01b0381166000908152600a602052604090205415610ea757600080fd5b620100008210610eb657600080fd5b6000828152600860205260409020546001600160a01b0316610efe57600082815260086020526040902080546001600160a01b0319166001600160a01b038316179055610f24565b6000828152600860205260409020546001600160a01b03828116911614610f2457600080fd5b6001600160a01b0381166000818152600a602090815260409182902060019055815185815291517f374195d639167721eee596157426d922ffedad376d1ec774751088e8de1dcd0d9281900390910190a25050565b6001600160a01b038116610f8c57600080fd5b6001600160a01b03811660009081526009602052604090205415610faf57600080fd5b6401000000008210610fc057600080fd5b6000828152600760205260409020546001600160a01b031661100857600082815260076020526040902080546001600160a01b0319166001600160a01b03831617905561102e565b6000828152600760205260409020546001600160a01b0382811691161461102e57600080fd5b6001600160a01b03811660008181526009602090815260409182902060019055815185815291517fbf243b72bbb85c2ba6c30b23be7f331a52bf376571cb39a055f15278aa3edf3c9281900390910190a25050565b6001600160a01b03811661109657600080fd5b6001600160a01b0381166000908152600a60205260409020546110b857600080fd5b6001600160a01b03166000908152600a6020526040812055565b6007602052600090815260409020546001600160a01b031681565b60ce81565b608d81565b608c81565b6001600160a01b03811661110f57600080fd5b6001600160a01b03811660009081526009602052604090205461113157600080fd5b6001600160a01b0316600090815260096020526040812055565b6001600160a01b03821661115e57600080fd5b6111673361198c565b61117057600080fd5b611179336117da565b61118257600080fd5b61118b826119d9565b61119457600080fd5b600081116111a157600080fd5b6001600160a01b03821660009081526005602090815260408083203384529091529020546111d5908263ffffffff6117c516565b6001600160a01b0383166000818152600560209081526040808320338085529083529281902085905580519384529083018590528281019390935291517ff341246adaac6f497bc2a656f546ab9e182111d630394f0c57c710a59a2cb5679181900360600190a2610d3c6001600160a01b038316338363ffffffff61193216565b61125f336119bc565b61126857600080fd5b336000818152600b6020526040808220829055517f0be774851955c26a1d6a32b13b020663a069006b4a3b643ff0b809d3182605729190a2565b6001600160a01b0382166112b557600080fd5b806112bf57600080fd5b6001600160a01b0382166000908152600960205260409020546112e157600080fd5b6001600160a01b03821660009081526009602052604090205481141561130657600080fd5b6001600160a01b03909116600090815260096020526040902055565b604b81565b600560209081526000928352604080842090915290825290205481565b600061138583838080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250611a5992505050565b905060606113c884848080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201829052509250611a6f915050565b905060006113d582611aa8565b60008181526006602052604081205491925090611401906113f585611abd565b9063ffffffff6117c516565b905060008160015b868110156115395760606114548a8a8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250869250611a6f915050565b905061145f81611ad0565b151561146a88611ad0565b1515141561147757600080fd5b600061148282611ae5565b9050600061148f83611abd565b9050600061149c84611aa8565b600081815260066020526040812054919250906114c090849063ffffffff6117c516565b9050868111156114d057866114d2565b805b905060006114f6846114ea878563ffffffff611af816565b9063ffffffff611b1f16565b9050611508888363ffffffff6117c516565b975061151a898263ffffffff61191916565b9850611527828288611b41565b50506001909401935061140992505050565b5061154a838263ffffffff6117c516565b905061155585611ad0565b1561159c576115738161156787611ae5565b9063ffffffff611af816565b61158c61157f87611abd565b849063ffffffff611af816565b111561159757600080fd5b6115c0565b6115a98161156787611ae5565b6115b561157f87611abd565b10156115c057600080fd5b610bc4818387611b41565b6115d4336119bc565b156115de57600080fd5b600034116115eb57600080fd5b3360009081526000805160206122388339815191526020526040902054611618903463ffffffff61191916565b336000818152600080516020612238833981519152602081815260408084208690558484529181528151928352349083015281810193909352915190917fdcbc1c05240f31ff3ad067ef1ee35ce4997762752e3a095284754544f4c709d7919081900360600190a2565b60045481565b6008602052600090815260409020546001600160a01b031681565b8060045414156116b257600080fd5b600455565b60066020526000908152604090205481565b6116d2336119bc565b156116dc57600080fd5b6004546116f090429063ffffffff61191916565b336000818152600b60209081526040918290208490558151938452905191927f625fed9875dada8643f2418b838ae0bc78d9a148a18eee4ee1979ff0f3f5d427929081900390910190a2565b600061174f82608863ffffffff611f9916565b63ffffffff1692915050565b600061176e82608663ffffffff611fb516565b61ffff1692915050565b600061178b82606663ffffffff611fd116565b92915050565b600061178b82604163ffffffff611fd116565b600060016117b983606563ffffffff611fed16565b1660ff16151592915050565b6000828211156117d457600080fd5b50900390565b6001600160a01b0316600090815260096020526040902054151590565b600061180c826041604b63ffffffff61200916565b805190602001209050919050565b600061178b82602063ffffffff611fd116565b600061178b828263ffffffff611fd116565b600061178b82604063ffffffff611fed16565b601b8160ff16101561186257601b015b8060ff16601b148061187757508060ff16601c145b61188057600080fd5b6000600161188d86612089565b83868660405160008152602001604052604051808581526020018460ff1660ff1681526020018381526020018281526020019450505050506020604051602081039080840390855afa1580156118e7573d6000803e3d6000fd5b505050602060405103519050806001600160a01b0316866001600160a01b03161461191157600080fd5b505050505050565b60008282018381101561192b57600080fd5b9392505050565b604080516001600160a01b038416602482015260448082018490528251808303909101815260649091019091526020810180516001600160e01b0316600160e01b63a9059cbb021790526119879084906120da565b505050565b6000611997826119bc565b801561178b5750506001600160a01b03166000908152600b6020526040902054421190565b6001600160a01b03166000908152600b6020526040902054151590565b6001600160a01b03166000908152600a6020526040902054151590565b604080516001600160a01b0385811660248301528416604482015260648082018490528251808303909101815260849091019091526020810180516001600160e01b0316600160e01b6323b872dd02179052611a539085906120da565b50505050565b805160009061178b9060ce63ffffffff611b1f16565b6060611a7a83611a59565b8210611a8557600080fd5b61192b611a9960ce8463ffffffff611af816565b849060ce63ffffffff61200916565b600061180c826041608d63ffffffff61200916565b600061178b8260a863ffffffff611fd116565b600060016117b983608563ffffffff611fed16565b600061178b82608663ffffffff611fd116565b600082611b075750600061178b565b82820282848281611b1457fe5b041461192b57600080fd5b6000808211611b2d57600080fd5b6000828481611b3857fe5b04949350505050565b82611b4b57600080fd5b600060076000611b5a846121d0565b815260208101919091526040016000908120546001600160a01b03169150611b8183611aa8565b9050600060086000611b92866121e3565b815260208101919091526040016000908120546001600160a01b03169150600881611bbc876121f6565b815260208101919091526040016000908120546001600160a01b0316915080611be4866117da565b611bed57600080fd5b611bf687611ad0565b15611c71576001600160a01b038085166000908152600560209081526040808320938a1683529290522054611c31908963ffffffff6117c516565b6001600160a01b038085166000908152600560209081526040808320938b1683529290522054909250611c6a908a63ffffffff61191916565b9050611ce3565b6001600160a01b038085166000908152600560209081526040808320938a1683529290522054611ca7908963ffffffff61191916565b6001600160a01b038085166000908152600560209081526040808320938b1683529290522054909250611ce0908a63ffffffff6117c516565b90505b6000611cee88612209565b611d2c57600160005260086020527fad67d757c34507f157cacfa2e3153e9f260a2244f30428821be7be64587ac55f546001600160a01b0316611d2e565b845b90506000611d4b611d3e8a611abd565b6114ea8d6115678d61221e565b600088815260066020526040902054909150611d9d57611d818888611d6f8c61181a565b611d788d61182d565b6109f28e61183f565b611d9a611d8d8a611791565b829063ffffffff61191916565b90505b600087815260066020526040902054611dbc908c63ffffffff61191916565b6000888152600660205260409020556001600160a01b038281169086161415611df657611def838263ffffffff6117c516565b9250611e84565b856001600160a01b0316826001600160a01b03161415611e2757611e20848263ffffffff6117c516565b9350611e84565b6001600160a01b038083166000908152600560209081526040808320938c1683529290522054611e5d908263ffffffff6117c516565b6001600160a01b038084166000908152600560209081526040808320938d16835292905220555b6001600160a01b0380831660009081526005602090815260408083206000805160206122588339815191525490941683529290522054611eca908263ffffffff61191916565b6001600160a01b03808416600090815260056020818152604080842060008051602061225883398151915254861685528252808420959095558984168084528282528584208e86168086529083528685208a9055948c168085529282528584208585529091529390912087905591907f4a68b34faf5dd268be25bab80592718fdfe94f50a60757365b81d3905dbf409a611f638d611ad0565b8f8f6040518084151515158152602001838152602001828152602001935050505060405180910390a45050505050505050505050565b60008160040183511015611fac57600080fd5b50016004015190565b60008160020183511015611fc857600080fd5b50016002015190565b60008160200183511015611fe457600080fd5b50016020015190565b6000816001018351101561200057600080fd5b50016001015190565b60608183018451101561201b57600080fd5b60608215801561203657604051915060208201604052612080565b6040519150601f8416801560200281840101858101878315602002848b0101015b8183101561206f578051835260209283019201612057565b5050858452601f01601f1916604052505b50949350505050565b604080517f19457468657265756d205369676e6564204d6573736167653a0a333200000000602080830191909152603c8083019490945282518083039094018452605c909101909152815191012090565b6120ec826001600160a01b0316612231565b6120f557600080fd5b60006060836001600160a01b0316836040518082805190602001908083835b602083106121335780518252601f199092019160209182019101612114565b6001836020036101000a0380198251168184511680821785525050505050509050019150506000604051808303816000865af19150503d8060008114612195576040519150601f19603f3d011682016040523d82523d6000602084013e61219a565b606091505b5091509150816121a957600080fd5b805115611a53578080602001905160208110156121c557600080fd5b5051611a5357600080fd5b600061174f8260ca63ffffffff611f9916565b600061176e8260a663ffffffff611fb516565b600061176e8260c863ffffffff611fb516565b600060026117b983608563ffffffff611fed16565b600061178b82606163ffffffff611fd116565b3b15159056fe05b8ccbb9d4d8fb16ea74ce3c29a41f1b461fbdaff4714a0d9a8eb05499746bc6d5257204ebe7d88fd91ae87941cb2dd9d8062b64ae5a2bd2d28ec40b9fbf6dfa165627a7a723058209499380bf58299e767d5fe05ab2b07069597f305a98ef1c1d36a1632c3fe61680029"
}