{
  "address": "0x59523b19e6614f9e6acede42100619458ee01eab",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "QuantstampAuditPolice",
  "compilerVersion": "v0.4.25+commit.59dbf8f1",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2019-05-14\n*/\n\npragma solidity 0.4.25;\n\n// File: contracts/LinkedListLib.sol\n\n/**\n * @title LinkedListLib\n * @author Darryl Morris (o0ragman0o) and Modular.network\n *\n * This utility library was forked from https://github.com/o0ragman0o/LibCLL\n * into the Modular-Network ethereum-libraries repo at https://github.com/Modular-Network/ethereum-libraries\n * It has been updated to add additional functionality and be more compatible with solidity 0.4.18\n * coding patterns.\n *\n * version 1.1.1\n * Copyright (c) 2017 Modular Inc.\n * The MIT License (MIT)\n * https://github.com/Modular-network/ethereum-libraries/blob/master/LICENSE\n *\n * The LinkedListLib provides functionality for implementing data indexing using\n * a circlular linked list\n *\n * Modular provides smart contract services and security reviews for contract\n * deployments in addition to working on open source projects in the Ethereum\n * community. Our purpose is to test, document, and deploy reusable code onto the\n * blockchain and improve both security and usability. We also educate non-profits,\n * schools, and other community members about the application of blockchain\n * technology. For further information: modular.network\n *\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n\nlibrary LinkedListLib {\n\n    uint256 constant NULL = 0;\n    uint256 constant HEAD = 0;\n    bool constant PREV = false;\n    bool constant NEXT = true;\n\n    struct LinkedList{\n        mapping (uint256 => mapping (bool => uint256)) list;\n    }\n\n    /// @dev returns true if the list exists\n    /// @param self stored linked list from contract\n    function listExists(LinkedList storage self)\n        public\n        view returns (bool)\n    {\n        // if the head nodes previous or next pointers both point to itself, then there are no items in the list\n        if (self.list[HEAD][PREV] != HEAD || self.list[HEAD][NEXT] != HEAD) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /// @dev returns true if the node exists\n    /// @param self stored linked list from contract\n    /// @param _node a node to search for\n    function nodeExists(LinkedList storage self, uint256 _node)\n        public\n        view returns (bool)\n    {\n        if (self.list[_node][PREV] == HEAD && self.list[_node][NEXT] == HEAD) {\n            if (self.list[HEAD][NEXT] == _node) {\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /// @dev Returns the number of elements in the list\n    /// @param self stored linked list from contract\n    function sizeOf(LinkedList storage self) public view returns (uint256 numElements) {\n        bool exists;\n        uint256 i;\n        (exists,i) = getAdjacent(self, HEAD, NEXT);\n        while (i != HEAD) {\n            (exists,i) = getAdjacent(self, i, NEXT);\n            numElements++;\n        }\n        return;\n    }\n\n    /// @dev Returns the links of a node as a tuple\n    /// @param self stored linked list from contract\n    /// @param _node id of the node to get\n    function getNode(LinkedList storage self, uint256 _node)\n        public view returns (bool,uint256,uint256)\n    {\n        if (!nodeExists(self,_node)) {\n            return (false,0,0);\n        } else {\n            return (true,self.list[_node][PREV], self.list[_node][NEXT]);\n        }\n    }\n\n    /// @dev Returns the link of a node `_node` in direction `_direction`.\n    /// @param self stored linked list from contract\n    /// @param _node id of the node to step from\n    /// @param _direction direction to step in\n    function getAdjacent(LinkedList storage self, uint256 _node, bool _direction)\n        public view returns (bool,uint256)\n    {\n        if (!nodeExists(self,_node)) {\n            return (false,0);\n        } else {\n            return (true,self.list[_node][_direction]);\n        }\n    }\n\n    /// @dev Can be used before `insert` to build an ordered list\n    /// @param self stored linked list from contract\n    /// @param _node an existing node to search from, e.g. HEAD.\n    /// @param _value value to seek\n    /// @param _direction direction to seek in\n    //  @return next first node beyond '_node' in direction `_direction`\n    function getSortedSpot(LinkedList storage self, uint256 _node, uint256 _value, bool _direction)\n        public view returns (uint256)\n    {\n        if (sizeOf(self) == 0) { return 0; }\n        require((_node == 0) || nodeExists(self,_node));\n        bool exists;\n        uint256 next;\n        (exists,next) = getAdjacent(self, _node, _direction);\n        while  ((next != 0) && (_value != next) && ((_value < next) != _direction)) next = self.list[next][_direction];\n        return next;\n    }\n\n    /// @dev Creates a bidirectional link between two nodes on direction `_direction`\n    /// @param self stored linked list from contract\n    /// @param _node first node for linking\n    /// @param _link  node to link to in the _direction\n    function createLink(LinkedList storage self, uint256 _node, uint256 _link, bool _direction) private  {\n        self.list[_link][!_direction] = _node;\n        self.list[_node][_direction] = _link;\n    }\n\n    /// @dev Insert node `_new` beside existing node `_node` in direction `_direction`.\n    /// @param self stored linked list from contract\n    /// @param _node existing node\n    /// @param _new  new node to insert\n    /// @param _direction direction to insert node in\n    function insert(LinkedList storage self, uint256 _node, uint256 _new, bool _direction) internal returns (bool) {\n        if(!nodeExists(self,_new) && nodeExists(self,_node)) {\n            uint256 c = self.list[_node][_direction];\n            createLink(self, _node, _new, _direction);\n            createLink(self, _new, c, _direction);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /// @dev removes an entry from the linked list\n    /// @param self stored linked list from contract\n    /// @param _node node to remove from the list\n    function remove(LinkedList storage self, uint256 _node) internal returns (uint256) {\n        if ((_node == NULL) || (!nodeExists(self,_node))) { return 0; }\n        createLink(self, self.list[_node][PREV], self.list[_node][NEXT], NEXT);\n        delete self.list[_node][PREV];\n        delete self.list[_node][NEXT];\n        return _node;\n    }\n\n    /// @dev pushes an enrty to the head of the linked list\n    /// @param self stored linked list from contract\n    /// @param _node new entry to push to the head\n    /// @param _direction push to the head (NEXT) or tail (PREV)\n    function push(LinkedList storage self, uint256 _node, bool _direction) internal  {\n        insert(self, HEAD, _node, _direction);\n    }\n\n    /// @dev pops the first entry from the linked list\n    /// @param self stored linked list from contract\n    /// @param _direction pop from the head (NEXT) or the tail (PREV)\n    function pop(LinkedList storage self, bool _direction) internal returns (uint256) {\n        bool exists;\n        uint256 adj;\n\n        (exists,adj) = getAdjacent(self, HEAD, _direction);\n\n        return remove(self, adj);\n    }\n}\n\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipRenounced(address indexed previousOwner);\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to relinquish control of the contract.\n   */\n  function renounceOwnership() public onlyOwner {\n    emit OwnershipRenounced(owner);\n    owner = address(0);\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address _newOwner) public onlyOwner {\n    _transferOwnership(_newOwner);\n  }\n\n  /**\n   * @dev Transfers control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function _transferOwnership(address _newOwner) internal {\n    require(_newOwner != address(0));\n    emit OwnershipTransferred(owner, _newOwner);\n    owner = _newOwner;\n  }\n}\n\n// File: openzeppelin-solidity/contracts/ownership/rbac/Roles.sol\n\n/**\n * @title Roles\n * @author Francisco Giordano (@frangio)\n * @dev Library for managing addresses assigned to a Role.\n *      See RBAC.sol for example usage.\n */\nlibrary Roles {\n  struct Role {\n    mapping (address => bool) bearer;\n  }\n\n  /**\n   * @dev give an address access to this role\n   */\n  function add(Role storage role, address addr)\n    internal\n  {\n    role.bearer[addr] = true;\n  }\n\n  /**\n   * @dev remove an address' access to this role\n   */\n  function remove(Role storage role, address addr)\n    internal\n  {\n    role.bearer[addr] = false;\n  }\n\n  /**\n   * @dev check if an address has this role\n   * // reverts\n   */\n  function check(Role storage role, address addr)\n    view\n    internal\n  {\n    require(has(role, addr));\n  }\n\n  /**\n   * @dev check if an address has this role\n   * @return bool\n   */\n  function has(Role storage role, address addr)\n    view\n    internal\n    returns (bool)\n  {\n    return role.bearer[addr];\n  }\n}\n\n// File: openzeppelin-solidity/contracts/ownership/rbac/RBAC.sol\n\n/**\n * @title RBAC (Role-Based Access Control)\n * @author Matt Condon (@Shrugs)\n * @dev Stores and provides setters and getters for roles and addresses.\n * @dev Supports unlimited numbers of roles and addresses.\n * @dev See //contracts/mocks/RBACMock.sol for an example of usage.\n * This RBAC method uses strings to key roles. It may be beneficial\n *  for you to write your own implementation of this interface using Enums or similar.\n * It's also recommended that you define constants in the contract, like ROLE_ADMIN below,\n *  to avoid typos.\n */\ncontract RBAC {\n  using Roles for Roles.Role;\n\n  mapping (string => Roles.Role) private roles;\n\n  event RoleAdded(address addr, string roleName);\n  event RoleRemoved(address addr, string roleName);\n\n  /**\n   * @dev reverts if addr does not have role\n   * @param addr address\n   * @param roleName the name of the role\n   * // reverts\n   */\n  function checkRole(address addr, string roleName)\n    view\n    public\n  {\n    roles[roleName].check(addr);\n  }\n\n  /**\n   * @dev determine if addr has role\n   * @param addr address\n   * @param roleName the name of the role\n   * @return bool\n   */\n  function hasRole(address addr, string roleName)\n    view\n    public\n    returns (bool)\n  {\n    return roles[roleName].has(addr);\n  }\n\n  /**\n   * @dev add a role to an address\n   * @param addr address\n   * @param roleName the name of the role\n   */\n  function addRole(address addr, string roleName)\n    internal\n  {\n    roles[roleName].add(addr);\n    emit RoleAdded(addr, roleName);\n  }\n\n  /**\n   * @dev remove a role from an address\n   * @param addr address\n   * @param roleName the name of the role\n   */\n  function removeRole(address addr, string roleName)\n    internal\n  {\n    roles[roleName].remove(addr);\n    emit RoleRemoved(addr, roleName);\n  }\n\n  /**\n   * @dev modifier to scope access to a single role (uses msg.sender as addr)\n   * @param roleName the name of the role\n   * // reverts\n   */\n  modifier onlyRole(string roleName)\n  {\n    checkRole(msg.sender, roleName);\n    _;\n  }\n\n  /**\n   * @dev modifier to scope access to a set of roles (uses msg.sender as addr)\n   * @param roleNames the names of the roles to scope access to\n   * // reverts\n   *\n   * @TODO - when solidity supports dynamic arrays as arguments to modifiers, provide this\n   *  see: https://github.com/ethereum/solidity/issues/2467\n   */\n  // modifier onlyRoles(string[] roleNames) {\n  //     bool hasAnyRole = false;\n  //     for (uint8 i = 0; i < roleNames.length; i++) {\n  //         if (hasRole(msg.sender, roleNames[i])) {\n  //             hasAnyRole = true;\n  //             break;\n  //         }\n  //     }\n\n  //     require(hasAnyRole);\n\n  //     _;\n  // }\n}\n\n// File: openzeppelin-solidity/contracts/ownership/Whitelist.sol\n\n/**\n * @title Whitelist\n * @dev The Whitelist contract has a whitelist of addresses, and provides basic authorization control functions.\n * @dev This simplifies the implementation of \"user permissions\".\n */\ncontract Whitelist is Ownable, RBAC {\n  event WhitelistedAddressAdded(address addr);\n  event WhitelistedAddressRemoved(address addr);\n\n  string public constant ROLE_WHITELISTED = \"whitelist\";\n\n  /**\n   * @dev Throws if called by any account that's not whitelisted.\n   */\n  modifier onlyWhitelisted() {\n    checkRole(msg.sender, ROLE_WHITELISTED);\n    _;\n  }\n\n  /**\n   * @dev add an address to the whitelist\n   * @param addr address\n   * @return true if the address was added to the whitelist, false if the address was already in the whitelist\n   */\n  function addAddressToWhitelist(address addr)\n    onlyOwner\n    public\n  {\n    addRole(addr, ROLE_WHITELISTED);\n    emit WhitelistedAddressAdded(addr);\n  }\n\n  /**\n   * @dev getter to determine if address is in whitelist\n   */\n  function whitelist(address addr)\n    public\n    view\n    returns (bool)\n  {\n    return hasRole(addr, ROLE_WHITELISTED);\n  }\n\n  /**\n   * @dev add addresses to the whitelist\n   * @param addrs addresses\n   * @return true if at least one address was added to the whitelist,\n   * false if all addresses were already in the whitelist\n   */\n  function addAddressesToWhitelist(address[] addrs)\n    onlyOwner\n    public\n  {\n    for (uint256 i = 0; i < addrs.length; i++) {\n      addAddressToWhitelist(addrs[i]);\n    }\n  }\n\n  /**\n   * @dev remove an address from the whitelist\n   * @param addr address\n   * @return true if the address was removed from the whitelist,\n   * false if the address wasn't in the whitelist in the first place\n   */\n  function removeAddressFromWhitelist(address addr)\n    onlyOwner\n    public\n  {\n    removeRole(addr, ROLE_WHITELISTED);\n    emit WhitelistedAddressRemoved(addr);\n  }\n\n  /**\n   * @dev remove addresses from the whitelist\n   * @param addrs addresses\n   * @return true if at least one address was removed from the whitelist,\n   * false if all addresses weren't in the whitelist in the first place\n   */\n  function removeAddressesFromWhitelist(address[] addrs)\n    onlyOwner\n    public\n  {\n    for (uint256 i = 0; i < addrs.length; i++) {\n      removeAddressFromWhitelist(addrs[i]);\n    }\n  }\n\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/BasicToken.sol\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    emit Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256) {\n    return balances[_owner];\n  }\n\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender)\n    public view returns (uint256);\n\n  function transferFrom(address from, address to, uint256 value)\n    public returns (bool);\n\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/StandardToken.sol\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  )\n    public\n    returns (bool)\n  {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    emit Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    emit Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(\n    address _owner,\n    address _spender\n   )\n    public\n    view\n    returns (uint256)\n  {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(\n    address _spender,\n    uint _addedValue\n  )\n    public\n    returns (bool)\n  {\n    allowed[msg.sender][_spender] = (\n      allowed[msg.sender][_spender].add(_addedValue));\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(\n    address _spender,\n    uint _subtractedValue\n  )\n    public\n    returns (bool)\n  {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n// File: contracts/QuantstampAuditData.sol\n\ncontract QuantstampAuditData is Whitelist {\n  // state of audit requests submitted to the contract\n  enum AuditState {\n    None,\n    Queued,\n    Assigned,\n    Refunded,\n    Completed,  // automated audit finished successfully and the report is available\n    Error,      // automated audit failed to finish; the report contains detailed information about the error\n    Expired,\n    Resolved\n  }\n\n  // structure representing an audit\n  struct Audit {\n    address requestor;\n    string contractUri;\n    uint256 price;\n    uint256 requestBlockNumber; // block number that audit was requested\n    QuantstampAuditData.AuditState state;\n    address auditor;       // the address of the node assigned to the audit\n    uint256 assignBlockNumber;  // block number that audit was assigned\n    string reportHash;     // stores the hash of audit report\n    uint256 reportBlockNumber;  // block number that the payment and the audit report were submitted\n    address registrar;  // address of the contract which registers this request\n  }\n\n  // map audits (requestId, Audit)\n  mapping(uint256 => Audit) public audits;\n\n  // token used to pay for audits. This contract assumes that the owner of the contract trusts token's code and\n  // that transfer function (such as transferFrom, transfer) do the right thing\n  StandardToken public token;\n\n  // Once an audit node gets an audit request, they must submit a report within this many blocks.\n  // After that, the report is verified by the police.\n  uint256 public auditTimeoutInBlocks = 50;\n\n  // maximum number of assigned audits per each audit node\n  uint256 public maxAssignedRequests = 10;\n\n  // map audit nodes to their minimum prices. Defaults to zero: the node accepts all requests.\n  mapping(address => uint256) public minAuditPrice;\n\n  // For generating requestIds starting from 1\n  uint256 private requestCounter;\n\n  /**\n   * @dev The constructor creates an audit contract.\n   * @param tokenAddress The address of a StandardToken that will be used to pay audit nodes.\n   */\n  constructor (address tokenAddress) public {\n    require(tokenAddress != address(0));\n    token = StandardToken(tokenAddress);\n  }\n\n  function addAuditRequest (address requestor, string contractUri, uint256 price) public onlyWhitelisted returns(uint256) {\n    // assign the next request ID\n    uint256 requestId = ++requestCounter;\n    // store the audit\n    audits[requestId] = Audit(requestor, contractUri, price, block.number, AuditState.Queued, address(0), 0, \"\", 0, msg.sender);  // solhint-disable-line not-rely-on-time\n    return requestId;\n  }\n\n  /**\n   * @dev Allows a whitelisted logic contract (QuantstampAudit) to spend stored tokens.\n   * @param amount The number of wei-QSP that will be approved.\n   */\n  function approveWhitelisted(uint256 amount) public onlyWhitelisted {\n    token.approve(msg.sender, amount);\n  }\n\n  function getAuditContractUri(uint256 requestId) public view returns(string) {\n    return audits[requestId].contractUri;\n  }\n\n  function getAuditRequestor(uint256 requestId) public view returns(address) {\n    return audits[requestId].requestor;\n  }\n\n  function getAuditPrice (uint256 requestId) public view returns(uint256) {\n    return audits[requestId].price;\n  }\n\n  function getAuditState (uint256 requestId) public view returns(AuditState) {\n    return audits[requestId].state;\n  }\n\n  function getAuditRequestBlockNumber (uint256 requestId) public view returns(uint) {\n    return audits[requestId].requestBlockNumber;\n  }\n\n  function setAuditState (uint256 requestId, AuditState state) public onlyWhitelisted {\n    audits[requestId].state = state;\n  }\n\n  function getAuditAuditor (uint256 requestId) public view returns(address) {\n    return audits[requestId].auditor;\n  }\n\n  function getAuditRegistrar (uint256 requestId) public view returns(address) {\n    return audits[requestId].registrar;\n  }\n\n  function setAuditAuditor (uint256 requestId, address auditor) public onlyWhitelisted {\n    audits[requestId].auditor = auditor;\n  }\n\n  function getAuditAssignBlockNumber (uint256 requestId) public view returns(uint256) {\n    return audits[requestId].assignBlockNumber;\n  }\n\n  function getAuditReportBlockNumber (uint256 requestId) public view returns (uint256) {\n    return audits[requestId].reportBlockNumber;\n  }\n\n  function setAuditAssignBlockNumber (uint256 requestId, uint256 assignBlockNumber) public onlyWhitelisted {\n    audits[requestId].assignBlockNumber = assignBlockNumber;\n  }\n\n  function setAuditReportHash (uint256 requestId, string reportHash) public onlyWhitelisted {\n    audits[requestId].reportHash = reportHash;\n  }\n\n  function setAuditReportBlockNumber (uint256 requestId, uint256 reportBlockNumber) public onlyWhitelisted {\n    audits[requestId].reportBlockNumber = reportBlockNumber;\n  }\n\n  function setAuditRegistrar (uint256 requestId, address registrar) public onlyWhitelisted {\n    audits[requestId].registrar = registrar;\n  }\n\n  function setAuditTimeout (uint256 timeoutInBlocks) public onlyOwner {\n    auditTimeoutInBlocks = timeoutInBlocks;\n  }\n\n  /**\n   * @dev Set the maximum number of audits any audit node can handle at any time.\n   * @param maxAssignments Maximum number of audit requests for each audit node.\n   */\n  function setMaxAssignedRequests (uint256 maxAssignments) public onlyOwner {\n    maxAssignedRequests = maxAssignments;\n  }\n\n  function getMinAuditPrice (address auditor) public view returns(uint256) {\n    return minAuditPrice[auditor];\n  }\n\n  /**\n   * @dev Allows the audit node to set its minimum price per audit in wei-QSP.\n   * @param price The minimum price.\n   */\n  function setMinAuditPrice(address auditor, uint256 price) public onlyWhitelisted {\n    minAuditPrice[auditor] = price;\n  }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n    require(token.transfer(to, value));\n  }\n\n  function safeTransferFrom(\n    ERC20 token,\n    address from,\n    address to,\n    uint256 value\n  )\n    internal\n  {\n    require(token.transferFrom(from, to, value));\n  }\n\n  function safeApprove(ERC20 token, address spender, uint256 value) internal {\n    require(token.approve(spender, value));\n  }\n}\n\n// File: contracts/token_escrow/TokenEscrow.sol\n\n/**\n * NOTE: All contracts in this directory were taken from a non-master branch of openzeppelin-solidity.\n * This contract was modified to be a whitelist.\n * Commit: ed451a8688d1fa7c927b27cec299a9726667d9b1\n */\n\npragma solidity ^0.4.24;\n\n\n\n\n\n\n/**\n * @title TokenEscrow\n * @dev Holds tokens destinated to a payee until they withdraw them.\n * The contract that uses the TokenEscrow as its payment method\n * should be its owner, and provide public methods redirecting\n * to the TokenEscrow's deposit and withdraw.\n * Moreover, the TokenEscrow should also be allowed to transfer\n * tokens from the payer to itself.\n */\ncontract TokenEscrow is Ownable, Whitelist {\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20;\n\n  event Deposited(address indexed payee, uint256 tokenAmount);\n  event Withdrawn(address indexed payee, uint256 tokenAmount);\n\n  mapping(address => uint256) public deposits;\n\n  ERC20 public token;\n\n  constructor (ERC20 _token) public {\n    require(_token != address(0));\n    token = _token;\n  }\n\n  function depositsOf(address _payee) public view returns (uint256) {\n    return deposits[_payee];\n  }\n\n  /**\n  * @dev Puts in escrow a certain amount of tokens as credit to be withdrawn.\n  * @param _payee The destination address of the tokens.\n  * @param _amount The amount of tokens to deposit in escrow.\n  */\n  function deposit(address _payee, uint256 _amount) public onlyWhitelisted {\n    deposits[_payee] = deposits[_payee].add(_amount);\n\n    token.safeTransferFrom(msg.sender, address(this), _amount);\n\n    emit Deposited(_payee, _amount);\n  }\n\n  /**\n  * @dev Withdraw accumulated tokens for a payee.\n  * @param _payee The address whose tokens will be withdrawn and transferred to.\n  */\n  function withdraw(address _payee) public onlyWhitelisted {\n    uint256 payment = deposits[_payee];\n    assert(token.balanceOf(address(this)) >= payment);\n\n    deposits[_payee] = 0;\n\n    token.safeTransfer(_payee, payment);\n\n    emit Withdrawn(_payee, payment);\n  }\n}\n\n// File: contracts/token_escrow/ConditionalTokenEscrow.sol\n\n/**\n * NOTE: All contracts in this directory were taken from a non-master branch of openzeppelin-solidity.\n * Commit: ed451a8688d1fa7c927b27cec299a9726667d9b1\n */\n\npragma solidity ^0.4.24;\n\n\n\n/**\n * @title ConditionalTokenEscrow\n * @dev Base abstract escrow to only allow withdrawal of tokens\n * if a condition is met.\n */\ncontract ConditionalTokenEscrow is TokenEscrow {\n  /**\n  * @dev Returns whether an address is allowed to withdraw their tokens.\n  * To be implemented by derived contracts.\n  * @param _payee The destination address of the tokens.\n  */\n  function withdrawalAllowed(address _payee) public view returns (bool);\n\n  function withdraw(address _payee) public {\n    require(withdrawalAllowed(_payee));\n    super.withdraw(_payee);\n  }\n}\n\n// File: contracts/QuantstampAuditTokenEscrow.sol\n\ncontract QuantstampAuditTokenEscrow is ConditionalTokenEscrow {\n\n  // the escrow maintains the list of staked addresses\n  using LinkedListLib for LinkedListLib.LinkedList;\n\n  // constants used by LinkedListLib\n  uint256 constant internal NULL = 0;\n  uint256 constant internal HEAD = 0;\n  bool constant internal PREV = false;\n  bool constant internal NEXT = true;\n\n  // maintain the number of staked nodes\n  // saves gas cost over needing to call stakedNodesList.sizeOf()\n  uint256 public stakedNodesCount = 0;\n\n  // the minimum amount of wei-QSP that must be staked in order to be a node\n  uint256 public minAuditStake = 10000 * (10 ** 18);\n\n  // if true, the payee cannot currently withdraw their funds\n  mapping(address => bool) public lockedFunds;\n\n  // if funds are locked, they may be retrieved after this block\n  // if funds are unlocked, the number should be ignored\n  mapping(address => uint256) public unlockBlockNumber;\n\n  // staked audit nodes -- needed to inquire about audit node statistics, such as min price\n  // this list contains all nodes that have *ANY* stake, however when getNextStakedNode is called,\n  // it skips nodes that do not meet the minimum stake.\n  // the reason for this approach is that if the owner lowers the minAuditStake,\n  // we must be aware of any node with a stake.\n  LinkedListLib.LinkedList internal stakedNodesList;\n\n  event Slashed(address addr, uint256 amount);\n  event StakedNodeAdded(address addr);\n  event StakedNodeRemoved(address addr);\n\n  // the constructor of TokenEscrow requires an ERC20, not an address\n  constructor(address tokenAddress) public TokenEscrow(ERC20(tokenAddress)) {} // solhint-disable no-empty-blocks\n\n  /**\n  * @dev Puts in escrow a certain amount of tokens as credit to be withdrawn.\n  *      Overrides the function in TokenEscrow.sol to add the payee to the staked list.\n  * @param _payee The destination address of the tokens.\n  * @param _amount The amount of tokens to deposit in escrow.\n  */\n  function deposit(address _payee, uint256 _amount) public onlyWhitelisted {\n    super.deposit(_payee, _amount);\n    if (_amount > 0) {\n      // fails gracefully if the node already exists\n      addNodeToStakedList(_payee);\n    }\n  }\n\n /**\n  * @dev Withdraw accumulated tokens for a payee.\n  *      Overrides the function in TokenEscrow.sol to remove the payee from the staked list.\n  * @param _payee The address whose tokens will be withdrawn and transferred to.\n  */\n  function withdraw(address _payee) public onlyWhitelisted {\n    super.withdraw(_payee);\n    removeNodeFromStakedList(_payee);\n  }\n\n  /**\n   * @dev Sets the minimum stake to a new value.\n   * @param _value The new value. _value must be greater than zero in order for the linked list to be maintained correctly.\n   */\n  function setMinAuditStake(uint256 _value) public onlyOwner {\n    require(_value > 0);\n    minAuditStake = _value;\n  }\n\n  /**\n   * @dev Returns true if the sender staked enough.\n   * @param addr The address to check.\n   */\n  function hasEnoughStake(address addr) public view returns(bool) {\n    return depositsOf(addr) >= minAuditStake;\n  }\n\n  /**\n   * @dev Overrides ConditionalTokenEscrow function. If true, funds may be withdrawn.\n   * @param _payee The address that wants to withdraw funds.\n   */\n  function withdrawalAllowed(address _payee) public view returns (bool) {\n    return !lockedFunds[_payee] || unlockBlockNumber[_payee] < block.number;\n  }\n\n  /**\n   * @dev Prevents the payee from withdrawing funds.\n   * @param _payee The address that will be locked.\n   */\n  function lockFunds(address _payee, uint256 _unlockBlockNumber) public onlyWhitelisted returns (bool) {\n    lockedFunds[_payee] = true;\n    unlockBlockNumber[_payee] = _unlockBlockNumber;\n    return true;\n  }\n\n    /**\n   * @dev Slash a percentage of the stake of an address.\n   *      The percentage is taken from the minAuditStake, not the total stake of the address.\n   *      The caller of this function receives the slashed QSP.\n   *      If the current stake does not cover the slash amount, the full stake is taken.\n   *\n   * @param addr The address that will be slashed.\n   * @param percentage The percent of the minAuditStake that should be slashed.\n   */\n  function slash(address addr, uint256 percentage) public onlyWhitelisted returns (uint256) {\n    require(0 <= percentage && percentage <= 100);\n\n    uint256 slashAmount = getSlashAmount(percentage);\n    uint256 balance = depositsOf(addr);\n    if (balance < slashAmount) {\n      slashAmount = balance;\n    }\n\n    // subtract from the deposits amount of the addr\n    deposits[addr] = deposits[addr].sub(slashAmount);\n\n    emit Slashed(addr, slashAmount);\n\n    // if the deposits of the address are now zero, remove from the list\n    if (depositsOf(addr) == 0) {\n      removeNodeFromStakedList(addr);\n    }\n\n    // transfer the slashAmount to the police contract\n    token.safeTransfer(msg.sender, slashAmount);\n\n    return slashAmount;\n  }\n\n  /**\n   * @dev Returns the slash amount for a given percentage.\n   * @param percentage The percent of the minAuditStake that should be slashed.\n   */\n  function getSlashAmount(uint256 percentage) public view returns (uint256) {\n    return (minAuditStake.mul(percentage)).div(100);\n  }\n\n  /**\n   * @dev Given a staked address, returns the next address from the list that meets the minAuditStake.\n   * @param addr The staked address.\n   * @return The next address in the list.\n   */\n  function getNextStakedNode(address addr) public view returns(address) {\n    bool exists;\n    uint256 next;\n    (exists, next) = stakedNodesList.getAdjacent(uint256(addr), NEXT);\n    // only return addresses that meet the minAuditStake\n    while (exists && next != HEAD && !hasEnoughStake(address(next))) {\n      (exists, next) = stakedNodesList.getAdjacent(next, NEXT);\n    }\n    return address(next);\n  }\n\n  /**\n   * @dev Adds an address to the stakedNodesList.\n   * @param addr The address to be added to the list.\n   * @return true if the address was added to the list.\n   */\n  function addNodeToStakedList(address addr) internal returns(bool success) {\n    if (stakedNodesList.insert(HEAD, uint256(addr), PREV)) {\n      stakedNodesCount++;\n      emit StakedNodeAdded(addr);\n      success = true;\n    }\n  }\n\n  /**\n   * @dev Removes an address from the stakedNodesList.\n   * @param addr The address to be removed from the list.\n   * @return true if the address was removed from the list.\n   */\n  function removeNodeFromStakedList(address addr) internal returns(bool success) {\n    if (stakedNodesList.remove(uint256(addr)) != 0) {\n      stakedNodesCount--;\n      emit StakedNodeRemoved(addr);\n      success = true;\n    }\n  }\n}\n\n// File: contracts/QuantstampAuditPolice.sol\n\n// TODO (QSP-833): salary and taxing\n// TODO transfer existing salary if removing police\ncontract QuantstampAuditPolice is Whitelist {   // solhint-disable max-states-count\n\n  using SafeMath for uint256;\n  using LinkedListLib for LinkedListLib.LinkedList;\n\n  // constants used by LinkedListLib\n  uint256 constant internal NULL = 0;\n  uint256 constant internal HEAD = 0;\n  bool constant internal PREV = false;\n  bool constant internal NEXT = true;\n\n  enum PoliceReportState {\n    UNVERIFIED,\n    INVALID,\n    VALID,\n    EXPIRED\n  }\n\n  // whitelisted police nodes\n  LinkedListLib.LinkedList internal policeList;\n\n  // the total number of police nodes\n  uint256 public numPoliceNodes = 0;\n\n  // the number of police nodes assigned to each report\n  uint256 public policeNodesPerReport = 3;\n\n  // the number of blocks the police have to verify a report\n  uint256 public policeTimeoutInBlocks = 100;\n\n  // number from [0-100] that indicates the percentage of the minAuditStake that should be slashed\n  uint256 public slashPercentage = 20;\n\n    // this is only deducted once per report, regardless of the number of police nodes assigned to it\n  uint256 public reportProcessingFeePercentage = 5;\n\n  event PoliceNodeAdded(address addr);\n  event PoliceNodeRemoved(address addr);\n  // TODO: we may want these parameters indexed\n  event PoliceNodeAssignedToReport(address policeNode, uint256 requestId);\n  event PoliceSubmissionPeriodExceeded(uint256 requestId, uint256 timeoutBlock, uint256 currentBlock);\n  event PoliceSlash(uint256 requestId, address policeNode, address auditNode, uint256 amount);\n  event PoliceFeesClaimed(address policeNode, uint256 fee);\n  event PoliceFeesCollected(uint256 requestId, uint256 fee);\n  event PoliceAssignmentExpiredAndCleared(uint256 requestId);\n\n  // pointer to the police node that was last assigned to a report\n  address private lastAssignedPoliceNode = address(HEAD);\n\n  // maps each police node to the IDs of reports it should check\n  mapping(address => LinkedListLib.LinkedList) internal assignedReports;\n\n  // maps request IDs to the police nodes that are expected to check the report\n  mapping(uint256 => LinkedListLib.LinkedList) internal assignedPolice;\n\n  // maps each audit node to the IDs of reports that are pending police approval for payment\n  mapping(address => LinkedListLib.LinkedList) internal pendingPayments;\n\n  // maps request IDs to police timeouts\n  mapping(uint256 => uint256) public policeTimeouts;\n\n  // maps request IDs to reports submitted by police nodes\n  mapping(uint256 => mapping(address => bytes)) public policeReports;\n\n  // maps request IDs to the result reported by each police node\n  mapping(uint256 => mapping(address => PoliceReportState)) public policeReportResults;\n\n  // maps request IDs to whether they have been verified by the police\n  mapping(uint256 => PoliceReportState) public verifiedReports;\n\n  // maps request IDs to whether their reward has been claimed by the submitter\n  mapping(uint256 => bool) public rewardHasBeenClaimed;\n\n  // tracks the total number of reports ever assigned to a police node\n  mapping(address => uint256) public totalReportsAssigned;\n\n  // tracks the total number of reports ever checked by a police node\n  mapping(address => uint256) public totalReportsChecked;\n\n  // the collected fees for each report\n  mapping(uint256 => uint256) public collectedFees;\n\n  // contract that stores audit data (separate from the auditing logic)\n  QuantstampAuditData public auditData;\n\n  // contract that stores token escrows of nodes on the network\n  QuantstampAuditTokenEscrow public tokenEscrow;\n\n  /**\n   * @dev The constructor creates a police contract.\n   * @param auditDataAddress The address of an AuditData that stores data used for performing audits.\n   * @param escrowAddress The address of a QuantstampTokenEscrow contract that holds staked deposits of nodes.\n   */\n  constructor (address auditDataAddress, address escrowAddress) public {\n    require(auditDataAddress != address(0));\n    require(escrowAddress != address(0));\n    auditData = QuantstampAuditData(auditDataAddress);\n    tokenEscrow = QuantstampAuditTokenEscrow(escrowAddress);\n  }\n\n  /**\n   * @dev Assigns police nodes to a submitted report\n   * @param requestId The ID of the audit request.\n   */\n  function assignPoliceToReport(uint256 requestId) public onlyWhitelisted {\n    // ensure that the requestId has not already been assigned to police already\n    require(policeTimeouts[requestId] == 0);\n    // set the timeout for police reports\n    policeTimeouts[requestId] = block.number + policeTimeoutInBlocks;\n    // if there are not enough police nodes, this avoids assigning the same node twice\n    uint256 numToAssign = policeNodesPerReport;\n    if (numPoliceNodes < numToAssign) {\n      numToAssign = numPoliceNodes;\n    }\n    while (numToAssign > 0) {\n      lastAssignedPoliceNode = getNextPoliceNode(lastAssignedPoliceNode);\n      if (lastAssignedPoliceNode != address(0)) {\n        // push the request ID to the tail of the assignment list for the police node\n        assignedReports[lastAssignedPoliceNode].push(requestId, PREV);\n        // push the police node to the list of nodes assigned to check the report\n        assignedPolice[requestId].push(uint256(lastAssignedPoliceNode), PREV);\n        emit PoliceNodeAssignedToReport(lastAssignedPoliceNode, requestId);\n        totalReportsAssigned[lastAssignedPoliceNode] = totalReportsAssigned[lastAssignedPoliceNode].add(1);\n        numToAssign = numToAssign.sub(1);\n      }\n    }\n  }\n\n  /**\n   * Cleans the list of assignments to police node (msg.sender), but checks only up to a limit\n   * of assignments. If the limit is 0, attempts to clean the entire list.\n   * @param policeNode The node whose assignments should be cleared.\n   * @param limit The number of assigments to check.\n   */\n  function clearExpiredAssignments (address policeNode, uint256 limit) public {\n    removeExpiredAssignments(policeNode, 0, limit);\n  }\n\n  /**\n   * @dev Collects the police fee for checking a report.\n   *      NOTE: this function assumes that the fee will be transferred by the calling contract.\n   * @param requestId The ID of the audit request.\n   * @return The amount collected.\n   */\n  function collectFee(uint256 requestId) public onlyWhitelisted returns (uint256) {\n    uint256 policeFee = getPoliceFee(auditData.getAuditPrice(requestId));\n    // the collected fee needs to be stored in a map since the owner could change the fee percentage\n    collectedFees[requestId] = policeFee;\n    emit PoliceFeesCollected(requestId, policeFee);\n    return policeFee;\n  }\n\n  /**\n   * @dev Split a payment, which may be for report checking or from slashing, amongst all police nodes\n   * @param amount The amount to be split, which should have been transferred to this contract earlier.\n   */\n  function splitPayment(uint256 amount) public onlyWhitelisted {\n    require(numPoliceNodes != 0);\n    address policeNode = getNextPoliceNode(address(HEAD));\n    uint256 amountPerNode = amount.div(numPoliceNodes);\n    // TODO: upgrade our openzeppelin version to use mod\n    uint256 largerAmount = amountPerNode.add(amount % numPoliceNodes);\n    bool largerAmountClaimed = false;\n    while (policeNode != address(HEAD)) {\n      // give the largerAmount to the current lastAssignedPoliceNode if it is not equal to HEAD\n      // this approach is only truly fair if numPoliceNodes and policeNodesPerReport are relatively prime\n      // but the remainder should be extremely small in any case\n      // the last conditional handles the edge case where all police nodes were removed and then re-added\n      if (!largerAmountClaimed && (policeNode == lastAssignedPoliceNode || lastAssignedPoliceNode == address(HEAD))) {\n        require(auditData.token().transfer(policeNode, largerAmount));\n        emit PoliceFeesClaimed(policeNode, largerAmount);\n        largerAmountClaimed = true;\n      } else {\n        require(auditData.token().transfer(policeNode, amountPerNode));\n        emit PoliceFeesClaimed(policeNode, amountPerNode);\n      }\n      policeNode = getNextPoliceNode(address(policeNode));\n    }\n  }\n\n  /**\n   * @dev Associates a pending payment with an auditor that can be claimed after the policing period.\n   * @param auditor The audit node that submitted the report.\n   * @param requestId The ID of the audit request.\n   */\n  function addPendingPayment(address auditor, uint256 requestId) public onlyWhitelisted {\n    pendingPayments[auditor].push(requestId, PREV);\n  }\n\n  /**\n   * @dev Submits verification of a report by a police node.\n   * @param policeNode The address of the police node.\n   * @param auditNode The address of the audit node.\n   * @param requestId The ID of the audit request.\n   * @param report The compressed bytecode representation of the report.\n   * @param isVerified Whether the police node's report matches the submitted report.\n   *                   If not, the audit node is slashed.\n   * @return two bools and a uint256: (true if the report was successfully submitted, true if a slash occurred, the slash amount).\n   */\n  function submitPoliceReport(\n    address policeNode,\n    address auditNode,\n    uint256 requestId,\n    bytes report,\n    bool isVerified) public onlyWhitelisted returns (bool, bool, uint256) {\n    // remove expired assignments\n    bool hasRemovedCurrentId = removeExpiredAssignments(policeNode, requestId, 0);\n    // if the current request has timed out, return\n    if (hasRemovedCurrentId) {\n      emit PoliceSubmissionPeriodExceeded(requestId, policeTimeouts[requestId], block.number);\n      return (false, false, 0);\n    }\n    // the police node is assigned to the report\n    require(isAssigned(requestId, policeNode));\n\n    // remove the report from the assignments to the node\n    assignedReports[policeNode].remove(requestId);\n    // increment the number of reports checked by the police node\n    totalReportsChecked[policeNode] = totalReportsChecked[policeNode] + 1;\n    // store the report\n    policeReports[requestId][policeNode] = report;\n    // emit an event\n    PoliceReportState state;\n    if (isVerified) {\n      state = PoliceReportState.VALID;\n    } else {\n      state = PoliceReportState.INVALID;\n    }\n    policeReportResults[requestId][policeNode] = state;\n\n    // the report was already marked invalid by a different police node\n    if (verifiedReports[requestId] == PoliceReportState.INVALID) {\n      return (true, false, 0);\n    } else {\n      verifiedReports[requestId] = state;\n    }\n    bool slashOccurred;\n    uint256 slashAmount;\n    if (!isVerified) {\n      pendingPayments[auditNode].remove(requestId);\n      // an audit node can only be slashed once for each report,\n      // even if multiple police mark the report as invalid\n      slashAmount = tokenEscrow.slash(auditNode, slashPercentage);\n      slashOccurred = true;\n      emit PoliceSlash(requestId, policeNode, auditNode, slashAmount);\n    }\n    return (true, slashOccurred, slashAmount);\n  }\n\n  /**\n   * @dev Determines whether an audit node is allowed by the police to claim an audit.\n   * @param auditNode The address of the audit node.\n   * @param requestId The ID of the requested audit.\n   */\n  function canClaimAuditReward (address auditNode, uint256 requestId) public view returns (bool) {\n    // NOTE: can't use requires here, as claimNextReward needs to iterate the full list\n    return\n      // the report is in the pending payments list for the audit node\n      pendingPayments[auditNode].nodeExists(requestId) &&\n      // the policing period has ended for the report\n      policeTimeouts[requestId] < block.number &&\n      // the police did not invalidate the report\n      verifiedReports[requestId] != PoliceReportState.INVALID &&\n      // the reward has not already been claimed\n      !rewardHasBeenClaimed[requestId] &&\n      // the requestId is non-zero\n      requestId > 0;\n  }\n\n  /**\n   * @dev Given a requestId, returns the next pending available reward for the audit node.\n   * @param auditNode The address of the audit node.\n   * @param requestId The ID of the current linked list node\n   * @return true if the next reward exists, and the corresponding requestId in the linked list\n   */\n  function getNextAvailableReward (address auditNode, uint256 requestId) public view returns (bool, uint256) {\n    bool exists;\n    (exists, requestId) = pendingPayments[auditNode].getAdjacent(requestId, NEXT);\n    // NOTE: Do NOT short circuit this list based on timeouts.\n    // The ordering may be broken if the owner changes the timeouts.\n    while (exists && requestId != HEAD) {\n      if (canClaimAuditReward(auditNode, requestId)) {\n        return (true, requestId);\n      }\n      (exists, requestId) = pendingPayments[auditNode].getAdjacent(requestId, NEXT);\n    }\n    return (false, 0);\n  }\n\n  /**\n   * @dev Sets the reward as claimed after checking that it can be claimed.\n   *      This function also ensures double payment does not occur.\n   * @param auditNode The address of the audit node.\n   * @param requestId The ID of the requested audit.\n   */\n  function setRewardClaimed (address auditNode, uint256 requestId) public onlyWhitelisted returns (bool) {\n    // set the reward to claimed, to avoid double payment\n    rewardHasBeenClaimed[requestId] = true;\n    pendingPayments[auditNode].remove(requestId);\n    // if it is possible to claim yet the state is UNVERIFIED, mark EXPIRED\n    if (verifiedReports[requestId] == PoliceReportState.UNVERIFIED) {\n      verifiedReports[requestId] = PoliceReportState.EXPIRED;\n    }\n    return true;\n  }\n\n  /**\n   * @dev Selects the next ID to be rewarded.\n   * @param auditNode The address of the audit node.\n   * @param requestId The previous claimed requestId (initially set to HEAD).\n   * @return True if another reward exists, and the request ID.\n   */\n  function claimNextReward (address auditNode, uint256 requestId) public onlyWhitelisted returns (bool, uint256) {\n    bool exists;\n    (exists, requestId) = pendingPayments[auditNode].getAdjacent(requestId, NEXT);\n    // NOTE: Do NOT short circuit this list based on timeouts.\n    // The ordering may be broken if the owner changes the timeouts.\n    while (exists && requestId != HEAD) {\n      if (canClaimAuditReward(auditNode, requestId)) {\n        setRewardClaimed(auditNode, requestId);\n        return (true, requestId);\n      }\n      (exists, requestId) = pendingPayments[auditNode].getAdjacent(requestId, NEXT);\n    }\n    return (false, 0);\n  }\n\n  /**\n   * @dev Gets the next assigned report to the police node.\n   * @param policeNode The address of the police node.\n   * @return true if the list is non-empty, requestId, auditPrice, uri, and policeAssignmentBlockNumber.\n   */\n  function getNextPoliceAssignment(address policeNode) public view returns (bool, uint256, uint256, string, uint256) {\n    bool exists;\n    uint256 requestId;\n    (exists, requestId) = assignedReports[policeNode].getAdjacent(HEAD, NEXT);\n    // if the head of the list is an expired assignment, try to find a current one\n    while (exists && requestId != HEAD) {\n      if (policeTimeouts[requestId] < block.number) {\n        (exists, requestId) = assignedReports[policeNode].getAdjacent(requestId, NEXT);\n      } else {\n        uint256 price = auditData.getAuditPrice(requestId);\n        string memory uri = auditData.getAuditContractUri(requestId);\n        uint256 policeAssignmentBlockNumber = auditData.getAuditReportBlockNumber(requestId);\n        return (exists, requestId, price, uri, policeAssignmentBlockNumber);\n      }\n    }\n    return (false, 0, 0, \"\", 0);\n  }\n\n  /**\n   * @dev Gets the next assigned police node to an audit request.\n   * @param requestId The ID of the audit request.\n   * @param policeNode The previous claimed requestId (initially set to HEAD).\n   * @return true if the next police node exists, and the address of the police node.\n   */\n  function getNextAssignedPolice(uint256 requestId, address policeNode) public view returns (bool, address) {\n    bool exists;\n    uint256 nextPoliceNode;\n    (exists, nextPoliceNode) = assignedPolice[requestId].getAdjacent(uint256(policeNode), NEXT);\n    if (nextPoliceNode == HEAD) {\n      return (false, address(0));\n    }\n    return (exists, address(nextPoliceNode));\n  }\n\n  /**\n   * @dev Sets the number of police nodes that should check each report.\n   * @param numPolice The number of police.\n   */\n  function setPoliceNodesPerReport(uint256 numPolice) public onlyOwner {\n    policeNodesPerReport = numPolice;\n  }\n\n  /**\n   * @dev Sets the police timeout.\n   * @param numBlocks The number of blocks for the timeout.\n   */\n  function setPoliceTimeoutInBlocks(uint256 numBlocks) public onlyOwner {\n    policeTimeoutInBlocks = numBlocks;\n  }\n\n  /**\n   * @dev Sets the slash percentage.\n   * @param percentage The percentage as an integer from [0-100].\n   */\n  function setSlashPercentage(uint256 percentage) public onlyOwner {\n    require(0 <= percentage && percentage <= 100);\n    slashPercentage = percentage;\n  }\n\n  /**\n   * @dev Sets the report processing fee percentage.\n   * @param percentage The percentage in the range of [0-100].\n   */\n  function setReportProcessingFeePercentage(uint256 percentage) public onlyOwner {\n    require(percentage <= 100);\n    reportProcessingFeePercentage = percentage;\n  }\n\n  /**\n   * @dev Returns true if a node is whitelisted.\n   * @param node The node to check.\n   */\n  function isPoliceNode(address node) public view returns (bool) {\n    return policeList.nodeExists(uint256(node));\n  }\n\n  /**\n   * @dev Adds an address to the police.\n   * @param addr The address to be added.\n   * @return true if the address was added to the whitelist.\n   */\n  function addPoliceNode(address addr) public onlyOwner returns (bool success) {\n    if (policeList.insert(HEAD, uint256(addr), PREV)) {\n      numPoliceNodes = numPoliceNodes.add(1);\n      emit PoliceNodeAdded(addr);\n      success = true;\n    }\n  }\n\n  /**\n   * @dev Removes an address from the whitelist linked-list.\n   * @param addr The address to be removed.\n   * @return true if the address was removed from the whitelist.\n   */\n  function removePoliceNode(address addr) public onlyOwner returns (bool success) {\n    // if lastAssignedPoliceNode is addr, need to move the pointer\n    bool exists;\n    uint256 next;\n    if (lastAssignedPoliceNode == addr) {\n      (exists, next) = policeList.getAdjacent(uint256(addr), NEXT);\n      lastAssignedPoliceNode = address(next);\n    }\n\n    if (policeList.remove(uint256(addr)) != NULL) {\n      numPoliceNodes = numPoliceNodes.sub(1);\n      emit PoliceNodeRemoved(addr);\n      success = true;\n    }\n  }\n\n  /**\n   * @dev Given a whitelisted address, returns the next address from the whitelist.\n   * @param addr The address in the whitelist.\n   * @return The next address in the whitelist.\n   */\n  function getNextPoliceNode(address addr) public view returns (address) {\n    bool exists;\n    uint256 next;\n    (exists, next) = policeList.getAdjacent(uint256(addr), NEXT);\n    return address(next);\n  }\n\n  /**\n   * @dev Returns the resulting state of a police report for a given audit request.\n   * @param requestId The ID of the audit request.\n   * @param policeAddr The address of the police node.\n   * @return the PoliceReportState of the (requestId, policeNode) pair.\n   */\n  function getPoliceReportResult(uint256 requestId, address policeAddr) public view returns (PoliceReportState) {\n    return policeReportResults[requestId][policeAddr];\n  }\n\n  function getPoliceReport(uint256 requestId, address policeAddr) public view returns (bytes) {\n    return policeReports[requestId][policeAddr];\n  }\n\n  function getPoliceFee(uint256 auditPrice) public view returns (uint256) {\n    return auditPrice.mul(reportProcessingFeePercentage).div(100);\n  }\n\n  function isAssigned(uint256 requestId, address policeAddr) public view returns (bool) {\n    return assignedReports[policeAddr].nodeExists(requestId);\n  }\n\n  /**\n   * Cleans the list of assignments to a given police node.\n   * @param policeNode The address of the police node.\n   * @param requestId The ID of the audit request.\n   * @param limit The number of assigments to check. Use 0 if the entire list should be checked.\n   * @return true if the current request ID gets removed during cleanup.\n   */\n  function removeExpiredAssignments (address policeNode, uint256 requestId, uint256 limit) internal returns (bool) {\n    bool hasRemovedCurrentId = false;\n    bool exists;\n    uint256 potentialExpiredRequestId;\n    uint256 nextExpiredRequestId;\n    uint256 iterationsLeft = limit;\n    (exists, nextExpiredRequestId) = assignedReports[policeNode].getAdjacent(HEAD, NEXT);\n    // NOTE: Short circuiting this list may cause expired assignments to exist later in the list.\n    //       The may occur if the owner changes the global police timeout.\n    //       These expired assignments will be removed in subsequent calls.\n    while (exists && nextExpiredRequestId != HEAD && (limit == 0 || iterationsLeft > 0)) {\n      potentialExpiredRequestId = nextExpiredRequestId;\n      (exists, nextExpiredRequestId) = assignedReports[policeNode].getAdjacent(nextExpiredRequestId, NEXT);\n      if (policeTimeouts[potentialExpiredRequestId] < block.number) {\n        assignedReports[policeNode].remove(potentialExpiredRequestId);\n        emit PoliceAssignmentExpiredAndCleared(potentialExpiredRequestId);\n        if (potentialExpiredRequestId == requestId) {\n          hasRemovedCurrentId = true;\n        }\n      } else {\n        break;\n      }\n      iterationsLeft -= 1;\n    }\n    return hasRemovedCurrentId;\n  }\n}",
  "bytecode": "60806040526000600390815560045560646005908155601460065560075560088054600160a060020a031916905534801561003957600080fd5b5060405160408061332b83398101604052805160209091015160008054600160a060020a03191633179055600160a060020a038216151561007957600080fd5b600160a060020a038116151561008e57600080fd5b60148054600160a060020a03938416600160a060020a03199182161790915560158054929093169116179055613262806100c96000396000f3006080604052600436106102425763ffffffff60e060020a60003504166305357c69811461024757806308567a871461027f5780630988ca8c146102a05780630deaf3f8146103095780630ea3634514610348578063160abdd51461036f5780631741c48e1461039057806318b919e9146103cd5780631ed27a1414610457578063217fe6c61461046f57806324953eaa146104d657806327411dfd1461052b578063286dd3f5146105435780632db1469d14610564578063309945ba14610588578063393ebbf8146105a05780633c1c5e04146105b85780634394aaad146106005780634a1b13f0146106245780634f5b7fba1461063c5780636072ec6414610654578063641446eb146106695780636afef23f14610681578063715018a6146107145780637b9417c8146107295780637e06ee131461074a5780637e319e4a1461075f5780638826db7a146107a65780638b7358a01461085f5780638da5cb5b14610883578063928c97eb1461089857806394558862146108ad5780639766b69f146108d15780639b19251a146108e95780639c40478c1461090a5780639cecba341461092e578063a2be19fb1461094f578063a969ff0a14610967578063aac41ed61461097f578063ae56463e14610994578063af26ed68146109b8578063b3a3dda3146109d0578063b8a26260146109f4578063b977978714610a0c578063ba5bea0914610a2d578063bd58199a14610a51578063de66eaec14610a66578063e2ec6ec314610a7b578063e4ca784b14610ad0578063f2fde38b14610af1575b600080fd5b34801561025357600080fd5b5061026b600435600160a060020a0360243516610b12565b604080519115158252519081900360200190f35b34801561028b57600080fd5b5061026b600160a060020a0360043516610bcf565b3480156102ac57600080fd5b5060408051602060046024803582810135601f8101859004850286018501909652858552610307958335600160a060020a0316953695604494919390910191908190840183828082843750949750610d499650505050505050565b005b34801561031557600080fd5b5061032d600160a060020a0360043516602435610db7565b60408051921515835260208301919091528051918290030190f35b34801561035457600080fd5b5061035d610f94565b60408051918252519081900360200190f35b34801561037b57600080fd5b5061035d600160a060020a0360043516610f9a565b34801561039c57600080fd5b506103b1600160a060020a0360043516610fac565b60408051600160a060020a039092168252519081900360200190f35b3480156103d957600080fd5b506103e2611051565b6040805160208082528351818301528351919283929083019185019080838360005b8381101561041c578181015183820152602001610404565b50505050905090810190601f1680156104495780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b34801561046357600080fd5b50610307600435611076565b34801561047b57600080fd5b5060408051602060046024803582810135601f810185900485028601850190965285855261026b958335600160a060020a03169536956044949193909101919081908401838280828437509497506110929650505050505050565b3480156104e257600080fd5b5060408051602060048035808201358381028086018501909652808552610307953695939460249493850192918291850190849080828437509497506111059650505050505050565b34801561053757600080fd5b5061035d600435611152565b34801561054f57600080fd5b50610307600160a060020a0360043516611182565b34801561057057600080fd5b506103e2600435600160a060020a0360243516611205565b34801561059457600080fd5b5061035d6004356112a9565b3480156105ac57600080fd5b506103076004356112bb565b3480156105c457600080fd5b506105dc600435600160a060020a03602435166112f4565b604051808260038111156105ec57fe5b60ff16815260200191505060405180910390f35b34801561060c57600080fd5b5061032d600160a060020a0360043516602435611314565b34801561063057600080fd5b506103076004356114a9565b34801561064857600080fd5b5061026b6004356114c5565b34801561066057600080fd5b506103b16114da565b34801561067557600080fd5b506103076004356114e9565b34801561068d57600080fd5b50604080516020601f6064356004818101359283018490048402850184019095528184526106f494600160a060020a0381358116956024803590921695604435953695608494019181908401838280828437509497505050509135151592506118a1915050565b604080519315158452911515602084015282820152519081900360600190f35b34801561072057600080fd5b50610307611c07565b34801561073557600080fd5b50610307600160a060020a0360043516611c73565b34801561075657600080fd5b5061035d611cf6565b34801561076b57600080fd5b50610783600435600160a060020a0360243516611cfc565b604080519215158352600160a060020a0390911660208301528051918290030190f35b3480156107b257600080fd5b506107c7600160a060020a0360043516611dd2565b604051808615151515815260200185815260200184815260200180602001838152602001828103825284818151815260200191508051906020019080838360005b83811015610820578181015183820152602001610808565b50505050905090810190601f16801561084d5780820380516001836020036101000a031916815260200191505b50965050505050505060405180910390f35b34801561086b57600080fd5b506105dc600435600160a060020a03602435166121d3565b34801561088f57600080fd5b506103b16121fe565b3480156108a457600080fd5b5061035d61220d565b3480156108b957600080fd5b5061026b600160a060020a0360043516602435612213565b3480156108dd57600080fd5b5061035d6004356122c8565b3480156108f557600080fd5b5061026b600160a060020a03600435166122da565b34801561091657600080fd5b5061026b600160a060020a0360043516602435612309565b34801561093a57600080fd5b5061026b600160a060020a036004351661242a565b34801561095b57600080fd5b506103076004356124bf565b34801561097357600080fd5b5061035d600435612680565b34801561098b57600080fd5b506103b161279f565b3480156109a057600080fd5b506103e2600435600160a060020a03602435166127ae565b3480156109c457600080fd5b50610307600435612861565b3480156109dc57600080fd5b50610307600160a060020a036004351660243561288b565b348015610a0057600080fd5b506105dc60043561289c565b348015610a1857600080fd5b5061035d600160a060020a03600435166128b1565b348015610a3957600080fd5b50610307600160a060020a03600435166024356128c3565b348015610a5d57600080fd5b5061035d612919565b348015610a7257600080fd5b5061035d61291f565b348015610a8757600080fd5b5060408051602060048035808201358381028086018501909652808552610307953695939460249493850192918291850190849080828437509497506129259650505050505050565b348015610adc57600080fd5b5061026b600160a060020a0360043516612972565b348015610afd57600080fd5b50610307600160a060020a0360043516612a22565b600160a060020a038116600090815260096020908152604080832081517ff593633c000000000000000000000000000000000000000000000000000000008152600481019190915260248101869052905173697e2033ba28c1cc9e28d94ca910ca53a978aad09263f593633c9260448082019391829003018186803b158015610b9a57600080fd5b505af4158015610bae573d6000803e3d6000fd5b505050506040513d6020811015610bc457600080fd5b505190505b92915050565b6000805481908190600160a060020a03163314610beb57600080fd5b600854600160a060020a0385811691161415610cc9576040805160e260020a6315d011eb02815260026004820152600160a060020a038616602482015260016044820152815173697e2033ba28c1cc9e28d94ca910ca53a978aad09263574047ac9260648082019391829003018186803b158015610c6857600080fd5b505af4158015610c7c573d6000803e3d6000fd5b505050506040513d6040811015610c9257600080fd5b5080516020909101516008805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a03831617905590925090505b6000610ce56002600160a060020a03871663ffffffff612a4516565b14610d4257600354610cfe90600163ffffffff612ac316565b60035560408051600160a060020a038616815290517f1cc782f073c215c86d2a35c1a03f21815db8cf407cf37bb2286528a89db2a39f9181900360200190a1600192505b5050919050565b610db3826001836040518082805190602001908083835b60208310610d7f5780518252601f199092019160209182019101610d60565b51815160209384036101000a6000190180199092169116179052920194855250604051938490030190922092915050612ad5565b5050565b6000806000610de933604080519081016040528060098152602001600080516020613217833981519152815250610d49565b600160a060020a0385166000908152600b602052604090819020815160e260020a6315d011eb02815260048101919091526024810186905260016044820152815173697e2033ba28c1cc9e28d94ca910ca53a978aad09263574047ac9260648082019391829003018186803b158015610e6157600080fd5b505af4158015610e75573d6000803e3d6000fd5b505050506040513d6040811015610e8b57600080fd5b508051602090910151945090505b808015610ea557508315155b15610f8457610eb48585612309565b15610ed057610ec38585612213565b5060018492509250610f8c565b600160a060020a0385166000908152600b602052604090819020815160e260020a6315d011eb02815260048101919091526024810186905260016044820152815173697e2033ba28c1cc9e28d94ca910ca53a978aad09263574047ac9260648082019391829003018186803b158015610f4857600080fd5b505af4158015610f5c573d6000803e3d6000fd5b505050506040513d6040811015610f7257600080fd5b50805160209091015194509050610e99565b600092508291505b509250929050565b60075481565b60116020526000908152604090205481565b6040805160e260020a6315d011eb02815260026004820152600160a060020a03831660248201526001604482015281516000928392839273697e2033ba28c1cc9e28d94ca910ca53a978aad09263574047ac9260648082019391829003018186803b15801561101a57600080fd5b505af415801561102e573d6000803e3d6000fd5b505050506040513d604081101561104457600080fd5b5060200151949350505050565b6040805180820190915260098152600080516020613217833981519152602082015281565b600054600160a060020a0316331461108d57600080fd5b600455565b60006110fe836001846040518082805190602001908083835b602083106110ca5780518252601f1990920191602091820191016110ab565b51815160209384036101000a6000190180199092169116179052920194855250604051938490030190922092915050612aea565b9392505050565b60008054600160a060020a0316331461111d57600080fd5b5060005b8151811015610db35761114a828281518110151561113b57fe5b90602001906020020151611182565b600101611121565b600061117a606461116e60075485612b0990919063ffffffff16565b9063ffffffff612b3216565b90505b919050565b600054600160a060020a0316331461119957600080fd5b6111c681604080519081016040528060098152602001600080516020613217833981519152815250612b47565b60408051600160a060020a038316815290517ff1abf01a1043b7c244d128e8595cf0c1d10743b022b03a02dffd8ca3bf729f5a9181900360200190a150565b600d6020908152600092835260408084208252918352918190208054825160026001831615610100026000190190921691909104601f8101859004850282018501909352828152929091908301828280156112a15780601f10611276576101008083540402835291602001916112a1565b820191906000526020600020905b81548152906001019060200180831161128457829003601f168201915b505050505081565b60136020526000908152604090205481565b600054600160a060020a031633146112d257600080fd5b806000111580156112e4575060648111155b15156112ef57600080fd5b600655565b600e60209081526000928352604080842090915290825290205460ff1681565b600160a060020a0382166000908152600b6020526040808220815160e260020a6315d011eb0281526004810191909152602481018490526001604482015281518392839273697e2033ba28c1cc9e28d94ca910ca53a978aad09263574047ac92606480840193919291829003018186803b15801561139157600080fd5b505af41580156113a5573d6000803e3d6000fd5b505050506040513d60408110156113bb57600080fd5b508051602090910151945090505b8080156113d557508315155b15610f84576113e48585612309565b156113f55760018492509250610f8c565b600160a060020a0385166000908152600b602052604090819020815160e260020a6315d011eb02815260048101919091526024810186905260016044820152815173697e2033ba28c1cc9e28d94ca910ca53a978aad09263574047ac9260648082019391829003018186803b15801561146d57600080fd5b505af4158015611481573d6000803e3d6000fd5b505050506040513d604081101561149757600080fd5b508051602090910151945090506113c9565b600054600160a060020a031633146114c057600080fd5b600555565b60106020526000908152604090205460ff1681565b601454600160a060020a031681565b60008060008061151c33604080519081016040528060098152602001600080516020613217833981519152815250610d49565b600354151561152a57600080fd5b6115346000610fac565b935061154b60035486612b3290919063ffffffff16565b925061156c6003548681151561155d57fe5b8591900663ffffffff612c6816565b9150600090505b600160a060020a0384161561189a57801580156115b05750600854600160a060020a03858116911614806115b05750600854600160a060020a0316155b1561172357601460009054906101000a9004600160a060020a0316600160a060020a031663fc0c546a6040518163ffffffff1660e060020a028152600401602060405180830381600087803b15801561160857600080fd5b505af115801561161c573d6000803e3d6000fd5b505050506040513d602081101561163257600080fd5b5051604080517fa9059cbb000000000000000000000000000000000000000000000000000000008152600160a060020a038781166004830152602482018690529151919092169163a9059cbb9160448083019260209291908290030181600087803b1580156116a057600080fd5b505af11580156116b4573d6000803e3d6000fd5b505050506040513d60208110156116ca57600080fd5b505115156116d757600080fd5b60408051600160a060020a03861681526020810184905281517f220bf7c27f24aa2072c97a9f3679522e25063e4e5420851d1dd2ae2d7eedaf96929181900390910190a150600161188a565b601460009054906101000a9004600160a060020a0316600160a060020a031663fc0c546a6040518163ffffffff1660e060020a028152600401602060405180830381600087803b15801561177657600080fd5b505af115801561178a573d6000803e3d6000fd5b505050506040513d60208110156117a057600080fd5b5051604080517fa9059cbb000000000000000000000000000000000000000000000000000000008152600160a060020a038781166004830152602482018790529151919092169163a9059cbb9160448083019260209291908290030181600087803b15801561180e57600080fd5b505af1158015611822573d6000803e3d6000fd5b505050506040513d602081101561183857600080fd5b5051151561184557600080fd5b60408051600160a060020a03861681526020810185905281517f220bf7c27f24aa2072c97a9f3679522e25063e4e5420851d1dd2ae2d7eedaf96929181900390910190a15b61189384610fac565b9350611573565b5050505050565b60008060008060008060006118d933604080519081016040528060098152602001600080516020613217833981519152815250610d49565b6118e58c8b6000612c75565b935083156119495760008a8152600c60209081526040918290205482518d815291820152438183015290517f764073f9ee9dbd62b4e15bcf81b9fd0e112226675be79ee964de258124da8a709181900360600190a160009650869550859450611bf8565b6119538a8d610b12565b151561195e57600080fd5b600160a060020a038c166000908152600960205260409020611986908b63ffffffff612a4516565b50600160a060020a038c166000818152601260209081526040808320805460010190558d8352600d82528083209383529281529190208a516119ca928c019061317b565b5087156119da57600292506119df565b600192505b82600e60008c815260200190815260200160002060008e600160a060020a0316600160a060020a0316815260200190815260200160002060006101000a81548160ff02191690836003811115611a3157fe5b0217905550600160008b8152600f602052604090205460ff166003811115611a5557fe5b1415611a6b576001965060009550859450611bf8565b60008a8152600f60205260409020805484919060ff19166001836003811115611a9057fe5b0217905550871515611bed57600160a060020a038b166000908152600b60205260409020611ac4908b63ffffffff612a4516565b50601554600654604080517f02fb4d85000000000000000000000000000000000000000000000000000000008152600160a060020a038f811660048301526024820193909352905191909216916302fb4d859160448083019260209291908290030181600087803b158015611b3857600080fd5b505af1158015611b4c573d6000803e3d6000fd5b505050506040513d6020811015611b6257600080fd5b81019080805190602001909291905050509050600191507fbb3db90091e7d94a3031b1e74ca2c6eef93076c8b10469ae849657f482abf4ca8a8d8d846040518085815260200184600160a060020a0316600160a060020a0316815260200183600160a060020a0316600160a060020a0316815260200182815260200194505050505060405180910390a15b600182829650965096505b50505050955095509592505050565b600054600160a060020a03163314611c1e57600080fd5b60008054604051600160a060020a03909116917ff8df31144d9c2f0f6b59d69b8b98abd5459d07f2742c4df920b25aae33c6482091a26000805473ffffffffffffffffffffffffffffffffffffffff19169055565b600054600160a060020a03163314611c8a57600080fd5b611cb781604080519081016040528060098152602001600080516020613217833981519152815250612eac565b60408051600160a060020a038316815290517fd1bba68c128cc3f427e5831b3c6f99f480b6efa6b9e80c757768f6124158cc3f9181900360200190a150565b60055481565b6000828152600a6020526040808220815160e260020a6315d011eb0281526004810191909152600160a060020a038416602482015260016044820152815183928392839273697e2033ba28c1cc9e28d94ca910ca53a978aad09263574047ac9260648082019391829003018186803b158015611d7757600080fd5b505af4158015611d8b573d6000803e3d6000fd5b505050506040513d6040811015611da157600080fd5b5080516020909101519092509050801515611dc25760008093509350611dc9565b8181935093505b50509250929050565b600160a060020a038116600090815260096020526040808220815160e260020a6315d011eb0281526004810191909152602481018390526001604482015281518392839260609284928392839283928792849273697e2033ba28c1cc9e28d94ca910ca53a978aad09263574047ac9260648082019391829003018186803b158015611e5c57600080fd5b505af4158015611e70573d6000803e3d6000fd5b505050506040513d6040811015611e8657600080fd5b50805160209091015190955093505b848015611ea157508315155b156121a7576000848152600c6020526040902054431115611f7157600160a060020a038b1660009081526009602052604090819020815160e260020a6315d011eb02815260048101919091526024810186905260016044820152815173697e2033ba28c1cc9e28d94ca910ca53a978aad09263574047ac9260648082019391829003018186803b158015611f3457600080fd5b505af4158015611f48573d6000803e3d6000fd5b505050506040513d6040811015611f5e57600080fd5b50805160209091015190955093506121a2565b601454604080517fc15185f5000000000000000000000000000000000000000000000000000000008152600481018790529051600160a060020a039092169163c15185f5916024808201926020929091908290030181600087803b158015611fd857600080fd5b505af1158015611fec573d6000803e3d6000fd5b505050506040513d602081101561200257600080fd5b5051601454604080517f843e240e000000000000000000000000000000000000000000000000000000008152600481018890529051929550600160a060020a039091169163843e240e9160248082019260009290919082900301818387803b15801561206d57600080fd5b505af1158015612081573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405260208110156120aa57600080fd5b8101908080516401000000008111156120c257600080fd5b820160208101848111156120d557600080fd5b81516401000000008111828201871017156120ef57600080fd5b5050601454604080517f7a805504000000000000000000000000000000000000000000000000000000008152600481018b90529051929750600160a060020a039091169450637a805504935060248082019350602092918290030181600087803b15801561215c57600080fd5b505af1158015612170573d6000803e3d6000fd5b505050506040513d602081101561218657600080fd5b50519499509297509095509350909150859050848484846121c5565b611e95565b604080516020810190915260008082529a508a995089985096508795505b505050505091939590929450565b6000918252600e60209081526040808420600160a060020a0393909316845291905290205460ff1690565b600054600160a060020a031681565b60035481565b600061224233604080519081016040528060098152602001600080516020613217833981519152815250610d49565b6000828152601060209081526040808320805460ff19166001179055600160a060020a0386168352600b9091529020612281908363ffffffff612a4516565b506000828152600f602052604081205460ff16600381111561229f57fe5b14156122bf576000828152600f60205260409020805460ff191660031790555b50600192915050565b600c6020526000908152604090205481565b600061117a82604080519081016040528060098152602001600080516020613217833981519152815250611092565b600160a060020a0382166000908152600b6020908152604080832081517ff593633c000000000000000000000000000000000000000000000000000000008152600481019190915260248101859052905173697e2033ba28c1cc9e28d94ca910ca53a978aad09263f593633c9260448082019391829003018186803b15801561239157600080fd5b505af41580156123a5573d6000803e3d6000fd5b505050506040513d60208110156123bb57600080fd5b505180156123d657506000828152600c602052604090205443115b80156123ff575060016000838152600f602052604090205460ff1660038111156123fc57fe5b14155b801561241a575060008281526010602052604090205460ff16155b80156110fe575050600010919050565b60008054600160a060020a0316331461244257600080fd5b61245f60026000600160a060020a0385168163ffffffff612f8d16565b1561117d5760035461247890600163ffffffff612c6816565b60035560408051600160a060020a038416815290517f28b1be6c28ecc224735ddd86f7778c8648895718b28d90e565a56ad5952314049181900360200190a1506001919050565b60006124ee33604080519081016040528060098152602001600080516020613217833981519152815250610d49565b6000828152600c60205260409020541561250757600080fd5b506005546000828152600c6020526040902043909101905560045460035481111561253157506003545b6000811115610db35760085461254f90600160a060020a0316610fac565b6008805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a039283161790819055161561267b57600854600160a060020a031660009081526009602052604081206125ab91849063ffffffff612ffb16565b6008546000838152600a602052604081206125d9929091600160a060020a039091169063ffffffff612ffb16565b60085460408051600160a060020a0390921682526020820184905280517f41000dc4a0fb757999a82d88448d2e01e89419ffd8f21c0599d5a60247ae7cde9281900390910190a1600854600160a060020a031660009081526011602052604090205461264c90600163ffffffff612c6816565b600854600160a060020a031660009081526011602052604090205561267881600163ffffffff612ac316565b90505b612531565b6000806126b033604080519081016040528060098152602001600080516020613217833981519152815250610d49565b601454604080517fc15185f500000000000000000000000000000000000000000000000000000000815260048101869052905161274992600160a060020a03169163c15185f59160248083019260209291908290030181600087803b15801561271857600080fd5b505af115801561272c573d6000803e3d6000fd5b505050506040513d602081101561274257600080fd5b5051611152565b600084815260136020908152604091829020839055815186815290810183905281519293507fe923960f0e10192d5f8159892304055fb305a2f9b86eca4dcdb117ab6a8eca60929081900390910190a192915050565b601554600160a060020a031681565b6000828152600d60209081526040808320600160a060020a038516845282529182902080548351601f60026000196101006001861615020190931692909204918201849004840281018401909452808452606093928301828280156128545780601f1061282957610100808354040283529160200191612854565b820191906000526020600020905b81548152906001019060200180831161283757829003601f168201915b5050505050905092915050565b600054600160a060020a0316331461287857600080fd5b606481111561288657600080fd5b600755565b61289782600083612c75565b505050565b600f6020526000908152604090205460ff1681565b60126020526000908152604090205481565b6128f033604080519081016040528060098152602001600080516020613217833981519152815250610d49565b600160a060020a0382166000908152600b60205260408120610db391839063ffffffff612ffb16565b60065481565b60045481565b60008054600160a060020a0316331461293d57600080fd5b5060005b8151811015610db35761296a828281518110151561295b57fe5b90602001906020020151611c73565b600101612941565b604080517ff593633c00000000000000000000000000000000000000000000000000000000815260026004820152600160a060020a0383166024820152905160009173697e2033ba28c1cc9e28d94ca910ca53a978aad09163f593633c91604480820192602092909190829003018186803b1580156129f057600080fd5b505af4158015612a04573d6000803e3d6000fd5b505050506040513d6020811015612a1a57600080fd5b505192915050565b600054600160a060020a03163314612a3957600080fd5b612a428161300e565b50565b6000811580612a5b5750612a59838361308b565b155b15612a6857506000610bc9565b6000828152602084815260408083208380529091528082205460018084529190922054612a99928692909190613103565b50600081815260209283526040808220828052909352828120819055600181529182209190915590565b600082821115612acf57fe5b50900390565b612adf8282612aea565b1515610db357600080fd5b600160a060020a03166000908152602091909152604090205460ff1690565b6000821515612b1a57506000610bc9565b50818102818382811515612b2a57fe5b0414610bc957fe5b60008183811515612b3f57fe5b049392505050565b612bb1826001836040518082805190602001908083835b60208310612b7d5780518252601f199092019160209182019101612b5e565b51815160209384036101000a6000190180199092169116179052920194855250604051938490030190922092915050613134565b7fd211483f91fc6eff862467f8de606587a30c8fc9981056f051b897a418df803a82826040518083600160a060020a0316600160a060020a0316815260200180602001828103825283818151815260200191508051906020019080838360005b83811015612c29578181015183820152602001612c11565b50505050905090810190601f168015612c565780820380516001836020036101000a031916815260200191505b50935050505060405180910390a15050565b81810182811015610bc957fe5b600160a060020a038316600090815260096020526040808220815160e260020a6315d011eb0281526004810191909152602481018390526001604482015281518392839283928392889273697e2033ba28c1cc9e28d94ca910ca53a978aad09263574047ac92606480840193919291829003018186803b158015612cf857600080fd5b505af4158015612d0c573d6000803e3d6000fd5b505050506040513d6040811015612d2257600080fd5b50805160209091015190945091505b838015612d3d57508115155b8015612d515750861580612d515750600081115b15612e9f57600160a060020a03891660009081526009602052604090819020815160e260020a6315d011eb028152600481019190915260248101849052600160448201528151939450849373697e2033ba28c1cc9e28d94ca910ca53a978aad09263574047ac9260648082019391829003018186803b158015612dd357600080fd5b505af4158015612de7573d6000803e3d6000fd5b505050506040513d6040811015612dfd57600080fd5b5080516020918201516000868152600c909352604090922054909550909250431115612e9157600160a060020a0389166000908152600960205260409020612e4b908463ffffffff612a4516565b506040805184815290517f3c19ef3613691cc28a274f1e4f5a26e85cff95fb7f0077b909a25aa4c82047919181900360200190a187831415612e8c57600194505b612e96565b612e9f565b60001901612d31565b5092979650505050505050565b612f16826001836040518082805190602001908083835b60208310612ee25780518252601f199092019160209182019101612ec3565b51815160209384036101000a6000190180199092169116179052920194855250604051938490030190922092915050613156565b7fbfec83d64eaa953f2708271a023ab9ee82057f8f3578d548c1a4ba0b5b70048982826040518083600160a060020a0316600160a060020a03168152602001806020018281038252838181518152602001915080519060200190808383600083811015612c29578181015183820152602001612c11565b600080612f9a868561308b565b158015612fac5750612fac868661308b565b15612fed57506000848152602086815260408083208515158452909152902054612fd886868686613103565b612fe486858386613103565b60019150612ff2565b600091505b50949350505050565b6130088360008484612f8d565b50505050565b600160a060020a038116151561302357600080fd5b60008054604051600160a060020a03808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a36000805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b6000818152602083815260408083208380529091528120541580156130c6575060008281526020848152604080832060018452909152902054155b156130fb57600080805260208481526040808320600184529091529020548214156130f357506001610bc9565b506000610bc9565b506001610bc9565b6000828152602085815260408083209315808452938252808320869055948252948552838120911581529352912055565b600160a060020a0316600090815260209190915260409020805460ff19169055565b600160a060020a0316600090815260209190915260409020805460ff19166001179055565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f106131bc57805160ff19168380011785556131e9565b828001600101855582156131e9579182015b828111156131e95782518255916020019190600101906131ce565b506131f59291506131f9565b5090565b61321391905b808211156131f557600081556001016131ff565b90560077686974656c6973740000000000000000000000000000000000000000000000a165627a7a7230582035dd21252c73e7570849d8d85bc0fd54445dac06c3a43a420c3852f26b59182d0029000000000000000000000000fcbc318314aae617cf58c2d13a9ee48be0e4c37000000000000000000000000051397c286a6399b4dd1fb8c221be94562d6951cb",
  "constructorArguments": "000000000000000000000000fcbc318314aae617cf58c2d13a9ee48be0e4c37000000000000000000000000051397c286a6399b4dd1fb8c221be94562d6951cb",
  "libraries": [
    {
      "name": "LinkedListLib",
      "address": "0x697E2033BA28C1cC9E28d94ca910cA53a978aaD0"
    }
  ]
}