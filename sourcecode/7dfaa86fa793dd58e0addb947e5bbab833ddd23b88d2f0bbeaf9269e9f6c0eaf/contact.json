{
  "address": "0x5ec18b477b20af940807b5478db5a64cd4a77efd",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "RenExBalances",
  "compilerVersion": "v0.4.24+commit.e67f0147",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2018-09-27\n*/\n\npragma solidity 0.4.24;\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * See https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender)\n    public view returns (uint256);\n\n  function transferFrom(address from, address to, uint256 value)\n    public returns (bool);\n\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipRenounced(address indexed previousOwner);\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to relinquish control of the contract.\n   * @notice Renouncing to ownership will leave the contract without an owner.\n   * It will not be possible to call the functions with the `onlyOwner`\n   * modifier anymore.\n   */\n  function renounceOwnership() public onlyOwner {\n    emit OwnershipRenounced(owner);\n    owner = address(0);\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address _newOwner) public onlyOwner {\n    _transferOwnership(_newOwner);\n  }\n\n  /**\n   * @dev Transfers control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function _transferOwnership(address _newOwner) internal {\n    require(_newOwner != address(0));\n    emit OwnershipTransferred(owner, _newOwner);\n    owner = _newOwner;\n  }\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev Total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev Transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    emit Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256) {\n    return balances[_owner];\n  }\n\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * https://github.com/ethereum/EIPs/issues/20\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  )\n    public\n    returns (bool)\n  {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    emit Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    emit Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(\n    address _owner,\n    address _spender\n   )\n    public\n    view\n    returns (uint256)\n  {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(\n    address _spender,\n    uint256 _addedValue\n  )\n    public\n    returns (bool)\n  {\n    allowed[msg.sender][_spender] = (\n      allowed[msg.sender][_spender].add(_addedValue));\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(\n    address _spender,\n    uint256 _subtractedValue\n  )\n    public\n    returns (bool)\n  {\n    uint256 oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n\n/**\n * @title Pausable token\n * @dev StandardToken modified with pausable transfers.\n **/\ncontract PausableToken is StandardToken, Pausable {\n\n  function transfer(\n    address _to,\n    uint256 _value\n  )\n    public\n    whenNotPaused\n    returns (bool)\n  {\n    return super.transfer(_to, _value);\n  }\n\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  )\n    public\n    whenNotPaused\n    returns (bool)\n  {\n    return super.transferFrom(_from, _to, _value);\n  }\n\n  function approve(\n    address _spender,\n    uint256 _value\n  )\n    public\n    whenNotPaused\n    returns (bool)\n  {\n    return super.approve(_spender, _value);\n  }\n\n  function increaseApproval(\n    address _spender,\n    uint _addedValue\n  )\n    public\n    whenNotPaused\n    returns (bool success)\n  {\n    return super.increaseApproval(_spender, _addedValue);\n  }\n\n  function decreaseApproval(\n    address _spender,\n    uint _subtractedValue\n  )\n    public\n    whenNotPaused\n    returns (bool success)\n  {\n    return super.decreaseApproval(_spender, _subtractedValue);\n  }\n}\n\n/**\n * @title Burnable Token\n * @dev Token that can be irreversibly burned (destroyed).\n */\ncontract BurnableToken is BasicToken {\n\n  event Burn(address indexed burner, uint256 value);\n\n  /**\n   * @dev Burns a specific amount of tokens.\n   * @param _value The amount of token to be burned.\n   */\n  function burn(uint256 _value) public {\n    _burn(msg.sender, _value);\n  }\n\n  function _burn(address _who, uint256 _value) internal {\n    require(_value <= balances[_who]);\n    // no need to require value <= totalSupply, since that would imply the\n    // sender's balance is greater than the totalSupply, which *should* be an assertion failure\n\n    balances[_who] = balances[_who].sub(_value);\n    totalSupply_ = totalSupply_.sub(_value);\n    emit Burn(_who, _value);\n    emit Transfer(_who, address(0), _value);\n  }\n}\n\ncontract RepublicToken is PausableToken, BurnableToken {\n\n    string public constant name = \"Republic Token\";\n    string public constant symbol = \"REN\";\n    uint8 public constant decimals = 18;\n    uint256 public constant INITIAL_SUPPLY = 1000000000 * 10**uint256(decimals);\n\n    /// @notice The RepublicToken Constructor.\n    constructor() public {\n        totalSupply_ = INITIAL_SUPPLY;\n        balances[msg.sender] = INITIAL_SUPPLY;\n    }\n\n    function transferTokens(address beneficiary, uint256 amount) public onlyOwner returns (bool) {\n        /* solium-disable error-reason */\n        require(amount > 0);\n\n        balances[owner] = balances[owner].sub(amount);\n        balances[beneficiary] = balances[beneficiary].add(amount);\n        emit Transfer(owner, beneficiary, amount);\n\n        return true;\n    }\n}\n\n/**\n * @notice LinkedList is a library for a circular double linked list.\n */\nlibrary LinkedList {\n\n    /*\n    * @notice A permanent NULL node (0x0) in the circular double linked list.\n    * NULL.next is the head, and NULL.previous is the tail.\n    */\n    address public constant NULL = 0x0;\n\n    /**\n    * @notice A node points to the node before it, and the node after it. If\n    * node.previous = NULL, then the node is the head of the list. If\n    * node.next = NULL, then the node is the tail of the list.\n    */\n    struct Node {\n        bool inList;\n        address previous;\n        address next;\n    }\n\n    /**\n    * @notice LinkedList uses a mapping from address to nodes. Each address\n    * uniquely identifies a node, and in this way they are used like pointers.\n    */\n    struct List {\n        mapping (address => Node) list;\n    }\n\n    /**\n    * @notice Insert a new node before an existing node.\n    *\n    * @param self The list being used.\n    * @param target The existing node in the list.\n    * @param newNode The next node to insert before the target.\n    */\n    function insertBefore(List storage self, address target, address newNode) internal {\n        require(!isInList(self, newNode), \"already in list\");\n        require(isInList(self, target) || target == NULL, \"not in list\");\n\n        // It is expected that this value is sometimes NULL.\n        address prev = self.list[target].previous;\n\n        self.list[newNode].next = target;\n        self.list[newNode].previous = prev;\n        self.list[target].previous = newNode;\n        self.list[prev].next = newNode;\n\n        self.list[newNode].inList = true;\n    }\n\n    /**\n    * @notice Insert a new node after an existing node.\n    *\n    * @param self The list being used.\n    * @param target The existing node in the list.\n    * @param newNode The next node to insert after the target.\n    */\n    function insertAfter(List storage self, address target, address newNode) internal {\n        require(!isInList(self, newNode), \"already in list\");\n        require(isInList(self, target) || target == NULL, \"not in list\");\n\n        // It is expected that this value is sometimes NULL.\n        address n = self.list[target].next;\n\n        self.list[newNode].previous = target;\n        self.list[newNode].next = n;\n        self.list[target].next = newNode;\n        self.list[n].previous = newNode;\n\n        self.list[newNode].inList = true;\n    }\n\n    /**\n    * @notice Remove a node from the list, and fix the previous and next\n    * pointers that are pointing to the removed node. Removing anode that is not\n    * in the list will do nothing.\n    *\n    * @param self The list being using.\n    * @param node The node in the list to be removed.\n    */\n    function remove(List storage self, address node) internal {\n        require(isInList(self, node), \"not in list\");\n        if (node == NULL) {\n            return;\n        }\n        address p = self.list[node].previous;\n        address n = self.list[node].next;\n\n        self.list[p].next = n;\n        self.list[n].previous = p;\n\n        // Deleting the node should set this value to false, but we set it here for\n        // explicitness.\n        self.list[node].inList = false;\n        delete self.list[node];\n    }\n\n    /**\n    * @notice Insert a node at the beginning of the list.\n    *\n    * @param self The list being used.\n    * @param node The node to insert at the beginning of the list.\n    */\n    function prepend(List storage self, address node) internal {\n        // isInList(node) is checked in insertBefore\n\n        insertBefore(self, begin(self), node);\n    }\n\n    /**\n    * @notice Insert a node at the end of the list.\n    *\n    * @param self The list being used.\n    * @param node The node to insert at the end of the list.\n    */\n    function append(List storage self, address node) internal {\n        // isInList(node) is checked in insertBefore\n\n        insertAfter(self, end(self), node);\n    }\n\n    function swap(List storage self, address left, address right) internal {\n        // isInList(left) and isInList(right) are checked in remove\n\n        address previousRight = self.list[right].previous;\n        remove(self, right);\n        insertAfter(self, left, right);\n        remove(self, left);\n        insertAfter(self, previousRight, left);\n    }\n\n    function isInList(List storage self, address node) internal view returns (bool) {\n        return self.list[node].inList;\n    }\n\n    /**\n    * @notice Get the node at the beginning of a double linked list.\n    *\n    * @param self The list being used.\n    *\n    * @return A address identifying the node at the beginning of the double\n    * linked list.\n    */\n    function begin(List storage self) internal view returns (address) {\n        return self.list[NULL].next;\n    }\n\n    /**\n    * @notice Get the node at the end of a double linked list.\n    *\n    * @param self The list being used.\n    *\n    * @return A address identifying the node at the end of the double linked\n    * list.\n    */\n    function end(List storage self) internal view returns (address) {\n        return self.list[NULL].previous;\n    }\n\n    function next(List storage self, address node) internal view returns (address) {\n        require(isInList(self, node), \"not in list\");\n        return self.list[node].next;\n    }\n\n    function previous(List storage self, address node) internal view returns (address) {\n        require(isInList(self, node), \"not in list\");\n        return self.list[node].previous;\n    }\n\n}\n\n/// @notice This contract stores data and funds for the DarknodeRegistry\n/// contract. The data / fund logic and storage have been separated to improve\n/// upgradability.\ncontract DarknodeRegistryStore is Ownable {\n    string public VERSION; // Passed in as a constructor parameter.\n\n    /// @notice Darknodes are stored in the darknode struct. The owner is the\n    /// address that registered the darknode, the bond is the amount of REN that\n    /// was transferred during registration, and the public key is the\n    /// encryption key that should be used when sending sensitive information to\n    /// the darknode.\n    struct Darknode {\n        // The owner of a Darknode is the address that called the register\n        // function. The owner is the only address that is allowed to\n        // deregister the Darknode, unless the Darknode is slashed for\n        // malicious behavior.\n        address owner;\n\n        // The bond is the amount of REN submitted as a bond by the Darknode.\n        // This amount is reduced when the Darknode is slashed for malicious\n        // behavior.\n        uint256 bond;\n\n        // The block number at which the Darknode is considered registered.\n        uint256 registeredAt;\n\n        // The block number at which the Darknode is considered deregistered.\n        uint256 deregisteredAt;\n\n        // The public key used by this Darknode for encrypting sensitive data\n        // off chain. It is assumed that the Darknode has access to the\n        // respective private key, and that there is an agreement on the format\n        // of the public key.\n        bytes publicKey;\n    }\n\n    /// Registry data.\n    mapping(address => Darknode) private darknodeRegistry;\n    LinkedList.List private darknodes;\n\n    // RepublicToken.\n    RepublicToken public ren;\n\n    /// @notice The contract constructor.\n    ///\n    /// @param _VERSION A string defining the contract version.\n    /// @param _ren The address of the RepublicToken contract.\n    constructor(\n        string _VERSION,\n        RepublicToken _ren\n    ) public {\n        VERSION = _VERSION;\n        ren = _ren;\n    }\n\n    /// @notice Instantiates a darknode and appends it to the darknodes\n    /// linked-list.\n    ///\n    /// @param _darknodeID The darknode's ID.\n    /// @param _darknodeOwner The darknode's owner's address\n    /// @param _bond The darknode's bond value\n    /// @param _publicKey The darknode's public key\n    /// @param _registeredAt The time stamp when the darknode is registered.\n    /// @param _deregisteredAt The time stamp when the darknode is deregistered.\n    function appendDarknode(\n        address _darknodeID,\n        address _darknodeOwner,\n        uint256 _bond,\n        bytes _publicKey,\n        uint256 _registeredAt,\n        uint256 _deregisteredAt\n    ) external onlyOwner {\n        Darknode memory darknode = Darknode({\n            owner: _darknodeOwner,\n            bond: _bond,\n            publicKey: _publicKey,\n            registeredAt: _registeredAt,\n            deregisteredAt: _deregisteredAt\n        });\n        darknodeRegistry[_darknodeID] = darknode;\n        LinkedList.append(darknodes, _darknodeID);\n    }\n\n    /// @notice Returns the address of the first darknode in the store\n    function begin() external view onlyOwner returns(address) {\n        return LinkedList.begin(darknodes);\n    }\n\n    /// @notice Returns the address of the next darknode in the store after the\n    /// given address.\n    function next(address darknodeID) external view onlyOwner returns(address) {\n        return LinkedList.next(darknodes, darknodeID);\n    }\n\n    /// @notice Removes a darknode from the store and transfers its bond to the\n    /// owner of this contract.\n    function removeDarknode(address darknodeID) external onlyOwner {\n        uint256 bond = darknodeRegistry[darknodeID].bond;\n        delete darknodeRegistry[darknodeID];\n        LinkedList.remove(darknodes, darknodeID);\n        require(ren.transfer(owner, bond), \"bond transfer failed\");\n    }\n\n    /// @notice Updates the bond of the darknode. If the bond is being\n    /// decreased, the difference is sent to the owner of this contract.\n    function updateDarknodeBond(address darknodeID, uint256 bond) external onlyOwner {\n        uint256 previousBond = darknodeRegistry[darknodeID].bond;\n        darknodeRegistry[darknodeID].bond = bond;\n        if (previousBond > bond) {\n            require(ren.transfer(owner, previousBond - bond), \"cannot transfer bond\");\n        }\n    }\n\n    /// @notice Updates the deregistration timestamp of a darknode.\n    function updateDarknodeDeregisteredAt(address darknodeID, uint256 deregisteredAt) external onlyOwner {\n        darknodeRegistry[darknodeID].deregisteredAt = deregisteredAt;\n    }\n\n    /// @notice Returns the owner of a given darknode.\n    function darknodeOwner(address darknodeID) external view onlyOwner returns (address) {\n        return darknodeRegistry[darknodeID].owner;\n    }\n\n    /// @notice Returns the bond of a given darknode.\n    function darknodeBond(address darknodeID) external view onlyOwner returns (uint256) {\n        return darknodeRegistry[darknodeID].bond;\n    }\n\n    /// @notice Returns the registration time of a given darknode.\n    function darknodeRegisteredAt(address darknodeID) external view onlyOwner returns (uint256) {\n        return darknodeRegistry[darknodeID].registeredAt;\n    }\n\n    /// @notice Returns the deregistration time of a given darknode.\n    function darknodeDeregisteredAt(address darknodeID) external view onlyOwner returns (uint256) {\n        return darknodeRegistry[darknodeID].deregisteredAt;\n    }\n\n    /// @notice Returns the encryption public key of a given darknode.\n    function darknodePublicKey(address darknodeID) external view onlyOwner returns (bytes) {\n        return darknodeRegistry[darknodeID].publicKey;\n    }\n}\n\n/// @notice DarknodeRegistry is responsible for the registration and\n/// deregistration of Darknodes.\ncontract DarknodeRegistry is Ownable {\n    string public VERSION; // Passed in as a constructor parameter.\n\n    /// @notice Darknode pods are shuffled after a fixed number of blocks.\n    /// An Epoch stores an epoch hash used as an (insecure) RNG seed, and the\n    /// blocknumber which restricts when the next epoch can be called.\n    struct Epoch {\n        uint256 epochhash;\n        uint256 blocknumber;\n    }\n\n    uint256 public numDarknodes;\n    uint256 public numDarknodesNextEpoch;\n    uint256 public numDarknodesPreviousEpoch;\n\n    /// Variables used to parameterize behavior.\n    uint256 public minimumBond;\n    uint256 public minimumPodSize;\n    uint256 public minimumEpochInterval;\n    address public slasher;\n\n    /// When one of the above variables is modified, it is only updated when the\n    /// next epoch is called. These variables store the values for the next epoch.\n    uint256 public nextMinimumBond;\n    uint256 public nextMinimumPodSize;\n    uint256 public nextMinimumEpochInterval;\n    address public nextSlasher;\n\n    /// The current and previous epoch\n    Epoch public currentEpoch;\n    Epoch public previousEpoch;\n\n    /// Republic ERC20 token contract used to transfer bonds.\n    RepublicToken public ren;\n\n    /// Darknode Registry Store is the storage contract for darknodes.\n    DarknodeRegistryStore public store;\n\n    /// @notice Emitted when a darknode is registered.\n    /// @param _darknodeID The darknode ID that was registered.\n    /// @param _bond The amount of REN that was transferred as bond.\n    event LogDarknodeRegistered(address _darknodeID, uint256 _bond);\n\n    /// @notice Emitted when a darknode is deregistered.\n    /// @param _darknodeID The darknode ID that was deregistered.\n    event LogDarknodeDeregistered(address _darknodeID);\n\n    /// @notice Emitted when a refund has been made.\n    /// @param _owner The address that was refunded.\n    /// @param _amount The amount of REN that was refunded.\n    event LogDarknodeOwnerRefunded(address _owner, uint256 _amount);\n\n    /// @notice Emitted when a new epoch has begun.\n    event LogNewEpoch();\n\n    /// @notice Emitted when a constructor parameter has been updated.\n    event LogMinimumBondUpdated(uint256 previousMinimumBond, uint256 nextMinimumBond);\n    event LogMinimumPodSizeUpdated(uint256 previousMinimumPodSize, uint256 nextMinimumPodSize);\n    event LogMinimumEpochIntervalUpdated(uint256 previousMinimumEpochInterval, uint256 nextMinimumEpochInterval);\n    event LogSlasherUpdated(address previousSlasher, address nextSlasher);\n\n    /// @notice Only allow the owner that registered the darknode to pass.\n    modifier onlyDarknodeOwner(address _darknodeID) {\n        require(store.darknodeOwner(_darknodeID) == msg.sender, \"must be darknode owner\");\n        _;\n    }\n\n    /// @notice Only allow unregistered darknodes.\n    modifier onlyRefunded(address _darknodeID) {\n        require(isRefunded(_darknodeID), \"must be refunded or never registered\");\n        _;\n    }\n\n    /// @notice Only allow refundable darknodes.\n    modifier onlyRefundable(address _darknodeID) {\n        require(isRefundable(_darknodeID), \"must be deregistered for at least one epoch\");\n        _;\n    }\n\n    /// @notice Only allowed registered nodes without a pending deregistration to\n    /// deregister\n    modifier onlyDeregisterable(address _darknodeID) {\n        require(isDeregisterable(_darknodeID), \"must be deregisterable\");\n        _;\n    }\n\n    /// @notice Only allow the Slasher contract.\n    modifier onlySlasher() {\n        require(slasher == msg.sender, \"must be slasher\");\n        _;\n    }\n\n    /// @notice The contract constructor.\n    ///\n    /// @param _VERSION A string defining the contract version.\n    /// @param _renAddress The address of the RepublicToken contract.\n    /// @param _storeAddress The address of the DarknodeRegistryStore contract.\n    /// @param _minimumBond The minimum bond amount that can be submitted by a\n    ///        Darknode.\n    /// @param _minimumPodSize The minimum size of a Darknode pod.\n    /// @param _minimumEpochInterval The minimum number of blocks between\n    ///        epochs.\n    constructor(\n        string _VERSION,\n        RepublicToken _renAddress,\n        DarknodeRegistryStore _storeAddress,\n        uint256 _minimumBond,\n        uint256 _minimumPodSize,\n        uint256 _minimumEpochInterval\n    ) public {\n        VERSION = _VERSION;\n\n        store = _storeAddress;\n        ren = _renAddress;\n\n        minimumBond = _minimumBond;\n        nextMinimumBond = minimumBond;\n\n        minimumPodSize = _minimumPodSize;\n        nextMinimumPodSize = minimumPodSize;\n\n        minimumEpochInterval = _minimumEpochInterval;\n        nextMinimumEpochInterval = minimumEpochInterval;\n\n        currentEpoch = Epoch({\n            epochhash: uint256(blockhash(block.number - 1)),\n            blocknumber: block.number\n        });\n        numDarknodes = 0;\n        numDarknodesNextEpoch = 0;\n        numDarknodesPreviousEpoch = 0;\n    }\n\n    /// @notice Register a darknode and transfer the bond to this contract. The\n    /// caller must provide a public encryption key for the darknode as well as\n    /// a bond in REN. The bond must be provided as an ERC20 allowance. The dark\n    /// node will remain pending registration until the next epoch. Only after\n    /// this period can the darknode be deregistered. The caller of this method\n    /// will be stored as the owner of the darknode.\n    ///\n    /// @param _darknodeID The darknode ID that will be registered.\n    /// @param _publicKey The public key of the darknode. It is stored to allow\n    ///        other darknodes and traders to encrypt messages to the trader.\n    /// @param _bond The bond that will be paid. It must be greater than, or\n    ///        equal to, the minimum bond.\n    function register(address _darknodeID, bytes _publicKey, uint256 _bond) external onlyRefunded(_darknodeID) {\n        // REN allowance\n        require(_bond >= minimumBond, \"insufficient bond\");\n        // require(ren.allowance(msg.sender, address(this)) >= _bond);\n        require(ren.transferFrom(msg.sender, address(this), _bond), \"bond transfer failed\");\n        ren.transfer(address(store), _bond);\n\n        // Flag this darknode for registration\n        store.appendDarknode(\n            _darknodeID,\n            msg.sender,\n            _bond,\n            _publicKey,\n            currentEpoch.blocknumber + minimumEpochInterval,\n            0\n        );\n\n        numDarknodesNextEpoch += 1;\n\n        // Emit an event.\n        emit LogDarknodeRegistered(_darknodeID, _bond);\n    }\n\n    /// @notice Deregister a darknode. The darknode will not be deregistered\n    /// until the end of the epoch. After another epoch, the bond can be\n    /// refunded by calling the refund method.\n    /// @param _darknodeID The darknode ID that will be deregistered. The caller\n    ///        of this method store.darknodeRegisteredAt(_darknodeID) must be\n    //         the owner of this darknode.\n    function deregister(address _darknodeID) external onlyDeregisterable(_darknodeID) onlyDarknodeOwner(_darknodeID) {\n        // Flag the darknode for deregistration\n        store.updateDarknodeDeregisteredAt(_darknodeID, currentEpoch.blocknumber + minimumEpochInterval);\n        numDarknodesNextEpoch -= 1;\n\n        // Emit an event\n        emit LogDarknodeDeregistered(_darknodeID);\n    }\n\n    /// @notice Progress the epoch if it is possible to do so. This captures\n    /// the current timestamp and current blockhash and overrides the current\n    /// epoch.\n    function epoch() external {\n        if (previousEpoch.blocknumber == 0) {\n            // The first epoch must be called by the owner of the contract\n            require(msg.sender == owner, \"not authorized (first epochs)\");\n        }\n\n        // Require that the epoch interval has passed\n        require(block.number >= currentEpoch.blocknumber + minimumEpochInterval, \"epoch interval has not passed\");\n        uint256 epochhash = uint256(blockhash(block.number - 1));\n\n        // Update the epoch hash and timestamp\n        previousEpoch = currentEpoch;\n        currentEpoch = Epoch({\n            epochhash: epochhash,\n            blocknumber: block.number\n        });\n\n        // Update the registry information\n        numDarknodesPreviousEpoch = numDarknodes;\n        numDarknodes = numDarknodesNextEpoch;\n\n        // If any update functions have been called, update the values now\n        if (nextMinimumBond != minimumBond) {\n            minimumBond = nextMinimumBond;\n            emit LogMinimumBondUpdated(minimumBond, nextMinimumBond);\n        }\n        if (nextMinimumPodSize != minimumPodSize) {\n            minimumPodSize = nextMinimumPodSize;\n            emit LogMinimumPodSizeUpdated(minimumPodSize, nextMinimumPodSize);\n        }\n        if (nextMinimumEpochInterval != minimumEpochInterval) {\n            minimumEpochInterval = nextMinimumEpochInterval;\n            emit LogMinimumEpochIntervalUpdated(minimumEpochInterval, nextMinimumEpochInterval);\n        }\n        if (nextSlasher != slasher) {\n            slasher = nextSlasher;\n            emit LogSlasherUpdated(slasher, nextSlasher);\n        }\n\n        // Emit an event\n        emit LogNewEpoch();\n    }\n\n    /// @notice Allows the contract owner to transfer ownership of the\n    /// DarknodeRegistryStore.\n    /// @param _newOwner The address to transfer the ownership to.\n    function transferStoreOwnership(address _newOwner) external onlyOwner {\n        store.transferOwnership(_newOwner);\n    }\n\n    /// @notice Allows the contract owner to update the minimum bond.\n    /// @param _nextMinimumBond The minimum bond amount that can be submitted by\n    ///        a darknode.\n    function updateMinimumBond(uint256 _nextMinimumBond) external onlyOwner {\n        // Will be updated next epoch\n        nextMinimumBond = _nextMinimumBond;\n    }\n\n    /// @notice Allows the contract owner to update the minimum pod size.\n    /// @param _nextMinimumPodSize The minimum size of a pod.\n    function updateMinimumPodSize(uint256 _nextMinimumPodSize) external onlyOwner {\n        // Will be updated next epoch\n        nextMinimumPodSize = _nextMinimumPodSize;\n    }\n\n    /// @notice Allows the contract owner to update the minimum epoch interval.\n    /// @param _nextMinimumEpochInterval The minimum number of blocks between epochs.\n    function updateMinimumEpochInterval(uint256 _nextMinimumEpochInterval) external onlyOwner {\n        // Will be updated next epoch\n        nextMinimumEpochInterval = _nextMinimumEpochInterval;\n    }\n\n    /// @notice Allow the contract owner to update the DarknodeSlasher contract\n    /// address.\n    /// @param _slasher The new slasher address.\n    function updateSlasher(address _slasher) external onlyOwner {\n        nextSlasher = _slasher;\n    }\n\n    /// @notice Allow the DarknodeSlasher contract to slash half of a darknode's\n    /// bond and deregister it. The bond is distributed as follows:\n    ///   1/2 is kept by the guilty prover\n    ///   1/8 is rewarded to the first challenger\n    ///   1/8 is rewarded to the second challenger\n    ///   1/4 becomes unassigned\n    /// @param _prover The guilty prover whose bond is being slashed\n    /// @param _challenger1 The first of the two darknodes who submitted the challenge\n    /// @param _challenger2 The second of the two darknodes who submitted the challenge\n    function slash(address _prover, address _challenger1, address _challenger2)\n        external\n        onlySlasher\n    {\n        uint256 penalty = store.darknodeBond(_prover) / 2;\n        uint256 reward = penalty / 4;\n\n        // Slash the bond of the failed prover in half\n        store.updateDarknodeBond(_prover, penalty);\n\n        // If the darknode has not been deregistered then deregister it\n        if (isDeregisterable(_prover)) {\n            store.updateDarknodeDeregisteredAt(_prover, currentEpoch.blocknumber + minimumEpochInterval);\n            numDarknodesNextEpoch -= 1;\n            emit LogDarknodeDeregistered(_prover);\n        }\n\n        // Reward the challengers with less than the penalty so that it is not\n        // worth challenging yourself\n        ren.transfer(store.darknodeOwner(_challenger1), reward);\n        ren.transfer(store.darknodeOwner(_challenger2), reward);\n    }\n\n    /// @notice Refund the bond of a deregistered darknode. This will make the\n    /// darknode available for registration again. Anyone can call this function\n    /// but the bond will always be refunded to the darknode owner.\n    ///\n    /// @param _darknodeID The darknode ID that will be refunded. The caller\n    ///        of this method must be the owner of this darknode.\n    function refund(address _darknodeID) external onlyRefundable(_darknodeID) {\n        address darknodeOwner = store.darknodeOwner(_darknodeID);\n\n        // Remember the bond amount\n        uint256 amount = store.darknodeBond(_darknodeID);\n\n        // Erase the darknode from the registry\n        store.removeDarknode(_darknodeID);\n\n        // Refund the owner by transferring REN\n        ren.transfer(darknodeOwner, amount);\n\n        // Emit an event.\n        emit LogDarknodeOwnerRefunded(darknodeOwner, amount);\n    }\n\n    /// @notice Retrieves the address of the account that registered a darknode.\n    /// @param _darknodeID The ID of the darknode to retrieve the owner for.\n    function getDarknodeOwner(address _darknodeID) external view returns (address) {\n        return store.darknodeOwner(_darknodeID);\n    }\n\n    /// @notice Retrieves the bond amount of a darknode in 10^-18 REN.\n    /// @param _darknodeID The ID of the darknode to retrieve the bond for.\n    function getDarknodeBond(address _darknodeID) external view returns (uint256) {\n        return store.darknodeBond(_darknodeID);\n    }\n\n    /// @notice Retrieves the encryption public key of the darknode.\n    /// @param _darknodeID The ID of the darknode to retrieve the public key for.\n    function getDarknodePublicKey(address _darknodeID) external view returns (bytes) {\n        return store.darknodePublicKey(_darknodeID);\n    }\n\n    /// @notice Retrieves a list of darknodes which are registered for the\n    /// current epoch.\n    /// @param _start A darknode ID used as an offset for the list. If _start is\n    ///        0x0, the first dark node will be used. _start won't be\n    ///        included it is not registered for the epoch.\n    /// @param _count The number of darknodes to retrieve starting from _start.\n    ///        If _count is 0, all of the darknodes from _start are\n    ///        retrieved. If _count is more than the remaining number of\n    ///        registered darknodes, the rest of the list will contain\n    ///        0x0s.\n    function getDarknodes(address _start, uint256 _count) external view returns (address[]) {\n        uint256 count = _count;\n        if (count == 0) {\n            count = numDarknodes;\n        }\n        return getDarknodesFromEpochs(_start, count, false);\n    }\n\n    /// @notice Retrieves a list of darknodes which were registered for the\n    /// previous epoch. See `getDarknodes` for the parameter documentation.\n    function getPreviousDarknodes(address _start, uint256 _count) external view returns (address[]) {\n        uint256 count = _count;\n        if (count == 0) {\n            count = numDarknodesPreviousEpoch;\n        }\n        return getDarknodesFromEpochs(_start, count, true);\n    }\n\n    /// @notice Returns whether a darknode is scheduled to become registered\n    /// at next epoch.\n    /// @param _darknodeID The ID of the darknode to return\n    function isPendingRegistration(address _darknodeID) external view returns (bool) {\n        uint256 registeredAt = store.darknodeRegisteredAt(_darknodeID);\n        return registeredAt != 0 && registeredAt > currentEpoch.blocknumber;\n    }\n\n    /// @notice Returns if a darknode is in the pending deregistered state. In\n    /// this state a darknode is still considered registered.\n    function isPendingDeregistration(address _darknodeID) external view returns (bool) {\n        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);\n        return deregisteredAt != 0 && deregisteredAt > currentEpoch.blocknumber;\n    }\n\n    /// @notice Returns if a darknode is in the deregistered state.\n    function isDeregistered(address _darknodeID) public view returns (bool) {\n        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);\n        return deregisteredAt != 0 && deregisteredAt <= currentEpoch.blocknumber;\n    }\n\n    /// @notice Returns if a darknode can be deregistered. This is true if the\n    /// darknodes is in the registered state and has not attempted to\n    /// deregister yet.\n    function isDeregisterable(address _darknodeID) public view returns (bool) {\n        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);\n        // The Darknode is currently in the registered state and has not been\n        // transitioned to the pending deregistration, or deregistered, state\n        return isRegistered(_darknodeID) && deregisteredAt == 0;\n    }\n\n    /// @notice Returns if a darknode is in the refunded state. This is true\n    /// for darknodes that have never been registered, or darknodes that have\n    /// been deregistered and refunded.\n    function isRefunded(address _darknodeID) public view returns (bool) {\n        uint256 registeredAt = store.darknodeRegisteredAt(_darknodeID);\n        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);\n        return registeredAt == 0 && deregisteredAt == 0;\n    }\n\n    /// @notice Returns if a darknode is refundable. This is true for darknodes\n    /// that have been in the deregistered state for one full epoch.\n    function isRefundable(address _darknodeID) public view returns (bool) {\n        return isDeregistered(_darknodeID) && store.darknodeDeregisteredAt(_darknodeID) <= previousEpoch.blocknumber;\n    }\n\n    /// @notice Returns if a darknode is in the registered state.\n    function isRegistered(address _darknodeID) public view returns (bool) {\n        return isRegisteredInEpoch(_darknodeID, currentEpoch);\n    }\n\n    /// @notice Returns if a darknode was in the registered state last epoch.\n    function isRegisteredInPreviousEpoch(address _darknodeID) public view returns (bool) {\n        return isRegisteredInEpoch(_darknodeID, previousEpoch);\n    }\n\n    /// @notice Returns if a darknode was in the registered state for a given\n    /// epoch.\n    /// @param _darknodeID The ID of the darknode\n    /// @param _epoch One of currentEpoch, previousEpoch\n    function isRegisteredInEpoch(address _darknodeID, Epoch _epoch) private view returns (bool) {\n        uint256 registeredAt = store.darknodeRegisteredAt(_darknodeID);\n        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);\n        bool registered = registeredAt != 0 && registeredAt <= _epoch.blocknumber;\n        bool notDeregistered = deregisteredAt == 0 || deregisteredAt > _epoch.blocknumber;\n        // The Darknode has been registered and has not yet been deregistered,\n        // although it might be pending deregistration\n        return registered && notDeregistered;\n    }\n\n    /// @notice Returns a list of darknodes registered for either the current\n    /// or the previous epoch. See `getDarknodes` for documentation on the\n    /// parameters `_start` and `_count`.\n    /// @param _usePreviousEpoch If true, use the previous epoch, otherwise use\n    ///        the current epoch.\n    function getDarknodesFromEpochs(address _start, uint256 _count, bool _usePreviousEpoch) private view returns (address[]) {\n        uint256 count = _count;\n        if (count == 0) {\n            count = numDarknodes;\n        }\n\n        address[] memory nodes = new address[](count);\n\n        // Begin with the first node in the list\n        uint256 n = 0;\n        address next = _start;\n        if (next == 0x0) {\n            next = store.begin();\n        }\n\n        // Iterate until all registered Darknodes have been collected\n        while (n < count) {\n            if (next == 0x0) {\n                break;\n            }\n            // Only include Darknodes that are currently registered\n            bool includeNext;\n            if (_usePreviousEpoch) {\n                includeNext = isRegisteredInPreviousEpoch(next);\n            } else {\n                includeNext = isRegistered(next);\n            }\n            if (!includeNext) {\n                next = store.next(next);\n                continue;\n            }\n            nodes[n] = next;\n            next = store.next(next);\n            n += 1;\n        }\n        return nodes;\n    }\n}\n\n/**\n * @title Math\n * @dev Assorted math operations\n */\nlibrary Math {\n  function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n    return a >= b ? a : b;\n  }\n\n  function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n    return a < b ? a : b;\n  }\n\n  function max256(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a >= b ? a : b;\n  }\n\n  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a < b ? a : b;\n  }\n}\n\n/// @notice Implements safeTransfer, safeTransferFrom and\n/// safeApprove for CompatibleERC20.\n///\n/// See https://github.com/ethereum/solidity/issues/4116\n///\n/// This library allows interacting with ERC20 tokens that implement any of\n/// these interfaces:\n///\n/// (1) transfer returns true on success, false on failure\n/// (2) transfer returns true on success, reverts on failure\n/// (3) transfer returns nothing on success, reverts on failure\n///\n/// Additionally, safeTransferFromWithFees will return the final token\n/// value received after accounting for token fees.\nlibrary CompatibleERC20Functions {\n    using SafeMath for uint256;\n\n    /// @notice Calls transfer on the token and reverts if the call fails.\n    function safeTransfer(address token, address to, uint256 amount) internal {\n        CompatibleERC20(token).transfer(to, amount);\n        require(previousReturnValue(), \"transfer failed\");\n    }\n\n    /// @notice Calls transferFrom on the token and reverts if the call fails.\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\n        CompatibleERC20(token).transferFrom(from, to, amount);\n        require(previousReturnValue(), \"transferFrom failed\");\n    }\n\n    /// @notice Calls approve on the token and reverts if the call fails.\n    function safeApprove(address token, address spender, uint256 amount) internal {\n        CompatibleERC20(token).approve(spender, amount);\n        require(previousReturnValue(), \"approve failed\");\n    }\n\n    /// @notice Calls transferFrom on the token, reverts if the call fails and\n    /// returns the value transferred after fees.\n    function safeTransferFromWithFees(address token, address from, address to, uint256 amount) internal returns (uint256) {\n        uint256 balancesBefore = CompatibleERC20(token).balanceOf(to);\n        CompatibleERC20(token).transferFrom(from, to, amount);\n        require(previousReturnValue(), \"transferFrom failed\");\n        uint256 balancesAfter = CompatibleERC20(token).balanceOf(to);\n        return Math.min256(amount, balancesAfter.sub(balancesBefore));\n    }\n\n    /// @notice Checks the return value of the previous function. Returns true\n    /// if the previous function returned 32 non-zero bytes or returned zero\n    /// bytes.\n    function previousReturnValue() private pure returns (bool)\n    {\n        uint256 returnData = 0;\n\n        assembly { /* solium-disable-line security/no-inline-assembly */\n            // Switch on the number of bytes returned by the previous call\n            switch returndatasize\n\n            // 0 bytes: ERC20 of type (3), did not throw\n            case 0 {\n                returnData := 1\n            }\n\n            // 32 bytes: ERC20 of types (1) or (2)\n            case 32 {\n                // Copy the return data into scratch space\n                returndatacopy(0x0, 0x0, 32)\n\n                // Load  the return data into returnData\n                returnData := mload(0x0)\n            }\n\n            // Other return size: return false\n            default { }\n        }\n\n        return returnData != 0;\n    }\n}\n\n/// @notice ERC20 interface which doesn't specify the return type for transfer,\n/// transferFrom and approve.\ninterface CompatibleERC20 {\n    // Modified to not return boolean\n    function transfer(address to, uint256 value) external;\n    function transferFrom(address from, address to, uint256 value) external;\n    function approve(address spender, uint256 value) external;\n\n    // Not modifier\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address who) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/// @notice The DarknodeRewardVault contract is responsible for holding fees\n/// for darknodes for settling orders. Fees can be withdrawn to the address of\n/// the darknode's operator. Fees can be in ETH or in ERC20 tokens.\n/// Docs: https://github.com/republicprotocol/republic-sol/blob/master/docs/02-darknode-reward-vault.md\ncontract DarknodeRewardVault is Ownable {\n    using SafeMath for uint256;\n    using CompatibleERC20Functions for CompatibleERC20;\n\n    string public VERSION; // Passed in as a constructor parameter.\n\n    /// @notice The special address for Ether.\n    address constant public ETHEREUM = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    DarknodeRegistry public darknodeRegistry;\n\n    mapping(address => mapping(address => uint256)) public darknodeBalances;\n\n    event LogDarknodeRegistryUpdated(DarknodeRegistry previousDarknodeRegistry, DarknodeRegistry nextDarknodeRegistry);\n\n    /// @notice The contract constructor.\n    ///\n    /// @param _VERSION A string defining the contract version.\n    /// @param _darknodeRegistry The DarknodeRegistry contract that is used by\n    ///        the vault to lookup Darknode owners.\n    constructor(string _VERSION, DarknodeRegistry _darknodeRegistry) public {\n        VERSION = _VERSION;\n        darknodeRegistry = _darknodeRegistry;\n    }\n\n    function updateDarknodeRegistry(DarknodeRegistry _newDarknodeRegistry) public onlyOwner {\n        emit LogDarknodeRegistryUpdated(darknodeRegistry, _newDarknodeRegistry);\n        darknodeRegistry = _newDarknodeRegistry;\n    }\n\n    /// @notice Deposit fees into the vault for a Darknode. The Darknode\n    /// registration is not checked (to reduce gas fees); the caller must be\n    /// careful not to call this function for a Darknode that is not registered\n    /// otherwise any fees deposited to that Darknode can be withdrawn by a\n    /// malicious adversary (by registering the Darknode before the honest\n    /// party and claiming ownership).\n    ///\n    /// @param _darknode The address of the Darknode that will receive the\n    ///        fees.\n    /// @param _token The address of the ERC20 token being used to pay the fee.\n    ///        A special address is used for Ether.\n    /// @param _value The amount of fees in the smallest unit of the token.\n    function deposit(address _darknode, ERC20 _token, uint256 _value) public payable {\n        uint256 receivedValue = _value;\n        if (address(_token) == ETHEREUM) {\n            require(msg.value == _value, \"mismatched ether value\");\n        } else {\n            require(msg.value == 0, \"unexpected ether value\");\n            receivedValue = CompatibleERC20(_token).safeTransferFromWithFees(msg.sender, address(this), _value);\n        }\n        darknodeBalances[_darknode][_token] = darknodeBalances[_darknode][_token].add(receivedValue);\n    }\n\n    /// @notice Withdraw fees earned by a Darknode. The fees will be sent to\n    /// the owner of the Darknode. If a Darknode is not registered the fees\n    /// cannot be withdrawn.\n    ///\n    /// @param _darknode The address of the Darknode whose fees are being\n    ///        withdrawn. The owner of this Darknode will receive the fees.\n    /// @param _token The address of the ERC20 token to withdraw.\n    function withdraw(address _darknode, ERC20 _token) public {\n        address darknodeOwner = darknodeRegistry.getDarknodeOwner(address(_darknode));\n\n        require(darknodeOwner != 0x0, \"invalid darknode owner\");\n\n        uint256 value = darknodeBalances[_darknode][_token];\n        darknodeBalances[_darknode][_token] = 0;\n\n        if (address(_token) == ETHEREUM) {\n            darknodeOwner.transfer(value);\n        } else {\n            CompatibleERC20(_token).safeTransfer(darknodeOwner, value);\n        }\n    }\n\n}\n\n/// @notice The BrokerVerifier interface defines the functions that a settlement\n/// layer's broker verifier contract must implement.\ninterface BrokerVerifier {\n\n    /// @notice The function signature that will be called when a trader opens\n    /// an order.\n    ///\n    /// @param _trader The trader requesting the withdrawal.\n    /// @param _signature The 65-byte signature from the broker.\n    /// @param _orderID The 32-byte order ID.\n    function verifyOpenSignature(\n        address _trader,\n        bytes _signature,\n        bytes32 _orderID\n    ) external returns (bool);\n}\n\n/// @notice The Settlement interface defines the functions that a settlement\n/// layer must implement.\n/// Docs: https://github.com/republicprotocol/republic-sol/blob/nightly/docs/05-settlement.md\ninterface Settlement {\n    function submitOrder(\n        bytes _details,\n        uint64 _settlementID,\n        uint64 _tokens,\n        uint256 _price,\n        uint256 _volume,\n        uint256 _minimumVolume\n    ) external;\n\n    function submissionGasPriceLimit() external view returns (uint256);\n\n    function settle(\n        bytes32 _buyID,\n        bytes32 _sellID\n    ) external;\n\n    /// @notice orderStatus should return the status of the order, which should\n    /// be:\n    ///     0  - Order not seen before\n    ///     1  - Order details submitted\n    ///     >1 - Order settled, or settlement no longer possible\n    function orderStatus(bytes32 _orderID) external view returns (uint8);\n}\n\n/// @notice SettlementRegistry allows a Settlement layer to register the\n/// contracts used for match settlement and for broker signature verification.\ncontract SettlementRegistry is Ownable {\n    string public VERSION; // Passed in as a constructor parameter.\n\n    struct SettlementDetails {\n        bool registered;\n        Settlement settlementContract;\n        BrokerVerifier brokerVerifierContract;\n    }\n\n    // Settlement IDs are 64-bit unsigned numbers\n    mapping(uint64 => SettlementDetails) public settlementDetails;\n\n    // Events\n    event LogSettlementRegistered(uint64 settlementID, Settlement settlementContract, BrokerVerifier brokerVerifierContract);\n    event LogSettlementUpdated(uint64 settlementID, Settlement settlementContract, BrokerVerifier brokerVerifierContract);\n    event LogSettlementDeregistered(uint64 settlementID);\n\n    /// @notice The contract constructor.\n    ///\n    /// @param _VERSION A string defining the contract version.\n    constructor(string _VERSION) public {\n        VERSION = _VERSION;\n    }\n\n    /// @notice Returns the settlement contract of a settlement layer.\n    function settlementRegistration(uint64 _settlementID) external view returns (bool) {\n        return settlementDetails[_settlementID].registered;\n    }\n\n    /// @notice Returns the settlement contract of a settlement layer.\n    function settlementContract(uint64 _settlementID) external view returns (Settlement) {\n        return settlementDetails[_settlementID].settlementContract;\n    }\n\n    /// @notice Returns the broker verifier contract of a settlement layer.\n    function brokerVerifierContract(uint64 _settlementID) external view returns (BrokerVerifier) {\n        return settlementDetails[_settlementID].brokerVerifierContract;\n    }\n\n    /// @param _settlementID A unique 64-bit settlement identifier.\n    /// @param _settlementContract The address to use for settling matches.\n    /// @param _brokerVerifierContract The decimals to use for verifying\n    ///        broker signatures.\n    function registerSettlement(uint64 _settlementID, Settlement _settlementContract, BrokerVerifier _brokerVerifierContract) public onlyOwner {\n        bool alreadyRegistered = settlementDetails[_settlementID].registered;\n        \n        settlementDetails[_settlementID] = SettlementDetails({\n            registered: true,\n            settlementContract: _settlementContract,\n            brokerVerifierContract: _brokerVerifierContract\n        });\n\n        if (alreadyRegistered) {\n            emit LogSettlementUpdated(_settlementID, _settlementContract, _brokerVerifierContract);\n        } else {\n            emit LogSettlementRegistered(_settlementID, _settlementContract, _brokerVerifierContract);\n        }\n    }\n\n    /// @notice Deregisteres a settlement layer, clearing the details.\n    /// @param _settlementID The unique 64-bit settlement identifier.\n    function deregisterSettlement(uint64 _settlementID) external onlyOwner {\n        require(settlementDetails[_settlementID].registered, \"not registered\");\n\n        delete settlementDetails[_settlementID];\n\n        emit LogSettlementDeregistered(_settlementID);\n    }\n}\n\n/**\n * @title Eliptic curve signature operations\n * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\n * TODO Remove this library once solidity supports passing a signature to ecrecover.\n * See https://github.com/ethereum/solidity/issues/864\n */\n\nlibrary ECRecovery {\n\n  /**\n   * @dev Recover signer address from a message by using their signature\n   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\n   * @param sig bytes signature, the signature is generated using web3.eth.sign()\n   */\n  function recover(bytes32 hash, bytes sig)\n    internal\n    pure\n    returns (address)\n  {\n    bytes32 r;\n    bytes32 s;\n    uint8 v;\n\n    // Check the signature length\n    if (sig.length != 65) {\n      return (address(0));\n    }\n\n    // Divide the signature in r, s and v variables\n    // ecrecover takes the signature parameters, and the only way to get them\n    // currently is to use assembly.\n    // solium-disable-next-line security/no-inline-assembly\n    assembly {\n      r := mload(add(sig, 32))\n      s := mload(add(sig, 64))\n      v := byte(0, mload(add(sig, 96)))\n    }\n\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n    if (v < 27) {\n      v += 27;\n    }\n\n    // If the version is correct return the signer address\n    if (v != 27 && v != 28) {\n      return (address(0));\n    } else {\n      // solium-disable-next-line arg-overflow\n      return ecrecover(hash, v, r, s);\n    }\n  }\n\n  /**\n   * toEthSignedMessageHash\n   * @dev prefix a bytes32 value with \"\\x19Ethereum Signed Message:\"\n   * and hash the result\n   */\n  function toEthSignedMessageHash(bytes32 hash)\n    internal\n    pure\n    returns (bytes32)\n  {\n    // 32 is the length in bytes of hash,\n    // enforced by the type signature above\n    return keccak256(\n      abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)\n    );\n  }\n}\n\nlibrary Utils {\n\n    /**\n     * @notice Converts a number to its string/bytes representation\n     *\n     * @param _v the uint to convert\n     */\n    function uintToBytes(uint256 _v) internal pure returns (bytes) {\n        uint256 v = _v;\n        if (v == 0) {\n            return \"0\";\n        }\n\n        uint256 digits = 0;\n        uint256 v2 = v;\n        while (v2 > 0) {\n            v2 /= 10;\n            digits += 1;\n        }\n\n        bytes memory result = new bytes(digits);\n\n        for (uint256 i = 0; i < digits; i++) {\n            result[digits - i - 1] = bytes1((v % 10) + 48);\n            v /= 10;\n        }\n\n        return result;\n    }\n\n    /**\n     * @notice Retrieves the address from a signature\n     *\n     * @param _hash the message that was signed (any length of bytes)\n     * @param _signature the signature (65 bytes)\n     */\n    function addr(bytes _hash, bytes _signature) internal pure returns (address) {\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n\";\n        bytes memory encoded = abi.encodePacked(prefix, uintToBytes(_hash.length), _hash);\n        bytes32 prefixedHash = keccak256(encoded);\n\n        return ECRecovery.recover(prefixedHash, _signature);\n    }\n\n}\n\n/// @notice The Orderbook contract stores the state and priority of orders and\n/// allows the Darknodes to easily reach consensus. Eventually, this contract\n/// will only store a subset of order states, such as cancellation, to improve\n/// the throughput of orders.\ncontract Orderbook is Ownable {\n    string public VERSION; // Passed in as a constructor parameter.\n\n    /// @notice OrderState enumerates the possible states of an order. All\n    /// orders default to the Undefined state.\n    enum OrderState {Undefined, Open, Confirmed, Canceled}\n\n    /// @notice Order stores a subset of the public data associated with an order.\n    struct Order {\n        OrderState state;     // State of the order\n        address trader;       // Trader that owns the order\n        address confirmer;    // Darknode that confirmed the order in a match\n        uint64 settlementID;  // The settlement that signed the order opening\n        uint256 priority;     // Logical time priority of this order\n        uint256 blockNumber;  // Block number of the most recent state change\n        bytes32 matchedOrder; // Order confirmed in a match with this order\n    }\n\n    DarknodeRegistry public darknodeRegistry;\n    SettlementRegistry public settlementRegistry;\n\n    bytes32[] private orderbook;\n\n    // Order details are exposed through directly accessing this mapping, or\n    // through the getter functions below for each of the order's fields.\n    mapping(bytes32 => Order) public orders;\n\n    event LogFeeUpdated(uint256 previousFee, uint256 nextFee);\n    event LogDarknodeRegistryUpdated(DarknodeRegistry previousDarknodeRegistry, DarknodeRegistry nextDarknodeRegistry);\n\n    /// @notice Only allow registered dark nodes.\n    modifier onlyDarknode(address _sender) {\n        require(darknodeRegistry.isRegistered(address(_sender)), \"must be registered darknode\");\n        _;\n    }\n\n    /// @notice The contract constructor.\n    ///\n    /// @param _VERSION A string defining the contract version.\n    /// @param _darknodeRegistry The address of the DarknodeRegistry contract.\n    /// @param _settlementRegistry The address of the SettlementRegistry\n    ///        contract.\n    constructor(\n        string _VERSION,\n        DarknodeRegistry _darknodeRegistry,\n        SettlementRegistry _settlementRegistry\n    ) public {\n        VERSION = _VERSION;\n        darknodeRegistry = _darknodeRegistry;\n        settlementRegistry = _settlementRegistry;\n    }\n\n    /// @notice Allows the owner to update the address of the DarknodeRegistry\n    /// contract.\n    function updateDarknodeRegistry(DarknodeRegistry _newDarknodeRegistry) external onlyOwner {\n        emit LogDarknodeRegistryUpdated(darknodeRegistry, _newDarknodeRegistry);\n        darknodeRegistry = _newDarknodeRegistry;\n    }\n\n    /// @notice Open an order in the orderbook. The order must be in the\n    /// Undefined state.\n    ///\n    /// @param _signature Signature of the message that defines the trader. The\n    ///        message is \"Republic Protocol: open: {orderId}\".\n    /// @param _orderID The hash of the order.\n    function openOrder(uint64 _settlementID, bytes _signature, bytes32 _orderID) external {\n        require(orders[_orderID].state == OrderState.Undefined, \"invalid order status\");\n\n        address trader = msg.sender;\n\n        // Verify the order signature\n        require(settlementRegistry.settlementRegistration(_settlementID), \"settlement not registered\");\n        BrokerVerifier brokerVerifier = settlementRegistry.brokerVerifierContract(_settlementID);\n        require(brokerVerifier.verifyOpenSignature(trader, _signature, _orderID), \"invalid broker signature\");\n\n        orders[_orderID] = Order({\n            state: OrderState.Open,\n            trader: trader,\n            confirmer: 0x0,\n            settlementID: _settlementID,\n            priority: orderbook.length + 1,\n            blockNumber: block.number,\n            matchedOrder: 0x0\n        });\n\n        orderbook.push(_orderID);\n    }\n\n    /// @notice Confirm an order match between orders. The confirmer must be a\n    /// registered Darknode and the orders must be in the Open state. A\n    /// malicious confirmation by a Darknode will result in a bond slash of the\n    /// Darknode.\n    ///\n    /// @param _orderID The hash of the order.\n    /// @param _matchedOrderID The hashes of the matching order.\n    function confirmOrder(bytes32 _orderID, bytes32 _matchedOrderID) external onlyDarknode(msg.sender) {\n        require(orders[_orderID].state == OrderState.Open, \"invalid order status\");\n        require(orders[_matchedOrderID].state == OrderState.Open, \"invalid order status\");\n\n        orders[_orderID].state = OrderState.Confirmed;\n        orders[_orderID].confirmer = msg.sender;\n        orders[_orderID].matchedOrder = _matchedOrderID;\n        orders[_orderID].blockNumber = block.number;\n\n        orders[_matchedOrderID].state = OrderState.Confirmed;\n        orders[_matchedOrderID].confirmer = msg.sender;\n        orders[_matchedOrderID].matchedOrder = _orderID;\n        orders[_matchedOrderID].blockNumber = block.number;\n    }\n\n    /// @notice Cancel an open order in the orderbook. An order can be cancelled\n    /// by the trader who opened the order, or by the broker verifier contract.\n    /// This allows the settlement layer to implement their own logic for\n    /// cancelling orders without trader interaction (e.g. to ban a trader from\n    /// a specific darkpool, or to use multiple order-matching platforms)\n    ///\n    /// @param _orderID The hash of the order.\n    function cancelOrder(bytes32 _orderID) external {\n        require(orders[_orderID].state == OrderState.Open, \"invalid order state\");\n\n        // Require the msg.sender to be the trader or the broker verifier\n        address brokerVerifier = address(settlementRegistry.brokerVerifierContract(orders[_orderID].settlementID));\n        require(msg.sender == orders[_orderID].trader || msg.sender == brokerVerifier, \"not authorized\");\n\n        orders[_orderID].state = OrderState.Canceled;\n        orders[_orderID].blockNumber = block.number;\n    }\n\n    /// @notice returns status of the given orderID.\n    function orderState(bytes32 _orderID) external view returns (OrderState) {\n        return orders[_orderID].state;\n    }\n\n    /// @notice returns a list of matched orders to the given orderID.\n    function orderMatch(bytes32 _orderID) external view returns (bytes32) {\n        return orders[_orderID].matchedOrder;\n    }\n\n    /// @notice returns the priority of the given orderID.\n    /// The priority is the index of the order in the orderbook.\n    function orderPriority(bytes32 _orderID) external view returns (uint256) {\n        return orders[_orderID].priority;\n    }\n\n    /// @notice returns the trader of the given orderID.\n    /// Trader is the one who signs the message and does the actual trading.\n    function orderTrader(bytes32 _orderID) external view returns (address) {\n        return orders[_orderID].trader;\n    }\n\n    /// @notice returns the darknode address which confirms the given orderID.\n    function orderConfirmer(bytes32 _orderID) external view returns (address) {\n        return orders[_orderID].confirmer;\n    }\n\n    /// @notice returns the block number when the order being last modified.\n    function orderBlockNumber(bytes32 _orderID) external view returns (uint256) {\n        return orders[_orderID].blockNumber;\n    }\n\n    /// @notice returns the block depth of the orderId\n    function orderDepth(bytes32 _orderID) external view returns (uint256) {\n        if (orders[_orderID].blockNumber == 0) {\n            return 0;\n        }\n        return (block.number - orders[_orderID].blockNumber);\n    }\n\n    /// @notice returns the number of orders in the orderbook\n    function ordersCount() external view returns (uint256) {\n        return orderbook.length;\n    }\n\n    /// @notice returns order details of the orders starting from the offset.\n    function getOrders(uint256 _offset, uint256 _limit) external view returns (bytes32[], address[], uint8[]) {\n        if (_offset >= orderbook.length) {\n            return;\n        }\n\n        // If the provided limit is more than the number of orders after the offset,\n        // decrease the limit\n        uint256 limit = _limit;\n        if (_offset + limit > orderbook.length) {\n            limit = orderbook.length - _offset;\n        }\n\n        bytes32[] memory orderIDs = new bytes32[](limit);\n        address[] memory traderAddresses = new address[](limit);\n        uint8[] memory states = new uint8[](limit);\n\n        for (uint256 i = 0; i < limit; i++) {\n            bytes32 order = orderbook[i + _offset];\n            orderIDs[i] = order;\n            traderAddresses[i] = orders[order].trader;\n            states[i] = uint8(orders[order].state);\n        }\n\n        return (orderIDs, traderAddresses, states);\n    }\n}\n\n/// @notice A library for calculating and verifying order match details\nlibrary SettlementUtils {\n\n    struct OrderDetails {\n        uint64 settlementID;\n        uint64 tokens;\n        uint256 price;\n        uint256 volume;\n        uint256 minimumVolume;\n    }\n\n    /// @notice Calculates the ID of the order.\n    /// @param details Order details that are not required for settlement\n    ///        execution. They are combined as a single byte array.\n    /// @param order The order details required for settlement execution.\n    function hashOrder(bytes details, OrderDetails memory order) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encodePacked(\n                details,\n                order.settlementID,\n                order.tokens,\n                order.price,\n                order.volume,\n                order.minimumVolume\n            )\n        );\n    }\n\n    /// @notice Verifies that two orders match when considering the tokens,\n    /// price, volumes / minimum volumes and settlement IDs. verifyMatchDetails is used\n    /// my the DarknodeSlasher to verify challenges. Settlement layers may also\n    /// use this function.\n    /// @dev When verifying two orders for settlement, you should also:\n    ///   1) verify the orders have been confirmed together\n    ///   2) verify the orders' traders are distinct\n    /// @param _buy The buy order details.\n    /// @param _sell The sell order details.\n    function verifyMatchDetails(OrderDetails memory _buy, OrderDetails memory _sell) internal pure returns (bool) {\n\n        // Buy and sell tokens should match\n        if (!verifyTokens(_buy.tokens, _sell.tokens)) {\n            return false;\n        }\n\n        // Buy price should be greater than sell price\n        if (_buy.price < _sell.price) {\n            return false;\n        }\n\n        // // Buy volume should be greater than sell minimum volume\n        if (_buy.volume < _sell.minimumVolume) {\n            return false;\n        }\n\n        // Sell volume should be greater than buy minimum volume\n        if (_sell.volume < _buy.minimumVolume) {\n            return false;\n        }\n\n        // Require that the orders were submitted to the same settlement layer\n        if (_buy.settlementID != _sell.settlementID) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /// @notice Verifies that two token requirements can be matched and that the\n    /// tokens are formatted correctly.\n    /// @param _buyTokens The buy token details.\n    /// @param _sellToken The sell token details.\n    function verifyTokens(uint64 _buyTokens, uint64 _sellToken) internal pure returns (bool) {\n        return ((\n                uint32(_buyTokens) == uint32(_sellToken >> 32)) && (\n                uint32(_sellToken) == uint32(_buyTokens >> 32)) && (\n                uint32(_buyTokens >> 32) <= uint32(_buyTokens))\n        );\n    }\n}\n\n/// @notice RenExTokens is a registry of tokens that can be traded on RenEx.\ncontract RenExTokens is Ownable {\n    string public VERSION; // Passed in as a constructor parameter.\n\n    struct TokenDetails {\n        address addr;\n        uint8 decimals;\n        bool registered;\n    }\n\n    // Storage\n    mapping(uint32 => TokenDetails) public tokens;\n    mapping(uint32 => bool) private detailsSubmitted;\n\n    // Events\n    event LogTokenRegistered(uint32 tokenCode, address tokenAddress, uint8 tokenDecimals);\n    event LogTokenDeregistered(uint32 tokenCode);\n\n    /// @notice The contract constructor.\n    ///\n    /// @param _VERSION A string defining the contract version.\n    constructor(string _VERSION) public {\n        VERSION = _VERSION;\n    }\n\n    /// @notice Allows the owner to register and the details for a token.\n    /// Once details have been submitted, they cannot be overwritten.\n    /// To re-register the same token with different details (e.g. if the address\n    /// has changed), a different token identifier should be used and the\n    /// previous token identifier should be deregistered.\n    /// If a token is not Ethereum-based, the address will be set to 0x0.\n    ///\n    /// @param _tokenCode A unique 32-bit token identifier.\n    /// @param _tokenAddress The address of the token.\n    /// @param _tokenDecimals The decimals to use for the token.\n    function registerToken(uint32 _tokenCode, address _tokenAddress, uint8 _tokenDecimals) public onlyOwner {\n        require(!tokens[_tokenCode].registered, \"already registered\");\n\n        // If a token is being re-registered, the same details must be provided.\n        if (detailsSubmitted[_tokenCode]) {\n            require(tokens[_tokenCode].addr == _tokenAddress, \"different address\");\n            require(tokens[_tokenCode].decimals == _tokenDecimals, \"different decimals\");\n        } else {\n            detailsSubmitted[_tokenCode] = true;\n        }\n\n        tokens[_tokenCode] = TokenDetails({\n            addr: _tokenAddress,\n            decimals: _tokenDecimals,\n            registered: true\n        });\n\n        emit LogTokenRegistered(_tokenCode, _tokenAddress, _tokenDecimals);\n    }\n\n    /// @notice Sets a token as being deregistered. The details are still stored\n    /// to prevent the token from being re-registered with different details.\n    ///\n    /// @param _tokenCode The unique 32-bit token identifier.\n    function deregisterToken(uint32 _tokenCode) external onlyOwner {\n        require(tokens[_tokenCode].registered, \"not registered\");\n\n        tokens[_tokenCode].registered = false;\n\n        emit LogTokenDeregistered(_tokenCode);\n    }\n}\n\n/// @notice RenExSettlement implements the Settlement interface. It implements\n/// the on-chain settlement for the RenEx settlement layer, and the fee payment\n/// for the RenExAtomic settlement layer.\ncontract RenExSettlement is Ownable {\n    using SafeMath for uint256;\n\n    string public VERSION; // Passed in as a constructor parameter.\n\n    // This contract handles the settlements with ID 1 and 2.\n    uint32 constant public RENEX_SETTLEMENT_ID = 1;\n    uint32 constant public RENEX_ATOMIC_SETTLEMENT_ID = 2;\n\n    // Fees in RenEx are 0.2%. To represent this as integers, it is broken into\n    // a numerator and denominator.\n    uint256 constant public DARKNODE_FEES_NUMERATOR = 2;\n    uint256 constant public DARKNODE_FEES_DENOMINATOR = 1000;\n\n    // Constants used in the price / volume inputs.\n    int16 constant private PRICE_OFFSET = 12;\n    int16 constant private VOLUME_OFFSET = 12;\n\n    // Constructor parameters, updatable by the owner\n    Orderbook public orderbookContract;\n    RenExTokens public renExTokensContract;\n    RenExBalances public renExBalancesContract;\n    address public slasherAddress;\n    uint256 public submissionGasPriceLimit;\n\n    enum OrderStatus {None, Submitted, Settled, Slashed}\n\n    struct TokenPair {\n        RenExTokens.TokenDetails priorityToken;\n        RenExTokens.TokenDetails secondaryToken;\n    }\n\n    // A uint256 tuple representing a value and an associated fee\n    struct ValueWithFees {\n        uint256 value;\n        uint256 fees;\n    }\n\n    // A uint256 tuple representing a fraction\n    struct Fraction {\n        uint256 numerator;\n        uint256 denominator;\n    }\n\n    // We use left and right because the tokens do not always represent the\n    // priority and secondary tokens.\n    struct SettlementDetails {\n        uint256 leftVolume;\n        uint256 rightVolume;\n        uint256 leftTokenFee;\n        uint256 rightTokenFee;\n        address leftTokenAddress;\n        address rightTokenAddress;\n    }\n\n    // Events\n    event LogOrderbookUpdated(Orderbook previousOrderbook, Orderbook nextOrderbook);\n    event LogRenExTokensUpdated(RenExTokens previousRenExTokens, RenExTokens nextRenExTokens);\n    event LogRenExBalancesUpdated(RenExBalances previousRenExBalances, RenExBalances nextRenExBalances);\n    event LogSubmissionGasPriceLimitUpdated(uint256 previousSubmissionGasPriceLimit, uint256 nextSubmissionGasPriceLimit);\n    event LogSlasherUpdated(address previousSlasher, address nextSlasher);\n\n    // Order Storage\n    mapping(bytes32 => SettlementUtils.OrderDetails) public orderDetails;\n    mapping(bytes32 => address) public orderSubmitter;\n    mapping(bytes32 => OrderStatus) public orderStatus;\n\n    // Match storage (match details are indexed by [buyID][sellID])\n    mapping(bytes32 => mapping(bytes32 => uint256)) public matchTimestamp;\n\n    /// @notice Prevents a function from being called with a gas price higher\n    /// than the specified limit.\n    ///\n    /// @param _gasPriceLimit The gas price upper-limit in Wei.\n    modifier withGasPriceLimit(uint256 _gasPriceLimit) {\n        require(tx.gasprice <= _gasPriceLimit, \"gas price too high\");\n        _;\n    }\n\n    /// @notice Restricts a function to only being called by the slasher\n    /// address.\n    modifier onlySlasher() {\n        require(msg.sender == slasherAddress, \"unauthorized\");\n        _;\n    }\n\n    /// @notice The contract constructor.\n    ///\n    /// @param _VERSION A string defining the contract version.\n    /// @param _orderbookContract The address of the Orderbook contract.\n    /// @param _renExBalancesContract The address of the RenExBalances\n    ///        contract.\n    /// @param _renExTokensContract The address of the RenExTokens contract.\n    constructor(\n        string _VERSION,\n        Orderbook _orderbookContract,\n        RenExTokens _renExTokensContract,\n        RenExBalances _renExBalancesContract,\n        address _slasherAddress,\n        uint256 _submissionGasPriceLimit\n    ) public {\n        VERSION = _VERSION;\n        orderbookContract = _orderbookContract;\n        renExTokensContract = _renExTokensContract;\n        renExBalancesContract = _renExBalancesContract;\n        slasherAddress = _slasherAddress;\n        submissionGasPriceLimit = _submissionGasPriceLimit;\n    }\n\n    /// @notice The owner of the contract can update the Orderbook address.\n    /// @param _newOrderbookContract The address of the new Orderbook contract.\n    function updateOrderbook(Orderbook _newOrderbookContract) external onlyOwner {\n        emit LogOrderbookUpdated(orderbookContract, _newOrderbookContract);\n        orderbookContract = _newOrderbookContract;\n    }\n\n    /// @notice The owner of the contract can update the RenExTokens address.\n    /// @param _newRenExTokensContract The address of the new RenExTokens\n    ///       contract.\n    function updateRenExTokens(RenExTokens _newRenExTokensContract) external onlyOwner {\n        emit LogRenExTokensUpdated(renExTokensContract, _newRenExTokensContract);\n        renExTokensContract = _newRenExTokensContract;\n    }\n    \n    /// @notice The owner of the contract can update the RenExBalances address.\n    /// @param _newRenExBalancesContract The address of the new RenExBalances\n    ///       contract.\n    function updateRenExBalances(RenExBalances _newRenExBalancesContract) external onlyOwner {\n        emit LogRenExBalancesUpdated(renExBalancesContract, _newRenExBalancesContract);\n        renExBalancesContract = _newRenExBalancesContract;\n    }\n\n    /// @notice The owner of the contract can update the order submission gas\n    /// price limit.\n    /// @param _newSubmissionGasPriceLimit The new gas price limit.\n    function updateSubmissionGasPriceLimit(uint256 _newSubmissionGasPriceLimit) external onlyOwner {\n        emit LogSubmissionGasPriceLimitUpdated(submissionGasPriceLimit, _newSubmissionGasPriceLimit);\n        submissionGasPriceLimit = _newSubmissionGasPriceLimit;\n    }\n\n    /// @notice The owner of the contract can update the slasher address.\n    /// @param _newSlasherAddress The new slasher address.\n    function updateSlasher(address _newSlasherAddress) external onlyOwner {\n        emit LogSlasherUpdated(slasherAddress, _newSlasherAddress);\n        slasherAddress = _newSlasherAddress;\n    }\n\n    /// @notice Stores the details of an order.\n    ///\n    /// @param _prefix The miscellaneous details of the order required for\n    ///        calculating the order id.\n    /// @param _settlementID The settlement identifier.\n    /// @param _tokens The encoding of the token pair (buy token is encoded as\n    ///        the first 32 bytes and sell token is encoded as the last 32\n    ///        bytes).\n    /// @param _price The price of the order. Interpreted as the cost for 1\n    ///        standard unit of the non-priority token, in 1e12 (i.e.\n    ///        PRICE_OFFSET) units of the priority token).\n    /// @param _volume The volume of the order. Interpreted as the maximum\n    ///        number of 1e-12 (i.e. VOLUME_OFFSET) units of the non-priority\n    ///        token that can be traded by this order.\n    /// @param _minimumVolume The minimum volume the trader is willing to\n    ///        accept. Encoded the same as the volume.\n    function submitOrder(\n        bytes _prefix,\n        uint64 _settlementID,\n        uint64 _tokens,\n        uint256 _price,\n        uint256 _volume,\n        uint256 _minimumVolume\n    ) external withGasPriceLimit(submissionGasPriceLimit) {\n\n        SettlementUtils.OrderDetails memory order = SettlementUtils.OrderDetails({\n            settlementID: _settlementID,\n            tokens: _tokens,\n            price: _price,\n            volume: _volume,\n            minimumVolume: _minimumVolume\n        });\n        bytes32 orderID = SettlementUtils.hashOrder(_prefix, order);\n\n        require(orderStatus[orderID] == OrderStatus.None, \"order already submitted\");\n        require(orderbookContract.orderState(orderID) == Orderbook.OrderState.Confirmed, \"unconfirmed order\");\n\n        orderSubmitter[orderID] = msg.sender;\n        orderStatus[orderID] = OrderStatus.Submitted;\n        orderDetails[orderID] = order;\n    }\n\n    /// @notice Settles two orders that are matched. `submitOrder` must have been\n    /// called for each order before this function is called.\n    ///\n    /// @param _buyID The 32 byte ID of the buy order.\n    /// @param _sellID The 32 byte ID of the sell order.\n    function settle(bytes32 _buyID, bytes32 _sellID) external {\n        require(orderStatus[_buyID] == OrderStatus.Submitted, \"invalid buy status\");\n        require(orderStatus[_sellID] == OrderStatus.Submitted, \"invalid sell status\");\n\n        // Check the settlement ID (only have to check for one, since\n        // `verifyMatchDetails` checks that they are the same)\n        require(\n            orderDetails[_buyID].settlementID == RENEX_ATOMIC_SETTLEMENT_ID ||\n            orderDetails[_buyID].settlementID == RENEX_SETTLEMENT_ID,\n            \"invalid settlement id\"\n        );\n\n        // Verify that the two order details are compatible.\n        require(SettlementUtils.verifyMatchDetails(orderDetails[_buyID], orderDetails[_sellID]), \"incompatible orders\");\n\n        // Verify that the two orders have been confirmed to one another.\n        require(orderbookContract.orderMatch(_buyID) == _sellID, \"unconfirmed orders\");\n\n        // Retrieve token details.\n        TokenPair memory tokens = getTokenDetails(orderDetails[_buyID].tokens);\n\n        // Require that the tokens have been registered.\n        require(tokens.priorityToken.registered, \"unregistered priority token\");\n        require(tokens.secondaryToken.registered, \"unregistered secondary token\");\n\n        address buyer = orderbookContract.orderTrader(_buyID);\n        address seller = orderbookContract.orderTrader(_sellID);\n\n        require(buyer != seller, \"orders from same trader\");\n\n        execute(_buyID, _sellID, buyer, seller, tokens);\n\n        /* solium-disable-next-line security/no-block-members */\n        matchTimestamp[_buyID][_sellID] = now;\n\n        // Store that the orders have been settled.\n        orderStatus[_buyID] = OrderStatus.Settled;\n        orderStatus[_sellID] = OrderStatus.Settled;\n    }\n\n    /// @notice Slashes the bond of a guilty trader. This is called when an\n    /// atomic swap is not executed successfully.\n    /// To open an atomic order, a trader must have a balance equivalent to\n    /// 0.6% of the trade in the Ethereum-based token. 0.2% is always paid in\n    /// darknode fees when the order is matched. If the remaining amount is\n    /// is slashed, it is distributed as follows:\n    ///   1) 0.2% goes to the other trader, covering their fee\n    ///   2) 0.2% goes to the slasher address\n    /// Only one order in a match can be slashed.\n    ///\n    /// @param _guiltyOrderID The 32 byte ID of the order of the guilty trader.\n    function slash(bytes32 _guiltyOrderID) external onlySlasher {\n        require(orderDetails[_guiltyOrderID].settlementID == RENEX_ATOMIC_SETTLEMENT_ID, \"slashing non-atomic trade\");\n\n        bytes32 innocentOrderID = orderbookContract.orderMatch(_guiltyOrderID);\n\n        require(orderStatus[_guiltyOrderID] == OrderStatus.Settled, \"invalid order status\");\n        require(orderStatus[innocentOrderID] == OrderStatus.Settled, \"invalid order status\");\n        orderStatus[_guiltyOrderID] = OrderStatus.Slashed;\n\n        (bytes32 buyID, bytes32 sellID) = isBuyOrder(_guiltyOrderID) ?\n            (_guiltyOrderID, innocentOrderID) : (innocentOrderID, _guiltyOrderID);\n\n        TokenPair memory tokens = getTokenDetails(orderDetails[buyID].tokens);\n\n        SettlementDetails memory settlementDetails = calculateAtomicFees(buyID, sellID, tokens);\n\n        // Transfer the fee amount to the other trader\n        renExBalancesContract.transferBalanceWithFee(\n            orderbookContract.orderTrader(_guiltyOrderID),\n            orderbookContract.orderTrader(innocentOrderID),\n            settlementDetails.leftTokenAddress,\n            settlementDetails.leftTokenFee,\n            0,\n            0x0\n        );\n\n        // Transfer the fee amount to the slasher\n        renExBalancesContract.transferBalanceWithFee(\n            orderbookContract.orderTrader(_guiltyOrderID),\n            slasherAddress,\n            settlementDetails.leftTokenAddress,\n            settlementDetails.leftTokenFee,\n            0,\n            0x0\n        );\n    }\n\n    /// @notice Retrieves the settlement details of an order.\n    /// For atomic swaps, it returns the full volumes, not the settled fees.\n    ///\n    /// @param _orderID The order to lookup the details of. Can be the ID of a\n    ///        buy or a sell order.\n    /// @return [\n    ///     a boolean representing whether or not the order has been settled,\n    ///     a boolean representing whether or not the order is a buy\n    ///     the 32-byte order ID of the matched order\n    ///     the volume of the priority token,\n    ///     the volume of the secondary token,\n    ///     the fee paid in the priority token,\n    ///     the fee paid in the secondary token,\n    ///     the token code of the priority token,\n    ///     the token code of the secondary token\n    /// ]\n    function getMatchDetails(bytes32 _orderID)\n    external view returns (\n        bool settled,\n        bool orderIsBuy,\n        bytes32 matchedID,\n        uint256 priorityVolume,\n        uint256 secondaryVolume,\n        uint256 priorityFee,\n        uint256 secondaryFee,\n        uint32 priorityToken,\n        uint32 secondaryToken\n    ) {\n        matchedID = orderbookContract.orderMatch(_orderID);\n\n        orderIsBuy = isBuyOrder(_orderID);\n\n        (bytes32 buyID, bytes32 sellID) = orderIsBuy ?\n            (_orderID, matchedID) : (matchedID, _orderID);\n\n        SettlementDetails memory settlementDetails = calculateSettlementDetails(\n            buyID,\n            sellID,\n            getTokenDetails(orderDetails[buyID].tokens)\n        );\n\n        return (\n            orderStatus[_orderID] == OrderStatus.Settled || orderStatus[_orderID] == OrderStatus.Slashed,\n            orderIsBuy,\n            matchedID,\n            settlementDetails.leftVolume,\n            settlementDetails.rightVolume,\n            settlementDetails.leftTokenFee,\n            settlementDetails.rightTokenFee,\n            uint32(orderDetails[buyID].tokens >> 32),\n            uint32(orderDetails[buyID].tokens)\n        );\n    }\n\n    /// @notice Exposes the hashOrder function for computing a hash of an\n    /// order's details. An order hash is used as its ID. See `submitOrder`\n    /// for the parameter descriptions.\n    ///\n    /// @return The 32-byte hash of the order.\n    function hashOrder(\n        bytes _prefix,\n        uint64 _settlementID,\n        uint64 _tokens,\n        uint256 _price,\n        uint256 _volume,\n        uint256 _minimumVolume\n    ) external pure returns (bytes32) {\n        return SettlementUtils.hashOrder(_prefix, SettlementUtils.OrderDetails({\n            settlementID: _settlementID,\n            tokens: _tokens,\n            price: _price,\n            volume: _volume,\n            minimumVolume: _minimumVolume\n        }));\n    }\n\n    /// @notice Called by `settle`, executes the settlement for a RenEx order\n    /// or distributes the fees for a RenExAtomic swap.\n    ///\n    /// @param _buyID The 32 byte ID of the buy order.\n    /// @param _sellID The 32 byte ID of the sell order.\n    /// @param _buyer The address of the buy trader.\n    /// @param _seller The address of the sell trader.\n    /// @param _tokens The details of the priority and secondary tokens.\n    function execute(\n        bytes32 _buyID,\n        bytes32 _sellID,\n        address _buyer,\n        address _seller,\n        TokenPair memory _tokens\n    ) private {\n        // Calculate the fees for atomic swaps, and the settlement details\n        // otherwise.\n        SettlementDetails memory settlementDetails = (orderDetails[_buyID].settlementID == RENEX_ATOMIC_SETTLEMENT_ID) ?\n            settlementDetails = calculateAtomicFees(_buyID, _sellID, _tokens) :\n            settlementDetails = calculateSettlementDetails(_buyID, _sellID, _tokens);\n\n        // Transfer priority token value\n        renExBalancesContract.transferBalanceWithFee(\n            _buyer,\n            _seller,\n            settlementDetails.leftTokenAddress,\n            settlementDetails.leftVolume,\n            settlementDetails.leftTokenFee,\n            orderSubmitter[_buyID]\n        );\n\n        // Transfer secondary token value\n        renExBalancesContract.transferBalanceWithFee(\n            _seller,\n            _buyer,\n            settlementDetails.rightTokenAddress,\n            settlementDetails.rightVolume,\n            settlementDetails.rightTokenFee,\n            orderSubmitter[_sellID]\n        );\n    }\n\n    /// @notice Calculates the details required to execute two matched orders.\n    ///\n    /// @param _buyID The 32 byte ID of the buy order.\n    /// @param _sellID The 32 byte ID of the sell order.\n    /// @param _tokens The details of the priority and secondary tokens.\n    /// @return A struct containing the settlement details.\n    function calculateSettlementDetails(\n        bytes32 _buyID,\n        bytes32 _sellID,\n        TokenPair memory _tokens\n    ) private view returns (SettlementDetails memory) {\n\n        // Calculate the mid-price (using numerator and denominator to not loose\n        // precision).\n        Fraction memory midPrice = Fraction(orderDetails[_buyID].price + orderDetails[_sellID].price, 2);\n\n        // Calculate the lower of the two max volumes of each trader\n        uint256 commonVolume = Math.min256(orderDetails[_buyID].volume, orderDetails[_sellID].volume);\n\n        uint256 priorityTokenVolume = joinFraction(\n            commonVolume.mul(midPrice.numerator),\n            midPrice.denominator,\n            int16(_tokens.priorityToken.decimals) - PRICE_OFFSET - VOLUME_OFFSET\n        );\n        uint256 secondaryTokenVolume = joinFraction(\n            commonVolume,\n            1,\n            int16(_tokens.secondaryToken.decimals) - VOLUME_OFFSET\n        );\n\n        // Calculate darknode fees\n        ValueWithFees memory priorityVwF = subtractDarknodeFee(priorityTokenVolume);\n        ValueWithFees memory secondaryVwF = subtractDarknodeFee(secondaryTokenVolume);\n\n        return SettlementDetails({\n            leftVolume: priorityVwF.value,\n            rightVolume: secondaryVwF.value,\n            leftTokenFee: priorityVwF.fees,\n            rightTokenFee: secondaryVwF.fees,\n            leftTokenAddress: _tokens.priorityToken.addr,\n            rightTokenAddress: _tokens.secondaryToken.addr\n        });\n    }\n\n    /// @notice Calculates the fees to be transferred for an atomic swap.\n    ///\n    /// @param _buyID The 32 byte ID of the buy order.\n    /// @param _sellID The 32 byte ID of the sell order.\n    /// @param _tokens The details of the priority and secondary tokens.\n    /// @return A struct containing the fee details.\n    function calculateAtomicFees(\n        bytes32 _buyID,\n        bytes32 _sellID,\n        TokenPair memory _tokens\n    ) private view returns (SettlementDetails memory) {\n\n        // Calculate the mid-price (using numerator and denominator to not loose\n        // precision).\n        Fraction memory midPrice = Fraction(orderDetails[_buyID].price + orderDetails[_sellID].price, 2);\n\n        // Calculate the lower of the two max volumes of each trader\n        uint256 commonVolume = Math.min256(orderDetails[_buyID].volume, orderDetails[_sellID].volume);\n\n        if (isEthereumBased(_tokens.secondaryToken.addr)) {\n            uint256 secondaryTokenVolume = joinFraction(\n                commonVolume,\n                1,\n                int16(_tokens.secondaryToken.decimals) - VOLUME_OFFSET\n            );\n\n            // Calculate darknode fees\n            ValueWithFees memory secondaryVwF = subtractDarknodeFee(secondaryTokenVolume);\n\n            return SettlementDetails({\n                leftVolume: 0,\n                rightVolume: 0,\n                leftTokenFee: secondaryVwF.fees,\n                rightTokenFee: secondaryVwF.fees,\n                leftTokenAddress: _tokens.secondaryToken.addr,\n                rightTokenAddress: _tokens.secondaryToken.addr\n            });\n        } else if (isEthereumBased(_tokens.priorityToken.addr)) {\n            uint256 priorityTokenVolume = joinFraction(\n                commonVolume.mul(midPrice.numerator),\n                midPrice.denominator,\n                int16(_tokens.priorityToken.decimals) - PRICE_OFFSET - VOLUME_OFFSET\n            );\n\n            // Calculate darknode fees\n            ValueWithFees memory priorityVwF = subtractDarknodeFee(priorityTokenVolume);\n\n            return SettlementDetails({\n                leftVolume: 0,\n                rightVolume: 0,\n                leftTokenFee: priorityVwF.fees,\n                rightTokenFee: priorityVwF.fees,\n                leftTokenAddress: _tokens.priorityToken.addr,\n                rightTokenAddress: _tokens.priorityToken.addr\n            });\n        } else {\n            // Currently, at least one token must be Ethereum-based.\n            // This will be implemented in the future.\n            revert(\"non-eth atomic swaps are not supported\");\n        }\n    }\n\n    /// @notice Order parity is set by the order tokens are listed. This returns\n    /// whether an order is a buy or a sell.\n    /// @return true if _orderID is a buy order.\n    function isBuyOrder(bytes32 _orderID) private view returns (bool) {\n        uint64 tokens = orderDetails[_orderID].tokens;\n        uint32 firstToken = uint32(tokens >> 32);\n        uint32 secondaryToken = uint32(tokens);\n        return (firstToken < secondaryToken);\n    }\n\n    /// @return (value - fee, fee) where fee is 0.2% of value\n    function subtractDarknodeFee(uint256 _value) private pure returns (ValueWithFees memory) {\n        uint256 newValue = (_value * (DARKNODE_FEES_DENOMINATOR - DARKNODE_FEES_NUMERATOR)) / DARKNODE_FEES_DENOMINATOR;\n        return ValueWithFees(newValue, _value - newValue);\n    }\n\n    /// @notice Gets the order details of the priority and secondary token from\n    /// the RenExTokens contract and returns them as a single struct.\n    ///\n    /// @param _tokens The 64-bit combined token identifiers.\n    /// @return A TokenPair struct containing two TokenDetails structs.\n    function getTokenDetails(uint64 _tokens) private view returns (TokenPair memory) {\n        (\n            address priorityAddress,\n            uint8 priorityDecimals,\n            bool priorityRegistered\n        ) = renExTokensContract.tokens(uint32(_tokens >> 32));\n\n        (\n            address secondaryAddress,\n            uint8 secondaryDecimals,\n            bool secondaryRegistered\n        ) = renExTokensContract.tokens(uint32(_tokens));\n\n        return TokenPair({\n            priorityToken: RenExTokens.TokenDetails(priorityAddress, priorityDecimals, priorityRegistered),\n            secondaryToken: RenExTokens.TokenDetails(secondaryAddress, secondaryDecimals, secondaryRegistered)\n        });\n    }\n\n    /// @return true if _tokenAddress is 0x0, representing a token that is not\n    /// on Ethereum\n    function isEthereumBased(address _tokenAddress) private pure returns (bool) {\n        return (_tokenAddress != address(0x0));\n    }\n\n    /// @notice Computes (_numerator / _denominator) * 10 ** _scale\n    function joinFraction(uint256 _numerator, uint256 _denominator, int16 _scale) private pure returns (uint256) {\n        if (_scale >= 0) {\n            // Check that (10**_scale) doesn't overflow\n            assert(_scale <= 77); // log10(2**256) = 77.06\n            return _numerator.mul(10 ** uint256(_scale)) / _denominator;\n        } else {\n            /// @dev If _scale is less than -77, 10**-_scale would overflow.\n            // For now, -_scale > -24 (when a token has 0 decimals and\n            // VOLUME_OFFSET and PRICE_OFFSET are each 12). It is unlikely these\n            // will be increased to add to more than 77.\n            // assert((-_scale) <= 77); // log10(2**256) = 77.06\n            return (_numerator / _denominator) / 10 ** uint256(-_scale);\n        }\n    }\n}\n\n/// @notice RenExBrokerVerifier implements the BrokerVerifier contract,\n/// verifying broker signatures for order opening and fund withdrawal.\ncontract RenExBrokerVerifier is Ownable {\n    string public VERSION; // Passed in as a constructor parameter.\n\n    // Events\n    event LogBalancesContractUpdated(address previousBalancesContract, address nextBalancesContract);\n    event LogBrokerRegistered(address broker);\n    event LogBrokerDeregistered(address broker);\n\n    // Storage\n    mapping(address => bool) public brokers;\n    mapping(address => uint256) public traderNonces;\n\n    address public balancesContract;\n\n    modifier onlyBalancesContract() {\n        require(msg.sender == balancesContract, \"not authorized\");\n        _;\n    }\n\n    /// @notice The contract constructor.\n    ///\n    /// @param _VERSION A string defining the contract version.\n    constructor(string _VERSION) public {\n        VERSION = _VERSION;\n    }\n\n    /// @notice Allows the owner of the contract to update the address of the\n    /// RenExBalances contract.\n    ///\n    /// @param _balancesContract The address of the new balances contract\n    function updateBalancesContract(address _balancesContract) external onlyOwner {\n        emit LogBalancesContractUpdated(balancesContract, _balancesContract);\n\n        balancesContract = _balancesContract;\n    }\n\n    /// @notice Approved an address to sign order-opening and withdrawals.\n    /// @param _broker The address of the broker.\n    function registerBroker(address _broker) external onlyOwner {\n        require(!brokers[_broker], \"already registered\");\n        brokers[_broker] = true;\n        emit LogBrokerRegistered(_broker);\n    }\n\n    /// @notice Reverts the a broker's registration.\n    /// @param _broker The address of the broker.\n    function deregisterBroker(address _broker) external onlyOwner {\n        require(brokers[_broker], \"not registered\");\n        brokers[_broker] = false;\n        emit LogBrokerDeregistered(_broker);\n    }\n\n    /// @notice Verifies a broker's signature for an order opening.\n    /// The data signed by the broker is a prefixed message and the order ID.\n    ///\n    /// @param _trader The trader requesting the withdrawal.\n    /// @param _signature The 65-byte signature from the broker.\n    /// @param _orderID The 32-byte order ID.\n    /// @return True if the signature is valid, false otherwise.\n    function verifyOpenSignature(\n        address _trader,\n        bytes _signature,\n        bytes32 _orderID\n    ) external view returns (bool) {\n        bytes memory data = abi.encodePacked(\"Republic Protocol: open: \", _trader, _orderID);\n        address signer = Utils.addr(data, _signature);\n        return (brokers[signer] == true);\n    }\n\n    /// @notice Verifies a broker's signature for a trader withdrawal.\n    /// The data signed by the broker is a prefixed message, the trader address\n    /// and a 256-bit trader nonce, which is incremented every time a valid\n    /// signature is checked.\n    ///\n    /// @param _trader The trader requesting the withdrawal.\n    /// @param _signature 65-byte signature from the broker.\n    /// @return True if the signature is valid, false otherwise.\n    function verifyWithdrawSignature(\n        address _trader,\n        bytes _signature\n    ) external onlyBalancesContract returns (bool) {\n        bytes memory data = abi.encodePacked(\"Republic Protocol: withdraw: \", _trader, traderNonces[_trader]);\n        address signer = Utils.addr(data, _signature);\n        if (brokers[signer]) {\n            traderNonces[_trader] += 1;\n            return true;\n        }\n        return false;\n    }\n}\n\n/// @notice RenExBalances is responsible for holding RenEx trader funds.\ncontract RenExBalances is Ownable {\n    using SafeMath for uint256;\n    using CompatibleERC20Functions for CompatibleERC20;\n\n    string public VERSION; // Passed in as a constructor parameter.\n\n    RenExSettlement public settlementContract;\n    RenExBrokerVerifier public brokerVerifierContract;\n    DarknodeRewardVault public rewardVaultContract;\n\n    /// @dev Should match the address in the DarknodeRewardVault\n    address constant public ETHEREUM = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n    \n    // Delay between a trader calling `withdrawSignal` and being able to call\n    // `withdraw` without a broker signature.\n    uint256 constant public SIGNAL_DELAY = 48 hours;\n\n    // Events\n    event LogBalanceDecreased(address trader, ERC20 token, uint256 value);\n    event LogBalanceIncreased(address trader, ERC20 token, uint256 value);\n    event LogRenExSettlementContractUpdated(address previousRenExSettlementContract, address newRenExSettlementContract);\n    event LogRewardVaultContractUpdated(address previousRewardVaultContract, address newRewardVaultContract);\n    event LogBrokerVerifierContractUpdated(address previousBrokerVerifierContract, address newBrokerVerifierContract);\n\n    // Storage\n    mapping(address => mapping(address => uint256)) public traderBalances;\n    mapping(address => mapping(address => uint256)) public traderWithdrawalSignals;\n\n    /// @notice The contract constructor.\n    ///\n    /// @param _VERSION A string defining the contract version.\n    /// @param _rewardVaultContract The address of the RewardVault contract.\n    constructor(\n        string _VERSION,\n        DarknodeRewardVault _rewardVaultContract,\n        RenExBrokerVerifier _brokerVerifierContract\n    ) public {\n        VERSION = _VERSION;\n        rewardVaultContract = _rewardVaultContract;\n        brokerVerifierContract = _brokerVerifierContract;\n    }\n\n    /// @notice Restricts a function to only being called by the RenExSettlement\n    /// contract.\n    modifier onlyRenExSettlementContract() {\n        require(msg.sender == address(settlementContract), \"not authorized\");\n        _;\n    }\n\n    /// @notice Restricts trader withdrawing to be called if a signature from a\n    /// RenEx broker is provided, or if a certain amount of time has passed\n    /// since a trader has called `signalBackupWithdraw`.\n    /// @dev If the trader is withdrawing after calling `signalBackupWithdraw`,\n    /// this will reset the time to zero, writing to storage.\n    modifier withBrokerSignatureOrSignal(address _token, bytes _signature) {\n        address trader = msg.sender;\n\n        // If a signature has been provided, verify it - otherwise, verify that\n        // the user has signalled the withdraw\n        if (_signature.length > 0) {\n            require (brokerVerifierContract.verifyWithdrawSignature(trader, _signature), \"invalid signature\");\n        } else  {\n            require(traderWithdrawalSignals[trader][_token] != 0, \"not signalled\");\n            /* solium-disable-next-line security/no-block-members */\n            require((now - traderWithdrawalSignals[trader][_token]) > SIGNAL_DELAY, \"signal time remaining\");\n            traderWithdrawalSignals[trader][_token] = 0;\n        }\n        _;\n    }\n\n    /// @notice Allows the owner of the contract to update the address of the\n    /// RenExSettlement contract.\n    ///\n    /// @param _newSettlementContract the address of the new settlement contract\n    function updateRenExSettlementContract(RenExSettlement _newSettlementContract) external onlyOwner {\n        emit LogRenExSettlementContractUpdated(settlementContract, _newSettlementContract);\n        settlementContract = _newSettlementContract;\n    }\n\n    /// @notice Allows the owner of the contract to update the address of the\n    /// DarknodeRewardVault contract.\n    ///\n    /// @param _newRewardVaultContract the address of the new reward vault contract\n    function updateRewardVaultContract(DarknodeRewardVault _newRewardVaultContract) external onlyOwner {\n        emit LogRewardVaultContractUpdated(rewardVaultContract, _newRewardVaultContract);\n        rewardVaultContract = _newRewardVaultContract;\n    }\n\n    /// @notice Allows the owner of the contract to update the address of the\n    /// RenExBrokerVerifier contract.\n    ///\n    /// @param _newBrokerVerifierContract the address of the new broker verifier contract\n    function updateBrokerVerifierContract(RenExBrokerVerifier _newBrokerVerifierContract) external onlyOwner {\n        emit LogBrokerVerifierContractUpdated(brokerVerifierContract, _newBrokerVerifierContract);\n        brokerVerifierContract = _newBrokerVerifierContract;\n    }\n\n    /// @notice Transfer a token value from one trader to another, transferring\n    /// a fee to the RewardVault. Can only be called by the RenExSettlement\n    /// contract.\n    ///\n    /// @param _traderFrom The address of the trader to decrement the balance of.\n    /// @param _traderTo The address of the trader to increment the balance of.\n    /// @param _token The token's address.\n    /// @param _value The number of tokens to decrement the balance by (in the\n    ///        token's smallest unit).\n    /// @param _fee The fee amount to forward on to the RewardVault.\n    /// @param _feePayee The recipient of the fee.\n    function transferBalanceWithFee(address _traderFrom, address _traderTo, address _token, uint256 _value, uint256 _fee, address _feePayee)\n    external onlyRenExSettlementContract {\n        require(traderBalances[_traderFrom][_token] >= _fee, \"insufficient funds for fee\");\n\n        if (address(_token) == ETHEREUM) {\n            rewardVaultContract.deposit.value(_fee)(_feePayee, ERC20(_token), _fee);\n        } else {\n            CompatibleERC20(_token).safeApprove(rewardVaultContract, _fee);\n            rewardVaultContract.deposit(_feePayee, ERC20(_token), _fee);\n        }\n        privateDecrementBalance(_traderFrom, ERC20(_token), _value + _fee);\n        if (_value > 0) {\n            privateIncrementBalance(_traderTo, ERC20(_token), _value);\n        }\n    }\n\n    /// @notice Deposits ETH or an ERC20 token into the contract.\n    ///\n    /// @param _token The token's address (must be a registered token).\n    /// @param _value The amount to deposit in the token's smallest unit.\n    function deposit(ERC20 _token, uint256 _value) external payable {\n        address trader = msg.sender;\n\n        uint256 receivedValue = _value;\n        if (address(_token) == ETHEREUM) {\n            require(msg.value == _value, \"mismatched value parameter and tx value\");\n        } else {\n            require(msg.value == 0, \"unexpected ether transfer\");\n            receivedValue = CompatibleERC20(_token).safeTransferFromWithFees(trader, this, _value);\n        }\n        privateIncrementBalance(trader, _token, receivedValue);\n    }\n\n    /// @notice Withdraws ETH or an ERC20 token from the contract. A broker\n    /// signature is required to guarantee that the trader has a sufficient\n    /// balance after accounting for open orders. As a trustless backup,\n    /// traders can withdraw 48 hours after calling `signalBackupWithdraw`.\n    ///\n    /// @param _token The token's address.\n    /// @param _value The amount to withdraw in the token's smallest unit.\n    /// @param _signature The broker signature\n    function withdraw(ERC20 _token, uint256 _value, bytes _signature) external withBrokerSignatureOrSignal(_token, _signature) {\n        address trader = msg.sender;\n\n        privateDecrementBalance(trader, _token, _value);\n        if (address(_token) == ETHEREUM) {\n            trader.transfer(_value);\n        } else {\n            CompatibleERC20(_token).safeTransfer(trader, _value);\n        }\n    }\n\n    /// @notice A trader can withdraw without needing a broker signature if they\n    /// first call `signalBackupWithdraw` for the token they want to withdraw.\n    /// The trader can only withdraw the particular token once for each call to\n    /// this function. Traders can signal the intent to withdraw multiple\n    /// tokens.\n    /// Once this function is called, brokers will not sign order-opens for the\n    /// trader until the trader has withdrawn, guaranteeing that they won't have\n    /// orders open for the particular token.\n    function signalBackupWithdraw(address _token) external {\n        /* solium-disable-next-line security/no-block-members */\n        traderWithdrawalSignals[msg.sender][_token] = now;\n    }\n\n    function privateIncrementBalance(address _trader, ERC20 _token, uint256 _value) private {\n        traderBalances[_trader][_token] = traderBalances[_trader][_token].add(_value);\n\n        emit LogBalanceIncreased(_trader, _token, _value);\n    }\n\n    function privateDecrementBalance(address _trader, ERC20 _token, uint256 _value) private {\n        require(traderBalances[_trader][_token] >= _value, \"insufficient funds\");\n        traderBalances[_trader][_token] = traderBalances[_trader][_token].sub(_value);\n\n        emit LogBalanceDecreased(_trader, _token, _value);\n    }\n}",
  "bytecode": "60806040523480156200001157600080fd5b50604051620016323803806200163283398101604090815281516020808401519284015160008054600160a060020a031916331790559190930180519093620000609160019186019062000094565b5060048054600160a060020a03938416600160a060020a031991821617909155600380549290931691161790555062000139565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f10620000d757805160ff191683800117855562000107565b8280016001018555821562000107579182015b8281111562000107578251825591602001919060010190620000ea565b506200011592915062000119565b5090565b6200013691905b8082111562000115576000815560010162000120565b90565b6114e980620001496000396000f3006080604052600436106100e25763ffffffff60e060020a600035041663080bdfa881146100e75780631d65551d1461011857806323017a3a1461013b57806331f092651461015057806334814e581461018157806347e7ef24146101bc57806367aa50ae146101d3578063715018a6146101f45780638da5cb5b1461020957806395b8cf551461021e578063c43c633b1461023f578063e12cbb3c14610278578063e1c3aedc1461028d578063ea42418b146102ae578063f2fde38b146102c3578063f7cdf47c146102e4578063fc257baa146102f9578063ffa1ad7414610320575b600080fd5b3480156100f357600080fd5b506100fc6103aa565b60408051600160a060020a039092168252519081900360200190f35b34801561012457600080fd5b50610139600160a060020a03600435166103b9565b005b34801561014757600080fd5b506100fc610447565b34801561015c57600080fd5b5061013960048035600160a060020a0316906024803591604435918201910135610456565b34801561018d57600080fd5b50610139600160a060020a03600435811690602435811690604435811690606435906084359060a435166107ab565b610139600160a060020a0360043516602435610a24565b3480156101df57600080fd5b50610139600160a060020a0360043516610b52565b34801561020057600080fd5b50610139610be0565b34801561021557600080fd5b506100fc610c4c565b34801561022a57600080fd5b50610139600160a060020a0360043516610c5b565b34801561024b57600080fd5b50610266600160a060020a0360043581169060243516610c84565b60408051918252519081900360200190f35b34801561028457600080fd5b50610266610ca1565b34801561029957600080fd5b50610139600160a060020a0360043516610ca8565b3480156102ba57600080fd5b506100fc610d36565b3480156102cf57600080fd5b50610139600160a060020a0360043516610d45565b3480156102f057600080fd5b506100fc610d68565b34801561030557600080fd5b50610266600160a060020a0360043581169060243516610d80565b34801561032c57600080fd5b50610335610d9d565b6040805160208082528351818301528351919283929083019185019080838360005b8381101561036f578181015183820152602001610357565b50505050905090810190601f16801561039c5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b600354600160a060020a031681565b600054600160a060020a031633146103d057600080fd5b60025460408051600160a060020a039283168152918316602083015280517f8108e388ca125ce52d732c3507bc30e14194e147d133753ca55d6b5f109467ae9281900390910190a16002805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b600454600160a060020a031681565b60008483838080601f016020809104026020016040519081016040528093929190818152602001838380828437505084513394506000101592506105ef91505057600354604080517fc043df8c000000000000000000000000000000000000000000000000000000008152600160a060020a038481166004830190815260248301938452865160448401528651919094169363c043df8c9386938893606490910190602085019080838360005b8381101561051b578181015183820152602001610503565b50505050905090810190601f1680156105485780820380516001836020036101000a031916815260200191505b509350505050602060405180830381600087803b15801561056857600080fd5b505af115801561057c573d6000803e3d6000fd5b505050506040513d602081101561059257600080fd5b505115156105ea576040805160e560020a62461bcd02815260206004820152601160248201527f696e76616c6964207369676e6174757265000000000000000000000000000000604482015290519081900360640190fd5b610718565b600160a060020a03808216600090815260066020908152604080832093871683529290522054151561066b576040805160e560020a62461bcd02815260206004820152600d60248201527f6e6f74207369676e616c6c656400000000000000000000000000000000000000604482015290519081900360640190fd5b600160a060020a038082166000908152600660209081526040808320938716835292905220546202a3004291909103116106ef576040805160e560020a62461bcd02815260206004820152601560248201527f7369676e616c2074696d652072656d61696e696e670000000000000000000000604482015290519081900360640190fd5b600160a060020a0380821660009081526006602090815260408083209387168352929052908120555b339350610726848989610e2a565b600160a060020a03881673eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee141561078757604051600160a060020a0385169088156108fc029089906000818181858888f19350505050158015610781573d6000803e3d6000fd5b506107a1565b6107a1600160a060020a038916858963ffffffff610f4d16565b5050505050505050565b600254600160a060020a0316331461080d576040805160e560020a62461bcd02815260206004820152600e60248201527f6e6f7420617574686f72697a6564000000000000000000000000000000000000604482015290519081900360640190fd5b600160a060020a0380871660009081526005602090815260408083209388168352929052205482111561088a576040805160e560020a62461bcd02815260206004820152601a60248201527f696e73756666696369656e742066756e647320666f7220666565000000000000604482015290519081900360640190fd5b600160a060020a03841673eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee14156109485760048054604080517f8340f549000000000000000000000000000000000000000000000000000000008152600160a060020a038581169482019490945287841660248201526044810186905290519290911691638340f549918591606480830192600092919082900301818588803b15801561092a57600080fd5b505af115801561093e573d6000803e3d6000fd5b50505050506109fb565b60045461096890600160a060020a0386811691168463ffffffff61102b16565b60048054604080517f8340f549000000000000000000000000000000000000000000000000000000008152600160a060020a038581169482019490945287841660248201526044810186905290519290911691638340f5499160648082019260009290919082900301818387803b1580156109e257600080fd5b505af11580156109f6573d6000803e3d6000fd5b505050505b610a088685848601610e2a565b6000831115610a1c57610a1c858585611104565b505050505050565b3381600160a060020a03841673eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee1415610acd57348314610ac8576040805160e560020a62461bcd02815260206004820152602760248201527f6d69736d6174636865642076616c756520706172616d6574657220616e64207460448201527f782076616c756500000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b610b41565b3415610b23576040805160e560020a62461bcd02815260206004820152601960248201527f756e6578706563746564206574686572207472616e7366657200000000000000604482015290519081900360640190fd5b610b3e600160a060020a03851683308663ffffffff6111aa16565b90505b610b4c828583611104565b50505050565b600054600160a060020a03163314610b6957600080fd5b60035460408051600160a060020a039283168152918316602083015280517f320ee0620117fe5b31d2b2ca97b2a711e2045489d6eb5290a73f04747f1819be9281900390910190a16003805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b600054600160a060020a03163314610bf757600080fd5b60008054604051600160a060020a03909116917ff8df31144d9c2f0f6b59d69b8b98abd5459d07f2742c4df920b25aae33c6482091a26000805473ffffffffffffffffffffffffffffffffffffffff19169055565b600054600160a060020a031681565b336000908152600660209081526040808320600160a060020a0394909416835292905220429055565b600560209081526000928352604080842090915290825290205481565b6202a30081565b600054600160a060020a03163314610cbf57600080fd5b60045460408051600160a060020a039283168152918316602083015280517f6c348498f095f3d7eb84de1c0bf7fd7db8217d2fdd2af573ad0fa3642901c2459281900390910190a16004805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b600254600160a060020a031681565b600054600160a060020a03163314610d5c57600080fd5b610d65816113cf565b50565b73eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee81565b600660209081526000928352604080842090915290825290205481565b60018054604080516020600284861615610100026000190190941693909304601f81018490048402820184019092528181529291830182828015610e225780601f10610df757610100808354040283529160200191610e22565b820191906000526020600020905b815481529060010190602001808311610e0557829003601f168201915b505050505081565b600160a060020a03808416600090815260056020908152604080832093861683529290522054811115610ea7576040805160e560020a62461bcd02815260206004820152601260248201527f696e73756666696369656e742066756e64730000000000000000000000000000604482015290519081900360640190fd5b600160a060020a03808416600090815260056020908152604080832093861683529290522054610edd908263ffffffff61144c16565b600160a060020a038085166000818152600560209081526040808320948816808452948252918290209490945580519182529281019190915280820183905290517f2622669645a3d6b14dc5d6134367eb988c1b617ea2df59f8aa0f102ba049977c9181900360600190a1505050565b82600160a060020a031663a9059cbb83836040518363ffffffff1660e060020a0281526004018083600160a060020a0316600160a060020a0316815260200182815260200192505050600060405180830381600087803b158015610fb057600080fd5b505af1158015610fc4573d6000803e3d6000fd5b50505050610fd061145e565b1515611026576040805160e560020a62461bcd02815260206004820152600f60248201527f7472616e73666572206661696c65640000000000000000000000000000000000604482015290519081900360640190fd5b505050565b82600160a060020a031663095ea7b383836040518363ffffffff1660e060020a0281526004018083600160a060020a0316600160a060020a0316815260200182815260200192505050600060405180830381600087803b15801561108e57600080fd5b505af11580156110a2573d6000803e3d6000fd5b505050506110ae61145e565b1515611026576040805160e560020a62461bcd02815260206004820152600e60248201527f617070726f7665206661696c6564000000000000000000000000000000000000604482015290519081900360640190fd5b600160a060020a0380841660009081526005602090815260408083209386168352929052205461113a908263ffffffff61149216565b600160a060020a038085166000818152600560209081526040808320948816808452948252918290209490945580519182529281019190915280820183905290517f8d6dc51e8945c5e6a4ddb872612ec2b1f5e375a97daebdbb6a03a64e7c6592099181900360600190a1505050565b600080600086600160a060020a03166370a08231866040518263ffffffff1660e060020a0281526004018082600160a060020a0316600160a060020a03168152602001915050602060405180830381600087803b15801561120a57600080fd5b505af115801561121e573d6000803e3d6000fd5b505050506040513d602081101561123457600080fd5b5051604080517f23b872dd000000000000000000000000000000000000000000000000000000008152600160a060020a0389811660048301528881166024830152604482018890529151929450908916916323b872dd9160648082019260009290919082900301818387803b1580156112ac57600080fd5b505af11580156112c0573d6000803e3d6000fd5b505050506112cc61145e565b1515611322576040805160e560020a62461bcd02815260206004820152601360248201527f7472616e7366657246726f6d206661696c656400000000000000000000000000604482015290519081900360640190fd5b86600160a060020a03166370a08231866040518263ffffffff1660e060020a0281526004018082600160a060020a0316600160a060020a03168152602001915050602060405180830381600087803b15801561137d57600080fd5b505af1158015611391573d6000803e3d6000fd5b505050506040513d60208110156113a757600080fd5b505190506113c4846113bf838563ffffffff61144c16565b6114a5565b979650505050505050565b600160a060020a03811615156113e457600080fd5b60008054604051600160a060020a03808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a36000805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b60008282111561145857fe5b50900390565b6000803d8015611475576020811461147e5761148a565b6001915061148a565b60206000803e60005191505b501515919050565b8181018281101561149f57fe5b92915050565b60008183106114b457816114b6565b825b93925050505600a165627a7a72305820598ffd68e54c83a8aac3208c875bee2d7b9684c803d2575e42a61153209fcbaf00290000000000000000000000000000000000000000000000000000000000000060000000000000000000000000880407c9cd119bef48b1821cdfc434e3ca3cd58800000000000000000000000031a0d1a199631d244761eeba67e8501296d2e383000000000000000000000000000000000000000000000000000000000000000d6d61696e6e65742d312e302e3100000000000000000000000000000000000000",
  "constructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000880407c9cd119bef48b1821cdfc434e3ca3cd58800000000000000000000000031a0d1a199631d244761eeba67e8501296d2e383000000000000000000000000000000000000000000000000000000000000000d6d61696e6e65742d312e302e3100000000000000000000000000000000000000"
}