{
  "address": "0xa5c996ea25af22f7bc82c973620503290635fade",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "Factory",
  "compilerVersion": "v0.5.7+commit.6da8b019",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2019-04-16\n*/\n\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ninterface IERC20 {\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address who) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @title SafeMath\n * @dev Unsigned math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    /**\n    * @dev Multiplies two unsigned integers, reverts on overflow.\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n    * @dev Adds two unsigned integers, reverts on overflow.\n    */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n    * reverts when dividing by zero.\n    */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\n\npragma solidity ^0.5.0;\n\n\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        require(token.transfer(to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        require(token.transferFrom(from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require((value == 0) || (token.allowance(address(this), spender) == 0));\n        require(token.approve(spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        require(token.approve(spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\n        require(token.approve(spender, newAllowance));\n    }\n}\n\n// File: contracts/ens/AbstractENS.sol\n\npragma solidity ^0.5.0;\n\ncontract AbstractENS {\n    function owner(bytes32 _node) public view returns(address);\n    function resolver(bytes32 _node) public view returns(address);\n    function ttl(bytes32 _node) public view returns(uint64);\n    function setOwner(bytes32 _node, address _owner) public;\n    function setSubnodeOwner(bytes32 _node, bytes32 _label, address _owner) public;\n    function setResolver(bytes32 _node, address _resolver) public;\n    function setTTL(bytes32 _node, uint64 _ttl) public;\n\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address owner);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolver);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttl);\n}\n\n// File: contracts/ens/AbstractResolver.sol\n\npragma solidity ^0.5.0;\n\ncontract AbstractResolver {\n    function supportsInterface(bytes4 _interfaceID) public view returns (bool);\n    function addr(bytes32 _node) public view returns (address ret);\n    function setAddr(bytes32 _node, address _addr) public;\n    function hash(bytes32 _node) public view returns (bytes32 ret);\n    function setHash(bytes32 _node, bytes32 _hash) public;\n}\n\n// File: contracts/misc/SingletonHash.sol\n\npragma solidity ^0.5.0;\n\ncontract SingletonHash {\n    event HashConsumed(bytes32 indexed hash);\n\n    /**\n     * @dev Used hash accounting\n     */\n    mapping(bytes32 => bool) public isHashConsumed;\n\n    /**\n     * @dev Parameter can be used only once\n     * @param _hash Single usage hash\n     */\n    function singletonHash(bytes32 _hash) internal {\n        require(!isHashConsumed[_hash]);\n        isHashConsumed[_hash] = true;\n        emit HashConsumed(_hash);\n    }\n}\n\n// File: openzeppelin-solidity/contracts/access/Roles.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    /**\n     * @dev give an account access to this role\n     */\n    function add(Role storage role, address account) internal {\n        require(account != address(0));\n        require(!has(role, account));\n\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev remove an account's access to this role\n     */\n    function remove(Role storage role, address account) internal {\n        require(account != address(0));\n        require(has(role, account));\n\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev check if an account has this role\n     * @return bool\n     */\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0));\n        return role.bearer[account];\n    }\n}\n\n// File: openzeppelin-solidity/contracts/access/roles/SignerRole.sol\n\npragma solidity ^0.5.0;\n\n\ncontract SignerRole {\n    using Roles for Roles.Role;\n\n    event SignerAdded(address indexed account);\n    event SignerRemoved(address indexed account);\n\n    Roles.Role private _signers;\n\n    constructor () internal {\n        _addSigner(msg.sender);\n    }\n\n    modifier onlySigner() {\n        require(isSigner(msg.sender));\n        _;\n    }\n\n    function isSigner(address account) public view returns (bool) {\n        return _signers.has(account);\n    }\n\n    function addSigner(address account) public onlySigner {\n        _addSigner(account);\n    }\n\n    function renounceSigner() public {\n        _removeSigner(msg.sender);\n    }\n\n    function _addSigner(address account) internal {\n        _signers.add(account);\n        emit SignerAdded(account);\n    }\n\n    function _removeSigner(address account) internal {\n        _signers.remove(account);\n        emit SignerRemoved(account);\n    }\n}\n\n// File: openzeppelin-solidity/contracts/cryptography/ECDSA.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @title Elliptic curve signature operations\n * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\n * TODO Remove this library once solidity supports passing a signature to ecrecover.\n * See https://github.com/ethereum/solidity/issues/864\n */\n\nlibrary ECDSA {\n    /**\n     * @dev Recover signer address from a message by using their signature\n     * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\n     * @param signature bytes signature, the signature is generated using web3.eth.sign()\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // Check the signature length\n        if (signature.length != 65) {\n            return (address(0));\n        }\n\n        // Divide the signature in r, s and v variables\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n        if (v < 27) {\n            v += 27;\n        }\n\n        // If the version is correct return the signer address\n        if (v != 27 && v != 28) {\n            return (address(0));\n        } else {\n            return ecrecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * toEthSignedMessageHash\n     * @dev prefix a bytes32 value with \"\\x19Ethereum Signed Message:\"\n     * and hash the result\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n}\n\n// File: openzeppelin-solidity/contracts/drafts/SignatureBouncer.sol\n\npragma solidity ^0.5.0;\n\n\n\n/**\n * @title SignatureBouncer\n * @author PhABC, Shrugs and aflesher\n * @dev SignatureBouncer allows users to submit a signature as a permission to\n * do an action.\n * If the signature is from one of the authorized signer addresses, the\n * signature is valid.\n * Note that SignatureBouncer offers no protection against replay attacks, users\n * must add this themselves!\n *\n * Signer addresses can be individual servers signing grants or different\n * users within a decentralized club that have permission to invite other\n * members. This technique is useful for whitelists and airdrops; instead of\n * putting all valid addresses on-chain, simply sign a grant of the form\n * keccak256(abi.encodePacked(`:contractAddress` + `:granteeAddress`)) using a\n * valid signer address.\n * Then restrict access to your crowdsale/whitelist/airdrop using the\n * `onlyValidSignature` modifier (or implement your own using _isValidSignature).\n * In addition to `onlyValidSignature`, `onlyValidSignatureAndMethod` and\n * `onlyValidSignatureAndData` can be used to restrict access to only a given\n * method or a given method with given parameters respectively.\n * See the tests in SignatureBouncer.test.js for specific usage examples.\n *\n * @notice A method that uses the `onlyValidSignatureAndData` modifier must make\n * the _signature parameter the \"last\" parameter. You cannot sign a message that\n * has its own signature in it so the last 128 bytes of msg.data (which\n * represents the length of the _signature data and the _signaature data itself)\n * is ignored when validating. Also non fixed sized parameters make constructing\n * the data in the signature much more complex.\n * See https://ethereum.stackexchange.com/a/50616 for more details.\n */\ncontract SignatureBouncer is SignerRole {\n    using ECDSA for bytes32;\n\n    // Function selectors are 4 bytes long, as documented in\n    // https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector\n    uint256 private constant _METHOD_ID_SIZE = 4;\n    // Signature size is 65 bytes (tightly packed v + r + s), but gets padded to 96 bytes\n    uint256 private constant _SIGNATURE_SIZE = 96;\n\n    constructor () internal {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    /**\n     * @dev requires that a valid signature of a signer was provided\n     */\n    modifier onlyValidSignature(bytes memory signature) {\n        require(_isValidSignature(msg.sender, signature));\n        _;\n    }\n\n    /**\n     * @dev requires that a valid signature with a specifed method of a signer was provided\n     */\n    modifier onlyValidSignatureAndMethod(bytes memory signature) {\n        require(_isValidSignatureAndMethod(msg.sender, signature));\n        _;\n    }\n\n    /**\n     * @dev requires that a valid signature with a specifed method and params of a signer was provided\n     */\n    modifier onlyValidSignatureAndData(bytes memory signature) {\n        require(_isValidSignatureAndData(msg.sender, signature));\n        _;\n    }\n\n    /**\n     * @dev is the signature of `this + sender` from a signer?\n     * @return bool\n     */\n    function _isValidSignature(address account, bytes memory signature) internal view returns (bool) {\n        return _isValidDataHash(keccak256(abi.encodePacked(address(this), account)), signature);\n    }\n\n    /**\n     * @dev is the signature of `this + sender + methodId` from a signer?\n     * @return bool\n     */\n    function _isValidSignatureAndMethod(address account, bytes memory signature) internal view returns (bool) {\n        bytes memory data = new bytes(_METHOD_ID_SIZE);\n        for (uint i = 0; i < data.length; i++) {\n            data[i] = msg.data[i];\n        }\n        return _isValidDataHash(keccak256(abi.encodePacked(address(this), account, data)), signature);\n    }\n\n    /**\n        * @dev is the signature of `this + sender + methodId + params(s)` from a signer?\n        * @notice the signature parameter of the method being validated must be the \"last\" parameter\n        * @return bool\n        */\n    function _isValidSignatureAndData(address account, bytes memory signature) internal view returns (bool) {\n        require(msg.data.length > _SIGNATURE_SIZE);\n\n        bytes memory data = new bytes(msg.data.length - _SIGNATURE_SIZE);\n        for (uint i = 0; i < data.length; i++) {\n            data[i] = msg.data[i];\n        }\n\n        return _isValidDataHash(keccak256(abi.encodePacked(address(this), account, data)), signature);\n    }\n\n    /**\n     * @dev internal function to convert a hash to an eth signed message\n     * and then recover the signature and check it against the signer role\n     * @return bool\n     */\n    function _isValidDataHash(bytes32 hash, bytes memory signature) internal view returns (bool) {\n        address signer = hash.toEthSignedMessageHash().recover(signature);\n\n        return signer != address(0) && isSigner(signer);\n    }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n\npragma solidity ^0.5.0;\n\n\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n * Originally based on code by FirstBlood:\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n *\n * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\n * all accounts just by listening to said events. Note that this isn't required by the specification, and other\n * compliant implementations may not do it.\n */\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowed;\n\n    uint256 private _totalSupply;\n\n    /**\n    * @dev Total number of tokens in existence\n    */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n    * @dev Gets the balance of the specified address.\n    * @param owner The address to query the balance of.\n    * @return An uint256 representing the amount owned by the passed address.\n    */\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\n\n    /**\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n     * @param owner address The address which owns the funds.\n     * @param spender address The address which will spend the funds.\n     * @return A uint256 specifying the amount of tokens still available for the spender.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\n\n    /**\n    * @dev Transfer token for a specified address\n    * @param to The address to transfer to.\n    * @param value The amount to be transferred.\n    */\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     */\n    function approve(address spender, uint256 value) public returns (bool) {\n        require(spender != address(0));\n\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev Transfer tokens from one address to another.\n     * Note that while this function emits an Approval event, this is not required as per the specification,\n     * and other compliant implementations may not emit the event.\n     * @param from address The address which you want to send tokens from\n     * @param to address The address which you want to transfer to\n     * @param value uint256 the amount of tokens to be transferred\n     */\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n        _transfer(from, to, value);\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\n        return true;\n    }\n\n    /**\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\n     * approve should be called when allowed_[_spender] == 0. To increment\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * Emits an Approval event.\n     * @param spender The address which will spend the funds.\n     * @param addedValue The amount of tokens to increase the allowance by.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0));\n\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n    /**\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n     * approve should be called when allowed_[_spender] == 0. To decrement\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * Emits an Approval event.\n     * @param spender The address which will spend the funds.\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        require(spender != address(0));\n\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n    /**\n    * @dev Transfer token for a specified addresses\n    * @param from The address to transfer from.\n    * @param to The address to transfer to.\n    * @param value The amount to be transferred.\n    */\n    function _transfer(address from, address to, uint256 value) internal {\n        require(to != address(0));\n\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Internal function that mints an amount of the token and assigns it to\n     * an account. This encapsulates the modification of balances such that the\n     * proper events are emitted.\n     * @param account The account that will receive the created tokens.\n     * @param value The amount that will be created.\n     */\n    function _mint(address account, uint256 value) internal {\n        require(account != address(0));\n\n        _totalSupply = _totalSupply.add(value);\n        _balances[account] = _balances[account].add(value);\n        emit Transfer(address(0), account, value);\n    }\n\n    /**\n     * @dev Internal function that burns an amount of the token of a given\n     * account.\n     * @param account The account whose tokens will be burnt.\n     * @param value The amount that will be burnt.\n     */\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0));\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    /**\n     * @dev Internal function that burns an amount of the token of a given\n     * account, deducting from the sender's allowance for said account. Uses the\n     * internal burn function.\n     * Emits an Approval event (reflecting the reduced allowance).\n     * @param account The account whose tokens will be burnt.\n     * @param value The amount that will be burnt.\n     */\n    function _burnFrom(address account, uint256 value) internal {\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\n        _burn(account, value);\n        emit Approval(account, msg.sender, _allowed[account][msg.sender]);\n    }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Burnable.sol\n\npragma solidity ^0.5.0;\n\n\n/**\n * @title Burnable Token\n * @dev Token that can be irreversibly burned (destroyed).\n */\ncontract ERC20Burnable is ERC20 {\n    /**\n     * @dev Burns a specific amount of tokens.\n     * @param value The amount of token to be burned.\n     */\n    function burn(uint256 value) public {\n        _burn(msg.sender, value);\n    }\n\n    /**\n     * @dev Burns a specific amount of tokens from the target address and decrements allowance\n     * @param from address The address which you want to send tokens from\n     * @param value uint256 The amount of token to be burned\n     */\n    function burnFrom(address from, uint256 value) public {\n        _burnFrom(from, value);\n    }\n}\n\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @return the address of the owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner());\n        _;\n    }\n\n    /**\n     * @return true if `msg.sender` is the owner of the contract.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Allows the current owner to relinquish control of the contract.\n     * @notice Renouncing to ownership will leave the contract without an owner.\n     * It will not be possible to call the functions with the `onlyOwner`\n     * modifier anymore.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n// File: contracts/misc/DutchAuction.sol\n\npragma solidity ^0.5.0;\n\n\n\n\n\n\n/// @title Dutch auction contract - distribution of XRT tokens using an auction.\n/// @author Stefan George - <[email protected]>\n/// @author Airalab - <[email protected]> \ncontract DutchAuction is SignatureBouncer, Ownable {\n    using SafeERC20 for ERC20Burnable;\n\n    /*\n     *  Events\n     */\n    event BidSubmission(address indexed sender, uint256 amount);\n\n    /*\n     *  Constants\n     */\n    uint constant public WAITING_PERIOD = 0; // 1 days;\n\n    /*\n     *  Storage\n     */\n    ERC20Burnable public token;\n    address public ambix;\n    address payable public wallet;\n    uint public maxTokenSold;\n    uint public ceiling;\n    uint public priceFactor;\n    uint public startBlock;\n    uint public endTime;\n    uint public totalReceived;\n    uint public finalPrice;\n    mapping (address => uint) public bids;\n    Stages public stage;\n\n    /*\n     *  Enums\n     */\n    enum Stages {\n        AuctionDeployed,\n        AuctionSetUp,\n        AuctionStarted,\n        AuctionEnded,\n        TradingStarted\n    }\n\n    /*\n     *  Modifiers\n     */\n    modifier atStage(Stages _stage) {\n        // Contract on stage\n        require(stage == _stage);\n        _;\n    }\n\n    modifier isValidPayload() {\n        require(msg.data.length == 4 || msg.data.length == 164);\n        _;\n    }\n\n    modifier timedTransitions() {\n        if (stage == Stages.AuctionStarted && calcTokenPrice() <= calcStopPrice())\n            finalizeAuction();\n        if (stage == Stages.AuctionEnded && now > endTime + WAITING_PERIOD)\n            stage = Stages.TradingStarted;\n        _;\n    }\n\n    /*\n     *  Public functions\n     */\n    /// @dev Contract constructor function sets owner.\n    /// @param _wallet Multisig wallet.\n    /// @param _maxTokenSold Auction token balance.\n    /// @param _ceiling Auction ceiling.\n    /// @param _priceFactor Auction price factor.\n    constructor(address payable _wallet, uint _maxTokenSold, uint _ceiling, uint _priceFactor)\n        public\n    {\n        require(_wallet != address(0) && _ceiling > 0 && _priceFactor > 0);\n\n        wallet = _wallet;\n        maxTokenSold = _maxTokenSold;\n        ceiling = _ceiling;\n        priceFactor = _priceFactor;\n        stage = Stages.AuctionDeployed;\n    }\n\n    /// @dev Setup function sets external contracts' addresses.\n    /// @param _token Token address.\n    /// @param _ambix Distillation cube address.\n    function setup(ERC20Burnable _token, address _ambix)\n        public\n        onlyOwner\n        atStage(Stages.AuctionDeployed)\n    {\n        // Validate argument\n        require(_token != ERC20Burnable(0) && _ambix != address(0));\n\n        token = _token;\n        ambix = _ambix;\n\n        // Validate token balance\n        require(token.balanceOf(address(this)) == maxTokenSold);\n\n        stage = Stages.AuctionSetUp;\n    }\n\n    /// @dev Starts auction and sets startBlock.\n    function startAuction()\n        public\n        onlyOwner\n        atStage(Stages.AuctionSetUp)\n    {\n        stage = Stages.AuctionStarted;\n        startBlock = block.number;\n    }\n\n    /// @dev Calculates current token price.\n    /// @return Returns token price.\n    function calcCurrentTokenPrice()\n        public\n        timedTransitions\n        returns (uint)\n    {\n        if (stage == Stages.AuctionEnded || stage == Stages.TradingStarted)\n            return finalPrice;\n        return calcTokenPrice();\n    }\n\n    /// @dev Returns correct stage, even if a function with timedTransitions modifier has not yet been called yet.\n    /// @return Returns current auction stage.\n    function updateStage()\n        public\n        timedTransitions\n        returns (Stages)\n    {\n        return stage;\n    }\n\n    /// @dev Allows to send a bid to the auction.\n    /// @param signature KYC approvement\n    function bid(bytes calldata signature)\n        external\n        payable\n        isValidPayload\n        timedTransitions\n        atStage(Stages.AuctionStarted)\n        onlyValidSignature(signature)\n        returns (uint amount)\n    {\n        require(msg.value > 0);\n        amount = msg.value;\n\n        address payable receiver = msg.sender;\n\n        // Prevent that more than 90% of tokens are sold. Only relevant if cap not reached.\n        uint maxWei = maxTokenSold * calcTokenPrice() / 10**9 - totalReceived;\n        uint maxWeiBasedOnTotalReceived = ceiling - totalReceived;\n        if (maxWeiBasedOnTotalReceived < maxWei)\n            maxWei = maxWeiBasedOnTotalReceived;\n\n        // Only invest maximum possible amount.\n        if (amount > maxWei) {\n            amount = maxWei;\n            // Send change back to receiver address.\n            receiver.transfer(msg.value - amount);\n        }\n\n        // Forward funding to ether wallet\n        (bool success,) = wallet.call.value(amount)(\"\");\n        require(success);\n\n        bids[receiver] += amount;\n        totalReceived += amount;\n        emit BidSubmission(receiver, amount);\n\n        // Finalize auction when maxWei reached\n        if (amount == maxWei)\n            finalizeAuction();\n    }\n\n    /// @dev Claims tokens for bidder after auction.\n    function claimTokens()\n        public\n        isValidPayload\n        timedTransitions\n        atStage(Stages.TradingStarted)\n    {\n        address receiver = msg.sender;\n        uint tokenCount = bids[receiver] * 10**9 / finalPrice;\n        bids[receiver] = 0;\n        token.safeTransfer(receiver, tokenCount);\n    }\n\n    /// @dev Calculates stop price.\n    /// @return Returns stop price.\n    function calcStopPrice()\n        view\n        public\n        returns (uint)\n    {\n        return totalReceived * 10**9 / maxTokenSold + 1;\n    }\n\n    /// @dev Calculates token price.\n    /// @return Returns token price.\n    function calcTokenPrice()\n        view\n        public\n        returns (uint)\n    {\n        return priceFactor * 10**18 / (block.number - startBlock + 7500) + 1;\n    }\n\n    /*\n     *  Private functions\n     */\n    function finalizeAuction()\n        private\n    {\n        stage = Stages.AuctionEnded;\n        finalPrice = totalReceived == ceiling ? calcTokenPrice() : calcStopPrice();\n        uint soldTokens = totalReceived * 10**9 / finalPrice;\n\n        if (totalReceived == ceiling) {\n            // Auction contract transfers all unsold tokens to Ambix contract\n            token.safeTransfer(ambix, maxTokenSold - soldTokens);\n        } else {\n            // Auction contract burn all unsold tokens\n            token.burn(maxTokenSold - soldTokens);\n        }\n\n        endTime = now;\n    }\n}\n\n// File: contracts/misc/SharedCode.sol\n\npragma solidity ^0.5.0;\n\n// Inspired by https://github.com/GNSPS/2DProxy\nlibrary SharedCode {\n    /**\n     * @dev Create tiny proxy without constructor\n     * @param _shared Shared code contract address\n     */\n    function proxy(address _shared) internal returns (address instance) {\n        bytes memory code = abi.encodePacked(\n            hex\"603160008181600b9039f3600080808080368092803773\",\n            _shared, hex\"5af43d828181803e808314603057f35bfd\"\n        );\n        assembly {\n            instance := create(0, add(code, 0x20), 60)\n            if iszero(extcodesize(instance)) {\n                revert(0, 0)\n            }\n        }\n    }\n}\n\n// File: contracts/robonomics/interface/ILiability.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @title Standard liability smart contract interface\n */\ncontract ILiability {\n    /**\n     * @dev Liability termination signal\n     */\n    event Finalized(bool indexed success, bytes result);\n\n    /**\n     * @dev Behaviour model multihash\n     */\n    bytes public model;\n\n    /**\n     * @dev Objective ROSBAG multihash\n     * @notice ROSBAGv2 is used: http://wiki.ros.org/Bags/Format/2.0 \n     */\n    bytes public objective;\n\n    /**\n     * @dev Report ROSBAG multihash \n     * @notice ROSBAGv2 is used: http://wiki.ros.org/Bags/Format/2.0 \n     */\n    bytes public result;\n\n    /**\n     * @dev Payment token address\n     */\n    address public token;\n\n    /**\n     * @dev Liability cost\n     */\n    uint256 public cost;\n\n    /**\n     * @dev Lighthouse fee in wn\n     */\n    uint256 public lighthouseFee;\n\n    /**\n     * @dev Validator fee in wn\n     */\n    uint256 public validatorFee;\n\n    /**\n     * @dev Robonomics demand message hash\n     */\n    bytes32 public demandHash;\n\n    /**\n     * @dev Robonomics offer message hash\n     */\n    bytes32 public offerHash;\n\n    /**\n     * @dev Liability promisor address\n     */\n    address public promisor;\n\n    /**\n     * @dev Liability promisee address\n     */\n    address public promisee;\n\n    /**\n     * @dev Lighthouse assigned to this liability\n     */\n    address public lighthouse;\n\n    /**\n     * @dev Liability validator address\n     */\n    address public validator;\n\n    /**\n     * @dev Liability success flag\n     */\n    bool public isSuccess;\n\n    /**\n     * @dev Liability finalization status flag\n     */\n    bool public isFinalized;\n\n    /**\n     * @dev Deserialize robonomics demand message\n     * @notice It can be called by factory only\n     */\n    function demand(\n        bytes   calldata _model,\n        bytes   calldata _objective,\n\n        address _token,\n        uint256 _cost,\n\n        address _lighthouse,\n\n        address _validator,\n        uint256 _validator_fee,\n\n        uint256 _deadline,\n        address _sender,\n        bytes   calldata _signature\n    ) external returns (bool);\n\n    /**\n     * @dev Deserialize robonomics offer message\n     * @notice It can be called by factory only\n     */\n    function offer(\n        bytes   calldata _model,\n        bytes   calldata _objective,\n        \n        address _token,\n        uint256 _cost,\n\n        address _validator,\n\n        address _lighthouse,\n        uint256 _lighthouse_fee,\n\n        uint256 _deadline,\n        address _sender,\n        bytes   calldata _signature\n    ) external returns (bool);\n\n    /**\n     * @dev Finalize liability contract\n     * @param _result Result data hash\n     * @param _success Set 'true' when liability has success result\n     * @param _signature Result signature: liability address, result and success flag signed by promisor\n     * @notice It can be called by assigned lighthouse only\n     */\n    function finalize(\n        bytes calldata _result,\n        bool  _success,\n        bytes calldata _signature\n    ) external returns (bool);\n}\n\n// File: contracts/robonomics/interface/ILighthouse.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @title Robonomics lighthouse contract interface\n */\ncontract ILighthouse {\n    /**\n     * @dev Provider going online\n     */\n    event Online(address indexed provider);\n\n    /**\n     * @dev Provider going offline\n     */\n    event Offline(address indexed provider);\n\n    /**\n     * @dev Active robonomics provider\n     */\n    event Current(address indexed provider, uint256 indexed quota);\n\n    /**\n     * @dev Robonomics providers list\n     */\n    address[] public providers;\n\n    /**\n     * @dev Count of robonomics providers on this lighthouse\n     */\n    function providersLength() public view returns (uint256)\n    { return providers.length; }\n\n    /**\n     * @dev Provider stake distribution\n     */\n    mapping(address => uint256) public stakes;\n\n    /**\n     * @dev Minimal stake to get one quota\n     */\n    uint256 public minimalStake;\n\n    /**\n     * @dev Silence timeout for provider in blocks\n     */\n    uint256 public timeoutInBlocks;\n\n    /**\n     * @dev Block number of last transaction from current provider\n     */\n    uint256 public keepAliveBlock;\n\n    /**\n     * @dev Round robin provider list marker\n     */\n    uint256 public marker;\n\n    /**\n     * @dev Current provider quota\n     */\n    uint256 public quota;\n\n    /**\n     * @dev Get quota of provider\n     */\n    function quotaOf(address _provider) public view returns (uint256)\n    { return stakes[_provider] / minimalStake; }\n\n    /**\n     * @dev Increase stake and get more quota,\n     *      one quota - one transaction in round\n     * @param _value in wn\n     * @notice XRT should be approved before call this \n     */\n    function refill(uint256 _value) external returns (bool);\n\n    /**\n     * @dev Decrease stake and get XRT back\n     * @param _value in wn\n     */\n    function withdraw(uint256 _value) external returns (bool);\n\n    /**\n     * @dev Create liability smart contract assigned to this lighthouse\n     * @param _demand ABI-encoded demand message\n     * @param _offer ABI-encoded offer message\n     * @notice Only current provider can call it\n     */\n    function createLiability(\n        bytes calldata _demand,\n        bytes calldata _offer\n    ) external returns (bool);\n\n    /**\n     * @dev Finalize liability smart contract assigned to this lighthouse\n     * @param _liability smart contract address\n     * @param _result report of work\n     * @param _success work success flag\n     * @param _signature work signature\n     */\n    function finalizeLiability(\n        address _liability,\n        bytes calldata _result,\n        bool _success,\n        bytes calldata _signature\n    ) external returns (bool);\n}\n\n// File: contracts/robonomics/interface/IFactory.sol\n\npragma solidity ^0.5.0;\n\n\n\n/**\n * @title Robonomics liability factory interface\n */\ncontract IFactory {\n    /**\n     * @dev New liability created \n     */\n    event NewLiability(address indexed liability);\n\n    /**\n     * @dev New lighthouse created\n     */\n    event NewLighthouse(address indexed lighthouse, string name);\n\n    /**\n     * @dev Lighthouse address mapping\n     */\n    mapping(address => bool) public isLighthouse;\n\n    /**\n     * @dev Nonce accounting\n     */\n    mapping(address => uint256) public nonceOf;\n\n    /**\n     * @dev Total GAS utilized by Robonomics network\n     */\n    uint256 public totalGasConsumed = 0;\n\n    /**\n     * @dev GAS utilized by liability contracts\n     */\n    mapping(address => uint256) public gasConsumedOf;\n\n    /**\n     * @dev The count of consumed gas for switch to next epoch \n     */\n    uint256 public constant gasEpoch = 347 * 10**10;\n\n    /**\n     * @dev Current gas price in wei\n     */\n    uint256 public gasPrice = 10 * 10**9;\n\n    /**\n     * @dev XRT emission value for consumed gas\n     * @param _gas Gas consumed by robonomics program\n     */\n    function wnFromGas(uint256 _gas) public view returns (uint256);\n\n    /**\n     * @dev Create lighthouse smart contract\n     * @param _minimalStake Minimal stake value of XRT token (one quota price)\n     * @param _timeoutInBlocks Max time of lighthouse silence in blocks\n     * @param _name Lighthouse name,\n     *              example: 'my-name' will create 'my-name.lighthouse.4.robonomics.eth' domain\n     */\n    function createLighthouse(\n        uint256 _minimalStake,\n        uint256 _timeoutInBlocks,\n        string calldata _name\n    ) external returns (ILighthouse);\n\n    /**\n     * @dev Create robot liability smart contract\n     * @param _demand ABI-encoded demand message\n     * @param _offer ABI-encoded offer message\n     * @notice This method is for lighthouse contract use only\n     */\n    function createLiability(\n        bytes calldata _demand,\n        bytes calldata _offer\n    ) external returns (ILiability);\n\n    /**\n     * @dev Is called after liability creation\n     * @param _liability Liability contract address\n     * @param _start_gas Transaction start gas level\n     * @notice This method is for lighthouse contract use only\n     */\n    function liabilityCreated(ILiability _liability, uint256 _start_gas) external returns (bool);\n\n    /**\n     * @dev Is called after liability finalization\n     * @param _liability Liability contract address\n     * @param _start_gas Transaction start gas level\n     * @notice This method is for lighthouse contract use only\n     */\n    function liabilityFinalized(ILiability _liability, uint256 _start_gas) external returns (bool);\n}\n\n// File: openzeppelin-solidity/contracts/access/roles/MinterRole.sol\n\npragma solidity ^0.5.0;\n\n\ncontract MinterRole {\n    using Roles for Roles.Role;\n\n    event MinterAdded(address indexed account);\n    event MinterRemoved(address indexed account);\n\n    Roles.Role private _minters;\n\n    constructor () internal {\n        _addMinter(msg.sender);\n    }\n\n    modifier onlyMinter() {\n        require(isMinter(msg.sender));\n        _;\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return _minters.has(account);\n    }\n\n    function addMinter(address account) public onlyMinter {\n        _addMinter(account);\n    }\n\n    function renounceMinter() public {\n        _removeMinter(msg.sender);\n    }\n\n    function _addMinter(address account) internal {\n        _minters.add(account);\n        emit MinterAdded(account);\n    }\n\n    function _removeMinter(address account) internal {\n        _minters.remove(account);\n        emit MinterRemoved(account);\n    }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Mintable.sol\n\npragma solidity ^0.5.0;\n\n\n\n/**\n * @title ERC20Mintable\n * @dev ERC20 minting logic\n */\ncontract ERC20Mintable is ERC20, MinterRole {\n    /**\n     * @dev Function to mint tokens\n     * @param to The address that will receive the minted tokens.\n     * @param value The amount of tokens to mint.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function mint(address to, uint256 value) public onlyMinter returns (bool) {\n        _mint(to, value);\n        return true;\n    }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Detailed.sol\n\npragma solidity ^0.5.0;\n\n\n/**\n * @title ERC20Detailed token\n * @dev The decimals are only for visualization purposes.\n * All the operations are done using the smallest and indivisible token unit,\n * just as on Ethereum all the operations are done in wei.\n */\ncontract ERC20Detailed is IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    /**\n     * @return the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @return the symbol of the token.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @return the number of decimals of the token.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n\n// File: contracts/robonomics/XRT.sol\n\npragma solidity ^0.5.0;\n\n\n\n\ncontract XRT is ERC20Mintable, ERC20Burnable, ERC20Detailed {\n    constructor(uint256 _initial_supply) public ERC20Detailed(\"Robonomics\", \"XRT\", 9) {\n        _mint(msg.sender, _initial_supply);\n    }\n}\n\n// File: contracts/robonomics/Lighthouse.sol\n\npragma solidity ^0.5.0;\n\n\n\n\n\ncontract Lighthouse is ILighthouse {\n    using SafeERC20 for XRT;\n\n    IFactory public factory;\n    XRT      public xrt;\n\n    function setup(XRT _xrt, uint256 _minimalStake, uint256 _timeoutInBlocks) external returns (bool) {\n        require(factory == IFactory(0) && _minimalStake > 0 && _timeoutInBlocks > 0);\n\n        minimalStake    = _minimalStake;\n        timeoutInBlocks = _timeoutInBlocks;\n        factory         = IFactory(msg.sender);\n        xrt             = _xrt;\n\n        return true;\n    }\n\n    /**\n     * @dev Providers index, started from 1\n     */\n    mapping(address => uint256) public indexOf;\n\n    function refill(uint256 _value) external returns (bool) {\n        xrt.safeTransferFrom(msg.sender, address(this), _value);\n\n        if (stakes[msg.sender] == 0) {\n            require(_value >= minimalStake);\n            providers.push(msg.sender);\n            indexOf[msg.sender] = providers.length;\n            emit Online(msg.sender);\n        }\n\n        stakes[msg.sender] += _value;\n        return true;\n    }\n\n    function withdraw(uint256 _value) external returns (bool) {\n        require(stakes[msg.sender] >= _value);\n\n        stakes[msg.sender] -= _value;\n        xrt.safeTransfer(msg.sender, _value);\n\n        // Drop member with zero quota\n        if (quotaOf(msg.sender) == 0) {\n            uint256 balance = stakes[msg.sender];\n            stakes[msg.sender] = 0;\n            xrt.safeTransfer(msg.sender, balance);\n            \n            uint256 senderIndex = indexOf[msg.sender] - 1;\n            uint256 lastIndex = providers.length - 1;\n            if (senderIndex < lastIndex)\n                providers[senderIndex] = providers[lastIndex];\n\n            providers.length -= 1;\n            indexOf[msg.sender] = 0;\n\n            emit Offline(msg.sender);\n        }\n        return true;\n    }\n\n    function keepAliveTransaction() internal {\n        if (timeoutInBlocks < block.number - keepAliveBlock) {\n            // Set up the marker according to provider index\n            marker = indexOf[msg.sender];\n\n            // Thransaction sender should be a registered provider\n            require(marker > 0 && marker <= providers.length);\n\n            // Allocate new quota\n            quota = quotaOf(providers[marker - 1]);\n\n            // Current provider signal\n            emit Current(providers[marker - 1], quota);\n        }\n\n        // Store transaction sending block\n        keepAliveBlock = block.number;\n    }\n\n    function quotedTransaction() internal {\n        // Don't premit transactions without providers on board\n        require(providers.length > 0);\n\n        // Zero quota guard\n        // XXX: When quota for some reasons is zero, DoS will be preverted by keepalive transaction\n        require(quota > 0);\n\n        // Only provider with marker can to send transaction\n        require(msg.sender == providers[marker - 1]);\n\n        // Consume one quota for transaction sending\n        if (quota > 1) {\n            quota -= 1;\n        } else {\n            // Step over marker\n            marker = marker % providers.length + 1;\n\n            // Allocate new quota\n            quota = quotaOf(providers[marker - 1]);\n\n            // Current provider signal\n            emit Current(providers[marker - 1], quota);\n        }\n    }\n\n    function startGas() internal view returns (uint256 gas) {\n        // the total amount of gas the tx is DataFee + TxFee + ExecutionGas\n        // ExecutionGas\n        gas = gasleft();\n        // TxFee\n        gas += 21000;\n        // DataFee\n        for (uint256 i = 0; i < msg.data.length; ++i)\n            gas += msg.data[i] == 0 ? 4 : 68;\n    }\n\n    function createLiability(\n        bytes calldata _demand,\n        bytes calldata _offer\n    )\n        external\n        returns (bool)\n    {\n        // Gas with estimation error\n        uint256 gas = startGas() + 5292;\n\n        keepAliveTransaction();\n        quotedTransaction();\n\n        ILiability liability = factory.createLiability(_demand, _offer);\n        require(liability != ILiability(0));\n        require(factory.liabilityCreated(liability, gas - gasleft()));\n        return true;\n    }\n\n    function finalizeLiability(\n        address _liability,\n        bytes calldata _result,\n        bool _success,\n        bytes calldata _signature\n    )\n        external\n        returns (bool)\n    {\n        // Gas with estimation error\n        uint256 gas = startGas() + 23363;\n\n        keepAliveTransaction();\n        quotedTransaction();\n\n        ILiability liability = ILiability(_liability);\n        require(factory.gasConsumedOf(_liability) > 0);\n        require(liability.finalize(_result, _success, _signature));\n        require(factory.liabilityFinalized(liability, gas - gasleft()));\n        return true;\n    }\n}\n\n// File: contracts/robonomics/interface/IValidator.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Observing network contract interface\n */\ncontract IValidator {\n    /**\n     * @dev Be sure than address is really validator\n     * @return true when validator address in argument\n     */\n    function isValidator(address _validator) external returns (bool);\n}\n\n// File: contracts/robonomics/Liability.sol\n\npragma solidity ^0.5.0;\n\n\n\n\n\n\n\ncontract Liability is ILiability {\n    using ECDSA for bytes32;\n    using SafeERC20 for XRT;\n    using SafeERC20 for ERC20;\n\n    address public factory;\n    XRT     public xrt;\n\n    function setup(XRT _xrt) external returns (bool) {\n        require(factory == address(0));\n\n        factory = msg.sender;\n        xrt     = _xrt;\n\n        return true;\n    }\n\n    function demand(\n        bytes   calldata _model,\n        bytes   calldata _objective,\n\n        address _token,\n        uint256 _cost,\n\n        address _lighthouse,\n\n        address _validator,\n        uint256 _validator_fee,\n\n        uint256 _deadline,\n        address _sender,\n        bytes   calldata _signature\n    )\n        external\n        returns (bool)\n    {\n        require(msg.sender == factory);\n        require(block.number < _deadline);\n\n        model        = _model;\n        objective    = _objective;\n        token        = _token;\n        cost         = _cost;\n        lighthouse   = _lighthouse;\n        validator    = _validator;\n        validatorFee = _validator_fee;\n\n        demandHash = keccak256(abi.encodePacked(\n            _model\n          , _objective\n          , _token\n          , _cost\n          , _lighthouse\n          , _validator\n          , _validator_fee\n          , _deadline\n          , IFactory(factory).nonceOf(_sender)\n          , _sender\n        ));\n\n        promisee = demandHash\n            .toEthSignedMessageHash()\n            .recover(_signature);\n        require(promisee == _sender);\n        return true;\n    }\n\n    function offer(\n        bytes   calldata _model,\n        bytes   calldata _objective,\n        \n        address _token,\n        uint256 _cost,\n\n        address _validator,\n\n        address _lighthouse,\n        uint256 _lighthouse_fee,\n\n        uint256 _deadline,\n        address _sender,\n        bytes   calldata _signature\n    )\n        external\n        returns (bool)\n    {\n        require(msg.sender == factory);\n        require(block.number < _deadline);\n        require(keccak256(model) == keccak256(_model));\n        require(keccak256(objective) == keccak256(_objective));\n        require(_token == token);\n        require(_cost == cost);\n        require(_lighthouse == lighthouse);\n        require(_validator == validator);\n\n        lighthouseFee = _lighthouse_fee;\n\n        offerHash = keccak256(abi.encodePacked(\n            _model\n          , _objective\n          , _token\n          , _cost\n          , _validator\n          , _lighthouse\n          , _lighthouse_fee\n          , _deadline\n          , IFactory(factory).nonceOf(_sender)\n          , _sender\n        ));\n\n        promisor = offerHash\n            .toEthSignedMessageHash()\n            .recover(_signature);\n        require(promisor == _sender);\n        return true;\n    }\n\n    function finalize(\n        bytes calldata _result,\n        bool  _success,\n        bytes calldata _signature\n    )\n        external\n        returns (bool)\n    {\n        require(msg.sender == lighthouse);\n        require(!isFinalized);\n\n        isFinalized = true;\n        result      = _result;\n        isSuccess   = _success;\n\n        address resultSender = keccak256(abi.encodePacked(this, _result, _success))\n            .toEthSignedMessageHash()\n            .recover(_signature);\n\n        if (validator == address(0)) {\n            require(resultSender == promisor);\n        } else {\n            require(IValidator(validator).isValidator(resultSender));\n            // Transfer validator fee when is set\n            if (validatorFee > 0)\n                xrt.safeTransfer(validator, validatorFee);\n\n        }\n\n        if (cost > 0)\n            ERC20(token).safeTransfer(isSuccess ? promisor : promisee, cost);\n\n        emit Finalized(isSuccess, result);\n        return true;\n    }\n}\n\n// File: contracts/robonomics/Factory.sol\n\npragma solidity ^0.5.0;\n\n\n\n\n\n\n\n\n\n\n\ncontract Factory is IFactory, SingletonHash {\n    constructor(\n        address _liability,\n        address _lighthouse,\n        DutchAuction _auction,\n        AbstractENS _ens,\n        XRT _xrt\n    ) public {\n        liabilityCode = _liability;\n        lighthouseCode = _lighthouse;\n        auction = _auction;\n        ens = _ens;\n        xrt = _xrt;\n    }\n\n    address public liabilityCode;\n    address public lighthouseCode;\n\n    using SafeERC20 for XRT;\n    using SafeERC20 for ERC20;\n    using SharedCode for address;\n\n    /**\n     * @dev Robonomics dutch auction contract\n     */\n    DutchAuction public auction;\n\n    /**\n     * @dev Ethereum name system\n     */\n    AbstractENS public ens;\n\n    /**\n     * @dev Robonomics network protocol token\n     */\n    XRT public xrt;\n\n    /**\n     * @dev SMMA filter with function: SMMA(i) = (SMMA(i-1)*(n-1) + PRICE(i)) / n\n     * @param _prePrice PRICE[n-1]\n     * @param _price PRICE[n]\n     * @return filtered price\n     */\n    function smma(uint256 _prePrice, uint256 _price) internal pure returns (uint256) {\n        return (_prePrice * (smmaPeriod - 1) + _price) / smmaPeriod;\n    }\n\n    /**\n     * @dev SMMA filter period\n     */\n    uint256 private constant smmaPeriod = 1000;\n\n    /**\n     * @dev XRT emission value for utilized gas\n     */\n    function wnFromGas(uint256 _gas) public view returns (uint256) {\n        // Just return wn=gas when auction isn't finish\n        if (auction.finalPrice() == 0)\n            return _gas;\n\n        // Current gas utilization epoch\n        uint256 epoch = totalGasConsumed / gasEpoch;\n\n        // XRT emission with addition coefficient by gas utilzation epoch\n        uint256 wn = _gas * 10**9 * gasPrice * 2**epoch / 3**epoch / auction.finalPrice();\n\n        // Check to not permit emission decrease below wn=gas\n        return wn < _gas ? _gas : wn;\n    }\n\n    modifier onlyLighthouse {\n        require(isLighthouse[msg.sender]);\n\n        _;\n    }\n\n    modifier gasPriceEstimate {\n        gasPrice = smma(gasPrice, tx.gasprice);\n\n        _;\n    }\n\n    function createLighthouse(\n        uint256 _minimalStake,\n        uint256 _timeoutInBlocks,\n        string  calldata _name\n    )\n        external\n        returns (ILighthouse lighthouse)\n    {\n        bytes32 LIGHTHOUSE_NODE\n            // lighthouse.5.robonomics.eth\n            = 0x8d6c004b56cbe83bbfd9dcbd8f45d1f76398267bbb130a4629d822abc1994b96;\n        bytes32 hname = keccak256(bytes(_name));\n\n        // Name reservation check\n        bytes32 subnode = keccak256(abi.encodePacked(LIGHTHOUSE_NODE, hname));\n        require(ens.resolver(subnode) == address(0));\n\n        // Create lighthouse\n        lighthouse = ILighthouse(lighthouseCode.proxy());\n        require(Lighthouse(address(lighthouse)).setup(xrt, _minimalStake, _timeoutInBlocks));\n\n        emit NewLighthouse(address(lighthouse), _name);\n        isLighthouse[address(lighthouse)] = true;\n\n        // Register subnode\n        ens.setSubnodeOwner(LIGHTHOUSE_NODE, hname, address(this));\n\n        // Register lighthouse address\n        AbstractResolver resolver = AbstractResolver(ens.resolver(LIGHTHOUSE_NODE));\n        ens.setResolver(subnode, address(resolver));\n        resolver.setAddr(subnode, address(lighthouse));\n    }\n\n    function createLiability(\n        bytes calldata _demand,\n        bytes calldata _offer\n    )\n        external\n        onlyLighthouse\n        returns (ILiability liability)\n    {\n        // Create liability\n        liability = ILiability(liabilityCode.proxy());\n        require(Liability(address(liability)).setup(xrt));\n\n        emit NewLiability(address(liability));\n\n        // Parse messages\n        (bool success, bytes memory returnData)\n            = address(liability).call(abi.encodePacked(bytes4(0x48a984e4), _demand)); // liability.demand(...)\n        require(success);\n        singletonHash(liability.demandHash());\n        nonceOf[liability.promisee()] += 1;\n\n        (success, returnData)\n            = address(liability).call(abi.encodePacked(bytes4(0x413781d2), _offer)); // liability.offer(...)\n        require(success);\n        singletonHash(liability.offerHash());\n        nonceOf[liability.promisor()] += 1;\n\n        // Check lighthouse\n        require(isLighthouse[liability.lighthouse()]);\n\n        // Transfer lighthouse fee to lighthouse worker directly\n        if (liability.lighthouseFee() > 0)\n            xrt.safeTransferFrom(liability.promisor(),\n                                 tx.origin,\n                                 liability.lighthouseFee());\n\n        // Transfer liability security and hold on contract\n        ERC20 token = ERC20(liability.token());\n        if (liability.cost() > 0)\n            token.safeTransferFrom(liability.promisee(),\n                                   address(liability),\n                                   liability.cost());\n\n        // Transfer validator fee and hold on contract\n        if (liability.validator() != address(0) && liability.validatorFee() > 0)\n            xrt.safeTransferFrom(liability.promisee(),\n                                 address(liability),\n                                 liability.validatorFee());\n     }\n\n    function liabilityCreated(\n        ILiability _liability,\n        uint256 _gas\n    )\n        external\n        onlyLighthouse\n        gasPriceEstimate\n        returns (bool)\n    {\n        address liability = address(_liability);\n        totalGasConsumed         += _gas;\n        gasConsumedOf[liability] += _gas;\n        return true;\n    }\n\n    function liabilityFinalized(\n        ILiability _liability,\n        uint256 _gas\n    )\n        external\n        onlyLighthouse\n        gasPriceEstimate\n        returns (bool)\n    {\n        address liability = address(_liability);\n        totalGasConsumed         += _gas;\n        gasConsumedOf[liability] += _gas;\n        require(xrt.mint(tx.origin, wnFromGas(gasConsumedOf[liability])));\n        return true;\n    }\n}",
  "abi": "[{\"constant\":true,\"inputs\":[],\"name\":\"gasEpoch\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"xrt\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ens\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minimalStake\",\"type\":\"uint256\"},{\"name\":\"_timeoutInBlocks\",\"type\":\"uint256\"},{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"createLighthouse\",\"outputs\":[{\"name\":\"lighthouse\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"liabilityCode\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lighthouseCode\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"auction\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"gasConsumedOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_liability\",\"type\":\"address\"},{\"name\":\"_gas\",\"type\":\"uint256\"}],\"name\":\"liabilityFinalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isLighthouse\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_demand\",\"type\":\"bytes\"},{\"name\":\"_offer\",\"type\":\"bytes\"}],\"name\":\"createLiability\",\"outputs\":[{\"name\":\"liability\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_gas\",\"type\":\"uint256\"}],\"name\":\"wnFromGas\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalGasConsumed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"isHashConsumed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gasPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_liability\",\"type\":\"address\"},{\"name\":\"_gas\",\"type\":\"uint256\"}],\"name\":\"liabilityCreated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_liability\",\"type\":\"address\"},{\"name\":\"_lighthouse\",\"type\":\"address\"},{\"name\":\"_auction\",\"type\":\"address\"},{\"name\":\"_ens\",\"type\":\"address\"},{\"name\":\"_xrt\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"HashConsumed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"liability\",\"type\":\"address\"}],\"name\":\"NewLiability\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"lighthouse\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"}],\"name\":\"NewLighthouse\",\"type\":\"event\"}]",
  "bytecode": "608060405260006002556402540be40060045534801561001e57600080fd5b5060405160a0806117c5833981018060405260a081101561003e57600080fd5b508051602082015160408301516060840151608090940151600680546001600160a01b03199081166001600160a01b0396871617909155600780548216948616949094179093556008805484169285169290921790915560098054831694841694909417909355600a805490911691909216179055611703806100c26000396000f3fe608060405234801561001057600080fd5b506004361061010b5760003560e01c8063a51daf26116100a2578063d8fe925011610071578063d8fe925014610355578063ed2a2d641461035d578063fa3260de14610383578063fe173b97146103a0578063feb67918146103a85761010b565b8063a51daf2614610210578063bbb6630f14610250578063d2b962f214610276578063d64d136d146103385761010b565b80635afa47c2116100de5780635afa47c2146101d2578063773fb7fd146101da5780637d9f6db5146101e257806399d5bae1146101ea5761010b565b8063284fd42f14610110578063330f95881461012a5780633f15457f1461014e5780634d5b85f114610156575b600080fd5b6101186103d4565b60408051918252519081900360200190f35b6101326103de565b604080516001600160a01b039092168252519081900360200190f35b6101326103ed565b6101326004803603606081101561016c57600080fd5b81359160208101359181019060608101604082013564010000000081111561019357600080fd5b8201836020820111156101a557600080fd5b803590602001918460018302840111640100000000831117156101c757600080fd5b5090925090506103fc565b610132610810565b61013261081f565b61013261082e565b6101186004803603602081101561020057600080fd5b50356001600160a01b031661083d565b61023c6004803603604081101561022657600080fd5b506001600160a01b03813516906020013561084f565b604080519115158252519081900360200190f35b61023c6004803603602081101561026657600080fd5b50356001600160a01b0316610949565b6101326004803603604081101561028c57600080fd5b8101906020810181356401000000008111156102a757600080fd5b8201836020820111156102b957600080fd5b803590602001918460018302840111640100000000831117156102db57600080fd5b9193909290916020810190356401000000008111156102f957600080fd5b82018360208201111561030b57600080fd5b8035906020019184600183028401116401000000008311171561032d57600080fd5b50909250905061095e565b6101186004803603602081101561034e57600080fd5b503561135b565b6101186114ae565b6101186004803603602081101561037357600080fd5b50356001600160a01b03166114b4565b61023c6004803603602081101561039957600080fd5b50356114c6565b6101186114db565b61023c600480360360408110156103be57600080fd5b506001600160a01b0381351690602001356114e1565b650327ec1e0c0081565b600a546001600160a01b031681565b6009546001600160a01b031681565b6000807f8d6c004b56cbe83bbfd9dcbd8f45d1f76398267bbb130a4629d822abc1994b9660001b905060008484604051808383808284376040805193909101839003832060208085018a905284830182905282518086038401815260608601808552815191830191909120600954600160e01b630178b8bf02909252606487018190529351929950929750600096506001600160a01b03929092169450630178b8bf936084808201945090829003018186803b1580156104bb57600080fd5b505afa1580156104cf573d6000803e3d6000fd5b505050506040513d60208110156104e557600080fd5b50516001600160a01b0316146104fa57600080fd5b60075461050f906001600160a01b031661153b565b600a5460408051600160e01b6364f6f7b90281526001600160a01b039283166004820152602481018c9052604481018b90529051929650908616916364f6f7b9916064808201926020929091908290030181600087803b15801561057257600080fd5b505af1158015610586573d6000803e3d6000fd5b505050506040513d602081101561059c57600080fd5b50516105a757600080fd5b836001600160a01b03167ffea5f888ffd98cd2299e704fb235c2166cb5a9d9d8e9debcc08160626b8019a4878760405180806020018281038252848482818152602001925080828437600083820152604051601f909101601f19169092018290039550909350505050a26001600160a01b03808516600090815260208190526040808220805460ff191660011790556009548151600160e01b6306ab5923028152600481018890526024810187905230604482015291519316926306ab59239260648084019391929182900301818387803b15801561068557600080fd5b505af1158015610699573d6000803e3d6000fd5b505060095460408051600160e01b630178b8bf028152600481018890529051600094506001600160a01b039092169250630178b8bf916024808301926020929190829003018186803b1580156106ee57600080fd5b505afa158015610702573d6000803e3d6000fd5b505050506040513d602081101561071857600080fd5b505160095460408051600160e11b630c4b7b85028152600481018690526001600160a01b0380851660248301529151939450911691631896f70a9160448082019260009290919082900301818387803b15801561077457600080fd5b505af1158015610788573d6000803e3d6000fd5b50505050806001600160a01b031663d5fa2b0083876040518363ffffffff1660e01b815260040180838152602001826001600160a01b03166001600160a01b0316815260200192505050600060405180830381600087803b1580156107ec57600080fd5b505af1158015610800573d6000803e3d6000fd5b5050505050505050949350505050565b6006546001600160a01b031681565b6007546001600160a01b031681565b6008546001600160a01b031681565b60036020526000908152604090205481565b3360009081526020819052604081205460ff1661086b57600080fd5b6108776004543a6115d0565b60045560028054830190556001600160a01b0380841660009081526003602052604090208054840190819055600a54859216906340c10f199032906108bb9061135b565b6040518363ffffffff1660e01b815260040180836001600160a01b03166001600160a01b0316815260200182815260200192505050602060405180830381600087803b15801561090a57600080fd5b505af115801561091e573d6000803e3d6000fd5b505050506040513d602081101561093457600080fd5b505161093f57600080fd5b5060019392505050565b60006020819052908152604090205460ff1681565b3360009081526020819052604081205460ff1661097a57600080fd5b60065461098f906001600160a01b031661153b565b600a5460408051600160e01b6366d382030281526001600160a01b0392831660048201529051929350908316916366d38203916024808201926020929091908290030181600087803b1580156109e457600080fd5b505af11580156109f8573d6000803e3d6000fd5b505050506040513d6020811015610a0e57600080fd5b5051610a1957600080fd5b6040516001600160a01b038216907ff0f0e2354315aae25080baa26761b4ef52d621c91208fb0edde9e3f3fade321990600090a2604051600160e21b63122a613902602082018181526000926060926001600160a01b0386169290918a918a916024018383808284378083019250505093505050506040516020818303038152906040526040518082805190602001908083835b60208310610acc5780518252601f199092019160209182019101610aad565b6001836020036101000a0380198251168184511680821785525050505050509050019150506000604051808303816000865af19150503d8060008114610b2e576040519150601f19603f3d011682016040523d82523d6000602084013e610b33565b606091505b509150915081610b4257600080fd5b610baf836001600160a01b031663f0476bc56040518163ffffffff1660e01b815260040160206040518083038186803b158015610b7e57600080fd5b505afa158015610b92573d6000803e3d6000fd5b505050506040513d6020811015610ba857600080fd5b50516115df565b6001806000856001600160a01b031663474ce8726040518163ffffffff1660e01b815260040160206040518083038186803b158015610bed57600080fd5b505afa158015610c01573d6000803e3d6000fd5b505050506040513d6020811015610c1757600080fd5b50516001600160a01b0390811682526020828101939093526040918201600020805490940190935551600160e11b63209bc0e9029181018281529286169288918891906024018383808284378083019250505093505050506040516020818303038152906040526040518082805190602001908083835b60208310610cad5780518252601f199092019160209182019101610c8e565b6001836020036101000a0380198251168184511680821785525050505050509050019150506000604051808303816000865af19150503d8060008114610d0f576040519150601f19603f3d011682016040523d82523d6000602084013e610d14565b606091505b50909250905081610d2457600080fd5b610d60836001600160a01b031663699373ca6040518163ffffffff1660e01b815260040160206040518083038186803b158015610b7e57600080fd5b6001806000856001600160a01b031663c2d8de546040518163ffffffff1660e01b815260040160206040518083038186803b158015610d9e57600080fd5b505afa158015610db2573d6000803e3d6000fd5b505050506040513d6020811015610dc857600080fd5b50516001600160a01b0390811682526020828101939093526040918201600090812080549095019094558151600160e01b636301fd630281529151849391881692636301fd63926004808301939192829003018186803b158015610e2b57600080fd5b505afa158015610e3f573d6000803e3d6000fd5b505050506040513d6020811015610e5557600080fd5b50516001600160a01b0316815260208101919091526040016000205460ff16610e7d57600080fd5b6000836001600160a01b031663051064c66040518163ffffffff1660e01b815260040160206040518083038186803b158015610eb857600080fd5b505afa158015610ecc573d6000803e3d6000fd5b505050506040513d6020811015610ee257600080fd5b50511115610fde57610fde836001600160a01b031663c2d8de546040518163ffffffff1660e01b815260040160206040518083038186803b158015610f2657600080fd5b505afa158015610f3a573d6000803e3d6000fd5b505050506040513d6020811015610f5057600080fd5b505160408051600160e11b6302883263028152905132916001600160a01b0388169163051064c691600480820192602092909190829003018186803b158015610f9857600080fd5b505afa158015610fac573d6000803e3d6000fd5b505050506040513d6020811015610fc257600080fd5b5051600a546001600160a01b031692919063ffffffff61163e16565b6000836001600160a01b031663fc0c546a6040518163ffffffff1660e01b815260040160206040518083038186803b15801561101957600080fd5b505afa15801561102d573d6000803e3d6000fd5b505050506040513d602081101561104357600080fd5b505160408051600160e11b6309fd76f302815290519192506000916001600160a01b038716916313faede6916004808301926020929190829003018186803b15801561108e57600080fd5b505afa1580156110a2573d6000803e3d6000fd5b505050506040513d60208110156110b857600080fd5b505111156111b2576111b2846001600160a01b031663474ce8726040518163ffffffff1660e01b815260040160206040518083038186803b1580156110fc57600080fd5b505afa158015611110573d6000803e3d6000fd5b505050506040513d602081101561112657600080fd5b505160408051600160e11b6309fd76f3028152905187916001600160a01b038316916313faede691600480820192602092909190829003018186803b15801561116e57600080fd5b505afa158015611182573d6000803e3d6000fd5b505050506040513d602081101561119857600080fd5b50516001600160a01b03851692919063ffffffff61163e16565b60006001600160a01b0316846001600160a01b0316633a5381b56040518163ffffffff1660e01b815260040160206040518083038186803b1580156111f657600080fd5b505afa15801561120a573d6000803e3d6000fd5b505050506040513d602081101561122057600080fd5b50516001600160a01b03161480159061129d57506000846001600160a01b0316633f6d82566040518163ffffffff1660e01b815260040160206040518083038186803b15801561126f57600080fd5b505afa158015611283573d6000803e3d6000fd5b505050506040513d602081101561129957600080fd5b5051115b1561135057611350846001600160a01b031663474ce8726040518163ffffffff1660e01b815260040160206040518083038186803b1580156112de57600080fd5b505afa1580156112f2573d6000803e3d6000fd5b505050506040513d602081101561130857600080fd5b505160408051600160e11b631fb6c12b028152905187916001600160a01b03831691633f6d825691600480820192602092909190829003018186803b158015610f9857600080fd5b505050949350505050565b60085460408051600160e11b63535a89f702815290516000926001600160a01b03169163a6b513ee916004808301926020929190829003018186803b1580156113a357600080fd5b505afa1580156113b7573d6000803e3d6000fd5b505050506040513d60208110156113cd57600080fd5b50516113da5750806114a9565b6000650327ec1e0c00600254816113ed57fe5b0490506000600860009054906101000a90046001600160a01b03166001600160a01b031663a6b513ee6040518163ffffffff1660e01b815260040160206040518083038186803b15801561144057600080fd5b505afa158015611454573d6000803e3d6000fd5b505050506040513d602081101561146a57600080fd5b5051600454600384900a908602600285900a02633b9aca00028161148a57fe5b048161149257fe5b0490508381106114a257806114a4565b835b925050505b919050565b60025481565b60016020526000908152604090205481565b60056020526000908152604090205460ff1681565b60045481565b3360009081526020819052604081205460ff166114fd57600080fd5b6115096004543a6115d0565b6004555060028054820190556001600160a01b0382166000908152600360205260409020805482019055600192915050565b604080517f603160008181600b9039f36000808080803680928037730000000000000000006020808301919091526001600160a01b03841660601b60378301527f5af43d828181803e808314603057f35bfd000000000000000000000000000000604b8301528251603c81840381018252605c9093019093526000929190820183f09150813b6115ca57600080fd5b50919050565b6103e86103e792909202010490565b60008181526005602052604090205460ff16156115fb57600080fd5b600081815260056020526040808220805460ff191660011790555182917fff8bad61d8f2eaa50a98cc8d31de285608e5a904d330f193043d6c9854e2586d91a250565b60408051600160e01b6323b872dd0281526001600160a01b0385811660048301528481166024830152604482018490529151918616916323b872dd916064808201926020929091908290030181600087803b15801561169c57600080fd5b505af11580156116b0573d6000803e3d6000fd5b505050506040513d60208110156116c657600080fd5b50516116d157600080fd5b5050505056fea165627a7a72305820e4bde616e53d570190b801942c7172857b11861198d0e196a86e47a393c3e0800029000000000000000000000000f2713688e9c1d8dbd937413b18db1b4f134b3f82000000000000000000000000a5cf968690739cfed4bfb00d47f0ee7c32f703dc000000000000000000000000f396de9a6b0a9f29e01e28e4d61c68eaf5448514000000000000000000000000314159265dd8dbb310642f98f50c066173c1259b00000000000000000000000052a175413b99ee49b7a743226ddade4f97f161fb",
  "constructorArguments": "000000000000000000000000f2713688e9c1d8dbd937413b18db1b4f134b3f82000000000000000000000000a5cf968690739cfed4bfb00d47f0ee7c32f703dc000000000000000000000000f396de9a6b0a9f29e01e28e4d61c68eaf5448514000000000000000000000000314159265dd8dbb310642f98f50c066173c1259b00000000000000000000000052a175413b99ee49b7a743226ddade4f97f161fb"
}