{
  "address": "0x08c0bc283682a314f3dce5b3ee52119d3d534daa",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "MokenMintingByCredit",
  "compilerVersion": "v0.4.24+commit.e67f0147",
  "optimization": true,
  "runs": "999",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2019-04-06\n*/\n\npragma solidity 0.4.24;\npragma experimental \"v0.5.0\";\n/******************************************************************************\\\n* Author: Nick Mudge, [emailÂ protected]\n* Mokens\n* Copyright (c) 2019\n*\n* Minting mokens with credit.\n/******************************************************************************/\n///////////////////////////////////////////////////////////////////////////////////\n//Storage contracts\n////////////\n//Some delegate contracts are listed with storage contracts they inherit.\n///////////////////////////////////////////////////////////////////////////////////\n\n///////////////////////////////////////////////////////////////////////////////////\n//Mokens\n///////////////////////////////////////////////////////////////////////////////////\ncontract Storage0 {\n    // funcId => delegate contract\n    mapping(bytes4 => address) internal delegates;\n}\n///////////////////////////////////////////////////////////////////////////////////\n//MokenUpdates\n//MokenOwner\n//QueryMokenDelegates\n///////////////////////////////////////////////////////////////////////////////////\ncontract Storage1 is Storage0 {\n    address internal contractOwner;\n    bytes[] internal funcSignatures;\n    // signature => index+1\n    mapping(bytes => uint256) internal funcSignatureToIndex;\n}\n///////////////////////////////////////////////////////////////////////////////////\n//MokensSupportsInterfaces\n///////////////////////////////////////////////////////////////////////////////////\ncontract Storage2 is Storage1 {\n    mapping(bytes4 => bool) internal supportedInterfaces;\n}\n///////////////////////////////////////////////////////////////////////////////////\n//MokenRootOwnerOf\n//MokenERC721Metadata\n///////////////////////////////////////////////////////////////////////////////////\ncontract Storage3 is Storage2 {\n    struct Moken {\n        string name;\n        uint256 data;\n        uint256 parentTokenId;\n    }\n    //tokenId => moken\n    mapping(uint256 => Moken) internal mokens;\n    uint256 internal mokensLength;\n    // child address => child tokenId => tokenId+1\n    mapping(address => mapping(uint256 => uint256)) internal childTokenOwner;\n}\n///////////////////////////////////////////////////////////////////////////////////\n//MokenERC721Enumerable\n//MokenLinkHash\n///////////////////////////////////////////////////////////////////////////////////\ncontract Storage4 is Storage3 {\n    // root token owner address => (tokenId => approved address)\n    mapping(address => mapping(uint256 => address)) internal rootOwnerAndTokenIdToApprovedAddress;\n    // token owner => (operator address => bool)\n    mapping(address => mapping(address => bool)) internal tokenOwnerToOperators;\n    // Mapping from owner to list of owned token IDs\n    mapping(address => uint32[]) internal ownedTokens;\n}\n///////////////////////////////////////////////////////////////////////////////////\n//MokenERC998ERC721TopDown\n//MokenERC998ERC721TopDownBatch\n//MokenERC721\n//MokenERC721Batch\n///////////////////////////////////////////////////////////////////////////////////\ncontract Storage5 is Storage4 {\n    // tokenId => (child address => array of child tokens)\n    mapping(uint256 => mapping(address => uint256[])) internal childTokens;\n    // tokenId => (child address => (child token => child index)\n    mapping(uint256 => mapping(address => mapping(uint256 => uint256))) internal childTokenIndex;\n    // tokenId => (child address => contract index)\n    mapping(uint256 => mapping(address => uint256)) internal childContractIndex;\n    // tokenId => child contract\n    mapping(uint256 => address[]) internal childContracts;\n}\n///////////////////////////////////////////////////////////////////////////////////\n//MokenERC998ERC20TopDown\n//MokenStateChange\n///////////////////////////////////////////////////////////////////////////////////\ncontract Storage6 is Storage5 {\n    // tokenId => token contract\n    mapping(uint256 => address[]) internal erc20Contracts;\n    // tokenId => (token contract => token contract index)\n    mapping(uint256 => mapping(address => uint256)) erc20ContractIndex;\n    // tokenId => (token contract => balance)\n    mapping(uint256 => mapping(address => uint256)) internal erc20Balances;\n}\n///////////////////////////////////////////////////////////////////////////////////\n//MokenERC998ERC721BottomUp\n//MokenERC998ERC721BottomUpBatch\n///////////////////////////////////////////////////////////////////////////////////\ncontract Storage7 is Storage6 {\n    // parent address => (parent tokenId => array of child tokenIds)\n    mapping(address => mapping(uint256 => uint32[])) internal parentToChildTokenIds;\n    // tokenId => position in childTokens array\n    mapping(uint256 => uint256) internal tokenIdToChildTokenIdsIndex;\n}\n///////////////////////////////////////////////////////////////////////////////////\n//MokenMinting\n//MokenMintContractManagement\n//MokenEras\n//QueryMokenData\n///////////////////////////////////////////////////////////////////////////////////\ncontract Storage8 is Storage7 {\n    // index => category\n    mapping(uint256 => bytes32) internal categories;\n    uint256 internal categoryLength;\n    // category => index+1\n    mapping(bytes32 => uint256) internal categoryIndex;\n    uint256 internal mintPriceOffset; // = 0 szabo;\n    uint256 internal mintStepPrice; // = 500 szabo;\n    uint256 internal mintPriceBuffer; // = 5000 szabo;\n    address[] internal permissionsList;\n    // Order is from right to left\n    // 0 bit is permission to give permission\n    // 1 bit is permission to mint\n    mapping(address => uint256) internal permissions;\n    //moken name => tokenId+1\n    mapping(string => uint256) internal tokenByName_;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// MokenCredit\n///////////////////////////////////////////////////////////////////////////////////\ncontract Storage9 is Storage8 {\n    // molder => wei\n    mapping(address => uint256) internal credit;\n\n    // categoryIndex >> mint price\n    mapping(uint256 => uint256) internal categoryMintPrice;\n}\n\ncontract MokenMintingByCredit is Storage9 {\n\n    uint256 constant MAX_MOKENS = 4294967296;\n    uint256 constant MAX_OWNER_MOKENS = 65536;\n    uint256 constant MOKEN_LINK_HASH_MASK = 0xffffffffffffffff000000000000000000000000000000000000000000000000;\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    event Mint(\n        address indexed mintContract,\n        address indexed owner,\n        bytes32 indexed category,\n        string mokenName,\n        bytes32 data,\n        uint256 tokenId,\n        bytes32 currencyName,\n        uint256 price\n    );\n\n    function mintInfo(address _address, bytes32 _category) external view returns (uint256 balance, uint256 mintPrice){\n        balance = credit[_address];\n        uint256 index = categoryIndex[_category];\n        require(index != 0, \"No category exists with this name.\");\n        mintPrice = categoryMintPrice[index-1];\n    }\n\n    function mint(address _tokenOwner, string _mokenName, bytes32 _category, bytes32 _linkHash) external returns (uint256 tokenId) {\n        require((permissions[msg.sender] >> 1) & 1 == 1, \"Only a minter can call this function.\");\n\n        require(_tokenOwner != address(0), \"Owner cannot be the 0 address.\");\n\n        tokenId = mokensLength++;\n        // prevents 32 bit overflow\n        require(tokenId < MAX_MOKENS, \"Only 4,294,967,296 mokens can be created.\");\n\n        //Was enough ether passed in?\n        uint256 categoryIndex = categoryIndex[_category];\n        require(categoryIndex != 0, \"No category exists with this name.\");\n        categoryIndex--;\n        uint256 currentMintPrice = categoryMintPrice[categoryIndex];\n        uint256 creditBalance = credit[_tokenOwner];\n        uint256 ownedTokensIndex = ownedTokens[_tokenOwner].length;\n        if(creditBalance >= currentMintPrice) {\n            credit[_tokenOwner] = creditBalance - currentMintPrice;\n        }\n        else {\n            credit[_tokenOwner] = 0;\n        }\n\n        string memory lowerMokenName = validateAndLower(_mokenName);\n        require(tokenByName_[lowerMokenName] == 0, \"Moken name already exists.\");\n\n        // prevents 16 bit overflow\n        require(ownedTokensIndex < MAX_OWNER_MOKENS, \"An single owner address cannot possess more than 65,536 mokens.\");\n\n        // adding the current category index, ownedTokenIndex and owner address to data\n        // this saves gas for each mint.\n        uint256 data = uint256(_linkHash) & MOKEN_LINK_HASH_MASK | categoryIndex << 176 | ownedTokensIndex << 160 | uint160(_tokenOwner);\n\n        // create moken\n        mokens[tokenId].name = _mokenName;\n        mokens[tokenId].data = data;\n        tokenByName_[lowerMokenName] = tokenId + 1;\n\n        //add moken to the specific owner\n        ownedTokens[_tokenOwner].push(uint32(tokenId));\n\n        //emit events\n        emit Transfer(address(0), _tokenOwner, tokenId);\n        emit Mint(address(this), _tokenOwner, _category, _mokenName, bytes32(data), tokenId, \"Ether\", currentMintPrice);\n\n        return tokenId;\n    }\n\n\n    function validateAndLower(string memory _s) internal pure returns (string memory mokenName) {\n        assembly {\n        // get length of _s\n            let len := mload(_s)\n        // get position of _s\n            let p := add(_s, 0x20)\n        // _s cannot be 0 characters\n            if eq(len, 0) {\n                revert(0, 0)\n            }\n        // _s cannot be more than 100 characters\n            if gt(len, 100) {\n                revert(0, 0)\n            }\n        // get first character\n            let b := byte(0, mload(add(_s, 0x20)))\n        // first character cannot be whitespace/unprintable\n            if lt(b, 0x21) {\n                revert(0, 0)\n            }\n        // get last character\n            b := byte(0, mload(add(p, sub(len, 1))))\n        // last character cannot be whitespace/unprintable\n            if lt(b, 0x21) {\n                revert(0, 0)\n            }\n        // loop through _s and lowercase uppercase characters\n            for {let end := add(p, len)}\n            lt(p, end)\n            {p := add(p, 1)}\n            {\n                b := byte(0, mload(p))\n                if lt(b, 0x5b) {\n                    if gt(b, 0x40) {\n                        mstore8(p, add(b, 32))\n                    }\n                }\n            }\n        }\n        return _s;\n    }\n}",
  "abi": "[{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_category\",\"type\":\"bytes32\"}],\"name\":\"mintInfo\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"mintPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenOwner\",\"type\":\"address\"},{\"name\":\"_mokenName\",\"type\":\"string\"},{\"name\":\"_category\",\"type\":\"bytes32\"},{\"name\":\"_linkHash\",\"type\":\"bytes32\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"mintContract\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"category\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"mokenName\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"currencyName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"}]",
  "bytecode": "608060405234801561001057600080fd5b50610b18806100206000396000f30060806040526004361061004b5763ffffffff7c01000000000000000000000000000000000000000000000000000000006000350416631e22b8818114610050578063a79992381461009a575b600080fd5b34801561005c57600080fd5b5061008173ffffffffffffffffffffffffffffffffffffffff600435166024356100ec565b6040805192835260208301919091528051918290030190f35b3480156100a657600080fd5b506100da6004803573ffffffffffffffffffffffffffffffffffffffff1690602480359081019101356044356064356101d5565b60408051918252519081900360200190f35b73ffffffffffffffffffffffffffffffffffffffff82166000908152601d602090815260408083205484845260169092528220549091908015156101b757604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602260248201527f4e6f2063617465676f72792065786973747320776974682074686973206e616d60448201527f652e000000000000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b600019016000908152601e6020526040902054919491935090915050565b336000908152601b6020526040812054819081908190819060609082906002900460019081161461028d57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602560248201527f4f6e6c792061206d696e7465722063616e2063616c6c20746869732066756e6360448201527f74696f6e2e000000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b73ffffffffffffffffffffffffffffffffffffffff8c16151561031157604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601e60248201527f4f776e65722063616e6e6f7420626520746865203020616464726573732e0000604482015290519081900360640190fd5b6006805460018101909155965064010000000087106103b757604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602960248201527f4f6e6c7920342c3239342c3936372c323936206d6f6b656e732063616e20626560448201527f20637265617465642e0000000000000000000000000000000000000000000000606482015290519081900360840190fd5b600089815260166020526040902054955085151561045c57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602260248201527f4e6f2063617465676f72792065786973747320776974682074686973206e616d60448201527f652e000000000000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b858060019003965050601e6000878152602001908152602001600020549450601d60008d73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549350600a60008d73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020805490509250848410151561053a5773ffffffffffffffffffffffffffffffffffffffff8c166000908152601d602052604090208585039055610561565b73ffffffffffffffffffffffffffffffffffffffff8c166000908152601d60205260408120555b61059a8b8b8080601f016020809104026020016040519081016040528093929190818152602001838380828437506109bc945050505050565b9150601c826040518082805190602001908083835b602083106105ce5780518252601f1990920191602091820191016105af565b51815160209384036101000a600019018019909216911617905292019485525060405193849003019092205415915061066a905057604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601a60248201527f4d6f6b656e206e616d6520616c7265616479206578697374732e000000000000604482015290519081900360640190fd5b62010000831061070157604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603f60248201527f416e2073696e676c65206f776e657220616464726573732063616e6e6f74207060448201527f6f7373657373206d6f7265207468616e2036352c353336206d6f6b656e732e00606482015290519081900360840190fd5b5060008681526005602052604090207fffffffffffffffff00000000000000000000000000000000000000000000000088167601000000000000000000000000000000000000000000008702177401000000000000000000000000000000000000000084021773ffffffffffffffffffffffffffffffffffffffff8d16179061078b908c8c610a51565b5080600560008981526020019081526020016000206001018190555086600101601c836040518082805190602001908083835b602083106107dd5780518252601f1990920191602091820191016107be565b6001836020036101000a038019825116818451168082178552505050505050905001915050908152602001604051809103902081905550600a60008d73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002087908060018154018082558091505090600182039060005260206000209060089182820401919006600402909192909190916101000a81548163ffffffff021916908363ffffffff16021790555050868c73ffffffffffffffffffffffffffffffffffffffff16600073ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef60405160405180910390a460408051602081018390529081018890527f457468657200000000000000000000000000000000000000000000000000000060608201526080810186905260a080825281018b9052899073ffffffffffffffffffffffffffffffffffffffff8e169030907f4f5deb80fdeba40173210414430f34a873aa31bd90b2e16d5ef16390381f6a3f908f908f9087908e908d908060c0810187878082843760405192018290039850909650505050505050a450505050505095945050505050565b606081516020830160008214156109d257600080fd5b60648211156109e057600080fd5b602084015160001a60218110156109f657600080fd5b50808201600019015160001a6021811015610a1057600080fd5b8282015b80831015610a4757825160001a9150605b821015610a3c576040821115610a3c576020820183535b600183019250610a14565b5093949350505050565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f10610a925782800160ff19823516178555610abf565b82800160010185558215610abf579182015b82811115610abf578235825591602001919060010190610aa4565b50610acb929150610acf565b5090565b610ae991905b80821115610acb5760008155600101610ad5565b905600a165627a7a72305820a77337fa75737a00f00394101f3b183bfa8f54fe287cc00eaec81ea5e50c655a0029"
}