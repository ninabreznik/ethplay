{
  "address": "0x5a0e27020fa22adab2e81495025bef3fab7821fd",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "QuantstampAudit",
  "compilerVersion": "v0.4.25+commit.59dbf8f1",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2019-06-07\n*/\n\npragma solidity 0.4.25;\n\n// File: contracts/LinkedListLib.sol\n\n/**\n * @title LinkedListLib\n * @author Darryl Morris (o0ragman0o) and Modular.network\n *\n * This utility library was forked from https://github.com/o0ragman0o/LibCLL\n * into the Modular-Network ethereum-libraries repo at https://github.com/Modular-Network/ethereum-libraries\n * It has been updated to add additional functionality and be more compatible with solidity 0.4.18\n * coding patterns.\n *\n * version 1.1.1\n * Copyright (c) 2017 Modular Inc.\n * The MIT License (MIT)\n * https://github.com/Modular-network/ethereum-libraries/blob/master/LICENSE\n *\n * The LinkedListLib provides functionality for implementing data indexing using\n * a circlular linked list\n *\n * Modular provides smart contract services and security reviews for contract\n * deployments in addition to working on open source projects in the Ethereum\n * community. Our purpose is to test, document, and deploy reusable code onto the\n * blockchain and improve both security and usability. We also educate non-profits,\n * schools, and other community members about the application of blockchain\n * technology. For further information: modular.network\n *\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n\nlibrary LinkedListLib {\n\n    uint256 constant NULL = 0;\n    uint256 constant HEAD = 0;\n    bool constant PREV = false;\n    bool constant NEXT = true;\n\n    struct LinkedList{\n        mapping (uint256 => mapping (bool => uint256)) list;\n    }\n\n    /// @dev returns true if the list exists\n    /// @param self stored linked list from contract\n    function listExists(LinkedList storage self)\n        public\n        view returns (bool)\n    {\n        // if the head nodes previous or next pointers both point to itself, then there are no items in the list\n        if (self.list[HEAD][PREV] != HEAD || self.list[HEAD][NEXT] != HEAD) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /// @dev returns true if the node exists\n    /// @param self stored linked list from contract\n    /// @param _node a node to search for\n    function nodeExists(LinkedList storage self, uint256 _node)\n        public\n        view returns (bool)\n    {\n        if (self.list[_node][PREV] == HEAD && self.list[_node][NEXT] == HEAD) {\n            if (self.list[HEAD][NEXT] == _node) {\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /// @dev Returns the number of elements in the list\n    /// @param self stored linked list from contract\n    function sizeOf(LinkedList storage self) public view returns (uint256 numElements) {\n        bool exists;\n        uint256 i;\n        (exists,i) = getAdjacent(self, HEAD, NEXT);\n        while (i != HEAD) {\n            (exists,i) = getAdjacent(self, i, NEXT);\n            numElements++;\n        }\n        return;\n    }\n\n    /// @dev Returns the links of a node as a tuple\n    /// @param self stored linked list from contract\n    /// @param _node id of the node to get\n    function getNode(LinkedList storage self, uint256 _node)\n        public view returns (bool,uint256,uint256)\n    {\n        if (!nodeExists(self,_node)) {\n            return (false,0,0);\n        } else {\n            return (true,self.list[_node][PREV], self.list[_node][NEXT]);\n        }\n    }\n\n    /// @dev Returns the link of a node `_node` in direction `_direction`.\n    /// @param self stored linked list from contract\n    /// @param _node id of the node to step from\n    /// @param _direction direction to step in\n    function getAdjacent(LinkedList storage self, uint256 _node, bool _direction)\n        public view returns (bool,uint256)\n    {\n        if (!nodeExists(self,_node)) {\n            return (false,0);\n        } else {\n            return (true,self.list[_node][_direction]);\n        }\n    }\n\n    /// @dev Can be used before `insert` to build an ordered list\n    /// @param self stored linked list from contract\n    /// @param _node an existing node to search from, e.g. HEAD.\n    /// @param _value value to seek\n    /// @param _direction direction to seek in\n    //  @return next first node beyond '_node' in direction `_direction`\n    function getSortedSpot(LinkedList storage self, uint256 _node, uint256 _value, bool _direction)\n        public view returns (uint256)\n    {\n        if (sizeOf(self) == 0) { return 0; }\n        require((_node == 0) || nodeExists(self,_node));\n        bool exists;\n        uint256 next;\n        (exists,next) = getAdjacent(self, _node, _direction);\n        while  ((next != 0) && (_value != next) && ((_value < next) != _direction)) next = self.list[next][_direction];\n        return next;\n    }\n\n    /// @dev Creates a bidirectional link between two nodes on direction `_direction`\n    /// @param self stored linked list from contract\n    /// @param _node first node for linking\n    /// @param _link  node to link to in the _direction\n    function createLink(LinkedList storage self, uint256 _node, uint256 _link, bool _direction) private  {\n        self.list[_link][!_direction] = _node;\n        self.list[_node][_direction] = _link;\n    }\n\n    /// @dev Insert node `_new` beside existing node `_node` in direction `_direction`.\n    /// @param self stored linked list from contract\n    /// @param _node existing node\n    /// @param _new  new node to insert\n    /// @param _direction direction to insert node in\n    function insert(LinkedList storage self, uint256 _node, uint256 _new, bool _direction) internal returns (bool) {\n        if(!nodeExists(self,_new) && nodeExists(self,_node)) {\n            uint256 c = self.list[_node][_direction];\n            createLink(self, _node, _new, _direction);\n            createLink(self, _new, c, _direction);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /// @dev removes an entry from the linked list\n    /// @param self stored linked list from contract\n    /// @param _node node to remove from the list\n    function remove(LinkedList storage self, uint256 _node) internal returns (uint256) {\n        if ((_node == NULL) || (!nodeExists(self,_node))) { return 0; }\n        createLink(self, self.list[_node][PREV], self.list[_node][NEXT], NEXT);\n        delete self.list[_node][PREV];\n        delete self.list[_node][NEXT];\n        return _node;\n    }\n\n    /// @dev pushes an enrty to the head of the linked list\n    /// @param self stored linked list from contract\n    /// @param _node new entry to push to the head\n    /// @param _direction push to the head (NEXT) or tail (PREV)\n    function push(LinkedList storage self, uint256 _node, bool _direction) internal  {\n        insert(self, HEAD, _node, _direction);\n    }\n\n    /// @dev pops the first entry from the linked list\n    /// @param self stored linked list from contract\n    /// @param _direction pop from the head (NEXT) or the tail (PREV)\n    function pop(LinkedList storage self, bool _direction) internal returns (uint256) {\n        bool exists;\n        uint256 adj;\n\n        (exists,adj) = getAdjacent(self, HEAD, _direction);\n\n        return remove(self, adj);\n    }\n}\n\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipRenounced(address indexed previousOwner);\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to relinquish control of the contract.\n   */\n  function renounceOwnership() public onlyOwner {\n    emit OwnershipRenounced(owner);\n    owner = address(0);\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address _newOwner) public onlyOwner {\n    _transferOwnership(_newOwner);\n  }\n\n  /**\n   * @dev Transfers control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function _transferOwnership(address _newOwner) internal {\n    require(_newOwner != address(0));\n    emit OwnershipTransferred(owner, _newOwner);\n    owner = _newOwner;\n  }\n}\n\n// File: openzeppelin-solidity/contracts/ownership/rbac/Roles.sol\n\n/**\n * @title Roles\n * @author Francisco Giordano (@frangio)\n * @dev Library for managing addresses assigned to a Role.\n *      See RBAC.sol for example usage.\n */\nlibrary Roles {\n  struct Role {\n    mapping (address => bool) bearer;\n  }\n\n  /**\n   * @dev give an address access to this role\n   */\n  function add(Role storage role, address addr)\n    internal\n  {\n    role.bearer[addr] = true;\n  }\n\n  /**\n   * @dev remove an address' access to this role\n   */\n  function remove(Role storage role, address addr)\n    internal\n  {\n    role.bearer[addr] = false;\n  }\n\n  /**\n   * @dev check if an address has this role\n   * // reverts\n   */\n  function check(Role storage role, address addr)\n    view\n    internal\n  {\n    require(has(role, addr));\n  }\n\n  /**\n   * @dev check if an address has this role\n   * @return bool\n   */\n  function has(Role storage role, address addr)\n    view\n    internal\n    returns (bool)\n  {\n    return role.bearer[addr];\n  }\n}\n\n// File: openzeppelin-solidity/contracts/ownership/rbac/RBAC.sol\n\n/**\n * @title RBAC (Role-Based Access Control)\n * @author Matt Condon (@Shrugs)\n * @dev Stores and provides setters and getters for roles and addresses.\n * @dev Supports unlimited numbers of roles and addresses.\n * @dev See //contracts/mocks/RBACMock.sol for an example of usage.\n * This RBAC method uses strings to key roles. It may be beneficial\n *  for you to write your own implementation of this interface using Enums or similar.\n * It's also recommended that you define constants in the contract, like ROLE_ADMIN below,\n *  to avoid typos.\n */\ncontract RBAC {\n  using Roles for Roles.Role;\n\n  mapping (string => Roles.Role) private roles;\n\n  event RoleAdded(address addr, string roleName);\n  event RoleRemoved(address addr, string roleName);\n\n  /**\n   * @dev reverts if addr does not have role\n   * @param addr address\n   * @param roleName the name of the role\n   * // reverts\n   */\n  function checkRole(address addr, string roleName)\n    view\n    public\n  {\n    roles[roleName].check(addr);\n  }\n\n  /**\n   * @dev determine if addr has role\n   * @param addr address\n   * @param roleName the name of the role\n   * @return bool\n   */\n  function hasRole(address addr, string roleName)\n    view\n    public\n    returns (bool)\n  {\n    return roles[roleName].has(addr);\n  }\n\n  /**\n   * @dev add a role to an address\n   * @param addr address\n   * @param roleName the name of the role\n   */\n  function addRole(address addr, string roleName)\n    internal\n  {\n    roles[roleName].add(addr);\n    emit RoleAdded(addr, roleName);\n  }\n\n  /**\n   * @dev remove a role from an address\n   * @param addr address\n   * @param roleName the name of the role\n   */\n  function removeRole(address addr, string roleName)\n    internal\n  {\n    roles[roleName].remove(addr);\n    emit RoleRemoved(addr, roleName);\n  }\n\n  /**\n   * @dev modifier to scope access to a single role (uses msg.sender as addr)\n   * @param roleName the name of the role\n   * // reverts\n   */\n  modifier onlyRole(string roleName)\n  {\n    checkRole(msg.sender, roleName);\n    _;\n  }\n\n  /**\n   * @dev modifier to scope access to a set of roles (uses msg.sender as addr)\n   * @param roleNames the names of the roles to scope access to\n   * // reverts\n   *\n   * @TODO - when solidity supports dynamic arrays as arguments to modifiers, provide this\n   *  see: https://github.com/ethereum/solidity/issues/2467\n   */\n  // modifier onlyRoles(string[] roleNames) {\n  //     bool hasAnyRole = false;\n  //     for (uint8 i = 0; i < roleNames.length; i++) {\n  //         if (hasRole(msg.sender, roleNames[i])) {\n  //             hasAnyRole = true;\n  //             break;\n  //         }\n  //     }\n\n  //     require(hasAnyRole);\n\n  //     _;\n  // }\n}\n\n// File: openzeppelin-solidity/contracts/ownership/Whitelist.sol\n\n/**\n * @title Whitelist\n * @dev The Whitelist contract has a whitelist of addresses, and provides basic authorization control functions.\n * @dev This simplifies the implementation of \"user permissions\".\n */\ncontract Whitelist is Ownable, RBAC {\n  event WhitelistedAddressAdded(address addr);\n  event WhitelistedAddressRemoved(address addr);\n\n  string public constant ROLE_WHITELISTED = \"whitelist\";\n\n  /**\n   * @dev Throws if called by any account that's not whitelisted.\n   */\n  modifier onlyWhitelisted() {\n    checkRole(msg.sender, ROLE_WHITELISTED);\n    _;\n  }\n\n  /**\n   * @dev add an address to the whitelist\n   * @param addr address\n   * @return true if the address was added to the whitelist, false if the address was already in the whitelist\n   */\n  function addAddressToWhitelist(address addr)\n    onlyOwner\n    public\n  {\n    addRole(addr, ROLE_WHITELISTED);\n    emit WhitelistedAddressAdded(addr);\n  }\n\n  /**\n   * @dev getter to determine if address is in whitelist\n   */\n  function whitelist(address addr)\n    public\n    view\n    returns (bool)\n  {\n    return hasRole(addr, ROLE_WHITELISTED);\n  }\n\n  /**\n   * @dev add addresses to the whitelist\n   * @param addrs addresses\n   * @return true if at least one address was added to the whitelist,\n   * false if all addresses were already in the whitelist\n   */\n  function addAddressesToWhitelist(address[] addrs)\n    onlyOwner\n    public\n  {\n    for (uint256 i = 0; i < addrs.length; i++) {\n      addAddressToWhitelist(addrs[i]);\n    }\n  }\n\n  /**\n   * @dev remove an address from the whitelist\n   * @param addr address\n   * @return true if the address was removed from the whitelist,\n   * false if the address wasn't in the whitelist in the first place\n   */\n  function removeAddressFromWhitelist(address addr)\n    onlyOwner\n    public\n  {\n    removeRole(addr, ROLE_WHITELISTED);\n    emit WhitelistedAddressRemoved(addr);\n  }\n\n  /**\n   * @dev remove addresses from the whitelist\n   * @param addrs addresses\n   * @return true if at least one address was removed from the whitelist,\n   * false if all addresses weren't in the whitelist in the first place\n   */\n  function removeAddressesFromWhitelist(address[] addrs)\n    onlyOwner\n    public\n  {\n    for (uint256 i = 0; i < addrs.length; i++) {\n      removeAddressFromWhitelist(addrs[i]);\n    }\n  }\n\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/BasicToken.sol\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    emit Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256) {\n    return balances[_owner];\n  }\n\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender)\n    public view returns (uint256);\n\n  function transferFrom(address from, address to, uint256 value)\n    public returns (bool);\n\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/StandardToken.sol\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  )\n    public\n    returns (bool)\n  {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    emit Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    emit Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(\n    address _owner,\n    address _spender\n   )\n    public\n    view\n    returns (uint256)\n  {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(\n    address _spender,\n    uint _addedValue\n  )\n    public\n    returns (bool)\n  {\n    allowed[msg.sender][_spender] = (\n      allowed[msg.sender][_spender].add(_addedValue));\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(\n    address _spender,\n    uint _subtractedValue\n  )\n    public\n    returns (bool)\n  {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n// File: contracts/QuantstampAuditData.sol\n\ncontract QuantstampAuditData is Whitelist {\n  // state of audit requests submitted to the contract\n  enum AuditState {\n    None,\n    Queued,\n    Assigned,\n    Refunded,\n    Completed,  // automated audit finished successfully and the report is available\n    Error,      // automated audit failed to finish; the report contains detailed information about the error\n    Expired,\n    Resolved\n  }\n\n  // structure representing an audit\n  struct Audit {\n    address requestor;\n    string contractUri;\n    uint256 price;\n    uint256 requestBlockNumber; // block number that audit was requested\n    QuantstampAuditData.AuditState state;\n    address auditor;       // the address of the node assigned to the audit\n    uint256 assignBlockNumber;  // block number that audit was assigned\n    string reportHash;     // stores the hash of audit report\n    uint256 reportBlockNumber;  // block number that the payment and the audit report were submitted\n    address registrar;  // address of the contract which registers this request\n  }\n\n  // map audits (requestId, Audit)\n  mapping(uint256 => Audit) public audits;\n\n  // token used to pay for audits. This contract assumes that the owner of the contract trusts token's code and\n  // that transfer function (such as transferFrom, transfer) do the right thing\n  StandardToken public token;\n\n  // Once an audit node gets an audit request, they must submit a report within this many blocks.\n  // After that, the report is verified by the police.\n  uint256 public auditTimeoutInBlocks = 50;\n\n  // maximum number of assigned audits per each audit node\n  uint256 public maxAssignedRequests = 10;\n\n  // map audit nodes to their minimum prices. Defaults to zero: the node accepts all requests.\n  mapping(address => uint256) public minAuditPrice;\n\n  // For generating requestIds starting from 1\n  uint256 private requestCounter;\n\n  /**\n   * @dev The constructor creates an audit contract.\n   * @param tokenAddress The address of a StandardToken that will be used to pay audit nodes.\n   */\n  constructor (address tokenAddress) public {\n    require(tokenAddress != address(0));\n    token = StandardToken(tokenAddress);\n  }\n\n  function addAuditRequest (address requestor, string contractUri, uint256 price) public onlyWhitelisted returns(uint256) {\n    // assign the next request ID\n    uint256 requestId = ++requestCounter;\n    // store the audit\n    audits[requestId] = Audit(requestor, contractUri, price, block.number, AuditState.Queued, address(0), 0, \"\", 0, msg.sender);  // solhint-disable-line not-rely-on-time\n    return requestId;\n  }\n\n  /**\n   * @dev Allows a whitelisted logic contract (QuantstampAudit) to spend stored tokens.\n   * @param amount The number of wei-QSP that will be approved.\n   */\n  function approveWhitelisted(uint256 amount) public onlyWhitelisted {\n    token.approve(msg.sender, amount);\n  }\n\n  function getAuditContractUri(uint256 requestId) public view returns(string) {\n    return audits[requestId].contractUri;\n  }\n\n  function getAuditRequestor(uint256 requestId) public view returns(address) {\n    return audits[requestId].requestor;\n  }\n\n  function getAuditPrice (uint256 requestId) public view returns(uint256) {\n    return audits[requestId].price;\n  }\n\n  function getAuditState (uint256 requestId) public view returns(AuditState) {\n    return audits[requestId].state;\n  }\n\n  function getAuditRequestBlockNumber (uint256 requestId) public view returns(uint) {\n    return audits[requestId].requestBlockNumber;\n  }\n\n  function setAuditState (uint256 requestId, AuditState state) public onlyWhitelisted {\n    audits[requestId].state = state;\n  }\n\n  function getAuditAuditor (uint256 requestId) public view returns(address) {\n    return audits[requestId].auditor;\n  }\n\n  function getAuditRegistrar (uint256 requestId) public view returns(address) {\n    return audits[requestId].registrar;\n  }\n\n  function setAuditAuditor (uint256 requestId, address auditor) public onlyWhitelisted {\n    audits[requestId].auditor = auditor;\n  }\n\n  function getAuditAssignBlockNumber (uint256 requestId) public view returns(uint256) {\n    return audits[requestId].assignBlockNumber;\n  }\n\n  function getAuditReportBlockNumber (uint256 requestId) public view returns (uint256) {\n    return audits[requestId].reportBlockNumber;\n  }\n\n  function setAuditAssignBlockNumber (uint256 requestId, uint256 assignBlockNumber) public onlyWhitelisted {\n    audits[requestId].assignBlockNumber = assignBlockNumber;\n  }\n\n  function setAuditReportHash (uint256 requestId, string reportHash) public onlyWhitelisted {\n    audits[requestId].reportHash = reportHash;\n  }\n\n  function setAuditReportBlockNumber (uint256 requestId, uint256 reportBlockNumber) public onlyWhitelisted {\n    audits[requestId].reportBlockNumber = reportBlockNumber;\n  }\n\n  function setAuditRegistrar (uint256 requestId, address registrar) public onlyWhitelisted {\n    audits[requestId].registrar = registrar;\n  }\n\n  function setAuditTimeout (uint256 timeoutInBlocks) public onlyOwner {\n    auditTimeoutInBlocks = timeoutInBlocks;\n  }\n\n  /**\n   * @dev Set the maximum number of audits any audit node can handle at any time.\n   * @param maxAssignments Maximum number of audit requests for each audit node.\n   */\n  function setMaxAssignedRequests (uint256 maxAssignments) public onlyOwner {\n    maxAssignedRequests = maxAssignments;\n  }\n\n  function getMinAuditPrice (address auditor) public view returns(uint256) {\n    return minAuditPrice[auditor];\n  }\n\n  /**\n   * @dev Allows the audit node to set its minimum price per audit in wei-QSP.\n   * @param price The minimum price.\n   */\n  function setMinAuditPrice(address auditor, uint256 price) public onlyWhitelisted {\n    minAuditPrice[auditor] = price;\n  }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n    require(token.transfer(to, value));\n  }\n\n  function safeTransferFrom(\n    ERC20 token,\n    address from,\n    address to,\n    uint256 value\n  )\n    internal\n  {\n    require(token.transferFrom(from, to, value));\n  }\n\n  function safeApprove(ERC20 token, address spender, uint256 value) internal {\n    require(token.approve(spender, value));\n  }\n}\n\n// File: contracts/token_escrow/TokenEscrow.sol\n\n/**\n * NOTE: All contracts in this directory were taken from a non-master branch of openzeppelin-solidity.\n * This contract was modified to be a whitelist.\n * Commit: ed451a8688d1fa7c927b27cec299a9726667d9b1\n */\n\npragma solidity ^0.4.24;\n\n\n\n\n\n\n/**\n * @title TokenEscrow\n * @dev Holds tokens destinated to a payee until they withdraw them.\n * The contract that uses the TokenEscrow as its payment method\n * should be its owner, and provide public methods redirecting\n * to the TokenEscrow's deposit and withdraw.\n * Moreover, the TokenEscrow should also be allowed to transfer\n * tokens from the payer to itself.\n */\ncontract TokenEscrow is Ownable, Whitelist {\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20;\n\n  event Deposited(address indexed payee, uint256 tokenAmount);\n  event Withdrawn(address indexed payee, uint256 tokenAmount);\n\n  mapping(address => uint256) public deposits;\n\n  ERC20 public token;\n\n  constructor (ERC20 _token) public {\n    require(_token != address(0));\n    token = _token;\n  }\n\n  function depositsOf(address _payee) public view returns (uint256) {\n    return deposits[_payee];\n  }\n\n  /**\n  * @dev Puts in escrow a certain amount of tokens as credit to be withdrawn.\n  * @param _payee The destination address of the tokens.\n  * @param _amount The amount of tokens to deposit in escrow.\n  */\n  function deposit(address _payee, uint256 _amount) public onlyWhitelisted {\n    deposits[_payee] = deposits[_payee].add(_amount);\n\n    token.safeTransferFrom(msg.sender, address(this), _amount);\n\n    emit Deposited(_payee, _amount);\n  }\n\n  /**\n  * @dev Withdraw accumulated tokens for a payee.\n  * @param _payee The address whose tokens will be withdrawn and transferred to.\n  */\n  function withdraw(address _payee) public onlyWhitelisted {\n    uint256 payment = deposits[_payee];\n    assert(token.balanceOf(address(this)) >= payment);\n\n    deposits[_payee] = 0;\n\n    token.safeTransfer(_payee, payment);\n\n    emit Withdrawn(_payee, payment);\n  }\n}\n\n// File: contracts/token_escrow/ConditionalTokenEscrow.sol\n\n/**\n * NOTE: All contracts in this directory were taken from a non-master branch of openzeppelin-solidity.\n * Commit: ed451a8688d1fa7c927b27cec299a9726667d9b1\n */\n\npragma solidity ^0.4.24;\n\n\n\n/**\n * @title ConditionalTokenEscrow\n * @dev Base abstract escrow to only allow withdrawal of tokens\n * if a condition is met.\n */\ncontract ConditionalTokenEscrow is TokenEscrow {\n  /**\n  * @dev Returns whether an address is allowed to withdraw their tokens.\n  * To be implemented by derived contracts.\n  * @param _payee The destination address of the tokens.\n  */\n  function withdrawalAllowed(address _payee) public view returns (bool);\n\n  function withdraw(address _payee) public {\n    require(withdrawalAllowed(_payee));\n    super.withdraw(_payee);\n  }\n}\n\n// File: contracts/QuantstampAuditTokenEscrow.sol\n\ncontract QuantstampAuditTokenEscrow is ConditionalTokenEscrow {\n\n  // the escrow maintains the list of staked addresses\n  using LinkedListLib for LinkedListLib.LinkedList;\n\n  // constants used by LinkedListLib\n  uint256 constant internal NULL = 0;\n  uint256 constant internal HEAD = 0;\n  bool constant internal PREV = false;\n  bool constant internal NEXT = true;\n\n  // maintain the number of staked nodes\n  // saves gas cost over needing to call stakedNodesList.sizeOf()\n  uint256 public stakedNodesCount = 0;\n\n  // the minimum amount of wei-QSP that must be staked in order to be a node\n  uint256 public minAuditStake = 10000 * (10 ** 18);\n\n  // if true, the payee cannot currently withdraw their funds\n  mapping(address => bool) public lockedFunds;\n\n  // if funds are locked, they may be retrieved after this block\n  // if funds are unlocked, the number should be ignored\n  mapping(address => uint256) public unlockBlockNumber;\n\n  // staked audit nodes -- needed to inquire about audit node statistics, such as min price\n  // this list contains all nodes that have *ANY* stake, however when getNextStakedNode is called,\n  // it skips nodes that do not meet the minimum stake.\n  // the reason for this approach is that if the owner lowers the minAuditStake,\n  // we must be aware of any node with a stake.\n  LinkedListLib.LinkedList internal stakedNodesList;\n\n  event Slashed(address addr, uint256 amount);\n  event StakedNodeAdded(address addr);\n  event StakedNodeRemoved(address addr);\n\n  // the constructor of TokenEscrow requires an ERC20, not an address\n  constructor(address tokenAddress) public TokenEscrow(ERC20(tokenAddress)) {} // solhint-disable no-empty-blocks\n\n  /**\n  * @dev Puts in escrow a certain amount of tokens as credit to be withdrawn.\n  *      Overrides the function in TokenEscrow.sol to add the payee to the staked list.\n  * @param _payee The destination address of the tokens.\n  * @param _amount The amount of tokens to deposit in escrow.\n  */\n  function deposit(address _payee, uint256 _amount) public onlyWhitelisted {\n    super.deposit(_payee, _amount);\n    if (_amount > 0) {\n      // fails gracefully if the node already exists\n      addNodeToStakedList(_payee);\n    }\n  }\n\n /**\n  * @dev Withdraw accumulated tokens for a payee.\n  *      Overrides the function in TokenEscrow.sol to remove the payee from the staked list.\n  * @param _payee The address whose tokens will be withdrawn and transferred to.\n  */\n  function withdraw(address _payee) public onlyWhitelisted {\n    super.withdraw(_payee);\n    removeNodeFromStakedList(_payee);\n  }\n\n  /**\n   * @dev Sets the minimum stake to a new value.\n   * @param _value The new value. _value must be greater than zero in order for the linked list to be maintained correctly.\n   */\n  function setMinAuditStake(uint256 _value) public onlyOwner {\n    require(_value > 0);\n    minAuditStake = _value;\n  }\n\n  /**\n   * @dev Returns true if the sender staked enough.\n   * @param addr The address to check.\n   */\n  function hasEnoughStake(address addr) public view returns(bool) {\n    return depositsOf(addr) >= minAuditStake;\n  }\n\n  /**\n   * @dev Overrides ConditionalTokenEscrow function. If true, funds may be withdrawn.\n   * @param _payee The address that wants to withdraw funds.\n   */\n  function withdrawalAllowed(address _payee) public view returns (bool) {\n    return !lockedFunds[_payee] || unlockBlockNumber[_payee] < block.number;\n  }\n\n  /**\n   * @dev Prevents the payee from withdrawing funds.\n   * @param _payee The address that will be locked.\n   */\n  function lockFunds(address _payee, uint256 _unlockBlockNumber) public onlyWhitelisted returns (bool) {\n    lockedFunds[_payee] = true;\n    unlockBlockNumber[_payee] = _unlockBlockNumber;\n    return true;\n  }\n\n    /**\n   * @dev Slash a percentage of the stake of an address.\n   *      The percentage is taken from the minAuditStake, not the total stake of the address.\n   *      The caller of this function receives the slashed QSP.\n   *      If the current stake does not cover the slash amount, the full stake is taken.\n   *\n   * @param addr The address that will be slashed.\n   * @param percentage The percent of the minAuditStake that should be slashed.\n   */\n  function slash(address addr, uint256 percentage) public onlyWhitelisted returns (uint256) {\n    require(0 <= percentage && percentage <= 100);\n\n    uint256 slashAmount = getSlashAmount(percentage);\n    uint256 balance = depositsOf(addr);\n    if (balance < slashAmount) {\n      slashAmount = balance;\n    }\n\n    // subtract from the deposits amount of the addr\n    deposits[addr] = deposits[addr].sub(slashAmount);\n\n    emit Slashed(addr, slashAmount);\n\n    // if the deposits of the address are now zero, remove from the list\n    if (depositsOf(addr) == 0) {\n      removeNodeFromStakedList(addr);\n    }\n\n    // transfer the slashAmount to the police contract\n    token.safeTransfer(msg.sender, slashAmount);\n\n    return slashAmount;\n  }\n\n  /**\n   * @dev Returns the slash amount for a given percentage.\n   * @param percentage The percent of the minAuditStake that should be slashed.\n   */\n  function getSlashAmount(uint256 percentage) public view returns (uint256) {\n    return (minAuditStake.mul(percentage)).div(100);\n  }\n\n  /**\n   * @dev Given a staked address, returns the next address from the list that meets the minAuditStake.\n   * @param addr The staked address.\n   * @return The next address in the list.\n   */\n  function getNextStakedNode(address addr) public view returns(address) {\n    bool exists;\n    uint256 next;\n    (exists, next) = stakedNodesList.getAdjacent(uint256(addr), NEXT);\n    // only return addresses that meet the minAuditStake\n    while (exists && next != HEAD && !hasEnoughStake(address(next))) {\n      (exists, next) = stakedNodesList.getAdjacent(next, NEXT);\n    }\n    return address(next);\n  }\n\n  /**\n   * @dev Adds an address to the stakedNodesList.\n   * @param addr The address to be added to the list.\n   * @return true if the address was added to the list.\n   */\n  function addNodeToStakedList(address addr) internal returns(bool success) {\n    if (stakedNodesList.insert(HEAD, uint256(addr), PREV)) {\n      stakedNodesCount++;\n      emit StakedNodeAdded(addr);\n      success = true;\n    }\n  }\n\n  /**\n   * @dev Removes an address from the stakedNodesList.\n   * @param addr The address to be removed from the list.\n   * @return true if the address was removed from the list.\n   */\n  function removeNodeFromStakedList(address addr) internal returns(bool success) {\n    if (stakedNodesList.remove(uint256(addr)) != 0) {\n      stakedNodesCount--;\n      emit StakedNodeRemoved(addr);\n      success = true;\n    }\n  }\n}\n\n// File: contracts/QuantstampAuditPolice.sol\n\n// TODO (QSP-833): salary and taxing\n// TODO transfer existing salary if removing police\ncontract QuantstampAuditPolice is Whitelist {   // solhint-disable max-states-count\n\n  using SafeMath for uint256;\n  using LinkedListLib for LinkedListLib.LinkedList;\n\n  // constants used by LinkedListLib\n  uint256 constant internal NULL = 0;\n  uint256 constant internal HEAD = 0;\n  bool constant internal PREV = false;\n  bool constant internal NEXT = true;\n\n  enum PoliceReportState {\n    UNVERIFIED,\n    INVALID,\n    VALID,\n    EXPIRED\n  }\n\n  // whitelisted police nodes\n  LinkedListLib.LinkedList internal policeList;\n\n  // the total number of police nodes\n  uint256 public numPoliceNodes = 0;\n\n  // the number of police nodes assigned to each report\n  uint256 public policeNodesPerReport = 3;\n\n  // the number of blocks the police have to verify a report\n  uint256 public policeTimeoutInBlocks = 100;\n\n  // number from [0-100] that indicates the percentage of the minAuditStake that should be slashed\n  uint256 public slashPercentage = 20;\n\n    // this is only deducted once per report, regardless of the number of police nodes assigned to it\n  uint256 public reportProcessingFeePercentage = 5;\n\n  event PoliceNodeAdded(address addr);\n  event PoliceNodeRemoved(address addr);\n  // TODO: we may want these parameters indexed\n  event PoliceNodeAssignedToReport(address policeNode, uint256 requestId);\n  event PoliceSubmissionPeriodExceeded(uint256 requestId, uint256 timeoutBlock, uint256 currentBlock);\n  event PoliceSlash(uint256 requestId, address policeNode, address auditNode, uint256 amount);\n  event PoliceFeesClaimed(address policeNode, uint256 fee);\n  event PoliceFeesCollected(uint256 requestId, uint256 fee);\n  event PoliceAssignmentExpiredAndCleared(uint256 requestId);\n\n  // pointer to the police node that was last assigned to a report\n  address private lastAssignedPoliceNode = address(HEAD);\n\n  // maps each police node to the IDs of reports it should check\n  mapping(address => LinkedListLib.LinkedList) internal assignedReports;\n\n  // maps request IDs to the police nodes that are expected to check the report\n  mapping(uint256 => LinkedListLib.LinkedList) internal assignedPolice;\n\n  // maps each audit node to the IDs of reports that are pending police approval for payment\n  mapping(address => LinkedListLib.LinkedList) internal pendingPayments;\n\n  // maps request IDs to police timeouts\n  mapping(uint256 => uint256) public policeTimeouts;\n\n  // maps request IDs to reports submitted by police nodes\n  mapping(uint256 => mapping(address => bytes)) public policeReports;\n\n  // maps request IDs to the result reported by each police node\n  mapping(uint256 => mapping(address => PoliceReportState)) public policeReportResults;\n\n  // maps request IDs to whether they have been verified by the police\n  mapping(uint256 => PoliceReportState) public verifiedReports;\n\n  // maps request IDs to whether their reward has been claimed by the submitter\n  mapping(uint256 => bool) public rewardHasBeenClaimed;\n\n  // tracks the total number of reports ever assigned to a police node\n  mapping(address => uint256) public totalReportsAssigned;\n\n  // tracks the total number of reports ever checked by a police node\n  mapping(address => uint256) public totalReportsChecked;\n\n  // the collected fees for each report\n  mapping(uint256 => uint256) public collectedFees;\n\n  // contract that stores audit data (separate from the auditing logic)\n  QuantstampAuditData public auditData;\n\n  // contract that stores token escrows of nodes on the network\n  QuantstampAuditTokenEscrow public tokenEscrow;\n\n  /**\n   * @dev The constructor creates a police contract.\n   * @param auditDataAddress The address of an AuditData that stores data used for performing audits.\n   * @param escrowAddress The address of a QuantstampTokenEscrow contract that holds staked deposits of nodes.\n   */\n  constructor (address auditDataAddress, address escrowAddress) public {\n    require(auditDataAddress != address(0));\n    require(escrowAddress != address(0));\n    auditData = QuantstampAuditData(auditDataAddress);\n    tokenEscrow = QuantstampAuditTokenEscrow(escrowAddress);\n  }\n\n  /**\n   * @dev Assigns police nodes to a submitted report\n   * @param requestId The ID of the audit request.\n   */\n  function assignPoliceToReport(uint256 requestId) public onlyWhitelisted {\n    // ensure that the requestId has not already been assigned to police already\n    require(policeTimeouts[requestId] == 0);\n    // set the timeout for police reports\n    policeTimeouts[requestId] = block.number + policeTimeoutInBlocks;\n    // if there are not enough police nodes, this avoids assigning the same node twice\n    uint256 numToAssign = policeNodesPerReport;\n    if (numPoliceNodes < numToAssign) {\n      numToAssign = numPoliceNodes;\n    }\n    while (numToAssign > 0) {\n      lastAssignedPoliceNode = getNextPoliceNode(lastAssignedPoliceNode);\n      if (lastAssignedPoliceNode != address(0)) {\n        // push the request ID to the tail of the assignment list for the police node\n        assignedReports[lastAssignedPoliceNode].push(requestId, PREV);\n        // push the police node to the list of nodes assigned to check the report\n        assignedPolice[requestId].push(uint256(lastAssignedPoliceNode), PREV);\n        emit PoliceNodeAssignedToReport(lastAssignedPoliceNode, requestId);\n        totalReportsAssigned[lastAssignedPoliceNode] = totalReportsAssigned[lastAssignedPoliceNode].add(1);\n        numToAssign = numToAssign.sub(1);\n      }\n    }\n  }\n\n  /**\n   * Cleans the list of assignments to police node (msg.sender), but checks only up to a limit\n   * of assignments. If the limit is 0, attempts to clean the entire list.\n   * @param policeNode The node whose assignments should be cleared.\n   * @param limit The number of assigments to check.\n   */\n  function clearExpiredAssignments (address policeNode, uint256 limit) public {\n    removeExpiredAssignments(policeNode, 0, limit);\n  }\n\n  /**\n   * @dev Collects the police fee for checking a report.\n   *      NOTE: this function assumes that the fee will be transferred by the calling contract.\n   * @param requestId The ID of the audit request.\n   * @return The amount collected.\n   */\n  function collectFee(uint256 requestId) public onlyWhitelisted returns (uint256) {\n    uint256 policeFee = getPoliceFee(auditData.getAuditPrice(requestId));\n    // the collected fee needs to be stored in a map since the owner could change the fee percentage\n    collectedFees[requestId] = policeFee;\n    emit PoliceFeesCollected(requestId, policeFee);\n    return policeFee;\n  }\n\n  /**\n   * @dev Split a payment, which may be for report checking or from slashing, amongst all police nodes\n   * @param amount The amount to be split, which should have been transferred to this contract earlier.\n   */\n  function splitPayment(uint256 amount) public onlyWhitelisted {\n    require(numPoliceNodes != 0);\n    address policeNode = getNextPoliceNode(address(HEAD));\n    uint256 amountPerNode = amount.div(numPoliceNodes);\n    // TODO: upgrade our openzeppelin version to use mod\n    uint256 largerAmount = amountPerNode.add(amount % numPoliceNodes);\n    bool largerAmountClaimed = false;\n    while (policeNode != address(HEAD)) {\n      // give the largerAmount to the current lastAssignedPoliceNode if it is not equal to HEAD\n      // this approach is only truly fair if numPoliceNodes and policeNodesPerReport are relatively prime\n      // but the remainder should be extremely small in any case\n      // the last conditional handles the edge case where all police nodes were removed and then re-added\n      if (!largerAmountClaimed && (policeNode == lastAssignedPoliceNode || lastAssignedPoliceNode == address(HEAD))) {\n        require(auditData.token().transfer(policeNode, largerAmount));\n        emit PoliceFeesClaimed(policeNode, largerAmount);\n        largerAmountClaimed = true;\n      } else {\n        require(auditData.token().transfer(policeNode, amountPerNode));\n        emit PoliceFeesClaimed(policeNode, amountPerNode);\n      }\n      policeNode = getNextPoliceNode(address(policeNode));\n    }\n  }\n\n  /**\n   * @dev Associates a pending payment with an auditor that can be claimed after the policing period.\n   * @param auditor The audit node that submitted the report.\n   * @param requestId The ID of the audit request.\n   */\n  function addPendingPayment(address auditor, uint256 requestId) public onlyWhitelisted {\n    pendingPayments[auditor].push(requestId, PREV);\n  }\n\n  /**\n   * @dev Submits verification of a report by a police node.\n   * @param policeNode The address of the police node.\n   * @param auditNode The address of the audit node.\n   * @param requestId The ID of the audit request.\n   * @param report The compressed bytecode representation of the report.\n   * @param isVerified Whether the police node's report matches the submitted report.\n   *                   If not, the audit node is slashed.\n   * @return two bools and a uint256: (true if the report was successfully submitted, true if a slash occurred, the slash amount).\n   */\n  function submitPoliceReport(\n    address policeNode,\n    address auditNode,\n    uint256 requestId,\n    bytes report,\n    bool isVerified) public onlyWhitelisted returns (bool, bool, uint256) {\n    // remove expired assignments\n    bool hasRemovedCurrentId = removeExpiredAssignments(policeNode, requestId, 0);\n    // if the current request has timed out, return\n    if (hasRemovedCurrentId) {\n      emit PoliceSubmissionPeriodExceeded(requestId, policeTimeouts[requestId], block.number);\n      return (false, false, 0);\n    }\n    // the police node is assigned to the report\n    require(isAssigned(requestId, policeNode));\n\n    // remove the report from the assignments to the node\n    assignedReports[policeNode].remove(requestId);\n    // increment the number of reports checked by the police node\n    totalReportsChecked[policeNode] = totalReportsChecked[policeNode] + 1;\n    // store the report\n    policeReports[requestId][policeNode] = report;\n    // emit an event\n    PoliceReportState state;\n    if (isVerified) {\n      state = PoliceReportState.VALID;\n    } else {\n      state = PoliceReportState.INVALID;\n    }\n    policeReportResults[requestId][policeNode] = state;\n\n    // the report was already marked invalid by a different police node\n    if (verifiedReports[requestId] == PoliceReportState.INVALID) {\n      return (true, false, 0);\n    } else {\n      verifiedReports[requestId] = state;\n    }\n    bool slashOccurred;\n    uint256 slashAmount;\n    if (!isVerified) {\n      pendingPayments[auditNode].remove(requestId);\n      // an audit node can only be slashed once for each report,\n      // even if multiple police mark the report as invalid\n      slashAmount = tokenEscrow.slash(auditNode, slashPercentage);\n      slashOccurred = true;\n      emit PoliceSlash(requestId, policeNode, auditNode, slashAmount);\n    }\n    return (true, slashOccurred, slashAmount);\n  }\n\n  /**\n   * @dev Determines whether an audit node is allowed by the police to claim an audit.\n   * @param auditNode The address of the audit node.\n   * @param requestId The ID of the requested audit.\n   */\n  function canClaimAuditReward (address auditNode, uint256 requestId) public view returns (bool) {\n    // NOTE: can't use requires here, as claimNextReward needs to iterate the full list\n    return\n      // the report is in the pending payments list for the audit node\n      pendingPayments[auditNode].nodeExists(requestId) &&\n      // the policing period has ended for the report\n      policeTimeouts[requestId] < block.number &&\n      // the police did not invalidate the report\n      verifiedReports[requestId] != PoliceReportState.INVALID &&\n      // the reward has not already been claimed\n      !rewardHasBeenClaimed[requestId] &&\n      // the requestId is non-zero\n      requestId > 0;\n  }\n\n  /**\n   * @dev Given a requestId, returns the next pending available reward for the audit node.\n   * @param auditNode The address of the audit node.\n   * @param requestId The ID of the current linked list node\n   * @return true if the next reward exists, and the corresponding requestId in the linked list\n   */\n  function getNextAvailableReward (address auditNode, uint256 requestId) public view returns (bool, uint256) {\n    bool exists;\n    (exists, requestId) = pendingPayments[auditNode].getAdjacent(requestId, NEXT);\n    // NOTE: Do NOT short circuit this list based on timeouts.\n    // The ordering may be broken if the owner changes the timeouts.\n    while (exists && requestId != HEAD) {\n      if (canClaimAuditReward(auditNode, requestId)) {\n        return (true, requestId);\n      }\n      (exists, requestId) = pendingPayments[auditNode].getAdjacent(requestId, NEXT);\n    }\n    return (false, 0);\n  }\n\n  /**\n   * @dev Sets the reward as claimed after checking that it can be claimed.\n   *      This function also ensures double payment does not occur.\n   * @param auditNode The address of the audit node.\n   * @param requestId The ID of the requested audit.\n   */\n  function setRewardClaimed (address auditNode, uint256 requestId) public onlyWhitelisted returns (bool) {\n    // set the reward to claimed, to avoid double payment\n    rewardHasBeenClaimed[requestId] = true;\n    pendingPayments[auditNode].remove(requestId);\n    // if it is possible to claim yet the state is UNVERIFIED, mark EXPIRED\n    if (verifiedReports[requestId] == PoliceReportState.UNVERIFIED) {\n      verifiedReports[requestId] = PoliceReportState.EXPIRED;\n    }\n    return true;\n  }\n\n  /**\n   * @dev Selects the next ID to be rewarded.\n   * @param auditNode The address of the audit node.\n   * @param requestId The previous claimed requestId (initially set to HEAD).\n   * @return True if another reward exists, and the request ID.\n   */\n  function claimNextReward (address auditNode, uint256 requestId) public onlyWhitelisted returns (bool, uint256) {\n    bool exists;\n    (exists, requestId) = pendingPayments[auditNode].getAdjacent(requestId, NEXT);\n    // NOTE: Do NOT short circuit this list based on timeouts.\n    // The ordering may be broken if the owner changes the timeouts.\n    while (exists && requestId != HEAD) {\n      if (canClaimAuditReward(auditNode, requestId)) {\n        setRewardClaimed(auditNode, requestId);\n        return (true, requestId);\n      }\n      (exists, requestId) = pendingPayments[auditNode].getAdjacent(requestId, NEXT);\n    }\n    return (false, 0);\n  }\n\n  /**\n   * @dev Gets the next assigned report to the police node.\n   * @param policeNode The address of the police node.\n   * @return true if the list is non-empty, requestId, auditPrice, uri, and policeAssignmentBlockNumber.\n   */\n  function getNextPoliceAssignment(address policeNode) public view returns (bool, uint256, uint256, string, uint256) {\n    bool exists;\n    uint256 requestId;\n    (exists, requestId) = assignedReports[policeNode].getAdjacent(HEAD, NEXT);\n    // if the head of the list is an expired assignment, try to find a current one\n    while (exists && requestId != HEAD) {\n      if (policeTimeouts[requestId] < block.number) {\n        (exists, requestId) = assignedReports[policeNode].getAdjacent(requestId, NEXT);\n      } else {\n        uint256 price = auditData.getAuditPrice(requestId);\n        string memory uri = auditData.getAuditContractUri(requestId);\n        uint256 policeAssignmentBlockNumber = auditData.getAuditReportBlockNumber(requestId);\n        return (exists, requestId, price, uri, policeAssignmentBlockNumber);\n      }\n    }\n    return (false, 0, 0, \"\", 0);\n  }\n\n  /**\n   * @dev Gets the next assigned police node to an audit request.\n   * @param requestId The ID of the audit request.\n   * @param policeNode The previous claimed requestId (initially set to HEAD).\n   * @return true if the next police node exists, and the address of the police node.\n   */\n  function getNextAssignedPolice(uint256 requestId, address policeNode) public view returns (bool, address) {\n    bool exists;\n    uint256 nextPoliceNode;\n    (exists, nextPoliceNode) = assignedPolice[requestId].getAdjacent(uint256(policeNode), NEXT);\n    if (nextPoliceNode == HEAD) {\n      return (false, address(0));\n    }\n    return (exists, address(nextPoliceNode));\n  }\n\n  /**\n   * @dev Sets the number of police nodes that should check each report.\n   * @param numPolice The number of police.\n   */\n  function setPoliceNodesPerReport(uint256 numPolice) public onlyOwner {\n    policeNodesPerReport = numPolice;\n  }\n\n  /**\n   * @dev Sets the police timeout.\n   * @param numBlocks The number of blocks for the timeout.\n   */\n  function setPoliceTimeoutInBlocks(uint256 numBlocks) public onlyOwner {\n    policeTimeoutInBlocks = numBlocks;\n  }\n\n  /**\n   * @dev Sets the slash percentage.\n   * @param percentage The percentage as an integer from [0-100].\n   */\n  function setSlashPercentage(uint256 percentage) public onlyOwner {\n    require(0 <= percentage && percentage <= 100);\n    slashPercentage = percentage;\n  }\n\n  /**\n   * @dev Sets the report processing fee percentage.\n   * @param percentage The percentage in the range of [0-100].\n   */\n  function setReportProcessingFeePercentage(uint256 percentage) public onlyOwner {\n    require(percentage <= 100);\n    reportProcessingFeePercentage = percentage;\n  }\n\n  /**\n   * @dev Returns true if a node is whitelisted.\n   * @param node The node to check.\n   */\n  function isPoliceNode(address node) public view returns (bool) {\n    return policeList.nodeExists(uint256(node));\n  }\n\n  /**\n   * @dev Adds an address to the police.\n   * @param addr The address to be added.\n   * @return true if the address was added to the whitelist.\n   */\n  function addPoliceNode(address addr) public onlyOwner returns (bool success) {\n    if (policeList.insert(HEAD, uint256(addr), PREV)) {\n      numPoliceNodes = numPoliceNodes.add(1);\n      emit PoliceNodeAdded(addr);\n      success = true;\n    }\n  }\n\n  /**\n   * @dev Removes an address from the whitelist linked-list.\n   * @param addr The address to be removed.\n   * @return true if the address was removed from the whitelist.\n   */\n  function removePoliceNode(address addr) public onlyOwner returns (bool success) {\n    // if lastAssignedPoliceNode is addr, need to move the pointer\n    bool exists;\n    uint256 next;\n    if (lastAssignedPoliceNode == addr) {\n      (exists, next) = policeList.getAdjacent(uint256(addr), NEXT);\n      lastAssignedPoliceNode = address(next);\n    }\n\n    if (policeList.remove(uint256(addr)) != NULL) {\n      numPoliceNodes = numPoliceNodes.sub(1);\n      emit PoliceNodeRemoved(addr);\n      success = true;\n    }\n  }\n\n  /**\n   * @dev Given a whitelisted address, returns the next address from the whitelist.\n   * @param addr The address in the whitelist.\n   * @return The next address in the whitelist.\n   */\n  function getNextPoliceNode(address addr) public view returns (address) {\n    bool exists;\n    uint256 next;\n    (exists, next) = policeList.getAdjacent(uint256(addr), NEXT);\n    return address(next);\n  }\n\n  /**\n   * @dev Returns the resulting state of a police report for a given audit request.\n   * @param requestId The ID of the audit request.\n   * @param policeAddr The address of the police node.\n   * @return the PoliceReportState of the (requestId, policeNode) pair.\n   */\n  function getPoliceReportResult(uint256 requestId, address policeAddr) public view returns (PoliceReportState) {\n    return policeReportResults[requestId][policeAddr];\n  }\n\n  function getPoliceReport(uint256 requestId, address policeAddr) public view returns (bytes) {\n    return policeReports[requestId][policeAddr];\n  }\n\n  function getPoliceFee(uint256 auditPrice) public view returns (uint256) {\n    return auditPrice.mul(reportProcessingFeePercentage).div(100);\n  }\n\n  function isAssigned(uint256 requestId, address policeAddr) public view returns (bool) {\n    return assignedReports[policeAddr].nodeExists(requestId);\n  }\n\n  /**\n   * Cleans the list of assignments to a given police node.\n   * @param policeNode The address of the police node.\n   * @param requestId The ID of the audit request.\n   * @param limit The number of assigments to check. Use 0 if the entire list should be checked.\n   * @return true if the current request ID gets removed during cleanup.\n   */\n  function removeExpiredAssignments (address policeNode, uint256 requestId, uint256 limit) internal returns (bool) {\n    bool hasRemovedCurrentId = false;\n    bool exists;\n    uint256 potentialExpiredRequestId;\n    uint256 nextExpiredRequestId;\n    uint256 iterationsLeft = limit;\n    (exists, nextExpiredRequestId) = assignedReports[policeNode].getAdjacent(HEAD, NEXT);\n    // NOTE: Short circuiting this list may cause expired assignments to exist later in the list.\n    //       The may occur if the owner changes the global police timeout.\n    //       These expired assignments will be removed in subsequent calls.\n    while (exists && nextExpiredRequestId != HEAD && (limit == 0 || iterationsLeft > 0)) {\n      potentialExpiredRequestId = nextExpiredRequestId;\n      (exists, nextExpiredRequestId) = assignedReports[policeNode].getAdjacent(nextExpiredRequestId, NEXT);\n      if (policeTimeouts[potentialExpiredRequestId] < block.number) {\n        assignedReports[policeNode].remove(potentialExpiredRequestId);\n        emit PoliceAssignmentExpiredAndCleared(potentialExpiredRequestId);\n        if (potentialExpiredRequestId == requestId) {\n          hasRemovedCurrentId = true;\n        }\n      } else {\n        break;\n      }\n      iterationsLeft -= 1;\n    }\n    return hasRemovedCurrentId;\n  }\n}\n\n// File: contracts/QuantstampAuditReportData.sol\n\ncontract QuantstampAuditReportData is Whitelist {\n\n  // mapping from requestId to a report\n  mapping(uint256 => bytes) public reports;\n\n  function setReport(uint256 requestId, bytes report) external onlyWhitelisted {\n    reports[requestId] = report;\n  }\n\n  function getReport(uint256 requestId) external view returns(bytes) {\n    return reports[requestId];\n  }\n\n}\n\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n\n// File: contracts/QuantstampAudit.sol\n\ncontract QuantstampAudit is Pausable {\n  using SafeMath for uint256;\n  using LinkedListLib for LinkedListLib.LinkedList;\n\n  // constants used by LinkedListLib\n  uint256 constant internal NULL = 0;\n  uint256 constant internal HEAD = 0;\n  bool constant internal PREV = false;\n  bool constant internal NEXT = true;\n\n  uint256 private minAuditPriceLowerCap = 0;\n\n  // mapping from an audit node address to the number of requests that it currently processes\n  mapping(address => uint256) public assignedRequestCount;\n\n  // increasingly sorted linked list of prices\n  LinkedListLib.LinkedList internal priceList;\n  // map from price to a list of request IDs\n  mapping(uint256 => LinkedListLib.LinkedList) internal auditsByPrice;\n\n  // list of request IDs of assigned audits (the list preserves temporal order of assignments)\n  LinkedListLib.LinkedList internal assignedAudits;\n\n  // stores request ids of the most recently assigned audits for each audit node\n  mapping(address => uint256) public mostRecentAssignedRequestIdsPerAuditor;\n\n  // contract that stores audit data (separate from the auditing logic)\n  QuantstampAuditData public auditData;\n\n  // contract that stores audit reports on-chain\n  QuantstampAuditReportData public reportData;\n\n  // contract that handles policing\n  QuantstampAuditPolice public police;\n\n  // contract that stores token escrows of nodes on the network\n  QuantstampAuditTokenEscrow public tokenEscrow;\n\n  event LogAuditFinished(\n    uint256 requestId,\n    address auditor,\n    QuantstampAuditData.AuditState auditResult,\n    bytes report\n  );\n\n  event LogPoliceAuditFinished(\n    uint256 requestId,\n    address policeNode,\n    bytes report,\n    bool isVerified\n  );\n\n  event LogAuditRequested(uint256 requestId,\n    address requestor,\n    string uri,\n    uint256 price\n  );\n\n  event LogAuditAssigned(uint256 requestId,\n    address auditor,\n    address requestor,\n    string uri,\n    uint256 price,\n    uint256 requestBlockNumber);\n\n  /* solhint-disable event-name-camelcase */\n  event LogReportSubmissionError_InvalidAuditor(uint256 requestId, address auditor);\n  event LogReportSubmissionError_InvalidState(uint256 requestId, address auditor, QuantstampAuditData.AuditState state);\n  event LogReportSubmissionError_InvalidResult(uint256 requestId, address auditor, QuantstampAuditData.AuditState state);\n  event LogReportSubmissionError_ExpiredAudit(uint256 requestId, address auditor, uint256 allowanceBlockNumber);\n  event LogAuditAssignmentError_ExceededMaxAssignedRequests(address auditor);\n  event LogAuditAssignmentError_Understaked(address auditor, uint256 stake);\n  event LogAuditAssignmentUpdate_Expired(uint256 requestId, uint256 allowanceBlockNumber);\n  event LogClaimRewardsReachedGasLimit(address auditor);\n\n  /* solhint-enable event-name-camelcase */\n\n  event LogAuditQueueIsEmpty();\n\n  event LogPayAuditor(uint256 requestId, address auditor, uint256 amount);\n  event LogAuditNodePriceChanged(address auditor, uint256 amount);\n\n  event LogRefund(uint256 requestId, address requestor, uint256 amount);\n  event LogRefundInvalidRequestor(uint256 requestId, address requestor);\n  event LogRefundInvalidState(uint256 requestId, QuantstampAuditData.AuditState state);\n  event LogRefundInvalidFundsLocked(uint256 requestId, uint256 currentBlock, uint256 fundLockEndBlock);\n\n  // the audit queue has elements, but none satisfy the minPrice of the audit node\n  // amount corresponds to the current minPrice of the audit node\n  event LogAuditNodePriceHigherThanRequests(address auditor, uint256 amount);\n\n  enum AuditAvailabilityState {\n    Error,\n    Ready,      // an audit is available to be picked up\n    Empty,      // there is no audit request in the queue\n    Exceeded,   // number of incomplete audit requests is reached the cap\n    Underpriced, // all queued audit requests are less than the expected price\n    Understaked // the audit node's stake is not large enough to request its min price\n  }\n\n  /**\n   * @dev The constructor creates an audit contract.\n   * @param auditDataAddress The address of an AuditData that stores data used for performing audits.\n   * @param reportDataAddress The address of a ReportData that stores audit reports.\n   * @param escrowAddress The address of a QuantstampTokenEscrow contract that holds staked deposits of nodes.\n   * @param policeAddress The address of a QuantstampAuditPolice that performs report checking.\n   */\n  constructor (address auditDataAddress, address reportDataAddress, address escrowAddress, address policeAddress) public {\n    require(auditDataAddress != address(0));\n    require(reportDataAddress != address(0));\n    require(escrowAddress != address(0));\n    require(policeAddress != address(0));\n    auditData = QuantstampAuditData(auditDataAddress);\n    reportData = QuantstampAuditReportData(reportDataAddress);\n    tokenEscrow = QuantstampAuditTokenEscrow(escrowAddress);\n    police = QuantstampAuditPolice(policeAddress);\n  }\n\n  /**\n   * @dev Allows contract owner to set the lower cap the min audit price.\n   * @param amount The amount of wei-QSP.\n   */\n  function setMinAuditPriceLowerCap(uint256 amount) external onlyOwner {\n    minAuditPriceLowerCap = amount;\n  }\n\n  /**\n   * @dev Allows nodes to stake a deposit. The audit node must approve QuantstampAudit before invoking.\n   * @param amount The amount of wei-QSP to deposit.\n   */\n  function stake(uint256 amount) external returns(bool) {\n    // first acquire the tokens approved by the audit node\n    require(auditData.token().transferFrom(msg.sender, address(this), amount));\n    // use those tokens to approve a transfer in the escrow\n    auditData.token().approve(address(tokenEscrow), amount);\n    // a \"Deposited\" event is emitted in TokenEscrow\n    tokenEscrow.deposit(msg.sender, amount);\n    return true;\n  }\n\n  /**\n   * @dev Allows audit nodes to retrieve a deposit.\n   */\n  function unstake() external returns(bool) {\n    // the escrow contract ensures that the deposit is not currently locked\n    tokenEscrow.withdraw(msg.sender);\n    return true;\n  }\n\n  /**\n   * @dev Returns funds to the requestor.\n   * @param requestId Unique ID of the audit request.\n   */\n  function refund(uint256 requestId) external returns(bool) {\n    QuantstampAuditData.AuditState state = auditData.getAuditState(requestId);\n    // check that the audit exists and is in a valid state\n    if (state != QuantstampAuditData.AuditState.Queued &&\n          state != QuantstampAuditData.AuditState.Assigned &&\n            state != QuantstampAuditData.AuditState.Expired) {\n      emit LogRefundInvalidState(requestId, state);\n      return false;\n    }\n    address requestor = auditData.getAuditRequestor(requestId);\n    if (requestor != msg.sender) {\n      emit LogRefundInvalidRequestor(requestId, msg.sender);\n      return;\n    }\n    uint256 refundBlockNumber = auditData.getAuditAssignBlockNumber(requestId).add(auditData.auditTimeoutInBlocks());\n    // check that the audit node has not recently started the audit (locking the funds)\n    if (state == QuantstampAuditData.AuditState.Assigned) {\n      if (block.number <= refundBlockNumber) {\n        emit LogRefundInvalidFundsLocked(requestId, block.number, refundBlockNumber);\n        return false;\n      }\n      // the request is expired but not detected by getNextAuditRequest\n      updateAssignedAudits(requestId);\n    } else if (state == QuantstampAuditData.AuditState.Queued) {\n      // remove the request from the queue\n      // note that if an audit node is currently assigned the request, it is already removed from the queue\n      removeQueueElement(requestId);\n    }\n\n    // set the audit state to refunded\n    auditData.setAuditState(requestId, QuantstampAuditData.AuditState.Refunded);\n\n    // return the funds to the requestor\n    uint256 price = auditData.getAuditPrice(requestId);\n    emit LogRefund(requestId, requestor, price);\n    safeTransferFromDataContract(requestor, price);\n    return true;\n  }\n\n  /**\n   * @dev Submits audit request.\n   * @param contractUri Identifier of the resource to audit.\n   * @param price The total amount of tokens that will be paid for the audit.\n   */\n  function requestAudit(string contractUri, uint256 price) public returns(uint256) {\n    // it passes HEAD as the existing price, therefore may result in extra gas needed for list iteration\n    return requestAuditWithPriceHint(contractUri, price, HEAD);\n  }\n\n  /**\n   * @dev Submits audit request.\n   * @param contractUri Identifier of the resource to audit.\n   * @param price The total amount of tokens that will be paid for the audit.\n   * @param existingPrice Existing price in the list (price hint allows for optimization that can make insertion O(1)).\n   */\n  function requestAuditWithPriceHint(string contractUri, uint256 price, uint256 existingPrice) public whenNotPaused returns(uint256) {\n    require(price > 0);\n    require(price >= minAuditPriceLowerCap);\n\n    // transfer tokens to the data contract\n    require(auditData.token().transferFrom(msg.sender, address(auditData), price));\n    // store the audit\n    uint256 requestId = auditData.addAuditRequest(msg.sender, contractUri, price);\n\n    queueAuditRequest(requestId, existingPrice);\n\n    emit LogAuditRequested(requestId, msg.sender, contractUri, price); // solhint-disable-line not-rely-on-time\n\n    return requestId;\n  }\n\n  /**\n   * @dev Submits the report and pays the audit node for their work if the audit is completed.\n   * @param requestId Unique identifier of the audit request.\n   * @param auditResult Result of an audit.\n   * @param report a compressed report. TODO, let's document the report format.\n   */\n  function submitReport(uint256 requestId, QuantstampAuditData.AuditState auditResult, bytes report) public { // solhint-disable-line function-max-lines\n    if (QuantstampAuditData.AuditState.Completed != auditResult && QuantstampAuditData.AuditState.Error != auditResult) {\n      emit LogReportSubmissionError_InvalidResult(requestId, msg.sender, auditResult);\n      return;\n    }\n\n    QuantstampAuditData.AuditState auditState = auditData.getAuditState(requestId);\n    if (auditState != QuantstampAuditData.AuditState.Assigned) {\n      emit LogReportSubmissionError_InvalidState(requestId, msg.sender, auditState);\n      return;\n    }\n\n    // the sender must be the audit node\n    if (msg.sender != auditData.getAuditAuditor(requestId)) {\n      emit LogReportSubmissionError_InvalidAuditor(requestId, msg.sender);\n      return;\n    }\n\n    // remove the requestId from assigned queue\n    updateAssignedAudits(requestId);\n\n    // the audit node should not send a report after its allowed period\n    uint256 allowanceBlockNumber = auditData.getAuditAssignBlockNumber(requestId) + auditData.auditTimeoutInBlocks();\n    if (allowanceBlockNumber < block.number) {\n      // update assigned to expired state\n      auditData.setAuditState(requestId, QuantstampAuditData.AuditState.Expired);\n      emit LogReportSubmissionError_ExpiredAudit(requestId, msg.sender, allowanceBlockNumber);\n      return;\n    }\n\n    // update the audit information held in this contract\n    auditData.setAuditState(requestId, auditResult);\n    auditData.setAuditReportBlockNumber(requestId, block.number); // solhint-disable-line not-rely-on-time\n\n    // validate the audit state\n    require(isAuditFinished(requestId));\n\n    // store reports on-chain\n    reportData.setReport(requestId, report);\n\n    emit LogAuditFinished(requestId, msg.sender, auditResult, report);\n\n    // alert the police to verify the report\n    police.assignPoliceToReport(requestId);\n    // add the requestId to the pending payments that should be paid to the audit node after policing\n    police.addPendingPayment(msg.sender, requestId);\n    // pay fee to the police\n    if (police.reportProcessingFeePercentage() > 0 && police.numPoliceNodes() > 0) {\n      uint256 policeFee = police.collectFee(requestId);\n      safeTransferFromDataContract(address(police), policeFee);\n      police.splitPayment(policeFee);\n    }\n  }\n\n  /**\n   * @dev Returns the compressed report submitted by the audit node.\n   * @param requestId The ID of the audit request.\n   */\n  function getReport(uint256 requestId) public view returns (bytes) {\n    return reportData.getReport(requestId);\n  }\n\n  /**\n   * @dev Checks whether a given node is a police.\n   * @param node The address of the node to be checked.\n   * @return true if the target address is a police node.\n   */\n  function isPoliceNode(address node) public view returns(bool) {\n    return police.isPoliceNode(node);\n  }\n\n  /**\n   * @dev Submits verification of a report by a police node.\n   * @param requestId The ID of the audit request.\n   * @param report The compressed bytecode representation of the report.\n   * @param isVerified Whether the police node's report matches the submitted report.\n   *                   If not, the audit node is slashed.\n   * @return true if the report was submitted successfully.\n   */\n  function submitPoliceReport(\n    uint256 requestId,\n    bytes report,\n    bool isVerified) public returns (bool) {\n    require(police.isPoliceNode(msg.sender));\n    // get the address of the audit node\n    address auditNode = auditData.getAuditAuditor(requestId);\n    bool hasBeenSubmitted;\n    bool slashOccurred;\n    uint256 slashAmount;\n    // hasBeenSubmitted may be false if the police submission period has ended\n    (hasBeenSubmitted, slashOccurred, slashAmount) = police.submitPoliceReport(msg.sender, auditNode, requestId, report, isVerified);\n    if (hasBeenSubmitted) {\n      emit LogPoliceAuditFinished(requestId, msg.sender, report, isVerified);\n    }\n    if (slashOccurred) {\n      // transfer the audit request price to the police\n      uint256 auditPoliceFee = police.collectedFees(requestId);\n      uint256 adjustedPrice = auditData.getAuditPrice(requestId).sub(auditPoliceFee);\n      safeTransferFromDataContract(address(police), adjustedPrice);\n\n      // divide the adjusted price + slash among police assigned to report\n      police.splitPayment(adjustedPrice.add(slashAmount));\n    }\n    return hasBeenSubmitted;\n  }\n\n  /**\n   * @dev Determines whether the address (of an audit node) can claim any audit rewards.\n   */\n  function hasAvailableRewards () public view returns (bool) {\n    bool exists;\n    uint256 next;\n    (exists, next) = police.getNextAvailableReward(msg.sender, HEAD);\n    return exists;\n  }\n\n  /**\n   * @dev Returns the minimum price nodes could set\n   */\n  function getMinAuditPriceLowerCap() public view returns(uint256) {\n    return minAuditPriceLowerCap;\n  }\n\n  /**\n   * @dev Given a requestId, returns the next pending available reward for the audit node.\n   *      This can be used in conjunction with claimReward() if claimRewards fails due to gas limits.\n   * @param requestId The ID of the current linked list node\n   * @return true if the next reward exists, and the corresponding requestId in the linked list\n   */\n  function getNextAvailableReward (uint256 requestId) public view returns(bool, uint256) {\n    return police.getNextAvailableReward(msg.sender, requestId);\n  }\n\n  /**\n   * @dev If the policing period has ended without the report being marked invalid,\n   *      allow the audit node to claim the audit's reward.\n   * @param requestId The ID of the audit request.\n   * NOTE: We need this function if claimRewards always fails due to gas limits.\n   *       I think this can only happen if the audit node receives many (i.e., hundreds) of audits,\n   *       and never calls claimRewards() until much later.\n   */\n  function claimReward (uint256 requestId) public returns (bool) {\n    require(police.canClaimAuditReward(msg.sender, requestId));\n    police.setRewardClaimed(msg.sender, requestId);\n    transferReward(requestId);\n    return true;\n  }\n\n  /**\n   * @dev Claim all pending rewards for the audit node.\n   * @return Returns true if the operation ran to completion, or false if the loop exits due to gas limits.\n   */\n  function claimRewards () public returns (bool) {\n    // Yet another list iteration. Could ignore this check, but makes testing painful.\n    require(hasAvailableRewards());\n    bool exists;\n    uint256 requestId = HEAD;\n    uint256 remainingGasBeforeCall;\n    uint256 remainingGasAfterCall;\n    bool loopExitedDueToGasLimit;\n    // This loop occurs here (not in QuantstampAuditPolice) due to requiring the audit price,\n    // as otherwise we require more dependencies/mappings in QuantstampAuditPolice.\n    while (true) {\n      remainingGasBeforeCall = gasleft();\n      (exists, requestId) = police.claimNextReward(msg.sender, HEAD);\n      if (!exists) {\n        break;\n      }\n      transferReward(requestId);\n      remainingGasAfterCall = gasleft();\n      // multiplying by 2 to leave a bit of extra leeway, particularly due to the while-loop in claimNextReward\n      if (remainingGasAfterCall < remainingGasBeforeCall.sub(remainingGasAfterCall).mul(2)) {\n        loopExitedDueToGasLimit = true;\n        emit LogClaimRewardsReachedGasLimit(msg.sender);\n        break;\n      }\n    }\n    return loopExitedDueToGasLimit;\n  }\n\n  /**\n   * @dev Returns the total stake deposited by an address.\n   * @param addr The address to check.\n   */\n  function totalStakedFor(address addr) public view returns(uint256) {\n    return tokenEscrow.depositsOf(addr);\n  }\n\n  /**\n   * @dev Returns true if the sender staked enough.\n   * @param addr The address to check.\n   */\n  function hasEnoughStake(address addr) public view returns(bool) {\n    return tokenEscrow.hasEnoughStake(addr);\n  }\n\n  /**\n   * @dev Returns the minimum stake required to be an audit node.\n   */\n  function getMinAuditStake() public view returns(uint256) {\n    return tokenEscrow.minAuditStake();\n  }\n\n  /**\n   *  @dev Returns the timeout time (in blocks) for any given audit.\n   */\n  function getAuditTimeoutInBlocks() public view returns(uint256) {\n    return auditData.auditTimeoutInBlocks();\n  }\n\n  /**\n   *  @dev Returns the minimum price for a specific audit node.\n   */\n  function getMinAuditPrice (address auditor) public view returns(uint256) {\n    return auditData.getMinAuditPrice(auditor);\n  }\n\n  /**\n   * @dev Returns the maximum number of assigned audits for any given audit node.\n   */\n  function getMaxAssignedRequests() public view returns(uint256) {\n    return auditData.maxAssignedRequests();\n  }\n\n  /**\n   * @dev Determines if there is an audit request available to be picked up by the caller.\n   */\n  function anyRequestAvailable() public view returns(AuditAvailabilityState) {\n    uint256 requestId;\n\n    // check that the audit node's stake is large enough\n    if (!hasEnoughStake(msg.sender)) {\n      return AuditAvailabilityState.Understaked;\n    }\n\n    // there are no audits in the queue\n    if (!auditQueueExists()) {\n      return AuditAvailabilityState.Empty;\n    }\n\n    // check if the audit node's assignment count is not exceeded\n    if (assignedRequestCount[msg.sender] >= auditData.maxAssignedRequests()) {\n      return AuditAvailabilityState.Exceeded;\n    }\n\n    requestId = anyAuditRequestMatchesPrice(auditData.getMinAuditPrice(msg.sender));\n    if (requestId == 0) {\n      return AuditAvailabilityState.Underpriced;\n    }\n    return AuditAvailabilityState.Ready;\n  }\n\n  /**\n   * @dev Returns the next assigned report in a police node's assignment queue.\n   * @return true if the list is non-empty, requestId, auditPrice, uri, and policeAssignmentBlockNumber.\n   */\n  function getNextPoliceAssignment() public view returns (bool, uint256, uint256, string, uint256) {\n    return police.getNextPoliceAssignment(msg.sender);\n  }\n\n  /**\n   * @dev Finds a list of most expensive audits and assigns the oldest one to the audit node.\n   */\n  /* solhint-disable function-max-lines */\n  function getNextAuditRequest() public {\n    // remove an expired audit request\n    if (assignedAudits.listExists()) {\n      bool exists;\n      uint256 potentialExpiredRequestId;\n      (exists, potentialExpiredRequestId) = assignedAudits.getAdjacent(HEAD, NEXT);\n      uint256 allowanceBlockNumber = auditData.getAuditAssignBlockNumber(potentialExpiredRequestId) + auditData.auditTimeoutInBlocks();\n      if (allowanceBlockNumber < block.number) {\n        updateAssignedAudits(potentialExpiredRequestId);\n        auditData.setAuditState(potentialExpiredRequestId, QuantstampAuditData.AuditState.Expired);\n        emit LogAuditAssignmentUpdate_Expired(potentialExpiredRequestId, allowanceBlockNumber);\n      }\n    }\n\n    AuditAvailabilityState isRequestAvailable = anyRequestAvailable();\n    // there are no audits in the queue\n    if (isRequestAvailable == AuditAvailabilityState.Empty) {\n      emit LogAuditQueueIsEmpty();\n      return;\n    }\n\n    // check if the audit node's assignment is not exceeded\n    if (isRequestAvailable == AuditAvailabilityState.Exceeded) {\n      emit LogAuditAssignmentError_ExceededMaxAssignedRequests(msg.sender);\n      return;\n    }\n\n    uint256 minPrice = auditData.getMinAuditPrice(msg.sender);\n    require(minPrice >= minAuditPriceLowerCap);\n\n    // check that the audit node has staked enough QSP\n    if (isRequestAvailable == AuditAvailabilityState.Understaked) {\n      emit LogAuditAssignmentError_Understaked(msg.sender, totalStakedFor(msg.sender));\n      return;\n    }\n\n    // there are no audits in the queue with a price high enough for the audit node\n    uint256 requestId = dequeueAuditRequest(minPrice);\n    if (requestId == 0) {\n      emit LogAuditNodePriceHigherThanRequests(msg.sender, minPrice);\n      return;\n    }\n\n    auditData.setAuditState(requestId, QuantstampAuditData.AuditState.Assigned);\n    auditData.setAuditAuditor(requestId, msg.sender);\n    auditData.setAuditAssignBlockNumber(requestId, block.number);\n    assignedRequestCount[msg.sender]++;\n    // push to the tail\n    assignedAudits.push(requestId, PREV);\n\n    // lock stake when assigned\n    tokenEscrow.lockFunds(msg.sender, block.number.add(auditData.auditTimeoutInBlocks()).add(police.policeTimeoutInBlocks()));\n\n    mostRecentAssignedRequestIdsPerAuditor[msg.sender] = requestId;\n    emit LogAuditAssigned(requestId,\n      auditData.getAuditAuditor(requestId),\n      auditData.getAuditRequestor(requestId),\n      auditData.getAuditContractUri(requestId),\n      auditData.getAuditPrice(requestId),\n      auditData.getAuditRequestBlockNumber(requestId));\n  }\n  /* solhint-enable function-max-lines */\n\n  /**\n   * @dev Allows the audit node to set its minimum price per audit in wei-QSP.\n   * @param price The minimum price.\n   */\n  function setAuditNodePrice(uint256 price) public {\n    require(price >= minAuditPriceLowerCap);\n    require(price <= auditData.token().totalSupply());\n    auditData.setMinAuditPrice(msg.sender, price);\n    emit LogAuditNodePriceChanged(msg.sender, price);\n  }\n\n  /**\n   * @dev Checks if an audit is finished. It is considered finished when the audit is either completed or failed.\n   * @param requestId Unique ID of the audit request.\n   */\n  function isAuditFinished(uint256 requestId) public view returns(bool) {\n    QuantstampAuditData.AuditState state = auditData.getAuditState(requestId);\n    return state == QuantstampAuditData.AuditState.Completed || state == QuantstampAuditData.AuditState.Error;\n  }\n\n  /**\n   * @dev Given a price, returns the next price from the priceList.\n   * @param price A price indicated by a node in priceList.\n   * @return The next price in the linked list.\n   */\n  function getNextPrice(uint256 price) public view returns(uint256) {\n    bool exists;\n    uint256 next;\n    (exists, next) = priceList.getAdjacent(price, NEXT);\n    return next;\n  }\n\n  /**\n   * @dev Given a requestId, returns the next one from assignedAudits.\n   * @param requestId The ID of the current linked list node\n   * @return next requestId in the linked list\n   */\n  function getNextAssignedRequest(uint256 requestId) public view returns(uint256) {\n    bool exists;\n    uint256 next;\n    (exists, next) = assignedAudits.getAdjacent(requestId, NEXT);\n    return next;\n  }\n\n  /**\n   * @dev Returns the audit request most recently assigned to msg.sender.\n   * @return A tuple (requestId, audit_uri, audit_price, request_block_number).\n   */\n  function myMostRecentAssignedAudit() public view returns(\n    uint256, // requestId\n    address, // requestor\n    string,  // contract uri\n    uint256, // price\n    uint256  // request block number\n  ) {\n    uint256 requestId = mostRecentAssignedRequestIdsPerAuditor[msg.sender];\n    return (\n      requestId,\n      auditData.getAuditRequestor(requestId),\n      auditData.getAuditContractUri(requestId),\n      auditData.getAuditPrice(requestId),\n      auditData.getAuditRequestBlockNumber(requestId)\n    );\n  }\n\n  /**\n   * @dev Given a price and a requestId, the function returns the next requestId with the same price.\n   * Return 0, provided the given price does not exist in auditsByPrice.\n   * @param price The price value of the current bucket.\n   * @param requestId Unique Id of a requested audit.\n   * @return The next requestId with the same price.\n   */\n  function getNextAuditByPrice(uint256 price, uint256 requestId) public view returns(uint256) {\n    bool exists;\n    uint256 next;\n    (exists, next) = auditsByPrice[price].getAdjacent(requestId, NEXT);\n    return next;\n  }\n\n  /**\n   * @dev Given a price finds where it should be placed to build a sorted list.\n   * @return next First existing price higher than the passed price.\n   */\n  function findPrecedingPrice(uint256 price) public view returns(uint256) {\n    return priceList.getSortedSpot(HEAD, price, NEXT);\n  }\n\n  /**\n   * @dev Given a requestId, the function removes it from the list of audits and decreases the number of assigned\n   * audits of the associated audit node.\n   * @param requestId Unique ID of a requested audit.\n   */\n  function updateAssignedAudits(uint256 requestId) internal {\n    assignedAudits.remove(requestId);\n    assignedRequestCount[auditData.getAuditAuditor(requestId)] =\n      assignedRequestCount[auditData.getAuditAuditor(requestId)].sub(1);\n  }\n\n  /**\n   * @dev Checks if the list of audits has any elements.\n   */\n  function auditQueueExists() internal view returns(bool) {\n    return priceList.listExists();\n  }\n\n  /**\n   * @dev Adds an audit request to the queue.\n   * @param requestId Request ID.\n   * @param existingPrice The price of an existing audit in the queue (makes insertion O(1)).\n   */\n  function queueAuditRequest(uint256 requestId, uint256 existingPrice) internal {\n    uint256 price = auditData.getAuditPrice(requestId);\n    if (!priceList.nodeExists(price)) {\n      uint256 priceHint = priceList.nodeExists(existingPrice) ? existingPrice : HEAD;\n      // if a price bucket doesn't exist, create it next to an existing one\n      priceList.insert(priceList.getSortedSpot(priceHint, price, NEXT), price, PREV);\n    }\n    // push to the tail\n    auditsByPrice[price].push(requestId, PREV);\n  }\n\n  /**\n   * @dev Evaluates if there is an audit price >= minPrice.\n   * Note that there should not be any audit with price as 0.\n   * @param minPrice The minimum audit price.\n   * @return The requestId of an audit adhering to the minPrice, or 0 if no such audit exists.\n   */\n  function anyAuditRequestMatchesPrice(uint256 minPrice) internal view returns(uint256) {\n    bool priceExists;\n    uint256 price;\n    uint256 requestId;\n\n    // picks the tail of price buckets\n    (priceExists, price) = priceList.getAdjacent(HEAD, PREV);\n    if (price < minPrice) {\n      return 0;\n    }\n    requestId = getNextAuditByPrice(price, HEAD);\n    return requestId;\n  }\n\n  /**\n   * @dev Finds a list of most expensive audits and returns the oldest one that has a price >= minPrice.\n   * @param minPrice The minimum audit price.\n   */\n  function dequeueAuditRequest(uint256 minPrice) internal returns(uint256) {\n\n    uint256 requestId;\n    uint256 price;\n\n    // picks the tail of price buckets\n    // TODO seems the following statement is redundantly called from getNextAuditRequest. If this is the only place\n    // to call dequeueAuditRequest, then removing the following line saves gas, but leaves dequeueAuditRequest\n    // unsafe for further extension.\n    requestId = anyAuditRequestMatchesPrice(minPrice);\n\n    if (requestId > 0) {\n      price = auditData.getAuditPrice(requestId);\n      auditsByPrice[price].remove(requestId);\n      // removes the price bucket if it contains no requests\n      if (!auditsByPrice[price].listExists()) {\n        priceList.remove(price);\n      }\n      return requestId;\n    }\n    return 0;\n  }\n\n  /**\n   * @dev Removes an element from the list.\n   * @param requestId The Id of the request to be removed.\n   */\n  function removeQueueElement(uint256 requestId) internal {\n    uint256 price = auditData.getAuditPrice(requestId);\n\n    // the node must exist in the list\n    require(priceList.nodeExists(price));\n    require(auditsByPrice[price].nodeExists(requestId));\n\n    auditsByPrice[price].remove(requestId);\n    if (!auditsByPrice[price].listExists()) {\n      priceList.remove(price);\n    }\n  }\n\n  /**\n   * @dev Internal helper function to perform the transfer of rewards.\n   * @param requestId The ID of the audit request.\n   */\n  function transferReward (uint256 requestId) internal {\n    uint256 auditPoliceFee = police.collectedFees(requestId);\n    uint256 auditorPayment = auditData.getAuditPrice(requestId).sub(auditPoliceFee);\n    safeTransferFromDataContract(msg.sender, auditorPayment);\n    emit LogPayAuditor(requestId, msg.sender, auditorPayment);\n  }\n\n  /**\n   * @dev Used to transfer funds stored in the data contract to a given address.\n   * @param _to The address to transfer funds.\n   * @param amount The number of wei-QSP to be transferred.\n   */\n  function safeTransferFromDataContract(address _to, uint256 amount) internal {\n    auditData.approveWhitelisted(amount);\n    require(auditData.token().transferFrom(address(auditData), _to, amount));\n  }\n}",
  "abi": "[{\"constant\":true,\"inputs\":[],\"name\":\"reportData\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"requestId\",\"type\":\"uint256\"}],\"name\":\"isAuditFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMinAuditPriceLowerCap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"setAuditNodePrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contractUri\",\"type\":\"string\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"requestAudit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"requestId\",\"type\":\"uint256\"}],\"name\":\"refund\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"requestId\",\"type\":\"uint256\"}],\"name\":\"getNextAuditByPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unstake\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myMostRecentAssignedAudit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"mostRecentAssignedRequestIdsPerAuditor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"requestId\",\"type\":\"uint256\"},{\"name\":\"report\",\"type\":\"bytes\"},{\"name\":\"isVerified\",\"type\":\"bool\"}],\"name\":\"submitPoliceReport\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimRewards\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contractUri\",\"type\":\"string\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"existingPrice\",\"type\":\"uint256\"}],\"name\":\"requestAuditWithPriceHint\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"totalStakedFor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"requestId\",\"type\":\"uint256\"}],\"name\":\"getReport\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"requestId\",\"type\":\"uint256\"}],\"name\":\"getNextAvailableReward\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"requestId\",\"type\":\"uint256\"}],\"name\":\"getNextAssignedRequest\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMinAuditPriceLowerCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"auditData\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"anyRequestAvailable\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"hasEnoughStake\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMaxAssignedRequests\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAuditTimeoutInBlocks\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"getNextPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMinAuditStake\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasAvailableRewards\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenEscrow\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"requestId\",\"type\":\"uint256\"}],\"name\":\"claimReward\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getNextAuditRequest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"police\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"assignedRequestCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"requestId\",\"type\":\"uint256\"},{\"name\":\"auditResult\",\"type\":\"uint8\"},{\"name\":\"report\",\"type\":\"bytes\"}],\"name\":\"submitReport\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"findPrecedingPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"node\",\"type\":\"address\"}],\"name\":\"isPoliceNode\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNextPoliceAssignment\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"auditor\",\"type\":\"address\"}],\"name\":\"getMinAuditPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"auditDataAddress\",\"type\":\"address\"},{\"name\":\"reportDataAddress\",\"type\":\"address\"},{\"name\":\"escrowAddress\",\"type\":\"address\"},{\"name\":\"policeAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"auditor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"auditResult\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"report\",\"type\":\"bytes\"}],\"name\":\"LogAuditFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"policeNode\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"report\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"isVerified\",\"type\":\"bool\"}],\"name\":\"LogPoliceAuditFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"requestor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"uri\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"LogAuditRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"auditor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"requestor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"uri\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"requestBlockNumber\",\"type\":\"uint256\"}],\"name\":\"LogAuditAssigned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"auditor\",\"type\":\"address\"}],\"name\":\"LogReportSubmissionError_InvalidAuditor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"auditor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"state\",\"type\":\"uint8\"}],\"name\":\"LogReportSubmissionError_InvalidState\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"auditor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"state\",\"type\":\"uint8\"}],\"name\":\"LogReportSubmissionError_InvalidResult\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"auditor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"allowanceBlockNumber\",\"type\":\"uint256\"}],\"name\":\"LogReportSubmissionError_ExpiredAudit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"auditor\",\"type\":\"address\"}],\"name\":\"LogAuditAssignmentError_ExceededMaxAssignedRequests\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"auditor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"stake\",\"type\":\"uint256\"}],\"name\":\"LogAuditAssignmentError_Understaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"allowanceBlockNumber\",\"type\":\"uint256\"}],\"name\":\"LogAuditAssignmentUpdate_Expired\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"auditor\",\"type\":\"address\"}],\"name\":\"LogClaimRewardsReachedGasLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LogAuditQueueIsEmpty\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"auditor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogPayAuditor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"auditor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogAuditNodePriceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"requestor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"requestor\",\"type\":\"address\"}],\"name\":\"LogRefundInvalidRequestor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"state\",\"type\":\"uint8\"}],\"name\":\"LogRefundInvalidState\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"currentBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fundLockEndBlock\",\"type\":\"uint256\"}],\"name\":\"LogRefundInvalidFundsLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"auditor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogAuditNodePriceHigherThanRequests\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]",
  "bytecode": "60806040526000805460a060020a60ff02191681556001553480156200002457600080fd5b506040516080806200549e833981016040908152815160208301519183015160609093015160008054600160a060020a03191633179055909290600160a060020a03841615156200007457600080fd5b600160a060020a03831615156200008a57600080fd5b600160a060020a0382161515620000a057600080fd5b600160a060020a0381161515620000b657600080fd5b60078054600160a060020a03958616600160a060020a0319918216179091556008805494861694821694909417909355600a8054928516928416929092179091556009805491909316911617905561538a80620001146000396000f3006080604052600436106101f55763ffffffff60e060020a6000350416630c36eb2181146101fa57806310debdf81461022b57806321a4d25914610257578063236ebbae146102715780632520071814610289578063278ecde1146102f65780632c90ccba1461030e5780632def6620146103295780632fd1b3201461033e57806332143a35146103f95780633224ba231461041a578063372500ab1461047c5780633f4ba83a146104915780634115f883146104a65780634b341aed146105085780634e7f9b19146105295780635650152b146105b65780635905b171146105e95780635c8f66f3146106015780635c975abb146106165780636072ec641461062b5780636ca78a1c14610640578063715018a61461067957806379735d541461068e5780637d2b48bb146106af578063823b5e9f146106c45780638456cb59146106d95780638da5cb5b146106ee578063976e0da9146107035780639a3fc2251461071b5780639bb1cfd614610730578063a694fc3a14610745578063aac41ed61461075d578063ae169a5014610772578063be7a31641461078a578063c7330dd41461079f578063d1e0cc21146107b4578063dc61b497146107d5578063de3039d214610838578063e4ca784b14610850578063f2fde38b14610871578063f769aeb214610892578063fcb0a7ad146108ff575b600080fd5b34801561020657600080fd5b5061020f610920565b60408051600160a060020a039092168252519081900360200190f35b34801561023757600080fd5b5061024360043561092f565b604080519115158252519081900360200190f35b34801561026357600080fd5b5061026f6004356109f4565b005b34801561027d57600080fd5b5061026f600435610a10565b34801561029557600080fd5b506040805160206004803580820135601f81018490048402850184019095528484526102e49436949293602493928401919081908401838280828437509497505093359450610bf59350505050565b60408051918252519081900360200190f35b34801561030257600080fd5b50610243600435610c0c565b34801561031a57600080fd5b506102e4600435602435611115565b34801561033557600080fd5b506102436111bd565b34801561034a57600080fd5b50610353611240565b6040518086815260200185600160a060020a0316600160a060020a0316815260200180602001848152602001838152602001828103825285818151815260200191508051906020019080838360005b838110156103ba5781810151838201526020016103a2565b50505050905090810190601f1680156103e75780820380516001836020036101000a031916815260200191505b50965050505050505060405180910390f35b34801561040557600080fd5b506102e4600160a060020a03600435166114fd565b34801561042657600080fd5b5060408051602060046024803582810135601f810185900485028601850190965285855261024395833595369560449491939091019190819084018382808284375094975050505091351515925061150f915050565b34801561048857600080fd5b50610243611a1d565b34801561049d57600080fd5b5061026f611b6f565b3480156104b257600080fd5b506040805160206004803580820135601f81018490048402850184019095528484526102e4943694929360249392840191908190840183828082843750949750508435955050506020909201359150611be59050565b34801561051457600080fd5b506102e4600160a060020a0360043516611f22565b34801561053557600080fd5b50610541600435611fbf565b6040805160208082528351818301528351919283929083019185019080838360005b8381101561057b578181015183820152602001610563565b50505050905090810190601f1680156105a85780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b3480156105c257600080fd5b506105ce6004356120b3565b60408051921515835260208301919091528051918290030190f35b3480156105f557600080fd5b506102e460043561215c565b34801561060d57600080fd5b506102e4612204565b34801561062257600080fd5b5061024361220a565b34801561063757600080fd5b5061020f61221a565b34801561064c57600080fd5b50610655612229565b6040518082600581111561066557fe5b60ff16815260200191505060405180910390f35b34801561068557600080fd5b5061026f6123ab565b34801561069a57600080fd5b50610243600160a060020a0360043516612417565b3480156106bb57600080fd5b506102e4612482565b3480156106d057600080fd5b506102e4612512565b3480156106e557600080fd5b5061026f61255b565b3480156106fa57600080fd5b5061020f6125d6565b34801561070f57600080fd5b506102e46004356125e5565b34801561072757600080fd5b506102e461264b565b34801561073c57600080fd5b506102436126aa565b34801561075157600080fd5b5061024360043561274d565b34801561076957600080fd5b5061020f612a25565b34801561077e57600080fd5b50610243600435612a34565b34801561079657600080fd5b5061026f612b82565b3480156107ab57600080fd5b5061020f6137a8565b3480156107c057600080fd5b506102e4600160a060020a03600435166137b7565b3480156107e157600080fd5b50604080516020600460443581810135601f810184900484028501840190955284845261026f948235946024803560ff16953695946064949201919081908401838280828437509497506137c99650505050505050565b34801561084457600080fd5b506102e4600435614224565b34801561085c57600080fd5b50610243600160a060020a03600435166142ba565b34801561087d57600080fd5b5061026f600160a060020a0360043516614325565b34801561089e57600080fd5b506108a7614348565b60405180861515151581526020018581526020018481526020018060200183815260200182810382528481815181526020019150805190602001908083836000838110156103ba5781810151838201526020016103a2565b34801561090b57600080fd5b506102e4600160a060020a036004351661446f565b600854600160a060020a031681565b600754604080517f0783c2ef0000000000000000000000000000000000000000000000000000000081526004810184905290516000928392600160a060020a0390911691630783c2ef9160248082019260209290919082900301818787803b15801561099a57600080fd5b505af11580156109ae573d6000803e3d6000fd5b505050506040513d60208110156109c457600080fd5b5051905060048160078111156109d657fe5b14806109ed575060058160078111156109eb57fe5b145b9392505050565b600054600160a060020a03163314610a0b57600080fd5b600155565b600154811015610a1f57600080fd5b600760009054906101000a9004600160a060020a0316600160a060020a031663fc0c546a6040518163ffffffff1660e060020a028152600401602060405180830381600087803b158015610a7257600080fd5b505af1158015610a86573d6000803e3d6000fd5b505050506040513d6020811015610a9c57600080fd5b5051604080517f18160ddd0000000000000000000000000000000000000000000000000000000081529051600160a060020a03909216916318160ddd916004808201926020929091908290030181600087803b158015610afb57600080fd5b505af1158015610b0f573d6000803e3d6000fd5b505050506040513d6020811015610b2557600080fd5b5051811115610b3357600080fd5b600754604080517fd5c21c4f000000000000000000000000000000000000000000000000000000008152336004820152602481018490529051600160a060020a039092169163d5c21c4f9160448082019260009290919082900301818387803b158015610b9f57600080fd5b505af1158015610bb3573d6000803e3d6000fd5b5050604080513381526020810185905281517fddbe8ac5fd80afcdfe74510771f42b2d5faa2540275a36ec03f427b8746a8fdd9450908190039091019150a150565b6000610c0383836000611be5565b90505b92915050565b6000806000806000600760009054906101000a9004600160a060020a0316600160a060020a0316630783c2ef876040518263ffffffff1660e060020a02815260040180828152602001915050602060405180830381600087803b158015610c7257600080fd5b505af1158015610c86573d6000803e3d6000fd5b505050506040513d6020811015610c9c57600080fd5b505193506001846007811115610cae57fe5b14158015610cc857506002846007811115610cc557fe5b14155b8015610ce057506006846007811115610cdd57fe5b14155b15610d3b577f252974ce60c3b659020152c6a83af57c5bbce037c4ee31c2b314351add4da7be868560405180838152602001826007811115610d1e57fe5b60ff1681526020019250505060405180910390a16000945061110c565b600754604080517fe0ebdbff000000000000000000000000000000000000000000000000000000008152600481018990529051600160a060020a039092169163e0ebdbff916024808201926020929091908290030181600087803b158015610da257600080fd5b505af1158015610db6573d6000803e3d6000fd5b505050506040513d6020811015610dcc57600080fd5b50519250600160a060020a0383163314610e1f576040805187815233602082015281517fc51ab1f8d63f8e46b3c04ac4a66ac4b693cb2ce80c3b5b7389e154353082592f929181900390910190a161110c565b6007546040805160e060020a63de42f0450281529051610f3592600160a060020a03169163de42f0459160048083019260209291908290030181600087803b158015610e6a57600080fd5b505af1158015610e7e573d6000803e3d6000fd5b505050506040513d6020811015610e9457600080fd5b5051600754604080517f630eb125000000000000000000000000000000000000000000000000000000008152600481018b90529051600160a060020a039092169163630eb125916024808201926020929091908290030181600087803b158015610efd57600080fd5b505af1158015610f11573d6000803e3d6000fd5b505050506040513d6020811015610f2757600080fd5b50519063ffffffff6144da16565b91506002846007811115610f4557fe5b1415610fa857438210610f9a576040805187815243602082015280820184905290517fdb8b2c3ddf278f26b9faf68fffeaf005fdf4fdb58edc05affdf9fcf5efd2294a9181900360600190a16000945061110c565b610fa3866144e7565b610fc5565b6001846007811115610fb657fe5b1415610fc557610fc586614644565b6007546040805160e260020a63226be83b02815260048101899052600360248201529051600160a060020a03909216916389afa0ec9160448082019260009290919082900301818387803b15801561101c57600080fd5b505af1158015611030573d6000803e3d6000fd5b50506007546040805160e060020a63c15185f5028152600481018b90529051600160a060020a03909216935063c15185f592506024808201926020929091908290030181600087803b15801561108557600080fd5b505af1158015611099573d6000803e3d6000fd5b505050506040513d60208110156110af57600080fd5b505160408051888152600160a060020a038616602082015280820183905290519192507fd712b46ccde5e095a18ecd18aed6bf9d83d9263601d1942365932b15f23cd7da919081900360600190a161110783826148cf565b600194505b50505050919050565b6000828152600460208190526040808320815160e260020a6315d011eb02815292830152602482018490526001604483015280518392839273697e2033ba28c1cc9e28d94ca910ca53a978aad09263574047ac926064808201939291829003018186803b15801561118557600080fd5b505af4158015611199573d6000803e3d6000fd5b505050506040513d60408110156111af57600080fd5b506020015195945050505050565b600a54604080517f51cff8d90000000000000000000000000000000000000000000000000000000081523360048201529051600092600160a060020a0316916351cff8d9916024808301928692919082900301818387803b15801561122157600080fd5b505af1158015611235573d6000803e3d6000fd5b505050506001905090565b3360009081526006602090815260408083205460075482517fe0ebdbff00000000000000000000000000000000000000000000000000000000815260048101839052925185946060948694859490938493600160a060020a039092169263e0ebdbff92602480830193919282900301818987803b1580156112c057600080fd5b505af11580156112d4573d6000803e3d6000fd5b505050506040513d60208110156112ea57600080fd5b5051600754604080517f843e240e000000000000000000000000000000000000000000000000000000008152600481018690529051600160a060020a039092169163843e240e9160248082019260009290919082900301818387803b15801561135257600080fd5b505af1158015611366573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052602081101561138f57600080fd5b8101908080516401000000008111156113a757600080fd5b820160208101848111156113ba57600080fd5b81516401000000008111828201871017156113d457600080fd5b50506007546040805160e060020a63c15185f5028152600481018a90529051929550600160a060020a03909116935063c15185f592506024808201926020929091908290030181600087803b15801561142c57600080fd5b505af1158015611440573d6000803e3d6000fd5b505050506040513d602081101561145657600080fd5b5051600754604080517f2d4194c7000000000000000000000000000000000000000000000000000000008152600481018890529051600160a060020a0390921691632d4194c7916024808201926020929091908290030181600087803b1580156114bf57600080fd5b505af11580156114d3573d6000803e3d6000fd5b505050506040513d60208110156114e957600080fd5b5051939a9299509097509550909350915050565b60066020526000908152604090205481565b600954604080517fe4ca784b0000000000000000000000000000000000000000000000000000000081523360048201529051600092839283928392839283928392600160a060020a03169163e4ca784b91602480830192602092919082900301818787803b15801561158057600080fd5b505af1158015611594573d6000803e3d6000fd5b505050506040513d60208110156115aa57600080fd5b505115156115b757600080fd5b6007546040805160e060020a633c9a5d59028152600481018d90529051600160a060020a0390921691633c9a5d59916024808201926020929091908290030181600087803b15801561160857600080fd5b505af115801561161c573d6000803e3d6000fd5b505050506040513d602081101561163257600080fd5b81019080805190602001909291905050509550600960009054906101000a9004600160a060020a0316600160a060020a0316636afef23f33888d8d8d6040518663ffffffff1660e060020a0281526004018086600160a060020a0316600160a060020a0316815260200185600160a060020a0316600160a060020a031681526020018481526020018060200183151515158152602001828103825284818151815260200191508051906020019080838360005b838110156116fd5781810151838201526020016116e5565b50505050905090810190601f16801561172a5780820380516001836020036101000a031916815260200191505b509650505050505050606060405180830381600087803b15801561174d57600080fd5b505af1158015611761573d6000803e3d6000fd5b505050506040513d606081101561177757600080fd5b50805160208201516040909201519096509094509250841561185b577f70a7ec97048a84d6fad0b20372a959338939da2fae30107b8f34c8d1159c70028a338b8b6040518085815260200184600160a060020a0316600160a060020a031681526020018060200183151515158152602001828103825284818151815260200191508051906020019080838360005b8381101561181d578181015183820152602001611805565b50505050905090810190601f16801561184a5780820380516001836020036101000a031916815260200191505b509550505050505060405180910390a15b8315611a0f57600954604080517f309945ba000000000000000000000000000000000000000000000000000000008152600481018d90529051600160a060020a039092169163309945ba916024808201926020929091908290030181600087803b1580156118c857600080fd5b505af11580156118dc573d6000803e3d6000fd5b505050506040513d60208110156118f257600080fd5b50516007546040805160e060020a63c15185f5028152600481018e90529051929450611983928592600160a060020a03169163c15185f59160248083019260209291908290030181600087803b15801561194b57600080fd5b505af115801561195f573d6000803e3d6000fd5b505050506040513d602081101561197557600080fd5b50519063ffffffff614a7a16565b60095490915061199c90600160a060020a0316826148cf565b600954600160a060020a031663641446eb6119bd838663ffffffff6144da16565b6040518263ffffffff1660e060020a02815260040180828152602001915050600060405180830381600087803b1580156119f657600080fd5b505af1158015611a0a573d6000803e3d6000fd5b505050505b509298975050505050505050565b600080600080600080611a2e6126aa565b1515611a3957600080fd5b600093505b5a600954604080517f0deaf3f80000000000000000000000000000000000000000000000000000000081523360048201526000602482018190528251949750600160a060020a0390931693630deaf3f893604480840194938390030190829087803b158015611aac57600080fd5b505af1158015611ac0573d6000803e3d6000fd5b505050506040513d6040811015611ad657600080fd5b5080516020909101519095509350841515611af057611b66565b611af984614a8c565b5a9150611b1d6002611b11858563ffffffff614a7a16565b9063ffffffff614bca16565b821015611b6157506040805133815290516001917f764bdfe1f1effdf0cae61d67e6bd6fd090076b62ac5625f7f31169e635119ced919081900360200190a1611b66565b611a3e565b95945050505050565b600054600160a060020a03163314611b8657600080fd5b60005460a060020a900460ff161515611b9e57600080fd5b6000805474ff0000000000000000000000000000000000000000191681556040517f7805862f689e2f13df9f062ff482ad3ad112aca9e0847911ed832e158c525b339190a1565b60008054819060a060020a900460ff1615611bff57600080fd5b60008411611c0c57600080fd5b600154841015611c1b57600080fd5b600760009054906101000a9004600160a060020a0316600160a060020a031663fc0c546a6040518163ffffffff1660e060020a028152600401602060405180830381600087803b158015611c6e57600080fd5b505af1158015611c82573d6000803e3d6000fd5b505050506040513d6020811015611c9857600080fd5b5051600754604080517f23b872dd000000000000000000000000000000000000000000000000000000008152336004820152600160a060020a03928316602482015260448101889052905191909216916323b872dd9160648083019260209291908290030181600087803b158015611d0f57600080fd5b505af1158015611d23573d6000803e3d6000fd5b505050506040513d6020811015611d3957600080fd5b50511515611d4657600080fd5b6007546040517f23d2691b000000000000000000000000000000000000000000000000000000008152336004820181815260448301889052606060248401908152895160648501528951600160a060020a03909516946323d2691b948b938b939092909160840190602086019080838360005b83811015611dd1578181015183820152602001611db9565b50505050905090810190601f168015611dfe5780820380516001836020036101000a031916815260200191505b50945050505050602060405180830381600087803b158015611e1f57600080fd5b505af1158015611e33573d6000803e3d6000fd5b505050506040513d6020811015611e4957600080fd5b50519050611e578184614bf3565b7f4840dade871b5e2ef351b94bf0013ddc305ba95cf2db9d14b18720e1267b5bca813387876040518085815260200184600160a060020a0316600160a060020a0316815260200180602001838152602001828103825284818151815260200191508051906020019080838360005b83811015611edd578181015183820152602001611ec5565b50505050905090810190601f168015611f0a5780820380516001836020036101000a031916815260200191505b509550505050505060405180910390a1949350505050565b600a54604080517fe3a9db1a000000000000000000000000000000000000000000000000000000008152600160a060020a0384811660048301529151600093929092169163e3a9db1a9160248082019260209290919082900301818787803b158015611f8d57600080fd5b505af1158015611fa1573d6000803e3d6000fd5b505050506040513d6020811015611fb757600080fd5b505192915050565b600854604080517f4e7f9b19000000000000000000000000000000000000000000000000000000008152600481018490529051606092600160a060020a031691634e7f9b1991602480830192600092919082900301818387803b15801561202557600080fd5b505af1158015612039573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052602081101561206257600080fd5b81019080805164010000000081111561207a57600080fd5b8201602081018481111561208d57600080fd5b81516401000000008111828201871017156120a757600080fd5b50909695505050505050565b600954604080517f4394aaad0000000000000000000000000000000000000000000000000000000081523360048201526024810184905281516000938493600160a060020a0390911692634394aaad926044808301939282900301818787803b15801561211f57600080fd5b505af1158015612133573d6000803e3d6000fd5b505050506040513d604081101561214957600080fd5b5080516020909101519092509050915091565b6040805160e260020a6315d011eb02815260056004820152602481018390526001604482015281516000928392839273697e2033ba28c1cc9e28d94ca910ca53a978aad09263574047ac9260648082019391829003018186803b1580156121c257600080fd5b505af41580156121d6573d6000803e3d6000fd5b505050506040513d60408110156121ec57600080fd5b508051602090910151935091508290505b5050919050565b60015490565b60005460a060020a900460ff1681565b600754600160a060020a031681565b60008061223533612417565b151561224457600591506123a7565b61224c614e86565b151561225b57600291506123a7565b600760009054906101000a9004600160a060020a0316600160a060020a031663f773a3fb6040518163ffffffff1660e060020a028152600401602060405180830381600087803b1580156122ae57600080fd5b505af11580156122c2573d6000803e3d6000fd5b505050506040513d60208110156122d857600080fd5b505133600090815260026020526040902054106122f857600391506123a7565b600754604080517ffcb0a7ad000000000000000000000000000000000000000000000000000000008152336004820152905161239092600160a060020a03169163fcb0a7ad9160248083019260209291908290030181600087803b15801561235f57600080fd5b505af1158015612373573d6000803e3d6000fd5b505050506040513d602081101561238957600080fd5b5051614ef1565b90508015156123a257600491506123a7565b600191505b5090565b600054600160a060020a031633146123c257600080fd5b60008054604051600160a060020a03909116917ff8df31144d9c2f0f6b59d69b8b98abd5459d07f2742c4df920b25aae33c6482091a26000805473ffffffffffffffffffffffffffffffffffffffff19169055565b600a54604080517f79735d54000000000000000000000000000000000000000000000000000000008152600160a060020a038481166004830152915160009392909216916379735d549160248082019260209290919082900301818787803b158015611f8d57600080fd5b600754604080517ff773a3fb0000000000000000000000000000000000000000000000000000000081529051600092600160a060020a03169163f773a3fb91600480830192602092919082900301818787803b1580156124e157600080fd5b505af11580156124f5573d6000803e3d6000fd5b505050506040513d602081101561250b57600080fd5b5051905090565b6007546040805160e060020a63de42f0450281529051600092600160a060020a03169163de42f04591600480830192602092919082900301818787803b1580156124e157600080fd5b600054600160a060020a0316331461257257600080fd5b60005460a060020a900460ff161561258957600080fd5b6000805474ff0000000000000000000000000000000000000000191660a060020a1781556040517f6985a02210a168e66602d3235cb6db0e70f92b3ba4d376a33c0f3d9434bff6259190a1565b600054600160a060020a031681565b6040805160e260020a6315d011eb02815260036004820152602481018390526001604482015281516000928392839273697e2033ba28c1cc9e28d94ca910ca53a978aad09263574047ac9260648082019391829003018186803b1580156121c257600080fd5b600a54604080517fc7d1b0980000000000000000000000000000000000000000000000000000000081529051600092600160a060020a03169163c7d1b09891600480830192602092919082900301818787803b1580156124e157600080fd5b600954604080517f4394aaad0000000000000000000000000000000000000000000000000000000081523360048201526000602482018190528251909384938493600160a060020a0390921692634394aaad92604480820193929182900301818787803b15801561271a57600080fd5b505af115801561272e573d6000803e3d6000fd5b505050506040513d604081101561274457600080fd5b50519392505050565b600754604080517ffc0c546a0000000000000000000000000000000000000000000000000000000081529051600092600160a060020a03169163fc0c546a91600480830192602092919082900301818787803b1580156127ac57600080fd5b505af11580156127c0573d6000803e3d6000fd5b505050506040513d60208110156127d657600080fd5b5051604080517f23b872dd000000000000000000000000000000000000000000000000000000008152336004820152306024820152604481018590529051600160a060020a03909216916323b872dd916064808201926020929091908290030181600087803b15801561284857600080fd5b505af115801561285c573d6000803e3d6000fd5b505050506040513d602081101561287257600080fd5b5051151561287f57600080fd5b600760009054906101000a9004600160a060020a0316600160a060020a031663fc0c546a6040518163ffffffff1660e060020a028152600401602060405180830381600087803b1580156128d257600080fd5b505af11580156128e6573d6000803e3d6000fd5b505050506040513d60208110156128fc57600080fd5b5051600a54604080517f095ea7b3000000000000000000000000000000000000000000000000000000008152600160a060020a039283166004820152602481018690529051919092169163095ea7b39160448083019260209291908290030181600087803b15801561296d57600080fd5b505af1158015612981573d6000803e3d6000fd5b505050506040513d602081101561299757600080fd5b5050600a54604080517f47e7ef24000000000000000000000000000000000000000000000000000000008152336004820152602481018590529051600160a060020a03909216916347e7ef249160448082019260009290919082900301818387803b158015612a0557600080fd5b505af1158015612a19573d6000803e3d6000fd5b50600195945050505050565b600a54600160a060020a031681565b600954604080517f9c40478c000000000000000000000000000000000000000000000000000000008152336004820152602481018490529051600092600160a060020a031691639c40478c91604480830192602092919082900301818787803b158015612aa057600080fd5b505af1158015612ab4573d6000803e3d6000fd5b505050506040513d6020811015612aca57600080fd5b50511515612ad757600080fd5b600954604080517f94558862000000000000000000000000000000000000000000000000000000008152336004820152602481018590529051600160a060020a03909216916394558862916044808201926020929091908290030181600087803b158015612b4457600080fd5b505af1158015612b58573d6000803e3d6000fd5b505050506040513d6020811015612b6e57600080fd5b50612b7a905082614a8c565b506001919050565b600080600080600080600573697e2033ba28c1cc9e28d94ca910ca53a978aad06353d00bd490916040518263ffffffff1660e060020a0281526004018082815260200191505060206040518083038186803b158015612be057600080fd5b505af4158015612bf4573d6000803e3d6000fd5b505050506040513d6020811015612c0a57600080fd5b505115612e69576040805160e260020a6315d011eb028152600560048201526000602482015260016044820152815173697e2033ba28c1cc9e28d94ca910ca53a978aad09263574047ac9260648082019391829003018186803b158015612c7057600080fd5b505af4158015612c84573d6000803e3d6000fd5b505050506040513d6040811015612c9a57600080fd5b5080516020918201516007546040805160e060020a63de42f0450281529051939a50919850600160a060020a03169263de42f045926004808401938290030181600087803b158015612ceb57600080fd5b505af1158015612cff573d6000803e3d6000fd5b505050506040513d6020811015612d1557600080fd5b5051600754604080517f630eb125000000000000000000000000000000000000000000000000000000008152600481018990529051600160a060020a039092169163630eb125916024808201926020929091908290030181600087803b158015612d7e57600080fd5b505af1158015612d92573d6000803e3d6000fd5b505050506040513d6020811015612da857600080fd5b505101935043841015612e6957612dbe856144e7565b6007546040805160e260020a63226be83b02815260048101889052600660248201529051600160a060020a03909216916389afa0ec9160448082019260009290919082900301818387803b158015612e1557600080fd5b505af1158015612e29573d6000803e3d6000fd5b5050604080518881526020810188905281517fa711f872e3732bc5b6130b03d9d7e514ffe570ac79dce6d1de822fe98c5b24009450908190039091019150a15b612e71612229565b92506002836005811115612e8157fe5b1415612eb5576040517f20c67af46c413c2d718d4d21afe5ab6bfcb13460d2660353bc9058257cf7eb0790600090a16137a0565b6003836005811115612ec357fe5b1415612f01576040805133815290517fa02f269007e4473186254aa700b45b5a04c17e9620880bda1ab752f0ead122409181900360200190a16137a0565b600754604080517ffcb0a7ad0000000000000000000000000000000000000000000000000000000081523360048201529051600160a060020a039092169163fcb0a7ad916024808201926020929091908290030181600087803b158015612f6757600080fd5b505af1158015612f7b573d6000803e3d6000fd5b505050506040513d6020811015612f9157600080fd5b5051600154909250821015612fa557600080fd5b6005836005811115612fb357fe5b141561300b577fcd1a5c2608a4f819aefa1f8e9fd631d8f945388ec4f548862145374cfacee62233612fe433611f22565b60408051600160a060020a03909316835260208301919091528051918290030190a16137a0565b61301482614fbc565b905080151561305d57604080513381526020810184905281517f0f6aa5cab8b4a5dfb68af521bc651c3de27e3644244a5194cfec3d4d1e26b00b929181900390910190a16137a0565b6007546040805160e260020a63226be83b02815260048101849052600260248201529051600160a060020a03909216916389afa0ec9160448082019260009290919082900301818387803b1580156130b457600080fd5b505af11580156130c8573d6000803e3d6000fd5b5050600754604080517f9e8c3543000000000000000000000000000000000000000000000000000000008152600481018690523360248201529051600160a060020a039092169350639e8c3543925060448082019260009290919082900301818387803b15801561313857600080fd5b505af115801561314c573d6000803e3d6000fd5b5050600754604080517f4f96fba7000000000000000000000000000000000000000000000000000000008152600481018690524360248201529051600160a060020a039092169350634f96fba7925060448082019260009290919082900301818387803b1580156131bc57600080fd5b505af11580156131d0573d6000803e3d6000fd5b5050336000908152600260205260408120805460010190556131fe925060059150839063ffffffff61513f16565b600a54600954604080517f7e06ee130000000000000000000000000000000000000000000000000000000081529051600160a060020a03938416936312e382b493339361332d939190921691637e06ee139160048083019260209291908290030181600087803b15801561327157600080fd5b505af1158015613285573d6000803e3d6000fd5b505050506040513d602081101561329b57600080fd5b50516007546040805160e060020a63de42f045028152905161332192600160a060020a03169163de42f0459160048083019260209291908290030181600087803b1580156132e857600080fd5b505af11580156132fc573d6000803e3d6000fd5b505050506040513d602081101561331257600080fd5b5051439063ffffffff6144da16565b9063ffffffff6144da16565b6040518363ffffffff1660e060020a0281526004018083600160a060020a0316600160a060020a0316815260200182815260200192505050602060405180830381600087803b15801561337f57600080fd5b505af1158015613393573d6000803e3d6000fd5b505050506040513d60208110156133a957600080fd5b5050336000908152600660209081526040808320849055600754815160e060020a633c9a5d590281526004810186905291517f7f77829ea87833bf5f6593e4e0c63ef9049662fb927b51278325bcf708b38359948694600160a060020a0390931693633c9a5d5993602480830194919391928390030190829087803b15801561343157600080fd5b505af1158015613445573d6000803e3d6000fd5b505050506040513d602081101561345b57600080fd5b5051600754604080517fe0ebdbff000000000000000000000000000000000000000000000000000000008152600481018790529051600160a060020a039092169163e0ebdbff916024808201926020929091908290030181600087803b1580156134c457600080fd5b505af11580156134d8573d6000803e3d6000fd5b505050506040513d60208110156134ee57600080fd5b5051600754604080517f843e240e000000000000000000000000000000000000000000000000000000008152600481018890529051600160a060020a039092169163843e240e9160248082019260009290919082900301818387803b15801561355657600080fd5b505af115801561356a573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052602081101561359357600080fd5b8101908080516401000000008111156135ab57600080fd5b820160208101848111156135be57600080fd5b81516401000000008111828201871017156135d857600080fd5b50506007546040805160e060020a63c15185f5028152600481018c90529051929550600160a060020a03909116935063c15185f592506024808201926020929091908290030181600087803b15801561363057600080fd5b505af1158015613644573d6000803e3d6000fd5b505050506040513d602081101561365a57600080fd5b5051600754604080517f2d4194c7000000000000000000000000000000000000000000000000000000008152600481018a90529051600160a060020a0390921691632d4194c7916024808201926020929091908290030181600087803b1580156136c357600080fd5b505af11580156136d7573d6000803e3d6000fd5b505050506040513d60208110156136ed57600080fd5b505160408051878152600160a060020a03808816602083810191909152908716928201929092526080810184905260a0810183905260c06060820181815286519183019190915285519192909160e084019187019080838360005b83811015613760578181015183820152602001613748565b50505050905090810190601f16801561378d5780820380516001836020036101000a031916815260200191505b5097505050505050505060405180910390a15b505050505050565b600954600160a060020a031681565b60026020526000908152604090205481565b60008060008460078111156137da57fe5b6004141580156137f657508460078111156137f157fe5b600514155b15613867577f3a0de84191b46e385bc9aff0ecb6cb021f3bb03c3ca5ee8434455163c2d815998633876040518084815260200183600160a060020a0316600160a060020a0316815260200182600781111561384d57fe5b60ff168152602001935050505060405180910390a16137a0565b600754604080517f0783c2ef000000000000000000000000000000000000000000000000000000008152600481018990529051600160a060020a0390921691630783c2ef916024808201926020929091908290030181600087803b1580156138ce57600080fd5b505af11580156138e2573d6000803e3d6000fd5b505050506040513d60208110156138f857600080fd5b50519250600283600781111561390a57fe5b14613961577f6b363836716c3877f3c49dd37defa9fb5d124706cb0b6640f49c2e09db911daf8633856040518084815260200183600160a060020a0316600160a060020a0316815260200182600781111561384d57fe5b6007546040805160e060020a633c9a5d59028152600481018990529051600160a060020a0390921691633c9a5d59916024808201926020929091908290030181600087803b1580156139b257600080fd5b505af11580156139c6573d6000803e3d6000fd5b505050506040513d60208110156139dc57600080fd5b5051600160a060020a03163314613a2c576040805187815233602082015281517ff347c161bf17d622e62922326092dd9579fd3e85fa93f6de90e7df3a7336c2fb929181900390910190a16137a0565b613a35866144e7565b600760009054906101000a9004600160a060020a0316600160a060020a031663de42f0456040518163ffffffff1660e060020a028152600401602060405180830381600087803b158015613a8857600080fd5b505af1158015613a9c573d6000803e3d6000fd5b505050506040513d6020811015613ab257600080fd5b5051600754604080517f630eb125000000000000000000000000000000000000000000000000000000008152600481018a90529051600160a060020a039092169163630eb125916024808201926020929091908290030181600087803b158015613b1b57600080fd5b505af1158015613b2f573d6000803e3d6000fd5b505050506040513d6020811015613b4557600080fd5b505101915043821015613c06576007546040805160e260020a63226be83b02815260048101899052600660248201529051600160a060020a03909216916389afa0ec9160448082019260009290919082900301818387803b158015613ba957600080fd5b505af1158015613bbd573d6000803e3d6000fd5b50506040805189815233602082015280820186905290517fe1f2d12acdc0bb70d6d7daaa80a51c7d266585e839cdf1fe120d178938d425659350908190036060019150a16137a0565b6007805460405160e260020a63226be83b02815260048101898152600160a060020a03909216926389afa0ec928a928a926024909101908390811115613c4857fe5b60ff16815260200192505050600060405180830381600087803b158015613c6e57600080fd5b505af1158015613c82573d6000803e3d6000fd5b5050600754604080517f3b08d35e000000000000000000000000000000000000000000000000000000008152600481018b90524360248201529051600160a060020a039092169350633b08d35e925060448082019260009290919082900301818387803b158015613cf257600080fd5b505af1158015613d06573d6000803e3d6000fd5b50505050613d138661092f565b1515613d1e57600080fd5b600854604080517f896d505a0000000000000000000000000000000000000000000000000000000081526004810189815260248201928352875160448301528751600160a060020a039094169363896d505a938b938a9392606490910190602085019080838360005b83811015613d9f578181015183820152602001613d87565b50505050905090810190601f168015613dcc5780820380516001836020036101000a031916815260200191505b509350505050600060405180830381600087803b158015613dec57600080fd5b505af1158015613e00573d6000803e3d6000fd5b505050507fb767d2160422b0b43310f02f68c4fdaa45af8962e7f088353b947647fd6e5fc4863387876040518085815260200184600160a060020a0316600160a060020a03168152602001836007811115613e5757fe5b60ff16815260200180602001828103825283818151815260200191508051906020019080838360005b83811015613e98578181015183820152602001613e80565b50505050905090810190601f168015613ec55780820380516001836020036101000a031916815260200191505b509550505050505060405180910390a1600954604080517fa2be19fb000000000000000000000000000000000000000000000000000000008152600481018990529051600160a060020a039092169163a2be19fb9160248082019260009290919082900301818387803b158015613f3b57600080fd5b505af1158015613f4f573d6000803e3d6000fd5b5050600954604080517fba5bea09000000000000000000000000000000000000000000000000000000008152336004820152602481018b90529051600160a060020a03909216935063ba5bea09925060448082019260009290919082900301818387803b158015613fbf57600080fd5b505af1158015613fd3573d6000803e3d6000fd5b505050506000600960009054906101000a9004600160a060020a0316600160a060020a0316630ea363456040518163ffffffff1660e060020a028152600401602060405180830381600087803b15801561402c57600080fd5b505af1158015614040573d6000803e3d6000fd5b505050506040513d602081101561405657600080fd5b50511180156140ed5750600954604080517f928c97eb0000000000000000000000000000000000000000000000000000000081529051600092600160a060020a03169163928c97eb91600480830192602092919082900301818787803b1580156140bf57600080fd5b505af11580156140d3573d6000803e3d6000fd5b505050506040513d60208110156140e957600080fd5b5051115b156137a057600954604080517fa969ff0a000000000000000000000000000000000000000000000000000000008152600481018990529051600160a060020a039092169163a969ff0a916024808201926020929091908290030181600087803b15801561415957600080fd5b505af115801561416d573d6000803e3d6000fd5b505050506040513d602081101561418357600080fd5b505160095490915061419e90600160a060020a0316826148cf565b600954604080517f641446eb000000000000000000000000000000000000000000000000000000008152600481018490529051600160a060020a039092169163641446eb9160248082019260009290919082900301818387803b15801561420457600080fd5b505af1158015614218573d6000803e3d6000fd5b50505050505050505050565b604080517f352a714b000000000000000000000000000000000000000000000000000000008152600360048201526000602482018190526044820184905260016064830152915173697e2033ba28c1cc9e28d94ca910ca53a978aad09163352a714b916084808301926020929190829003018186803b1580156142a657600080fd5b505af4158015611fa1573d6000803e3d6000fd5b600954604080517fe4ca784b000000000000000000000000000000000000000000000000000000008152600160a060020a0384811660048301529151600093929092169163e4ca784b9160248082019260209290919082900301818787803b158015611f8d57600080fd5b600054600160a060020a0316331461433c57600080fd5b6143458161514c565b50565b600954604080517f8826db7a0000000000000000000000000000000000000000000000000000000081523360048201529051600092839283926060928492600160a060020a0390911691638826db7a91602480820192869290919082900301818387803b1580156143b857600080fd5b505af11580156143cc573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405260a08110156143f557600080fd5b815160208301516040840151606085018051939592949193918301929164010000000081111561442457600080fd5b8201602081018481111561443757600080fd5b815164010000000081118282018710171561445157600080fd5b505060209190910151959b949a509298509196509294509092505050565b600754604080517ffcb0a7ad000000000000000000000000000000000000000000000000000000008152600160a060020a0384811660048301529151600093929092169163fcb0a7ad9160248082019260209290919082900301818787803b158015611f8d57600080fd5b81810182811015610c0657fe5b6144f860058263ffffffff6151c916565b506007546040805160e060020a633c9a5d590281526004810184905290516145a592600192600292600092600160a060020a031691633c9a5d5991602480830192602092919082900301818787803b15801561455357600080fd5b505af1158015614567573d6000803e3d6000fd5b505050506040513d602081101561457d57600080fd5b5051600160a060020a031681526020810191909152604001600020549063ffffffff614a7a16565b6007546040805160e060020a633c9a5d59028152600481018590529051600292600092600160a060020a0390911691633c9a5d599160248082019260209290919082900301818787803b1580156145fb57600080fd5b505af115801561460f573d6000803e3d6000fd5b505050506040513d602081101561462557600080fd5b5051600160a060020a0316815260208101919091526040016000205550565b6007546040805160e060020a63c15185f5028152600481018490529051600092600160a060020a03169163c15185f591602480830192602092919082900301818787803b15801561469457600080fd5b505af11580156146a8573d6000803e3d6000fd5b505050506040513d60208110156146be57600080fd5b50516040805160e260020a633d64d8cf0281526003600482015260248101839052905191925073697e2033ba28c1cc9e28d94ca910ca53a978aad09163f593633c91604480820192602092909190829003018186803b15801561472057600080fd5b505af4158015614734573d6000803e3d6000fd5b505050506040513d602081101561474a57600080fd5b5051151561475757600080fd5b600081815260046020818152604092839020835160e260020a633d64d8cf0281529283015260248201859052915173697e2033ba28c1cc9e28d94ca910ca53a978aad09263f593633c9260448082019391829003018186803b1580156147bc57600080fd5b505af41580156147d0573d6000803e3d6000fd5b505050506040513d60208110156147e657600080fd5b505115156147f357600080fd5b6000818152600460205260409020614811908363ffffffff6151c916565b5060008181526004602081815260409283902083517f53d00bd400000000000000000000000000000000000000000000000000000000815292830152915173697e2033ba28c1cc9e28d94ca910ca53a978aad0926353d00bd49260248082019391829003018186803b15801561488657600080fd5b505af415801561489a573d6000803e3d6000fd5b505050506040513d60208110156148b057600080fd5b505115156148cb576148c960038263ffffffff6151c916565b505b5050565b600754604080517ff8efc03e000000000000000000000000000000000000000000000000000000008152600481018490529051600160a060020a039092169163f8efc03e9160248082019260009290919082900301818387803b15801561493557600080fd5b505af1158015614949573d6000803e3d6000fd5b50505050600760009054906101000a9004600160a060020a0316600160a060020a031663fc0c546a6040518163ffffffff1660e060020a028152600401602060405180830381600087803b1580156149a057600080fd5b505af11580156149b4573d6000803e3d6000fd5b505050506040513d60208110156149ca57600080fd5b5051600754604080517f23b872dd000000000000000000000000000000000000000000000000000000008152600160a060020a039283166004820152858316602482015260448101859052905191909216916323b872dd9160648083019260209291908290030181600087803b158015614a4357600080fd5b505af1158015614a57573d6000803e3d6000fd5b505050506040513d6020811015614a6d57600080fd5b505115156148cb57600080fd5b600082821115614a8657fe5b50900390565b600954604080517f309945ba0000000000000000000000000000000000000000000000000000000081526004810184905290516000928392600160a060020a039091169163309945ba9160248082019260209290919082900301818787803b158015614af757600080fd5b505af1158015614b0b573d6000803e3d6000fd5b505050506040513d6020811015614b2157600080fd5b50516007546040805160e060020a63c15185f5028152600481018790529051929450614b7a928592600160a060020a03169163c15185f59160248083019260209291908290030181600087803b15801561194b57600080fd5b9050614b8633826148cf565b6040805184815233602082015280820183905290517fea648b3eaf17a2dc7140d38177ea6c732aa308fdae50d160350b9b4588a0ddb79181900360600190a1505050565b6000821515614bdb57506000610c06565b50818102818382811515614beb57fe5b0414610c0657fe5b6007546040805160e060020a63c15185f50281526004810185905290516000928392600160a060020a039091169163c15185f59160248082019260209290919082900301818787803b158015614c4857600080fd5b505af1158015614c5c573d6000803e3d6000fd5b505050506040513d6020811015614c7257600080fd5b50516040805160e260020a633d64d8cf0281526003600482015260248101839052905191935073697e2033ba28c1cc9e28d94ca910ca53a978aad09163f593633c91604480820192602092909190829003018186803b158015614cd457600080fd5b505af4158015614ce8573d6000803e3d6000fd5b505050506040513d6020811015614cfe57600080fd5b50511515614e61576040805160e260020a633d64d8cf0281526003600482015260248101859052905173697e2033ba28c1cc9e28d94ca910ca53a978aad09163f593633c916044808301926020929190829003018186803b158015614d6257600080fd5b505af4158015614d76573d6000803e3d6000fd5b505050506040513d6020811015614d8c57600080fd5b5051614d99576000614d9b565b825b604080517f352a714b000000000000000000000000000000000000000000000000000000008152600360048201526024810183905260448101859052600160648201529051919250614e5f9173697e2033ba28c1cc9e28d94ca910ca53a978aad09163352a714b916084808301926020929190829003018186803b158015614e2257600080fd5b505af4158015614e36573d6000803e3d6000fd5b505050506040513d6020811015614e4c57600080fd5b505160039084600063ffffffff61524716565b505b6000828152600460205260408120614e8091869063ffffffff61513f16565b50505050565b6000600373697e2033ba28c1cc9e28d94ca910ca53a978aad06353d00bd490916040518263ffffffff1660e060020a0281526004018082815260200191505060206040518083038186803b158015614edd57600080fd5b505af41580156124f5573d6000803e3d6000fd5b6040805160e260020a6315d011eb02815260036004820152600060248201819052604482018190528251909283928392839273697e2033ba28c1cc9e28d94ca910ca53a978aad09263574047ac9260648083019392829003018186803b158015614f5a57600080fd5b505af4158015614f6e573d6000803e3d6000fd5b505050506040513d6040811015614f8457600080fd5b508051602090910151909350915084821015614fa35760009350614fb4565b614fae826000611115565b90508093505b505050919050565b6000806000614fca84614ef1565b91506000821115615135576007546040805160e060020a63c15185f5028152600481018590529051600160a060020a039092169163c15185f5916024808201926020929091908290030181600087803b15801561502657600080fd5b505af115801561503a573d6000803e3d6000fd5b505050506040513d602081101561505057600080fd5b50516000818152600460205260409020909150615073908363ffffffff6151c916565b5060008181526004602081815260409283902083517f53d00bd400000000000000000000000000000000000000000000000000000000815292830152915173697e2033ba28c1cc9e28d94ca910ca53a978aad0926353d00bd49260248082019391829003018186803b1580156150e857600080fd5b505af41580156150fc573d6000803e3d6000fd5b505050506040513d602081101561511257600080fd5b5051151561512d5761512b60038263ffffffff6151c916565b505b8192506121fd565b5060009392505050565b614e808360008484615247565b600160a060020a038116151561516157600080fd5b60008054604051600160a060020a03808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a36000805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b60008115806151df57506151dd83836152b5565b155b156151ec57506000610c06565b600082815260208481526040808320838052909152808220546001808452919092205461521d92869290919061532d565b50600081815260209283526040808220828052909352828120819055600181529182209190915590565b60008061525486856152b5565b158015615266575061526686866152b5565b156152a7575060008481526020868152604080832085151584529091529020546152928686868661532d565b61529e8685838661532d565b600191506152ac565b600091505b50949350505050565b6000818152602083815260408083208380529091528120541580156152f0575060008281526020848152604080832060018452909152902054155b15615325576000808052602084815260408083206001845290915290205482141561531d57506001610c06565b506000610c06565b506001610c06565b60008281526020858152604080832093158084529382528083208690559482529485528381209115815293529120555600a165627a7a72305820efdb5ce665ca7da239f64397b7470ebce9a16c842dbb5cc9b644c65c59adfc7c0029000000000000000000000000fcbc318314aae617cf58c2d13a9ee48be0e4c3700000000000000000000000005d7213b2fd42d5cc86a4d3a180a8f8f600ac95c800000000000000000000000051397c286a6399b4dd1fb8c221be94562d6951cb00000000000000000000000059523b19e6614f9e6acede42100619458ee01eab",
  "constructorArguments": "000000000000000000000000fcbc318314aae617cf58c2d13a9ee48be0e4c3700000000000000000000000005d7213b2fd42d5cc86a4d3a180a8f8f600ac95c800000000000000000000000051397c286a6399b4dd1fb8c221be94562d6951cb00000000000000000000000059523b19e6614f9e6acede42100619458ee01eab",
  "libraries": [
    {
      "name": "LinkedListLib",
      "address": "0x697e2033ba28c1cc9e28d94ca910ca53a978aad0"
    }
  ]
}