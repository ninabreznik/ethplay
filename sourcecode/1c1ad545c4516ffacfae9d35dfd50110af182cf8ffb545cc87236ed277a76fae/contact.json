{
  "address": "0x730dc765471340f68774a415e15f1cbc06d37bce",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "XcertCreateProxy",
  "compilerVersion": "v0.5.1+commit.c8a2cb62",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2019-02-15\n*/\n\npragma solidity 0.5.1;\n\n/**\n * @dev Xcert interface.\n */\ninterface Xcert // is ERC721 metadata enumerable\n{\n\n  /**\n   * @dev Creates a new Xcert.\n   * @param _to The address that will own the created Xcert.\n   * @param _id The Xcert to be created by the msg.sender.\n   * @param _imprint Cryptographic asset imprint.\n   */\n  function create(\n    address _to,\n    uint256 _id,\n    bytes32 _imprint\n  )\n    external;\n\n  /**\n   * @dev Change URI base.\n   * @param _uriBase New uriBase.\n   */\n  function setUriBase(\n    string calldata _uriBase\n  )\n    external;\n\n  /**\n   * @dev Returns a bytes4 of keccak256 of json schema representing 0xcert Protocol convention.\n   * @return Schema id.\n   */\n  function schemaId()\n    external\n    view\n    returns (bytes32 _schemaId);\n\n  /**\n   * @dev Returns imprint for Xcert.\n   * @param _tokenId Id of the Xcert.\n   * @return Token imprint.\n   */\n  function tokenImprint(\n    uint256 _tokenId\n  )\n    external\n    view\n    returns(bytes32 imprint);\n\n}\n\n\n/**\n * @dev Math operations with safety checks that throw on error. This contract is based on the \n * source code at: \n * https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol.\n */\nlibrary SafeMath\n{\n\n  /**\n   * @dev Error constants.\n   */\n  string constant OVERFLOW = \"008001\";\n  string constant SUBTRAHEND_GREATER_THEN_MINUEND = \"008002\";\n  string constant DIVISION_BY_ZERO = \"008003\";\n\n  /**\n   * @dev Multiplies two numbers, reverts on overflow.\n   * @param _factor1 Factor number.\n   * @param _factor2 Factor number.\n   * @return The product of the two factors.\n   */\n  function mul(\n    uint256 _factor1,\n    uint256 _factor2\n  )\n    internal\n    pure\n    returns (uint256 product)\n  {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (_factor1 == 0)\n    {\n      return 0;\n    }\n\n    product = _factor1 * _factor2;\n    require(product / _factor1 == _factor2, OVERFLOW);\n  }\n\n  /**\n   * @dev Integer division of two numbers, truncating the quotient, reverts on division by zero.\n   * @param _dividend Dividend number.\n   * @param _divisor Divisor number.\n   * @return The quotient.\n   */\n  function div(\n    uint256 _dividend,\n    uint256 _divisor\n  )\n    internal\n    pure\n    returns (uint256 quotient)\n  {\n    // Solidity automatically asserts when dividing by 0, using all gas.\n    require(_divisor > 0, DIVISION_BY_ZERO);\n    quotient = _dividend / _divisor;\n    // assert(_dividend == _divisor * quotient + _dividend % _divisor); // There is no case in which this doesn't hold.\n  }\n\n  /**\n   * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n   * @param _minuend Minuend number.\n   * @param _subtrahend Subtrahend number.\n   * @return Difference.\n   */\n  function sub(\n    uint256 _minuend,\n    uint256 _subtrahend\n  )\n    internal\n    pure\n    returns (uint256 difference)\n  {\n    require(_subtrahend <= _minuend, SUBTRAHEND_GREATER_THEN_MINUEND);\n    difference = _minuend - _subtrahend;\n  }\n\n  /**\n   * @dev Adds two numbers, reverts on overflow.\n   * @param _addend1 Number.\n   * @param _addend2 Number.\n   * @return Sum.\n   */\n  function add(\n    uint256 _addend1,\n    uint256 _addend2\n  )\n    internal\n    pure\n    returns (uint256 sum)\n  {\n    sum = _addend1 + _addend2;\n    require(sum >= _addend1, OVERFLOW);\n  }\n\n  /**\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo), reverts when\n    * dividing by zero.\n    * @param _dividend Number.\n    * @param _divisor Number.\n    * @return Remainder.\n    */\n  function mod(\n    uint256 _dividend,\n    uint256 _divisor\n  )\n    internal\n    pure\n    returns (uint256 remainder) \n  {\n    require(_divisor != 0, DIVISION_BY_ZERO);\n    remainder = _dividend % _divisor;\n  }\n\n}\n\n/**\n * @title Contract for setting abilities.\n * @dev For optimization purposes the abilities are represented as a bitfield. Maximum number of\n * abilities is therefore 256. This is an example(for simplicity is made for max 8 abilities) of how\n * this works. \n * 00000001 Ability A - number representation 1\n * 00000010 Ability B - number representation 2\n * 00000100 Ability C - number representation 4\n * 00001000 Ability D - number representation 8\n * 00010000 Ability E - number representation 16\n * etc ... \n * To grant abilities B and C, we would need a bitfield of 00000110 which is represented by number\n * 6, in other words, the sum of abilities B and C. The same concept works for revoking abilities\n * and checking if someone has multiple abilities.\n */\ncontract Abilitable\n{\n  using SafeMath for uint;\n\n  /**\n   * @dev Error constants.\n   */\n  string constant NOT_AUTHORIZED = \"017001\";\n  string constant ONE_ZERO_ABILITY_HAS_TO_EXIST = \"017002\";\n  string constant INVALID_INPUT = \"017003\";\n\n  /**\n   * @dev Ability 1 is a reserved ability. It is an ability to grant or revoke abilities. \n   * There can be minimum of 1 address with ability 1.\n   * Other abilities are determined by implementing contract.\n   */\n  uint8 constant ABILITY_TO_MANAGE_ABILITIES = 1;\n\n  /**\n   * @dev Maps address to ability ids.\n   */\n  mapping(address => uint256) public addressToAbility;\n\n  /**\n   * @dev Count of zero ability addresses.\n   */\n  uint256 private zeroAbilityCount;\n\n  /**\n   * @dev Emits when an address is granted an ability.\n   * @param _target Address to which we are granting abilities.\n   * @param _abilities Number representing bitfield of abilities we are granting.\n   */\n  event GrantAbilities(\n    address indexed _target,\n    uint256 indexed _abilities\n  );\n\n  /**\n   * @dev Emits when an address gets an ability revoked.\n   * @param _target Address of which we are revoking an ability.\n   * @param _abilities Number representing bitfield of abilities we are revoking.\n   */\n  event RevokeAbilities(\n    address indexed _target,\n    uint256 indexed _abilities\n  );\n\n  /**\n   * @dev Guarantees that msg.sender has certain abilities.\n   */\n  modifier hasAbilities(\n    uint256 _abilities\n  ) \n  {\n    require(_abilities > 0, INVALID_INPUT);\n    require(\n      (addressToAbility[msg.sender] & _abilities) == _abilities,\n      NOT_AUTHORIZED\n    );\n    _;\n  }\n\n  /**\n   * @dev Contract constructor.\n   * Sets ABILITY_TO_MANAGE_ABILITIES ability to the sender account.\n   */\n  constructor()\n    public\n  {\n    addressToAbility[msg.sender] = ABILITY_TO_MANAGE_ABILITIES;\n    zeroAbilityCount = 1;\n    emit GrantAbilities(msg.sender, ABILITY_TO_MANAGE_ABILITIES);\n  }\n\n  /**\n   * @dev Grants specific abilities to specified address.\n   * @param _target Address to grant abilities to.\n   * @param _abilities Number representing bitfield of abilities we are granting.\n   */\n  function grantAbilities(\n    address _target,\n    uint256 _abilities\n  )\n    external\n    hasAbilities(ABILITY_TO_MANAGE_ABILITIES)\n  {\n    addressToAbility[_target] |= _abilities;\n\n    if((_abilities & ABILITY_TO_MANAGE_ABILITIES) == ABILITY_TO_MANAGE_ABILITIES)\n    {\n      zeroAbilityCount = zeroAbilityCount.add(1);\n    }\n    emit GrantAbilities(_target, _abilities);\n  }\n\n  /**\n   * @dev Unassigns specific abilities from specified address.\n   * @param _target Address of which we revoke abilites.\n   * @param _abilities Number representing bitfield of abilities we are revoking.\n   */\n  function revokeAbilities(\n    address _target,\n    uint256 _abilities\n  )\n    external\n    hasAbilities(ABILITY_TO_MANAGE_ABILITIES)\n  {\n    addressToAbility[_target] &= ~_abilities;\n    if((_abilities & 1) == 1)\n    {\n      require(zeroAbilityCount > 1, ONE_ZERO_ABILITY_HAS_TO_EXIST);\n      zeroAbilityCount--;\n    }\n    emit RevokeAbilities(_target, _abilities);\n  }\n\n  /**\n   * @dev Check if an address has a specific ability. Throws if checking for 0.\n   * @param _target Address for which we want to check if it has a specific abilities.\n   * @param _abilities Number representing bitfield of abilities we are checking.\n   */\n  function isAble(\n    address _target,\n    uint256 _abilities\n  )\n    external\n    view\n    returns (bool)\n  {\n    require(_abilities > 0, INVALID_INPUT);\n    return (addressToAbility[_target] & _abilities) == _abilities;\n  }\n  \n}\n\n/**\n * @title XcertCreateProxy - creates a token on behalf of contracts that have been approved via\n * decentralized governance.\n */\ncontract XcertCreateProxy is \n  Abilitable \n{\n\n  /**\n   * @dev List of abilities:\n   * 2 - Ability to execute create. \n   */\n  uint8 constant ABILITY_TO_EXECUTE = 2;\n\n  /**\n   * @dev Creates a new NFT.\n   * @param _xcert Address of the Xcert contract on which the creation will be perfomed.\n   * @param _to The address that will own the created NFT.\n   * @param _id The NFT to be created by the msg.sender.\n   * @param _imprint Cryptographic asset imprint.\n   */\n  function create(\n    address _xcert,\n    address _to,\n    uint256 _id,\n    bytes32 _imprint\n  )\n    external\n    hasAbilities(ABILITY_TO_EXECUTE)\n  {\n    Xcert(_xcert).create(_to, _id, _imprint);\n  }\n  \n}",
  "bytecode": "6080604081815233600081815260208190529182206001908190558080559290917fc4adfc5f00262a1ab9b2241c7e98408a91e58dc5777d786164bba34a7652f62f91a36107d8806100526000396000f3fe608060405260043610610066577c010000000000000000000000000000000000000000000000000000000060003504630ab319e8811461006b57806345a32c86146100a657806346009b0e146100eb578063ba00a33014610134578063f394b6df14610181575b600080fd5b34801561007757600080fd5b506100a46004803603604081101561008e57600080fd5b50600160a060020a0381351690602001356101ba565b005b3480156100b257600080fd5b506100d9600480360360208110156100c957600080fd5b5035600160a060020a031661034d565b60408051918252519081900360200190f35b3480156100f757600080fd5b506100a46004803603608081101561010e57600080fd5b50600160a060020a0381358116916020810135909116906040810135906060013561035f565b34801561014057600080fd5b5061016d6004803603604081101561015757600080fd5b50600160a060020a0381351690602001356104ab565b604080519115158252519081900360200190f35b34801561018d57600080fd5b506100a4600480360360408110156101a457600080fd5b50600160a060020a038135169060200135610545565b604080518082019091526006815260008051602061078d8339815191526020820152600190610237565b838110156101fc5781810151838201526020016101e4565b50505050905090810190601f1680156102295780820380516001836020036101000a031916815260200191505b509250505060405180910390fd5b503360009081526020818152604091829020548251808401909352600683527f303137303031000000000000000000000000000000000000000000000000000091830191909152821682146102d15760405160e560020a62461bcd028152600401808060200182810382528381815181526020019150805190602001908083836000838110156101fc5781810151838201526020016101e4565b50600160a060020a038316600090815260208190526040902080548317905560018083161415610312576001805461030e9163ffffffff6106fa16565b6001555b6040518290600160a060020a038516907fc4adfc5f00262a1ab9b2241c7e98408a91e58dc5777d786164bba34a7652f62f90600090a3505050565b60006020819052908152604090205481565b604080518082018252600680825260008051602061078d8339815191526020928301523360009081528083528390205483518085019094529083527f30313730303100000000000000000000000000000000000000000000000000009183019190915260029190821682146104195760405160e560020a62461bcd028152600401808060200182810382528381815181526020019150805190602001908083836000838110156101fc5781810151838201526020016101e4565b50604080517fb0e329e4000000000000000000000000000000000000000000000000000000008152600160a060020a038681166004830152602482018690526044820185905291519187169163b0e329e49160648082019260009290919082900301818387803b15801561048c57600080fd5b505af11580156104a0573d6000803e3d6000fd5b505050505050505050565b604080518082019091526006815260008051602061078d83398151915260208201526000908183116105225760405160e560020a62461bcd028152600401808060200182810382528381815181526020019150805190602001908083836000838110156101fc5781810151838201526020016101e4565b5050600160a060020a039190911660009081526020819052604090205481161490565b604080518082018252600680825260008051602061078d8339815191526020928301523360009081528083528390205483518085019094529083527f30313730303100000000000000000000000000000000000000000000000000009183019190915260019190821682146105ff5760405160e560020a62461bcd028152600401808060200182810382528381815181526020019150805190602001908083836000838110156101fc5781810151838201526020016101e4565b50600160a060020a038316600090815260208190526040902080548319169055600180831614156106bf576001805460408051808201909152600681527f3031373030320000000000000000000000000000000000000000000000000000602082015291106106b35760405160e560020a62461bcd028152600401808060200182810382528381815181526020019150805190602001908083836000838110156101fc5781810151838201526020016101e4565b50600180546000190190555b6040518290600160a060020a038516907fbb71944f65b9a48cc7d835179fb5e874f29b60aa0195785fb54968d8dddef08a90600090a3505050565b60408051808201909152600681527f3030383030310000000000000000000000000000000000000000000000000000602082015282820190838210156107855760405160e560020a62461bcd028152600401808060200182810382528381815181526020019150805190602001908083836000838110156101fc5781810151838201526020016101e4565b509291505056fe3031373030330000000000000000000000000000000000000000000000000000a165627a7a7230582038b01670fd5c5761ee45139a247e4e1b7e65cb3dc334824d43ee8cedf300b4810029"
}