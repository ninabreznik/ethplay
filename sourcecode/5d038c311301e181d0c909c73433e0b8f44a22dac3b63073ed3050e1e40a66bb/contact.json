{
  "address": "0x17e2c574cf092950ef89fb4939c97db2086e796f",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "McFlyToken",
  "compilerVersion": "v0.4.19+commit.c4cbbb05",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2018-03-30\n*/\n\npragma solidity ^0.4.19;\n\n/**\n *\n * @title McFly.aero - main contract\n * @author Copyright (c) 2018 McFly.aero\n * @author Dmitriy Khizhinskiy\n * @author \"MIT\"\n *\n */ \n\n/**\n * @title ERC20 Basic smart contract\n * @author Copyright (c) 2016 Smart Contract Solutions, Inc.\n * @author \"Manuel Araoz <[email protected]>\"\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n * @dev license: \"MIT\", source: https://github.com/OpenZeppelin/zeppelin-solidity\n * @author modification: Dmitriy Khizhinskiy @McFly.aero\n */\ncontract ERC20Basic {\n    function totalSupply() public view returns (uint256);\n    function balanceOf(address who) public view returns (uint256);\n    function transfer(address to, uint256 value) public returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title Ownable smart contract\n * @author Copyright (c) 2016 Smart Contract Solutions, Inc.\n * @author \"Manuel Araoz <[email protected]>\"\n * @dev license: \"MIT\", source: https://github.com/OpenZeppelin/zeppelin-solidity\n * @author modification: Dmitriy Khizhinskiy @McFly.aero\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n    address public owner;\n    address public candidate;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n    * account.\n    */\n    function Ownable() public {\n        owner = msg.sender;\n    }\n\n\n    /**\n    * @dev Throws if called by any account other than the owner.\n    */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n\n    /**\n    * @dev Allows the current owner to _request_ transfer control of the contract to a newOwner.\n    * @param newOwner The address to transfer ownership to.\n    */\n    function requestOwnership(address newOwner) onlyOwner public {\n        require(newOwner != address(0));\n        candidate = newOwner;\n    }\n\n\n    /**\n    * @dev Allows the _NEW_ candidate to complete transfer control of the contract to him.\n    */\n    function confirmOwnership() public {\n        require(candidate == msg.sender);\n        owner = candidate;\n        OwnershipTransferred(owner, candidate);        \n    }\n}\n\n\n/**\n * @title MultiOwners smart contract\n * @author Copyright (c) 2018 McFly.aero\n * @author Dmitriy Khizhinskiy\n * @author \"MIT\"\n */\ncontract MultiOwners {\n\n    event AccessGrant(address indexed owner);\n    event AccessRevoke(address indexed owner);\n    \n    mapping(address => bool) owners;\n    address public publisher;\n\n\n    function MultiOwners() public {\n        owners[msg.sender] = true;\n        publisher = msg.sender;\n    }\n\n\n    modifier onlyOwner() { \n        require(owners[msg.sender] == true);\n        _; \n    }\n\n\n    function isOwner() constant public returns (bool) {\n        return owners[msg.sender] ? true : false;\n    }\n\n\n    function checkOwner(address maybe_owner) constant public returns (bool) {\n        return owners[maybe_owner] ? true : false;\n    }\n\n\n    function grant(address _owner) onlyOwner public {\n        owners[_owner] = true;\n        AccessGrant(_owner);\n    }\n\n\n    function revoke(address _owner) onlyOwner public {\n        require(_owner != publisher);\n        require(msg.sender != _owner);\n\n        owners[_owner] = false;\n        AccessRevoke(_owner);\n    }\n}\n\n\n\n\n/**\n * @title SafeMath\n * @author Copyright (c) 2016 Smart Contract Solutions, Inc.\n * @author \"Manuel Araoz <[email protected]>\"\n * @dev license: \"MIT\", source: https://github.com/OpenZeppelin/zeppelin-solidity\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n    /**\n    * @dev Multiplies two numbers, throws on overflow.\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n\n    /**\n    * @dev Integer division of two numbers, truncating the quotient.\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return c;\n    }\n\n\n    /**\n    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n\n    /**\n    * @dev Adds two numbers, throws on overflow.\n    */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @title BasicToken smart contract\n * @author Copyright (c) 2016 Smart Contract Solutions, Inc.\n * @author \"Manuel Araoz <[email protected]>\"\n * @dev license: \"MIT\", source: https://github.com/OpenZeppelin/zeppelin-solidity\n * @author modification: Dmitriy Khizhinskiy @McFly.aero\n */\n\n\n\n\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n    using SafeMath for uint256;\n\n    mapping(address => uint256) balances;\n\n    uint256 totalSupply_;\n\n    /**\n    * @dev total number of tokens in existence\n    */\n    function totalSupply() public view returns (uint256) {\n        return totalSupply_;\n    }\n\n\n    /**\n    * @dev transfer token for a specified address\n    * @param _to The address to transfer to.\n    * @param _value The amount to be transferred.\n    */\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(_value <= balances[msg.sender]);\n\n        // SafeMath.sub will throw if there is not enough balance.\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n\n    /**\n    * @dev Gets the balance of the specified address.\n    * @param _owner The address to query the the balance of.\n    * @return An uint256 representing the amount owned by the passed address.\n    */\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n}\n\n\n/**\n * @title ERC20 smart contract\n * @author Copyright (c) 2016 Smart Contract Solutions, Inc.\n * @author \"Manuel Araoz <[email protected]>\"\n * @dev license: \"MIT\", source: https://github.com/OpenZeppelin/zeppelin-solidity\n * @author modification: Dmitriy Khizhinskiy @McFly.aero\n */\n\n\n\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n    function allowance(address owner, address spender) public view returns (uint256);\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\n    function approve(address spender, uint256 value) public returns (bool);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title Standard ERC20 token\n * @author Copyright (c) 2016 Smart Contract Solutions, Inc.\n * @author \"Manuel Araoz <[email protected]>\"\n * @dev license: \"MIT\", source: https://github.com/OpenZeppelin/zeppelin-solidity\n * @author modification: Dmitriy Khizhinskiy @McFly.aero\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n    mapping (address => mapping (address => uint256)) internal allowed;\n  \n    /** \n    * @dev Transfer tokens from one address to another\n    * @param _from address The address which you want to send tokens from\n    * @param _to address The address which you want to transfer to\n    * @param _value uint256 the amount of tokens to be transferred\n    */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(_value <= balances[_from]);\n        require(_value <= allowed[_from][msg.sender]);\n\n        balances[_from] = balances[_from].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n\n    /**\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n    *\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    * @param _spender The address which will spend the funds.\n    * @param _value The amount of tokens to be spent.\n    */\n    function approve(address _spender, uint256 _value) public returns (bool) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n\n    /**\n    * @dev Function to check the amount of tokens that an owner allowed to a spender.\n    * @param _owner address The address which owns the funds.\n    * @param _spender address The address which will spend the funds.\n    * @return A uint256 specifying the amount of tokens still available for the spender.\n    */\n    function allowance(address _owner, address _spender) public view returns (uint256) {\n        return allowed[_owner][_spender];\n    }\n\n\n    /**\n    * @dev Increase the amount of tokens that an owner allowed to a spender.\n    *\n    * approve should be called when allowed[_spender] == 0. To increment\n    * allowed value is better to use this function to avoid 2 calls (and wait until\n    * the first transaction is mined)\n    * From MonolithDAO Token.sol\n    * @param _spender The address which will spend the funds.\n    * @param _addedValue The amount of tokens to increase the allowance by.\n    */\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n\n    /**\n    * @dev Decrease the amount of tokens that an owner allowed to a spender.\n    *\n    * approve should be called when allowed[_spender] == 0. To decrement\n    * allowed value is better to use this function to avoid 2 calls (and wait until\n    * the first transaction is mined)\n    * From MonolithDAO Token.sol\n    * @param _spender The address which will spend the funds.\n    * @param _subtractedValue The amount of tokens to decrease the allowance by.\n    */\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n        uint oldValue = allowed[msg.sender][_spender];\n        if (_subtractedValue > oldValue) {\n            allowed[msg.sender][_spender] = 0;\n        } else {\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n        }\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n}\n\n/**\n * @title Mintable token smart contract\n * @author Copyright (c) 2016 Smart Contract Solutions, Inc.\n * @author \"Manuel Araoz <[email protected]>\"\n * @dev license: \"MIT\", source: https://github.com/OpenZeppelin/zeppelin-solidity\n * @author modification: Dmitriy Khizhinskiy @McFly.aero\n * @dev Simple ERC20 Token example, with mintable token creation\n * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120\n * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\n */\ncontract MintableToken is StandardToken, Ownable {\n    event Mint(address indexed to, uint256 amount);\n    event MintFinished();\n\n    bool public mintingFinished = false;\n\n    modifier canMint() {\n        require(!mintingFinished);\n        _;\n    }\n\n\n    /**\n    * @dev Function to mint tokens\n    * @param _to The address that will receive the minted tokens.\n    * @param _amount The amount of tokens to mint.\n    * @return A boolean that indicates if the operation was successful.\n    */\n    function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n        totalSupply_ = totalSupply_.add(_amount);\n        balances[_to] = balances[_to].add(_amount);\n        Mint(_to, _amount);\n        Transfer(address(0), _to, _amount);\n        return true;\n    }\n\n\n    /**\n    * @dev Function to stop minting new tokens.\n    * @return True if the operation was successful.\n    */\n    function finishMinting() onlyOwner canMint public returns (bool) {\n        mintingFinished = true;\n        MintFinished();\n        return true;\n    }\n}\n\n\n/**\n * @title McFly token smart contract\n * @author Copyright (c) 2018 McFly.aero\n * @author Dmitriy Khizhinskiy\n * @author \"MIT\"\n */\ncontract McFlyToken is MintableToken {\n    string public constant name = \"McFlyToken\";\n    string public constant symbol = \"McFLY\";\n    uint8 public constant decimals = 18;\n\n    /// @dev mapping for whitelist\n    mapping(address=>bool) whitelist;\n\n    /// @dev event throw when allowed to transfer address added to whitelist\n    /// @param from address\n    event AllowTransfer(address from);\n\n    /// @dev check for allowence of transfer\n    modifier canTransfer() {\n        require(mintingFinished || whitelist[msg.sender]);\n        _;        \n    }\n\n    /// @dev add address to whitelist\n    /// @param from address to add\n    function allowTransfer(address from) onlyOwner public {\n        whitelist[from] = true;\n        AllowTransfer(from);\n    }\n\n    /// @dev Do the transfer from address to address value\n    /// @param from address from\n    /// @param to address to\n    /// @param value uint256\n    function transferFrom(address from, address to, uint256 value) canTransfer public returns (bool) {\n        return super.transferFrom(from, to, value);\n    }\n\n    /// @dev Do the transfer from token address to \"to\" address value\n    /// @param to address to\n    /// @param value uint256 value\n    function transfer(address to, uint256 value) canTransfer public returns (bool) {\n        return super.transfer(to, value);\n    }\n}\n\n\n\n\n\n\n\n/**\n * @title Haltable smart contract - controls owner access\n * @author Copyright (c) 2018 McFly.aero\n * @author Dmitriy Khizhinskiy\n * @author \"MIT\"\n */\ncontract Haltable is MultiOwners {\n    bool public halted;\n\n    modifier stopInEmergency {\n        require(!halted);\n        _;\n    }\n\n\n    modifier onlyInEmergency {\n        require(halted);\n        _;\n    }\n\n\n    /// @dev called by the owner on emergency, triggers stopped state\n    function halt() external onlyOwner {\n        halted = true;\n    }\n\n\n    /// @dev called by the owner on end of emergency, returns to normal state\n    function unhalt() external onlyOwner onlyInEmergency {\n        halted = false;\n    }\n\n}\n\n\n\n/**\n * @title McFly crowdsale smart contract \n * @author Copyright (c) 2018 McFly.aero\n * @author Dmitriy Khizhinskiy\n * @author \"MIT\"\n * @dev inherited from MultiOwners & Haltable\n */\ncontract McFlyCrowd is MultiOwners, Haltable {\n    using SafeMath for uint256;\n\n    /// @dev Total ETH received during WAVES, TLP1.2 & window[1-5]\n    uint256 public counter_in; // tlp2\n    \n    /// @dev minimum ETH to partisipate in window 1-5\n    uint256 public minETHin = 1e18; // 1 ETH\n\n    /// @dev Token\n    McFlyToken public token;\n\n    /// @dev Withdraw wallet\n    address public wallet;\n\n    /// @dev start and end timestamp for TLP 1.2, other values callculated\n    uint256 public sT2; // startTimeTLP2\n    uint256 constant dTLP2 = 118 days; // days of TLP2\n    uint256 constant dBt = 60 days; // days between Windows\n    uint256 constant dW = 12 days; // 12 days for 3,4,5,6,7 windows;\n\n    /// @dev Cap maximum possible tokens for minting\n    uint256 public constant hardCapInTokens = 1800e24; // 1,800,000,000 MFL\n\n    /// @dev maximum possible tokens for sell \n    uint256 public constant mintCapInTokens = 1260e24; // 1,260,000,000 MFL\n\n    /// @dev tokens crowd within TLP2\n    uint256 public crowdTokensTLP2;\n\n    uint256 public _preMcFly;\n\n    /// @dev maximum possible tokens for fund minting\n    uint256 constant fundTokens = 270e24; // 270,000,000 MFL\n    uint256 public fundTotalSupply;\n    address public fundMintingAgent;\n\n    /// @dev maximum possible tokens to convert from WAVES\n    uint256 constant wavesTokens = 100e24; // 100,000,000 MFL\n    address public wavesAgent;\n    address public wavesGW;\n\n    /// @dev Vesting param for team, advisory, reserve.\n    uint256 constant VestingPeriodInSeconds = 30 days; // 24 month\n    uint256 constant VestingPeriodsCount = 24;\n\n    /// @dev Team 10%\n    uint256 constant _teamTokens = 180e24;\n    uint256 public teamTotalSupply;\n    address public teamWallet;\n\n    /// @dev Bounty 5% (2% + 3%)\n    /// @dev Bounty online 2%\n    uint256 constant _bountyOnlineTokens = 36e24;\n    address public bountyOnlineWallet;\n    address public bountyOnlineGW;\n\n    /// @dev Bounty offline 3%\n    uint256 constant _bountyOfflineTokens = 54e24;\n    address public bountyOfflineWallet;\n\n    /// @dev Advisory 5%\n    uint256 constant _advisoryTokens = 90e24;\n    uint256 public advisoryTotalSupply;\n    address public advisoryWallet;\n\n    /// @dev Reserved for future 9%\n    uint256 constant _reservedTokens = 162e24;\n    uint256 public reservedTotalSupply;\n    address public reservedWallet;\n\n    /// @dev AirDrop 1%\n    uint256 constant _airdropTokens = 18e24;\n    address public airdropWallet;\n    address public airdropGW;\n\n    /// @dev PreMcFly wallet (MFL)\n    address public preMcFlyWallet;\n\n    /// @dev Ppl structure for Win1-5\n    struct Ppl {\n        address addr;\n        uint256 amount;\n    }\n    mapping (uint32 => Ppl) public ppls;\n\n    /// @dev Window structure for Win1-5\n    struct Window {\n        bool active;\n        uint256 totalEthInWindow;\n        uint32 totalTransCnt;\n        uint32 refundIndex;\n        uint256 tokenPerWindow;\n    } \n    mapping (uint8 => Window) public ww;\n\n\n    /// @dev Events\n    event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);\n    event TokenPurchaseInWindow(address indexed beneficiary, uint256 value, uint8 winnum, uint32 totalcnt, uint256 totaleth1);\n    event TransferOddEther(address indexed beneficiary, uint256 value);\n    event FundMinting(address indexed beneficiary, uint256 value);\n    event WithdrawVesting(address indexed beneficiary, uint256 period, uint256 value, uint256 valueTotal);\n    event TokenWithdrawAtWindow(address indexed beneficiary, uint256 value);\n    event SetFundMintingAgent(address newAgent);\n    event SetTeamWallet(address newTeamWallet);\n    event SetAdvisoryWallet(address newAdvisoryWallet);\n    event SetReservedWallet(address newReservedWallet);\n    event SetStartTimeTLP2(uint256 newStartTimeTLP2);\n    event SetMinETHincome(uint256 newMinETHin);\n    event NewWindow(uint8 winNum, uint256 amountTokensPerWin);\n    event TokenETH(uint256 totalEth, uint32 totalCnt);\n\n\n    /// @dev check for Non zero value\n    modifier validPurchase() {\n        require(msg.value != 0);\n        _;        \n    }\n\n\n    /**\n     * @dev conctructor of contract, set main params, create new token, do minting for some wallets\n     * @param _startTimeTLP2 - set date time of starting of TLP2 (main date!)\n     * @param _preMcFlyTotalSupply - set amount in wei total supply of previouse contract (MFL)\n     * @param _wallet - wallet for transfer ETH to it\n     * @param _wavesAgent - wallet for WAVES gw\n     * @param _wavesGW    - wallet for WAVES gw\n     * @param _fundMintingAgent - wallet who allowed to mint before TLP2\n     * @param _teamWallet - wallet for team vesting\n     * @param _bountyOnlineWallet - wallet for online bounty\n     * @param _bountyOnlineGW - wallet for online bounty GW\n     * @param _bountyOfflineWallet - wallet for offline bounty\n     * @param _advisoryWallet - wallet for advisory vesting\n     * @param _reservedWallet - wallet for reserved vesting\n     * @param _airdropWallet - wallet for airdrop\n     * @param _airdropGW - wallet for airdrop GW\n     * @param _preMcFlyWallet - wallet for transfer old MFL->McFly (once)\n     */\n    function McFlyCrowd(\n        uint256 _startTimeTLP2,\n        uint256 _preMcFlyTotalSupply,\n        address _wallet,\n        address _wavesAgent,\n        address _wavesGW,\n        address _fundMintingAgent,\n        address _teamWallet,\n        address _bountyOnlineWallet,\n        address _bountyOnlineGW,\n        address _bountyOfflineWallet,\n        address _advisoryWallet,\n        address _reservedWallet,\n        address _airdropWallet,\n        address _airdropGW,\n        address _preMcFlyWallet\n    ) public \n    {   \n        require(_startTimeTLP2 >= block.timestamp);\n        require(_preMcFlyTotalSupply > 0);\n        require(_wallet != 0x0);\n        require(_wavesAgent != 0x0);\n        require(_wavesGW != 0x0);\n        require(_fundMintingAgent != 0x0);\n        require(_teamWallet != 0x0);\n        require(_bountyOnlineWallet != 0x0);\n        require(_bountyOnlineGW != 0x0);\n        require(_bountyOfflineWallet != 0x0);\n        require(_advisoryWallet != 0x0);\n        require(_reservedWallet != 0x0);\n        require(_airdropWallet != 0x0);\n        require(_airdropGW != 0x0);\n        require(_preMcFlyWallet != 0x0);\n\n        token = new McFlyToken();\n\n        wallet = _wallet;\n\n        sT2 = _startTimeTLP2;\n\n        wavesAgent = _wavesAgent;\n        wavesGW = _wavesGW;\n\n        fundMintingAgent = _fundMintingAgent;\n\n        teamWallet = _teamWallet;\n        bountyOnlineWallet = _bountyOnlineWallet;\n        bountyOnlineGW = _bountyOnlineGW;\n        bountyOfflineWallet = _bountyOfflineWallet;\n        advisoryWallet = _advisoryWallet;\n        reservedWallet = _reservedWallet;\n        airdropWallet = _airdropWallet;\n        airdropGW = _airdropGW;\n        preMcFlyWallet = _preMcFlyWallet;\n\n        /// @dev Mint all tokens and than control it by vesting\n        _preMcFly = _preMcFlyTotalSupply;\n        token.mint(preMcFlyWallet, _preMcFly); // McFly for thansfer to old MFL owners\n        token.allowTransfer(preMcFlyWallet);\n        crowdTokensTLP2 = crowdTokensTLP2.add(_preMcFly);\n\n        token.mint(wavesAgent, wavesTokens); // 100,000,000 MFL\n        token.allowTransfer(wavesAgent);\n        token.allowTransfer(wavesGW);\n        crowdTokensTLP2 = crowdTokensTLP2.add(wavesTokens);\n\n        token.mint(this, _teamTokens); // mint to contract address\n\n        token.mint(bountyOnlineWallet, _bountyOnlineTokens);\n        token.allowTransfer(bountyOnlineWallet);\n        token.allowTransfer(bountyOnlineGW);\n\n        token.mint(bountyOfflineWallet, _bountyOfflineTokens);\n        token.allowTransfer(bountyOfflineWallet);\n\n        token.mint(this, _advisoryTokens);\n\n        token.mint(this, _reservedTokens);\n\n        token.mint(airdropWallet, _airdropTokens);\n        token.allowTransfer(airdropWallet);\n        token.allowTransfer(airdropGW);\n    }\n\n\n    /**\n     * @dev check is TLP2 is active?\n     * @return false if crowd TLP2 event was ended\n     */\n    function withinPeriod() constant public returns (bool) {\n        return (now >= sT2 && now <= (sT2+dTLP2));\n    }\n\n\n    /**\n     * @dev check is TLP2 is active and minting Not finished\n     * @return false if crowd event was ended\n     */\n    function running() constant public returns (bool) {\n        return withinPeriod() && !token.mintingFinished();\n    }\n\n\n    /**\n     * @dev check current stage name\n     * @return uint8 stage number\n     */\n    function stageName() constant public returns (uint8) {\n        uint256 eT2 = sT2+dTLP2;\n\n        if (now < sT2) {return 101;} // not started\n        if (now >= sT2 && now <= eT2) {return (102);} // TLP1.2\n\n        if (now > eT2 && now < eT2+dBt) {return (103);} // preTLP1.3\n        if (now >= (eT2+dBt) && now <= (eT2+dBt+dW)) {return (0);} // TLP1.3\n        if (now > (eT2+dBt+dW) && now < (eT2+dBt+dW+dBt)) {return (104);} // preTLP1.4\n        if (now >= (eT2+dBt+dW+dBt) && now <= (eT2+dBt+dW+dBt+dW)) {return (1);} // TLP1.4\n        if (now > (eT2+dBt+dW+dBt+dW) && now < (eT2+dBt+dW+dBt+dW+dBt)) {return (105);} // preTLP1.5\n        if (now >= (eT2+dBt+dW+dBt+dW+dBt) && now <= (eT2+dBt+dW+dBt+dW+dBt+dW)) {return (2);} // TLP1.5\n        if (now > (eT2+dBt+dW+dBt+dW+dBt+dW) && now < (eT2+dBt+dW+dBt+dW+dBt+dW+dBt)) {return (106);} // preTLP1.6\n        if (now >= (eT2+dBt+dW+dBt+dW+dBt+dW+dBt) && now <= (eT2+dBt+dW+dBt+dW+dBt+dW+dBt+dW)) {return (3);} // TLP1.6\n        if (now > (eT2+dBt+dW+dBt+dW+dBt+dW+dBt+dW) && now < (eT2+dBt+dW+dBt+dW+dBt+dW+dBt+dW+dBt)) {return (107);} // preTLP1.7\n        if (now >= (eT2+dBt+dW+dBt+dW+dBt+dW+dBt+dW+dBt) && now <= (eT2+dBt+dW+dBt+dW+dBt+dW+dBt+dW+dBt+dW)) {return (4);} // TLP1.7\"\n        if (now > (eT2+dBt+dW+dBt+dW+dBt+dW+dBt+dW+dBt+dW)) {return (200);} // Finished\n        return (201); // unknown\n    }\n\n\n    /** \n     * @dev change agent for minting\n     * @param agent - new agent address\n     */\n    function setFundMintingAgent(address agent) onlyOwner public {\n        fundMintingAgent = agent;\n        SetFundMintingAgent(agent);\n    }\n\n\n    /** \n     * @dev change wallet for team vesting (this make possible to set smart-contract address later)\n     * @param _newTeamWallet - new wallet address\n     */\n    function setTeamWallet(address _newTeamWallet) onlyOwner public {\n        teamWallet = _newTeamWallet;\n        SetTeamWallet(_newTeamWallet);\n    }\n\n\n    /** \n     * @dev change wallet for advisory vesting (this make possible to set smart-contract address later)\n     * @param _newAdvisoryWallet - new wallet address\n     */\n    function setAdvisoryWallet(address _newAdvisoryWallet) onlyOwner public {\n        advisoryWallet = _newAdvisoryWallet;\n        SetAdvisoryWallet(_newAdvisoryWallet);\n    }\n\n\n    /** \n     * @dev change wallet for reserved vesting (this make possible to set smart-contract address later)\n     * @param _newReservedWallet - new wallet address\n     */\n    function setReservedWallet(address _newReservedWallet) onlyOwner public {\n        reservedWallet = _newReservedWallet;\n        SetReservedWallet(_newReservedWallet);\n    }\n\n\n    /**\n     * @dev change min ETH income during Window1-5\n     * @param _minETHin - new limit\n     */\n    function setMinETHin(uint256 _minETHin) onlyOwner public {\n        minETHin = _minETHin;\n        SetMinETHincome(_minETHin);\n    }\n\n\n    /**\n     * @dev set TLP1.X (2-7) start & end dates\n     * @param _at - new or old start date\n     */\n    function setStartEndTimeTLP(uint256 _at) onlyOwner public {\n        require(block.timestamp < sT2); // forbid change time when TLP1.2 is active\n        require(block.timestamp < _at); // should be great than current block timestamp\n\n        sT2 = _at;\n        SetStartTimeTLP2(_at);\n    }\n\n\n    /**\n     * @dev Large Token Holder minting \n     * @param to - mint to address\n     * @param amount - how much mint\n     */\n    function fundMinting(address to, uint256 amount) stopInEmergency public {\n        require(msg.sender == fundMintingAgent || isOwner());\n        require(block.timestamp < sT2);\n        require(fundTotalSupply.add(amount) <= fundTokens);\n        require(token.totalSupply().add(amount) <= hardCapInTokens);\n\n        fundTotalSupply = fundTotalSupply.add(amount);\n        token.mint(to, amount);\n        FundMinting(to, amount);\n    }\n\n\n    /**\n     * @dev calculate amount\n     * @param  amount - ether to be converted to tokens\n     * @param  at - current time\n     * @param  _totalSupply - total supplied tokens\n     * @return tokens amount that we should send to our dear ppl\n     * @return odd ethers amount, which contract should send back\n     */\n    function calcAmountAt(\n        uint256 amount,\n        uint256 at,\n        uint256 _totalSupply\n    ) public constant returns (uint256, uint256) \n    {\n        uint256 estimate;\n        uint256 price;\n        \n        if (at >= sT2 && at <= (sT2+dTLP2)) {\n            if (at <= sT2 + 15 days) {price = 12e13;} else if (at <= sT2 + 30 days) {\n                price = 14e13;} else if (at <= sT2 + 45 days) {\n                    price = 16e13;} else if (at <= sT2 + 60 days) {\n                        price = 18e13;} else if (at <= sT2 + 75 days) {\n                            price = 20e13;} else if (at <= sT2 + 90 days) {\n                                price = 22e13;} else if (at <= sT2 + 105 days) {\n                                    price = 24e13;} else if (at <= sT2 + 118 days) {\n                                        price = 26e13;} else {revert();}\n        } else {revert();}\n\n        estimate = _totalSupply.add(amount.mul(1e18).div(price));\n\n        if (estimate > hardCapInTokens) {\n            return (\n                hardCapInTokens.sub(_totalSupply),\n                estimate.sub(hardCapInTokens).mul(price).div(1e18)\n            );\n        }\n        return (estimate.sub(_totalSupply), 0);\n    }\n\n\n    /**\n     * @dev fallback for processing ether\n     */\n    function() external payable {\n        return getTokens(msg.sender);\n    }\n\n\n    /**\n     * @dev sell token and send to contributor address\n     * @param contributor address\n     */\n    function getTokens(address contributor) payable stopInEmergency validPurchase public {\n        uint256 amount;\n        uint256 oddEthers;\n        uint256 ethers;\n        uint256 _at;\n        uint8 _winNum;\n\n        _at = block.timestamp;\n\n        require(contributor != 0x0);\n       \n        if (withinPeriod()) {\n        \n            (amount, oddEthers) = calcAmountAt(msg.value, _at, token.totalSupply());\n  \n            require(amount.add(token.totalSupply()) <= hardCapInTokens);\n\n            ethers = msg.value.sub(oddEthers);\n\n            token.mint(contributor, amount); // fail if minting is finished\n            TokenPurchase(contributor, ethers, amount);\n            counter_in = counter_in.add(ethers);\n            crowdTokensTLP2 = crowdTokensTLP2.add(amount);\n\n            if (oddEthers > 0) {\n                require(oddEthers < msg.value);\n                contributor.transfer(oddEthers);\n                TransferOddEther(contributor, oddEthers);\n            }\n\n            wallet.transfer(ethers);\n        } else {\n            require(msg.value >= minETHin); // checks min ETH income\n            _winNum = stageName();\n            require(_winNum >= 0 && _winNum < 5);\n            Window storage w = ww[_winNum];\n\n            require(w.tokenPerWindow > 0); // check that we have tokens!\n\n            w.totalEthInWindow = w.totalEthInWindow.add(msg.value);\n            ppls[w.totalTransCnt].addr = contributor;\n            ppls[w.totalTransCnt].amount = msg.value;\n            w.totalTransCnt++;\n            TokenPurchaseInWindow(contributor, msg.value, _winNum, w.totalTransCnt, w.totalEthInWindow);\n        }\n    }\n\n\n    /**\n     * @dev close Window and transfer Eth to wallet address\n     * @param _winNum - number of window 0-4 to close\n     */\n    function closeWindow(uint8 _winNum) onlyOwner stopInEmergency public {\n        require(ww[_winNum].active);\n        ww[_winNum].active = false;\n\n        wallet.transfer(this.balance);\n    }\n\n\n    /**\n     * @dev transfer tokens to ppl accts (window1-5)\n     * @param _winNum - number of window 0-4 to close\n     */\n    function sendTokensWindow(uint8 _winNum) onlyOwner stopInEmergency public {\n        uint256 _tokenPerETH;\n        uint256 _tokenToSend = 0;\n        address _tempAddr;\n        uint32 index = ww[_winNum].refundIndex;\n\n        TokenETH(ww[_winNum].totalEthInWindow, ww[_winNum].totalTransCnt);\n\n        require(ww[_winNum].active);\n        require(ww[_winNum].totalEthInWindow > 0);\n        require(ww[_winNum].totalTransCnt > 0);\n\n        _tokenPerETH = ww[_winNum].tokenPerWindow.div(ww[_winNum].totalEthInWindow); // max McFly in window / ethInWindow\n\n        while (index < ww[_winNum].totalTransCnt && msg.gas > 100000) {\n            _tokenToSend = _tokenPerETH.mul(ppls[index].amount);\n            ppls[index].amount = 0;\n            _tempAddr = ppls[index].addr;\n            ppls[index].addr = 0;\n            index++;\n            token.transfer(_tempAddr, _tokenToSend);\n            TokenWithdrawAtWindow(_tempAddr, _tokenToSend);\n        }\n        ww[_winNum].refundIndex = index;\n    }\n\n\n    /**\n     * @dev open new window 0-5 and write totl token per window in structure\n     * @param _winNum - number of window 0-4 to close\n     * @param _tokenPerWindow - total token for window 0-4\n     */\n    function newWindow(uint8 _winNum, uint256 _tokenPerWindow) private {\n        ww[_winNum] = Window(true, 0, 0, 0, _tokenPerWindow);\n        NewWindow(_winNum, _tokenPerWindow);\n    }\n\n\n    /**\n     * @dev Finish crowdsale TLP1.2 period and open window1-5 crowdsale\n     */\n    function finishCrowd() onlyOwner public {\n        uint256 _tokenPerWindow;\n        require(now > (sT2.add(dTLP2)) || hardCapInTokens == token.totalSupply());\n        require(!token.mintingFinished());\n\n        _tokenPerWindow = (mintCapInTokens.sub(crowdTokensTLP2).sub(fundTotalSupply)).div(5);\n        token.mint(this, _tokenPerWindow.mul(5)); // mint to contract address\n        // shoud be MAX tokens minted!!! 1,800,000,000\n        for (uint8 y = 0; y < 5; y++) {\n            newWindow(y, _tokenPerWindow);\n        }\n\n        token.finishMinting();\n    }\n\n\n    /**\n     * @dev withdraw tokens amount within vesting rules for team, advisory and reserved\n     * @param withdrawWallet - wallet to transfer tokens\n     * @param withdrawTokens - amount of tokens to transfer to\n     * @param withdrawTotalSupply - total amount of tokens transfered to account\n     * @return unit256 total amount of tokens after transfer\n     */\n    function vestingWithdraw(address withdrawWallet, uint256 withdrawTokens, uint256 withdrawTotalSupply) private returns (uint256) {\n        require(token.mintingFinished());\n        require(msg.sender == withdrawWallet || isOwner());\n\n        uint256 currentPeriod = (block.timestamp.sub(sT2.add(dTLP2))).div(VestingPeriodInSeconds);\n        if (currentPeriod > VestingPeriodsCount) {\n            currentPeriod = VestingPeriodsCount;\n        }\n        uint256 tokenAvailable = withdrawTokens.mul(currentPeriod).div(VestingPeriodsCount).sub(withdrawTotalSupply);  // RECHECK!!!!!\n\n        require((withdrawTotalSupply.add(tokenAvailable)) <= withdrawTokens);\n\n        uint256 _withdrawTotalSupply = withdrawTotalSupply.add(tokenAvailable);\n\n        token.transfer(withdrawWallet, tokenAvailable);\n        WithdrawVesting(withdrawWallet, currentPeriod, tokenAvailable, _withdrawTotalSupply);\n\n        return _withdrawTotalSupply;\n    }\n\n\n    /**\n     * @dev withdraw tokens amount within vesting rules for team\n     */\n    function teamWithdraw() public {\n        teamTotalSupply = vestingWithdraw(teamWallet, _teamTokens, teamTotalSupply);\n    }\n\n\n    /**\n     * @dev withdraw tokens amount within vesting rules for advisory\n     */\n    function advisoryWithdraw() public {\n        advisoryTotalSupply = vestingWithdraw(advisoryWallet, _advisoryTokens, advisoryTotalSupply);\n    }\n\n\n    /**\n     * @dev withdraw tokens amount within vesting rules for reserved wallet\n     */\n    function reservedWithdraw() public {\n        reservedTotalSupply = vestingWithdraw(reservedWallet, _reservedTokens, reservedTotalSupply);\n    }\n}",
  "bytecode": "60606040526004805460a060020a60ff021916905560038054600160a060020a03191633600160a060020a0316179055610d448061003e6000396000f3006060604052600436106101065763ffffffff7c010000000000000000000000000000000000000000000000000000000060003504166305d2035b811461010b57806306fdde0314610132578063095ea7b3146101bc57806318160ddd146101de57806323b872dd14610203578063313ce5671461022b57806340c10f191461025457806366188463146102765780636c8381f81461029857806370a08231146102c75780637d64bcb4146102e65780638753b16e146102f95780638da5cb5b1461031a57806395d89b411461032d578063a9059cbb14610340578063b3490bfc14610362578063d5d1e77014610381578063d73dd62314610394578063dd62ed3e146103b6575b600080fd5b341561011657600080fd5b61011e6103db565b604051901515815260200160405180910390f35b341561013d57600080fd5b6101456103eb565b60405160208082528190810183818151815260200191508051906020019080838360005b83811015610181578082015183820152602001610169565b50505050905090810190601f1680156101ae5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b34156101c757600080fd5b61011e600160a060020a0360043516602435610422565b34156101e957600080fd5b6101f161048e565b60405190815260200160405180910390f35b341561020e57600080fd5b61011e600160a060020a0360043581169060243516604435610494565b341561023657600080fd5b61023e6104e5565b60405160ff909116815260200160405180910390f35b341561025f57600080fd5b61011e600160a060020a03600435166024356104ea565b341561028157600080fd5b61011e600160a060020a03600435166024356105f8565b34156102a357600080fd5b6102ab6106f2565b604051600160a060020a03909116815260200160405180910390f35b34156102d257600080fd5b6101f1600160a060020a0360043516610701565b34156102f157600080fd5b61011e61071c565b341561030457600080fd5b610318600160a060020a03600435166107a7565b005b341561032557600080fd5b6102ab610806565b341561033857600080fd5b610145610815565b341561034b57600080fd5b61011e600160a060020a036004351660243561084c565b341561036d57600080fd5b610318600160a060020a036004351661089b565b341561038c57600080fd5b61031861091b565b341561039f57600080fd5b61011e600160a060020a0360043516602435610996565b34156103c157600080fd5b6101f1600160a060020a0360043581169060243516610a3a565b60045460a060020a900460ff1681565b60408051908101604052600a81527f4d63466c79546f6b656e00000000000000000000000000000000000000000000602082015281565b600160a060020a03338116600081815260026020908152604080832094871680845294909152808220859055909291907f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b9259085905190815260200160405180910390a350600192915050565b60015490565b60045460009060a060020a900460ff16806104c75750600160a060020a03331660009081526005602052604090205460ff165b15156104d257600080fd5b6104dd848484610a65565b949350505050565b601281565b60035460009033600160a060020a0390811691161461050857600080fd5b60045460a060020a900460ff161561051f57600080fd5b600154610532908363ffffffff610be516565b600155600160a060020a03831660009081526020819052604090205461055e908363ffffffff610be516565b600160a060020a0384166000818152602081905260409081902092909255907f0f6798a560793a54c3bcfe86a93cde1e73087d944c0ea20544137d41213968859084905190815260200160405180910390a2600160a060020a03831660007fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef8460405190815260200160405180910390a350600192915050565b600160a060020a0333811660009081526002602090815260408083209386168352929052908120548083111561065557600160a060020a03338116600090815260026020908152604080832093881683529290529081205561068c565b610665818463ffffffff610bf416565b600160a060020a033381166000908152600260209081526040808320938916835292905220555b600160a060020a0333811660008181526002602090815260408083209489168084529490915290819020547f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925915190815260200160405180910390a35060019392505050565b600454600160a060020a031681565b600160a060020a031660009081526020819052604090205490565b60035460009033600160a060020a0390811691161461073a57600080fd5b60045460a060020a900460ff161561075157600080fd5b6004805474ff0000000000000000000000000000000000000000191660a060020a1790557fae5184fba832cb2b1f702aca6117b8d265eaf03ad33eb133f19dde0f5920fa0860405160405180910390a150600190565b60035433600160a060020a039081169116146107c257600080fd5b600160a060020a03811615156107d757600080fd5b6004805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b600354600160a060020a031681565b60408051908101604052600581527f4d63464c59000000000000000000000000000000000000000000000000000000602082015281565b60045460009060a060020a900460ff168061087f5750600160a060020a03331660009081526005602052604090205460ff165b151561088a57600080fd5b6108948383610c06565b9392505050565b60035433600160a060020a039081169116146108b657600080fd5b600160a060020a03811660009081526005602052604090819020805460ff191660011790557fcc25b8a957df0a0b6c4413850c122a29ee10048018cd63f00e453e1bba64943a90829051600160a060020a03909116815260200160405180910390a150565b60045433600160a060020a0390811691161461093657600080fd5b6004546003805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a039283169081179182905591167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a3565b600160a060020a0333811660009081526002602090815260408083209386168352929052908120546109ce908363ffffffff610be516565b600160a060020a0333811660008181526002602090815260408083209489168084529490915290819020849055919290917f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92591905190815260200160405180910390a350600192915050565b600160a060020a03918216600090815260026020908152604080832093909416825291909152205490565b6000600160a060020a0383161515610a7c57600080fd5b600160a060020a038416600090815260208190526040902054821115610aa157600080fd5b600160a060020a0380851660009081526002602090815260408083203390941683529290522054821115610ad457600080fd5b600160a060020a038416600090815260208190526040902054610afd908363ffffffff610bf416565b600160a060020a038086166000908152602081905260408082209390935590851681522054610b32908363ffffffff610be516565b600160a060020a0380851660009081526020818152604080832094909455878316825260028152838220339093168252919091522054610b78908363ffffffff610bf416565b600160a060020a03808616600081815260026020908152604080832033861684529091529081902093909355908516917fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef9085905190815260200160405180910390a35060019392505050565b60008282018381101561089457fe5b600082821115610c0057fe5b50900390565b6000600160a060020a0383161515610c1d57600080fd5b600160a060020a033316600090815260208190526040902054821115610c4257600080fd5b600160a060020a033316600090815260208190526040902054610c6b908363ffffffff610bf416565b600160a060020a033381166000908152602081905260408082209390935590851681522054610ca0908363ffffffff610be516565b60008085600160a060020a0316600160a060020a031681526020019081526020016000208190555082600160a060020a031633600160a060020a03167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef8460405190815260200160405180910390a3506001929150505600a165627a7a723058204c830ad51b026fcc939bebe3d3fca769676dd770800ad28ffb1d1e8806a0fb590029"
}