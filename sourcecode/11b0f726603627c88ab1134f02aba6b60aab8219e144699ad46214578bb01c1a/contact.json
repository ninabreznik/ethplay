{
  "address": "0xfac16092dd1d459461d1e5caae87d4292d510e7c",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "BasicCoin",
  "compilerVersion": "v0.4.2+commit.af6afb04",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2017-09-25\n*/\n\n//! BasicCoin ECR20-compliant token contract\n//! By Parity Team (Ethcore), 2016.\n//! Released under the Apache Licence 2.\n\npragma solidity ^0.4.1;\n\n// ECR20 standard token interface\ncontract Token {\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  function balanceOf(address _owner) constant returns (uint256 balance);\n  function transfer(address _to, uint256 _value) returns (bool success);\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n  function approve(address _spender, uint256 _value) returns (bool success);\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n}\n\n// Owner-specific contract interface\ncontract Owned {\n  event NewOwner(address indexed old, address indexed current);\n\n  modifier only_owner {\n    if (msg.sender != owner) throw;\n    _;\n  }\n\n  address public owner = msg.sender;\n\n  function setOwner(address _new) only_owner {\n    NewOwner(owner, _new);\n    owner = _new;\n  }\n}\n\n// TokenReg interface\ncontract TokenReg {\n  function register(address _addr, string _tla, uint _base, string _name) payable returns (bool);\n  function registerAs(address _addr, string _tla, uint _base, string _name, address _owner) payable returns (bool);\n  function unregister(uint _id);\n  function setFee(uint _fee);\n  function tokenCount() constant returns (uint);\n  function token(uint _id) constant returns (address addr, string tla, uint base, string name, address owner);\n  function fromAddress(address _addr) constant returns (uint id, string tla, uint base, string name, address owner);\n  function fromTLA(string _tla) constant returns (uint id, address addr, uint base, string name, address owner);\n  function meta(uint _id, bytes32 _key) constant returns (bytes32);\n  function setMeta(uint _id, bytes32 _key, bytes32 _value);\n  function transferTLA(string _tla, address _to) returns (bool success);\n  function drain();\n  uint public fee;\n}\n\n// BasicCoin, ECR20 tokens that all belong to the owner for sending around\ncontract BasicCoin is Owned, Token {\n  // this is as basic as can be, only the associated balance & allowances\n  struct Account {\n    uint balance;\n    mapping (address => uint) allowanceOf;\n  }\n\n  // the balance should be available\n  modifier when_owns(address _owner, uint _amount) {\n    if (accounts[_owner].balance < _amount) throw;\n    _;\n  }\n\n  // an allowance should be available\n  modifier when_has_allowance(address _owner, address _spender, uint _amount) {\n    if (accounts[_owner].allowanceOf[_spender] < _amount) throw;\n    _;\n  }\n\n  // no ETH should be sent with the transaction\n  modifier when_no_eth {\n    if (msg.value > 0) throw;\n    _;\n  }\n\n  // a value should be > 0\n  modifier when_non_zero(uint _value) {\n    if (_value == 0) throw;\n    _;\n  }\n\n  // the base, tokens denoted in micros\n  uint constant public base = 1000000;\n\n  // available token supply\n  uint public totalSupply;\n\n  // storage and mapping of all balances & allowances\n  mapping (address => Account) accounts;\n\n  // constructor sets the parameters of execution, _totalSupply is all units\n  function BasicCoin(uint _totalSupply, address _owner) when_no_eth when_non_zero(_totalSupply) {\n    totalSupply = _totalSupply;\n    owner = _owner;\n    accounts[_owner].balance = totalSupply;\n  }\n\n  // balance of a specific address\n  function balanceOf(address _who) constant returns (uint256) {\n    return accounts[_who].balance;\n  }\n\n  // transfer\n  function transfer(address _to, uint256 _value) when_no_eth when_owns(msg.sender, _value) returns (bool) {\n    Transfer(msg.sender, _to, _value);\n    accounts[msg.sender].balance -= _value;\n    accounts[_to].balance += _value;\n\n    return true;\n  }\n\n  // transfer via allowance\n  function transferFrom(address _from, address _to, uint256 _value) when_no_eth when_owns(_from, _value) when_has_allowance(_from, msg.sender, _value) returns (bool) {\n    Transfer(_from, _to, _value);\n    accounts[_from].allowanceOf[msg.sender] -= _value;\n    accounts[_from].balance -= _value;\n    accounts[_to].balance += _value;\n\n    return true;\n  }\n\n  // approve allowances\n  function approve(address _spender, uint256 _value) when_no_eth returns (bool) {\n    Approval(msg.sender, _spender, _value);\n    accounts[msg.sender].allowanceOf[_spender] += _value;\n\n    return true;\n  }\n\n  // available allowance\n  function allowance(address _owner, address _spender) constant returns (uint256) {\n    return accounts[_owner].allowanceOf[_spender];\n  }\n\n  // no default function, simple contract only, entry-level users\n  function() {\n    throw;\n  }\n}\n\n// Manages BasicCoin instances, including the deployment & registration\ncontract BasicCoinManager is Owned {\n  // a structure wrapping a deployed BasicCoin\n  struct Coin {\n    address coin;\n    address owner;\n    address tokenreg;\n  }\n\n  // a new BasicCoin has been deployed\n  event Created(address indexed owner, address indexed tokenreg, address indexed coin);\n\n  // a list of all the deployed BasicCoins\n  Coin[] coins;\n\n  // all BasicCoins for a specific owner\n  mapping (address => uint[]) ownedCoins;\n\n  // the base, tokens denoted in micros (matches up with BasicCoin interface above)\n  uint constant public base = 1000000;\n\n  // return the number of deployed\n  function count() constant returns (uint) {\n    return coins.length;\n  }\n\n  // get a specific deployment\n  function get(uint _index) constant returns (address coin, address owner, address tokenreg) {\n    Coin c = coins[_index];\n\n    coin = c.coin;\n    owner = c.owner;\n    tokenreg = c.tokenreg;\n  }\n\n  // returns the number of coins for a specific owner\n  function countByOwner(address _owner) constant returns (uint) {\n    return ownedCoins[_owner].length;\n  }\n\n  // returns a specific index by owner\n  function getByOwner(address _owner, uint _index) constant returns (address coin, address owner, address tokenreg) {\n    return get(ownedCoins[_owner][_index]);\n  }\n\n  // deploy a new BasicCoin on the blockchain\n  function deploy(uint _totalSupply, string _tla, string _name, address _tokenreg) payable returns (bool) {\n    TokenReg tokenreg = TokenReg(_tokenreg);\n    BasicCoin coin = new BasicCoin(_totalSupply, msg.sender);\n\n    uint ownerCount = countByOwner(msg.sender);\n    uint fee = tokenreg.fee();\n\n    ownedCoins[msg.sender].length = ownerCount + 1;\n    ownedCoins[msg.sender][ownerCount] = coins.length;\n    coins.push(Coin(coin, msg.sender, tokenreg));\n    tokenreg.registerAs.value(fee)(coin, _tla, base, _name, msg.sender);\n\n    Created(msg.sender, tokenreg, coin);\n\n    return true;\n  }\n\n  // owner can withdraw all collected funds\n  function drain() only_owner {\n    if (!msg.sender.send(this.balance)) {\n      throw;\n    }\n  }\n}",
  "bytecode": "6060604081815260008054600160a060020a0319163317905580610523833960a09052516080516000341115609d576002565b8260016000508190555081600060006101000a815481600160a060020a03021916908302179055506001600050546002600050600084600160a060020a0316815260200190815260200160002060005060000160005081905550505050610479806100aa6000396000f35b818060001415603257600256606060405236156100775760e060020a6000350463095ea7b3811461008457806313af4035146100a257806318160ddd146100c957806323b872dd146100d75780635001f3b5146100f857806370a08231146101075780638da5cb5b1461013a578063a9059cbb14610151578063dd62ed3e1461016f575b34610002576101ae610002565b34610002576101b0600435602435600060003411156101e157610002565b34610002576101ae600435600054600160a060020a03908116339091161461026457610002565b346100025761012860015481565b34610002576101b0600435602435604435600060003411156102bf57610002565b3461000257610128620f424081565b3461000257600160a060020a03600435166000908152600260205260409020545b60408051918252519081900360200190f35b34610002576101c4600054600160a060020a031681565b34610002576101b0600435602435600060003411156103cb57610002565b3461000257610128600435602435600160a060020a03828116600090815260026020908152604080832093851683526001909301905220545b92915050565b005b604080519115158252519081900360200190f35b60408051600160a060020a03929092168252519081900360200190f35b82600160a060020a031633600160a060020a03167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925846040518082815260200191505060405180910390a35033600160a060020a0390811660009081526002602090815260408083209386168352600193840190915290208054830190556101a8565b60008054604051600160a060020a03848116939216917f70aea8d848e8a90fb7661b227dc522eb6395c3dac71b63cb59edd5c9899b236491a36000805473ffffffffffffffffffffffffffffffffffffffff19168217905550565b600160a060020a03841660009081526002602052604090205484908390819010156102e957610002565b600160a060020a03868116600090815260026020908152604080832033948516845260010190915290205487919086908190101561032657610002565b87600160a060020a031689600160a060020a03167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef896040518082815260200191505060405180910390a3600160a060020a03898116600090815260026020818152604080842033861685526001818101845282862080548f900390559390925281548c9003909155928b168252919020805489019055955050505050509392505050565b33600160a060020a0381166000908152600260205260409020548390819010156103f457610002565b84600160a060020a031633600160a060020a03167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef866040518082815260200191505060405180910390a333600160a060020a039081166000908152600260205260408082208054889003905591871681522080548501905560019250505092915050560000000000000000000000000000000000000000000000000000b5e620f4800000000000000000000000000000438a827b29e346879dc81404e296182d9b2b20"
}