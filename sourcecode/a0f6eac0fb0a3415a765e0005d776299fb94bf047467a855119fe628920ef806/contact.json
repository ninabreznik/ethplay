{
  "address": "0x8c9d4a3B17F0e080ED9F6190181Aac7058cEd7AC",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "KyberDxMarketMaker",
  "compilerVersion": "v0.5.2+commit.1df8f40c",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2019-04-07\n*/\n\npragma solidity 0.5.2;\n\n// File: contracts/ERC20Interface.sol\n\n// https://github.com/ethereum/EIPs/issues/20\ninterface ERC20 {\n    function totalSupply() external view returns (uint supply);\n    function balanceOf(address _owner) external view returns (uint balance);\n    function transfer(address _to, uint _value) external returns (bool success);\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\n    function approve(address _spender, uint _value) external returns (bool success);\n    function allowance(address _owner, address _spender) external view returns (uint remaining);\n    function decimals() external view returns(uint digits);\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\n\n\ncontract ERC20WithSymbol is ERC20 {\n    function symbol() external view returns (string memory _symbol);\n}\n\n// File: contracts/PermissionGroups.sol\n\ncontract PermissionGroups {\n\n    address public admin;\n    address public pendingAdmin;\n    mapping(address=>bool) internal operators;\n    mapping(address=>bool) internal alerters;\n    address[] internal operatorsGroup;\n    address[] internal alertersGroup;\n    uint constant internal MAX_GROUP_SIZE = 50;\n\n    constructor() public {\n        admin = msg.sender;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Operation limited to admin\");\n        _;\n    }\n\n    modifier onlyOperator() {\n        require(operators[msg.sender], \"Operation limited to operator\");\n        _;\n    }\n\n    modifier onlyAlerter() {\n        require(alerters[msg.sender], \"Operation limited to alerter\");\n        _;\n    }\n\n    function getOperators () external view returns(address[] memory) {\n        return operatorsGroup;\n    }\n\n    function getAlerters () external view returns(address[] memory) {\n        return alertersGroup;\n    }\n\n    event TransferAdminPending(address pendingAdmin);\n\n    /**\n     * @dev Allows the current admin to set the pendingAdmin address.\n     * @param newAdmin The address to transfer ownership to.\n     */\n    function transferAdmin(address newAdmin) public onlyAdmin {\n        require(newAdmin != address(0), \"admin address cannot be 0\");\n        emit TransferAdminPending(pendingAdmin);\n        pendingAdmin = newAdmin;\n    }\n\n    /**\n     * @dev Allows the current admin to set the admin in one tx. Useful initial deployment.\n     * @param newAdmin The address to transfer ownership to.\n     */\n    function transferAdminQuickly(address newAdmin) public onlyAdmin {\n        require(newAdmin != address(0), \"admin address cannot be 0\");\n        emit TransferAdminPending(newAdmin);\n        emit AdminClaimed(newAdmin, admin);\n        admin = newAdmin;\n    }\n\n    event AdminClaimed( address newAdmin, address previousAdmin);\n\n    /**\n     * @dev Allows the pendingAdmin address to finalize the change admin process.\n     */\n    function claimAdmin() public {\n        require(pendingAdmin == msg.sender, \"admin address cannot be 0\");\n        emit AdminClaimed(pendingAdmin, admin);\n        admin = pendingAdmin;\n        pendingAdmin = address(0);\n    }\n\n    event AlerterAdded (address newAlerter, bool isAdd);\n\n    function addAlerter(address newAlerter) public onlyAdmin {\n        // prevent duplicates.\n        require(!alerters[newAlerter], \"alerter already configured\");\n        require(\n            alertersGroup.length < MAX_GROUP_SIZE,\n            \"alerter group exceeding maximum size\"\n        );\n\n        emit AlerterAdded(newAlerter, true);\n        alerters[newAlerter] = true;\n        alertersGroup.push(newAlerter);\n    }\n\n    function removeAlerter (address alerter) public onlyAdmin {\n        require(alerters[alerter], \"alerter not configured\");\n        alerters[alerter] = false;\n\n        for (uint i = 0; i < alertersGroup.length; ++i) {\n            if (alertersGroup[i] == alerter) {\n                alertersGroup[i] = alertersGroup[alertersGroup.length - 1];\n                alertersGroup.length--;\n                emit AlerterAdded(alerter, false);\n                break;\n            }\n        }\n    }\n\n    event OperatorAdded(address newOperator, bool isAdd);\n\n    function addOperator(address newOperator) public onlyAdmin {\n        // prevent duplicates.\n        require(!operators[newOperator], \"operator already configured\");\n        require(\n            operatorsGroup.length < MAX_GROUP_SIZE,\n            \"operator group exceeding maximum size\"\n        );\n\n        emit OperatorAdded(newOperator, true);\n        operators[newOperator] = true;\n        operatorsGroup.push(newOperator);\n    }\n\n    function removeOperator (address operator) public onlyAdmin {\n        require(operators[operator], \"operator not configured\");\n        operators[operator] = false;\n\n        for (uint i = 0; i < operatorsGroup.length; ++i) {\n            if (operatorsGroup[i] == operator) {\n                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];\n                operatorsGroup.length -= 1;\n                emit OperatorAdded(operator, false);\n                break;\n            }\n        }\n    }\n}\n\n// File: contracts/Withdrawable.sol\n\n/**\n * @title Contracts that should be able to recover tokens or ethers\n * @author Ilan Doron\n * @dev This allows to recover any tokens or Ethers received in a contract.\n * This will prevent any accidental loss of tokens.\n */\ncontract Withdrawable is PermissionGroups {\n\n    event TokenWithdraw(\n        ERC20 indexed token,\n        uint amount,\n        address indexed sendTo\n    );\n\n    /**\n     * @dev Withdraw all ERC20 compatible tokens\n     * @param token ERC20 The address of the token contract\n     */\n    function withdrawToken(ERC20 token, uint amount, address sendTo) external onlyAdmin {\n        require(token.transfer(sendTo, amount), \"Could not transfer tokens\");\n        emit TokenWithdraw(token, amount, sendTo);\n    }\n\n    event EtherWithdraw(\n        uint amount,\n        address indexed sendTo\n    );\n\n    /**\n     * @dev Withdraw Ethers\n     */\n    function withdrawEther(uint amount, address payable sendTo) external onlyAdmin {\n        sendTo.transfer(amount);\n        emit EtherWithdraw(amount, sendTo);\n    }\n}\n\n// File: @gnosis.pm/util-contracts/contracts/Proxy.sol\n\n/// @title Proxied - indicates that a contract will be proxied. Also defines storage requirements for Proxy.\n/// @author Alan Lu - <[email protected]>\ncontract Proxied {\n    address public masterCopy;\n}\n\n/// @title Proxy - Generic proxy contract allows to execute all transactions applying the code of a master contract.\n/// @author Stefan George - <[email protected]>\ncontract Proxy is Proxied {\n    /// @dev Constructor function sets address of master copy contract.\n    /// @param _masterCopy Master copy address.\n    constructor(address _masterCopy) public {\n        require(_masterCopy != address(0), \"The master copy is required\");\n        masterCopy = _masterCopy;\n    }\n\n    /// @dev Fallback function forwards all transactions and returns all received return data.\n    function() external payable {\n        address _masterCopy = masterCopy;\n        assembly {\n            calldatacopy(0, 0, calldatasize)\n            let success := delegatecall(not(0), _masterCopy, 0, calldatasize, 0, 0)\n            returndatacopy(0, 0, returndatasize)\n            switch success\n                case 0 {\n                    revert(0, returndatasize)\n                }\n                default {\n                    return(0, returndatasize)\n                }\n        }\n    }\n}\n\n// File: @gnosis.pm/util-contracts/contracts/Token.sol\n\n/// Implements ERC 20 Token standard: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\npragma solidity ^0.5.2;\n\n/// @title Abstract token contract - Functions to be implemented by token contracts\ncontract Token {\n    /*\n     *  Events\n     */\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n\n    /*\n     *  Public functions\n     */\n    function transfer(address to, uint value) public returns (bool);\n    function transferFrom(address from, address to, uint value) public returns (bool);\n    function approve(address spender, uint value) public returns (bool);\n    function balanceOf(address owner) public view returns (uint);\n    function allowance(address owner, address spender) public view returns (uint);\n    function totalSupply() public view returns (uint);\n}\n\n// File: @gnosis.pm/util-contracts/contracts/Math.sol\n\n/// @title Math library - Allows calculation of logarithmic and exponential functions\n/// @author Alan Lu - <[email protected]>\n/// @author Stefan George - <[email protected]>\nlibrary GnosisMath {\n    /*\n     *  Constants\n     */\n    // This is equal to 1 in our calculations\n    uint public constant ONE = 0x10000000000000000;\n    uint public constant LN2 = 0xb17217f7d1cf79ac;\n    uint public constant LOG2_E = 0x171547652b82fe177;\n\n    /*\n     *  Public functions\n     */\n    /// @dev Returns natural exponential function value of given x\n    /// @param x x\n    /// @return e**x\n    function exp(int x) public pure returns (uint) {\n        // revert if x is > MAX_POWER, where\n        // MAX_POWER = int(mp.floor(mp.log(mpf(2**256 - 1) / ONE) * ONE))\n        require(x <= 2454971259878909886679);\n        // return 0 if exp(x) is tiny, using\n        // MIN_POWER = int(mp.floor(mp.log(mpf(1) / ONE) * ONE))\n        if (x < -818323753292969962227) return 0;\n        // Transform so that e^x -> 2^x\n        x = x * int(ONE) / int(LN2);\n        // 2^x = 2^whole(x) * 2^frac(x)\n        //       ^^^^^^^^^^ is a bit shift\n        // so Taylor expand on z = frac(x)\n        int shift;\n        uint z;\n        if (x >= 0) {\n            shift = x / int(ONE);\n            z = uint(x % int(ONE));\n        } else {\n            shift = x / int(ONE) - 1;\n            z = ONE - uint(-x % int(ONE));\n        }\n        // 2^x = 1 + (ln 2) x + (ln 2)^2/2! x^2 + ...\n        //\n        // Can generate the z coefficients using mpmath and the following lines\n        // >>> from mpmath import mp\n        // >>> mp.dps = 100\n        // >>> ONE =  0x10000000000000000\n        // >>> print('\\n'.join(hex(int(mp.log(2)**i / mp.factorial(i) * ONE)) for i in range(1, 7)))\n        // 0xb17217f7d1cf79ab\n        // 0x3d7f7bff058b1d50\n        // 0xe35846b82505fc5\n        // 0x276556df749cee5\n        // 0x5761ff9e299cc4\n        // 0xa184897c363c3\n        uint zpow = z;\n        uint result = ONE;\n        result += 0xb17217f7d1cf79ab * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0x3d7f7bff058b1d50 * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0xe35846b82505fc5 * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0x276556df749cee5 * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0x5761ff9e299cc4 * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0xa184897c363c3 * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0xffe5fe2c4586 * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0x162c0223a5c8 * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0x1b5253d395e * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0x1e4cf5158b * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0x1e8cac735 * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0x1c3bd650 * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0x1816193 * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0x131496 * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0xe1b7 * zpow / ONE;\n        zpow = zpow * z / ONE;\n        result += 0x9c7 * zpow / ONE;\n        if (shift >= 0) {\n            if (result >> (256 - shift) > 0) return (2 ** 256 - 1);\n            return result << shift;\n        } else return result >> (-shift);\n    }\n\n    /// @dev Returns natural logarithm value of given x\n    /// @param x x\n    /// @return ln(x)\n    function ln(uint x) public pure returns (int) {\n        require(x > 0);\n        // binary search for floor(log2(x))\n        int ilog2 = floorLog2(x);\n        int z;\n        if (ilog2 < 0) z = int(x << uint(-ilog2));\n        else z = int(x >> uint(ilog2));\n        // z = x * 2^-⌊log₂x⌋\n        // so 1 <= z < 2\n        // and ln z = ln x - ⌊log₂x⌋/log₂e\n        // so just compute ln z using artanh series\n        // and calculate ln x from that\n        int term = (z - int(ONE)) * int(ONE) / (z + int(ONE));\n        int halflnz = term;\n        int termpow = term * term / int(ONE) * term / int(ONE);\n        halflnz += termpow / 3;\n        termpow = termpow * term / int(ONE) * term / int(ONE);\n        halflnz += termpow / 5;\n        termpow = termpow * term / int(ONE) * term / int(ONE);\n        halflnz += termpow / 7;\n        termpow = termpow * term / int(ONE) * term / int(ONE);\n        halflnz += termpow / 9;\n        termpow = termpow * term / int(ONE) * term / int(ONE);\n        halflnz += termpow / 11;\n        termpow = termpow * term / int(ONE) * term / int(ONE);\n        halflnz += termpow / 13;\n        termpow = termpow * term / int(ONE) * term / int(ONE);\n        halflnz += termpow / 15;\n        termpow = termpow * term / int(ONE) * term / int(ONE);\n        halflnz += termpow / 17;\n        termpow = termpow * term / int(ONE) * term / int(ONE);\n        halflnz += termpow / 19;\n        termpow = termpow * term / int(ONE) * term / int(ONE);\n        halflnz += termpow / 21;\n        termpow = termpow * term / int(ONE) * term / int(ONE);\n        halflnz += termpow / 23;\n        termpow = termpow * term / int(ONE) * term / int(ONE);\n        halflnz += termpow / 25;\n        return (ilog2 * int(ONE)) * int(ONE) / int(LOG2_E) + 2 * halflnz;\n    }\n\n    /// @dev Returns base 2 logarithm value of given x\n    /// @param x x\n    /// @return logarithmic value\n    function floorLog2(uint x) public pure returns (int lo) {\n        lo = -64;\n        int hi = 193;\n        // I use a shift here instead of / 2 because it floors instead of rounding towards 0\n        int mid = (hi + lo) >> 1;\n        while ((lo + 1) < hi) {\n            if (mid < 0 && x << uint(-mid) < ONE || mid >= 0 && x >> uint(mid) < ONE) hi = mid;\n            else lo = mid;\n            mid = (hi + lo) >> 1;\n        }\n    }\n\n    /// @dev Returns maximum of an array\n    /// @param nums Numbers to look through\n    /// @return Maximum number\n    function max(int[] memory nums) public pure returns (int maxNum) {\n        require(nums.length > 0);\n        maxNum = -2 ** 255;\n        for (uint i = 0; i < nums.length; i++) if (nums[i] > maxNum) maxNum = nums[i];\n    }\n\n    /// @dev Returns whether an add operation causes an overflow\n    /// @param a First addend\n    /// @param b Second addend\n    /// @return Did no overflow occur?\n    function safeToAdd(uint a, uint b) internal pure returns (bool) {\n        return a + b >= a;\n    }\n\n    /// @dev Returns whether a subtraction operation causes an underflow\n    /// @param a Minuend\n    /// @param b Subtrahend\n    /// @return Did no underflow occur?\n    function safeToSub(uint a, uint b) internal pure returns (bool) {\n        return a >= b;\n    }\n\n    /// @dev Returns whether a multiply operation causes an overflow\n    /// @param a First factor\n    /// @param b Second factor\n    /// @return Did no overflow occur?\n    function safeToMul(uint a, uint b) internal pure returns (bool) {\n        return b == 0 || a * b / b == a;\n    }\n\n    /// @dev Returns sum if no overflow occurred\n    /// @param a First addend\n    /// @param b Second addend\n    /// @return Sum\n    function add(uint a, uint b) internal pure returns (uint) {\n        require(safeToAdd(a, b));\n        return a + b;\n    }\n\n    /// @dev Returns difference if no overflow occurred\n    /// @param a Minuend\n    /// @param b Subtrahend\n    /// @return Difference\n    function sub(uint a, uint b) internal pure returns (uint) {\n        require(safeToSub(a, b));\n        return a - b;\n    }\n\n    /// @dev Returns product if no overflow occurred\n    /// @param a First factor\n    /// @param b Second factor\n    /// @return Product\n    function mul(uint a, uint b) internal pure returns (uint) {\n        require(safeToMul(a, b));\n        return a * b;\n    }\n\n    /// @dev Returns whether an add operation causes an overflow\n    /// @param a First addend\n    /// @param b Second addend\n    /// @return Did no overflow occur?\n    function safeToAdd(int a, int b) internal pure returns (bool) {\n        return (b >= 0 && a + b >= a) || (b < 0 && a + b < a);\n    }\n\n    /// @dev Returns whether a subtraction operation causes an underflow\n    /// @param a Minuend\n    /// @param b Subtrahend\n    /// @return Did no underflow occur?\n    function safeToSub(int a, int b) internal pure returns (bool) {\n        return (b >= 0 && a - b <= a) || (b < 0 && a - b > a);\n    }\n\n    /// @dev Returns whether a multiply operation causes an overflow\n    /// @param a First factor\n    /// @param b Second factor\n    /// @return Did no overflow occur?\n    function safeToMul(int a, int b) internal pure returns (bool) {\n        return (b == 0) || (a * b / b == a);\n    }\n\n    /// @dev Returns sum if no overflow occurred\n    /// @param a First addend\n    /// @param b Second addend\n    /// @return Sum\n    function add(int a, int b) internal pure returns (int) {\n        require(safeToAdd(a, b));\n        return a + b;\n    }\n\n    /// @dev Returns difference if no overflow occurred\n    /// @param a Minuend\n    /// @param b Subtrahend\n    /// @return Difference\n    function sub(int a, int b) internal pure returns (int) {\n        require(safeToSub(a, b));\n        return a - b;\n    }\n\n    /// @dev Returns product if no overflow occurred\n    /// @param a First factor\n    /// @param b Second factor\n    /// @return Product\n    function mul(int a, int b) internal pure returns (int) {\n        require(safeToMul(a, b));\n        return a * b;\n    }\n}\n\n// File: @gnosis.pm/util-contracts/contracts/GnosisStandardToken.sol\n\n/**\n * Deprecated: Use Open Zeppeling one instead\n */\ncontract StandardTokenData {\n    /*\n     *  Storage\n     */\n    mapping(address => uint) balances;\n    mapping(address => mapping(address => uint)) allowances;\n    uint totalTokens;\n}\n\n/**\n * Deprecated: Use Open Zeppeling one instead\n */\n/// @title Standard token contract with overflow protection\ncontract GnosisStandardToken is Token, StandardTokenData {\n    using GnosisMath for *;\n\n    /*\n     *  Public functions\n     */\n    /// @dev Transfers sender's tokens to a given address. Returns success\n    /// @param to Address of token receiver\n    /// @param value Number of tokens to transfer\n    /// @return Was transfer successful?\n    function transfer(address to, uint value) public returns (bool) {\n        if (!balances[msg.sender].safeToSub(value) || !balances[to].safeToAdd(value)) {\n            return false;\n        }\n\n        balances[msg.sender] -= value;\n        balances[to] += value;\n        emit Transfer(msg.sender, to, value);\n        return true;\n    }\n\n    /// @dev Allows allowed third party to transfer tokens from one address to another. Returns success\n    /// @param from Address from where tokens are withdrawn\n    /// @param to Address to where tokens are sent\n    /// @param value Number of tokens to transfer\n    /// @return Was transfer successful?\n    function transferFrom(address from, address to, uint value) public returns (bool) {\n        if (!balances[from].safeToSub(value) || !allowances[from][msg.sender].safeToSub(\n            value\n        ) || !balances[to].safeToAdd(value)) {\n            return false;\n        }\n        balances[from] -= value;\n        allowances[from][msg.sender] -= value;\n        balances[to] += value;\n        emit Transfer(from, to, value);\n        return true;\n    }\n\n    /// @dev Sets approved amount of tokens for spender. Returns success\n    /// @param spender Address of allowed account\n    /// @param value Number of approved tokens\n    /// @return Was approval successful?\n    function approve(address spender, uint value) public returns (bool) {\n        allowances[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /// @dev Returns number of allowed tokens for given address\n    /// @param owner Address of token owner\n    /// @param spender Address of token spender\n    /// @return Remaining allowance for spender\n    function allowance(address owner, address spender) public view returns (uint) {\n        return allowances[owner][spender];\n    }\n\n    /// @dev Returns number of tokens owned by given address\n    /// @param owner Address of token owner\n    /// @return Balance of owner\n    function balanceOf(address owner) public view returns (uint) {\n        return balances[owner];\n    }\n\n    /// @dev Returns total supply of tokens\n    /// @return Total supply\n    function totalSupply() public view returns (uint) {\n        return totalTokens;\n    }\n}\n\n// File: @gnosis.pm/dx-contracts/contracts/TokenFRT.sol\n\n/// @title Standard token contract with overflow protection\ncontract TokenFRT is Proxied, GnosisStandardToken {\n    address public owner;\n\n    string public constant symbol = \"MGN\";\n    string public constant name = \"Magnolia Token\";\n    uint8 public constant decimals = 18;\n\n    struct UnlockedToken {\n        uint amountUnlocked;\n        uint withdrawalTime;\n    }\n\n    /*\n     *  Storage\n     */\n    address public minter;\n\n    // user => UnlockedToken\n    mapping(address => UnlockedToken) public unlockedTokens;\n\n    // user => amount\n    mapping(address => uint) public lockedTokenBalances;\n\n    /*\n     *  Public functions\n     */\n\n    // @dev allows to set the minter of Magnolia tokens once.\n    // @param   _minter the minter of the Magnolia tokens, should be the DX-proxy\n    function updateMinter(address _minter) public {\n        require(msg.sender == owner, \"Only the minter can set a new one\");\n        require(_minter != address(0), \"The new minter must be a valid address\");\n\n        minter = _minter;\n    }\n\n    // @dev the intention is to set the owner as the DX-proxy, once it is deployed\n    // Then only an update of the DX-proxy contract after a 30 days delay could change the minter again.\n    function updateOwner(address _owner) public {\n        require(msg.sender == owner, \"Only the owner can update the owner\");\n        require(_owner != address(0), \"The new owner must be a valid address\");\n        owner = _owner;\n    }\n\n    function mintTokens(address user, uint amount) public {\n        require(msg.sender == minter, \"Only the minter can mint tokens\");\n\n        lockedTokenBalances[user] = add(lockedTokenBalances[user], amount);\n        totalTokens = add(totalTokens, amount);\n    }\n\n    /// @dev Lock Token\n    function lockTokens(uint amount) public returns (uint totalAmountLocked) {\n        // Adjust amount by balance\n        uint actualAmount = min(amount, balances[msg.sender]);\n\n        // Update state variables\n        balances[msg.sender] = sub(balances[msg.sender], actualAmount);\n        lockedTokenBalances[msg.sender] = add(lockedTokenBalances[msg.sender], actualAmount);\n\n        // Get return variable\n        totalAmountLocked = lockedTokenBalances[msg.sender];\n    }\n\n    function unlockTokens() public returns (uint totalAmountUnlocked, uint withdrawalTime) {\n        // Adjust amount by locked balances\n        uint amount = lockedTokenBalances[msg.sender];\n\n        if (amount > 0) {\n            // Update state variables\n            lockedTokenBalances[msg.sender] = sub(lockedTokenBalances[msg.sender], amount);\n            unlockedTokens[msg.sender].amountUnlocked = add(unlockedTokens[msg.sender].amountUnlocked, amount);\n            unlockedTokens[msg.sender].withdrawalTime = now + 24 hours;\n        }\n\n        // Get return variables\n        totalAmountUnlocked = unlockedTokens[msg.sender].amountUnlocked;\n        withdrawalTime = unlockedTokens[msg.sender].withdrawalTime;\n    }\n\n    function withdrawUnlockedTokens() public {\n        require(unlockedTokens[msg.sender].withdrawalTime < now, \"The tokens cannot be withdrawn yet\");\n        balances[msg.sender] = add(balances[msg.sender], unlockedTokens[msg.sender].amountUnlocked);\n        unlockedTokens[msg.sender].amountUnlocked = 0;\n    }\n\n    function min(uint a, uint b) public pure returns (uint) {\n        if (a < b) {\n            return a;\n        } else {\n            return b;\n        }\n    }\n    \n    /// @dev Returns whether an add operation causes an overflow\n    /// @param a First addend\n    /// @param b Second addend\n    /// @return Did no overflow occur?\n    function safeToAdd(uint a, uint b) public pure returns (bool) {\n        return a + b >= a;\n    }\n\n    /// @dev Returns whether a subtraction operation causes an underflow\n    /// @param a Minuend\n    /// @param b Subtrahend\n    /// @return Did no underflow occur?\n    function safeToSub(uint a, uint b) public pure returns (bool) {\n        return a >= b;\n    }\n\n    /// @dev Returns sum if no overflow occurred\n    /// @param a First addend\n    /// @param b Second addend\n    /// @return Sum\n    function add(uint a, uint b) public pure returns (uint) {\n        require(safeToAdd(a, b), \"It must be a safe adition\");\n        return a + b;\n    }\n\n    /// @dev Returns difference if no overflow occurred\n    /// @param a Minuend\n    /// @param b Subtrahend\n    /// @return Difference\n    function sub(uint a, uint b) public pure returns (uint) {\n        require(safeToSub(a, b), \"It must be a safe substraction\");\n        return a - b;\n    }\n}\n\n// File: @gnosis.pm/owl-token/contracts/TokenOWL.sol\n\ncontract TokenOWL is Proxied, GnosisStandardToken {\n    using GnosisMath for *;\n\n    string public constant name = \"OWL Token\";\n    string public constant symbol = \"OWL\";\n    uint8 public constant decimals = 18;\n\n    struct masterCopyCountdownType {\n        address masterCopy;\n        uint timeWhenAvailable;\n    }\n\n    masterCopyCountdownType masterCopyCountdown;\n\n    address public creator;\n    address public minter;\n\n    event Minted(address indexed to, uint256 amount);\n    event Burnt(address indexed from, address indexed user, uint256 amount);\n\n    modifier onlyCreator() {\n        // R1\n        require(msg.sender == creator, \"Only the creator can perform the transaction\");\n        _;\n    }\n    /// @dev trickers the update process via the proxyMaster for a new address _masterCopy\n    /// updating is only possible after 30 days\n    function startMasterCopyCountdown(address _masterCopy) public onlyCreator {\n        require(address(_masterCopy) != address(0), \"The master copy must be a valid address\");\n\n        // Update masterCopyCountdown\n        masterCopyCountdown.masterCopy = _masterCopy;\n        masterCopyCountdown.timeWhenAvailable = now + 30 days;\n    }\n\n    /// @dev executes the update process via the proxyMaster for a new address _masterCopy\n    function updateMasterCopy() public onlyCreator {\n        require(address(masterCopyCountdown.masterCopy) != address(0), \"The master copy must be a valid address\");\n        require(\n            block.timestamp >= masterCopyCountdown.timeWhenAvailable,\n            \"It's not possible to update the master copy during the waiting period\"\n        );\n\n        // Update masterCopy\n        masterCopy = masterCopyCountdown.masterCopy;\n    }\n\n    function getMasterCopy() public view returns (address) {\n        return masterCopy;\n    }\n\n    /// @dev Set minter. Only the creator of this contract can call this.\n    /// @param newMinter The new address authorized to mint this token\n    function setMinter(address newMinter) public onlyCreator {\n        minter = newMinter;\n    }\n\n    /// @dev change owner/creator of the contract. Only the creator/owner of this contract can call this.\n    /// @param newOwner The new address, which should become the owner\n    function setNewOwner(address newOwner) public onlyCreator {\n        creator = newOwner;\n    }\n\n    /// @dev Mints OWL.\n    /// @param to Address to which the minted token will be given\n    /// @param amount Amount of OWL to be minted\n    function mintOWL(address to, uint amount) public {\n        require(minter != address(0), \"The minter must be initialized\");\n        require(msg.sender == minter, \"Only the minter can mint OWL\");\n        balances[to] = balances[to].add(amount);\n        totalTokens = totalTokens.add(amount);\n        emit Minted(to, amount);\n    }\n\n    /// @dev Burns OWL.\n    /// @param user Address of OWL owner\n    /// @param amount Amount of OWL to be burnt\n    function burnOWL(address user, uint amount) public {\n        allowances[user][msg.sender] = allowances[user][msg.sender].sub(amount);\n        balances[user] = balances[user].sub(amount);\n        totalTokens = totalTokens.sub(amount);\n        emit Burnt(msg.sender, user, amount);\n    }\n}\n\n// File: @gnosis.pm/dx-contracts/contracts/base/SafeTransfer.sol\n\ninterface BadToken {\n    function transfer(address to, uint value) external;\n    function transferFrom(address from, address to, uint value) external;\n}\n\ncontract SafeTransfer {\n    function safeTransfer(address token, address to, uint value, bool from) internal returns (bool result) {\n        if (from) {\n            BadToken(token).transferFrom(msg.sender, address(this), value);\n        } else {\n            BadToken(token).transfer(to, value);\n        }\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            switch returndatasize\n                case 0 {\n                    // This is our BadToken\n                    result := not(0) // result is true\n                }\n                case 32 {\n                    // This is our GoodToken\n                    returndatacopy(0, 0, 32)\n                    result := mload(0) // result == returndata of external call\n                }\n                default {\n                    // This is not an ERC20 token\n                    result := 0\n                }\n        }\n        return result;\n    }\n}\n\n// File: @gnosis.pm/dx-contracts/contracts/base/AuctioneerManaged.sol\n\ncontract AuctioneerManaged {\n    // auctioneer has the power to manage some variables\n    address public auctioneer;\n\n    function updateAuctioneer(address _auctioneer) public onlyAuctioneer {\n        require(_auctioneer != address(0), \"The auctioneer must be a valid address\");\n        auctioneer = _auctioneer;\n    }\n\n    // > Modifiers\n    modifier onlyAuctioneer() {\n        // Only allows auctioneer to proceed\n        // R1\n        // require(msg.sender == auctioneer, \"Only auctioneer can perform this operation\");\n        require(msg.sender == auctioneer, \"Only the auctioneer can nominate a new one\");\n        _;\n    }\n}\n\n// File: @gnosis.pm/dx-contracts/contracts/base/TokenWhitelist.sol\n\ncontract TokenWhitelist is AuctioneerManaged {\n    // Mapping that stores the tokens, which are approved\n    // Only tokens approved by auctioneer generate frtToken tokens\n    // addressToken => boolApproved\n    mapping(address => bool) public approvedTokens;\n\n    event Approval(address indexed token, bool approved);\n\n    /// @dev for quick overview of approved Tokens\n    /// @param addressesToCheck are the ERC-20 token addresses to be checked whether they are approved\n    function getApprovedAddressesOfList(address[] calldata addressesToCheck) external view returns (bool[] memory) {\n        uint length = addressesToCheck.length;\n\n        bool[] memory isApproved = new bool[](length);\n\n        for (uint i = 0; i < length; i++) {\n            isApproved[i] = approvedTokens[addressesToCheck[i]];\n        }\n\n        return isApproved;\n    }\n    \n    function updateApprovalOfToken(address[] memory token, bool approved) public onlyAuctioneer {\n        for (uint i = 0; i < token.length; i++) {\n            approvedTokens[token[i]] = approved;\n            emit Approval(token[i], approved);\n        }\n    }\n\n}\n\n// File: @gnosis.pm/dx-contracts/contracts/base/DxMath.sol\n\ncontract DxMath {\n    // > Math fns\n    function min(uint a, uint b) public pure returns (uint) {\n        if (a < b) {\n            return a;\n        } else {\n            return b;\n        }\n    }\n\n    function atleastZero(int a) public pure returns (uint) {\n        if (a < 0) {\n            return 0;\n        } else {\n            return uint(a);\n        }\n    }\n    \n    /// @dev Returns whether an add operation causes an overflow\n    /// @param a First addend\n    /// @param b Second addend\n    /// @return Did no overflow occur?\n    function safeToAdd(uint a, uint b) public pure returns (bool) {\n        return a + b >= a;\n    }\n\n    /// @dev Returns whether a subtraction operation causes an underflow\n    /// @param a Minuend\n    /// @param b Subtrahend\n    /// @return Did no underflow occur?\n    function safeToSub(uint a, uint b) public pure returns (bool) {\n        return a >= b;\n    }\n\n    /// @dev Returns whether a multiply operation causes an overflow\n    /// @param a First factor\n    /// @param b Second factor\n    /// @return Did no overflow occur?\n    function safeToMul(uint a, uint b) public pure returns (bool) {\n        return b == 0 || a * b / b == a;\n    }\n\n    /// @dev Returns sum if no overflow occurred\n    /// @param a First addend\n    /// @param b Second addend\n    /// @return Sum\n    function add(uint a, uint b) public pure returns (uint) {\n        require(safeToAdd(a, b));\n        return a + b;\n    }\n\n    /// @dev Returns difference if no overflow occurred\n    /// @param a Minuend\n    /// @param b Subtrahend\n    /// @return Difference\n    function sub(uint a, uint b) public pure returns (uint) {\n        require(safeToSub(a, b));\n        return a - b;\n    }\n\n    /// @dev Returns product if no overflow occurred\n    /// @param a First factor\n    /// @param b Second factor\n    /// @return Product\n    function mul(uint a, uint b) public pure returns (uint) {\n        require(safeToMul(a, b));\n        return a * b;\n    }\n}\n\n// File: @gnosis.pm/dx-contracts/contracts/Oracle/DSMath.sol\n\ncontract DSMath {\n    /*\n    standard uint256 functions\n     */\n\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assert((z = x + y) >= x);\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assert((z = x - y) <= x);\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assert((z = x * y) >= x);\n    }\n\n    function div(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x / y;\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x <= y ? x : y;\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x >= y ? x : y;\n    }\n\n    /*\n    uint128 functions (h is for half)\n     */\n\n    function hadd(uint128 x, uint128 y) internal pure returns (uint128 z) {\n        assert((z = x + y) >= x);\n    }\n\n    function hsub(uint128 x, uint128 y) internal pure returns (uint128 z) {\n        assert((z = x - y) <= x);\n    }\n\n    function hmul(uint128 x, uint128 y) internal pure returns (uint128 z) {\n        assert((z = x * y) >= x);\n    }\n\n    function hdiv(uint128 x, uint128 y) internal pure returns (uint128 z) {\n        z = x / y;\n    }\n\n    function hmin(uint128 x, uint128 y) internal pure returns (uint128 z) {\n        return x <= y ? x : y;\n    }\n\n    function hmax(uint128 x, uint128 y) internal pure returns (uint128 z) {\n        return x >= y ? x : y;\n    }\n\n    /*\n    int256 functions\n     */\n\n    function imin(int256 x, int256 y) internal pure returns (int256 z) {\n        return x <= y ? x : y;\n    }\n\n    function imax(int256 x, int256 y) internal pure returns (int256 z) {\n        return x >= y ? x : y;\n    }\n\n    /*\n    WAD math\n     */\n\n    uint128 constant WAD = 10 ** 18;\n\n    function wadd(uint128 x, uint128 y) internal pure returns (uint128) {\n        return hadd(x, y);\n    }\n\n    function wsub(uint128 x, uint128 y) internal pure returns (uint128) {\n        return hsub(x, y);\n    }\n\n    function wmul(uint128 x, uint128 y) internal pure returns (uint128 z) {\n        z = cast((uint256(x) * y + WAD / 2) / WAD);\n    }\n\n    function wdiv(uint128 x, uint128 y) internal pure returns (uint128 z) {\n        z = cast((uint256(x) * WAD + y / 2) / y);\n    }\n\n    function wmin(uint128 x, uint128 y) internal pure returns (uint128) {\n        return hmin(x, y);\n    }\n\n    function wmax(uint128 x, uint128 y) internal pure returns (uint128) {\n        return hmax(x, y);\n    }\n\n    /*\n    RAY math\n     */\n\n    uint128 constant RAY = 10 ** 27;\n\n    function radd(uint128 x, uint128 y) internal pure returns (uint128) {\n        return hadd(x, y);\n    }\n\n    function rsub(uint128 x, uint128 y) internal pure returns (uint128) {\n        return hsub(x, y);\n    }\n\n    function rmul(uint128 x, uint128 y) internal pure returns (uint128 z) {\n        z = cast((uint256(x) * y + RAY / 2) / RAY);\n    }\n\n    function rdiv(uint128 x, uint128 y) internal pure returns (uint128 z) {\n        z = cast((uint256(x) * RAY + y / 2) / y);\n    }\n\n    function rpow(uint128 x, uint64 n) internal pure returns (uint128 z) {\n        // This famous algorithm is called \"exponentiation by squaring\"\n        // and calculates x^n with x as fixed-point and n as regular unsigned.\n        //\n        // It's O(log n), instead of O(n) for naive repeated multiplication.\n        //\n        // These facts are why it works:\n        //\n        //  If n is even, then x^n = (x^2)^(n/2).\n        //  If n is odd,  then x^n = x * x^(n-1),\n        //   and applying the equation for even x gives\n        //    x^n = x * (x^2)^((n-1) / 2).\n        //\n        //  Also, EVM division is flooring and\n        //    floor[(n-1) / 2] = floor[n / 2].\n\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n\n    function rmin(uint128 x, uint128 y) internal pure returns (uint128) {\n        return hmin(x, y);\n    }\n\n    function rmax(uint128 x, uint128 y) internal pure returns (uint128) {\n        return hmax(x, y);\n    }\n\n    function cast(uint256 x) internal pure returns (uint128 z) {\n        assert((z = uint128(x)) == x);\n    }\n\n}\n\n// File: @gnosis.pm/dx-contracts/contracts/Oracle/DSAuth.sol\n\ncontract DSAuthority {\n    function canCall(address src, address dst, bytes4 sig) public view returns (bool);\n}\n\n\ncontract DSAuthEvents {\n    event LogSetAuthority(address indexed authority);\n    event LogSetOwner(address indexed owner);\n}\n\n\ncontract DSAuth is DSAuthEvents {\n    DSAuthority public authority;\n    address public owner;\n\n    constructor() public {\n        owner = msg.sender;\n        emit LogSetOwner(msg.sender);\n    }\n\n    function setOwner(address owner_) public auth {\n        owner = owner_;\n        emit LogSetOwner(owner);\n    }\n\n    function setAuthority(DSAuthority authority_) public auth {\n        authority = authority_;\n        emit LogSetAuthority(address(authority));\n    }\n\n    modifier auth {\n        require(isAuthorized(msg.sender, msg.sig), \"It must be an authorized call\");\n        _;\n    }\n\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else if (authority == DSAuthority(0)) {\n            return false;\n        } else {\n            return authority.canCall(src, address(this), sig);\n        }\n    }\n}\n\n// File: @gnosis.pm/dx-contracts/contracts/Oracle/DSNote.sol\n\ncontract DSNote {\n    event LogNote(\n        bytes4 indexed sig,\n        address indexed guy,\n        bytes32 indexed foo,\n        bytes32 bar,\n        uint wad,\n        bytes fax\n    );\n\n    modifier note {\n        bytes32 foo;\n        bytes32 bar;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            foo := calldataload(4)\n            bar := calldataload(36)\n        }\n\n        emit LogNote(\n            msg.sig,\n            msg.sender,\n            foo,\n            bar,\n            msg.value,\n            msg.data\n        );\n\n        _;\n    }\n}\n\n// File: @gnosis.pm/dx-contracts/contracts/Oracle/DSThing.sol\n\ncontract DSThing is DSAuth, DSNote, DSMath {}\n\n// File: @gnosis.pm/dx-contracts/contracts/Oracle/PriceFeed.sol\n\n/// price-feed.sol\n\n// Copyright (C) 2017  DappHub, LLC\n\n// Licensed under the Apache License, Version 2.0 (the \"License\").\n// You may not use this file except in compliance with the License.\n\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND (express or implied).\n\n\n\ncontract PriceFeed is DSThing {\n    uint128 val;\n    uint32 public zzz;\n\n    function peek() public view returns (bytes32, bool) {\n        return (bytes32(uint256(val)), block.timestamp < zzz);\n    }\n\n    function read() public view returns (bytes32) {\n        assert(block.timestamp < zzz);\n        return bytes32(uint256(val));\n    }\n\n    function post(uint128 val_, uint32 zzz_, address med_) public payable note auth {\n        val = val_;\n        zzz = zzz_;\n        (bool success, ) = med_.call(abi.encodeWithSignature(\"poke()\"));\n        require(success, \"The poke must succeed\");\n    }\n\n    function void() public payable note auth {\n        zzz = 0;\n    }\n\n}\n\n// File: @gnosis.pm/dx-contracts/contracts/Oracle/DSValue.sol\n\ncontract DSValue is DSThing {\n    bool has;\n    bytes32 val;\n    function peek() public view returns (bytes32, bool) {\n        return (val, has);\n    }\n\n    function read() public view returns (bytes32) {\n        (bytes32 wut, bool _has) = peek();\n        assert(_has);\n        return wut;\n    }\n\n    function poke(bytes32 wut) public payable note auth {\n        val = wut;\n        has = true;\n    }\n\n    function void() public payable note auth {\n        // unset the value\n        has = false;\n    }\n}\n\n// File: @gnosis.pm/dx-contracts/contracts/Oracle/Medianizer.sol\n\ncontract Medianizer is DSValue {\n    mapping(bytes12 => address) public values;\n    mapping(address => bytes12) public indexes;\n    bytes12 public next = bytes12(uint96(1));\n    uint96 public minimun = 0x1;\n\n    function set(address wat) public auth {\n        bytes12 nextId = bytes12(uint96(next) + 1);\n        assert(nextId != 0x0);\n        set(next, wat);\n        next = nextId;\n    }\n\n    function set(bytes12 pos, address wat) public payable note auth {\n        require(pos != 0x0, \"pos cannot be 0x0\");\n        require(wat == address(0) || indexes[wat] == 0, \"wat is not defined or it has an index\");\n\n        indexes[values[pos]] = bytes12(0); // Making sure to remove a possible existing address in that position\n\n        if (wat != address(0)) {\n            indexes[wat] = pos;\n        }\n\n        values[pos] = wat;\n    }\n\n    function setMin(uint96 min_) public payable note auth {\n        require(min_ != 0x0, \"min cannot be 0x0\");\n        minimun = min_;\n    }\n\n    function setNext(bytes12 next_) public payable note auth {\n        require(next_ != 0x0, \"next cannot be 0x0\");\n        next = next_;\n    }\n\n    function unset(bytes12 pos) public {\n        set(pos, address(0));\n    }\n\n    function unset(address wat) public {\n        set(indexes[wat], address(0));\n    }\n\n    function poke() public {\n        poke(0);\n    }\n\n    function poke(bytes32) public payable note {\n        (val, has) = compute();\n    }\n\n    function compute() public view returns (bytes32, bool) {\n        bytes32[] memory wuts = new bytes32[](uint96(next) - 1);\n        uint96 ctr = 0;\n        for (uint96 i = 1; i < uint96(next); i++) {\n            if (values[bytes12(i)] != address(0)) {\n                (bytes32 wut, bool wuz) = DSValue(values[bytes12(i)]).peek();\n                if (wuz) {\n                    if (ctr == 0 || wut >= wuts[ctr - 1]) {\n                        wuts[ctr] = wut;\n                    } else {\n                        uint96 j = 0;\n                        while (wut >= wuts[j]) {\n                            j++;\n                        }\n                        for (uint96 k = ctr; k > j; k--) {\n                            wuts[k] = wuts[k - 1];\n                        }\n                        wuts[j] = wut;\n                    }\n                    ctr++;\n                }\n            }\n        }\n\n        if (ctr < minimun)\n            return (val, false);\n\n        bytes32 value;\n        if (ctr % 2 == 0) {\n            uint128 val1 = uint128(uint(wuts[(ctr / 2) - 1]));\n            uint128 val2 = uint128(uint(wuts[ctr / 2]));\n            value = bytes32(uint256(wdiv(hadd(val1, val2), 2 ether)));\n        } else {\n            value = wuts[(ctr - 1) / 2];\n        }\n\n        return (value, true);\n    }\n}\n\n// File: @gnosis.pm/dx-contracts/contracts/Oracle/PriceOracleInterface.sol\n\n/*\nThis contract is the interface between the MakerDAO priceFeed and our DX platform.\n*/\n\n\n\n\ncontract PriceOracleInterface {\n    address public priceFeedSource;\n    address public owner;\n    bool public emergencyMode;\n\n    // Modifiers\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only the owner can do the operation\");\n        _;\n    }\n\n    /// @dev constructor of the contract\n    /// @param _priceFeedSource address of price Feed Source -> should be maker feeds Medianizer contract\n    constructor(address _owner, address _priceFeedSource) public {\n        owner = _owner;\n        priceFeedSource = _priceFeedSource;\n    }\n    \n    /// @dev gives the owner the possibility to put the Interface into an emergencyMode, which will\n    /// output always a price of 600 USD. This gives everyone time to set up a new pricefeed.\n    function raiseEmergency(bool _emergencyMode) public onlyOwner {\n        emergencyMode = _emergencyMode;\n    }\n\n    /// @dev updates the priceFeedSource\n    /// @param _owner address of owner\n    function updateCurator(address _owner) public onlyOwner {\n        owner = _owner;\n    }\n\n    /// @dev returns the USDETH price\n    function getUsdEthPricePeek() public view returns (bytes32 price, bool valid) {\n        return Medianizer(priceFeedSource).peek();\n    }\n\n    /// @dev returns the USDETH price, ie gets the USD price from Maker feed with 18 digits, but last 18 digits are cut off\n    function getUSDETHPrice() public view returns (uint256) {\n        // if the contract is in the emergencyMode, because there is an issue with the oracle, we will simply return a price of 600 USD\n        if (emergencyMode) {\n            return 600;\n        }\n        (bytes32 price, ) = Medianizer(priceFeedSource).peek();\n\n        // ensuring that there is no underflow or overflow possible,\n        // even if the price is compromised\n        uint priceUint = uint256(price)/(1 ether);\n        if (priceUint == 0) {\n            return 1;\n        }\n        if (priceUint > 1000000) {\n            return 1000000; \n        }\n        return priceUint;\n    }\n}\n\n// File: @gnosis.pm/dx-contracts/contracts/base/EthOracle.sol\n\ncontract EthOracle is AuctioneerManaged, DxMath {\n    uint constant WAITING_PERIOD_CHANGE_ORACLE = 30 days;\n\n    // Price Oracle interface\n    PriceOracleInterface public ethUSDOracle;\n    // Price Oracle interface proposals during update process\n    PriceOracleInterface public newProposalEthUSDOracle;\n\n    uint public oracleInterfaceCountdown;\n\n    event NewOracleProposal(PriceOracleInterface priceOracleInterface);\n\n    function initiateEthUsdOracleUpdate(PriceOracleInterface _ethUSDOracle) public onlyAuctioneer {\n        require(address(_ethUSDOracle) != address(0), \"The oracle address must be valid\");\n        newProposalEthUSDOracle = _ethUSDOracle;\n        oracleInterfaceCountdown = add(block.timestamp, WAITING_PERIOD_CHANGE_ORACLE);\n        emit NewOracleProposal(_ethUSDOracle);\n    }\n\n    function updateEthUSDOracle() public {\n        require(address(newProposalEthUSDOracle) != address(0), \"The new proposal must be a valid addres\");\n        require(\n            oracleInterfaceCountdown < block.timestamp,\n            \"It's not possible to update the oracle during the waiting period\"\n        );\n        ethUSDOracle = newProposalEthUSDOracle;\n        newProposalEthUSDOracle = PriceOracleInterface(0);\n    }\n}\n\n// File: @gnosis.pm/dx-contracts/contracts/base/DxUpgrade.sol\n\ncontract DxUpgrade is Proxied, AuctioneerManaged, DxMath {\n    uint constant WAITING_PERIOD_CHANGE_MASTERCOPY = 30 days;\n\n    address public newMasterCopy;\n    // Time when new masterCopy is updatabale\n    uint public masterCopyCountdown;\n\n    event NewMasterCopyProposal(address newMasterCopy);\n\n    function startMasterCopyCountdown(address _masterCopy) public onlyAuctioneer {\n        require(_masterCopy != address(0), \"The new master copy must be a valid address\");\n\n        // Update masterCopyCountdown\n        newMasterCopy = _masterCopy;\n        masterCopyCountdown = add(block.timestamp, WAITING_PERIOD_CHANGE_MASTERCOPY);\n        emit NewMasterCopyProposal(_masterCopy);\n    }\n\n    function updateMasterCopy() public {\n        require(newMasterCopy != address(0), \"The new master copy must be a valid address\");\n        require(block.timestamp >= masterCopyCountdown, \"The master contract cannot be updated in a waiting period\");\n\n        // Update masterCopy\n        masterCopy = newMasterCopy;\n        newMasterCopy = address(0);\n    }\n\n}\n\n// File: @gnosis.pm/dx-contracts/contracts/DutchExchange.sol\n\n/// @title Dutch Exchange - exchange token pairs with the clever mechanism of the dutch auction\n/// @author Alex Herrmann - <[email protected]>\n/// @author Dominik Teiml - <[email protected]>\n\ncontract DutchExchange is DxUpgrade, TokenWhitelist, EthOracle, SafeTransfer {\n\n    // The price is a rational number, so we need a concept of a fraction\n    struct Fraction {\n        uint num;\n        uint den;\n    }\n\n    uint constant WAITING_PERIOD_NEW_TOKEN_PAIR = 6 hours;\n    uint constant WAITING_PERIOD_NEW_AUCTION = 10 minutes;\n    uint constant AUCTION_START_WAITING_FOR_FUNDING = 1;\n\n    // > Storage\n    // Ether ERC-20 token\n    address public ethToken;\n\n    // Minimum required sell funding for adding a new token pair, in USD\n    uint public thresholdNewTokenPair;\n    // Minimum required sell funding for starting antoher auction, in USD\n    uint public thresholdNewAuction;\n    // Fee reduction token (magnolia, ERC-20 token)\n    TokenFRT public frtToken;\n    // Token for paying fees\n    TokenOWL public owlToken;\n\n    // For the following three mappings, there is one mapping for each token pair\n    // The order which the tokens should be called is smaller, larger\n    // These variables should never be called directly! They have getters below\n    // Token => Token => index\n    mapping(address => mapping(address => uint)) public latestAuctionIndices;\n    // Token => Token => time\n    mapping (address => mapping (address => uint)) public auctionStarts;\n    // Token => Token => auctionIndex => time\n    mapping (address => mapping (address => mapping (uint => uint))) public clearingTimes;\n\n    // Token => Token => auctionIndex => price\n    mapping(address => mapping(address => mapping(uint => Fraction))) public closingPrices;\n\n    // Token => Token => amount\n    mapping(address => mapping(address => uint)) public sellVolumesCurrent;\n    // Token => Token => amount\n    mapping(address => mapping(address => uint)) public sellVolumesNext;\n    // Token => Token => amount\n    mapping(address => mapping(address => uint)) public buyVolumes;\n\n    // Token => user => amount\n    // balances stores a user's balance in the DutchX\n    mapping(address => mapping(address => uint)) public balances;\n\n    // Token => Token => auctionIndex => amount\n    mapping(address => mapping(address => mapping(uint => uint))) public extraTokens;\n\n    // Token => Token =>  auctionIndex => user => amount\n    mapping(address => mapping(address => mapping(uint => mapping(address => uint)))) public sellerBalances;\n    mapping(address => mapping(address => mapping(uint => mapping(address => uint)))) public buyerBalances;\n    mapping(address => mapping(address => mapping(uint => mapping(address => uint)))) public claimedAmounts;\n\n    function depositAndSell(address sellToken, address buyToken, uint amount)\n        external\n        returns (uint newBal, uint auctionIndex, uint newSellerBal)\n    {\n        newBal = deposit(sellToken, amount);\n        (auctionIndex, newSellerBal) = postSellOrder(sellToken, buyToken, 0, amount);\n    }\n\n    function claimAndWithdraw(address sellToken, address buyToken, address user, uint auctionIndex, uint amount)\n        external\n        returns (uint returned, uint frtsIssued, uint newBal)\n    {\n        (returned, frtsIssued) = claimSellerFunds(sellToken, buyToken, user, auctionIndex);\n        newBal = withdraw(buyToken, amount);\n    }\n\n    /// @dev for multiple claims\n    /// @param auctionSellTokens are the sellTokens defining an auctionPair\n    /// @param auctionBuyTokens are the buyTokens defining an auctionPair\n    /// @param auctionIndices are the auction indices on which an token should be claimedAmounts\n    /// @param user is the user who wants to his tokens\n    function claimTokensFromSeveralAuctionsAsSeller(\n        address[] calldata auctionSellTokens,\n        address[] calldata auctionBuyTokens,\n        uint[] calldata auctionIndices,\n        address user\n    ) external returns (uint[] memory, uint[] memory)\n    {\n        uint length = checkLengthsForSeveralAuctionClaiming(auctionSellTokens, auctionBuyTokens, auctionIndices);\n\n        uint[] memory claimAmounts = new uint[](length);\n        uint[] memory frtsIssuedList = new uint[](length);\n\n        for (uint i = 0; i < length; i++) {\n            (claimAmounts[i], frtsIssuedList[i]) = claimSellerFunds(\n                auctionSellTokens[i],\n                auctionBuyTokens[i],\n                user,\n                auctionIndices[i]\n            );\n        }\n\n        return (claimAmounts, frtsIssuedList);\n    }\n\n    /// @dev for multiple claims\n    /// @param auctionSellTokens are the sellTokens defining an auctionPair\n    /// @param auctionBuyTokens are the buyTokens defining an auctionPair\n    /// @param auctionIndices are the auction indices on which an token should be claimedAmounts\n    /// @param user is the user who wants to his tokens\n    function claimTokensFromSeveralAuctionsAsBuyer(\n        address[] calldata auctionSellTokens,\n        address[] calldata auctionBuyTokens,\n        uint[] calldata auctionIndices,\n        address user\n    ) external returns (uint[] memory, uint[] memory)\n    {\n        uint length = checkLengthsForSeveralAuctionClaiming(auctionSellTokens, auctionBuyTokens, auctionIndices);\n\n        uint[] memory claimAmounts = new uint[](length);\n        uint[] memory frtsIssuedList = new uint[](length);\n\n        for (uint i = 0; i < length; i++) {\n            (claimAmounts[i], frtsIssuedList[i]) = claimBuyerFunds(\n                auctionSellTokens[i],\n                auctionBuyTokens[i],\n                user,\n                auctionIndices[i]\n            );\n        }\n\n        return (claimAmounts, frtsIssuedList);\n    }\n\n    /// @dev for multiple withdraws\n    /// @param auctionSellTokens are the sellTokens defining an auctionPair\n    /// @param auctionBuyTokens are the buyTokens defining an auctionPair\n    /// @param auctionIndices are the auction indices on which an token should be claimedAmounts\n    function claimAndWithdrawTokensFromSeveralAuctionsAsSeller(\n        address[] calldata auctionSellTokens,\n        address[] calldata auctionBuyTokens,\n        uint[] calldata auctionIndices\n    ) external returns (uint[] memory, uint frtsIssued)\n    {\n        uint length = checkLengthsForSeveralAuctionClaiming(auctionSellTokens, auctionBuyTokens, auctionIndices);\n\n        uint[] memory claimAmounts = new uint[](length);\n        uint claimFrts = 0;\n\n        for (uint i = 0; i < length; i++) {\n            (claimAmounts[i], claimFrts) = claimSellerFunds(\n                auctionSellTokens[i],\n                auctionBuyTokens[i],\n                msg.sender,\n                auctionIndices[i]\n            );\n\n            frtsIssued += claimFrts;\n\n            withdraw(auctionBuyTokens[i], claimAmounts[i]);\n        }\n\n        return (claimAmounts, frtsIssued);\n    }\n\n    /// @dev for multiple withdraws\n    /// @param auctionSellTokens are the sellTokens defining an auctionPair\n    /// @param auctionBuyTokens are the buyTokens defining an auctionPair\n    /// @param auctionIndices are the auction indices on which an token should be claimedAmounts\n    function claimAndWithdrawTokensFromSeveralAuctionsAsBuyer(\n        address[] calldata auctionSellTokens,\n        address[] calldata auctionBuyTokens,\n        uint[] calldata auctionIndices\n    ) external returns (uint[] memory, uint frtsIssued)\n    {\n        uint length = checkLengthsForSeveralAuctionClaiming(auctionSellTokens, auctionBuyTokens, auctionIndices);\n\n        uint[] memory claimAmounts = new uint[](length);\n        uint claimFrts = 0;\n\n        for (uint i = 0; i < length; i++) {\n            (claimAmounts[i], claimFrts) = claimBuyerFunds(\n                auctionSellTokens[i],\n                auctionBuyTokens[i],\n                msg.sender,\n                auctionIndices[i]\n            );\n\n            frtsIssued += claimFrts;\n\n            withdraw(auctionSellTokens[i], claimAmounts[i]);\n        }\n\n        return (claimAmounts, frtsIssued);\n    }\n\n    function getMasterCopy() external view returns (address) {\n        return masterCopy;\n    }\n\n    /// @dev Constructor-Function creates exchange\n    /// @param _frtToken - address of frtToken ERC-20 token\n    /// @param _owlToken - address of owlToken ERC-20 token\n    /// @param _auctioneer - auctioneer for managing interfaces\n    /// @param _ethToken - address of ETH ERC-20 token\n    /// @param _ethUSDOracle - address of the oracle contract for fetching feeds\n    /// @param _thresholdNewTokenPair - Minimum required sell funding for adding a new token pair, in USD\n    function setupDutchExchange(\n        TokenFRT _frtToken,\n        TokenOWL _owlToken,\n        address _auctioneer,\n        address _ethToken,\n        PriceOracleInterface _ethUSDOracle,\n        uint _thresholdNewTokenPair,\n        uint _thresholdNewAuction\n    ) public\n    {\n        // Make sure contract hasn't been initialised\n        require(ethToken == address(0), \"The contract must be uninitialized\");\n\n        // Validates inputs\n        require(address(_owlToken) != address(0), \"The OWL address must be valid\");\n        require(address(_frtToken) != address(0), \"The FRT address must be valid\");\n        require(_auctioneer != address(0), \"The auctioneer address must be valid\");\n        require(_ethToken != address(0), \"The WETH address must be valid\");\n        require(address(_ethUSDOracle) != address(0), \"The oracle address must be valid\");\n\n        frtToken = _frtToken;\n        owlToken = _owlToken;\n        auctioneer = _auctioneer;\n        ethToken = _ethToken;\n        ethUSDOracle = _ethUSDOracle;\n        thresholdNewTokenPair = _thresholdNewTokenPair;\n        thresholdNewAuction = _thresholdNewAuction;\n    }\n\n    function updateThresholdNewTokenPair(uint _thresholdNewTokenPair) public onlyAuctioneer {\n        thresholdNewTokenPair = _thresholdNewTokenPair;\n    }\n\n    function updateThresholdNewAuction(uint _thresholdNewAuction) public onlyAuctioneer {\n        thresholdNewAuction = _thresholdNewAuction;\n    }\n\n    /// @param initialClosingPriceNum initial price will be 2 * initialClosingPrice. This is its numerator\n    /// @param initialClosingPriceDen initial price will be 2 * initialClosingPrice. This is its denominator\n    function addTokenPair(\n        address token1,\n        address token2,\n        uint token1Funding,\n        uint token2Funding,\n        uint initialClosingPriceNum,\n        uint initialClosingPriceDen\n    ) public\n    {\n        // R1\n        require(token1 != token2, \"You cannot add a token pair using the same token\");\n\n        // R2\n        require(initialClosingPriceNum != 0, \"You must set the numerator for the initial price\");\n\n        // R3\n        require(initialClosingPriceDen != 0, \"You must set the denominator for the initial price\");\n\n        // R4\n        require(getAuctionIndex(token1, token2) == 0, \"The token pair was already added\");\n\n        // R5: to prevent overflow\n        require(initialClosingPriceNum < 10 ** 18, \"You must set a smaller numerator for the initial price\");\n\n        // R6\n        require(initialClosingPriceDen < 10 ** 18, \"You must set a smaller denominator for the initial price\");\n\n        setAuctionIndex(token1, token2);\n\n        token1Funding = min(token1Funding, balances[token1][msg.sender]);\n        token2Funding = min(token2Funding, balances[token2][msg.sender]);\n\n        // R7\n        require(token1Funding < 10 ** 30, \"You should use a smaller funding for token 1\");\n\n        // R8\n        require(token2Funding < 10 ** 30, \"You should use a smaller funding for token 2\");\n\n        uint fundedValueUSD;\n        uint ethUSDPrice = ethUSDOracle.getUSDETHPrice();\n\n        // Compute fundedValueUSD\n        address ethTokenMem = ethToken;\n        if (token1 == ethTokenMem) {\n            // C1\n            // MUL: 10^30 * 10^6 = 10^36\n            fundedValueUSD = mul(token1Funding, ethUSDPrice);\n        } else if (token2 == ethTokenMem) {\n            // C2\n            // MUL: 10^30 * 10^6 = 10^36\n            fundedValueUSD = mul(token2Funding, ethUSDPrice);\n        } else {\n            // C3: Neither token is ethToken\n            fundedValueUSD = calculateFundedValueTokenToken(\n                token1,\n                token2,\n                token1Funding,\n                token2Funding,\n                ethTokenMem,\n                ethUSDPrice\n            );\n        }\n\n        // R5\n        require(fundedValueUSD >= thresholdNewTokenPair, \"You should surplus the threshold for adding token pairs\");\n\n        // Save prices of opposite auctions\n        closingPrices[token1][token2][0] = Fraction(initialClosingPriceNum, initialClosingPriceDen);\n        closingPrices[token2][token1][0] = Fraction(initialClosingPriceDen, initialClosingPriceNum);\n\n        // Split into two fns because of 16 local-var cap\n        addTokenPairSecondPart(token1, token2, token1Funding, token2Funding);\n    }\n\n    function deposit(address tokenAddress, uint amount) public returns (uint) {\n        // R1\n        require(safeTransfer(tokenAddress, msg.sender, amount, true), \"The deposit transaction must succeed\");\n\n        uint newBal = add(balances[tokenAddress][msg.sender], amount);\n\n        balances[tokenAddress][msg.sender] = newBal;\n\n        emit NewDeposit(tokenAddress, amount);\n\n        return newBal;\n    }\n\n    function withdraw(address tokenAddress, uint amount) public returns (uint) {\n        uint usersBalance = balances[tokenAddress][msg.sender];\n        amount = min(amount, usersBalance);\n\n        // R1\n        require(amount > 0, \"The amount must be greater than 0\");\n\n        uint newBal = sub(usersBalance, amount);\n        balances[tokenAddress][msg.sender] = newBal;\n\n        // R2\n        require(safeTransfer(tokenAddress, msg.sender, amount, false), \"The withdraw transfer must succeed\");\n        emit NewWithdrawal(tokenAddress, amount);\n\n        return newBal;\n    }\n\n    function postSellOrder(address sellToken, address buyToken, uint auctionIndex, uint amount)\n        public\n        returns (uint, uint)\n    {\n        // Note: if a user specifies auctionIndex of 0, it\n        // means he is agnostic which auction his sell order goes into\n\n        amount = min(amount, balances[sellToken][msg.sender]);\n\n        // R1\n        // require(amount >= 0, \"Sell amount should be greater than 0\");\n\n        // R2\n        uint latestAuctionIndex = getAuctionIndex(sellToken, buyToken);\n        require(latestAuctionIndex > 0);\n\n        // R3\n        uint auctionStart = getAuctionStart(sellToken, buyToken);\n        if (auctionStart == AUCTION_START_WAITING_FOR_FUNDING || auctionStart > now) {\n            // C1: We are in the 10 minute buffer period\n            // OR waiting for an auction to receive sufficient sellVolume\n            // Auction has already cleared, and index has been incremented\n            // sell order must use that auction index\n            // R1.1\n            if (auctionIndex == 0) {\n                auctionIndex = latestAuctionIndex;\n            } else {\n                require(auctionIndex == latestAuctionIndex, \"Auction index should be equal to latest auction index\");\n            }\n\n            // R1.2\n            require(add(sellVolumesCurrent[sellToken][buyToken], amount) < 10 ** 30);\n        } else {\n            // C2\n            // R2.1: Sell orders must go to next auction\n            if (auctionIndex == 0) {\n                auctionIndex = latestAuctionIndex + 1;\n            } else {\n                require(auctionIndex == latestAuctionIndex + 1);\n            }\n\n            // R2.2\n            require(add(sellVolumesNext[sellToken][buyToken], amount) < 10 ** 30);\n        }\n\n        // Fee mechanism, fees are added to extraTokens\n        uint amountAfterFee = settleFee(sellToken, buyToken, auctionIndex, amount);\n\n        // Update variables\n        balances[sellToken][msg.sender] = sub(balances[sellToken][msg.sender], amount);\n        uint newSellerBal = add(sellerBalances[sellToken][buyToken][auctionIndex][msg.sender], amountAfterFee);\n        sellerBalances[sellToken][buyToken][auctionIndex][msg.sender] = newSellerBal;\n\n        if (auctionStart == AUCTION_START_WAITING_FOR_FUNDING || auctionStart > now) {\n            // C1\n            uint sellVolumeCurrent = sellVolumesCurrent[sellToken][buyToken];\n            sellVolumesCurrent[sellToken][buyToken] = add(sellVolumeCurrent, amountAfterFee);\n        } else {\n            // C2\n            uint sellVolumeNext = sellVolumesNext[sellToken][buyToken];\n            sellVolumesNext[sellToken][buyToken] = add(sellVolumeNext, amountAfterFee);\n\n            // close previous auction if theoretically closed\n            closeTheoreticalClosedAuction(sellToken, buyToken, latestAuctionIndex);\n        }\n\n        if (auctionStart == AUCTION_START_WAITING_FOR_FUNDING) {\n            scheduleNextAuction(sellToken, buyToken);\n        }\n\n        emit NewSellOrder(sellToken, buyToken, msg.sender, auctionIndex, amountAfterFee);\n\n        return (auctionIndex, newSellerBal);\n    }\n\n    function postBuyOrder(address sellToken, address buyToken, uint auctionIndex, uint amount)\n        public\n        returns (uint newBuyerBal)\n    {\n        // R1: auction must not have cleared\n        require(closingPrices[sellToken][buyToken][auctionIndex].den == 0);\n\n        uint auctionStart = getAuctionStart(sellToken, buyToken);\n\n        // R2\n        require(auctionStart <= now);\n\n        // R4\n        require(auctionIndex == getAuctionIndex(sellToken, buyToken));\n\n        // R5: auction must not be in waiting period\n        require(auctionStart > AUCTION_START_WAITING_FOR_FUNDING);\n\n        // R6: auction must be funded\n        require(sellVolumesCurrent[sellToken][buyToken] > 0);\n\n        uint buyVolume = buyVolumes[sellToken][buyToken];\n        amount = min(amount, balances[buyToken][msg.sender]);\n\n        // R7\n        require(add(buyVolume, amount) < 10 ** 30);\n\n        // Overbuy is when a part of a buy order clears an auction\n        // In that case we only process the part before the overbuy\n        // To calculate overbuy, we first get current price\n        uint sellVolume = sellVolumesCurrent[sellToken][buyToken];\n\n        uint num;\n        uint den;\n        (num, den) = getCurrentAuctionPrice(sellToken, buyToken, auctionIndex);\n        // 10^30 * 10^37 = 10^67\n        uint outstandingVolume = atleastZero(int(mul(sellVolume, num) / den - buyVolume));\n\n        uint amountAfterFee;\n        if (amount < outstandingVolume) {\n            if (amount > 0) {\n                amountAfterFee = settleFee(buyToken, sellToken, auctionIndex, amount);\n            }\n        } else {\n            amount = outstandingVolume;\n            amountAfterFee = outstandingVolume;\n        }\n\n        // Here we could also use outstandingVolume or amountAfterFee, it doesn't matter\n        if (amount > 0) {\n            // Update variables\n            balances[buyToken][msg.sender] = sub(balances[buyToken][msg.sender], amount);\n            newBuyerBal = add(buyerBalances[sellToken][buyToken][auctionIndex][msg.sender], amountAfterFee);\n            buyerBalances[sellToken][buyToken][auctionIndex][msg.sender] = newBuyerBal;\n            buyVolumes[sellToken][buyToken] = add(buyVolumes[sellToken][buyToken], amountAfterFee);\n            emit NewBuyOrder(sellToken, buyToken, msg.sender, auctionIndex, amountAfterFee);\n        }\n\n        // Checking for equality would suffice here. nevertheless:\n        if (amount >= outstandingVolume) {\n            // Clear auction\n            clearAuction(sellToken, buyToken, auctionIndex, sellVolume);\n        }\n\n        return (newBuyerBal);\n    }\n\n    function claimSellerFunds(address sellToken, address buyToken, address user, uint auctionIndex)\n        public\n        returns (\n        // < (10^60, 10^61)\n        uint returned,\n        uint frtsIssued\n    )\n    {\n        closeTheoreticalClosedAuction(sellToken, buyToken, auctionIndex);\n        uint sellerBalance = sellerBalances[sellToken][buyToken][auctionIndex][user];\n\n        // R1\n        require(sellerBalance > 0);\n\n        // Get closing price for said auction\n        Fraction memory closingPrice = closingPrices[sellToken][buyToken][auctionIndex];\n        uint num = closingPrice.num;\n        uint den = closingPrice.den;\n\n        // R2: require auction to have cleared\n        require(den > 0);\n\n        // Calculate return\n        // < 10^30 * 10^30 = 10^60\n        returned = mul(sellerBalance, num) / den;\n\n        frtsIssued = issueFrts(\n            sellToken,\n            buyToken,\n            returned,\n            auctionIndex,\n            sellerBalance,\n            user\n        );\n\n        // Claim tokens\n        sellerBalances[sellToken][buyToken][auctionIndex][user] = 0;\n        if (returned > 0) {\n            balances[buyToken][user] = add(balances[buyToken][user], returned);\n        }\n        emit NewSellerFundsClaim(\n            sellToken,\n            buyToken,\n            user,\n            auctionIndex,\n            returned,\n            frtsIssued\n        );\n    }\n\n    function claimBuyerFunds(address sellToken, address buyToken, address user, uint auctionIndex)\n        public\n        returns (uint returned, uint frtsIssued)\n    {\n        closeTheoreticalClosedAuction(sellToken, buyToken, auctionIndex);\n\n        uint num;\n        uint den;\n        (returned, num, den) = getUnclaimedBuyerFunds(sellToken, buyToken, user, auctionIndex);\n\n        if (closingPrices[sellToken][buyToken][auctionIndex].den == 0) {\n            // Auction is running\n            claimedAmounts[sellToken][buyToken][auctionIndex][user] = add(\n                claimedAmounts[sellToken][buyToken][auctionIndex][user],\n                returned\n            );\n        } else {\n            // Auction has closed\n            // We DON'T want to check for returned > 0, because that would fail if a user claims\n            // intermediate funds & auction clears in same block (he/she would not be able to claim extraTokens)\n\n            // Assign extra sell tokens (this is possible only after auction has cleared,\n            // because buyVolume could still increase before that)\n            uint extraTokensTotal = extraTokens[sellToken][buyToken][auctionIndex];\n            uint buyerBalance = buyerBalances[sellToken][buyToken][auctionIndex][user];\n\n            // closingPrices.num represents buyVolume\n            // < 10^30 * 10^30 = 10^60\n            uint tokensExtra = mul(\n                buyerBalance,\n                extraTokensTotal\n            ) / closingPrices[sellToken][buyToken][auctionIndex].num;\n            returned = add(returned, tokensExtra);\n\n            frtsIssued = issueFrts(\n                buyToken,\n                sellToken,\n                mul(buyerBalance, den) / num,\n                auctionIndex,\n                buyerBalance,\n                user\n            );\n\n            // Auction has closed\n            // Reset buyerBalances and claimedAmounts\n            buyerBalances[sellToken][buyToken][auctionIndex][user] = 0;\n            claimedAmounts[sellToken][buyToken][auctionIndex][user] = 0;\n        }\n\n        // Claim tokens\n        if (returned > 0) {\n            balances[sellToken][user] = add(balances[sellToken][user], returned);\n        }\n\n        emit NewBuyerFundsClaim(\n            sellToken,\n            buyToken,\n            user,\n            auctionIndex,\n            returned,\n            frtsIssued\n        );\n    }\n\n    /// @dev allows to close possible theoretical closed markets\n    /// @param sellToken sellToken of an auction\n    /// @param buyToken buyToken of an auction\n    /// @param auctionIndex is the auctionIndex of the auction\n    function closeTheoreticalClosedAuction(address sellToken, address buyToken, uint auctionIndex) public {\n        if (auctionIndex == getAuctionIndex(\n            buyToken,\n            sellToken\n        ) && closingPrices[sellToken][buyToken][auctionIndex].num == 0) {\n            uint buyVolume = buyVolumes[sellToken][buyToken];\n            uint sellVolume = sellVolumesCurrent[sellToken][buyToken];\n            uint num;\n            uint den;\n            (num, den) = getCurrentAuctionPrice(sellToken, buyToken, auctionIndex);\n            // 10^30 * 10^37 = 10^67\n            if (sellVolume > 0) {\n                uint outstandingVolume = atleastZero(int(mul(sellVolume, num) / den - buyVolume));\n\n                if (outstandingVolume == 0) {\n                    postBuyOrder(sellToken, buyToken, auctionIndex, 0);\n                }\n            }\n        }\n    }\n\n    /// @dev Claim buyer funds for one auction\n    function getUnclaimedBuyerFunds(address sellToken, address buyToken, address user, uint auctionIndex)\n        public\n        view\n        returns (\n        // < (10^67, 10^37)\n        uint unclaimedBuyerFunds,\n        uint num,\n        uint den\n    )\n    {\n        // R1: checks if particular auction has ever run\n        require(auctionIndex <= getAuctionIndex(sellToken, buyToken));\n\n        (num, den) = getCurrentAuctionPrice(sellToken, buyToken, auctionIndex);\n\n        if (num == 0) {\n            // This should rarely happen - as long as there is >= 1 buy order,\n            // auction will clear before price = 0. So this is just fail-safe\n            unclaimedBuyerFunds = 0;\n        } else {\n            uint buyerBalance = buyerBalances[sellToken][buyToken][auctionIndex][user];\n            // < 10^30 * 10^37 = 10^67\n            unclaimedBuyerFunds = atleastZero(\n                int(mul(buyerBalance, den) / num - claimedAmounts[sellToken][buyToken][auctionIndex][user])\n            );\n        }\n    }\n\n    function getFeeRatio(address user)\n        public\n        view\n        returns (\n        // feeRatio < 10^4\n        uint num,\n        uint den\n    )\n    {\n        uint totalSupply = frtToken.totalSupply();\n        uint lockedFrt = frtToken.lockedTokenBalances(user);\n\n        /*\n          Fee Model:\n            locked FRT range     Fee\n            -----------------   ------\n            [0, 0.01%)           0.5%\n            [0.01%, 0.1%)        0.4%\n            [0.1%, 1%)           0.3%\n            [1%, 10%)            0.2%\n            [10%, 100%)          0.1%\n        */\n\n        if (lockedFrt * 10000 < totalSupply || totalSupply == 0) {\n            // Maximum fee, if user has locked less than 0.01% of the total FRT\n            // Fee: 0.5%\n            num = 1;\n            den = 200;\n        } else if (lockedFrt * 1000 < totalSupply) {\n            // If user has locked more than 0.01% and less than 0.1% of the total FRT\n            // Fee: 0.4%\n            num = 1;\n            den = 250;\n        } else if (lockedFrt * 100 < totalSupply) {\n            // If user has locked more than 0.1% and less than 1% of the total FRT\n            // Fee: 0.3%\n            num = 3;\n            den = 1000;\n        } else if (lockedFrt * 10 < totalSupply) {\n            // If user has locked more than 1% and less than 10% of the total FRT\n            // Fee: 0.2%\n            num = 1;\n            den = 500;\n        } else {\n            // If user has locked more than 10% of the total FRT\n            // Fee: 0.1%\n            num = 1;\n            den = 1000;\n        }\n    }\n\n    //@ dev returns price in units [token2]/[token1]\n    //@ param token1 first token for price calculation\n    //@ param token2 second token for price calculation\n    //@ param auctionIndex index for the auction to get the averaged price from\n    function getPriceInPastAuction(\n        address token1,\n        address token2,\n        uint auctionIndex\n    )\n        public\n        view\n        // price < 10^31\n        returns (uint num, uint den)\n    {\n        if (token1 == token2) {\n            // C1\n            num = 1;\n            den = 1;\n        } else {\n            // C2\n            // R2.1\n            // require(auctionIndex >= 0);\n\n            // C3\n            // R3.1\n            require(auctionIndex <= getAuctionIndex(token1, token2));\n            // auction still running\n\n            uint i = 0;\n            bool correctPair = false;\n            Fraction memory closingPriceToken1;\n            Fraction memory closingPriceToken2;\n\n            while (!correctPair) {\n                closingPriceToken2 = closingPrices[token2][token1][auctionIndex - i];\n                closingPriceToken1 = closingPrices[token1][token2][auctionIndex - i];\n\n                if (closingPriceToken1.num > 0 && closingPriceToken1.den > 0 ||\n                    closingPriceToken2.num > 0 && closingPriceToken2.den > 0)\n                {\n                    correctPair = true;\n                }\n                i++;\n            }\n\n            // At this point at least one closing price is strictly positive\n            // If only one is positive, we want to output that\n            if (closingPriceToken1.num == 0 || closingPriceToken1.den == 0) {\n                num = closingPriceToken2.den;\n                den = closingPriceToken2.num;\n            } else if (closingPriceToken2.num == 0 || closingPriceToken2.den == 0) {\n                num = closingPriceToken1.num;\n                den = closingPriceToken1.den;\n            } else {\n                // If both prices are positive, output weighted average\n                num = closingPriceToken2.den + closingPriceToken1.num;\n                den = closingPriceToken2.num + closingPriceToken1.den;\n            }\n        }\n    }\n\n    function scheduleNextAuction(\n        address sellToken,\n        address buyToken\n    )\n        internal\n    {\n        (uint sellVolume, uint sellVolumeOpp) = getSellVolumesInUSD(sellToken, buyToken);\n\n        bool enoughSellVolume = sellVolume >= thresholdNewAuction;\n        bool enoughSellVolumeOpp = sellVolumeOpp >= thresholdNewAuction;\n        bool schedule;\n        // Make sure both sides have liquidity in order to start the auction\n        if (enoughSellVolume && enoughSellVolumeOpp) {\n            schedule = true;\n        } else if (enoughSellVolume || enoughSellVolumeOpp) {\n            // But if the auction didn't start in 24h, then is enough to have\n            // liquidity in one of the two sides\n            uint latestAuctionIndex = getAuctionIndex(sellToken, buyToken);\n            uint clearingTime = getClearingTime(sellToken, buyToken, latestAuctionIndex - 1);\n            schedule = clearingTime <= now - 24 hours;\n        }\n\n        if (schedule) {\n            // Schedule next auction\n            setAuctionStart(sellToken, buyToken, WAITING_PERIOD_NEW_AUCTION);\n        } else {\n            resetAuctionStart(sellToken, buyToken);\n        }\n    }\n\n    function getSellVolumesInUSD(\n        address sellToken,\n        address buyToken\n    )\n        internal\n        view\n        returns (uint sellVolume, uint sellVolumeOpp)\n    {\n        // Check if auctions received enough sell orders\n        uint ethUSDPrice = ethUSDOracle.getUSDETHPrice();\n\n        uint sellNum;\n        uint sellDen;\n        (sellNum, sellDen) = getPriceOfTokenInLastAuction(sellToken);\n\n        uint buyNum;\n        uint buyDen;\n        (buyNum, buyDen) = getPriceOfTokenInLastAuction(buyToken);\n\n        // We use current sell volume, because in clearAuction() we set\n        // sellVolumesCurrent = sellVolumesNext before calling this function\n        // (this is so that we don't need case work,\n        // since it might also be called from postSellOrder())\n\n        // < 10^30 * 10^31 * 10^6 = 10^67\n        sellVolume = mul(mul(sellVolumesCurrent[sellToken][buyToken], sellNum), ethUSDPrice) / sellDen;\n        sellVolumeOpp = mul(mul(sellVolumesCurrent[buyToken][sellToken], buyNum), ethUSDPrice) / buyDen;\n    }\n\n    /// @dev Gives best estimate for market price of a token in ETH of any price oracle on the Ethereum network\n    /// @param token address of ERC-20 token\n    /// @return Weighted average of closing prices of opposite Token-ethToken auctions, based on their sellVolume\n    function getPriceOfTokenInLastAuction(address token)\n        public\n        view\n        returns (\n        // price < 10^31\n        uint num,\n        uint den\n    )\n    {\n        uint latestAuctionIndex = getAuctionIndex(token, ethToken);\n        // getPriceInPastAuction < 10^30\n        (num, den) = getPriceInPastAuction(token, ethToken, latestAuctionIndex - 1);\n    }\n\n    function getCurrentAuctionPrice(address sellToken, address buyToken, uint auctionIndex)\n        public\n        view\n        returns (\n        // price < 10^37\n        uint num,\n        uint den\n    )\n    {\n        Fraction memory closingPrice = closingPrices[sellToken][buyToken][auctionIndex];\n\n        if (closingPrice.den != 0) {\n            // Auction has closed\n            (num, den) = (closingPrice.num, closingPrice.den);\n        } else if (auctionIndex > getAuctionIndex(sellToken, buyToken)) {\n            (num, den) = (0, 0);\n        } else {\n            // Auction is running\n            uint pastNum;\n            uint pastDen;\n            (pastNum, pastDen) = getPriceInPastAuction(sellToken, buyToken, auctionIndex - 1);\n\n            // If we're calling the function into an unstarted auction,\n            // it will return the starting price of that auction\n            uint timeElapsed = atleastZero(int(now - getAuctionStart(sellToken, buyToken)));\n\n            // The numbers below are chosen such that\n            // P(0 hrs) = 2 * lastClosingPrice, P(6 hrs) = lastClosingPrice, P(>=24 hrs) = 0\n\n            // 10^5 * 10^31 = 10^36\n            num = atleastZero(int((24 hours - timeElapsed) * pastNum));\n            // 10^6 * 10^31 = 10^37\n            den = mul((timeElapsed + 12 hours), pastDen);\n\n            if (mul(num, sellVolumesCurrent[sellToken][buyToken]) <= mul(den, buyVolumes[sellToken][buyToken])) {\n                num = buyVolumes[sellToken][buyToken];\n                den = sellVolumesCurrent[sellToken][buyToken];\n            }\n        }\n    }\n\n    // > Helper fns\n    function getTokenOrder(address token1, address token2) public pure returns (address, address) {\n        if (token2 < token1) {\n            (token1, token2) = (token2, token1);\n        }\n\n        return (token1, token2);\n    }\n\n    function getAuctionStart(address token1, address token2) public view returns (uint auctionStart) {\n        (token1, token2) = getTokenOrder(token1, token2);\n        auctionStart = auctionStarts[token1][token2];\n    }\n\n    function getAuctionIndex(address token1, address token2) public view returns (uint auctionIndex) {\n        (token1, token2) = getTokenOrder(token1, token2);\n        auctionIndex = latestAuctionIndices[token1][token2];\n    }\n\n    function calculateFundedValueTokenToken(\n        address token1,\n        address token2,\n        uint token1Funding,\n        uint token2Funding,\n        address ethTokenMem,\n        uint ethUSDPrice\n    )\n        internal\n        view\n        returns (uint fundedValueUSD)\n    {\n        // We require there to exist ethToken-Token auctions\n        // R3.1\n        require(getAuctionIndex(token1, ethTokenMem) > 0);\n\n        // R3.2\n        require(getAuctionIndex(token2, ethTokenMem) > 0);\n\n        // Price of Token 1\n        uint priceToken1Num;\n        uint priceToken1Den;\n        (priceToken1Num, priceToken1Den) = getPriceOfTokenInLastAuction(token1);\n\n        // Price of Token 2\n        uint priceToken2Num;\n        uint priceToken2Den;\n        (priceToken2Num, priceToken2Den) = getPriceOfTokenInLastAuction(token2);\n\n        // Compute funded value in ethToken and USD\n        // 10^30 * 10^30 = 10^60\n        uint fundedValueETH = add(\n            mul(token1Funding, priceToken1Num) / priceToken1Den,\n            token2Funding * priceToken2Num / priceToken2Den\n        );\n\n        fundedValueUSD = mul(fundedValueETH, ethUSDPrice);\n    }\n\n    function addTokenPairSecondPart(\n        address token1,\n        address token2,\n        uint token1Funding,\n        uint token2Funding\n    )\n        internal\n    {\n        balances[token1][msg.sender] = sub(balances[token1][msg.sender], token1Funding);\n        balances[token2][msg.sender] = sub(balances[token2][msg.sender], token2Funding);\n\n        // Fee mechanism, fees are added to extraTokens\n        uint token1FundingAfterFee = settleFee(token1, token2, 1, token1Funding);\n        uint token2FundingAfterFee = settleFee(token2, token1, 1, token2Funding);\n\n        // Update other variables\n        sellVolumesCurrent[token1][token2] = token1FundingAfterFee;\n        sellVolumesCurrent[token2][token1] = token2FundingAfterFee;\n        sellerBalances[token1][token2][1][msg.sender] = token1FundingAfterFee;\n        sellerBalances[token2][token1][1][msg.sender] = token2FundingAfterFee;\n\n        // Save clearingTime as adding time\n        (address tokenA, address tokenB) = getTokenOrder(token1, token2);\n        clearingTimes[tokenA][tokenB][0] = now;\n\n        setAuctionStart(token1, token2, WAITING_PERIOD_NEW_TOKEN_PAIR);\n        emit NewTokenPair(token1, token2);\n    }\n\n    function setClearingTime(\n        address token1,\n        address token2,\n        uint auctionIndex,\n        uint auctionStart,\n        uint sellVolume,\n        uint buyVolume\n    )\n        internal\n    {\n        (uint pastNum, uint pastDen) = getPriceInPastAuction(token1, token2, auctionIndex - 1);\n        // timeElapsed = (12 hours)*(2 * pastNum * sellVolume - buyVolume * pastDen)/\n            // (sellVolume * pastNum + buyVolume * pastDen)\n        uint numerator = sub(mul(mul(pastNum, sellVolume), 24 hours), mul(mul(buyVolume, pastDen), 12 hours));\n        uint timeElapsed = numerator / (add(mul(sellVolume, pastNum), mul(buyVolume, pastDen)));\n        uint clearingTime = auctionStart + timeElapsed;\n        (token1, token2) = getTokenOrder(token1, token2);\n        clearingTimes[token1][token2][auctionIndex] = clearingTime;\n    }\n\n    function getClearingTime(\n        address token1,\n        address token2,\n        uint auctionIndex\n    )\n        public\n        view\n        returns (uint time)\n    {\n        (token1, token2) = getTokenOrder(token1, token2);\n        time = clearingTimes[token1][token2][auctionIndex];\n    }\n\n    function issueFrts(\n        address primaryToken,\n        address secondaryToken,\n        uint x,\n        uint auctionIndex,\n        uint bal,\n        address user\n    )\n        internal\n        returns (uint frtsIssued)\n    {\n        if (approvedTokens[primaryToken] && approvedTokens[secondaryToken]) {\n            address ethTokenMem = ethToken;\n            // Get frts issued based on ETH price of returned tokens\n            if (primaryToken == ethTokenMem) {\n                frtsIssued = bal;\n            } else if (secondaryToken == ethTokenMem) {\n                // 10^30 * 10^39 = 10^66\n                frtsIssued = x;\n            } else {\n                // Neither token is ethToken, so we use getHhistoricalPriceOracle()\n                uint pastNum;\n                uint pastDen;\n                (pastNum, pastDen) = getPriceInPastAuction(primaryToken, ethTokenMem, auctionIndex - 1);\n                // 10^30 * 10^35 = 10^65\n                frtsIssued = mul(bal, pastNum) / pastDen;\n            }\n\n            if (frtsIssued > 0) {\n                // Issue frtToken\n                frtToken.mintTokens(user, frtsIssued);\n            }\n        }\n    }\n\n    function settleFee(address primaryToken, address secondaryToken, uint auctionIndex, uint amount)\n        internal\n        returns (\n        // < 10^30\n        uint amountAfterFee\n    )\n    {\n        uint feeNum;\n        uint feeDen;\n        (feeNum, feeDen) = getFeeRatio(msg.sender);\n        // 10^30 * 10^3 / 10^4 = 10^29\n        uint fee = mul(amount, feeNum) / feeDen;\n\n        if (fee > 0) {\n            fee = settleFeeSecondPart(primaryToken, fee);\n\n            uint usersExtraTokens = extraTokens[primaryToken][secondaryToken][auctionIndex + 1];\n            extraTokens[primaryToken][secondaryToken][auctionIndex + 1] = add(usersExtraTokens, fee);\n\n            emit Fee(primaryToken, secondaryToken, msg.sender, auctionIndex, fee);\n        }\n\n        amountAfterFee = sub(amount, fee);\n    }\n\n    function settleFeeSecondPart(address primaryToken, uint fee) internal returns (uint newFee) {\n        // Allow user to reduce up to half of the fee with owlToken\n        uint num;\n        uint den;\n        (num, den) = getPriceOfTokenInLastAuction(primaryToken);\n\n        // Convert fee to ETH, then USD\n        // 10^29 * 10^30 / 10^30 = 10^29\n        uint feeInETH = mul(fee, num) / den;\n\n        uint ethUSDPrice = ethUSDOracle.getUSDETHPrice();\n        // 10^29 * 10^6 = 10^35\n        // Uses 18 decimal places <> exactly as owlToken tokens: 10**18 owlToken == 1 USD\n        uint feeInUSD = mul(feeInETH, ethUSDPrice);\n        uint amountOfowlTokenBurned = min(owlToken.allowance(msg.sender, address(this)), feeInUSD / 2);\n        amountOfowlTokenBurned = min(owlToken.balanceOf(msg.sender), amountOfowlTokenBurned);\n\n        if (amountOfowlTokenBurned > 0) {\n            owlToken.burnOWL(msg.sender, amountOfowlTokenBurned);\n            // Adjust fee\n            // 10^35 * 10^29 = 10^64\n            uint adjustment = mul(amountOfowlTokenBurned, fee) / feeInUSD;\n            newFee = sub(fee, adjustment);\n        } else {\n            newFee = fee;\n        }\n    }\n\n    // addClearTimes\n    /// @dev clears an Auction\n    /// @param sellToken sellToken of the auction\n    /// @param buyToken  buyToken of the auction\n    /// @param auctionIndex of the auction to be cleared.\n    function clearAuction(\n        address sellToken,\n        address buyToken,\n        uint auctionIndex,\n        uint sellVolume\n    )\n        internal\n    {\n        // Get variables\n        uint buyVolume = buyVolumes[sellToken][buyToken];\n        uint sellVolumeOpp = sellVolumesCurrent[buyToken][sellToken];\n        uint closingPriceOppDen = closingPrices[buyToken][sellToken][auctionIndex].den;\n        uint auctionStart = getAuctionStart(sellToken, buyToken);\n\n        // Update closing price\n        if (sellVolume > 0) {\n            closingPrices[sellToken][buyToken][auctionIndex] = Fraction(buyVolume, sellVolume);\n        }\n\n        // if (opposite is 0 auction OR price = 0 OR opposite auction cleared)\n        // price = 0 happens if auction pair has been running for >= 24 hrs\n        if (sellVolumeOpp == 0 || now >= auctionStart + 24 hours || closingPriceOppDen > 0) {\n            // Close auction pair\n            uint buyVolumeOpp = buyVolumes[buyToken][sellToken];\n            if (closingPriceOppDen == 0 && sellVolumeOpp > 0) {\n                // Save opposite price\n                closingPrices[buyToken][sellToken][auctionIndex] = Fraction(buyVolumeOpp, sellVolumeOpp);\n            }\n\n            uint sellVolumeNext = sellVolumesNext[sellToken][buyToken];\n            uint sellVolumeNextOpp = sellVolumesNext[buyToken][sellToken];\n\n            // Update state variables for both auctions\n            sellVolumesCurrent[sellToken][buyToken] = sellVolumeNext;\n            if (sellVolumeNext > 0) {\n                sellVolumesNext[sellToken][buyToken] = 0;\n            }\n            if (buyVolume > 0) {\n                buyVolumes[sellToken][buyToken] = 0;\n            }\n\n            sellVolumesCurrent[buyToken][sellToken] = sellVolumeNextOpp;\n            if (sellVolumeNextOpp > 0) {\n                sellVolumesNext[buyToken][sellToken] = 0;\n            }\n            if (buyVolumeOpp > 0) {\n                buyVolumes[buyToken][sellToken] = 0;\n            }\n\n            // Save clearing time\n            setClearingTime(sellToken, buyToken, auctionIndex, auctionStart, sellVolume, buyVolume);\n            // Increment auction index\n            setAuctionIndex(sellToken, buyToken);\n            // Check if next auction can be scheduled\n            scheduleNextAuction(sellToken, buyToken);\n        }\n\n        emit AuctionCleared(sellToken, buyToken, sellVolume, buyVolume, auctionIndex);\n    }\n\n    function setAuctionStart(address token1, address token2, uint value) internal {\n        (token1, token2) = getTokenOrder(token1, token2);\n        uint auctionStart = now + value;\n        uint auctionIndex = latestAuctionIndices[token1][token2];\n        auctionStarts[token1][token2] = auctionStart;\n        emit AuctionStartScheduled(token1, token2, auctionIndex, auctionStart);\n    }\n\n    function resetAuctionStart(address token1, address token2) internal {\n        (token1, token2) = getTokenOrder(token1, token2);\n        if (auctionStarts[token1][token2] != AUCTION_START_WAITING_FOR_FUNDING) {\n            auctionStarts[token1][token2] = AUCTION_START_WAITING_FOR_FUNDING;\n        }\n    }\n\n    function setAuctionIndex(address token1, address token2) internal {\n        (token1, token2) = getTokenOrder(token1, token2);\n        latestAuctionIndices[token1][token2] += 1;\n    }\n\n    function checkLengthsForSeveralAuctionClaiming(\n        address[] memory auctionSellTokens,\n        address[] memory auctionBuyTokens,\n        uint[] memory auctionIndices\n    ) internal pure returns (uint length)\n    {\n        length = auctionSellTokens.length;\n        uint length2 = auctionBuyTokens.length;\n        require(length == length2);\n\n        uint length3 = auctionIndices.length;\n        require(length2 == length3);\n    }\n\n    // > Events\n    event NewDeposit(address indexed token, uint amount);\n\n    event NewWithdrawal(address indexed token, uint amount);\n\n    event NewSellOrder(\n        address indexed sellToken,\n        address indexed buyToken,\n        address indexed user,\n        uint auctionIndex,\n        uint amount\n    );\n\n    event NewBuyOrder(\n        address indexed sellToken,\n        address indexed buyToken,\n        address indexed user,\n        uint auctionIndex,\n        uint amount\n    );\n\n    event NewSellerFundsClaim(\n        address indexed sellToken,\n        address indexed buyToken,\n        address indexed user,\n        uint auctionIndex,\n        uint amount,\n        uint frtsIssued\n    );\n\n    event NewBuyerFundsClaim(\n        address indexed sellToken,\n        address indexed buyToken,\n        address indexed user,\n        uint auctionIndex,\n        uint amount,\n        uint frtsIssued\n    );\n\n    event NewTokenPair(address indexed sellToken, address indexed buyToken);\n\n    event AuctionCleared(\n        address indexed sellToken,\n        address indexed buyToken,\n        uint sellVolume,\n        uint buyVolume,\n        uint indexed auctionIndex\n    );\n\n    event AuctionStartScheduled(\n        address indexed sellToken,\n        address indexed buyToken,\n        uint indexed auctionIndex,\n        uint auctionStart\n    );\n\n    event Fee(\n        address indexed primaryToken,\n        address indexed secondarToken,\n        address indexed user,\n        uint auctionIndex,\n        uint fee\n    );\n}\n\n// File: @gnosis.pm/util-contracts/contracts/EtherToken.sol\n\n/// @title Token contract - Token exchanging Ether 1:1\n/// @author Stefan George - <[email protected]>\ncontract EtherToken is GnosisStandardToken {\n    using GnosisMath for *;\n\n    /*\n     *  Events\n     */\n    event Deposit(address indexed sender, uint value);\n    event Withdrawal(address indexed receiver, uint value);\n\n    /*\n     *  Constants\n     */\n    string public constant name = \"Ether Token\";\n    string public constant symbol = \"ETH\";\n    uint8 public constant decimals = 18;\n\n    /*\n     *  Public functions\n     */\n    /// @dev Buys tokens with Ether, exchanging them 1:1\n    function deposit() public payable {\n        balances[msg.sender] = balances[msg.sender].add(msg.value);\n        totalTokens = totalTokens.add(msg.value);\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    /// @dev Sells tokens in exchange for Ether, exchanging them 1:1\n    /// @param value Number of tokens to sell\n    function withdraw(uint value) public {\n        // Balance covers value\n        balances[msg.sender] = balances[msg.sender].sub(value);\n        totalTokens = totalTokens.sub(value);\n        msg.sender.transfer(value);\n        emit Withdrawal(msg.sender, value);\n    }\n}\n\n// File: contracts/KyberDxMarketMaker.sol\n\ninterface KyberNetworkProxy {\n    function getExpectedRate(ERC20 src, ERC20 dest, uint srcQty)\n        external\n        view\n        returns (uint expectedRate, uint slippageRate);\n}\n\n\ncontract KyberDxMarketMaker is Withdrawable {\n    // This is the representation of ETH as an ERC20 Token for Kyber Network.\n    ERC20 constant internal KYBER_ETH_TOKEN = ERC20(\n        0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee\n    );\n\n    // Declared in DutchExchange contract but not public.\n    uint public constant DX_AUCTION_START_WAITING_FOR_FUNDING = 1;\n\n    enum AuctionState {\n        WAITING_FOR_FUNDING,\n        WAITING_FOR_OPP_FUNDING,\n        WAITING_FOR_SCHEDULED_AUCTION,\n        AUCTION_IN_PROGRESS,\n        WAITING_FOR_OPP_TO_FINISH,\n        AUCTION_EXPIRED\n    }\n\n    // Exposing the enum values to external tools.\n    AuctionState constant public WAITING_FOR_FUNDING = AuctionState.WAITING_FOR_FUNDING;\n    AuctionState constant public WAITING_FOR_OPP_FUNDING = AuctionState.WAITING_FOR_OPP_FUNDING;\n    AuctionState constant public WAITING_FOR_SCHEDULED_AUCTION = AuctionState.WAITING_FOR_SCHEDULED_AUCTION;\n    AuctionState constant public AUCTION_IN_PROGRESS = AuctionState.AUCTION_IN_PROGRESS;\n    AuctionState constant public WAITING_FOR_OPP_TO_FINISH = AuctionState.WAITING_FOR_OPP_TO_FINISH;\n    AuctionState constant public AUCTION_EXPIRED = AuctionState.AUCTION_EXPIRED;\n\n    DutchExchange public dx;\n    EtherToken public weth;\n    KyberNetworkProxy public kyberNetworkProxy;\n\n    // Token => Token => auctionIndex\n    mapping (address => mapping (address => uint)) public lastParticipatedAuction;\n\n    constructor(\n        DutchExchange _dx,\n        KyberNetworkProxy _kyberNetworkProxy\n    ) public {\n        require(\n            address(_dx) != address(0),\n            \"DutchExchange address cannot be 0\"\n        );\n        require(\n            address(_kyberNetworkProxy) != address(0),\n            \"KyberNetworkProxy address cannot be 0\"\n        );\n\n        dx = DutchExchange(_dx);\n        weth = EtherToken(dx.ethToken());\n        kyberNetworkProxy = KyberNetworkProxy(_kyberNetworkProxy);\n    }\n\n    event KyberNetworkProxyUpdated(\n        KyberNetworkProxy kyberNetworkProxy\n    );\n\n    function setKyberNetworkProxy(\n        KyberNetworkProxy _kyberNetworkProxy\n    )\n        public\n        onlyAdmin\n        returns (bool)\n    {\n        require(\n            address(_kyberNetworkProxy) != address(0),\n            \"KyberNetworkProxy address cannot be 0\"\n        );\n\n        kyberNetworkProxy = _kyberNetworkProxy;\n        emit KyberNetworkProxyUpdated(kyberNetworkProxy);\n        return true;\n    }\n\n    event AmountDepositedToDx(\n        address indexed token,\n        uint amount\n    );\n\n    function depositToDx(\n        address token,\n        uint amount\n    )\n        public\n        onlyOperator\n        returns (uint)\n    {\n        require(ERC20(token).approve(address(dx), amount), \"Cannot approve deposit\");\n        uint deposited = dx.deposit(token, amount);\n        emit AmountDepositedToDx(token, deposited);\n        return deposited;\n    }\n\n    event AmountWithdrawnFromDx(\n        address indexed token,\n        uint amount\n    );\n\n    function withdrawFromDx(\n        address token,\n        uint amount\n    )\n        public\n        onlyOperator\n        returns (uint)\n    {\n        uint withdrawn = dx.withdraw(token, amount);\n        emit AmountWithdrawnFromDx(token, withdrawn);\n        return withdrawn;\n    }\n\n    /**\n      Claims funds from a specific auction.\n\n      sellerFunds - the amount in token wei of *buyToken* that was returned.\n      buyerFunds - the amount in token wei of *sellToken* that was returned.\n      */\n    function claimSpecificAuctionFunds(\n        address sellToken,\n        address buyToken,\n        uint auctionIndex\n    )\n        public\n        returns (uint sellerFunds, uint buyerFunds)\n    {\n        uint availableFunds;\n        availableFunds = dx.sellerBalances(\n            sellToken,\n            buyToken,\n            auctionIndex,\n            address(this)\n        );\n        if (availableFunds > 0) {\n            (sellerFunds, ) = dx.claimSellerFunds(\n                sellToken,\n                buyToken,\n                address(this),\n                auctionIndex\n            );\n        }\n\n        availableFunds = dx.buyerBalances(\n            sellToken,\n            buyToken,\n            auctionIndex,\n            address(this)\n        );\n        if (availableFunds > 0) {\n            (buyerFunds, ) = dx.claimBuyerFunds(\n                sellToken,\n                buyToken,\n                address(this),\n                auctionIndex\n            );\n        }\n    }\n\n    /**\n        Participates in the auction by taking the appropriate step according to\n        the auction state.\n\n        Returns true if there is a step to be taken in this auction at this\n        stage, false otherwise.\n    */\n    // TODO: consider removing onlyOperator limitation\n    function step(\n        address sellToken,\n        address buyToken\n    )\n        public\n        onlyOperator\n        returns (bool)\n    {\n        // KyberNetworkProxy.getExpectedRate() always returns a rate between\n        // tokens (and not between token wei as DutchX does).\n        // For this reason the rate is currently compatible only for tokens that\n        // have 18 decimals and is handled as though it is rate / 10**18.\n        // TODO: handle tokens with number of decimals other than 18.\n        require(\n            ERC20(sellToken).decimals() == 18 && ERC20(buyToken).decimals() == 18,\n            \"Only 18 decimals tokens are supported\"\n        );\n\n        // Deposit dxmm token balance to DutchX.\n        depositAllBalance(sellToken);\n        depositAllBalance(buyToken);\n\n        AuctionState state = getAuctionState(sellToken, buyToken);\n        uint auctionIndex = dx.getAuctionIndex(sellToken, buyToken);\n        emit CurrentAuctionState(sellToken, buyToken, auctionIndex, state);\n\n        if (state == AuctionState.WAITING_FOR_FUNDING) {\n            // Update the dutchX balance with the funds from the previous auction.\n            claimSpecificAuctionFunds(\n                sellToken,\n                buyToken,\n                lastParticipatedAuction[sellToken][buyToken]\n            );\n            require(fundAuctionDirection(sellToken, buyToken));\n            return true;\n        }\n\n        if (state == AuctionState.WAITING_FOR_OPP_FUNDING ||\n            state == AuctionState.WAITING_FOR_SCHEDULED_AUCTION) {\n            return false;\n        }\n\n        if (state == AuctionState.AUCTION_IN_PROGRESS) {\n            if (isPriceRightForBuying(sellToken, buyToken, auctionIndex)) {\n                return buyInAuction(sellToken, buyToken);\n            }\n            return false;\n        }\n\n        if (state == AuctionState.WAITING_FOR_OPP_TO_FINISH) {\n            return false;\n        }\n\n        if (state == AuctionState.AUCTION_EXPIRED) {\n            dx.closeTheoreticalClosedAuction(sellToken, buyToken, auctionIndex);\n            dx.closeTheoreticalClosedAuction(buyToken, sellToken, auctionIndex);\n            return true;\n        }\n\n        // Should be unreachable.\n        revert(\"Unknown auction state\");\n    }\n\n    function willAmountClearAuction(\n        address sellToken,\n        address buyToken,\n        uint auctionIndex,\n        uint amount\n    )\n        public\n        view\n        returns (bool)\n    {\n        uint buyVolume = dx.buyVolumes(sellToken, buyToken);\n\n        // Overbuy is when a part of a buy order clears an auction\n        // In that case we only process the part before the overbuy\n        // To calculate overbuy, we first get current price\n        uint sellVolume = dx.sellVolumesCurrent(sellToken, buyToken);\n\n        uint num;\n        uint den;\n        (num, den) = dx.getCurrentAuctionPrice(sellToken, buyToken, auctionIndex);\n        // 10^30 * 10^37 = 10^67\n        uint outstandingVolume = atleastZero(int(div(mul(sellVolume, num), sub(den, buyVolume))));\n        return amount >= outstandingVolume;\n    }\n\n    // TODO: consider adding a \"safety margin\" to compensate for accuracy issues.\n    function thresholdNewAuctionToken(\n        address token\n    )\n        public\n        view\n        returns (uint)\n    {\n        uint priceTokenNum;\n        uint priceTokenDen;\n        (priceTokenNum, priceTokenDen) = dx.getPriceOfTokenInLastAuction(token);\n\n        // TODO: maybe not add 1 if token is WETH\n        // Rounding up to make sure we pass the threshold\n        return 1 + div(\n            // mul() takes care of overflows\n            mul(\n                dx.thresholdNewAuction(),\n                priceTokenDen\n            ),\n            mul(\n                dx.ethUSDOracle().getUSDETHPrice(),\n                priceTokenNum\n            )\n        );\n    }\n\n    function calculateMissingTokenForAuctionStart(\n        address sellToken,\n        address buyToken\n    )\n        public\n        view\n        returns (uint)\n    {\n        uint currentAuctionSellVolume = dx.sellVolumesCurrent(sellToken, buyToken);\n        uint thresholdTokenWei = thresholdNewAuctionToken(sellToken);\n\n        if (thresholdTokenWei > currentAuctionSellVolume) {\n            return sub(thresholdTokenWei, currentAuctionSellVolume);\n        }\n\n        return 0;\n    }\n\n    function addFee(\n        uint amount\n    )\n        public\n        view\n        returns (uint)\n    {\n        uint num;\n        uint den;\n        (num, den) = dx.getFeeRatio(msg.sender);\n\n        // amount / (1 - num / den)\n        return div(\n            mul(amount, den),\n            sub(den, num)\n        );\n    }\n\n    function getAuctionState(\n        address sellToken,\n        address buyToken\n    )\n        public\n        view\n        returns (AuctionState)\n    {\n\n        // Unfunded auctions have an auctionStart time equal to a constant (1)\n        uint auctionStart = dx.getAuctionStart(sellToken, buyToken);\n        if (auctionStart == DX_AUCTION_START_WAITING_FOR_FUNDING) {\n            // Other side might also be not fully funded, but we're primarily\n            // interested in this direction.\n            if (calculateMissingTokenForAuctionStart(sellToken, buyToken) > 0) {\n                return AuctionState.WAITING_FOR_FUNDING;\n            } else {\n                return AuctionState.WAITING_FOR_OPP_FUNDING;\n            }\n        }\n\n        // DutchExchange logic uses auction start time.\n        /* solhint-disable-next-line not-rely-on-time */\n        if (auctionStart > now) {\n            // After 24 hours have passed since last auction closed,\n            // DutchExchange will trigger a new auction even if only the\n            // opposite side is funded.\n            // In these cases we want this side to be funded as well.\n            if (calculateMissingTokenForAuctionStart(sellToken, buyToken) > 0) {\n                return AuctionState.WAITING_FOR_FUNDING;\n            } else {\n                return AuctionState.WAITING_FOR_SCHEDULED_AUCTION;\n            }\n        }\n\n        // If over 24 hours have passed, the auction is no longer viable and\n        // should be closed.\n        /* solhint-disable-next-line not-rely-on-time */\n        if (now - auctionStart > 24 hours) {\n            return AuctionState.AUCTION_EXPIRED;\n        }\n\n        uint auctionIndex = dx.getAuctionIndex(sellToken, buyToken);\n        uint closingPriceDen;\n        (, closingPriceDen) = dx.closingPrices(sellToken, buyToken, auctionIndex);\n        if (closingPriceDen == 0) {\n            return AuctionState.AUCTION_IN_PROGRESS;\n        }\n\n        return AuctionState.WAITING_FOR_OPP_TO_FINISH;\n    }\n\n    function getKyberRate(\n        address _sellToken,\n        address _buyToken,\n        uint amount\n    )\n        public\n        view\n        returns (uint num, uint den)\n    {\n        // KyberNetworkProxy.getExpectedRate() always returns a rate between\n        // tokens (and not between token wei as DutchX does.\n        // For this reason the rate is currently compatible only for tokens that\n        // have 18 decimals and is handled as though it is rate / 10**18.\n        // TODO: handle tokens with number of decimals other than 18.\n        require(\n            ERC20(_sellToken).decimals() == 18 && ERC20(_buyToken).decimals() == 18,\n            \"Only 18 decimals tokens are supported\"\n        );\n\n        // Kyber uses a special constant address for representing ETH.\n        ERC20 sellToken = _sellToken == address(weth) ? KYBER_ETH_TOKEN : ERC20(_sellToken);\n        ERC20 buyToken = _buyToken == address(weth) ? KYBER_ETH_TOKEN : ERC20(_buyToken);\n        uint rate;\n        (rate, ) = kyberNetworkProxy.getExpectedRate(\n            sellToken,\n            buyToken,\n            amount\n        );\n\n        return (rate, 10 ** 18);\n    }\n\n    function tokensSoldInCurrentAuction(\n        address sellToken,\n        address buyToken,\n        uint auctionIndex,\n        address account\n    )\n        public\n        view\n        returns (uint)\n    {\n        return dx.sellerBalances(sellToken, buyToken, auctionIndex, account);\n    }\n\n    // The amount of tokens that matches the amount sold by provided account in\n    // specified auction index, deducting the amount that was already bought.\n    function calculateAuctionBuyTokens(\n        address sellToken,\n        address buyToken,\n        uint auctionIndex,\n        address account\n    )\n        public\n        view\n        returns (uint)\n    {\n        uint sellVolume = tokensSoldInCurrentAuction(\n            sellToken,\n            buyToken,\n            auctionIndex,\n            account\n        );\n\n        uint num;\n        uint den;\n        (num, den) = dx.getCurrentAuctionPrice(\n            sellToken,\n            buyToken,\n            auctionIndex\n        );\n\n        // No price for this auction, it is a future one.\n        if (den == 0) return 0;\n\n        uint wantedBuyVolume = div(mul(sellVolume, num), den);\n\n        uint auctionSellVolume = dx.sellVolumesCurrent(sellToken, buyToken);\n        uint buyVolume = dx.buyVolumes(sellToken, buyToken);\n        uint outstandingBuyVolume = atleastZero(\n            int(mul(auctionSellVolume, num) / den - buyVolume)\n        );\n\n        return wantedBuyVolume < outstandingBuyVolume\n            ? wantedBuyVolume\n            : outstandingBuyVolume;\n    }\n\n    function atleastZero(int a)\n        public\n        pure\n        returns (uint)\n    {\n        if (a < 0) {\n            return 0;\n        } else {\n            return uint(a);\n        }\n    }\n\n    event AuctionDirectionFunded(\n        address indexed sellToken,\n        address indexed buyToken,\n        uint indexed auctionIndex,\n        uint sellTokenAmount,\n        uint sellTokenAmountWithFee\n    );\n\n    function fundAuctionDirection(\n        address sellToken,\n        address buyToken\n    )\n        internal\n        returns (bool)\n    {\n        uint missingTokens = calculateMissingTokenForAuctionStart(\n            sellToken,\n            buyToken\n        );\n        uint missingTokensWithFee = addFee(missingTokens);\n        if (missingTokensWithFee == 0) return false;\n\n        uint balance = dx.balances(sellToken, address(this));\n        require(\n            balance >= missingTokensWithFee,\n            \"Not enough tokens to fund auction direction\"\n        );\n\n        uint auctionIndex = dx.getAuctionIndex(sellToken, buyToken);\n        dx.postSellOrder(sellToken, buyToken, auctionIndex, missingTokensWithFee);\n        lastParticipatedAuction[sellToken][buyToken] = auctionIndex;\n\n        emit AuctionDirectionFunded(\n            sellToken,\n            buyToken,\n            auctionIndex,\n            missingTokens,\n            missingTokensWithFee\n        );\n        return true;\n    }\n\n    // TODO: check for all the requirements of dutchx\n    event BoughtInAuction(\n        address indexed sellToken,\n        address indexed buyToken,\n        uint auctionIndex,\n        uint buyTokenAmount,\n        bool clearedAuction\n    );\n\n    /**\n        Will calculate the amount that the bot has sold in current auction and\n        buy that amount.\n\n        Returns false if ended up not buying.\n        Reverts if no auction active or not enough tokens for buying.\n    */\n    function buyInAuction(\n        address sellToken,\n        address buyToken\n    )\n        internal\n        returns (bool bought)\n    {\n        require(\n            getAuctionState(sellToken, buyToken) == AuctionState.AUCTION_IN_PROGRESS,\n            \"No auction in progress\"\n        );\n\n        uint auctionIndex = dx.getAuctionIndex(sellToken, buyToken);\n        uint buyTokenAmount = calculateAuctionBuyTokens(\n            sellToken,\n            buyToken,\n            auctionIndex,\n            address(this)\n        );\n\n        if (buyTokenAmount == 0) {\n            return false;\n        }\n\n        bool willClearAuction = willAmountClearAuction(\n            sellToken,\n            buyToken,\n            auctionIndex,\n            buyTokenAmount\n        );\n        if (!willClearAuction) {\n            buyTokenAmount = addFee(buyTokenAmount);\n        }\n\n        require(\n            dx.balances(buyToken, address(this)) >= buyTokenAmount,\n            \"Not enough buy token to buy required amount\"\n        );\n\n        dx.postBuyOrder(sellToken, buyToken, auctionIndex, buyTokenAmount);\n        emit BoughtInAuction(\n            sellToken,\n            buyToken,\n            auctionIndex,\n            buyTokenAmount,\n            willClearAuction\n        );\n        return true;\n    }\n\n    function depositAllBalance(\n        address token\n    )\n        internal\n        returns (uint)\n    {\n        uint amount;\n        uint balance = ERC20(token).balanceOf(address(this));\n        if (balance > 0) {\n            amount = depositToDx(token, balance);\n        }\n        return amount;\n    }\n\n    event CurrentAuctionState(\n        address indexed sellToken,\n        address indexed buyToken,\n        uint auctionIndex,\n        AuctionState auctionState\n    );\n\n    event PriceIsRightForBuying(\n        address indexed sellToken,\n        address indexed buyToken,\n        uint auctionIndex,\n        uint amount,\n        uint dutchExchangePriceNum,\n        uint dutchExchangePriceDen,\n        uint kyberPriceNum,\n        uint kyberPriceDen\n    );\n\n    function isPriceRightForBuying(\n        address sellToken,\n        address buyToken,\n        uint auctionIndex\n    )\n        internal\n        returns (bool)\n    {\n        uint amount = calculateAuctionBuyTokens(\n            sellToken,\n            buyToken,\n            auctionIndex,\n            address(this)\n        );\n\n        uint dNum;\n        uint dDen;\n        (dNum, dDen) = dx.getCurrentAuctionPrice(\n            sellToken,\n            buyToken,\n            auctionIndex\n        );\n\n        uint kNum;\n        uint kDen;\n        (kNum, kDen) = getKyberRate(sellToken, buyToken, amount);\n\n        // TODO: Check for overflow explicitly?\n        bool shouldBuy = mul(dNum, kDen) <= mul(kNum, dDen);\n        // TODO: should we add a boolean for shouldBuy?\n        emit PriceIsRightForBuying(\n            sellToken,\n            buyToken,\n            auctionIndex,\n            amount,\n            dNum,\n            dDen,\n            kNum,\n            kDen\n        );\n        return shouldBuy;\n    }\n\n    // --- Safe Math functions ---\n    // (https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol)\n    /**\n    * @dev Multiplies two numbers, reverts on overflow.\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero,\n        // but the benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two numbers truncating the quotient, reverts on\n        division by zero.\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if\n        subtrahend is greater than minuend).\n    */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n}",
  "abi": "[{\"constant\":false,\"inputs\":[{\"name\":\"alerter\",\"type\":\"address\"}],\"name\":\"removeAlerter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFromDx\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sellToken\",\"type\":\"address\"},{\"name\":\"buyToken\",\"type\":\"address\"},{\"name\":\"auctionIndex\",\"type\":\"uint256\"}],\"name\":\"claimSpecificAuctionFunds\",\"outputs\":[{\"name\":\"sellerFunds\",\"type\":\"uint256\"},{\"name\":\"buyerFunds\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_kyberNetworkProxy\",\"type\":\"address\"}],\"name\":\"setKyberNetworkProxy\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOperators\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sellToken\",\"type\":\"address\"},{\"name\":\"buyToken\",\"type\":\"address\"}],\"name\":\"calculateMissingTokenForAuctionStart\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WAITING_FOR_OPP_TO_FINISH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastParticipatedAuction\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"int256\"}],\"name\":\"atleastZero\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sellToken\",\"type\":\"address\"},{\"name\":\"_buyToken\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getKyberRate\",\"outputs\":[{\"name\":\"num\",\"type\":\"uint256\"},{\"name\":\"den\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAlerter\",\"type\":\"address\"}],\"name\":\"addAlerter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WAITING_FOR_FUNDING\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sellToken\",\"type\":\"address\"},{\"name\":\"buyToken\",\"type\":\"address\"},{\"name\":\"auctionIndex\",\"type\":\"uint256\"},{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"tokensSoldInCurrentAuction\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"thresholdNewAuctionToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"transferAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"transferAdminQuickly\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAlerters\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sellToken\",\"type\":\"address\"},{\"name\":\"buyToken\",\"type\":\"address\"}],\"name\":\"step\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sellToken\",\"type\":\"address\"},{\"name\":\"buyToken\",\"type\":\"address\"}],\"name\":\"getAuctionState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WAITING_FOR_SCHEDULED_AUCTION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DX_AUCTION_START_WAITING_FOR_FUNDING\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"addOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositToDx\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"removeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"AUCTION_IN_PROGRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dx\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sellToken\",\"type\":\"address\"},{\"name\":\"buyToken\",\"type\":\"address\"},{\"name\":\"auctionIndex\",\"type\":\"uint256\"},{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"calculateAuctionBuyTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kyberNetworkProxy\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WAITING_FOR_OPP_FUNDING\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sellToken\",\"type\":\"address\"},{\"name\":\"buyToken\",\"type\":\"address\"},{\"name\":\"auctionIndex\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"willAmountClearAuction\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"AUCTION_EXPIRED\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_dx\",\"type\":\"address\"},{\"name\":\"_kyberNetworkProxy\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"kyberNetworkProxy\",\"type\":\"address\"}],\"name\":\"KyberNetworkProxyUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AmountDepositedToDx\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AmountWithdrawnFromDx\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sellToken\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"buyToken\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"auctionIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sellTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sellTokenAmountWithFee\",\"type\":\"uint256\"}],\"name\":\"AuctionDirectionFunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sellToken\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"buyToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"auctionIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"buyTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"clearedAuction\",\"type\":\"bool\"}],\"name\":\"BoughtInAuction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sellToken\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"buyToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"auctionIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"auctionState\",\"type\":\"uint8\"}],\"name\":\"CurrentAuctionState\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sellToken\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"buyToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"auctionIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"dutchExchangePriceNum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"dutchExchangePriceDen\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"kyberPriceNum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"kyberPriceDen\",\"type\":\"uint256\"}],\"name\":\"PriceIsRightForBuying\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"TokenWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"EtherWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"pendingAdmin\",\"type\":\"address\"}],\"name\":\"TransferAdminPending\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newAdmin\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"previousAdmin\",\"type\":\"address\"}],\"name\":\"AdminClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newAlerter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"isAdd\",\"type\":\"bool\"}],\"name\":\"AlerterAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOperator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"isAdd\",\"type\":\"bool\"}],\"name\":\"OperatorAdded\",\"type\":\"event\"}]",
  "bytecode": "60806040523480156200001157600080fd5b5060405160408062003bd8833981018060405260408110156200003357600080fd5b50805160209091015160008054600160a060020a03191633179055600160a060020a0382161515620000b1576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252602181526020018062003b926021913960400191505060405180910390fd5b600160a060020a038116151562000114576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252602581526020018062003bb36025913960400191505060405180910390fd5b60068054600160a060020a031916600160a060020a038481169190911791829055604080517f7bf1a62700000000000000000000000000000000000000000000000000000000815290519290911691637bf1a62791600480820192602092909190829003018186803b1580156200018a57600080fd5b505afa1580156200019f573d6000803e3d6000fd5b505050506040513d6020811015620001b657600080fd5b505160078054600160a060020a03928316600160a060020a031991821617909155600880549390921692169190911790555061399a80620001f86000396000f3fe608060405234801561001057600080fd5b50600436106102365760003560e060020a9004806377f50f9711610134578063ac8a584a116100bc578063d77366a411610080578063d77366a414610724578063dc77a7a21461072c578063f7cf029014610734578063f851a44014610770578063f9c52c551461077857610236565b8063ac8a584a14610686578063af4561e5146106ac578063c9042b1e146106b4578063cda7ed5a146106bc578063ce56c454146106f857610236565b80638e3e5dab116101035780638e3e5dab146105f6578063951244cd1461062457806396fb2f581461062c5780639870d7fe146106345780639d365d771461065a57610236565b806377f50f97146105925780637acc86781461059a5780637c423f54146105c05780638e1f1f4c146105c857610236565b80632ec5e8b9116101c2578063408ee7fe11610186578063408ee7fe146104dc5780634f285fac146105025780635f0b664d1461050a57806370349c871461054657806375829def1461056c57610236565b80632ec5e8b91461041d578063306904681461044b5780633a2a22ff146104685780633ccdbb281461049e5780633fc8cef3146104d457610236565b80632678224711610209578063267822471461030d578063277206dd1461033157806327a099d81461036b5780632a259247146103c35780632c59d7c4146103f157610236565b806301a12fd31461023b578063178139d814610263578063198b7007146102a157806321307bac146102f0575b600080fd5b6102616004803603602081101561025157600080fd5b5035600160a060020a0316610780565b005b61028f6004803603604081101561027957600080fd5b50600160a060020a03813516906020013561096b565b60408051918252519081900360200190f35b6102d7600480360360608110156102b757600080fd5b50600160a060020a03813581169160208101359091169060400135610abc565b6040805192835260208301919091528051918290030190f35b61028f6004803603602081101561030657600080fd5b5035610d7f565b610315610e44565b60408051600160a060020a039092168252519081900360200190f35b6103576004803603602081101561034757600080fd5b5035600160a060020a0316610e53565b604080519115158252519081900360200190f35b610373610f4d565b60408051602080825283518183015283519192839290830191858101910280838360005b838110156103af578181015183820152602001610397565b505050509050019250505060405180910390f35b61028f600480360360408110156103d957600080fd5b50600160a060020a0381358116916020013516610fb0565b6103f9611081565b6040518082600581111561040957fe5b60ff16815260200191505060405180910390f35b61028f6004803603604081101561043357600080fd5b50600160a060020a0381358116916020013516611086565b61028f6004803603602081101561046157600080fd5b50356110a3565b6102d76004803603606081101561047e57600080fd5b50600160a060020a038135811691602081013590911690604001356110bc565b610261600480360360608110156104b457600080fd5b50600160a060020a03813581169160208101359160409091013516611301565b610315611486565b610261600480360360208110156104f257600080fd5b5035600160a060020a0316611495565b6103f9611644565b61028f6004803603608081101561052057600080fd5b50600160a060020a03813581169160208101358216916040820135916060013516611649565b61028f6004803603602081101561055c57600080fd5b5035600160a060020a0316611701565b6102616004803603602081101561058257600080fd5b5035600160a060020a0316611959565b610261611a6a565b610261600480360360208110156105b057600080fd5b5035600160a060020a0316611b3f565b610373611c95565b610357600480360360408110156105de57600080fd5b50600160a060020a0381358116916020013516611cf5565b6103f96004803603604081101561060c57600080fd5b50600160a060020a038135811691602001351661220a565b6103f961246b565b61028f612470565b6102616004803603602081101561064a57600080fd5b5035600160a060020a0316612475565b61028f6004803603604081101561067057600080fd5b50600160a060020a038135169060200135612624565b6102616004803603602081101561069c57600080fd5b5035600160a060020a0316612864565b6103f9612a4b565b610315612a50565b61028f600480360360808110156106d257600080fd5b50600160a060020a03813581169160208101358216916040820135916060013516612a5f565b6102616004803603604081101561070e57600080fd5b5080359060200135600160a060020a0316612ccb565b610315612d95565b6103f9612470565b6103576004803603608081101561074a57600080fd5b50600160a060020a03813581169160208101359091169060408101359060600135612da4565b610315612fc3565b6103f9612fd2565b600054600160a060020a031633146107d0576040805160e560020a62461bcd02815260206004820152601a6024820152600080516020613866833981519152604482015290519081900360640190fd5b600160a060020a03811660009081526003602052604090205460ff161515610842576040805160e560020a62461bcd02815260206004820152601660248201527f616c6572746572206e6f7420636f6e6669677572656400000000000000000000604482015290519081900360640190fd5b600160a060020a0381166000908152600360205260408120805460ff191690555b6005548110156109675781600160a060020a031660058281548110151561088657fe5b600091825260209091200154600160a060020a0316141561095f576005805460001981019081106108b357fe5b60009182526020909120015460058054600160a060020a0390921691839081106108d957fe5b60009182526020909120018054600160a060020a031916600160a060020a0392909216919091179055600580549061091590600019830161381e565b5060408051600160a060020a03841681526000602082015281517f5611bf3e417d124f97bf2c788843ea8bb502b66079fbee02158ef30b172cb762929181900390910190a1610967565b600101610863565b5050565b3360009081526002602052604081205460ff1615156109d4576040805160e560020a62461bcd02815260206004820152601d60248201527f4f7065726174696f6e206c696d6974656420746f206f70657261746f72000000604482015290519081900360640190fd5b600654604080517ff3fef3a3000000000000000000000000000000000000000000000000000000008152600160a060020a038681166004830152602482018690529151600093929092169163f3fef3a39160448082019260209290919082900301818787803b158015610a4657600080fd5b505af1158015610a5a573d6000803e3d6000fd5b505050506040513d6020811015610a7057600080fd5b5051604080518281529051919250600160a060020a038616917f8ca99ea44887b22237c635176fab07cb68194e3cc222130f2a1645db6c5722329181900360200190a290505b92915050565b600654604080517fc1a21bf3000000000000000000000000000000000000000000000000000000008152600160a060020a03868116600483015285811660248301526044820185905230606483015291516000938493849391169163c1a21bf391608480820192602092909190829003018186803b158015610b3d57600080fd5b505afa158015610b51573d6000803e3d6000fd5b505050506040513d6020811015610b6757600080fd5b505190506000811115610c1c57600654604080517f65054e55000000000000000000000000000000000000000000000000000000008152600160a060020a03898116600483015288811660248301523060448301526064820188905282519316926365054e55926084808401939192918290030181600087803b158015610bed57600080fd5b505af1158015610c01573d6000803e3d6000fd5b505050506040513d6040811015610c1757600080fd5b505192505b600654604080517f37775807000000000000000000000000000000000000000000000000000000008152600160a060020a038981166004830152888116602483015260448201889052306064830152915191909216916337775807916084808301926020929190829003018186803b158015610c9757600080fd5b505afa158015610cab573d6000803e3d6000fd5b505050506040513d6020811015610cc157600080fd5b505190506000811115610d7657600654604080517fb0293850000000000000000000000000000000000000000000000000000000008152600160a060020a038981166004830152888116602483015230604483015260648201889052825193169263b0293850926084808401939192918290030181600087803b158015610d4757600080fd5b505af1158015610d5b573d6000803e3d6000fd5b505050506040513d6040811015610d7157600080fd5b505191505b50935093915050565b600654604080517fedd0b5cb000000000000000000000000000000000000000000000000000000008152336004820152815160009384938493600160a060020a039092169263edd0b5cb926024808201939291829003018186803b158015610de657600080fd5b505afa158015610dfa573d6000803e3d6000fd5b505050506040513d6040811015610e1057600080fd5b5080516020909101519092509050610e3a610e2b8583612fd7565b610e358385613009565b61301e565b925050505b919050565b600154600160a060020a031681565b60008054600160a060020a03163314610ea4576040805160e560020a62461bcd02815260206004820152601a6024820152600080516020613866833981519152604482015290519081900360640190fd5b600160a060020a0382161515610eee5760405160e560020a62461bcd02815260040180806020018281038252602581526020018061394a6025913960400191505060405180910390fd5b60088054600160a060020a031916600160a060020a03848116919091179182905560408051929091168252517f5c4c43d08230e2663cfcdd295f5d342988919c23fe1f7d2e61babb285f5079b5916020908290030190a1506001919050565b60606004805480602002602001604051908101604052809291908181526020018280548015610fa557602002820191906000526020600020905b8154600160a060020a03168152600190910190602001808311610f87575b505050505090505b90565b600654604080517fb64c4905000000000000000000000000000000000000000000000000000000008152600160a060020a038581166004830152848116602483015291516000938493169163b64c4905916044808301926020929190829003018186803b15801561102057600080fd5b505afa158015611034573d6000803e3d6000fd5b505050506040513d602081101561104a57600080fd5b50519050600061105985611701565b9050818111156110765761106d8183613009565b92505050610ab6565b506000949350505050565b600481565b600960209081526000928352604080842090915290825290205481565b6000808212156110b557506000610e3f565b5080610e3f565b60008084600160a060020a031663313ce5676040518163ffffffff1660e060020a02815260040160206040518083038186803b1580156110fb57600080fd5b505afa15801561110f573d6000803e3d6000fd5b505050506040513d602081101561112557600080fd5b5051601214801561119d575083600160a060020a031663313ce5676040518163ffffffff1660e060020a02815260040160206040518083038186803b15801561116d57600080fd5b505afa158015611181573d6000803e3d6000fd5b505050506040513d602081101561119757600080fd5b50516012145b15156111dd5760405160e560020a62461bcd0281526004018080602001828103825260258152602001806138d66025913960400191505060405180910390fd5b600754600090600160a060020a038781169116146111fb5785611211565b73eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee5b600754909150600090600160a060020a038781169116146112325785611248565b73eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee5b600854604080517f809a9e55000000000000000000000000000000000000000000000000000000008152600160a060020a0386811660048301528085166024830152604482018a9052825194955060009493169263809a9e5592606480840193919291829003018186803b1580156112bf57600080fd5b505afa1580156112d3573d6000803e3d6000fd5b505050506040513d60408110156112e957600080fd5b505198670de0b6b3a764000098509650505050505050565b600054600160a060020a03163314611351576040805160e560020a62461bcd02815260206004820152601a6024820152600080516020613866833981519152604482015290519081900360640190fd5b82600160a060020a031663a9059cbb82846040518363ffffffff1660e060020a0281526004018083600160a060020a0316600160a060020a0316815260200182815260200192505050602060405180830381600087803b1580156113b457600080fd5b505af11580156113c8573d6000803e3d6000fd5b505050506040513d60208110156113de57600080fd5b50511515611436576040805160e560020a62461bcd02815260206004820152601960248201527f436f756c64206e6f74207472616e7366657220746f6b656e7300000000000000604482015290519081900360640190fd5b80600160a060020a031683600160a060020a03167f72cb8a894ddb372ceec3d2a7648d86f17d5a15caae0e986c53109b8a9a9385e6846040518082815260200191505060405180910390a3505050565b600754600160a060020a031681565b600054600160a060020a031633146114e5576040805160e560020a62461bcd02815260206004820152601a6024820152600080516020613866833981519152604482015290519081900360640190fd5b600160a060020a03811660009081526003602052604090205460ff1615611556576040805160e560020a62461bcd02815260206004820152601a60248201527f616c657274657220616c726561647920636f6e66696775726564000000000000604482015290519081900360640190fd5b60055460321161159a5760405160e560020a62461bcd0281526004018080602001828103825260248152602001806138fb6024913960400191505060405180910390fd5b60408051600160a060020a03831681526001602082015281517f5611bf3e417d124f97bf2c788843ea8bb502b66079fbee02158ef30b172cb762929181900390910190a1600160a060020a03166000818152600360205260408120805460ff191660019081179091556005805491820181559091527f036b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db0018054600160a060020a0319169091179055565b600081565b600654604080517fc1a21bf3000000000000000000000000000000000000000000000000000000008152600160a060020a03878116600483015286811660248301526044820186905284811660648301529151600093929092169163c1a21bf391608480820192602092909190829003018186803b1580156116ca57600080fd5b505afa1580156116de573d6000803e3d6000fd5b505050506040513d60208110156116f457600080fd5b505190505b949350505050565b600654604080517ff41d97fc000000000000000000000000000000000000000000000000000000008152600160a060020a038481166004830152825160009485948594939091169263f41d97fc9260248083019392829003018186803b15801561176a57600080fd5b505afa15801561177e573d6000803e3d6000fd5b505050506040513d604081101561179457600080fd5b508051602091820151600654604080517fee93114c000000000000000000000000000000000000000000000000000000008152905193965091945061194e9361183693600160a060020a039092169263ee93114c9260048083019392829003018186803b15801561180457600080fd5b505afa158015611818573d6000803e3d6000fd5b505050506040513d602081101561182e57600080fd5b505183612fd7565b600654604080517f706eb3ab0000000000000000000000000000000000000000000000000000000081529051610e3592600160a060020a03169163706eb3ab916004808301926020929190829003018186803b15801561189557600080fd5b505afa1580156118a9573d6000803e3d6000fd5b505050506040513d60208110156118bf57600080fd5b5051604080517fa3ca17b20000000000000000000000000000000000000000000000000000000081529051600160a060020a039092169163a3ca17b291600480820192602092909190829003018186803b15801561191c57600080fd5b505afa158015611930573d6000803e3d6000fd5b505050506040513d602081101561194657600080fd5b505185612fd7565b600101949350505050565b600054600160a060020a031633146119a9576040805160e560020a62461bcd02815260206004820152601a6024820152600080516020613866833981519152604482015290519081900360640190fd5b600160a060020a0381161515611a09576040805160e560020a62461bcd02815260206004820152601960248201527f61646d696e20616464726573732063616e6e6f74206265203000000000000000604482015290519081900360640190fd5b60015460408051600160a060020a039092168252517f3b81caf78fa51ecbc8acb482fd7012a277b428d9b80f9d156e8a54107496cc409181900360200190a160018054600160a060020a031916600160a060020a0392909216919091179055565b600154600160a060020a03163314611acc576040805160e560020a62461bcd02815260206004820152601960248201527f61646d696e20616464726573732063616e6e6f74206265203000000000000000604482015290519081900360640190fd5b60015460005460408051600160a060020a03938416815292909116602083015280517f65da1cfc2c2e81576ad96afb24a581f8e109b7a403b35cbd3243a1c99efdb9ed9281900390910190a16001805460008054600160a060020a0319908116600160a060020a03841617909155169055565b600054600160a060020a03163314611b8f576040805160e560020a62461bcd02815260206004820152601a6024820152600080516020613866833981519152604482015290519081900360640190fd5b600160a060020a0381161515611bef576040805160e560020a62461bcd02815260206004820152601960248201527f61646d696e20616464726573732063616e6e6f74206265203000000000000000604482015290519081900360640190fd5b60408051600160a060020a038316815290517f3b81caf78fa51ecbc8acb482fd7012a277b428d9b80f9d156e8a54107496cc409181900360200190a160005460408051600160a060020a038085168252909216602083015280517f65da1cfc2c2e81576ad96afb24a581f8e109b7a403b35cbd3243a1c99efdb9ed9281900390910190a160008054600160a060020a031916600160a060020a0392909216919091179055565b60606005805480602002602001604051908101604052809291908181526020018280548015610fa557602002820191906000526020600020908154600160a060020a03168152600190910190602001808311610f87575050505050905090565b3360009081526002602052604081205460ff161515611d5e576040805160e560020a62461bcd02815260206004820152601d60248201527f4f7065726174696f6e206c696d6974656420746f206f70657261746f72000000604482015290519081900360640190fd5b82600160a060020a031663313ce5676040518163ffffffff1660e060020a02815260040160206040518083038186803b158015611d9a57600080fd5b505afa158015611dae573d6000803e3d6000fd5b505050506040513d6020811015611dc457600080fd5b50516012148015611e3c575081600160a060020a031663313ce5676040518163ffffffff1660e060020a02815260040160206040518083038186803b158015611e0c57600080fd5b505afa158015611e20573d6000803e3d6000fd5b505050506040513d6020811015611e3657600080fd5b50516012145b1515611e7c5760405160e560020a62461bcd0281526004018080602001828103825260258152602001806138d66025913960400191505060405180910390fd5b611e8583613042565b50611e8f82613042565b506000611e9c848461220a565b6006546040805160e060020a6314584a9d028152600160a060020a0388811660048301528781166024830152915193945060009391909216916314584a9d916044808301926020929190829003018186803b158015611efa57600080fd5b505afa158015611f0e573d6000803e3d6000fd5b505050506040513d6020811015611f2457600080fd5b5051604051818152909150600160a060020a0380861691908716907f25b5003020461bc1f47e2c60ffb06705fed1787b8e11c801e4b323beb3d5fc7a908490869060208101826005811115611f7557fe5b60ff1681526020019250505060405180910390a36000826005811115611f9757fe5b1415611ff257600160a060020a03808616600090815260096020908152604080832093881683529290522054611fd09086908690610abc565b5050611fdc85856130eb565b1515611fe757600080fd5b600192505050610ab6565b600182600581111561200057fe5b14806120175750600282600581111561201557fe5b145b1561202757600092505050610ab6565b600382600581111561203557fe5b14156120605761204685858361339c565b156120555761106d85856134ff565b600092505050610ab6565b600482600581111561206e57fe5b141561207f57600092505050610ab6565b600582600581111561208d57fe5b14156121ba57600654604080517f821b98f3000000000000000000000000000000000000000000000000000000008152600160a060020a0388811660048301528781166024830152604482018590529151919092169163821b98f391606480830192600092919082900301818387803b15801561210957600080fd5b505af115801561211d573d6000803e3d6000fd5b5050600654604080517f821b98f3000000000000000000000000000000000000000000000000000000008152600160a060020a0389811660048301528a8116602483015260448201879052915191909216935063821b98f39250606480830192600092919082900301818387803b15801561219757600080fd5b505af11580156121ab573d6000803e3d6000fd5b50505050600192505050610ab6565b6040805160e560020a62461bcd02815260206004820152601560248201527f556e6b6e6f776e2061756374696f6e2073746174650000000000000000000000604482015290519081900360640190fd5b600654604080517fdae595e5000000000000000000000000000000000000000000000000000000008152600160a060020a038581166004830152848116602483015291516000938493169163dae595e5916044808301926020929190829003018186803b15801561227a57600080fd5b505afa15801561228e573d6000803e3d6000fd5b505050506040513d60208110156122a457600080fd5b5051905060018114156122d75760006122bd8585610fb0565b11156122cd576000915050610ab6565b6001915050610ab6565b428111156123055760006122eb8585610fb0565b11156122fb576000915050610ab6565b6002915050610ab6565b62015180814203111561231c576005915050610ab6565b6006546040805160e060020a6314584a9d028152600160a060020a0387811660048301528681166024830152915160009392909216916314584a9d91604480820192602092909190829003018186803b15801561237857600080fd5b505afa15801561238c573d6000803e3d6000fd5b505050506040513d60208110156123a257600080fd5b5051600654604080517febcc0de1000000000000000000000000000000000000000000000000000000008152600160a060020a038981166004830152888116602483015260448201859052825194955060009493169263ebcc0de192606480840193919291829003018186803b15801561241b57600080fd5b505afa15801561242f573d6000803e3d6000fd5b505050506040513d604081101561244557600080fd5b5060200151905080151561245f5760039350505050610ab6565b50600495945050505050565b600281565b600181565b600054600160a060020a031633146124c5576040805160e560020a62461bcd02815260206004820152601a6024820152600080516020613866833981519152604482015290519081900360640190fd5b600160a060020a03811660009081526002602052604090205460ff1615612536576040805160e560020a62461bcd02815260206004820152601b60248201527f6f70657261746f7220616c726561647920636f6e666967757265640000000000604482015290519081900360640190fd5b60045460321161257a5760405160e560020a62461bcd0281526004018080602001828103825260258152602001806138866025913960400191505060405180910390fd5b60408051600160a060020a03831681526001602082015281517f091a7a4b85135fdd7e8dbc18b12fabe5cc191ea867aa3c2e1a24a102af61d58b929181900390910190a1600160a060020a03166000818152600260205260408120805460ff191660019081179091556004805491820181559091527f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b018054600160a060020a0319169091179055565b3360009081526002602052604081205460ff16151561268d576040805160e560020a62461bcd02815260206004820152601d60248201527f4f7065726174696f6e206c696d6974656420746f206f70657261746f72000000604482015290519081900360640190fd5b600654604080517f095ea7b3000000000000000000000000000000000000000000000000000000008152600160a060020a0392831660048201526024810185905290519185169163095ea7b3916044808201926020929091908290030181600087803b1580156126fc57600080fd5b505af1158015612710573d6000803e3d6000fd5b505050506040513d602081101561272657600080fd5b5051151561277e576040805160e560020a62461bcd02815260206004820152601660248201527f43616e6e6f7420617070726f7665206465706f73697400000000000000000000604482015290519081900360640190fd5b600654604080517f47e7ef24000000000000000000000000000000000000000000000000000000008152600160a060020a03868116600483015260248201869052915160009392909216916347e7ef249160448082019260209290919082900301818787803b1580156127f057600080fd5b505af1158015612804573d6000803e3d6000fd5b505050506040513d602081101561281a57600080fd5b5051604080518281529051919250600160a060020a038616917f3f8bb2cdbbcd382334e1cd4bbc92735b2671465c034f5f16b524a738f11e64689181900360200190a29392505050565b600054600160a060020a031633146128b4576040805160e560020a62461bcd02815260206004820152601a6024820152600080516020613866833981519152604482015290519081900360640190fd5b600160a060020a03811660009081526002602052604090205460ff161515612926576040805160e560020a62461bcd02815260206004820152601760248201527f6f70657261746f72206e6f7420636f6e66696775726564000000000000000000604482015290519081900360640190fd5b600160a060020a0381166000908152600260205260408120805460ff191690555b6004548110156109675781600160a060020a031660048281548110151561296a57fe5b600091825260209091200154600160a060020a03161415612a435760048054600019810190811061299757fe5b60009182526020909120015460048054600160a060020a0390921691839081106129bd57fe5b60009182526020909120018054600160a060020a031916600160a060020a03929092169190911790556004805460001901906129f9908261381e565b5060408051600160a060020a03841681526000602082015281517f091a7a4b85135fdd7e8dbc18b12fabe5cc191ea867aa3c2e1a24a102af61d58b929181900390910190a1610967565b600101612947565b600381565b600654600160a060020a031681565b600080612a6e86868686611649565b600654604080517ffdab1b7b000000000000000000000000000000000000000000000000000000008152600160a060020a038a8116600483015289811660248301526044820189905282519495506000948594919091169263fdab1b7b9260648082019391829003018186803b158015612ae757600080fd5b505afa158015612afb573d6000803e3d6000fd5b505050506040513d6040811015612b1157600080fd5b5080516020909101519092509050801515612b3257600093505050506116f9565b6000612b47612b418585612fd7565b8361301e565b600654604080517fb64c4905000000000000000000000000000000000000000000000000000000008152600160a060020a038d811660048301528c811660248301529151939450600093919092169163b64c4905916044808301926020929190829003018186803b158015612bbb57600080fd5b505afa158015612bcf573d6000803e3d6000fd5b505050506040513d6020811015612be557600080fd5b5051600654604080517fb8beafd6000000000000000000000000000000000000000000000000000000008152600160a060020a038e811660048301528d811660248301529151939450600093919092169163b8beafd6916044808301926020929190829003018186803b158015612c5b57600080fd5b505afa158015612c6f573d6000803e3d6000fd5b505050506040513d6020811015612c8557600080fd5b505190506000612caa8286612c9a868a612fd7565b811515612ca357fe5b04036110a3565b9050808410612cb95780612cbb565b835b9c9b505050505050505050505050565b600054600160a060020a03163314612d1b576040805160e560020a62461bcd02815260206004820152601a6024820152600080516020613866833981519152604482015290519081900360640190fd5b604051600160a060020a0382169083156108fc029084906000818181858888f19350505050158015612d51573d6000803e3d6000fd5b50604080518381529051600160a060020a038316917fec47e7ed86c86774d1a72c19f35c639911393fe7c1a34031fdbd260890da90de919081900360200190a25050565b600854600160a060020a031681565b600654604080517fb8beafd6000000000000000000000000000000000000000000000000000000008152600160a060020a038781166004830152868116602483015291516000938493169163b8beafd6916044808301926020929190829003018186803b158015612e1457600080fd5b505afa158015612e28573d6000803e3d6000fd5b505050506040513d6020811015612e3e57600080fd5b5051600654604080517fb64c4905000000000000000000000000000000000000000000000000000000008152600160a060020a038a8116600483015289811660248301529151939450600093919092169163b64c4905916044808301926020929190829003018186803b158015612eb457600080fd5b505afa158015612ec8573d6000803e3d6000fd5b505050506040513d6020811015612ede57600080fd5b5051600654604080517ffdab1b7b000000000000000000000000000000000000000000000000000000008152600160a060020a038b811660048301528a81166024830152604482018a905282519495506000948594919091169263fdab1b7b9260648082019391829003018186803b158015612f5957600080fd5b505afa158015612f6d573d6000803e3d6000fd5b505050506040513d6040811015612f8357600080fd5b50805160209091015190925090506000612fb2612fad612fa38686612fd7565b610e358589613009565b6110a3565b909610159998505050505050505050565b600054600160a060020a031681565b600581565b6000821515612fe857506000610ab6565b828202828482811515612ff757fe5b041461300257600080fd5b9392505050565b60008282111561301857600080fd5b50900390565b600080821161302c57600080fd5b6000828481151561303957fe5b04949350505050565b600080600083600160a060020a03166370a08231306040518263ffffffff1660e060020a0281526004018082600160a060020a0316600160a060020a0316815260200191505060206040518083038186803b1580156130a057600080fd5b505afa1580156130b4573d6000803e3d6000fd5b505050506040513d60208110156130ca57600080fd5b5051905060008111156130e4576130e18482612624565b91505b5092915050565b6000806130f88484610fb0565b9050600061310582610d7f565b905080151561311957600092505050610ab6565b600654604080517fc23f001f000000000000000000000000000000000000000000000000000000008152600160a060020a0388811660048301523060248301529151600093929092169163c23f001f91604480820192602092909190829003018186803b15801561318957600080fd5b505afa15801561319d573d6000803e3d6000fd5b505050506040513d60208110156131b357600080fd5b50519050818110156131f95760405160e560020a62461bcd02815260040180806020018281038252602b81526020018061391f602b913960400191505060405180910390fd5b6006546040805160e060020a6314584a9d028152600160a060020a0389811660048301528881166024830152915160009392909216916314584a9d91604480820192602092909190829003018186803b15801561325557600080fd5b505afa158015613269573d6000803e3d6000fd5b505050506040513d602081101561327f57600080fd5b5051600654604080517f59f96ae5000000000000000000000000000000000000000000000000000000008152600160a060020a038b811660048301528a8116602483015260448201859052606482018890528251949550909216926359f96ae59260848082019392918290030181600087803b1580156132fe57600080fd5b505af1158015613312573d6000803e3d6000fd5b505050506040513d604081101561332857600080fd5b5050600160a060020a038088166000818152600960209081526040808320948b168084529482529182902085905581518881529081018790528151859493927f9bcb067908e8dfb53d8eac0657e8f5b12a2ee96bd8226c7ead1393775ac4eb44928290030190a45060019695505050505050565b6000806133ab85858530612a5f565b600654604080517ffdab1b7b000000000000000000000000000000000000000000000000000000008152600160a060020a03898116600483015288811660248301526044820188905282519495506000948594919091169263fdab1b7b9260648082019391829003018186803b15801561342457600080fd5b505afa158015613438573d6000803e3d6000fd5b505050506040513d604081101561344e57600080fd5b508051602090910151909250905060008061346a8989876110bc565b9092509050600061347b8385612fd7565b6134858684612fd7565b604080518b8152602081018a9052808201899052606081018890526080810187905260a08101869052905192909111159250600160a060020a03808c1692908d16917f4bec7f25bd7b6891fe2081432d664b3ba85f137f20b4c1052ca7f3d971b695db919081900360c00190a39998505050505050505050565b6000600361350d848461220a565b600581111561351857fe5b1461356d576040805160e560020a62461bcd02815260206004820152601660248201527f4e6f2061756374696f6e20696e2070726f677265737300000000000000000000604482015290519081900360640190fd5b6006546040805160e060020a6314584a9d028152600160a060020a0386811660048301528581166024830152915160009392909216916314584a9d91604480820192602092909190829003018186803b1580156135c957600080fd5b505afa1580156135dd573d6000803e3d6000fd5b505050506040513d60208110156135f357600080fd5b50519050600061360585858430612a5f565b905080151561361957600092505050610ab6565b600061362786868585612da4565b905080151561363c5761363982610d7f565b91505b600654604080517fc23f001f000000000000000000000000000000000000000000000000000000008152600160a060020a03888116600483015230602483015291518593929092169163c23f001f91604480820192602092909190829003018186803b1580156136ab57600080fd5b505afa1580156136bf573d6000803e3d6000fd5b505050506040513d60208110156136d557600080fd5b505110156137175760405160e560020a62461bcd02815260040180806020018281038252602b8152602001806138ab602b913960400191505060405180910390fd5b600654604080517f5e7f22c2000000000000000000000000000000000000000000000000000000008152600160a060020a0389811660048301528881166024830152604482018790526064820186905291519190921691635e7f22c29160848083019260209291908290030181600087803b15801561379557600080fd5b505af11580156137a9573d6000803e3d6000fd5b505050506040513d60208110156137bf57600080fd5b50506040805184815260208101849052821515818301529051600160a060020a0380881692908916917f733d70430ecff67a78fe6afd1a2bf3fee1466721b16dc0a24c1d33b0e5e1dc169181900360600190a350600195945050505050565b81548183558181111561384257600083815260209020613842918101908301613847565b505050565b610fad91905b80821115613861576000815560010161384d565b509056fe4f7065726174696f6e206c696d6974656420746f2061646d696e0000000000006f70657261746f722067726f757020657863656564696e67206d6178696d756d2073697a654e6f7420656e6f7567682062757920746f6b656e20746f2062757920726571756972656420616d6f756e744f6e6c7920313820646563696d616c7320746f6b656e732061726520737570706f72746564616c65727465722067726f757020657863656564696e67206d6178696d756d2073697a654e6f7420656e6f75676820746f6b656e7320746f2066756e642061756374696f6e20646972656374696f6e4b796265724e6574776f726b50726f787920616464726573732063616e6e6f742062652030a165627a7a723058207a09d8334a183518491d0495fa00fbcd70969d4c08fa33d194435671c897d9f40029447574636845786368616e676520616464726573732063616e6e6f7420626520304b796265724e6574776f726b50726f787920616464726573732063616e6e6f742062652030000000000000000000000000b9812e2fa995ec53b5b6df34d21f9304762c5497000000000000000000000000818e6fecd516ecc3849daf6845e3ec868087b755",
  "constructorArguments": "000000000000000000000000b9812e2fa995ec53b5b6df34d21f9304762c5497000000000000000000000000818e6fecd516ecc3849daf6845e3ec868087b755"
}