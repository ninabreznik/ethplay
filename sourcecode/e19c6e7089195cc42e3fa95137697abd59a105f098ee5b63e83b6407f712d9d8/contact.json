{
  "address": "0xbd79bd7cf92229f97f975d4c8a703b74c9707865",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "ServiceController",
  "compilerVersion": "v0.4.19+commit.c4cbbb05",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2018-10-01\n*/\n\npragma solidity ^0.4.11;\n\n/**\n * @title Owned contract with safe ownership pass.\n *\n * Note: all the non constant functions return false instead of throwing in case if state change\n * didn't happen yet.\n */\ncontract Owned {\n    /**\n     * Contract owner address\n     */\n    address public contractOwner;\n\n    /**\n     * Contract owner address\n     */\n    address public pendingContractOwner;\n\n    function Owned() {\n        contractOwner = msg.sender;\n    }\n\n    /**\n    * @dev Owner check modifier\n    */\n    modifier onlyContractOwner() {\n        if (contractOwner == msg.sender) {\n            _;\n        }\n    }\n\n    /**\n     * @dev Destroy contract and scrub a data\n     * @notice Only owner can call it\n     */\n    function destroy() onlyContractOwner {\n        suicide(msg.sender);\n    }\n\n    /**\n     * Prepares ownership pass.\n     *\n     * Can only be called by current owner.\n     *\n     * @param _to address of the next owner. 0x0 is not allowed.\n     *\n     * @return success.\n     */\n    function changeContractOwnership(address _to) onlyContractOwner() returns(bool) {\n        if (_to  == 0x0) {\n            return false;\n        }\n\n        pendingContractOwner = _to;\n        return true;\n    }\n\n    /**\n     * Finalize ownership pass.\n     *\n     * Can only be called by pending owner.\n     *\n     * @return success.\n     */\n    function claimContractOwnership() returns(bool) {\n        if (pendingContractOwner != msg.sender) {\n            return false;\n        }\n\n        contractOwner = pendingContractOwner;\n        delete pendingContractOwner;\n\n        return true;\n    }\n}\n\ncontract ERC20Interface {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed from, address indexed spender, uint256 value);\n    string public symbol;\n\n    function totalSupply() constant returns (uint256 supply);\n    function balanceOf(address _owner) constant returns (uint256 balance);\n    function transfer(address _to, uint256 _value) returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n    function approve(address _spender, uint256 _value) returns (bool success);\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n}\n\n/**\n * @title Generic owned destroyable contract\n */\ncontract Object is Owned {\n    /**\n    *  Common result code. Means everything is fine.\n    */\n    uint constant OK = 1;\n    uint constant OWNED_ACCESS_DENIED_ONLY_CONTRACT_OWNER = 8;\n\n    function withdrawnTokens(address[] tokens, address _to) onlyContractOwner returns(uint) {\n        for(uint i=0;i<tokens.length;i++) {\n            address token = tokens[i];\n            uint balance = ERC20Interface(token).balanceOf(this);\n            if(balance != 0)\n                ERC20Interface(token).transfer(_to,balance);\n        }\n        return OK;\n    }\n\n    function checkOnlyContractOwner() internal constant returns(uint) {\n        if (contractOwner == msg.sender) {\n            return OK;\n        }\n\n        return OWNED_ACCESS_DENIED_ONLY_CONTRACT_OWNER;\n    }\n}\n\n/**\n* @title SafeMath\n* @dev Math operations with safety checks that throw on error\n*/\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a * b;\n        assert(a == 0 || c / a == b);\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\ncontract GroupsAccessManagerEmitter {\n\n    event UserCreated(address user);\n    event UserDeleted(address user);\n    event GroupCreated(bytes32 groupName);\n    event GroupActivated(bytes32 groupName);\n    event GroupDeactivated(bytes32 groupName);\n    event UserToGroupAdded(address user, bytes32 groupName);\n    event UserFromGroupRemoved(address user, bytes32 groupName);\n}\n\n/// @title Group Access Manager\n///\n/// Base implementation\n/// This contract serves as group manager\ncontract GroupsAccessManager is Object, GroupsAccessManagerEmitter {\n\n    uint constant USER_MANAGER_SCOPE = 111000;\n    uint constant USER_MANAGER_MEMBER_ALREADY_EXIST = USER_MANAGER_SCOPE + 1;\n    uint constant USER_MANAGER_GROUP_ALREADY_EXIST = USER_MANAGER_SCOPE + 2;\n    uint constant USER_MANAGER_OBJECT_ALREADY_SECURED = USER_MANAGER_SCOPE + 3;\n    uint constant USER_MANAGER_CONFIRMATION_HAS_COMPLETED = USER_MANAGER_SCOPE + 4;\n    uint constant USER_MANAGER_USER_HAS_CONFIRMED = USER_MANAGER_SCOPE + 5;\n    uint constant USER_MANAGER_NOT_ENOUGH_GAS = USER_MANAGER_SCOPE + 6;\n    uint constant USER_MANAGER_INVALID_INVOCATION = USER_MANAGER_SCOPE + 7;\n    uint constant USER_MANAGER_DONE = USER_MANAGER_SCOPE + 11;\n    uint constant USER_MANAGER_CANCELLED = USER_MANAGER_SCOPE + 12;\n\n    using SafeMath for uint;\n\n    struct Member {\n        address addr;\n        uint groupsCount;\n        mapping(bytes32 => uint) groupName2index;\n        mapping(uint => uint) index2globalIndex;\n    }\n\n    struct Group {\n        bytes32 name;\n        uint priority;\n        uint membersCount;\n        mapping(address => uint) memberAddress2index;\n        mapping(uint => uint) index2globalIndex;\n    }\n\n    uint public membersCount;\n    mapping(uint => address) index2memberAddress;\n    mapping(address => uint) memberAddress2index;\n    mapping(address => Member) address2member;\n\n    uint public groupsCount;\n    mapping(uint => bytes32) index2groupName;\n    mapping(bytes32 => uint) groupName2index;\n    mapping(bytes32 => Group) groupName2group;\n    mapping(bytes32 => bool) public groupsBlocked; // if groupName => true, then couldn't be used for confirmation\n\n    function() payable public {\n        revert();\n    }\n\n    /// @notice Register user\n    /// Can be called only by contract owner\n    ///\n    /// @param _user user address\n    ///\n    /// @return code\n    function registerUser(address _user) external onlyContractOwner returns (uint) {\n        require(_user != 0x0);\n\n        if (isRegisteredUser(_user)) {\n            return USER_MANAGER_MEMBER_ALREADY_EXIST;\n        }\n\n        uint _membersCount = membersCount.add(1);\n        membersCount = _membersCount;\n        memberAddress2index[_user] = _membersCount;\n        index2memberAddress[_membersCount] = _user;\n        address2member[_user] = Member(_user, 0);\n\n        UserCreated(_user);\n        return OK;\n    }\n\n    /// @notice Discard user registration\n    /// Can be called only by contract owner\n    ///\n    /// @param _user user address\n    ///\n    /// @return code\n    function unregisterUser(address _user) external onlyContractOwner returns (uint) {\n        require(_user != 0x0);\n\n        uint _memberIndex = memberAddress2index[_user];\n        if (_memberIndex == 0 || address2member[_user].groupsCount != 0) {\n            return USER_MANAGER_INVALID_INVOCATION;\n        }\n\n        uint _membersCount = membersCount;\n        delete memberAddress2index[_user];\n        if (_memberIndex != _membersCount) {\n            address _lastUser = index2memberAddress[_membersCount];\n            index2memberAddress[_memberIndex] = _lastUser;\n            memberAddress2index[_lastUser] = _memberIndex;\n        }\n        delete address2member[_user];\n        delete index2memberAddress[_membersCount];\n        delete memberAddress2index[_user];\n        membersCount = _membersCount.sub(1);\n\n        UserDeleted(_user);\n        return OK;\n    }\n\n    /// @notice Create group\n    /// Can be called only by contract owner\n    ///\n    /// @param _groupName group name\n    /// @param _priority group priority\n    ///\n    /// @return code\n    function createGroup(bytes32 _groupName, uint _priority) external onlyContractOwner returns (uint) {\n        require(_groupName != bytes32(0));\n\n        if (isGroupExists(_groupName)) {\n            return USER_MANAGER_GROUP_ALREADY_EXIST;\n        }\n\n        uint _groupsCount = groupsCount.add(1);\n        groupName2index[_groupName] = _groupsCount;\n        index2groupName[_groupsCount] = _groupName;\n        groupName2group[_groupName] = Group(_groupName, _priority, 0);\n        groupsCount = _groupsCount;\n\n        GroupCreated(_groupName);\n        return OK;\n    }\n\n    /// @notice Change group status\n    /// Can be called only by contract owner\n    ///\n    /// @param _groupName group name\n    /// @param _blocked block status\n    ///\n    /// @return code\n    function changeGroupActiveStatus(bytes32 _groupName, bool _blocked) external onlyContractOwner returns (uint) {\n        require(isGroupExists(_groupName));\n        groupsBlocked[_groupName] = _blocked;\n        return OK;\n    }\n\n    /// @notice Add users in group\n    /// Can be called only by contract owner\n    ///\n    /// @param _groupName group name\n    /// @param _users user array\n    ///\n    /// @return code\n    function addUsersToGroup(bytes32 _groupName, address[] _users) external onlyContractOwner returns (uint) {\n        require(isGroupExists(_groupName));\n\n        Group storage _group = groupName2group[_groupName];\n        uint _groupMembersCount = _group.membersCount;\n\n        for (uint _userIdx = 0; _userIdx < _users.length; ++_userIdx) {\n            address _user = _users[_userIdx];\n            uint _memberIndex = memberAddress2index[_user];\n            require(_memberIndex != 0);\n\n            if (_group.memberAddress2index[_user] != 0) {\n                continue;\n            }\n\n            _groupMembersCount = _groupMembersCount.add(1);\n            _group.memberAddress2index[_user] = _groupMembersCount;\n            _group.index2globalIndex[_groupMembersCount] = _memberIndex;\n\n            _addGroupToMember(_user, _groupName);\n\n            UserToGroupAdded(_user, _groupName);\n        }\n        _group.membersCount = _groupMembersCount;\n\n        return OK;\n    }\n\n    /// @notice Remove users in group\n    /// Can be called only by contract owner\n    ///\n    /// @param _groupName group name\n    /// @param _users user array\n    ///\n    /// @return code\n    function removeUsersFromGroup(bytes32 _groupName, address[] _users) external onlyContractOwner returns (uint) {\n        require(isGroupExists(_groupName));\n\n        Group storage _group = groupName2group[_groupName];\n        uint _groupMembersCount = _group.membersCount;\n\n        for (uint _userIdx = 0; _userIdx < _users.length; ++_userIdx) {\n            address _user = _users[_userIdx];\n            uint _memberIndex = memberAddress2index[_user];\n            uint _groupMemberIndex = _group.memberAddress2index[_user];\n\n            if (_memberIndex == 0 || _groupMemberIndex == 0) {\n                continue;\n            }\n\n            if (_groupMemberIndex != _groupMembersCount) {\n                uint _lastUserGlobalIndex = _group.index2globalIndex[_groupMembersCount];\n                address _lastUser = index2memberAddress[_lastUserGlobalIndex];\n                _group.index2globalIndex[_groupMemberIndex] = _lastUserGlobalIndex;\n                _group.memberAddress2index[_lastUser] = _groupMemberIndex;\n            }\n            delete _group.memberAddress2index[_user];\n            delete _group.index2globalIndex[_groupMembersCount];\n            _groupMembersCount = _groupMembersCount.sub(1);\n\n            _removeGroupFromMember(_user, _groupName);\n\n            UserFromGroupRemoved(_user, _groupName);\n        }\n        _group.membersCount = _groupMembersCount;\n\n        return OK;\n    }\n\n    /// @notice Check is user registered\n    ///\n    /// @param _user user address\n    ///\n    /// @return status\n    function isRegisteredUser(address _user) public view returns (bool) {\n        return memberAddress2index[_user] != 0;\n    }\n\n    /// @notice Check is user in group\n    ///\n    /// @param _groupName user array\n    /// @param _user user array\n    ///\n    /// @return status\n    function isUserInGroup(bytes32 _groupName, address _user) public view returns (bool) {\n        return isRegisteredUser(_user) && address2member[_user].groupName2index[_groupName] != 0;\n    }\n\n    /// @notice Check is group exist\n    ///\n    /// @param _groupName group name\n    ///\n    /// @return status\n    function isGroupExists(bytes32 _groupName) public view returns (bool) {\n        return groupName2index[_groupName] != 0;\n    }\n\n    /// @notice Get current group names\n    ///\n    /// @return group names\n    function getGroups() public view returns (bytes32[] _groups) {\n        uint _groupsCount = groupsCount;\n        _groups = new bytes32[](_groupsCount);\n        for (uint _groupIdx = 0; _groupIdx < _groupsCount; ++_groupIdx) {\n            _groups[_groupIdx] = index2groupName[_groupIdx + 1];\n        }\n    }\n\n    // PRIVATE\n\n    function _removeGroupFromMember(address _user, bytes32 _groupName) private {\n        Member storage _member = address2member[_user];\n        uint _memberGroupsCount = _member.groupsCount;\n        uint _memberGroupIndex = _member.groupName2index[_groupName];\n        if (_memberGroupIndex != _memberGroupsCount) {\n            uint _lastGroupGlobalIndex = _member.index2globalIndex[_memberGroupsCount];\n            bytes32 _lastGroupName = index2groupName[_lastGroupGlobalIndex];\n            _member.index2globalIndex[_memberGroupIndex] = _lastGroupGlobalIndex;\n            _member.groupName2index[_lastGroupName] = _memberGroupIndex;\n        }\n        delete _member.groupName2index[_groupName];\n        delete _member.index2globalIndex[_memberGroupsCount];\n        _member.groupsCount = _memberGroupsCount.sub(1);\n    }\n\n    function _addGroupToMember(address _user, bytes32 _groupName) private {\n        Member storage _member = address2member[_user];\n        uint _memberGroupsCount = _member.groupsCount.add(1);\n        _member.groupName2index[_groupName] = _memberGroupsCount;\n        _member.index2globalIndex[_memberGroupsCount] = groupName2index[_groupName];\n        _member.groupsCount = _memberGroupsCount;\n    }\n}\n\ncontract PendingManagerEmitter {\n\n    event PolicyRuleAdded(bytes4 sig, address contractAddress, bytes32 key, bytes32 groupName, uint acceptLimit, uint declinesLimit);\n    event PolicyRuleRemoved(bytes4 sig, address contractAddress, bytes32 key, bytes32 groupName);\n\n    event ProtectionTxAdded(bytes32 key, bytes32 sig, uint blockNumber);\n    event ProtectionTxAccepted(bytes32 key, address indexed sender, bytes32 groupNameVoted);\n    event ProtectionTxDone(bytes32 key);\n    event ProtectionTxDeclined(bytes32 key, address indexed sender, bytes32 groupNameVoted);\n    event ProtectionTxCancelled(bytes32 key);\n    event ProtectionTxVoteRevoked(bytes32 key, address indexed sender, bytes32 groupNameVoted);\n    event TxDeleted(bytes32 key);\n\n    event Error(uint errorCode);\n\n    function _emitError(uint _errorCode) internal returns (uint) {\n        Error(_errorCode);\n        return _errorCode;\n    }\n}\n\ncontract PendingManagerInterface {\n\n    function signIn(address _contract) external returns (uint);\n    function signOut(address _contract) external returns (uint);\n\n    function addPolicyRule(\n        bytes4 _sig, \n        address _contract, \n        bytes32 _groupName, \n        uint _acceptLimit, \n        uint _declineLimit \n        ) \n        external returns (uint);\n        \n    function removePolicyRule(\n        bytes4 _sig, \n        address _contract, \n        bytes32 _groupName\n        ) \n        external returns (uint);\n\n    function addTx(bytes32 _key, bytes4 _sig, address _contract) external returns (uint);\n    function deleteTx(bytes32 _key) external returns (uint);\n\n    function accept(bytes32 _key, bytes32 _votingGroupName) external returns (uint);\n    function decline(bytes32 _key, bytes32 _votingGroupName) external returns (uint);\n    function revoke(bytes32 _key) external returns (uint);\n\n    function hasConfirmedRecord(bytes32 _key) public view returns (uint);\n    function getPolicyDetails(bytes4 _sig, address _contract) public view returns (\n        bytes32[] _groupNames,\n        uint[] _acceptLimits,\n        uint[] _declineLimits,\n        uint _totalAcceptedLimit,\n        uint _totalDeclinedLimit\n        );\n}\n\n/// @title PendingManager\n///\n/// Base implementation\n/// This contract serves as pending manager for transaction status\ncontract PendingManager is Object, PendingManagerEmitter, PendingManagerInterface {\n\n    uint constant NO_RECORDS_WERE_FOUND = 4;\n    uint constant PENDING_MANAGER_SCOPE = 4000;\n    uint constant PENDING_MANAGER_INVALID_INVOCATION = PENDING_MANAGER_SCOPE + 1;\n    uint constant PENDING_MANAGER_HASNT_VOTED = PENDING_MANAGER_SCOPE + 2;\n    uint constant PENDING_DUPLICATE_TX = PENDING_MANAGER_SCOPE + 3;\n    uint constant PENDING_MANAGER_CONFIRMED = PENDING_MANAGER_SCOPE + 4;\n    uint constant PENDING_MANAGER_REJECTED = PENDING_MANAGER_SCOPE + 5;\n    uint constant PENDING_MANAGER_IN_PROCESS = PENDING_MANAGER_SCOPE + 6;\n    uint constant PENDING_MANAGER_TX_DOESNT_EXIST = PENDING_MANAGER_SCOPE + 7;\n    uint constant PENDING_MANAGER_TX_WAS_DECLINED = PENDING_MANAGER_SCOPE + 8;\n    uint constant PENDING_MANAGER_TX_WAS_NOT_CONFIRMED = PENDING_MANAGER_SCOPE + 9;\n    uint constant PENDING_MANAGER_INSUFFICIENT_GAS = PENDING_MANAGER_SCOPE + 10;\n    uint constant PENDING_MANAGER_POLICY_NOT_FOUND = PENDING_MANAGER_SCOPE + 11;\n\n    using SafeMath for uint;\n\n    enum GuardState {\n        Decline, Confirmed, InProcess\n    }\n\n    struct Requirements {\n        bytes32 groupName;\n        uint acceptLimit;\n        uint declineLimit;\n    }\n\n    struct Policy {\n        uint groupsCount;\n        mapping(uint => Requirements) participatedGroups; // index => globalGroupIndex\n        mapping(bytes32 => uint) groupName2index; // groupName => localIndex\n        \n        uint totalAcceptedLimit;\n        uint totalDeclinedLimit;\n\n        uint securesCount;\n        mapping(uint => uint) index2txIndex;\n        mapping(uint => uint) txIndex2index;\n    }\n\n    struct Vote {\n        bytes32 groupName;\n        bool accepted;\n    }\n\n    struct Guard {\n        GuardState state;\n        uint basePolicyIndex;\n\n        uint alreadyAccepted;\n        uint alreadyDeclined;\n        \n        mapping(address => Vote) votes; // member address => vote\n        mapping(bytes32 => uint) acceptedCount; // groupName => how many from group has already accepted\n        mapping(bytes32 => uint) declinedCount; // groupName => how many from group has already declined\n    }\n\n    address public accessManager;\n\n    mapping(address => bool) public authorized;\n\n    uint public policiesCount;\n    mapping(uint => bytes32) index2PolicyId; // index => policy hash\n    mapping(bytes32 => uint) policyId2Index; // policy hash => index\n    mapping(bytes32 => Policy) policyId2policy; // policy hash => policy struct\n\n    uint public txCount;\n    mapping(uint => bytes32) index2txKey;\n    mapping(bytes32 => uint) txKey2index; // tx key => index\n    mapping(bytes32 => Guard) txKey2guard;\n\n    /// @dev Execution is allowed only by authorized contract\n    modifier onlyAuthorized {\n        if (authorized[msg.sender] || address(this) == msg.sender) {\n            _;\n        }\n    }\n\n    /// @dev Pending Manager's constructor\n    ///\n    /// @param _accessManager access manager's address\n    function PendingManager(address _accessManager) public {\n        require(_accessManager != 0x0);\n        accessManager = _accessManager;\n    }\n\n    function() payable public {\n        revert();\n    }\n\n    /// @notice Update access manager address\n    ///\n    /// @param _accessManager access manager's address\n    function setAccessManager(address _accessManager) external onlyContractOwner returns (uint) {\n        require(_accessManager != 0x0);\n        accessManager = _accessManager;\n        return OK;\n    }\n\n    /// @notice Sign in contract\n    ///\n    /// @param _contract contract's address\n    function signIn(address _contract) external onlyContractOwner returns (uint) {\n        require(_contract != 0x0);\n        authorized[_contract] = true;\n        return OK;\n    }\n\n    /// @notice Sign out contract\n    ///\n    /// @param _contract contract's address\n    function signOut(address _contract) external onlyContractOwner returns (uint) {\n        require(_contract != 0x0);\n        delete authorized[_contract];\n        return OK;\n    }\n\n    /// @notice Register new policy rule\n    /// Can be called only by contract owner\n    ///\n    /// @param _sig target method signature\n    /// @param _contract target contract address\n    /// @param _groupName group's name\n    /// @param _acceptLimit accepted vote limit\n    /// @param _declineLimit decline vote limit\n    ///\n    /// @return code\n    function addPolicyRule(\n        bytes4 _sig,\n        address _contract,\n        bytes32 _groupName,\n        uint _acceptLimit,\n        uint _declineLimit\n    )\n    onlyContractOwner\n    external\n    returns (uint)\n    {\n        require(_sig != 0x0);\n        require(_contract != 0x0);\n        require(GroupsAccessManager(accessManager).isGroupExists(_groupName));\n        require(_acceptLimit != 0);\n        require(_declineLimit != 0);\n\n        bytes32 _policyHash = keccak256(_sig, _contract);\n        \n        if (policyId2Index[_policyHash] == 0) {\n            uint _policiesCount = policiesCount.add(1);\n            index2PolicyId[_policiesCount] = _policyHash;\n            policyId2Index[_policyHash] = _policiesCount;\n            policiesCount = _policiesCount;\n        }\n\n        Policy storage _policy = policyId2policy[_policyHash];\n        uint _policyGroupsCount = _policy.groupsCount;\n\n        if (_policy.groupName2index[_groupName] == 0) {\n            _policyGroupsCount += 1;\n            _policy.groupName2index[_groupName] = _policyGroupsCount;\n            _policy.participatedGroups[_policyGroupsCount].groupName = _groupName;\n            _policy.groupsCount = _policyGroupsCount;\n        }\n\n        uint _previousAcceptLimit = _policy.participatedGroups[_policyGroupsCount].acceptLimit;\n        uint _previousDeclineLimit = _policy.participatedGroups[_policyGroupsCount].declineLimit;\n        _policy.participatedGroups[_policyGroupsCount].acceptLimit = _acceptLimit;\n        _policy.participatedGroups[_policyGroupsCount].declineLimit = _declineLimit;\n        _policy.totalAcceptedLimit = _policy.totalAcceptedLimit.sub(_previousAcceptLimit).add(_acceptLimit);\n        _policy.totalDeclinedLimit = _policy.totalDeclinedLimit.sub(_previousDeclineLimit).add(_declineLimit);\n\n        PolicyRuleAdded(_sig, _contract, _policyHash, _groupName, _acceptLimit, _declineLimit);\n        return OK;\n    }\n\n    /// @notice Remove policy rule\n    /// Can be called only by contract owner\n    ///\n    /// @param _groupName group's name\n    ///\n    /// @return code\n    function removePolicyRule(\n        bytes4 _sig,\n        address _contract,\n        bytes32 _groupName\n    ) \n    onlyContractOwner \n    external \n    returns (uint) \n    {\n        require(_sig != bytes4(0));\n        require(_contract != 0x0);\n        require(GroupsAccessManager(accessManager).isGroupExists(_groupName));\n\n        bytes32 _policyHash = keccak256(_sig, _contract);\n        Policy storage _policy = policyId2policy[_policyHash];\n        uint _policyGroupNameIndex = _policy.groupName2index[_groupName];\n\n        if (_policyGroupNameIndex == 0) {\n            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\n        }\n\n        uint _policyGroupsCount = _policy.groupsCount;\n        if (_policyGroupNameIndex != _policyGroupsCount) {\n            Requirements storage _requirements = _policy.participatedGroups[_policyGroupsCount];\n            _policy.participatedGroups[_policyGroupNameIndex] = _requirements;\n            _policy.groupName2index[_requirements.groupName] = _policyGroupNameIndex;\n        }\n\n        _policy.totalAcceptedLimit = _policy.totalAcceptedLimit.sub(_policy.participatedGroups[_policyGroupsCount].acceptLimit);\n        _policy.totalDeclinedLimit = _policy.totalDeclinedLimit.sub(_policy.participatedGroups[_policyGroupsCount].declineLimit);\n\n        delete _policy.groupName2index[_groupName];\n        delete _policy.participatedGroups[_policyGroupsCount];\n        _policy.groupsCount = _policyGroupsCount.sub(1);\n\n        PolicyRuleRemoved(_sig, _contract, _policyHash, _groupName);\n        return OK;\n    }\n\n    /// @notice Add transaction\n    ///\n    /// @param _key transaction id\n    ///\n    /// @return code\n    function addTx(bytes32 _key, bytes4 _sig, address _contract) external onlyAuthorized returns (uint) {\n        require(_key != bytes32(0));\n        require(_sig != bytes4(0));\n        require(_contract != 0x0);\n\n        bytes32 _policyHash = keccak256(_sig, _contract);\n        require(isPolicyExist(_policyHash));\n\n        if (isTxExist(_key)) {\n            return _emitError(PENDING_DUPLICATE_TX);\n        }\n\n        if (_policyHash == bytes32(0)) {\n            return _emitError(PENDING_MANAGER_POLICY_NOT_FOUND);\n        }\n\n        uint _index = txCount.add(1);\n        txCount = _index;\n        index2txKey[_index] = _key;\n        txKey2index[_key] = _index;\n\n        Guard storage _guard = txKey2guard[_key];\n        _guard.basePolicyIndex = policyId2Index[_policyHash];\n        _guard.state = GuardState.InProcess;\n\n        Policy storage _policy = policyId2policy[_policyHash];\n        uint _counter = _policy.securesCount.add(1);\n        _policy.securesCount = _counter;\n        _policy.index2txIndex[_counter] = _index;\n        _policy.txIndex2index[_index] = _counter;\n\n        ProtectionTxAdded(_key, _policyHash, block.number);\n        return OK;\n    }\n\n    /// @notice Delete transaction\n    /// @param _key transaction id\n    /// @return code\n    function deleteTx(bytes32 _key) external onlyContractOwner returns (uint) {\n        require(_key != bytes32(0));\n\n        if (!isTxExist(_key)) {\n            return _emitError(PENDING_MANAGER_TX_DOESNT_EXIST);\n        }\n\n        uint _txsCount = txCount;\n        uint _txIndex = txKey2index[_key];\n        if (_txIndex != _txsCount) {\n            bytes32 _last = index2txKey[txCount];\n            index2txKey[_txIndex] = _last;\n            txKey2index[_last] = _txIndex;\n        }\n\n        delete txKey2index[_key];\n        delete index2txKey[_txsCount];\n        txCount = _txsCount.sub(1);\n\n        uint _basePolicyIndex = txKey2guard[_key].basePolicyIndex;\n        Policy storage _policy = policyId2policy[index2PolicyId[_basePolicyIndex]];\n        uint _counter = _policy.securesCount;\n        uint _policyTxIndex = _policy.txIndex2index[_txIndex];\n        if (_policyTxIndex != _counter) {\n            uint _movedTxIndex = _policy.index2txIndex[_counter];\n            _policy.index2txIndex[_policyTxIndex] = _movedTxIndex;\n            _policy.txIndex2index[_movedTxIndex] = _policyTxIndex;\n        }\n\n        delete _policy.index2txIndex[_counter];\n        delete _policy.txIndex2index[_txIndex];\n        _policy.securesCount = _counter.sub(1);\n\n        TxDeleted(_key);\n        return OK;\n    }\n\n    /// @notice Accept transaction\n    /// Can be called only by registered user in GroupsAccessManager\n    ///\n    /// @param _key transaction id\n    ///\n    /// @return code\n    function accept(bytes32 _key, bytes32 _votingGroupName) external returns (uint) {\n        if (!isTxExist(_key)) {\n            return _emitError(PENDING_MANAGER_TX_DOESNT_EXIST);\n        }\n\n        if (!GroupsAccessManager(accessManager).isUserInGroup(_votingGroupName, msg.sender)) {\n            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\n        }\n\n        Guard storage _guard = txKey2guard[_key];\n        if (_guard.state != GuardState.InProcess) {\n            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\n        }\n\n        if (_guard.votes[msg.sender].groupName != bytes32(0) && _guard.votes[msg.sender].accepted) {\n            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\n        }\n\n        Policy storage _policy = policyId2policy[index2PolicyId[_guard.basePolicyIndex]];\n        uint _policyGroupIndex = _policy.groupName2index[_votingGroupName];\n        uint _groupAcceptedVotesCount = _guard.acceptedCount[_votingGroupName];\n        if (_groupAcceptedVotesCount == _policy.participatedGroups[_policyGroupIndex].acceptLimit) {\n            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\n        }\n\n        _guard.votes[msg.sender] = Vote(_votingGroupName, true);\n        _guard.acceptedCount[_votingGroupName] = _groupAcceptedVotesCount + 1;\n        uint _alreadyAcceptedCount = _guard.alreadyAccepted + 1;\n        _guard.alreadyAccepted = _alreadyAcceptedCount;\n\n        ProtectionTxAccepted(_key, msg.sender, _votingGroupName);\n\n        if (_alreadyAcceptedCount == _policy.totalAcceptedLimit) {\n            _guard.state = GuardState.Confirmed;\n            ProtectionTxDone(_key);\n        }\n\n        return OK;\n    }\n\n    /// @notice Decline transaction\n    /// Can be called only by registered user in GroupsAccessManager\n    ///\n    /// @param _key transaction id\n    ///\n    /// @return code\n    function decline(bytes32 _key, bytes32 _votingGroupName) external returns (uint) {\n        if (!isTxExist(_key)) {\n            return _emitError(PENDING_MANAGER_TX_DOESNT_EXIST);\n        }\n\n        if (!GroupsAccessManager(accessManager).isUserInGroup(_votingGroupName, msg.sender)) {\n            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\n        }\n\n        Guard storage _guard = txKey2guard[_key];\n        if (_guard.state != GuardState.InProcess) {\n            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\n        }\n\n        if (_guard.votes[msg.sender].groupName != bytes32(0) && !_guard.votes[msg.sender].accepted) {\n            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\n        }\n\n        Policy storage _policy = policyId2policy[index2PolicyId[_guard.basePolicyIndex]];\n        uint _policyGroupIndex = _policy.groupName2index[_votingGroupName];\n        uint _groupDeclinedVotesCount = _guard.declinedCount[_votingGroupName];\n        if (_groupDeclinedVotesCount == _policy.participatedGroups[_policyGroupIndex].declineLimit) {\n            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\n        }\n\n        _guard.votes[msg.sender] = Vote(_votingGroupName, false);\n        _guard.declinedCount[_votingGroupName] = _groupDeclinedVotesCount + 1;\n        uint _alreadyDeclinedCount = _guard.alreadyDeclined + 1;\n        _guard.alreadyDeclined = _alreadyDeclinedCount;\n\n\n        ProtectionTxDeclined(_key, msg.sender, _votingGroupName);\n\n        if (_alreadyDeclinedCount == _policy.totalDeclinedLimit) {\n            _guard.state = GuardState.Decline;\n            ProtectionTxCancelled(_key);\n        }\n\n        return OK;\n    }\n\n    /// @notice Revoke user votes for transaction\n    /// Can be called only by contract owner\n    ///\n    /// @param _key transaction id\n    /// @param _user target user address\n    ///\n    /// @return code\n    function forceRejectVotes(bytes32 _key, address _user) external onlyContractOwner returns (uint) {\n        return _revoke(_key, _user);\n    }\n\n    /// @notice Revoke vote for transaction\n    /// Can be called only by authorized user\n    /// @param _key transaction id\n    /// @return code\n    function revoke(bytes32 _key) external returns (uint) {\n        return _revoke(_key, msg.sender);\n    }\n\n    /// @notice Check transaction status\n    /// @param _key transaction id\n    /// @return code\n    function hasConfirmedRecord(bytes32 _key) public view returns (uint) {\n        require(_key != bytes32(0));\n\n        if (!isTxExist(_key)) {\n            return NO_RECORDS_WERE_FOUND;\n        }\n\n        Guard storage _guard = txKey2guard[_key];\n        return _guard.state == GuardState.InProcess\n        ? PENDING_MANAGER_IN_PROCESS\n        : _guard.state == GuardState.Confirmed\n        ? OK\n        : PENDING_MANAGER_REJECTED;\n    }\n\n\n    /// @notice Check policy details\n    ///\n    /// @return _groupNames group names included in policies\n    /// @return _acceptLimits accept limit for group\n    /// @return _declineLimits decline limit for group\n    function getPolicyDetails(bytes4 _sig, address _contract)\n    public\n    view\n    returns (\n        bytes32[] _groupNames,\n        uint[] _acceptLimits,\n        uint[] _declineLimits,\n        uint _totalAcceptedLimit,\n        uint _totalDeclinedLimit\n    ) {\n        require(_sig != bytes4(0));\n        require(_contract != 0x0);\n        \n        bytes32 _policyHash = keccak256(_sig, _contract);\n        uint _policyIdx = policyId2Index[_policyHash];\n        if (_policyIdx == 0) {\n            return;\n        }\n\n        Policy storage _policy = policyId2policy[_policyHash];\n        uint _policyGroupsCount = _policy.groupsCount;\n        _groupNames = new bytes32[](_policyGroupsCount);\n        _acceptLimits = new uint[](_policyGroupsCount);\n        _declineLimits = new uint[](_policyGroupsCount);\n\n        for (uint _idx = 0; _idx < _policyGroupsCount; ++_idx) {\n            Requirements storage _requirements = _policy.participatedGroups[_idx + 1];\n            _groupNames[_idx] = _requirements.groupName;\n            _acceptLimits[_idx] = _requirements.acceptLimit;\n            _declineLimits[_idx] = _requirements.declineLimit;\n        }\n\n        (_totalAcceptedLimit, _totalDeclinedLimit) = (_policy.totalAcceptedLimit, _policy.totalDeclinedLimit);\n    }\n\n    /// @notice Check policy include target group\n    /// @param _policyHash policy hash (sig, contract address)\n    /// @param _groupName group id\n    /// @return bool\n    function isGroupInPolicy(bytes32 _policyHash, bytes32 _groupName) public view returns (bool) {\n        Policy storage _policy = policyId2policy[_policyHash];\n        return _policy.groupName2index[_groupName] != 0;\n    }\n\n    /// @notice Check is policy exist\n    /// @param _policyHash policy hash (sig, contract address)\n    /// @return bool\n    function isPolicyExist(bytes32 _policyHash) public view returns (bool) {\n        return policyId2Index[_policyHash] != 0;\n    }\n\n    /// @notice Check is transaction exist\n    /// @param _key transaction id\n    /// @return bool\n    function isTxExist(bytes32 _key) public view returns (bool){\n        return txKey2index[_key] != 0;\n    }\n\n    function _updateTxState(Policy storage _policy, Guard storage _guard, uint confirmedAmount, uint declineAmount) private {\n        if (declineAmount != 0 && _guard.state != GuardState.Decline) {\n            _guard.state = GuardState.Decline;\n        } else if (confirmedAmount >= _policy.groupsCount && _guard.state != GuardState.Confirmed) {\n            _guard.state = GuardState.Confirmed;\n        } else if (_guard.state != GuardState.InProcess) {\n            _guard.state = GuardState.InProcess;\n        }\n    }\n\n    function _revoke(bytes32 _key, address _user) private returns (uint) {\n        require(_key != bytes32(0));\n        require(_user != 0x0);\n\n        if (!isTxExist(_key)) {\n            return _emitError(PENDING_MANAGER_TX_DOESNT_EXIST);\n        }\n\n        Guard storage _guard = txKey2guard[_key];\n        if (_guard.state != GuardState.InProcess) {\n            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\n        }\n\n        bytes32 _votedGroupName = _guard.votes[_user].groupName;\n        if (_votedGroupName == bytes32(0)) {\n            return _emitError(PENDING_MANAGER_HASNT_VOTED);\n        }\n\n        bool isAcceptedVote = _guard.votes[_user].accepted;\n        if (isAcceptedVote) {\n            _guard.acceptedCount[_votedGroupName] = _guard.acceptedCount[_votedGroupName].sub(1);\n            _guard.alreadyAccepted = _guard.alreadyAccepted.sub(1);\n        } else {\n            _guard.declinedCount[_votedGroupName] = _guard.declinedCount[_votedGroupName].sub(1);\n            _guard.alreadyDeclined = _guard.alreadyDeclined.sub(1);\n\n        }\n\n        delete _guard.votes[_user];\n\n        ProtectionTxVoteRevoked(_key, _user, _votedGroupName);\n        return OK;\n    }\n}\n\n/// @title MultiSigAdapter\n///\n/// Abstract implementation\n/// This contract serves as transaction signer\ncontract MultiSigAdapter is Object {\n\n    uint constant MULTISIG_ADDED = 3;\n    uint constant NO_RECORDS_WERE_FOUND = 4;\n\n    modifier isAuthorized {\n        if (msg.sender == contractOwner || msg.sender == getPendingManager()) {\n            _;\n        }\n    }\n\n    /// @notice Get pending address\n    /// @dev abstract. Needs child implementation\n    ///\n    /// @return pending address\n    function getPendingManager() public view returns (address);\n\n    /// @notice Sign current transaction and add it to transaction pending queue\n    ///\n    /// @return code\n    function _multisig(bytes32 _args, uint _block) internal returns (uint _code) {\n        bytes32 _txHash = _getKey(_args, _block);\n        address _manager = getPendingManager();\n\n        _code = PendingManager(_manager).hasConfirmedRecord(_txHash);\n        if (_code != NO_RECORDS_WERE_FOUND) {\n            return _code;\n        }\n\n        if (OK != PendingManager(_manager).addTx(_txHash, msg.sig, address(this))) {\n            revert();\n        }\n\n        return MULTISIG_ADDED;\n    }\n\n    function _isTxExistWithArgs(bytes32 _args, uint _block) internal view returns (bool) {\n        bytes32 _txHash = _getKey(_args, _block);\n        address _manager = getPendingManager();\n        return PendingManager(_manager).isTxExist(_txHash);\n    }\n\n    function _getKey(bytes32 _args, uint _block) private view returns (bytes32 _txHash) {\n        _block = _block != 0 ? _block : block.number;\n        _txHash = keccak256(msg.sig, _args, _block);\n    }\n}\n\n/// @title ServiceController\n///\n/// Base implementation\n/// Serves for managing service instances\ncontract ServiceController is MultiSigAdapter {\n\n    event Error(uint _errorCode);\n\n    uint constant SERVICE_CONTROLLER = 350000;\n    uint constant SERVICE_CONTROLLER_EMISSION_EXIST = SERVICE_CONTROLLER + 1;\n    uint constant SERVICE_CONTROLLER_BURNING_MAN_EXIST = SERVICE_CONTROLLER + 2;\n    uint constant SERVICE_CONTROLLER_ALREADY_INITIALIZED = SERVICE_CONTROLLER + 3;\n    uint constant SERVICE_CONTROLLER_SERVICE_EXIST = SERVICE_CONTROLLER + 4;\n\n    address public profiterole;\n    address public treasury;\n    address public pendingManager;\n    address public proxy;\n\n    uint public sideServicesCount;\n    mapping(uint => address) public index2sideService;\n    mapping(address => uint) public sideService2index;\n    mapping(address => bool) public sideServices;\n\n    uint public emissionProvidersCount;\n    mapping(uint => address) public index2emissionProvider;\n    mapping(address => uint) public emissionProvider2index;\n    mapping(address => bool) public emissionProviders;\n\n    uint public burningMansCount;\n    mapping(uint => address) public index2burningMan;\n    mapping(address => uint) public burningMan2index;\n    mapping(address => bool) public burningMans;\n\n    /// @notice Default ServiceController's constructor\n    ///\n    /// @param _pendingManager pending manager address\n    /// @param _proxy ERC20 proxy address\n    /// @param _profiterole profiterole address\n    /// @param _treasury treasury address\n    function ServiceController(address _pendingManager, address _proxy, address _profiterole, address _treasury) public {\n        require(_pendingManager != 0x0);\n        require(_proxy != 0x0);\n        require(_profiterole != 0x0);\n        require(_treasury != 0x0);\n        pendingManager = _pendingManager;\n        proxy = _proxy;\n        profiterole = _profiterole;\n        treasury = _treasury;\n    }\n\n    /// @notice Return pending manager address\n    ///\n    /// @return code\n    function getPendingManager() public view returns (address) {\n        return pendingManager;\n    }\n\n    /// @notice Add emission provider\n    ///\n    /// @param _provider emission provider address\n    ///\n    /// @return code\n    function addEmissionProvider(address _provider, uint _block) public returns (uint _code) {\n        if (emissionProviders[_provider]) {\n            return _emitError(SERVICE_CONTROLLER_EMISSION_EXIST);\n        }\n        _code = _multisig(keccak256(_provider), _block);\n        if (OK != _code) {\n            return _code;\n        }\n\n        emissionProviders[_provider] = true;\n        uint _count = emissionProvidersCount + 1;\n        index2emissionProvider[_count] = _provider;\n        emissionProvider2index[_provider] = _count;\n        emissionProvidersCount = _count;\n\n        return OK;\n    }\n\n    /// @notice Remove emission provider\n    ///\n    /// @param _provider emission provider address\n    ///\n    /// @return code\n    function removeEmissionProvider(address _provider, uint _block) public returns (uint _code) {\n        _code = _multisig(keccak256(_provider), _block);\n        if (OK != _code) {\n            return _code;\n        }\n\n        uint _idx = emissionProvider2index[_provider];\n        uint _lastIdx = emissionProvidersCount;\n        if (_idx != 0) {\n            if (_idx != _lastIdx) {\n                address _lastEmissionProvider = index2emissionProvider[_lastIdx];\n                index2emissionProvider[_idx] = _lastEmissionProvider;\n                emissionProvider2index[_lastEmissionProvider] = _idx;\n            }\n\n            delete emissionProvider2index[_provider];\n            delete index2emissionProvider[_lastIdx];\n            delete emissionProviders[_provider];\n            emissionProvidersCount = _lastIdx - 1;\n        }\n\n        return OK;\n    }\n\n    /// @notice Add burning man\n    ///\n    /// @param _burningMan burning man address\n    ///\n    /// @return code\n    function addBurningMan(address _burningMan, uint _block) public returns (uint _code) {\n        if (burningMans[_burningMan]) {\n            return _emitError(SERVICE_CONTROLLER_BURNING_MAN_EXIST);\n        }\n\n        _code = _multisig(keccak256(_burningMan), _block);\n        if (OK != _code) {\n            return _code;\n        }\n\n        burningMans[_burningMan] = true;\n        uint _count = burningMansCount + 1;\n        index2burningMan[_count] = _burningMan;\n        burningMan2index[_burningMan] = _count;\n        burningMansCount = _count;\n\n        return OK;\n    }\n\n    /// @notice Remove burning man\n    ///\n    /// @param _burningMan burning man address\n    ///\n    /// @return code\n    function removeBurningMan(address _burningMan, uint _block) public returns (uint _code) {\n        _code = _multisig(keccak256(_burningMan), _block);\n        if (OK != _code) {\n            return _code;\n        }\n\n        uint _idx = burningMan2index[_burningMan];\n        uint _lastIdx = burningMansCount;\n        if (_idx != 0) {\n            if (_idx != _lastIdx) {\n                address _lastBurningMan = index2burningMan[_lastIdx];\n                index2burningMan[_idx] = _lastBurningMan;\n                burningMan2index[_lastBurningMan] = _idx;\n            }\n            \n            delete burningMan2index[_burningMan];\n            delete index2burningMan[_lastIdx];\n            delete burningMans[_burningMan];\n            burningMansCount = _lastIdx - 1;\n        }\n\n        return OK;\n    }\n\n    /// @notice Update a profiterole address\n    ///\n    /// @param _profiterole profiterole address\n    ///\n    /// @return result code of an operation\n    function updateProfiterole(address _profiterole, uint _block) public returns (uint _code) {\n        _code = _multisig(keccak256(_profiterole), _block);\n        if (OK != _code) {\n            return _code;\n        }\n\n        profiterole = _profiterole;\n        return OK;\n    }\n\n    /// @notice Update a treasury address\n    ///\n    /// @param _treasury treasury address\n    ///\n    /// @return result code of an operation\n    function updateTreasury(address _treasury, uint _block) public returns (uint _code) {\n        _code = _multisig(keccak256(_treasury), _block);\n        if (OK != _code) {\n            return _code;\n        }\n\n        treasury = _treasury;\n        return OK;\n    }\n\n    /// @notice Update pending manager address\n    ///\n    /// @param _pendingManager pending manager address\n    ///\n    /// @return result code of an operation\n    function updatePendingManager(address _pendingManager, uint _block) public returns (uint _code) {\n        _code = _multisig(keccak256(_pendingManager), _block);\n        if (OK != _code) {\n            return _code;\n        }\n\n        pendingManager = _pendingManager;\n        return OK;\n    }\n\n    function addSideService(address _service, uint _block) public returns (uint _code) {\n        if (sideServices[_service]) {\n            return SERVICE_CONTROLLER_SERVICE_EXIST;\n        }\n        _code = _multisig(keccak256(_service), _block);\n        if (OK != _code) {\n            return _code;\n        }\n\n        sideServices[_service] = true;\n        uint _count = sideServicesCount + 1;\n        index2sideService[_count] = _service;\n        sideService2index[_service] = _count;\n        sideServicesCount = _count;\n\n        return OK;\n    }\n\n    function removeSideService(address _service, uint _block) public returns (uint _code) {\n        _code = _multisig(keccak256(_service), _block);\n        if (OK != _code) {\n            return _code;\n        }\n\n        uint _idx = sideService2index[_service];\n        uint _lastIdx = sideServicesCount;\n        if (_idx != 0) {\n            if (_idx != _lastIdx) {\n                address _lastSideService = index2sideService[_lastIdx];\n                index2sideService[_idx] = _lastSideService;\n                sideService2index[_lastSideService] = _idx;\n            }\n            \n            delete sideService2index[_service];\n            delete index2sideService[_lastIdx];\n            delete sideServices[_service];\n            sideServicesCount = _lastIdx - 1;\n        }\n\n        return OK;\n    }\n\n    function getEmissionProviders()\n    public\n    view\n    returns (address[] _emissionProviders)\n    {\n        _emissionProviders = new address[](emissionProvidersCount);\n        for (uint _idx = 0; _idx < _emissionProviders.length; ++_idx) {\n            _emissionProviders[_idx] = index2emissionProvider[_idx + 1];\n        }\n    }\n\n    function getBurningMans()\n    public\n    view\n    returns (address[] _burningMans)\n    {\n        _burningMans = new address[](burningMansCount);\n        for (uint _idx = 0; _idx < _burningMans.length; ++_idx) {\n            _burningMans[_idx] = index2burningMan[_idx + 1];\n        }\n    }\n\n    function getSideServices()\n    public\n    view\n    returns (address[] _sideServices)\n    {\n        _sideServices = new address[](sideServicesCount);\n        for (uint _idx = 0; _idx < _sideServices.length; ++_idx) {\n            _sideServices[_idx] = index2sideService[_idx + 1];\n        }\n    }\n\n    /// @notice Check target address is service\n    ///\n    /// @param _address target address\n    ///\n    /// @return `true` when an address is a service, `false` otherwise\n    function isService(address _address) public view returns (bool check) {\n        return _address == profiterole ||\n            _address == treasury || \n            _address == proxy || \n            _address == pendingManager || \n            emissionProviders[_address] || \n            burningMans[_address] ||\n            sideServices[_address];\n    }\n\n    function _emitError(uint _errorCode) internal returns (uint) {\n        Error(_errorCode);\n        return _errorCode;\n    }\n}",
  "bytecode": "6060604052341561000f57600080fd5b6040516080806115838339810160405280805191906020018051919060200180519190602001805160008054600160a060020a03191633600160a060020a039081169190911790915590925085161515905061006a57600080fd5b600160a060020a038316151561007f57600080fd5b600160a060020a038216151561009457600080fd5b600160a060020a03811615156100a957600080fd5b60048054600160a060020a03958616600160a060020a031991821617909155600580549486169482169490941790935560028054928516928416929092179091556003805491909316911617905561147d806101066000396000f3006060604052600436106101a85763ffffffff60e060020a60003504166301308ac181146101ad5780630302263a146101df578063067906b1146101f257806335244bc01461020557806338ce1df8146102385780634592cd1d1461025d578063554edf2a14610270578063557f4bc91461028f5780635aa77d3c146102ae57806361d027b3146102c15780636aaab6f2146102d457806380af6d79146102f657806383197ef01461031857806383ebcb961461032d5780638484dc241461034c5780638c9ea8a41461036e578063974b25251461038457806399caf208146103a6578063a00fff6f146103c8578063a24ac910146103db578063adcfe41f146103fa578063b7f3ffed14610419578063b8126a3e1461043b578063ba064e731461045d578063bed230d01461047c578063bf5c7f9b1461048f578063c8c79643146104a2578063cc2dcd7e146104c4578063ce606ee0146104e6578063d8f9659b146104f9578063d916ec3214610553578063db433ba8146105b9578063e0d872b7146105cf578063e7b48d98146105e2578063e9d8dbfd146105f5578063ec55688914610614575b600080fd5b34156101b857600080fd5b6101c3600435610627565b604051600160a060020a03909116815260200160405180910390f35b34156101ea57600080fd5b6101c3610642565b34156101fd57600080fd5b6101c3610652565b341561021057600080fd5b610224600160a060020a0360043516610661565b604051901515815260200160405180910390f35b341561024357600080fd5b61024b610676565b60405190815260200160405180910390f35b341561026857600080fd5b61022461067c565b341561027b57600080fd5b61024b600160a060020a03600435166106c6565b341561029a57600080fd5b610224600160a060020a03600435166106d8565b34156102b957600080fd5b6101c361072a565b34156102cc57600080fd5b6101c3610739565b34156102df57600080fd5b61024b600160a060020a0360043516602435610748565b341561030157600080fd5b61024b600160a060020a03600435166024356107aa565b341561032357600080fd5b61032b61087f565b005b341561033857600080fd5b61024b600160a060020a03600435166108a4565b341561035757600080fd5b61024b600160a060020a03600435166024356108b6565b341561037957600080fd5b6101c36004356109c6565b341561038f57600080fd5b61024b600160a060020a03600435166024356109e1565b34156103b157600080fd5b61024b600160a060020a0360043516602435610aec565b34156103d357600080fd5b6101c3610b4f565b34156103e657600080fd5b610224600160a060020a0360043516610b5e565b341561040557600080fd5b61024b600160a060020a0360043516610b73565b341561042457600080fd5b61024b600160a060020a0360043516602435610b85565b341561044657600080fd5b61024b600160a060020a0360043516602435610be8565b341561046857600080fd5b610224600160a060020a0360043516610cb0565b341561048757600080fd5b61024b610cc5565b341561049a57600080fd5b61024b610ccb565b34156104ad57600080fd5b61024b600160a060020a0360043516602435610cd1565b34156104cf57600080fd5b61024b600160a060020a0360043516602435610d9a565b34156104f157600080fd5b6101c3610ea5565b341561050457600080fd5b61024b600460248135818101908301358060208181020160405190810160405280939291908181526020018383602002808284375094965050509235600160a060020a03169250610eb4915050565b341561055e57600080fd5b610566610ff5565b60405160208082528190810183818151815260200191508051906020019060200280838360005b838110156105a557808201518382015260200161058d565b505050509050019250505060405180910390f35b34156105c457600080fd5b6101c360043561107b565b34156105da57600080fd5b610566611096565b34156105ed57600080fd5b610566611118565b341561060057600080fd5b610224600160a060020a036004351661119a565b341561061f57600080fd5b6101c3611261565b600760205260009081526040902054600160a060020a031681565b600454600160a060020a03165b90565b600254600160a060020a031681565b60096020526000908152604090205460ff1681565b60065481565b60015460009033600160a060020a0390811691161461069d5750600061064f565b506001805460008054600160a060020a0319908116600160a060020a0384161790915516815590565b60086020526000908152604090205481565b6000805433600160a060020a039081169116141561072557600160a060020a038216151561070857506000610725565b5060018054600160a060020a031916600160a060020a0383161781555b919050565b600154600160a060020a031681565b600354600160a060020a031681565b600061077683604051600160a060020a0391909116606060020a028152601401604051809103902083611270565b905060018114610785576107a4565b5060038054600160a060020a031916600160a060020a03841617905560015b92915050565b600160a060020a0382166000908152600d6020526040812054819060ff16156107e0576107d9620557316113b3565b9150610878565b61080c84604051600160a060020a0391909116606060020a028152601401604051809103902084611270565b91506001821461081b57610878565b5050600160a060020a0382166000818152600d60209081526040808320805460ff19166001908117909155600a80548201808652600b85528386208054600160a060020a03191688179055958552600c9093529220839055829055905b5092915050565b60005433600160a060020a03908116911614156108a25733600160a060020a0316ff5b565b60106020526000908152604090205481565b6000806000806108e886604051600160a060020a0391909116606060020a028152601401604051809103902086611270565b9350600184146108f7576109bd565b600160a060020a0386166000908152600c6020526040902054600a54909350915082156109b85782821461096957506000818152600b60209081526040808320548584528184208054600160a060020a031916600160a060020a039092169182179055808452600c9092529091208390555b600160a060020a0386166000818152600c60209081526040808320839055858352600b82528083208054600160a060020a0319169055928252600d905220805460ff191690556000198201600a555b600193505b50505092915050565b600f60205260009081526040902054600160a060020a031681565b600080600080610a1386604051600160a060020a0391909116606060020a028152601401604051809103902086611270565b935060018414610a22576109bd565b600160a060020a038616600090815260106020526040902054600e54909350915082156109b857828214610a9457506000818152600f60209081526040808320548584528184208054600160a060020a031916600160a060020a03909216918217905580845260109092529091208390555b50600160a060020a03949094166000818152601060209081526040808320839055878352600f82528083208054600160a060020a03191690559282526011905220805460ff1916905550505060001901600e55600190565b6000610b1a83604051600160a060020a0391909116606060020a028152601401604051809103902083611270565b905060018114610b29576107a4565b5060048054600160a060020a038416600160a060020a0319909116179055600192915050565b600454600160a060020a031681565b60116020526000908152604090205460ff1681565b600c6020526000908152604090205481565b6000610bb383604051600160a060020a0391909116606060020a028152601401604051809103902083611270565b905060018114610bc2576107a4565b5060028054600160a060020a038416600160a060020a0319909116179055600192915050565b600160a060020a038216600090815260096020526040812054819060ff1615610c1657620557349150610878565b610c4284604051600160a060020a0391909116606060020a028152601401604051809103902084611270565b915060018214610c5157610878565b505050600160a060020a03166000818152600960209081526040808320805460ff19166001908117909155600680548201808652600785528386208054600160a060020a03191688179055958552600890935292208390559190915590565b600d6020526000908152604090205460ff1681565b600e5481565b600a5481565b600160a060020a038216600090815260116020526040812054819060ff1615610d00576107d9620557326113b3565b610d2c84604051600160a060020a0391909116606060020a028152601401604051809103902084611270565b915060018214610d3b57610878565b505050600160a060020a03166000818152601160209081526040808320805460ff19166001908117909155600e80548201808652600f85528386208054600160a060020a03191688179055958552601090935292208390559190915590565b600080600080610dcc86604051600160a060020a0391909116606060020a028152601401604051809103902086611270565b935060018414610ddb576109bd565b600160a060020a038616600090815260086020526040902054600654909350915082156109b857828214610e4d57506000818152600760209081526040808320548584528184208054600160a060020a031916600160a060020a03909216918217905580845260089092529091208390555b50600160a060020a03949094166000818152600860209081526040808320839055878352600782528083208054600160a060020a03191690559282526009905220805460ff1916905550505060001901600655600190565b600054600160a060020a031681565b6000805481908190819033600160a060020a03908116911614156109bd57600092505b85518310156109b857858381518110610eec57fe5b90602001906020020151915081600160a060020a03166370a082313060006040516020015260405160e060020a63ffffffff8416028152600160a060020a039091166004820152602401602060405180830381600087803b1515610f4f57600080fd5b6102c65a03f11515610f6057600080fd5b50505060405180519150508015610fea5781600160a060020a031663a9059cbb868360006040516020015260405160e060020a63ffffffff8516028152600160a060020a0390921660048301526024820152604401602060405180830381600087803b1515610fce57600080fd5b6102c65a03f11515610fdf57600080fd5b505050604051805150505b600190920191610ed7565b610ffd61143f565b6000600a5460405180591061100f5750595b90808252806020026020018201604052509150600090505b815181101561107757600181016000908152600b6020526040902054600160a060020a031682828151811061105857fe5b600160a060020a03909216602092830290910190910152600101611027565b5090565b600b60205260009081526040902054600160a060020a031681565b61109e61143f565b60006006546040518059106110b05750595b90808252806020026020018201604052509150600090505b81518110156110775760018101600090815260076020526040902054600160a060020a03168282815181106110f957fe5b600160a060020a039092166020928302909101909101526001016110c8565b61112061143f565b6000600e546040518059106111325750595b90808252806020026020018201604052509150600090505b815181101561107757600181016000908152600f6020526040902054600160a060020a031682828151811061117b57fe5b600160a060020a0390921660209283029091019091015260010161114a565b600254600090600160a060020a03838116911614806111c65750600354600160a060020a038381169116145b806111de5750600554600160a060020a038381169116145b806111f65750600454600160a060020a038381169116145b806112195750600160a060020a0382166000908152600d602052604090205460ff165b8061123c5750600160a060020a03821660009081526011602052604090205460ff165b806107a4575050600160a060020a031660009081526009602052604090205460ff1690565b600554600160a060020a031681565b600080600061127f85856113ec565b9150611289610642565b905080600160a060020a03166395e4c1bf8360006040516020015260405160e060020a63ffffffff84160281526004810191909152602401602060405180830381600087803b15156112da57600080fd5b6102c65a03f115156112eb57600080fd5b505050604051805193505060048314611303576113ab565b80600160a060020a0316632b828e4a83600035600160e060020a0319163060006040516020015260405160e060020a63ffffffff86160281526004810193909352600160e060020a03199091166024830152600160a060020a03166044820152606401602060405180830381600087803b151561137f57600080fd5b6102c65a03f1151561139057600080fd5b505050604051805160011490506113a657600080fd5b600392505b505092915050565b60007f2e36a7093f25f22bd4cbdeb6040174c3ba4c5fe8f1abc04e7c3c48f26c7413e08260405190815260200160405180910390a15090565b60008115156113fb57436113fd565b815b9150600035600160e060020a0319168383604051600160e060020a03199093168352600483019190915260248201526044016040518091039020905092915050565b602060405190810160405260008152905600a165627a7a7230582091781c97886c82111b2f7c4889f08c2e9a55f05f6d5e3f9494cd5c2e542d68c10029000000000000000000000000100fe59316884e4219550a24da3f4f43f69782ac000000000000000000000000d2ae5bf3b4665d0e52d225622ae832cba0f196ca000000000000000000000000510b787e38ceca5e3a95c836fa870df7ccee88f8000000000000000000000000ac8dd2c0851f08ca2b8d098e38bacc1ac3c277c3",
  "constructorArguments": "000000000000000000000000100fe59316884e4219550a24da3f4f43f69782ac000000000000000000000000d2ae5bf3b4665d0e52d225622ae832cba0f196ca000000000000000000000000510b787e38ceca5e3a95c836fa870df7ccee88f8000000000000000000000000ac8dd2c0851f08ca2b8d098e38bacc1ac3c277c3"
}