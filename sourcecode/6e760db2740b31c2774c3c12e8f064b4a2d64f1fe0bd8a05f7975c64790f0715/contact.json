{
  "address": "0xee44b11148486c05112d6418b987d8b8c2632e8f",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "Spineth",
  "compilerVersion": "v0.4.19+commit.c4cbbb05",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2017-12-26\n*/\n\npragma solidity ^0.4.19;\n\ncontract Spineth\n{\n    /// The states the game will transition through\n    enum State\n    {\n        WaitingForPlayers, // the game has been created by a player and is waiting for an opponent\n        WaitingForReveal, // someone has joined and also placed a bet, we are now waiting for the creator to their reveal bet\n        Complete // the outcome of the game is determined and players can withdraw their earnings\n    }\n\n    /// All possible event types\n    enum Event\n    {\n        Create,\n        Cancel,\n        Join,\n        Reveal,\n        Expire,\n        Complete,\n        Withdraw,\n        StartReveal\n    }\n    \n    // The game state associated with a single game between two players\n    struct GameInstance\n    {\n        // Address for players of this game\n        // player1 is always the creator\n        address player1;\n        address player2;\n    \n        // How much is being bet this game\n        uint betAmountInWei;\n    \n        // The wheelBet for each player\n        // For player1, the bet starts as a hash and is only changed to the real bet once revealed\n        uint wheelBetPlayer1;\n        uint wheelBetPlayer2;\n    \n        // The final wheel position after game is complete\n        uint wheelResult;\n    \n        // The time by which the creator of the game must reveal his bet after an opponent joins\n        // If the creator does not reveal in time, the opponent can expire the game, causing them to win the maximal amount of their bet\n        uint expireTime;\n\n        // Current state of the game    \n        State state;\n\n        // Tracks whether each player has withdrawn their earnings yet\n        bool withdrawnPlayer1;\n        bool withdrawnPlayer2;\n    }\n\n    /// How many places there are on the wheel that a bet can be placed\n    uint public constant WHEEL_SIZE = 19;\n    \n    /// What percentage of your opponent's bet a player wins for each place on \n    /// the wheel they are closer to the result than their opponent\n    /// i.e. If player1 distance from result = 4 and player2 distance from result = 6\n    /// then player1 earns (6-4) x WIN_PERCENT_PER_DISTANCE = 20% of player2's bet\n    uint public constant WIN_PERCENT_PER_DISTANCE = 10;\n\n    /// The percentage charged on earnings that are won\n    uint public constant FEE_PERCENT = 2;\n\n    /// The minimum amount that can be bet\n    uint public minBetWei = 1 finney;\n    \n    /// The maximum amount that can be bet\n    uint public maxBetWei = 10 ether;\n    \n    /// The amount of time creators have to reavel their bets before\n    /// the game can be expired by an opponent\n    uint public maxRevealSeconds = 3600 * 24;\n\n    /// The account that will receive fees and can configure min/max bet options\n    address public authority;\n\n    /// Counters that tracks how many games have been created by each player\n    /// This is used to generate a unique game id per player\n    mapping(address => uint) private counterContext;\n\n    /// Context for all created games\n    mapping(uint => GameInstance) public gameContext;\n\n    /// List of all currently open gameids\n    uint[] public openGames;\n\n    /// Indexes specific to each player\n    mapping(address => uint[]) public playerActiveGames;\n    mapping(address => uint[]) public playerCompleteGames;    \n\n    /// Event fired when a game's state changes\n    event GameEvent(uint indexed gameId, address indexed player, Event indexed eventType);\n\n    /// Create the contract and verify constant configurations make sense\n    function Spineth() public\n    {\n        // Make sure that the maximum possible win distance (WHEEL_SIZE / 2)\n        // multiplied by the WIN_PERCENT_PER_DISTANCE is less than 100%\n        // If it's not, then a maximally won bet can't be paid out\n        require((WHEEL_SIZE / 2) * WIN_PERCENT_PER_DISTANCE < 100);\n\n        authority = msg.sender;\n    }\n    \n    // Change authority\n    // Can only be called by authority\n    function changeAuthority(address newAuthority) public\n    {\n        require(msg.sender == authority);\n\n        authority = newAuthority;\n    }\n\n    // Change min/max bet amounts\n    // Can only be called by authority\n    function changeBetLimits(uint minBet, uint maxBet) public\n    {\n        require(msg.sender == authority);\n        require(maxBet >= minBet);\n\n        minBetWei = minBet;\n        maxBetWei = maxBet;\n    }\n    \n    // Internal helper function to add elements to an array\n    function arrayAdd(uint[] storage array, uint element) private\n    {\n        array.push(element);\n    }\n\n    // Internal helper function to remove element from an array\n    function arrayRemove(uint[] storage array, uint element) private\n    {\n        for(uint i = 0; i < array.length; ++i)\n        {\n            if(array[i] == element)\n            {\n                array[i] = array[array.length - 1];\n                delete array[array.length - 1];\n                --array.length;\n                break;\n            }\n        }\n    }\n\n    /// Get next game id to be associated with a player address\n    function getNextGameId(address player) public view\n        returns (uint)\n    {\n        uint counter = counterContext[player];\n\n        // Addresses are 160 bits so we can safely shift them up by (256 - 160 = 96 bits)\n        // to make room for the counter in the bottom 96 bits\n        // This means a single player cannot theoretically create more than 2^96 games\n        // which should more than enough for the lifetime of any player.\n        uint result = (uint(player) << 96) + counter;\n\n        // Check that we didn't overflow the counter (this will never happen)\n        require((result >> 96) == uint(player));\n\n        return result;\n    }\n\n    /// Used to calculate the bet hash given a wheel bet and a player secret.\n    /// Used by a game creator to calculate their bet bash off chain first.\n    /// When bet is revealed, contract will use this function to verify the revealed bet is valid\n    function createWheelBetHash(uint gameId, uint wheelBet, uint playerSecret) public pure\n        returns (uint)\n    {\n        require(wheelBet < WHEEL_SIZE);\n        return uint(keccak256(gameId, wheelBet, playerSecret));\n    }\n    \n    /// Create and initialize a game instance with the sent bet amount.\n    /// The creator will automatically become a participant of the game.\n    /// gameId must be the return value of getNextGameId(...) for the sender\n    /// wheelPositionHash should be calculated using createWheelBetHash(...)\n    function createGame(uint gameId, uint wheelPositionHash) public payable\n    {\n        // Make sure the player passed the correct value for the game id\n        require(getNextGameId(msg.sender) == gameId);\n\n        // Get the game instance and ensure that it doesn't already exist\n        GameInstance storage game = gameContext[gameId];\n        require(game.betAmountInWei == 0); \n        \n        // Must provide non-zero bet\n        require(msg.value > 0);\n        \n        // Restrict betting amount\n        // NOTE: Game creation can be disabled by setting min/max bet to 0\n        require(msg.value >= minBetWei && msg.value <= maxBetWei);\n\n        // Increment the create game counter for this player\n        counterContext[msg.sender] = counterContext[msg.sender] + 1;\n\n        // Update game state\n        // The creator becomes player1\n        game.state = State.WaitingForPlayers;\n        game.betAmountInWei = msg.value;\n        game.player1 = msg.sender;\n        game.wheelBetPlayer1 = wheelPositionHash;\n        \n        // This game is now open to others and active for the player\n        arrayAdd(openGames, gameId);\n        arrayAdd(playerActiveGames[msg.sender], gameId);\n\n        // Fire event for the creation of this game\n        GameEvent(gameId, msg.sender, Event.Create);\n    }\n    \n    /// Cancel a game that was created but never had another player join\n    /// A creator can use this function if they have been waiting too long for another\n    /// player and want to get their bet funds back. NOTE. Once someone joins\n    /// the game can no longer be cancelled.\n    function cancelGame(uint gameId) public\n    {\n        // Get the game instance and check that it exists\n        GameInstance storage game = gameContext[gameId];\n        require(game.betAmountInWei > 0); \n\n        // Can only cancel if we are still waiting for other participants\n        require(game.state == State.WaitingForPlayers);\n        \n        // Is the sender the creator?\n        require(game.player1 == msg.sender);\n\n        // Update game state\n        // Mark earnings as already withdrawn since we are returning the bet amount\n        game.state = State.Complete;\n        game.withdrawnPlayer1 = true;\n\n        // This game is no longer open and no longer active for the player\n        arrayRemove(openGames, gameId);\n        arrayRemove(playerActiveGames[msg.sender], gameId);\n\n        // Fire event for player canceling this game\n        GameEvent(gameId, msg.sender, Event.Cancel);\n\n        // Transfer the player's bet amount back to them\n        msg.sender.transfer(game.betAmountInWei);\n    }\n\n    /// Join an open game instance\n    /// Sender must provide an amount of wei equal to betAmountInWei\n    /// After the second player has joined, the creator will have maxRevealSeconds to reveal their bet\n    function joinGame(uint gameId, uint wheelBet) public payable\n    {\n        // Get the game instance and check that it exists\n        GameInstance storage game = gameContext[gameId];\n        require(game.betAmountInWei > 0); \n        \n        // Only allowed to participate while we are waiting for players\n        require(game.state == State.WaitingForPlayers);\n        \n        // Can't join a game that you created\n        require(game.player1 != msg.sender);\n        \n        // Is there space available?\n        require(game.player2 == 0);\n\n        // Must pay the amount of the bet to play\n        require(msg.value == game.betAmountInWei);\n\n        // Make sure the wheelBet makes sense\n        require(wheelBet < WHEEL_SIZE);\n\n        // Update game state\n        // The sender becomes player2\n        game.state = State.WaitingForReveal;\n        game.player2 = msg.sender;\n        game.wheelBetPlayer2 = wheelBet;\n        game.expireTime = now + maxRevealSeconds; // After expireTime the game can be expired\n\n        // This game is no longer open, and is now active for the joiner\n        arrayRemove(openGames, gameId);\n        arrayAdd(playerActiveGames[msg.sender], gameId);\n\n        // Fire event for player joining this game\n        GameEvent(gameId, msg.sender, Event.Join);\n\n        // Fire event for creator, letting them know they need to reveal their bet now\n        GameEvent(gameId, game.player1, Event.StartReveal);\n    }\n    \n    /// This can be called by the joining player to force the game to end once the expire\n    /// time has been reached. This is a safety measure to ensure the game can be completed\n    /// in case where the creator decides to not to reveal their bet. In this case, the creator\n    /// will lose the maximal amount of their bet\n    function expireGame(uint gameId) public\n    {\n        // Get the game instance and check that it exists\n        GameInstance storage game = gameContext[gameId];\n        require(game.betAmountInWei > 0); \n\n        // Only expire from the WaitingForReveal state\n        require(game.state == State.WaitingForReveal);\n        \n        // Has enough time passed to perform this action?\n        require(now > game.expireTime);\n        \n        // Can only expire the game if you are the second player\n        require(msg.sender == game.player2);\n\n        // Player1 (creator) did not reveal bet in time\n        // Complete the game in favor of player2\n        game.wheelResult = game.wheelBetPlayer2;\n        game.wheelBetPlayer1 = (game.wheelBetPlayer2 + (WHEEL_SIZE / 2)) % WHEEL_SIZE;\n        \n        // This game is complete, the withdrawEarnings flow can now be invoked\n        game.state = State.Complete;\n\n        // Fire an event for the player forcing this game to end\n        GameEvent(gameId, game.player1, Event.Expire);\n        GameEvent(gameId, game.player2, Event.Expire);\n    }\n    \n    /// Once a player has joined the game, the creator must reveal their bet\n    /// by providing the same playerSecret that was passed to createGame(...)\n    function revealBet(uint gameId, uint playerSecret) public\n    {\n        // Get the game instance and check that it exists\n        GameInstance storage game = gameContext[gameId];\n        require(game.betAmountInWei > 0); \n\n        // We can only reveal bets during the revealing bets state\n        require(game.state == State.WaitingForReveal);\n\n        // Only the creator does this\n        require(game.player1 == msg.sender);\n\n        uint i; // Loop counter used below\n\n        // Find the wheelBet the player made by enumerating the hash\n        // possibilities. It is done this way so the player only has to\n        // remember their secret in order to revel the bet\n        for(i = 0; i < WHEEL_SIZE; ++i)\n        {\n            // Find the bet that was provided in createGame(...)\n            if(createWheelBetHash(gameId, i, playerSecret) == game.wheelBetPlayer1)\n            {\n                // Update the bet to the revealed value\n                game.wheelBetPlayer1 = i;\n                break;\n            }\n        }\n        \n        // Make sure we successfully revealed the bet, otherwise\n        // the playerSecret was invalid\n        require(i < WHEEL_SIZE);\n        \n        // Fire an event for the revealing of the bet\n        GameEvent(gameId, msg.sender, Event.Reveal);\n\n        // Use the revealed bets to calculate the wheelResult\n        // NOTE: Neither player knew the unrevealed state of both bets when making their\n        // bet, so the combination can be used to generate a random number neither player could anticipate.\n        // This algorithm was tested for good outcome distribution for arbitrary hash values\n        uint256 hashResult = uint256(keccak256(gameId, now, game.wheelBetPlayer1, game.wheelBetPlayer2));\n        uint32 randomSeed = uint32(hashResult >> 0)\n                          ^ uint32(hashResult >> 32)\n                          ^ uint32(hashResult >> 64)\n                          ^ uint32(hashResult >> 96)\n                          ^ uint32(hashResult >> 128)\n                          ^ uint32(hashResult >> 160)\n                          ^ uint32(hashResult >> 192)\n                          ^ uint32(hashResult >> 224);\n\n        uint32 randomNumber = randomSeed;\n        uint32 randMax = 0xFFFFFFFF; // We use the whole 32 bit range\n\n        // Generate random numbers until we get a value in the unbiased range (see below)\n        do\n        {\n            randomNumber ^= (randomNumber >> 11);\n            randomNumber ^= (randomNumber << 7) & 0x9D2C5680;\n            randomNumber ^= (randomNumber << 15) & 0xEFC60000;\n            randomNumber ^= (randomNumber >> 18);\n        }\n        // Since WHEEL_SIZE is not divisible by randMax, using modulo below will introduce bias for\n        // numbers at the end of the randMax range. To remedy this, we discard these out of range numbers\n        // and generate additional numbers until we are in the largest range divisble by WHEEL_SIZE.\n        // This range will ensure we do not introduce any modulo bias\n        while(randomNumber >= (randMax - (randMax % WHEEL_SIZE)));\n\n        // Update game state        \n        game.wheelResult = randomNumber % WHEEL_SIZE;\n        game.state = State.Complete;\n        \n        // Fire an event for the completion of the game\n        GameEvent(gameId, game.player1, Event.Complete);\n        GameEvent(gameId, game.player2, Event.Complete);\n    }\n\n    /// A utility function to get the minimum distance between two selections\n    /// on a wheel of WHEEL_SIZE wrapping around at 0\n    function getWheelDistance(uint value1, uint value2) private pure\n        returns (uint)\n    {\n        // Make sure the values are within range\n        require(value1 < WHEEL_SIZE && value2 < WHEEL_SIZE);\n\n        // Calculate the distance of value1 with respect to value2\n        uint dist1 = (WHEEL_SIZE + value1 - value2) % WHEEL_SIZE;\n        \n        // Calculate the distance going the other way around the wheel\n        uint dist2 = WHEEL_SIZE - dist1;\n\n        // Whichever distance is shorter is the wheel distance\n        return (dist1 < dist2) ? dist1 : dist2;\n    }\n\n    /// Once the game is complete, use this function to get the results of\n    /// the game. Returns:\n    /// - the amount of wei charged for the fee\n    /// - the amount of wei to be paid out to player1\n    /// - the amount of wei to be paid out to player2\n    /// The sum of all the return values is exactly equal to the contributions\n    /// of both player bets. i.e. \n    ///     feeWei + weiPlayer1 + weiPlayer2 = 2 * betAmountInWei\n    function calculateEarnings(uint gameId) public view\n        returns (uint feeWei, uint weiPlayer1, uint weiPlayer2)\n    {\n        // Get the game instance and check that it exists\n        GameInstance storage game = gameContext[gameId];\n        require(game.betAmountInWei > 0); \n\n        // It doesn't make sense to call this function when the game isn't complete\n        require(game.state == State.Complete);\n        \n        uint distancePlayer1 = getWheelDistance(game.wheelBetPlayer1, game.wheelResult);\n        uint distancePlayer2 = getWheelDistance(game.wheelBetPlayer2, game.wheelResult);\n\n        // Outcome if there is a tie\n        feeWei = 0;\n        weiPlayer1 = game.betAmountInWei;\n        weiPlayer2 = game.betAmountInWei;\n\n        uint winDist = 0;\n        uint winWei = 0;\n        \n        // Player one was closer, so they won\n        if(distancePlayer1 < distancePlayer2)\n        {\n            winDist = distancePlayer2 - distancePlayer1;\n            winWei = game.betAmountInWei * (winDist * WIN_PERCENT_PER_DISTANCE) / 100;\n\n            feeWei = winWei * FEE_PERCENT / 100;\n            weiPlayer1 += winWei - feeWei;\n            weiPlayer2 -= winWei;\n        }\n        // Player two was closer, so they won\n        else if(distancePlayer2 < distancePlayer1)\n        {\n            winDist = distancePlayer1 - distancePlayer2;\n            winWei = game.betAmountInWei * (winDist * WIN_PERCENT_PER_DISTANCE) / 100;\n\n            feeWei = winWei * FEE_PERCENT / 100;\n            weiPlayer2 += winWei - feeWei;\n            weiPlayer1 -= winWei;\n        }\n        // Same distance, so it was a tie (see above)\n    }\n    \n    /// Once the game is complete, each player can withdraw their earnings\n    /// A fee is charged on winnings only and provided to the contract authority\n    function withdrawEarnings(uint gameId) public\n    {\n        // Get the game instance and check that it exists\n        GameInstance storage game = gameContext[gameId];\n        require(game.betAmountInWei > 0); \n\n        require(game.state == State.Complete);\n        \n        var (feeWei, weiPlayer1, weiPlayer2) = calculateEarnings(gameId);\n\n        bool payFee = false;\n        uint withdrawAmount = 0;\n\n        if(game.player1 == msg.sender)\n        {\n            // Can't have already withrawn\n            require(game.withdrawnPlayer1 == false);\n            \n            game.withdrawnPlayer1 = true; // They can't withdraw again\n            \n            // If player1 was the winner, they will pay the fee\n            if(weiPlayer1 > weiPlayer2)\n            {\n                payFee = true;\n            }\n            \n            withdrawAmount = weiPlayer1;\n        }\n        else if(game.player2 == msg.sender)\n        {\n            // Can't have already withrawn\n            require(game.withdrawnPlayer2 == false);\n            \n            game.withdrawnPlayer2 = true;\n\n            // If player2 was the winner, they will pay the fee\n            if(weiPlayer2 > weiPlayer1)\n            {\n                payFee = true;\n            }\n            \n            withdrawAmount = weiPlayer2;\n        }\n        else\n        {\n            // The sender isn't a participant\n            revert();\n        }\n\n        // This game is no longer active for this player, and now moved to complete for this player\n        arrayRemove(playerActiveGames[msg.sender], gameId);\n        arrayAdd(playerCompleteGames[msg.sender], gameId);\n\n        // Fire an event for the withdrawing of funds\n        GameEvent(gameId, msg.sender, Event.Withdraw);\n\n        // Pay the fee, if necessary\n        if(payFee == true)\n        {\n            authority.transfer(feeWei);\n        }\n    \n        // Transfer sender their outcome\n        msg.sender.transfer(withdrawAmount);\n    }\n}",
  "bytecode": "606060405266038d7ea4c68000600055678ac7230489e8000060015562015180600255341561002d57600080fd5b60038054600160a060020a03191633600160a060020a031617905561115a806100576000396000f3006060604052600436106101275763ffffffff7c0100000000000000000000000000000000000000000000000000000000600035041663116877cc811461012c5780632d3e20651461014d578063379930f7146101725780633c3efdc9146101855780633e33c37b146101bf5780634cc0a885146102625780635930a295146102755780635d3b2f371461028e57806360104cef146102ad57806361e4a23a146102bb57806369958ab9146102d15780636e70096e146102e7578063779ce152146102fd5780639344b0d614610310578063abfb589b14610332578063b60b9fcb1461034b578063bf7e214f14610359578063d2a6629c14610388578063eaf98d23146103aa578063f59f5e65146103bd578063fd22a6cf146103d9578063fe9ccc1e146103ef575b600080fd5b341561013757600080fd5b61014b600160a060020a0360043516610402565b005b341561015857600080fd5b61016061044c565b60405190815260200160405180910390f35b341561017d57600080fd5b610160610452565b341561019057600080fd5b61019b600435610457565b60405180848152602001838152602001828152602001935050505060405180910390f35b34156101ca57600080fd5b6101d5600435610553565b604051808b600160a060020a0316600160a060020a031681526020018a600160a060020a0316600160a060020a0316815260200189815260200188815260200187815260200186815260200185815260200184600281111561023357fe5b60ff16815292151560208401525015156040808301919091526060909101985096505050505050505180910390f35b341561026d57600080fd5b6101606105ba565b341561028057600080fd5b61014b6004356024356105c0565b341561029957600080fd5b610160600160a060020a03600435166105f3565b61014b600435602435610636565b34156102c657600080fd5b61014b600435610743565b34156102dc57600080fd5b61014b60043561082e565b34156102f257600080fd5b61014b600435610930565b341561030857600080fd5b610160610b1a565b341561031b57600080fd5b610160600160a060020a0360043516602435610b1f565b341561033d57600080fd5b61014b600435602435610b4d565b61014b600435602435610dce565b341561036457600080fd5b61036c610f2d565b604051600160a060020a03909116815260200160405180910390f35b341561039357600080fd5b610160600160a060020a0360043516602435610f3c565b34156103b557600080fd5b610160610f57565b34156103c857600080fd5b610160600435602435604435610f5c565b34156103e457600080fd5b610160600435610f9a565b34156103fa57600080fd5b610160610fb9565b60035433600160a060020a0390811691161461041d57600080fd5b6003805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b60005481565b601381565b6000818152600560205260408120600281015482918291829081908190819081901161048257600080fd5b6002600786015460ff16600281111561049757fe5b146104a157600080fd5b6104b385600301548660050154610fbf565b93506104c785600401548660050154610fbf565b600286015460009950975087965092508791508190508284101561051457600285015484840392506064908302600a02049050606460028202049750878103870196508086039550610547565b8383101561054757600285015483850392506064908302600a020490506064600282020497508781038601955080870396505b50505050509193909250565b600560208190526000918252604090912080546001820154600283015460038401546004850154958501546006860154600790960154600160a060020a039586169794909516959294919392909160ff80821691610100810482169162010000909104168a565b60025481565b60035433600160a060020a039081169116146105db57600080fd5b818110156105e857600080fd5b600091909155600155565b600160a060020a03811660008181526004602052604081205490916c010000000000000000000000008082028301919082041461062f57600080fd5b9392505050565b600082610642336105f3565b1461064c57600080fd5b50600082815260056020526040902060028101541561066a57600080fd5b6000341161067757600080fd5b600054341015801561068b57506001543411155b151561069657600080fd5b33600160a060020a031660008181526004602052604090208054600101905560078201805460ff19169055346002830155815473ffffffffffffffffffffffffffffffffffffffff1916178155600381018290556106f5600684611007565b600160a060020a03331660009081526007602052604090206107179084611007565b600033600160a060020a03168460008051602061110f83398151915260405160405180910390a4505050565b600081815260056020526040812060028101549091901161076357600080fd5b6001600782015460ff16600281111561077857fe5b1461078257600080fd5b6006810154421161079257600080fd5b600181015433600160a060020a039081169116146107af57600080fd5b60048101546005820181905560139060090106600382015560078101805460ff191660021790558054600490600160a060020a03168360008051602061110f83398151915260405160405180910390a460046001820154600160a060020a03168360008051602061110f83398151915260405160405180910390a45050565b600081815260056020526040812060028101549091901161084e57600080fd5b6000600782015460ff16600281111561086357fe5b1461086d57600080fd5b805433600160a060020a0390811691161461088757600080fd5b600781018054600260ff199091161761ff0019166101001790556108ac600683611029565b600160a060020a03331660009081526007602052604090206108ce9083611029565b600133600160a060020a03168360008051602061110f83398151915260405160405180910390a433600160a060020a03166108fc82600201549081150290604051600060405180830381858888f19350505050151561092c57600080fd5b5050565b60008181526005602052604081206002810154909190819081908190819081901161095a57600080fd5b6002600787015460ff16600281111561096f57fe5b1461097957600080fd5b61098287610457565b885492975090955093506000925082915033600160a060020a03908116911614156109e3576007860154610100900460ff16156109be57600080fd5b60078601805461ff001916610100179055828411156109dc57600191505b5082610a37565b600186015433600160a060020a039081169116141561012757600786015462010000900460ff1615610a1457600080fd5b60078601805462ff000019166201000017905583831115610a3457600191505b50815b600160a060020a0333166000908152600760205260409020610a599088611029565b600160a060020a0333166000908152600860205260409020610a7b9088611007565b600633600160a060020a03168860008051602061110f83398151915260405160405180910390a460018215151415610ae057600354600160a060020a031685156108fc0286604051600060405180830381858888f193505050501515610ae057600080fd5b600160a060020a03331681156108fc0282604051600060405180830381858888f193505050501515610b1157600080fd5b50505050505050565b600a81565b600860205281600052604060002081815481101515610b3a57fe5b6000918252602090912001549150829050565b600082815260056020526040812060028101549091908190819081908190819011610b7757600080fd5b6001600787015460ff166002811115610b8c57fe5b14610b9657600080fd5b855433600160a060020a03908116911614610bb057600080fd5b600094505b6013851015610beb578560030154610bce89878a610f5c565b1415610be05760038601859055610beb565b846001019450610bb5565b60138510610bf857600080fd5b600333600160a060020a03168960008051602061110f83398151915260405160405180910390a487428760030154886004015460405180858152602001848152602001838152602001828152602001945050505050604051908190039020935050505064010000000081048118680100000000000000008204186c010000000000000000000000008204187001000000000000000000000000000000008204187401000000000000000000000000000000000000000082041878010000000000000000000000000000000000000000000000008204187c01000000000000000000000000000000000000000000000000000000008204188063ffffffff5b6204000061080063ffffffff84811691909104909318808416608002639d2c568016188084166180000263efc6000016188084169190910418916013908216068163ffffffff16038263ffffffff16101515610d5157610cf6565b601363ffffffff83160660058781019190915560078701805460ff191660021790558654600160a060020a03168960008051602061110f83398151915260405160405180910390a460056001870154600160a060020a03168960008051602061110f83398151915260405160405180910390a45050505050505050565b6000828152600560205260408120600281015490919011610dee57600080fd5b6000600782015460ff166002811115610e0357fe5b14610e0d57600080fd5b805433600160a060020a0390811691161415610e2857600080fd5b6001810154600160a060020a031615610e4057600080fd5b60028101543414610e5057600080fd5b60138210610e5d57600080fd5b600781018054600160ff1990911681179091558101805473ffffffffffffffffffffffffffffffffffffffff191633600160a060020a0316179055600481018290556002544201600680830191909155610eb79084611029565b600160a060020a0333166000908152600760205260409020610ed99084611007565b600233600160a060020a03168460008051602061110f83398151915260405160405180910390a460078154600160a060020a03168460008051602061110f83398151915260405160405180910390a4505050565b600354600160a060020a031681565b600760205281600052604060002081815481101515610b3a57fe5b600281565b600060138310610f6b57600080fd5b838383604051808481526020018381526020018281526020019350505050604051908190039020949350505050565b6006805482908110610fa857fe5b600091825260209091200154905081565b60015481565b6000806000601385108015610fd45750601384105b1515610fdf57600080fd5b60138486038101069150816013039050808210610ffc5780610ffe565b815b95945050505050565b815482906001810161101983826110ce565b5060009182526020909120015550565b60005b82548110156110c95781838281548110151561104457fe5b90600052602060002090015414156110c15782548390600019810190811061106857fe5b906000526020600020900154838281548110151561108257fe5b6000918252602090912001558254839060001981019081106110a057fe5b60009182526020822001558254600019016110bb84826110ce565b506110c9565b60010161102c565b505050565b8154818355818115116110c9576000838152602090206110c991810190830161110b91905b8082111561110757600081556001016110f3565b5090565b905600afff33f4f313ba77ae394cf099251eb678a6e8295e7b173860e24e7da1fa6ef3a165627a7a72305820ade44effe03dd9be4665049aae02b3ea4c3fdc19f6ffa807177da58af47400110029"
}