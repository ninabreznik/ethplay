{
  "address": "0x42595584e6029178d6009077db7a6b68650aa1f0",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "BetContract",
  "compilerVersion": "v0.4.24+commit.e67f0147",
  "optimization": false,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2019-04-01\n*/\n\npragma solidity ^0.4.20;\n/* import \"github.com/oraclize/ethereum-api/oraclizeAPI.sol\"; */\n\n\ncontract OraclizeI {\n    address public cbAddress;\n    function query(uint _timestamp, string _datasource, string _arg) external payable returns (bytes32 _id);\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) external payable returns (bytes32 _id);\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) public payable returns (bytes32 _id);\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) external payable returns (bytes32 _id);\n    function queryN(uint _timestamp, string _datasource, bytes _argN) public payable returns (bytes32 _id);\n    function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) external payable returns (bytes32 _id);\n    function getPrice(string _datasource) public returns (uint _dsprice);\n    function getPrice(string _datasource, uint gaslimit) public returns (uint _dsprice);\n    function setProofType(byte _proofType) external;\n    function setCustomGasPrice(uint _gasPrice) external;\n    function randomDS_getSessionPubKeyHash() external constant returns(bytes32);\n}\ncontract OraclizeAddrResolverI {\n    function getAddress() public returns (address _addr);\n}\ncontract usingOraclize {\n    uint constant day = 60*60*24;\n    uint constant week = 60*60*24*7;\n    uint constant month = 60*60*24*30;\n    byte constant proofType_NONE = 0x00;\n    byte constant proofType_TLSNotary = 0x10;\n    byte constant proofType_Android = 0x20;\n    byte constant proofType_Ledger = 0x30;\n    byte constant proofType_Native = 0xF0;\n    byte constant proofStorage_IPFS = 0x01;\n    uint8 constant networkID_auto = 0;\n    uint8 constant networkID_mainnet = 1;\n    uint8 constant networkID_testnet = 2;\n    uint8 constant networkID_morden = 2;\n    uint8 constant networkID_consensys = 161;\n\n    OraclizeAddrResolverI OAR;\n\n    OraclizeI oraclize;\n    modifier oraclizeAPI {\n        if((address(OAR)==0)||(getCodeSize(address(OAR))==0))\n            oraclize_setNetwork(networkID_auto);\n\n        if(address(oraclize) != OAR.getAddress())\n            oraclize = OraclizeI(OAR.getAddress());\n\n        _;\n    }\n    modifier coupon(string code){\n        oraclize = OraclizeI(OAR.getAddress());\n        _;\n    }\n\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n      return oraclize_setNetwork();\n      networkID; // silence the warning and remain backwards compatible\n    }\n    function oraclize_setNetwork() internal returns(bool){\n        if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){ //mainnet\n            OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\n            oraclize_setNetworkName(\"eth_mainnet\");\n            return true;\n        }\n        if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){ //ropsten testnet\n            OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\n            oraclize_setNetworkName(\"eth_ropsten3\");\n            return true;\n        }\n        if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){ //kovan testnet\n            OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\n            oraclize_setNetworkName(\"eth_kovan\");\n            return true;\n        }\n        if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){ //rinkeby testnet\n            OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\n            oraclize_setNetworkName(\"eth_rinkeby\");\n            return true;\n        }\n        if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){ //ethereum-bridge\n            OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\n            return true;\n        }\n        if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){ //ether.camp ide\n            OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\n            return true;\n        }\n        if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){ //browser-solidity\n            OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\n            return true;\n        }\n        return false;\n    }\n\n    function __callback(bytes32 myid, string result) public {\n        __callback(myid, result, new bytes(0));\n    }\n    function __callback(bytes32 myid, string result, bytes proof) public {\n      return;\n      myid; result; proof; // Silence compiler warnings\n    }\n\n    function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\n        return oraclize.getPrice(datasource);\n    }\n\n    function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\n        return oraclize.getPrice(datasource, gaslimit);\n    }\n\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(0, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(timestamp, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        bytes memory args = stra2cbor(argN);\n        return oraclize.queryN.value(price)(0, datasource, args);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        bytes memory args = stra2cbor(argN);\n        return oraclize.queryN.value(price)(timestamp, datasource, args);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        bytes memory args = stra2cbor(argN);\n        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n    }\n    function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        bytes memory args = stra2cbor(argN);\n        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n    }\n    function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](1);\n        dynargs[0] = args[0];\n        return oraclize_query(datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](1);\n        dynargs[0] = args[0];\n        return oraclize_query(timestamp, datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](1);\n        dynargs[0] = args[0];\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](1);\n        dynargs[0] = args[0];\n        return oraclize_query(datasource, dynargs, gaslimit);\n    }\n\n    function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](2);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        return oraclize_query(datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](2);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        return oraclize_query(timestamp, datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](2);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](2);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        return oraclize_query(datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](3);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        return oraclize_query(datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](3);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        return oraclize_query(timestamp, datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](3);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](3);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        return oraclize_query(datasource, dynargs, gaslimit);\n    }\n\n    function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](4);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        return oraclize_query(datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](4);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        return oraclize_query(timestamp, datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](4);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](4);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        return oraclize_query(datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](5);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        dynargs[4] = args[4];\n        return oraclize_query(datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](5);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        dynargs[4] = args[4];\n        return oraclize_query(timestamp, datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](5);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        dynargs[4] = args[4];\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](5);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        dynargs[4] = args[4];\n        return oraclize_query(datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        bytes memory args = ba2cbor(argN);\n        return oraclize.queryN.value(price)(0, datasource, args);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        bytes memory args = ba2cbor(argN);\n        return oraclize.queryN.value(price)(timestamp, datasource, args);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        bytes memory args = ba2cbor(argN);\n        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n    }\n    function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        bytes memory args = ba2cbor(argN);\n        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n    }\n    function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](1);\n        dynargs[0] = args[0];\n        return oraclize_query(datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](1);\n        dynargs[0] = args[0];\n        return oraclize_query(timestamp, datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](1);\n        dynargs[0] = args[0];\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](1);\n        dynargs[0] = args[0];\n        return oraclize_query(datasource, dynargs, gaslimit);\n    }\n\n    function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](2);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        return oraclize_query(datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](2);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        return oraclize_query(timestamp, datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](2);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](2);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        return oraclize_query(datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](3);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        return oraclize_query(datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](3);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        return oraclize_query(timestamp, datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](3);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](3);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        return oraclize_query(datasource, dynargs, gaslimit);\n    }\n\n    function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](4);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        return oraclize_query(datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](4);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        return oraclize_query(timestamp, datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](4);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](4);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        return oraclize_query(datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](5);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        dynargs[4] = args[4];\n        return oraclize_query(datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](5);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        dynargs[4] = args[4];\n        return oraclize_query(timestamp, datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](5);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        dynargs[4] = args[4];\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](5);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        dynargs[4] = args[4];\n        return oraclize_query(datasource, dynargs, gaslimit);\n    }\n\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\n        return oraclize.cbAddress();\n    }\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\n        return oraclize.setProofType(proofP);\n    }\n    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\n        return oraclize.setCustomGasPrice(gasPrice);\n    }\n\n    function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){\n        return oraclize.randomDS_getSessionPubKeyHash();\n    }\n\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\n        assembly {\n            _size := extcodesize(_addr)\n        }\n    }\n\n    function parseAddr(string _a) internal pure returns (address){\n        bytes memory tmp = bytes(_a);\n        uint160 iaddr = 0;\n        uint160 b1;\n        uint160 b2;\n        for (uint i=2; i<2+2*20; i+=2){\n            iaddr *= 256;\n            b1 = uint160(tmp[i]);\n            b2 = uint160(tmp[i+1]);\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n            else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n            else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n            iaddr += (b1*16+b2);\n        }\n        return address(iaddr);\n    }\n\n    function strCompare(string _a, string _b) internal pure returns (int) {\n        bytes memory a = bytes(_a);\n        bytes memory b = bytes(_b);\n        uint minLength = a.length;\n        if (b.length < minLength) minLength = b.length;\n        for (uint i = 0; i < minLength; i ++)\n            if (a[i] < b[i])\n                return -1;\n            else if (a[i] > b[i])\n                return 1;\n        if (a.length < b.length)\n            return -1;\n        else if (a.length > b.length)\n            return 1;\n        else\n            return 0;\n    }\n\n    function indexOf(string _haystack, string _needle) internal pure returns (int) {\n        bytes memory h = bytes(_haystack);\n        bytes memory n = bytes(_needle);\n        if(h.length < 1 || n.length < 1 || (n.length > h.length))\n            return -1;\n        else if(h.length > (2**128 -1))\n            return -1;\n        else\n        {\n            uint subindex = 0;\n            for (uint i = 0; i < h.length; i ++)\n            {\n                if (h[i] == n[0])\n                {\n                    subindex = 1;\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n                    {\n                        subindex++;\n                    }\n                    if(subindex == n.length)\n                        return int(i);\n                }\n            }\n            return -1;\n        }\n    }\n\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n        bytes memory _ba = bytes(_a);\n        bytes memory _bb = bytes(_b);\n        bytes memory _bc = bytes(_c);\n        bytes memory _bd = bytes(_d);\n        bytes memory _be = bytes(_e);\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n        bytes memory babcde = bytes(abcde);\n        uint k = 0;\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n        return string(babcde);\n    }\n\n    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n        return strConcat(_a, _b, _c, _d, \"\");\n    }\n\n    function strConcat(string _a, string _b, string _c) internal pure returns (string) {\n        return strConcat(_a, _b, _c, \"\", \"\");\n    }\n\n    function strConcat(string _a, string _b) internal pure returns (string) {\n        return strConcat(_a, _b, \"\", \"\", \"\");\n    }\n\n    // parseInt\n    function parseInt(string _a) internal pure returns (uint) {\n        return parseInt(_a, 0);\n    }\n\n    // parseInt(parseFloat*10^_b)\n    function parseInt(string _a, uint _b) internal pure returns (uint) {\n        bytes memory bresult = bytes(_a);\n        uint mint = 0;\n        bool decimals = false;\n        for (uint i=0; i<bresult.length; i++){\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n                if (decimals){\n                   if (_b == 0) break;\n                    else _b--;\n                }\n                mint *= 10;\n                mint += uint(bresult[i]) - 48;\n            } else if (bresult[i] == 46) decimals = true;\n        }\n        if (_b > 0) mint *= 10**_b;\n        return mint;\n    }\n\n    function uint2str(uint i) internal pure returns (string){\n        if (i == 0) return \"0\";\n        uint j = i;\n        uint len;\n        while (j != 0){\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint k = len - 1;\n        while (i != 0){\n            bstr[k--] = byte(48 + i % 10);\n            i /= 10;\n        }\n        return string(bstr);\n    }\n\n    function stra2cbor(string[] arr) internal pure returns (bytes) {\n            uint arrlen = arr.length;\n\n            // get correct cbor output length\n            uint outputlen = 0;\n            bytes[] memory elemArray = new bytes[](arrlen);\n            for (uint i = 0; i < arrlen; i++) {\n                elemArray[i] = (bytes(arr[i]));\n                outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3; //+3 accounts for paired identifier types\n            }\n            uint ctr = 0;\n            uint cborlen = arrlen + 0x80;\n            outputlen += byte(cborlen).length;\n            bytes memory res = new bytes(outputlen);\n\n            while (byte(cborlen).length > ctr) {\n                res[ctr] = byte(cborlen)[ctr];\n                ctr++;\n            }\n            for (i = 0; i < arrlen; i++) {\n                res[ctr] = 0x5F;\n                ctr++;\n                for (uint x = 0; x < elemArray[i].length; x++) {\n                    // if there's a bug with larger strings, this may be the culprit\n                    if (x % 23 == 0) {\n                        uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\n                        elemcborlen += 0x40;\n                        uint lctr = ctr;\n                        while (byte(elemcborlen).length > ctr - lctr) {\n                            res[ctr] = byte(elemcborlen)[ctr - lctr];\n                            ctr++;\n                        }\n                    }\n                    res[ctr] = elemArray[i][x];\n                    ctr++;\n                }\n                res[ctr] = 0xFF;\n                ctr++;\n            }\n            return res;\n        }\n\n    function ba2cbor(bytes[] arr) internal pure returns (bytes) {\n            uint arrlen = arr.length;\n\n            // get correct cbor output length\n            uint outputlen = 0;\n            bytes[] memory elemArray = new bytes[](arrlen);\n            for (uint i = 0; i < arrlen; i++) {\n                elemArray[i] = (bytes(arr[i]));\n                outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3; //+3 accounts for paired identifier types\n            }\n            uint ctr = 0;\n            uint cborlen = arrlen + 0x80;\n            outputlen += byte(cborlen).length;\n            bytes memory res = new bytes(outputlen);\n\n            while (byte(cborlen).length > ctr) {\n                res[ctr] = byte(cborlen)[ctr];\n                ctr++;\n            }\n            for (i = 0; i < arrlen; i++) {\n                res[ctr] = 0x5F;\n                ctr++;\n                for (uint x = 0; x < elemArray[i].length; x++) {\n                    // if there's a bug with larger strings, this may be the culprit\n                    if (x % 23 == 0) {\n                        uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\n                        elemcborlen += 0x40;\n                        uint lctr = ctr;\n                        while (byte(elemcborlen).length > ctr - lctr) {\n                            res[ctr] = byte(elemcborlen)[ctr - lctr];\n                            ctr++;\n                        }\n                    }\n                    res[ctr] = elemArray[i][x];\n                    ctr++;\n                }\n                res[ctr] = 0xFF;\n                ctr++;\n            }\n            return res;\n        }\n\n\n    string oraclize_network_name;\n    function oraclize_setNetworkName(string _network_name) internal {\n        oraclize_network_name = _network_name;\n    }\n\n    function oraclize_getNetworkName() internal view returns (string) {\n        return oraclize_network_name;\n    }\n\n    function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\n        require((_nbytes > 0) && (_nbytes <= 32));\n        // Convert from seconds to ledger timer ticks\n        _delay *= 10;\n        bytes memory nbytes = new bytes(1);\n        nbytes[0] = byte(_nbytes);\n        bytes memory unonce = new bytes(32);\n        bytes memory sessionKeyHash = new bytes(32);\n        bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();\n        assembly {\n            mstore(unonce, 0x20)\n            mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\n            mstore(sessionKeyHash, 0x20)\n            mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\n        }\n        bytes memory delay = new bytes(32);\n        assembly {\n            mstore(add(delay, 0x20), _delay)\n        }\n\n        bytes memory delay_bytes8 = new bytes(8);\n        copyBytes(delay, 24, 8, delay_bytes8, 0);\n\n        bytes[4] memory args = [unonce, nbytes, sessionKeyHash, delay];\n        bytes32 queryId = oraclize_query(\"random\", args, _customGasLimit);\n\n        bytes memory delay_bytes8_left = new bytes(8);\n\n        assembly {\n            let x := mload(add(delay_bytes8, 0x20))\n            mstore8(add(delay_bytes8_left, 0x27), div(x, 0x100000000000000000000000000000000000000000000000000000000000000))\n            mstore8(add(delay_bytes8_left, 0x26), div(x, 0x1000000000000000000000000000000000000000000000000000000000000))\n            mstore8(add(delay_bytes8_left, 0x25), div(x, 0x10000000000000000000000000000000000000000000000000000000000))\n            mstore8(add(delay_bytes8_left, 0x24), div(x, 0x100000000000000000000000000000000000000000000000000000000))\n            mstore8(add(delay_bytes8_left, 0x23), div(x, 0x1000000000000000000000000000000000000000000000000000000))\n            mstore8(add(delay_bytes8_left, 0x22), div(x, 0x10000000000000000000000000000000000000000000000000000))\n            mstore8(add(delay_bytes8_left, 0x21), div(x, 0x100000000000000000000000000000000000000000000000000))\n            mstore8(add(delay_bytes8_left, 0x20), div(x, 0x1000000000000000000000000000000000000000000000000))\n\n        }\n\n        oraclize_randomDS_setCommitment(queryId, keccak256(delay_bytes8_left, args[1], sha256(args[0]), args[2]));\n        return queryId;\n    }\n\n    function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {\n        oraclize_randomDS_args[queryId] = commitment;\n    }\n\n    mapping(bytes32=>bytes32) oraclize_randomDS_args;\n    mapping(bytes32=>bool) oraclize_randomDS_sessionKeysHashVerified;\n\n    function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){\n        bool sigok;\n        address signer;\n\n        bytes32 sigr;\n        bytes32 sigs;\n\n        bytes memory sigr_ = new bytes(32);\n        uint offset = 4+(uint(dersig[3]) - 0x20);\n        sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);\n        bytes memory sigs_ = new bytes(32);\n        offset += 32 + 2;\n        sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);\n\n        assembly {\n            sigr := mload(add(sigr_, 32))\n            sigs := mload(add(sigs_, 32))\n        }\n\n\n        (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);\n        if (address(keccak256(pubkey)) == signer) return true;\n        else {\n            (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);\n            return (address(keccak256(pubkey)) == signer);\n        }\n    }\n\n    function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {\n        bool sigok;\n\n        // Step 6: verify the attestation signature, APPKEY1 must sign the sessionKey from the correct ledger app (CODEHASH)\n        bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);\n        copyBytes(proof, sig2offset, sig2.length, sig2, 0);\n\n        bytes memory appkey1_pubkey = new bytes(64);\n        copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);\n\n        bytes memory tosign2 = new bytes(1+65+32);\n        tosign2[0] = byte(1); //role\n        copyBytes(proof, sig2offset-65, 65, tosign2, 1);\n        bytes memory CODEHASH = hex\"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c\";\n        copyBytes(CODEHASH, 0, 32, tosign2, 1+65);\n        sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);\n\n        if (sigok == false) return false;\n\n\n        // Step 7: verify the APPKEY1 provenance (must be signed by Ledger)\n        bytes memory LEDGERKEY = hex\"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4\";\n\n        bytes memory tosign3 = new bytes(1+65);\n        tosign3[0] = 0xFE;\n        copyBytes(proof, 3, 65, tosign3, 1);\n\n        bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);\n        copyBytes(proof, 3+65, sig3.length, sig3, 0);\n\n        sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);\n\n        return sigok;\n    }\n\n    modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {\n        // Step 1: the prefix has to match 'LP\\x01' (Ledger Proof version 1)\n        require((_proof[0] == \"L\") && (_proof[1] == \"P\") && (_proof[2] == 1));\n\n        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n        require(proofVerified);\n\n        _;\n    }\n\n    function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){\n        // Step 1: the prefix has to match 'LP\\x01' (Ledger Proof version 1)\n        if ((_proof[0] != \"L\")||(_proof[1] != \"P\")||(_proof[2] != 1)) return 1;\n\n        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n        if (proofVerified == false) return 2;\n\n        return 0;\n    }\n\n    function matchBytes32Prefix(bytes32 content, bytes prefix, uint n_random_bytes) internal pure returns (bool){\n        bool match_ = true;\n\n        require(prefix.length == n_random_bytes);\n\n        for (uint256 i=0; i< n_random_bytes; i++) {\n            if (content[i] != prefix[i]) match_ = false;\n        }\n\n        return match_;\n    }\n\n    function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\n\n        // Step 2: the unique keyhash has to match with the sha256 of (context name + queryId)\n        uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32;\n        bytes memory keyhash = new bytes(32);\n        copyBytes(proof, ledgerProofLength, 32, keyhash, 0);\n        if (!(keccak256(keyhash) == keccak256(sha256(context_name, queryId)))) return false;\n\n        bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2);\n        copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0);\n\n        // Step 3: we assume sig1 is valid (it will be verified during step 5) and we verify if 'result' is the prefix of sha256(sig1)\n        if (!matchBytes32Prefix(sha256(sig1), result, uint(proof[ledgerProofLength+32+8]))) return false;\n\n        // Step 4: commitment match verification, keccak256(delay, nbytes, unonce, sessionKeyHash) == commitment in storage.\n        // This is to verify that the computed args match with the ones specified in the query.\n        bytes memory commitmentSlice1 = new bytes(8+1+32);\n        copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0);\n\n        bytes memory sessionPubkey = new bytes(64);\n        uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65;\n        copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0);\n\n        bytes32 sessionPubkeyHash = sha256(sessionPubkey);\n        if (oraclize_randomDS_args[queryId] == keccak256(commitmentSlice1, sessionPubkeyHash)){ //unonce, nbytes and sessionKeyHash match\n            delete oraclize_randomDS_args[queryId];\n        } else return false;\n\n\n        // Step 5: validity verification for sig1 (keyhash and args signed with the sessionKey)\n        bytes memory tosign1 = new bytes(32+8+1+32);\n        copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0);\n        if (!verifySig(sha256(tosign1), sig1, sessionPubkey)) return false;\n\n        // verify if sessionPubkeyHash was verified already, if not.. let's do it!\n        if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){\n            oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);\n        }\n\n        return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];\n    }\n\n    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\n    function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal pure returns (bytes) {\n        uint minLength = length + toOffset;\n\n        // Buffer too small\n        require(to.length >= minLength); // Should be a better way?\n\n        // NOTE: the offset 32 is added to skip the `size` field of both bytes variables\n        uint i = 32 + fromOffset;\n        uint j = 32 + toOffset;\n\n        while (i < (32 + fromOffset + length)) {\n            assembly {\n                let tmp := mload(add(from, i))\n                mstore(add(to, j), tmp)\n            }\n            i += 32;\n            j += 32;\n        }\n\n        return to;\n    }\n\n    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\n    // Duplicate Solidity's ecrecover, but catching the CALL return value\n    function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\n        // We do our own memory management here. Solidity uses memory offset\n        // 0x40 to store the current end of memory. We write past it (as\n        // writes are memory extensions), but don't update the offset so\n        // Solidity will reuse it. The memory used here is only needed for\n        // this context.\n\n        // FIXME: inline assembly can't access return values\n        bool ret;\n        address addr;\n\n        assembly {\n            let size := mload(0x40)\n            mstore(size, hash)\n            mstore(add(size, 32), v)\n            mstore(add(size, 64), r)\n            mstore(add(size, 96), s)\n\n            // NOTE: we can reuse the request memory because we deal with\n            //       the return code\n            ret := call(3000, 1, 0, size, 128, size, 32)\n            addr := mload(size)\n        }\n\n        return (ret, addr);\n    }\n\n    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\n    function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        if (sig.length != 65)\n          return (false, 0);\n\n        // The signature format is a compact form of:\n        //   {bytes32 r}{bytes32 s}{uint8 v}\n        // Compact means, uint8 is not padded to 32 bytes.\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n\n            // Here we are loading the last 32 bytes. We exploit the fact that\n            // 'mload' will pad with zeroes if we overread.\n            // There is no 'mload8' to do this, but that would be nicer.\n            v := byte(0, mload(add(sig, 96)))\n\n            // Alternative solution:\n            // 'byte' is not working due to the Solidity parser, so lets\n            // use the second best option, 'and'\n            // v := and(mload(add(sig, 65)), 255)\n        }\n\n        // albeit non-transactional signatures are not specified by the YP, one would expect it\n        // to match the YP range of [27, 28]\n        //\n        // geth uses [0, 1] and some clients have followed. This might change, see:\n        //  https://github.com/ethereum/go-ethereum/issues/2053\n        if (v < 27)\n          v += 27;\n\n        if (v != 27 && v != 28)\n            return (false, 0);\n\n        return safer_ecrecover(hash, v, r, s);\n    }\n\n}\n\ncontract BetContract is usingOraclize{\n  uint  maxProfit;//最高奖池\n  uint  maxmoneypercent;\n  uint public contractBalance;\n  uint minBet;\n  uint onoff;//游戏启用或关闭\n  address private owner;\n  uint private orderId;\n  uint private randonce;\n\n  event LogNewOraclizeQuery(string description,bytes32 queryId);\n  event LogNewRandomNumber(string result,bytes32 queryId);\n  event LogSendBonus(uint id,bytes32 lableId,uint playId,uint content,uint singleMoney,uint mutilple,address user,uint betTime,uint status,uint winMoney);\n  event LogBet(bytes32 queryId);\n\n  mapping (address => bytes32[]) playerLableList;//玩家下注批次\n  mapping (bytes32 => mapping (uint => uint[7])) betList;//批次，注单映射\n  mapping (bytes32 => uint) lableCount;//批次，注单数\n  mapping (bytes32 => uint) lableTime;//批次，投注时间\n  mapping (bytes32 => uint) lableStatus;//批次，状态 0 未结算，1 已撤单，2 已结算 3 已派奖\n  mapping (bytes32 => uint[3]) openNumberList;//批次开奖号码映射\n  mapping (bytes32 => string) openNumberStr;//批次开奖号码映射\n  mapping (bytes32 => address) lableUser;\n\n  function BetContract() public {\n    owner = msg.sender;\n    orderId = 0;\n\n    onoff=1;\n    minBet=1500000000000000;//最小金额要比手续费大\n    maxmoneypercent=80;\n    contractBalance = this.balance;\n    maxProfit=(this.balance * maxmoneypercent)/100;\n    randonce = 0;\n  }\n\n  /*\n    * uintToString\n    */\n   function uintToString(uint i) internal  returns (string){\n       if (i == 0) return \"0\";\n       uint j = i;\n       uint len;\n       while (j != 0){\n           len++;\n           j /= 10;\n       }\n       bytes memory bstr = new bytes(len);\n       uint k = len - 1;\n       while (i != 0){\n           bstr[k--] = byte(48 + i % 10);\n           i /= 10;\n       }\n       return string(bstr);\n   }\n\n\n  modifier onlyAdmin() {\n      require(msg.sender == owner);\n      _;\n  }\n\n  function setGameOnoff(uint _on0ff) public onlyAdmin{\n    onoff=_on0ff;\n  }\n\n  function getPlayRate(uint playId,uint level) internal pure returns (uint){\n      uint result = 0;\n      if(playId == 1 || playId == 2){\n        //大小单双，赔率放大了10倍\n        result = 19;\n      }else if(playId == 3){\n        //二同号复选\n        result = 11;\n      }else if(playId == 4){\n        //三同号单选\n        result = 156;\n      }else if(playId == 5){\n        //三同号通选\n        result = 26;\n      }else if(playId == 6){\n        //和值\n        if(level == 4 || level == 17){\n          result = 53;\n        }else if(level == 5 || level == 16){\n          result = 21;\n        }else if(level == 6 || level == 15){\n          result = 17;\n        }else if(level == 7 || level == 14){\n          result = 13;\n        }else if(level == 8 || level == 13){\n          result = 9;\n        }else if(level == 9 || level == 12){\n          result = 8;\n        }else if(level == 10 || level == 11){\n          result = 7;\n        }\n      }else if(playId == 7){\n        //二不同号\n        result = 6;\n      }else if(playId == 8){\n        //猜1个号，赔率放大了10倍\n        if(level == 1){\n          result = 19;//单色子\n        }else if(level == 2){\n          result = 28;//对子\n        }else if(level == 3){\n          result = 37;//豹子\n        }\n      }\n      return result;\n    }\n\n    function doBet(uint[] playid,uint[] betMoney,uint[] betContent,uint mutiply) public payable returns (bytes32) {\n      require(onoff==1);\n      require(playid.length > 0);\n      require(mutiply > 0);\n      require(msg.value >= minBet);\n\n      /* checkBet(playid,betMoney,betContent,mutiply,msg.value); */\n\n      /* uint total = 0; */\n      bytes32 queryId;\n      queryId = keccak256(block.blockhash(block.number-1),now,randonce);\n\n       uint[7] tmp ;\n       uint totalspand = 0;\n      for(uint i=0;i<playid.length;i++){\n        orderId++;\n        tmp[0] =orderId;\n        tmp[1] =playid[i];\n        tmp[2] =betContent[i];\n        tmp[3] =betMoney[i]*mutiply;\n        totalspand +=betMoney[i]*mutiply;\n        tmp[4] =now;\n        tmp[5] =0;\n        tmp[6] =0;\n        betList[queryId][i] =tmp;\n      }\n      require(msg.value >= totalspand);\n\n      lableTime[queryId] = now;\n      lableCount[queryId] = playid.length;\n      lableUser[queryId] = msg.sender;\n      uint[3] memory codes = [uint(0),0,0];//开奖号码\n      openNumberList[queryId] = codes;\n      openNumberStr[queryId] =\"0,0,0\";\n      lableStatus[queryId] = 0;\n\n      uint index=playerLableList[msg.sender].length++;\n      playerLableList[msg.sender][index]=queryId;//index:id\n      LogBet(queryId);\n      opencode(queryId);\n      return queryId;\n    }\n\n    function checkBet(uint[] playid,uint[] betMoney,uint[] betContent,uint mutiply,uint betTotal) internal{\n        uint totalMoney = 0;\n      uint totalWin1 = 0;//三个开奖号码不同时的盈利\n      uint totalWin2 = 0;//两个开奖号码相同时的盈利\n      uint totalWin3 = 0;//三个号码相同时的盈利\n      uint rate;\n      uint i;\n      for(i=0;i<playid.length;i++){\n        if(playid[i] >=1 && playid[i]<= 8){\n          totalMoney += betMoney[i] * mutiply;\n        }else{\n          throw;\n        }\n        if(playid[i] ==1 || playid[i] ==2){\n          rate = getPlayRate(playid[i],0)-10;\n          totalWin1+=betMoney[i] * mutiply *rate/10;\n          totalWin2+=betMoney[i] * mutiply *rate/10;\n        }else if(playid[i] ==3){\n          rate = getPlayRate(playid[i],0)-1;\n          totalWin2+=betMoney[i] * mutiply *rate;\n          totalWin3+=betMoney[i] * mutiply *rate;\n        }else if(playid[i] ==4 || playid[i] ==5){\n          rate = getPlayRate(playid[i],0)-1;\n          totalWin3+=betMoney[i] * mutiply *rate;\n        }else if(playid[i] ==6){\n          rate = getPlayRate(playid[i],betContent[i])-1;\n          totalWin1+=betMoney[i] * mutiply *rate;\n          totalWin2+=betMoney[i] * mutiply *rate;\n        }else if(playid[i] ==7){\n          rate = getPlayRate(playid[i],0)-1;\n          totalWin1+=betMoney[i] * mutiply *rate;\n          totalWin2+=betMoney[i] * mutiply *rate;\n        }else if(playid[i] ==8){\n          totalWin1+=betMoney[i] * mutiply *9/10;\n          totalWin2+=betMoney[i] * mutiply *18/10;\n          totalWin3+=betMoney[i] * mutiply *27/10;\n        }\n      }\n      uint maxWin=totalWin1;\n      if(totalWin2 > maxWin){\n        maxWin=totalWin2;\n      }\n      if(totalWin3 > maxWin){\n        maxWin=totalWin3;\n      }\n      require(betTotal >= totalMoney);\n\n      require(maxWin < maxProfit);\n    }\n\n    function opencode(bytes32 queryId) private {\n      if (lableCount[queryId] < 1) revert();\n      uint[3] memory codes = [uint(0),0,0];//开奖号码\n\n      bytes32 code0hash = keccak256(abi.encodePacked(block.blockhash(block.number-1), now,msg.sender,randonce));\n      randonce  = randonce + uint(code0hash)%10;\n      uint code0int = uint(code0hash) % 6 + 1;\n      bytes32 code1hash = keccak256(abi.encodePacked(block.blockhash(block.number-1), now,msg.sender,randonce));\n      randonce  = randonce + uint(code1hash)%10;\n      uint code1int = uint(code1hash) % 6 + 1;\n      bytes32 code2hash = keccak256(abi.encodePacked(block.blockhash(block.number-1), now,msg.sender,randonce));\n      randonce  = randonce + uint(code2hash)%10;\n      uint code2int = uint(code2hash) % 6 + 1;\n      var code0=uintToString(code0int);\n      var code1=uintToString(code1int);\n      var code2=uintToString(code2int);\n      codes[0] = code0int;\n      codes[1] = code1int;\n      codes[2] = code2int;\n      openNumberList[queryId] = codes;\n      openNumberStr[queryId] = strConcat(code0,\",\",code1,\",\",code2);\n\n      //结算，派奖\n      doCheckBounds(queryId);\n    }\n\n    function doCancel(bytes32 queryId) internal {\n      uint sta = lableStatus[queryId];\n      require(sta == 0);\n      uint[3] memory codes = openNumberList[queryId];\n      require(codes[0] == 0 || codes[1] == 0 ||codes[2] == 0);\n\n      uint totalBet = 0;\n      uint len = lableCount[queryId];\n\n      address to = lableUser[queryId];\n      for(uint aa = 0 ; aa<len; aa++){\n        //未结算\n        if(betList[queryId][aa][5] == 0){\n          totalBet+=betList[queryId][aa][3];\n        }\n      }\n\n      if(totalBet > 0){\n        to.transfer(totalBet);\n      }\n      contractBalance=this.balance;\n      maxProfit=(this.balance * maxmoneypercent)/100;\n      lableStatus[queryId] = 1;\n    }\n\n    function doSendBounds(bytes32 queryId) public payable {\n      uint sta = lableStatus[queryId];\n      require(sta == 2);\n\n      uint totalWin = 0;\n      uint len = lableCount[queryId];\n\n      address to = lableUser[queryId];\n      for(uint aa = 0 ; aa<len; aa++){\n        //中奖\n        if(betList[queryId][aa][5] == 2){\n          totalWin+=betList[queryId][aa][6];\n        }\n      }\n\n      if(totalWin > 0){\n          to.transfer(totalWin);//转账\n      }\n      lableStatus[queryId] = 3;\n      contractBalance=this.balance;\n      maxProfit=(this.balance * maxmoneypercent)/100;\n    }\n\n    //中奖判断\n    function checkWinMoney(uint[7] storage betinfo,uint[3] codes) internal {\n      uint rates;\n      if(betinfo[1] ==1){\n          //大小 豹子不中奖\n          if(codes[0] == codes[1] && codes[1] == codes[2]){\n            betinfo[5]=1;//未中奖\n          }else{\n            uint sum = codes[0]+codes[1]+codes[2];\n            if(sum >= 4 && sum < 11){\n              sum = 4;//小\n            }else if(sum >= 11 && sum < 18){\n              sum = 17;//大\n            }else{\n              sum = 0;\n            }\n            betinfo[5]=1;\n            if(sum >0 && betinfo[2] == sum){\n                betinfo[5]=2;\n                rates = getPlayRate(betinfo[1],0);\n                betinfo[6]=betinfo[3]*rates/10;\n            }\n\n          }\n      }else if(betinfo[1] == 2){\n          //单双 豹子不中奖\n          if(codes[0] == codes[1] && codes[1] == codes[2]){\n            betinfo[5]=1;//未中奖\n          }else{\n            uint sums = codes[0]+codes[1]+codes[2];\n            if(sums % 2 == 0){\n              sums = 2;//双\n            }else{\n              sums = 3;//单\n            }\n            betinfo[5]=1;\n            if(sums == betinfo[2]){\n              betinfo[5]=2;\n              rates = getPlayRate(betinfo[1],0);\n              betinfo[6]=betinfo[3]*rates/10;\n            }\n\n          }\n\n        }else if(betinfo[1] == 3){\n          //二同号复选\n          betinfo[5]=1;//不中奖\n          if(codes[0] == codes[1] || codes[1] == codes[2] ){\n            uint tmp = 0;\n            if(codes[0] == codes[1] ){\n              tmp = codes[0];\n            }else if(codes[1] == codes[2]){\n              tmp = codes[1];\n            }\n            if(tmp == betinfo[2]){\n              betinfo[5]=2;\n              rates = getPlayRate(betinfo[1],0);\n              betinfo[6]=betinfo[3]*rates;\n            }\n\n          }\n        }else if(betinfo[1] == 4){\n          //三同号单选\n          betinfo[5]=1;//不中奖\n          if(codes[0] == codes[1] && codes[1] == codes[2] ){\n            if(codes[0] == betinfo[2]){\n              betinfo[5]=2;\n              rates = getPlayRate(betinfo[1],0);\n              betinfo[6]=betinfo[3]*rates;\n            }\n          }\n        }else if(betinfo[1] == 5){\n          //三同号通选\n          betinfo[5]=1;//不中奖\n          if(codes[0] == codes[1] && codes[1] == codes[2] ){\n              betinfo[5]=2;\n              rates = getPlayRate(betinfo[1],0);\n              betinfo[6]=betinfo[3]*rates;\n          }\n        }else if(betinfo[1] == 6){\n          //和值 豹子不中奖\n          if(codes[0] == codes[1] && codes[1] == codes[2]){\n            betinfo[5]=1;//不中奖\n          }else{\n            betinfo[5]=1;//不中奖\n            uint sum6 = codes[0]+codes[1]+codes[2];\n            if(sum6 == betinfo[2]){\n              betinfo[5]=2;\n              rates = getPlayRate(betinfo[1],sum6);\n              betinfo[6]=betinfo[3]*rates;\n            }\n          }\n        }else if(betinfo[1] == 7){\n          //二不同号 豹子不中奖\n          if(codes[0] == codes[1] && codes[1] == codes[2]){\n            betinfo[5]=1;//不中奖\n          }else{\n            uint[2] memory haoma = getErbutongHao(betinfo[2]);\n            bool atmp=false;\n            bool btmp=false;\n            for(uint ai=0;ai<codes.length;ai++){\n              if(codes[ai] == haoma[0]){\n                atmp = true;\n                continue;\n              }\n              if(codes[ai] == haoma[1]){\n                btmp = true;\n                continue;\n              }\n            }\n            betinfo[5]=1;\n            if(atmp && btmp){\n              betinfo[5]=2;\n              rates = getPlayRate(betinfo[1],0);\n              betinfo[6]=betinfo[3]*rates;\n            }\n          }\n        }else if(betinfo[1] == 8){\n          //猜1个号，赔率放大了10倍\n          uint tmpp = 0;\n          betinfo[5]=1;//不中奖\n          if(codes[0] == betinfo[2]){\n            tmpp++;\n          }\n          if(codes[1] == betinfo[2]){\n            tmpp++;\n          }\n          if(codes[2] == betinfo[2]){\n            tmpp++;\n          }\n          if(tmpp > 0){\n            betinfo[5]=2;\n            rates = getPlayRate(betinfo[1],tmpp);\n            betinfo[6]=betinfo[3]*rates/10;\n          }\n        }\n\n    }\n\n    function getErbutongHao(uint sss) internal view returns(uint[2]){\n      uint[2] memory result ;\n      if(sss == 12){\n        result = [uint(1),2];\n      }else if(sss == 13){\n         result = [uint(1),3];\n      }else if(sss == 14){\n         result = [uint(1),4];\n      }else if(sss == 15){\n         result = [uint(1),5];\n      }else if(sss == 16){\n         result = [uint(1),6];\n      }else if(sss == 23){\n         result = [uint(2),3];\n      }else if(sss == 24){\n         result = [uint(2),4];\n      }else if(sss == 25){\n         result = [uint(2),5];\n      }else if(sss == 26){\n         result = [uint(2),6];\n      }else if(sss == 34){\n         result = [uint(3),4];\n      }else if(sss == 35){\n         result = [uint(3),5];\n      }else if(sss == 36){\n         result = [uint(3),6];\n      }else if(sss == 45){\n         result = [uint(4),5];\n      }else if(sss == 46){\n         result = [uint(4),6];\n      }else if(sss == 56){\n         result = [uint(5),6];\n      }\n      return (result);\n    }\n\n    function getLastBet() public view returns(string,uint[7][]){\n      uint len=playerLableList[msg.sender].length;\n      require(len>0);\n\n      uint i=len-1;\n      bytes32 lastLable = playerLableList[msg.sender][i];\n      uint max = lableCount[lastLable];\n      if(max > 50){\n          max = 50;\n      }\n      uint[7][] memory result = new uint[7][](max) ;\n      var opennum = \"\";\n      for(uint a=0;a<max;a++){\n         var ttmp =openNumberStr[lastLable];\n         if(a==0){\n           opennum =ttmp;\n         }else{\n           opennum = strConcat(opennum,\";\",ttmp);\n         }\n\n         result[a] = betList[lastLable][a];\n         if(lableStatus[lastLable] == 1){\n           result[a][5]=3;\n         }\n\n      }\n\n      return (opennum,result);\n    }\n\n    function getLableRecords(bytes32 lable) public view returns(string,uint[7][]){\n      uint max = lableCount[lable];\n      if(max > 50){\n          max = 50;\n      }\n      uint[7][] memory result = new uint[7][](max) ;\n      var opennum=\"\";\n\n      for(uint a=0;a<max;a++){\n         result[a] = betList[lable][a];\n         if(lableStatus[lable] == 1){\n           result[a][5]=3;\n         }\n         var ttmp =openNumberStr[lable];\n         if(a==0){\n           opennum =ttmp;\n         }else{\n           opennum = strConcat(opennum,\";\",ttmp);\n         }\n      }\n\n      return (opennum,result);\n    }\n\n    function getAllRecords() public view returns(string,uint[7][]){\n        uint len=playerLableList[msg.sender].length;\n        require(len>0);\n\n        uint max;\n        bytes32 lastLable ;\n        uint ss;\n\n        for(uint i1=0;i1<len;i1++){\n            ss = len-i1-1;\n            lastLable = playerLableList[msg.sender][ss];\n            max += lableCount[lastLable];\n            if(100 < max){\n              max = 100;\n              break;\n            }\n        }\n\n        uint[7][] memory result = new uint[7][](max) ;\n        bytes32[] memory resultlable = new bytes32[](max) ;\n        var opennum=\"\";\n\n        bool flag=false;\n        uint betnums;\n        uint j=0;\n\n        for(uint ii=0;ii<len;ii++){\n            ss = len-ii-1;\n            lastLable = playerLableList[msg.sender][ss];\n            betnums = lableCount[lastLable];\n            for(uint k= 0; k<betnums; k++){\n              if(j<max){\n                  resultlable[j] = lastLable;\n              \t var ttmp =openNumberStr[lastLable];\n                 if(j==0){\n                   opennum =ttmp;\n                 }else{\n                   opennum = strConcat(opennum,\";\",ttmp);\n                 }\n                  result[j] = betList[lastLable][k];\n                  if(lableStatus[lastLable] == 1){\n                    result[j][5]=3;\n                  }else if(lableStatus[lastLable] == 2){\n                    if(result[j][5]==2){\n                      result[j][5]=4;\n                    }\n                  }else if(lableStatus[lastLable] == 3){\n                    if(result[j][5]==2){\n                      result[j][5]=5;\n                    }\n                  }\n                  j++;\n              }else{\n                flag = true;\n                break;\n              }\n            }\n            if(flag){\n                break;\n            }\n        }\n        return (opennum,result);\n    }\n\n  function senttest() public payable onlyAdmin{\n      contractBalance=this.balance;\n      maxProfit=(this.balance*maxmoneypercent)/100;\n  }\n\n  function setRandomSeed(uint _randomSeed) public payable onlyAdmin{\n      randonce = _randomSeed;\n  }\n\n  function getRandomSeed() public view onlyAdmin returns(uint _randonce) {\n      _randonce = randonce;\n  }\n\n  function withdraw(uint _amount , address desaccount) public onlyAdmin{\n      desaccount.transfer(_amount);\n      contractBalance=this.balance;\n      maxProfit=(this.balance * maxmoneypercent)/100;\n  }\n\n  function getDatas() public view returns(\n    uint _maxProfit,\n    uint _minBet,\n    uint _contractbalance,\n    uint _onoff,\n    address _owner\n    //uint _oraclizeFee\n    ){\n        _maxProfit=maxProfit;\n        _minBet=minBet;\n        _contractbalance=contractBalance;\n        _onoff=onoff;\n        _owner=owner;\n    }\n\n    function getLableList() public view returns(string,bytes32[],uint[],uint[],uint){\n      uint len=playerLableList[msg.sender].length;\n      require(len>0);\n\n      uint max=50;\n      if(len < 50){\n          max = len;\n      }\n\n      bytes32[] memory lablelist = new bytes32[](max) ;\n      uint[] memory labletime = new uint[](max) ;\n      uint[] memory lablestatus = new uint[](max) ;\n      var opennum=\"\";\n\n      bytes32 lastLable ;\n      for(uint i=0;i<max;i++){\n          lastLable = playerLableList[msg.sender][max-i-1];\n          lablelist[i]=lastLable;\n          labletime[i]=lableTime[lastLable];\n          lablestatus[i]=lableStatus[lastLable];\n          var ttmp =openNumberStr[lastLable];\n         if(i==0){\n           opennum =ttmp;\n         }else{\n           opennum = strConcat(opennum,\";\",ttmp);\n         }\n      }\n\n      return (opennum,lablelist,labletime,lablestatus,now);\n    }\n\n    function doCheckBounds(bytes32 queryId) internal{\n        uint sta = lableStatus[queryId];\n        require(sta == 0 || sta == 2);\n        uint[3] memory codes = openNumberList[queryId];\n        require(codes[0] > 0);\n        //结算\n        uint len = lableCount[queryId];\n\n        uint totalWin;\n        address to = lableUser[queryId];\n        for(uint aa = 0 ; aa<len; aa++){\n          //未结算\n          if(sta == 0){\n           if(betList[queryId][aa][5] == 0){\n             checkWinMoney(betList[queryId][aa],codes);\n             totalWin+=betList[queryId][aa][6];\n           }\n          }else if(sta == 2){\n              totalWin+=betList[queryId][aa][6];\n          }\n        }\n\n        lableStatus[queryId] = 2;\n        //派奖\n        if(totalWin > 0){\n          if(totalWin < this.balance){\n            to.transfer(totalWin);//转账\n            lableStatus[queryId] = 3;\n          }else{\n              LogNewOraclizeQuery(\"sent bouns fail.\",queryId);\n          }\n        }else{\n          lableStatus[queryId] = 3;\n        }\n        contractBalance=this.balance;\n        maxProfit=(this.balance * maxmoneypercent)/100;\n    }\n\n    function getOpenNum(bytes32 queryId) public view returns(string){\n        return openNumberStr[queryId];\n    }\n\n    function doCheckSendBounds() public payable{\n        uint len=playerLableList[msg.sender].length;\n\n      uint max=50;\n      if(len < 50){\n          max = len;\n      }\n\n      uint sta;\n      bytes32 lastLable ;\n      for(uint i=0;i<max;i++){\n          lastLable = playerLableList[msg.sender][max-i-1];\n          sta = lableStatus[lastLable];\n          if(sta == 0 || sta==2){\n            doCheckBounds(lastLable);\n          }\n      }\n    }\n    \n    function deposit() public payable onlyAdmin returns(uint8 ret){\n        contractBalance=this.balance;\n        maxProfit=(this.balance * maxmoneypercent)/100;\n        ret = 1;\n    }\n\n    function doCancelAll() public payable{\n        uint len=playerLableList[msg.sender].length;\n\n      uint max=50;\n      if(len < 50){\n          max = len;\n      }\n\n      uint sta;\n      uint bettime;\n      bytes32 lastLable ;\n      for(uint i=0;i<max;i++){\n          lastLable = playerLableList[msg.sender][max-i-1];\n          sta = lableStatus[lastLable];\n          bettime = lableTime[lastLable];\n          if(sta == 0 && (now - bettime)>600){\n            doCancel(lastLable);\n          }\n      }\n    }\n}",
  "abi": "[{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"desaccount\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"queryId\",\"type\":\"bytes32\"}],\"name\":\"getOpenNum\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"lable\",\"type\":\"bytes32\"}],\"name\":\"getLableRecords\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"uint256[7][]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"myid\",\"type\":\"bytes32\"},{\"name\":\"result\",\"type\":\"string\"}],\"name\":\"__callback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"myid\",\"type\":\"bytes32\"},{\"name\":\"result\",\"type\":\"string\"},{\"name\":\"proof\",\"type\":\"bytes\"}],\"name\":\"__callback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLableList\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"bytes32[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_randomSeed\",\"type\":\"uint256\"}],\"name\":\"setRandomSeed\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"doCancelAll\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDatas\",\"outputs\":[{\"name\":\"_maxProfit\",\"type\":\"uint256\"},{\"name\":\"_minBet\",\"type\":\"uint256\"},{\"name\":\"_contractbalance\",\"type\":\"uint256\"},{\"name\":\"_onoff\",\"type\":\"uint256\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_on0ff\",\"type\":\"uint256\"}],\"name\":\"setGameOnoff\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRandomSeed\",\"outputs\":[{\"name\":\"_randonce\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"doCheckSendBounds\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllRecords\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"uint256[7][]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"queryId\",\"type\":\"bytes32\"}],\"name\":\"doSendBounds\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLastBet\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"uint256[7][]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[{\"name\":\"ret\",\"type\":\"uint8\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"playid\",\"type\":\"uint256[]\"},{\"name\":\"betMoney\",\"type\":\"uint256[]\"},{\"name\":\"betContent\",\"type\":\"uint256[]\"},{\"name\":\"mutiply\",\"type\":\"uint256\"}],\"name\":\"doBet\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"senttest\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"description\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"queryId\",\"type\":\"bytes32\"}],\"name\":\"LogNewOraclizeQuery\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"result\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"queryId\",\"type\":\"bytes32\"}],\"name\":\"LogNewRandomNumber\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"lableId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"playId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"content\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"singleMoney\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"mutilple\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"betTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"status\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winMoney\",\"type\":\"uint256\"}],\"name\":\"LogSendBonus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"queryId\",\"type\":\"bytes32\"}],\"name\":\"LogBet\",\"type\":\"event\"}]",
  "bytecode": "608060405234801561001057600080fd5b5033600a60006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506000600b8190555060016009819055506605543df729c00060088190555060506006819055503073ffffffffffffffffffffffffffffffffffffffff163160078190555060646006543073ffffffffffffffffffffffffffffffffffffffff1631028115156100bd57fe5b046005819055506000600c81905550614bff80620000dc6000396000f300608060405260043610610106576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168062f714ce1461010b578063039c9d841461015857806303dc05321461020257806327dc297e1461031757806338bbfa501461038e5780635b945c0e1461044b57806366fea1d4146105ba5780636c0a1117146105da5780636d34a775146105e4578063749ca1f3146106575780638b7afe2e1461068457806393b3cc6b146106af5780639536c05f146106da578063a7f9fe72146106e4578063ae817dd1146107df578063bbce3fc214610803578063d0e30db0146108fe578063fc22341014610922578063fca2d9f514610a27575b600080fd5b34801561011757600080fd5b5061015660048036038101908080359060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610a31565b005b34801561016457600080fd5b506101876004803603810190808035600019169060200190929190505050610b24565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156101c75780820151818401526020810190506101ac565b50505050905090810190601f1680156101f45780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b34801561020e57600080fd5b506102316004803603810190808035600019169060200190929190505050610be1565b604051808060200180602001838103835285818151815260200191508051906020019080838360005b8381101561027557808201518184015260208101905061025a565b50505050905090810190601f1680156102a25780820380516001836020036101000a031916815260200191505b508381038252848181518152602001915080516000925b8184101561030457828490602001906020020151600760200280838360005b838110156102f35780820151818401526020810190506102d8565b5050505090500192600101926102b9565b9250505094505050505060405180910390f35b34801561032357600080fd5b5061038c6004803603810190808035600019169060200190929190803590602001908201803590602001908080601f0160208091040260200160405190810160405280939291908181526020018383808284378201915050505050509192919290505050610f0e565b005b34801561039a57600080fd5b506104496004803603810190808035600019169060200190929190803590602001908201803590602001908080601f0160208091040260200160405190810160405280939291908181526020018383808284378201915050505050509192919290803590602001908201803590602001908080601f0160208091040260200160405190810160405280939291908181526020018383808284378201915050505050509192919290505050610f51565b005b34801561045757600080fd5b50610460610f56565b604051808060200180602001806020018060200186815260200185810385528a818151815260200191508051906020019080838360005b838110156104b2578082015181840152602081019050610497565b50505050905090810190601f1680156104df5780820380516001836020036101000a031916815260200191505b50858103845289818151815260200191508051906020019060200280838360005b8381101561051b578082015181840152602081019050610500565b50505050905001858103835288818151815260200191508051906020019060200280838360005b8381101561055d578082015181840152602081019050610542565b50505050905001858103825287818151815260200191508051906020019060200280838360005b8381101561059f578082015181840152602081019050610584565b50505050905001995050505050505050505060405180910390f35b6105d86004803603810190808035906020019092919050505061134b565b005b6105e26113b1565b005b3480156105f057600080fd5b506105f96114ee565b604051808681526020018581526020018481526020018381526020018273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019550505050505060405180910390f35b34801561066357600080fd5b5061068260048036038101908080359060200190929190505050611536565b005b34801561069057600080fd5b5061069961159c565b6040518082815260200191505060405180910390f35b3480156106bb57600080fd5b506106c46115a2565b6040518082815260200191505060405180910390f35b6106e2611608565b005b3480156106f057600080fd5b506106f9611721565b604051808060200180602001838103835285818151815260200191508051906020019080838360005b8381101561073d578082015181840152602081019050610722565b50505050905090810190601f16801561076a5780820380516001836020036101000a031916815260200191505b508381038252848181518152602001915080516000925b818410156107cc57828490602001906020020151600760200280838360005b838110156107bb5780820151818401526020810190506107a0565b505050509050019260010192610781565b9250505094505050505060405180910390f35b6108016004803603810190808035600019169060200190929190505050611d7a565b005b34801561080f57600080fd5b50610818611f74565b604051808060200180602001838103835285818151815260200191508051906020019080838360005b8381101561085c578082015181840152602081019050610841565b50505050905090810190601f1680156108895780820380516001836020036101000a031916815260200191505b508381038252848181518152602001915080516000925b818410156108eb57828490602001906020020151600760200280838360005b838110156108da5780820151818401526020810190506108bf565b5050505090500192600101926108a0565b9250505094505050505060405180910390f35b61090661235a565b604051808260ff1660ff16815260200191505060405180910390f35b610a096004803603810190808035906020019082018035906020019080806020026020016040519081016040528093929190818152602001838360200280828437820191505050505050919291929080359060200190820180359060200190808060200260200160405190810160405280939291908181526020018383602002808284378201915050505050509192919290803590602001908201803590602001908080602002602001604051908101604052809392919081815260200183836020028082843782019150505050505091929192908035906020019092919050505061240b565b60405180826000191660001916815260200191505060405180910390f35b610a2f612884565b005b600a60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16141515610a8d57600080fd5b8073ffffffffffffffffffffffffffffffffffffffff166108fc839081150290604051600060405180830381858888f19350505050158015610ad3573d6000803e3d6000fd5b503073ffffffffffffffffffffffffffffffffffffffff163160078190555060646006543073ffffffffffffffffffffffffffffffffffffffff163102811515610b1957fe5b046005819055505050565b60606013600083600019166000191681526020019081526020016000208054600181600116156101000203166002900480601f016020809104026020016040519081016040528092919081815260200182805460018160011615610100020316600290048015610bd55780601f10610baa57610100808354040283529160200191610bd5565b820191906000526020600020905b815481529060010190602001808311610bb857829003601f168201915b50505050509050919050565b6060806000606080600080600f600089600019166000191681526020019081526020016000205494506032851115610c1857603294505b84604051908082528060200260200182016040528015610c5257816020015b610c3f6149f8565b815260200190600190039081610c375790505b50935060206040519081016040528060008152509250600091505b84821015610efe57600e600089600019166000191681526020019081526020016000206000838152602001908152602001600020600780602002604051908101604052809291908260078015610cd8576020028201915b815481526020019060010190808311610cc4575b50505050508483815181101515610ceb57fe5b906020019060200201819052506001601160008a60001916600019168152602001908152602001600020541415610d4e5760038483815181101515610d2c57fe5b906020019060200201516005600781101515610d4457fe5b6020020181815250505b60136000896000191660001916815260200190815260200160002090506000821415610e1557808054600181600116156101000203166002900480601f016020809104026020016040519081016040528092919081815260200182805460018160011615610100020316600290048015610e095780601f10610dde57610100808354040283529160200191610e09565b820191906000526020600020905b815481529060010190602001808311610dec57829003601f168201915b50505050509250610ef1565b610eee836040805190810160405280600181526020017f3b00000000000000000000000000000000000000000000000000000000000000815250838054600181600116156101000203166002900480601f016020809104026020016040519081016040528092919081815260200182805460018160011615610100020316600290048015610ee45780601f10610eb957610100808354040283529160200191610ee4565b820191906000526020600020905b815481529060010190602001808311610ec757829003601f168201915b505050505061292e565b92505b8180600101925050610c6d565b8284965096505050505050915091565b610f4d828260006040519080825280601f01601f191660200182016040528015610f475781602001602082028038833980820191505090505b50610f51565b5050565b505050565b60608060608060008060006060806060806000806000600d60003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020805490509850600089111515610fc057600080fd5b603297506032891015610fd1578897505b876040519080825280602002602001820160405280156110005781602001602082028038833980820191505090505b509650876040519080825280602002602001820160405280156110325781602001602082028038833980820191505090505b509550876040519080825280602002602001820160405280156110645781602001602082028038833980820191505090505b50945060206040519081016040528060008152509350600091505b8782101561132c57600d60003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206001838a03038154811015156110d857fe5b906000526020600020015492508287838151811015156110f457fe5b90602001906020020190600019169081600019168152505060106000846000191660001916815260200190815260200160002054868381518110151561113657fe5b906020019060200201818152505060116000846000191660001916815260200190815260200160002054858381518110151561116e57fe5b90602001906020020181815250506013600084600019166000191681526020019081526020016000209050600082141561124357808054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156112375780601f1061120c57610100808354040283529160200191611237565b820191906000526020600020905b81548152906001019060200180831161121a57829003601f168201915b5050505050935061131f565b61131c846040805190810160405280600181526020017f3b00000000000000000000000000000000000000000000000000000000000000815250838054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156113125780601f106112e757610100808354040283529160200191611312565b820191906000526020600020905b8154815290600101906020018083116112f557829003601f168201915b505050505061292e565b93505b818060010192505061107f565b83878787429d509d509d509d509d505050505050505050509091929394565b600a60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415156113a757600080fd5b80600c8190555050565b600080600080600080600d60003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020805490509550603294506032861015611410578594505b600090505b848110156114e657600d60003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060018287030381548110151561146e57fe5b906000526020600020015491506011600083600019166000191681526020019081526020016000205493506010600083600019166000191681526020019081526020016000205492506000841480156114ca5750610258834203115b156114d9576114d882612966565b5b8080600101915050611415565b505050505050565b60008060008060006005549450600854935060075492506009549150600a60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690509091929394565b600a60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614151561159257600080fd5b8060098190555050565b60075481565b6000600a60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614151561160057600080fd5b600c54905090565b6000806000806000600d60003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020805490509450603293506032851015611666578493505b600090505b8381101561171a57600d60003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206001828603038154811015156116c457fe5b9060005260206000200154915060116000836000191660001916815260200190815260200160002054925060008314806116fe5750600283145b1561170d5761170c82612c20565b5b808060010191505061166b565b5050505050565b60608060008060008060006060806060600080600080600080600d60003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020805490509d5060008e11151561178e57600080fd5b600099505b8d8a101561183b5760018a8f03039a50600d60003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208b8154811015156117ef57fe5b90600052602060002001549b50600f60008d60001916600019168152602001908152602001600020548d019c508c6064101561182e5760649c5061183b565b89806001019a5050611793565b8c60405190808252806020026020018201604052801561187557816020015b6118626149f8565b81526020019060019003908161185a5790505b5098508c6040519080825280602002602001820160405280156118a75781602001602082028038833980820191505090505b509750602060405190810160405280600081525096506000955060009350600092505b8d831015611d62576001838f03039a50600d60003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208b81548110151561192657fe5b90600052602060002001549b50600f60008d60001916600019168152602001908152602001600020549450600091505b84821015611d4a578c841015611d34578b888581518110151561197557fe5b906020019060200201906000191690816000191681525050601360008d6000191660001916815260200190815260200160002090506000841415611a5457808054600181600116156101000203166002900480601f016020809104026020016040519081016040528092919081815260200182805460018160011615610100020316600290048015611a485780601f10611a1d57610100808354040283529160200191611a48565b820191906000526020600020905b815481529060010190602001808311611a2b57829003601f168201915b50505050509650611b30565b611b2d876040805190810160405280600181526020017f3b00000000000000000000000000000000000000000000000000000000000000815250838054600181600116156101000203166002900480601f016020809104026020016040519081016040528092919081815260200182805460018160011615610100020316600290048015611b235780601f10611af857610100808354040283529160200191611b23565b820191906000526020600020905b815481529060010190602001808311611b0657829003601f168201915b505050505061292e565b96505b600e60008d600019166000191681526020019081526020016000206000838152602001908152602001600020600780602002604051908101604052809291908260078015611b93576020028201915b815481526020019060010190808311611b7f575b50505050508985815181101515611ba657fe5b906020019060200201819052506001601160008e60001916600019168152602001908152602001600020541415611c0d5760038985815181101515611be757fe5b906020019060200201516005600781101515611bff57fe5b602002018181525050611d27565b6002601160008e60001916600019168152602001908152602001600020541415611c9b5760028985815181101515611c4157fe5b906020019060200201516005600781101515611c5957fe5b60200201511415611c965760048985815181101515611c7457fe5b906020019060200201516005600781101515611c8c57fe5b6020020181815250505b611d26565b6003601160008e60001916600019168152602001908152602001600020541415611d255760028985815181101515611ccf57fe5b906020019060200201516005600781101515611ce757fe5b60200201511415611d245760058985815181101515611d0257fe5b906020019060200201516005600781101515611d1a57fe5b6020020181815250505b5b5b5b8380600101945050611d3d565b60019550611d4a565b8180600101925050611956565b8515611d5557611d62565b82806001019350506118ca565b86899f509f5050505050505050505050505050509091565b6000806000806000601160008760001916600019168152602001908152602001600020549450600285141515611daf57600080fd5b60009350600f6000876000191660001916815260200190815260200160002054925060146000876000191660001916815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169150600090505b82811015611eae576002600e6000886000191660001916815260200190815260200160002060008381526020019081526020016000206005600781101515611e5857fe5b01541415611ea157600e6000876000191660001916815260200190815260200160002060008281526020019081526020016000206006600781101515611e9a57fe5b0154840193505b8080600101915050611e14565b6000841115611eff578173ffffffffffffffffffffffffffffffffffffffff166108fc859081150290604051600060405180830381858888f19350505050158015611efd573d6000803e3d6000fd5b505b6003601160008860001916600019168152602001908152602001600020819055503073ffffffffffffffffffffffffffffffffffffffff163160078190555060646006543073ffffffffffffffffffffffffffffffffffffffff163102811515611f6557fe5b04600581905550505050505050565b606080600080600080606080600080600d60003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020805490509750600088111515611fd757600080fd5b600188039650600d60003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208781548110151561202957fe5b90600052602060002001549550600f60008760001916600019168152602001908152602001600020549450603285111561206257603294505b8460405190808252806020026020018201604052801561209c57816020015b6120896149f8565b8152602001906001900390816120815790505b50935060206040519081016040528060008152509250600091505b84821015612348576013600087600019166000191681526020019081526020016000209050600082141561218657808054600181600116156101000203166002900480601f01602080910402602001604051908101604052809291908181526020018280546001816001161561010002031660029004801561217a5780601f1061214f5761010080835404028352916020019161217a565b820191906000526020600020905b81548152906001019060200180831161215d57829003601f168201915b50505050509250612262565b61225f836040805190810160405280600181526020017f3b00000000000000000000000000000000000000000000000000000000000000815250838054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156122555780601f1061222a57610100808354040283529160200191612255565b820191906000526020600020905b81548152906001019060200180831161223857829003601f168201915b505050505061292e565b92505b600e6000876000191660001916815260200190815260200160002060008381526020019081526020016000206007806020026040519081016040528092919082600780156122c5576020028201915b8154815260200190600101908083116122b1575b505050505084838151811015156122d857fe5b90602001906020020181905250600160116000886000191660001916815260200190815260200160002054141561233b576003848381518110151561231957fe5b90602001906020020151600560078110151561233157fe5b6020020181815250505b81806001019250506120b7565b82849950995050505050505050509091565b6000600a60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415156123b857600080fd5b3073ffffffffffffffffffffffffffffffffffffffff163160078190555060646006543073ffffffffffffffffffffffffffffffffffffffff1631028115156123fd57fe5b046005819055506001905090565b600080600080600061241b614a1b565b6000600160095414151561242e57600080fd5b60008b5111151561243e57600080fd5b60008811151561244d57600080fd5b600854341015151561245e57600080fd5b600143034042600c5460405180846000191660001916815260200183815260200182815260200193505050506040518091039020955060009350600092505b8a518310156125fd57600b60008154809291906001019190505550600b548560006007811015156124ca57fe5b01819055508a838151811015156124dd57fe5b906020019060200201518560016007811015156124f657fe5b0181905550888381518110151561250957fe5b9060200190602002015185600260078110151561252257fe5b0181905550878a8481518110151561253657fe5b906020019060200201510285600360078110151561255057fe5b0181905550878a8481518110151561256457fe5b9060200190602002015102840193504285600460078110151561258357fe5b0181905550600085600560078110151561259957fe5b018190555060008560066007811015156125af57fe5b018190555084600e6000886000191660001916815260200190815260200160002060008581526020019081526020016000209060076125ef929190614a3e565b50828060010193505061249d565b83341015151561260c57600080fd5b42601060008860001916600019168152602001908152602001600020819055508a51600f60008860001916600019168152602001908152602001600020819055503360146000886000191660001916815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550606060405190810160405280600081526020016000815260200160008152509150816012600088600019166000191681526020019081526020016000209060036126f2929190614a7b565b506040805190810160405280600581526020017f302c302c300000000000000000000000000000000000000000000000000000008152506013600088600019166000191681526020019081526020016000209080519060200190612757929190614abb565b50600060116000886000191660001916815260200190815260200160002081905550600d60003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002080548091906001016127ca9190614b3b565b905085600d60003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208281548110151561281957fe5b9060005260206000200181600019169055507fac038f3304801eaaf8be5e1857433a1cd22f8b6384720ccb25c1f291f74167848660405180826000191660001916815260200191505060405180910390a161287386613017565b859650505050505050949350505050565b600a60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415156128e057600080fd5b3073ffffffffffffffffffffffffffffffffffffffff163160078190555060646006543073ffffffffffffffffffffffffffffffffffffffff16310281151561292557fe5b04600581905550565b606061295d8484846020604051908101604052806000815250602060405190810160405280600081525061350c565b90509392505050565b6000612970614a1b565b6000806000806011600088600019166000191681526020019081526020016000205495506000861415156129a357600080fd5b6012600088600019166000191681526020019081526020016000206003806020026040519081016040528092919082600380156129f5576020028201915b8154815260200190600101908083116129e1575b505050505094506000856000600381101515612a0d57fe5b60200201511480612a3157506000856001600381101515612a2a57fe5b6020020151145b80612a4f57506000856002600381101515612a4857fe5b6020020151145b1515612a5a57600080fd5b60009350600f6000886000191660001916815260200190815260200160002054925060146000886000191660001916815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169150600090505b82811015612b59576000600e6000896000191660001916815260200190815260200160002060008381526020019081526020016000206005600781101515612b0357fe5b01541415612b4c57600e6000886000191660001916815260200190815260200160002060008281526020019081526020016000206003600781101515612b4557fe5b0154840193505b8080600101915050612abf565b6000841115612baa578173ffffffffffffffffffffffffffffffffffffffff166108fc859081150290604051600060405180830381858888f19350505050158015612ba8573d6000803e3d6000fd5b505b3073ffffffffffffffffffffffffffffffffffffffff163160078190555060646006543073ffffffffffffffffffffffffffffffffffffffff163102811515612bef57fe5b0460058190555060016011600089600019166000191681526020019081526020016000208190555050505050505050565b6000612c2a614a1b565b6000806000806011600088600019166000191681526020019081526020016000205495506000861480612c5d5750600286145b1515612c6857600080fd5b601260008860001916600019168152602001908152602001600020600380602002604051908101604052809291908260038015612cba576020028201915b815481526020019060010190808311612ca6575b505050505094506000856000600381101515612cd257fe5b6020020151111515612ce357600080fd5b600f6000886000191660001916815260200190815260200160002054935060146000886000191660001916815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169150600090505b83811015612e6c576000861415612e14576000600e6000896000191660001916815260200190815260200160002060008381526020019081526020016000206005600781101515612d9157fe5b01541415612e0f57612dce600e60008960001916600019168152602001908152602001600020600083815260200190815260200160002086613921565b600e6000886000191660001916815260200190815260200160002060008281526020019081526020016000206006600781101515612e0857fe5b0154830192505b612e5f565b6002861415612e5e57600e6000886000191660001916815260200190815260200160002060008281526020019081526020016000206006600781101515612e5757fe5b0154830192505b5b8080600101915050612d44565b6002601160008960001916600019168152602001908152602001600020819055506000831115612fa0573073ffffffffffffffffffffffffffffffffffffffff1631831015612f22578173ffffffffffffffffffffffffffffffffffffffff166108fc849081150290604051600060405180830381858888f19350505050158015612efb573d6000803e3d6000fd5b50600360116000896000191660001916815260200190815260200160002081905550612f9b565b7fd236fd58fd44deb7eda9b265c67a35dbe57eb585b61cd9b657cda55ce2dd74848760405180806020018360001916600019168152602001828103825260108152602001807f73656e7420626f756e73206661696c2e000000000000000000000000000000008152506020019250505060405180910390a15b612fc2565b6003601160008960001916600019168152602001908152602001600020819055505b3073ffffffffffffffffffffffffffffffffffffffff163160078190555060646006543073ffffffffffffffffffffffffffffffffffffffff16310281151561300757fe5b0460058190555050505050505050565b61301f614a1b565b60008060008060008060608060606001600f60008d6000191660001916815260200190815260200160002054101561305657600080fd5b60606040519081016040528060008152602001600081526020016000815250995060014303404233600c546040516020018085600019166000191681526020018481526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166c010000000000000000000000000281526014018281526020019450505050506040516020818303038152906040526040518082805190602001908083835b60208310151561312d5780518252602082019150602081019050602083039250613108565b6001836020036101000a03801982511681845116808217855250505050505090500191505060405180910390209850600a896001900481151561316c57fe5b06600c5401600c81905550600160068a6001900481151561318957fe5b0601975060014303404233600c546040516020018085600019166000191681526020018481526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166c010000000000000000000000000281526014018281526020019450505050506040516020818303038152906040526040518082805190602001908083835b602083101515613243578051825260208201915060208101905060208303925061321e565b6001836020036101000a03801982511681845116808217855250505050505090500191505060405180910390209650600a876001900481151561328257fe5b06600c5401600c8190555060016006886001900481151561329f57fe5b0601955060014303404233600c546040516020018085600019166000191681526020018481526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166c010000000000000000000000000281526014018281526020019450505050506040516020818303038152906040526040518082805190602001908083835b6020831015156133595780518252602082019150602081019050602083039250613334565b6001836020036101000a03801982511681845116808217855250505050505090500191505060405180910390209450600a856001900481151561339857fe5b06600c5401600c819055506001600686600190048115156133b557fe5b060193506133c2886144a0565b92506133cd866144a0565b91506133d8846144a0565b9050878a60006003811015156133ea57fe5b602002018181525050858a600160038110151561340357fe5b602002018181525050838a600260038110151561341c57fe5b60200201818152505089601260008d6000191660001916815260200190815260200160002090600361344f929190614a7b565b506134c7836040805190810160405280600181526020017f2c00000000000000000000000000000000000000000000000000000000000000815250846040805190810160405280600181526020017f2c000000000000000000000000000000000000000000000000000000000000008152508561350c565b601360008d6000191660001916815260200190815260200160002090805190602001906134f5929190614abb565b506134ff8b612c20565b5050505050505050505050565b6060806060806060806060806000808e98508d97508c96508b95508a94508451865188518a518c51010101016040519080825280601f01601f19166020018201604052801561356a5781602001602082028038833980820191505090505b50935083925060009150600090505b885181101561362c57888181518110151561359057fe5b9060200101517f010000000000000000000000000000000000000000000000000000000000000090047f01000000000000000000000000000000000000000000000000000000000000000283838060010194508151811015156135ef57fe5b9060200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053508080600101915050613579565b600090505b87518110156136e457878181518110151561364857fe5b9060200101517f010000000000000000000000000000000000000000000000000000000000000090047f01000000000000000000000000000000000000000000000000000000000000000283838060010194508151811015156136a757fe5b9060200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053508080600101915050613631565b600090505b865181101561379c57868181518110151561370057fe5b9060200101517f010000000000000000000000000000000000000000000000000000000000000090047f010000000000000000000000000000000000000000000000000000000000000002838380600101945081518110151561375f57fe5b9060200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535080806001019150506136e9565b600090505b85518110156138545785818151811015156137b857fe5b9060200101517f010000000000000000000000000000000000000000000000000000000000000090047f010000000000000000000000000000000000000000000000000000000000000002838380600101945081518110151561381757fe5b9060200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535080806001019150506137a1565b600090505b845181101561390c57848181518110151561387057fe5b9060200101517f010000000000000000000000000000000000000000000000000000000000000090047f01000000000000000000000000000000000000000000000000000000000000000283838060010194508151811015156138cf57fe5b9060200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053508080600101915050613859565b82995050505050505050505095945050505050565b6000806000806000613931614b67565b60008060008060018c600160078110151561394857fe5b01541415613af5578a600160038110151561395f57fe5b60200201518b600060038110151561397357fe5b60200201511480156139aa57508a600260038110151561398f57fe5b60200201518b60016003811015156139a357fe5b6020020151145b156139ca5760018c60056007811015156139c057fe5b0181905550613af0565b8a60026003811015156139d957fe5b60200201518b60016003811015156139ed57fe5b60200201518c6000600381101515613a0157fe5b60200201510101985060048910158015613a1b5750600b89105b15613a295760049850613a4e565b600b8910158015613a3a5750601289105b15613a485760119850613a4d565b600098505b5b60018c6005600781101515613a5f57fe5b0181905550600089118015613a835750888c6002600781101515613a7f57fe5b0154145b15613aef5760028c6005600781101515613a9957fe5b0181905550613ab98c6001600781101515613ab057fe5b015460006145f7565b9950600a8a8d6003600781101515613acd57fe5b015402811515613ad957fe5b048c6006600781101515613ae957fe5b01819055505b5b614492565b60028c6001600781101515613b0657fe5b01541415613c86578a6001600381101515613b1d57fe5b60200201518b6000600381101515613b3157fe5b6020020151148015613b6857508a6002600381101515613b4d57fe5b60200201518b6001600381101515613b6157fe5b6020020151145b15613b885760018c6005600781101515613b7e57fe5b0181905550613c81565b8a6002600381101515613b9757fe5b60200201518b6001600381101515613bab57fe5b60200201518c6000600381101515613bbf57fe5b6020020151010197506000600289811515613bd657fe5b061415613be65760029750613beb565b600397505b60018c6005600781101515613bfc57fe5b01819055508b6002600781101515613c1057fe5b0154881415613c805760028c6005600781101515613c2a57fe5b0181905550613c4a8c6001600781101515613c4157fe5b015460006145f7565b9950600a8a8d6003600781101515613c5e57fe5b015402811515613c6a57fe5b048c6006600781101515613c7a57fe5b01819055505b5b614491565b60038c6001600781101515613c9757fe5b01541415613e1f5760018c6005600781101515613cb057fe5b01819055508a6001600381101515613cc457fe5b60200201518b6000600381101515613cd857fe5b60200201511480613d0e57508a6002600381101515613cf357fe5b60200201518b6001600381101515613d0757fe5b6020020151145b15613e1a57600096508a6001600381101515613d2657fe5b60200201518b6000600381101515613d3a57fe5b60200201511415613d60578a6000600381101515613d5457fe5b60200201519650613da6565b8a6002600381101515613d6f57fe5b60200201518b6001600381101515613d8357fe5b60200201511415613da5578a6001600381101515613d9d57fe5b602002015196505b5b8b6002600781101515613db557fe5b0154871415613e195760028c6005600781101515613dcf57fe5b0181905550613def8c6001600781101515613de657fe5b015460006145f7565b9950898c6003600781101515613e0157fe5b0154028c6006600781101515613e1357fe5b01819055505b5b614490565b60048c6001600781101515613e3057fe5b01541415613f395760018c6005600781101515613e4957fe5b01819055508a6001600381101515613e5d57fe5b60200201518b6000600381101515613e7157fe5b6020020151148015613ea857508a6002600381101515613e8d57fe5b60200201518b6001600381101515613ea157fe5b6020020151145b15613f34578b6002600781101515613ebc57fe5b01548b6000600381101515613ecd57fe5b60200201511415613f335760028c6005600781101515613ee957fe5b0181905550613f098c6001600781101515613f0057fe5b015460006145f7565b9950898c6003600781101515613f1b57fe5b0154028c6006600781101515613f2d57fe5b01819055505b5b61448f565b60058c6001600781101515613f4a57fe5b015414156140275760018c6005600781101515613f6357fe5b01819055508a6001600381101515613f7757fe5b60200201518b6000600381101515613f8b57fe5b6020020151148015613fc257508a6002600381101515613fa757fe5b60200201518b6001600381101515613fbb57fe5b6020020151145b156140225760028c6005600781101515613fd857fe5b0181905550613ff88c6001600781101515613fef57fe5b015460006145f7565b9950898c600360078110151561400a57fe5b0154028c600660078110151561401c57fe5b01819055505b61448e565b60068c600160078110151561403857fe5b01541415614188578a600160038110151561404f57fe5b60200201518b600060038110151561406357fe5b602002015114801561409a57508a600260038110151561407f57fe5b60200201518b600160038110151561409357fe5b6020020151145b156140ba5760018c60056007811015156140b057fe5b0181905550614183565b60018c60056007811015156140cb57fe5b01819055508a60026003811015156140df57fe5b60200201518b60016003811015156140f357fe5b60200201518c600060038110151561410757fe5b6020020151010195508b600260078110151561411f57fe5b01548614156141825760028c600560078110151561413957fe5b01819055506141588c600160078110151561415057fe5b0154876145f7565b9950898c600360078110151561416a57fe5b0154028c600660078110151561417c57fe5b01819055505b5b61448d565b60078c600160078110151561419957fe5b0154141561434c578a60016003811015156141b057fe5b60200201518b60006003811015156141c457fe5b60200201511480156141fb57508a60026003811015156141e057fe5b60200201518b60016003811015156141f457fe5b6020020151145b1561421b5760018c600560078110151561421157fe5b0181905550614347565b6142348c600260078110151561422d57fe5b015461478c565b94506000935060009250600091505b60038210156142c65784600060028110151561425b57fe5b60200201518b8360038110151561426e57fe5b6020020151141561428257600193506142b9565b84600160028110151561429157fe5b60200201518b836003811015156142a457fe5b602002015114156142b857600192506142b9565b5b8180600101925050614243565b60018c60056007811015156142d757fe5b01819055508380156142e65750825b156143465760028c60056007811015156142fc57fe5b018190555061431c8c600160078110151561431357fe5b015460006145f7565b9950898c600360078110151561432e57fe5b0154028c600660078110151561434057fe5b01819055505b5b61448c565b60088c600160078110151561435d57fe5b0154141561448b576000905060018c600560078110151561437a57fe5b01819055508b600260078110151561438e57fe5b01548b600060038110151561439f57fe5b602002015114156143b35780806001019150505b8b60026007811015156143c257fe5b01548b60016003811015156143d357fe5b602002015114156143e75780806001019150505b8b60026007811015156143f657fe5b01548b600260038110151561440757fe5b6020020151141561441b5780806001019150505b600081111561448a5760028c600560078110151561443557fe5b01819055506144548c600160078110151561444c57fe5b0154826145f7565b9950600a8a8d600360078110151561446857fe5b01540281151561447457fe5b048c600660078110151561448457fe5b01819055505b5b5b5b5b5b5b5b5b505050505050505050505050565b606060008060606000808614156144ee576040805190810160405280600181526020017f300000000000000000000000000000000000000000000000000000000000000081525094506145ee565b8593505b600084141515614518578280600101935050600a8481151561451057fe5b0493506144f2565b826040519080825280601f01601f19166020018201604052801561454b5781602001602082028038833980820191505090505b5091506001830390505b6000861415156145ea57600a8681151561456b57fe5b066030017f0100000000000000000000000000000000000000000000000000000000000000028282806001900393508151811015156145a657fe5b9060200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a905350600a868115156145e257fe5b049550614555565b8194505b50505050919050565b60008060009050600184148061460d5750600284145b1561461b5760139050614782565b600384141561462d57600b9050614781565b600484141561463f57609c9050614780565b600584141561465157601a905061477f565b600684141561472c5760048314806146695750601183145b156146775760359050614727565b60058314806146865750601083145b156146945760159050614726565b60068314806146a35750600f83145b156146b15760119050614725565b60078314806146c05750600e83145b156146ce57600d9050614724565b60088314806146dd5750600d83145b156146eb5760099050614723565b60098314806146fa5750600c83145b156147085760089050614722565b600a8314806147175750600b83145b1561472157600790505b5b5b5b5b5b5b61477e565b600784141561473e576006905061477d565b600884141561477c576001831415614759576013905061477b565b600283141561476b57601c905061477a565b600383141561477957602590505b5b5b5b5b5b5b5b5b5b8091505092915050565b614794614b67565b61479c614b67565b600c8314156147c357604080519081016040528060018152602001600281525090506149ef565b600d8314156147ea57604080519081016040528060018152602001600381525090506149ee565b600e83141561481157604080519081016040528060018152602001600481525090506149ed565b600f83141561483857604080519081016040528060018152602001600581525090506149ec565b601083141561485f57604080519081016040528060018152602001600681525090506149eb565b601783141561488657604080519081016040528060028152602001600381525090506149ea565b60188314156148ad57604080519081016040528060028152602001600481525090506149e9565b60198314156148d457604080519081016040528060028152602001600581525090506149e8565b601a8314156148fb57604080519081016040528060028152602001600681525090506149e7565b602283141561492257604080519081016040528060038152602001600481525090506149e6565b602383141561494957604080519081016040528060038152602001600581525090506149e5565b602483141561497057604080519081016040528060038152602001600681525090506149e4565b602d83141561499757604080519081016040528060048152602001600581525090506149e3565b602e8314156149be57604080519081016040528060048152602001600681525090506149e2565b60388314156149e157604080519081016040528060058152602001600681525090505b5b5b5b5b5b5b5b5b5b5b5b5b5b5b80915050919050565b60e060405190810160405280600790602082028038833980820191505090505090565b606060405190810160405280600390602082028038833980820191505090505090565b8260078101928215614a6a579182015b82811115614a69578254825591600101919060010190614a4e565b5b509050614a779190614b89565b5090565b8260038101928215614aaa579160200282015b82811115614aa9578251825591602001919060010190614a8e565b5b509050614ab79190614b89565b5090565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f10614afc57805160ff1916838001178555614b2a565b82800160010185558215614b2a579182015b82811115614b29578251825591602001919060010190614b0e565b5b509050614b379190614b89565b5090565b815481835581811115614b6257818360005260206000209182019101614b619190614bae565b5b505050565b6040805190810160405280600290602082028038833980820191505090505090565b614bab91905b80821115614ba7576000816000905550600101614b8f565b5090565b90565b614bd091905b80821115614bcc576000816000905550600101614bb4565b5090565b905600a165627a7a72305820fa631151b026964b4808447e6edc344ea24db262ba1eb2135565ddd9371865b50029"
}