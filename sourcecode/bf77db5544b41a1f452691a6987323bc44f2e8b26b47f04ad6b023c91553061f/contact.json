{
  "address": "0xa7446cbb3644d14b3ebb1a27aa3a9c479b93a650",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "Eggfrenzy",
  "compilerVersion": "v0.4.20+commit.3155dd80",
  "optimization": false,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2018-04-14\n*/\n\npragma solidity ^0.4.2;\n\ncontract OraclizeI {\n    address public cbAddress;\n    function query(uint _timestamp, string _datasource, string _arg) external payable returns (bytes32 _id);\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) external payable returns (bytes32 _id);\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) public payable returns (bytes32 _id);\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) external payable returns (bytes32 _id);\n    function queryN(uint _timestamp, string _datasource, bytes _argN) public payable returns (bytes32 _id);\n    function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) external payable returns (bytes32 _id);\n    function getPrice(string _datasource) public returns (uint _dsprice);\n    function getPrice(string _datasource, uint gaslimit) public returns (uint _dsprice);\n    function setProofType(byte _proofType) external;\n    function setCustomGasPrice(uint _gasPrice) external;\n    function randomDS_getSessionPubKeyHash() external constant returns(bytes32);\n}\ncontract OraclizeAddrResolverI {\n    function getAddress() public returns (address _addr);\n}\ncontract usingOraclize {\n    uint constant day = 60*60*24;\n    uint constant week = 60*60*24*7;\n    uint constant month = 60*60*24*30;\n    byte constant proofType_NONE = 0x00;\n    byte constant proofType_TLSNotary = 0x10;\n    byte constant proofType_Android = 0x20;\n    byte constant proofType_Ledger = 0x30;\n    byte constant proofType_Native = 0xF0;\n    byte constant proofStorage_IPFS = 0x01;\n    uint8 constant networkID_auto = 0;\n    uint8 constant networkID_mainnet = 1;\n    uint8 constant networkID_testnet = 2;\n    uint8 constant networkID_morden = 2;\n    uint8 constant networkID_consensys = 161;\n\n    OraclizeAddrResolverI OAR;\n\n    OraclizeI oraclize;\n    modifier oraclizeAPI {\n        if((address(OAR)==0)||(getCodeSize(address(OAR))==0))\n            oraclize_setNetwork(networkID_auto);\n\n        if(address(oraclize) != OAR.getAddress())\n            oraclize = OraclizeI(OAR.getAddress());\n\n        _;\n    }\n    modifier coupon(string code){\n        oraclize = OraclizeI(OAR.getAddress());\n        _;\n    }\n\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n      return oraclize_setNetwork();\n      networkID; // silence the warning and remain backwards compatible\n    }\n    function oraclize_setNetwork() internal returns(bool){\n        if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){ //mainnet\n            OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\n            oraclize_setNetworkName(\"eth_mainnet\");\n            return true;\n        }\n        if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){ //ropsten testnet\n            OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\n            oraclize_setNetworkName(\"eth_ropsten3\");\n            return true;\n        }\n        if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){ //kovan testnet\n            OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\n            oraclize_setNetworkName(\"eth_kovan\");\n            return true;\n        }\n        if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){ //rinkeby testnet\n            OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\n            oraclize_setNetworkName(\"eth_rinkeby\");\n            return true;\n        }\n        if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){ //ethereum-bridge\n            OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\n            return true;\n        }\n        if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){ //ether.camp ide\n            OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\n            return true;\n        }\n        if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){ //browser-solidity\n            OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\n            return true;\n        }\n        return false;\n    }\n\n    function __callback(bytes32 myid, string result) public {\n        __callback(myid, result, new bytes(0));\n    }\n    function __callback(bytes32 myid, string result, bytes proof) public {\n      return;\n      myid; result; proof; // Silence compiler warnings\n    }\n\n    function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\n        return oraclize.getPrice(datasource);\n    }\n\n    function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\n        return oraclize.getPrice(datasource, gaslimit);\n    }\n\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(0, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(timestamp, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        bytes memory args = stra2cbor(argN);\n        return oraclize.queryN.value(price)(0, datasource, args);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        bytes memory args = stra2cbor(argN);\n        return oraclize.queryN.value(price)(timestamp, datasource, args);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        bytes memory args = stra2cbor(argN);\n        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n    }\n    function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        bytes memory args = stra2cbor(argN);\n        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n    }\n    function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](1);\n        dynargs[0] = args[0];\n        return oraclize_query(datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](1);\n        dynargs[0] = args[0];\n        return oraclize_query(timestamp, datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](1);\n        dynargs[0] = args[0];\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](1);\n        dynargs[0] = args[0];\n        return oraclize_query(datasource, dynargs, gaslimit);\n    }\n\n    function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](2);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        return oraclize_query(datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](2);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        return oraclize_query(timestamp, datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](2);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](2);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        return oraclize_query(datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](3);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        return oraclize_query(datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](3);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        return oraclize_query(timestamp, datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](3);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](3);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        return oraclize_query(datasource, dynargs, gaslimit);\n    }\n\n    function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](4);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        return oraclize_query(datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](4);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        return oraclize_query(timestamp, datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](4);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](4);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        return oraclize_query(datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](5);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        dynargs[4] = args[4];\n        return oraclize_query(datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](5);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        dynargs[4] = args[4];\n        return oraclize_query(timestamp, datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](5);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        dynargs[4] = args[4];\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](5);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        dynargs[4] = args[4];\n        return oraclize_query(datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        bytes memory args = ba2cbor(argN);\n        return oraclize.queryN.value(price)(0, datasource, args);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        bytes memory args = ba2cbor(argN);\n        return oraclize.queryN.value(price)(timestamp, datasource, args);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        bytes memory args = ba2cbor(argN);\n        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n    }\n    function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        bytes memory args = ba2cbor(argN);\n        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n    }\n    function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](1);\n        dynargs[0] = args[0];\n        return oraclize_query(datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](1);\n        dynargs[0] = args[0];\n        return oraclize_query(timestamp, datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](1);\n        dynargs[0] = args[0];\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](1);\n        dynargs[0] = args[0];\n        return oraclize_query(datasource, dynargs, gaslimit);\n    }\n\n    function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](2);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        return oraclize_query(datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](2);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        return oraclize_query(timestamp, datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](2);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](2);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        return oraclize_query(datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](3);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        return oraclize_query(datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](3);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        return oraclize_query(timestamp, datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](3);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](3);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        return oraclize_query(datasource, dynargs, gaslimit);\n    }\n\n    function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](4);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        return oraclize_query(datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](4);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        return oraclize_query(timestamp, datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](4);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](4);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        return oraclize_query(datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](5);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        dynargs[4] = args[4];\n        return oraclize_query(datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](5);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        dynargs[4] = args[4];\n        return oraclize_query(timestamp, datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](5);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        dynargs[4] = args[4];\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](5);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        dynargs[4] = args[4];\n        return oraclize_query(datasource, dynargs, gaslimit);\n    }\n\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\n        return oraclize.cbAddress();\n    }\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\n        return oraclize.setProofType(proofP);\n    }\n    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\n        return oraclize.setCustomGasPrice(gasPrice);\n    }\n\n    function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){\n        return oraclize.randomDS_getSessionPubKeyHash();\n    }\n\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\n        assembly {\n            _size := extcodesize(_addr)\n        }\n    }\n\n    function parseAddr(string _a) internal pure returns (address){\n        bytes memory tmp = bytes(_a);\n        uint160 iaddr = 0;\n        uint160 b1;\n        uint160 b2;\n        for (uint i=2; i<2+2*20; i+=2){\n            iaddr *= 256;\n            b1 = uint160(tmp[i]);\n            b2 = uint160(tmp[i+1]);\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n            else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n            else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n            iaddr += (b1*16+b2);\n        }\n        return address(iaddr);\n    }\n\n    function strCompare(string _a, string _b) internal pure returns (int) {\n        bytes memory a = bytes(_a);\n        bytes memory b = bytes(_b);\n        uint minLength = a.length;\n        if (b.length < minLength) minLength = b.length;\n        for (uint i = 0; i < minLength; i ++)\n            if (a[i] < b[i])\n                return -1;\n            else if (a[i] > b[i])\n                return 1;\n        if (a.length < b.length)\n            return -1;\n        else if (a.length > b.length)\n            return 1;\n        else\n            return 0;\n    }\n\n    function indexOf(string _haystack, string _needle) internal pure returns (int) {\n        bytes memory h = bytes(_haystack);\n        bytes memory n = bytes(_needle);\n        if(h.length < 1 || n.length < 1 || (n.length > h.length))\n            return -1;\n        else if(h.length > (2**128 -1))\n            return -1;\n        else\n        {\n            uint subindex = 0;\n            for (uint i = 0; i < h.length; i ++)\n            {\n                if (h[i] == n[0])\n                {\n                    subindex = 1;\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n                    {\n                        subindex++;\n                    }\n                    if(subindex == n.length)\n                        return int(i);\n                }\n            }\n            return -1;\n        }\n    }\n\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n        bytes memory _ba = bytes(_a);\n        bytes memory _bb = bytes(_b);\n        bytes memory _bc = bytes(_c);\n        bytes memory _bd = bytes(_d);\n        bytes memory _be = bytes(_e);\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n        bytes memory babcde = bytes(abcde);\n        uint k = 0;\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n        return string(babcde);\n    }\n\n    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n        return strConcat(_a, _b, _c, _d, \"\");\n    }\n\n    function strConcat(string _a, string _b, string _c) internal pure returns (string) {\n        return strConcat(_a, _b, _c, \"\", \"\");\n    }\n\n    function strConcat(string _a, string _b) internal pure returns (string) {\n        return strConcat(_a, _b, \"\", \"\", \"\");\n    }\n\n    // parseInt\n    function parseInt(string _a) internal pure returns (uint) {\n        return parseInt(_a, 0);\n    }\n\n    // parseInt(parseFloat*10^_b)\n    function parseInt(string _a, uint _b) internal pure returns (uint) {\n        bytes memory bresult = bytes(_a);\n        uint mint = 0;\n        bool decimals = false;\n        for (uint i=0; i<bresult.length; i++){\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n                if (decimals){\n                   if (_b == 0) break;\n                    else _b--;\n                }\n                mint *= 10;\n                mint += uint(bresult[i]) - 48;\n            } else if (bresult[i] == 46) decimals = true;\n        }\n        if (_b > 0) mint *= 10**_b;\n        return mint;\n    }\n\n    function uint2str(uint i) internal pure returns (string){\n        if (i == 0) return \"0\";\n        uint j = i;\n        uint len;\n        while (j != 0){\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint k = len - 1;\n        while (i != 0){\n            bstr[k--] = byte(48 + i % 10);\n            i /= 10;\n        }\n        return string(bstr);\n    }\n\n    function stra2cbor(string[] arr) internal pure returns (bytes) {\n            uint arrlen = arr.length;\n\n            // get correct cbor output length\n            uint outputlen = 0;\n            bytes[] memory elemArray = new bytes[](arrlen);\n            for (uint i = 0; i < arrlen; i++) {\n                elemArray[i] = (bytes(arr[i]));\n                outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3; //+3 accounts for paired identifier types\n            }\n            uint ctr = 0;\n            uint cborlen = arrlen + 0x80;\n            outputlen += byte(cborlen).length;\n            bytes memory res = new bytes(outputlen);\n\n            while (byte(cborlen).length > ctr) {\n                res[ctr] = byte(cborlen)[ctr];\n                ctr++;\n            }\n            for (i = 0; i < arrlen; i++) {\n                res[ctr] = 0x5F;\n                ctr++;\n                for (uint x = 0; x < elemArray[i].length; x++) {\n                    // if there's a bug with larger strings, this may be the culprit\n                    if (x % 23 == 0) {\n                        uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\n                        elemcborlen += 0x40;\n                        uint lctr = ctr;\n                        while (byte(elemcborlen).length > ctr - lctr) {\n                            res[ctr] = byte(elemcborlen)[ctr - lctr];\n                            ctr++;\n                        }\n                    }\n                    res[ctr] = elemArray[i][x];\n                    ctr++;\n                }\n                res[ctr] = 0xFF;\n                ctr++;\n            }\n            return res;\n        }\n\n    function ba2cbor(bytes[] arr) internal pure returns (bytes) {\n            uint arrlen = arr.length;\n\n            // get correct cbor output length\n            uint outputlen = 0;\n            bytes[] memory elemArray = new bytes[](arrlen);\n            for (uint i = 0; i < arrlen; i++) {\n                elemArray[i] = (bytes(arr[i]));\n                outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3; //+3 accounts for paired identifier types\n            }\n            uint ctr = 0;\n            uint cborlen = arrlen + 0x80;\n            outputlen += byte(cborlen).length;\n            bytes memory res = new bytes(outputlen);\n\n            while (byte(cborlen).length > ctr) {\n                res[ctr] = byte(cborlen)[ctr];\n                ctr++;\n            }\n            for (i = 0; i < arrlen; i++) {\n                res[ctr] = 0x5F;\n                ctr++;\n                for (uint x = 0; x < elemArray[i].length; x++) {\n                    // if there's a bug with larger strings, this may be the culprit\n                    if (x % 23 == 0) {\n                        uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\n                        elemcborlen += 0x40;\n                        uint lctr = ctr;\n                        while (byte(elemcborlen).length > ctr - lctr) {\n                            res[ctr] = byte(elemcborlen)[ctr - lctr];\n                            ctr++;\n                        }\n                    }\n                    res[ctr] = elemArray[i][x];\n                    ctr++;\n                }\n                res[ctr] = 0xFF;\n                ctr++;\n            }\n            return res;\n        }\n\n\n    string oraclize_network_name;\n    function oraclize_setNetworkName(string _network_name) internal {\n        oraclize_network_name = _network_name;\n    }\n\n    function oraclize_getNetworkName() internal view returns (string) {\n        return oraclize_network_name;\n    }\n\n    function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\n        require((_nbytes > 0) && (_nbytes <= 32));\n        // Convert from seconds to ledger timer ticks\n        _delay *= 10;\n        bytes memory nbytes = new bytes(1);\n        nbytes[0] = byte(_nbytes);\n        bytes memory unonce = new bytes(32);\n        bytes memory sessionKeyHash = new bytes(32);\n        bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();\n        assembly {\n            mstore(unonce, 0x20)\n            mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\n            mstore(sessionKeyHash, 0x20)\n            mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\n        }\n        bytes memory delay = new bytes(32);\n        assembly {\n            mstore(add(delay, 0x20), _delay)\n        }\n\n        bytes memory delay_bytes8 = new bytes(8);\n        copyBytes(delay, 24, 8, delay_bytes8, 0);\n\n        bytes[4] memory args = [unonce, nbytes, sessionKeyHash, delay];\n        bytes32 queryId = oraclize_query(\"random\", args, _customGasLimit);\n\n        bytes memory delay_bytes8_left = new bytes(8);\n\n        assembly {\n            let x := mload(add(delay_bytes8, 0x20))\n            mstore8(add(delay_bytes8_left, 0x27), div(x, 0x100000000000000000000000000000000000000000000000000000000000000))\n            mstore8(add(delay_bytes8_left, 0x26), div(x, 0x1000000000000000000000000000000000000000000000000000000000000))\n            mstore8(add(delay_bytes8_left, 0x25), div(x, 0x10000000000000000000000000000000000000000000000000000000000))\n            mstore8(add(delay_bytes8_left, 0x24), div(x, 0x100000000000000000000000000000000000000000000000000000000))\n            mstore8(add(delay_bytes8_left, 0x23), div(x, 0x1000000000000000000000000000000000000000000000000000000))\n            mstore8(add(delay_bytes8_left, 0x22), div(x, 0x10000000000000000000000000000000000000000000000000000))\n            mstore8(add(delay_bytes8_left, 0x21), div(x, 0x100000000000000000000000000000000000000000000000000))\n            mstore8(add(delay_bytes8_left, 0x20), div(x, 0x1000000000000000000000000000000000000000000000000))\n\n        }\n\n        oraclize_randomDS_setCommitment(queryId, keccak256(delay_bytes8_left, args[1], sha256(args[0]), args[2]));\n        return queryId;\n    }\n\n    function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {\n        oraclize_randomDS_args[queryId] = commitment;\n    }\n\n    mapping(bytes32=>bytes32) oraclize_randomDS_args;\n    mapping(bytes32=>bool) oraclize_randomDS_sessionKeysHashVerified;\n\n    function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){\n        bool sigok;\n        address signer;\n\n        bytes32 sigr;\n        bytes32 sigs;\n\n        bytes memory sigr_ = new bytes(32);\n        uint offset = 4+(uint(dersig[3]) - 0x20);\n        sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);\n        bytes memory sigs_ = new bytes(32);\n        offset += 32 + 2;\n        sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);\n\n        assembly {\n            sigr := mload(add(sigr_, 32))\n            sigs := mload(add(sigs_, 32))\n        }\n\n\n        (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);\n        if (address(keccak256(pubkey)) == signer) return true;\n        else {\n            (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);\n            return (address(keccak256(pubkey)) == signer);\n        }\n    }\n\n    function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {\n        bool sigok;\n\n        // Step 6: verify the attestation signature, APPKEY1 must sign the sessionKey from the correct ledger app (CODEHASH)\n        bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);\n        copyBytes(proof, sig2offset, sig2.length, sig2, 0);\n\n        bytes memory appkey1_pubkey = new bytes(64);\n        copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);\n\n        bytes memory tosign2 = new bytes(1+65+32);\n        tosign2[0] = byte(1); //role\n        copyBytes(proof, sig2offset-65, 65, tosign2, 1);\n        bytes memory CODEHASH = hex\"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c\";\n        copyBytes(CODEHASH, 0, 32, tosign2, 1+65);\n        sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);\n\n        if (sigok == false) return false;\n\n\n        // Step 7: verify the APPKEY1 provenance (must be signed by Ledger)\n        bytes memory LEDGERKEY = hex\"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4\";\n\n        bytes memory tosign3 = new bytes(1+65);\n        tosign3[0] = 0xFE;\n        copyBytes(proof, 3, 65, tosign3, 1);\n\n        bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);\n        copyBytes(proof, 3+65, sig3.length, sig3, 0);\n\n        sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);\n\n        return sigok;\n    }\n\n    modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {\n        // Step 1: the prefix has to match 'LP\\x01' (Ledger Proof version 1)\n        require((_proof[0] == \"L\") && (_proof[1] == \"P\") && (_proof[2] == 1));\n\n        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n        require(proofVerified);\n\n        _;\n    }\n\n    function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){\n        // Step 1: the prefix has to match 'LP\\x01' (Ledger Proof version 1)\n        if ((_proof[0] != \"L\")||(_proof[1] != \"P\")||(_proof[2] != 1)) return 1;\n\n        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n        if (proofVerified == false) return 2;\n\n        return 0;\n    }\n\n    function matchBytes32Prefix(bytes32 content, bytes prefix, uint n_random_bytes) internal pure returns (bool){\n        bool match_ = true;\n\n        require(prefix.length == n_random_bytes);\n\n        for (uint256 i=0; i< n_random_bytes; i++) {\n            if (content[i] != prefix[i]) match_ = false;\n        }\n\n        return match_;\n    }\n\n    function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\n\n        // Step 2: the unique keyhash has to match with the sha256 of (context name + queryId)\n        uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32;\n        bytes memory keyhash = new bytes(32);\n        copyBytes(proof, ledgerProofLength, 32, keyhash, 0);\n        if (!(keccak256(keyhash) == keccak256(sha256(context_name, queryId)))) return false;\n\n        bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2);\n        copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0);\n\n        // Step 3: we assume sig1 is valid (it will be verified during step 5) and we verify if 'result' is the prefix of sha256(sig1)\n        if (!matchBytes32Prefix(sha256(sig1), result, uint(proof[ledgerProofLength+32+8]))) return false;\n\n        // Step 4: commitment match verification, keccak256(delay, nbytes, unonce, sessionKeyHash) == commitment in storage.\n        // This is to verify that the computed args match with the ones specified in the query.\n        bytes memory commitmentSlice1 = new bytes(8+1+32);\n        copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0);\n\n        bytes memory sessionPubkey = new bytes(64);\n        uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65;\n        copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0);\n\n        bytes32 sessionPubkeyHash = sha256(sessionPubkey);\n        if (oraclize_randomDS_args[queryId] == keccak256(commitmentSlice1, sessionPubkeyHash)){ //unonce, nbytes and sessionKeyHash match\n            delete oraclize_randomDS_args[queryId];\n        } else return false;\n\n\n        // Step 5: validity verification for sig1 (keyhash and args signed with the sessionKey)\n        bytes memory tosign1 = new bytes(32+8+1+32);\n        copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0);\n        if (!verifySig(sha256(tosign1), sig1, sessionPubkey)) return false;\n\n        // verify if sessionPubkeyHash was verified already, if not.. let's do it!\n        if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){\n            oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);\n        }\n\n        return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];\n    }\n\n    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\n    function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal pure returns (bytes) {\n        uint minLength = length + toOffset;\n\n        // Buffer too small\n        require(to.length >= minLength); // Should be a better way?\n\n        // NOTE: the offset 32 is added to skip the `size` field of both bytes variables\n        uint i = 32 + fromOffset;\n        uint j = 32 + toOffset;\n\n        while (i < (32 + fromOffset + length)) {\n            assembly {\n                let tmp := mload(add(from, i))\n                mstore(add(to, j), tmp)\n            }\n            i += 32;\n            j += 32;\n        }\n\n        return to;\n    }\n\n    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\n    // Duplicate Solidity's ecrecover, but catching the CALL return value\n    function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\n        // We do our own memory management here. Solidity uses memory offset\n        // 0x40 to store the current end of memory. We write past it (as\n        // writes are memory extensions), but don't update the offset so\n        // Solidity will reuse it. The memory used here is only needed for\n        // this context.\n\n        // FIXME: inline assembly can't access return values\n        bool ret;\n        address addr;\n\n        assembly {\n            let size := mload(0x40)\n            mstore(size, hash)\n            mstore(add(size, 32), v)\n            mstore(add(size, 64), r)\n            mstore(add(size, 96), s)\n\n            // NOTE: we can reuse the request memory because we deal with\n            //       the return code\n            ret := call(3000, 1, 0, size, 128, size, 32)\n            addr := mload(size)\n        }\n\n        return (ret, addr);\n    }\n\n    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\n    function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        if (sig.length != 65)\n          return (false, 0);\n\n        // The signature format is a compact form of:\n        //   {bytes32 r}{bytes32 s}{uint8 v}\n        // Compact means, uint8 is not padded to 32 bytes.\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n\n            // Here we are loading the last 32 bytes. We exploit the fact that\n            // 'mload' will pad with zeroes if we overread.\n            // There is no 'mload8' to do this, but that would be nicer.\n            v := byte(0, mload(add(sig, 96)))\n\n            // Alternative solution:\n            // 'byte' is not working due to the Solidity parser, so lets\n            // use the second best option, 'and'\n            // v := and(mload(add(sig, 65)), 255)\n        }\n\n        // albeit non-transactional signatures are not specified by the YP, one would expect it\n        // to match the YP range of [27, 28]\n        //\n        // geth uses [0, 1] and some clients have followed. This might change, see:\n        //  https://github.com/ethereum/go-ethereum/issues/2053\n        if (v < 27)\n          v += 27;\n\n        if (v != 27 && v != 28)\n            return (false, 0);\n\n        return safer_ecrecover(hash, v, r, s);\n    }\n\n}\n\ncontract Eggfrenzy is usingOraclize {\n\n  mapping(address =>bytes32[]) recordindexlist;//玩家下注索引记录\n  mapping (bytes32 => address) playerAddress;\n  mapping(bytes32 =>uint) playerBetAmount;//下注额\n  mapping(bytes32 =>uint) playerWinmount;//赢的金额\n  mapping(bytes32 =>uint) playerWinorlose;//输赢1pending,2win,3lose,0no record\n  mapping(bytes32 =>uint) playerBetId;//选择第几个蛋\n  mapping(bytes32 =>uint) playerBetTotalNumber;//选择总蛋数\n  mapping(bytes32 =>uint) playerWineggno;//中奖的蛋序号\n  mapping(bytes32 =>uint) playerbettime;//下注时间\n\n  mapping(address => bytes32) betOracleid;//玩家最新一次的id\n  uint randomarr;\n  address public owner;\n  uint public profit2eggs;//二个蛋倍数\n  uint public profit3eggs;//三个蛋倍数\n  uint public profit5eggs;//五个蛋倍数\n\n  uint public maxprice;//最多金额\n  uint public minprice;//最小金额\n\n  uint public maxmoneypercent;\n  uint public fee;\n  uint public oraclizeFee;\n  uint public oraclizeGasLimit;\n\n  uint public maxProfit;//最高奖池\n  uint public totalWon;\n  uint public totalLose;\n  uint public totalWeiWon;\n  uint public contractBalance;\n  uint public onoff;\n  function Eggfrenzy() public {\n      owner = msg.sender;\n      profit2eggs=2;//二个蛋倍数\n      profit3eggs=3;//三个蛋倍数\n      profit5eggs=5;//五个蛋倍数\n      maxprice=5000000000000000;//最多金额\n      minprice=1500000000000000;//要最小金额比手续费大\n      oraclizeFee=1200000000000000;\n      maxmoneypercent=80;\n      fee=98;\n      oraclizeGasLimit=200000;\n      onoff=1;\n      contractBalance=this.balance;\n      maxProfit=(contractBalance * maxmoneypercent)/100;\n      /* maxmoney=(this.balance*maxmoneypercent)/100; */\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == owner);\n        _;\n    }\n    modifier onlyOraclize {\n        require (msg.sender == oraclize_cbAddress());\n        _;\n    }\n  //初始蛋的个数，价格\n  function openegg(uint betid,uint nums) public payable returns (bytes32) {\n    uint betValue = msg.value;\n    require(onoff==1);\n    require(nums==2||nums==3 || nums==5);\n    require(betValue >=minprice && betValue <=maxprice);\n    uint winnums=profit2eggs;\n    if(nums==3){\n      winnums=profit3eggs;\n    }else if(nums==5){\n      winnums=profit5eggs;\n    }\n    require(maxProfit > (betValue*winnums));\n    bytes32 queryId = oraclize_query(\"WolframAlpha\", \"random number between 0 and 100\",oraclizeGasLimit);\n    uint index=recordindexlist[msg.sender].length++;\n\n    recordindexlist[msg.sender][index]=queryId;//index:id\n    playerAddress[queryId]=msg.sender;//id:address\n    playerBetAmount[queryId]=betValue;//id:betvalue\n    playerBetId[queryId]=betid;//id:betid\n    playerBetTotalNumber[queryId]=nums;//id:bettotalno\n    playerWinmount[queryId]=0;//id:winvalue\n    playerWinorlose[queryId]=1;//id:winorlose,1pending,2win,3lose\n    playerWineggno[queryId]=999;//id:winno,default 999\n    playerbettime[queryId]=now;//id:time\n\n    betOracleid[msg.sender]=queryId;//address:id(latest id)\n\n    return queryId;\n  }\n\n  function getbetresult(bytes32 _queryId) public view returns(\n    uint _bettype,\n    uint _selectnum,\n    uint _winvalue,\n    uint _winno,\n    uint _eggnums,\n    uint _time){\n    _bettype=playerWinorlose[_queryId];\n    _selectnum=playerBetId[_queryId];\n    _winvalue=playerWinmount[_queryId];\n    _winno=playerWineggno[_queryId];\n    _eggnums=playerBetTotalNumber[_queryId];\n    _time=playerbettime[_queryId];\n  }\n  //获取当前最新的记录\n  function getbetresultfirst(address caccount) public view returns(\n    uint _bettype,\n    uint _winnum,\n    uint _selectnums,\n    uint _winvalue,\n    bytes32 _queryId,\n    uint _eggnums){\n    _queryId=betOracleid[caccount];\n    _bettype=playerWinorlose[_queryId];\n    _winnum=playerWineggno[_queryId];\n    _selectnums=playerBetId[_queryId];\n    _winvalue=playerWinmount[_queryId];\n    _eggnums=playerBetTotalNumber[_queryId];\n  }\n\n  function getallresutl() public view returns(uint[100],uint[100],uint[100],uint[100],uint[100]){\n    uint len=recordindexlist[msg.sender].length;\n    require(len>0);\n    uint[100] memory  twinorlost;\n    uint[100] memory tbetamount;\n    uint[100] memory twinamount;\n    uint[100] memory tbetid;\n    uint[100] memory tbeteggs;\n    uint[100] memory twineggno;\n    // uint[100] memory ttime;\n    uint j=0;\n    for(uint i=0;i<len;i++){\n      if(j<100){\n        bytes32 _queryId=recordindexlist[msg.sender][len-i-1];\n        twinorlost[i]=playerWinorlose[_queryId];\n        tbetamount[i]=playerBetAmount[_queryId];\n        twinamount[i]=playerWinmount[_queryId];\n        tbetid[i]=playerBetId[_queryId];\n        tbeteggs[i]=playerBetTotalNumber[_queryId];\n        twineggno[i]=playerWineggno[_queryId];\n        // ttime[i]=playerbettime[_queryId];\n      }\n      j++;\n    }\n      return (twinorlost,tbetamount,twinamount,tbetid,twineggno);\n  }\n  function senttest()public payable onlyAdmin{\n      contractBalance=this.balance;\n      maxProfit=(this.balance*maxmoneypercent)/100;\n  }\n  function updatebalance() public payable{\n    contractBalance=this.balance;\n    maxProfit=(this.balance*maxmoneypercent)/100;\n  }\n  function withdraw(uint _amount , address desaccount) public onlyAdmin{\n        desaccount.transfer(_amount);\n        contractBalance=this.balance;\n        maxProfit=(contractBalance*maxmoneypercent)/100;\n    }\n\n  function __callback(bytes32 queryId, string result) public onlyOraclize {\n      uint  weiWon;\n      uint divnum;\n      uint profitmul;\n      uint eggnuns=0;\n      if(playerBetTotalNumber[queryId]==2){\n        divnum=50;\n        profitmul=profit2eggs;\n      }else if(playerBetTotalNumber[queryId]==3){\n        divnum=33;\n        eggnuns=2;\n        profitmul=profit3eggs;\n      }else{\n        divnum=20;\n        eggnuns=5;\n        profitmul=profit5eggs;\n      }\n      randomarr=parseInt(result);\n      if(playerWinorlose[queryId]==1){\n          if( (parseInt(result)/divnum) == playerBetId[queryId]-eggnuns){\n              totalWon++;\n              weiWon=( playerBetAmount[queryId] * fee/100 )*profitmul - oraclizeFee;\n              totalWeiWon+=weiWon;\n              playerWinorlose[queryId]=2;\n              playerWinmount[queryId]=weiWon;\n              playerWineggno[queryId]=parseInt(result)/divnum+eggnuns;\n              playerAddress[queryId].transfer(weiWon);\n          }else{\n              playerWinorlose[queryId]=3;//1pending,2win,3lose\n              playerWineggno[queryId]=parseInt(result)/divnum+eggnuns;\n              totalLose++;\n          }\n      }\n\n\n      contractBalance=this.balance;\n      maxProfit=(this.balance * maxmoneypercent)/100;\n  }\n\n  function setGameOnoff(uint _on0ff) public onlyAdmin{\n    onoff=_on0ff;\n  }\n\n  function setGameVars(uint _profit2eggs,uint _profit3eggs,uint _profit5eggs,uint _fee,uint _oraclizeFee)public onlyAdmin{\n      profit2eggs=_profit2eggs;//二个蛋倍数\n      profit3eggs=_profit3eggs;//三个蛋倍数\n      profit5eggs=_profit5eggs;//五个蛋倍数\n      fee=_fee;\n      oraclizeFee=(_oraclizeFee * 1 wei);\n      maxProfit=(this.balance*maxmoneypercent)/100;\n      contractBalance=this.balance;\n  }\n\n  function setmaxprice(uint _maxprice) public onlyAdmin(){\n    maxprice=(_maxprice * 1 wei);//最多金额\n  }\n  function setminprice(uint _minprice) public onlyAdmin(){\n    minprice=(_minprice * 1 wei);//最小金额\n  }\n  function setoraclegasprice(uint newGas) public onlyAdmin(){\n    oraclize_setCustomGasPrice(newGas * 1 wei);\n  }\n  function setoraclelimitgas(uint _oraclizeGasLimit) public onlyAdmin(){\n    oraclizeGasLimit=(_oraclizeGasLimit* 1 wei);\n  }\n\n  function getrandoms()public view returns (uint){\n    return randomarr;\n  }\n  function getDatas() public view returns(\n      uint _maxProfit,\n      uint _minprice,\n      uint _maxprice,\n      uint _profit2eggs,\n      uint _profit3eggs,\n      uint _profit5eggs,\n      uint _totalWon,\n      uint _totalWeiWon,\n      uint _contractbalance,\n      uint _onoff,\n      uint _fee,\n      uint _oraclizeFee\n      ){\n          _maxProfit=maxProfit;\n          _minprice=minprice;\n          _maxprice=maxprice;\n          _profit2eggs=profit2eggs;\n          _profit3eggs=profit3eggs;\n          _profit5eggs=profit5eggs;\n          _totalWon=totalWon;\n          _contractbalance=contractBalance;\n          _totalWeiWon=totalWeiWon;\n          _onoff=onoff;\n          _fee=fee;\n          _oraclizeFee=oraclizeFee;\n\n\n      }\n}",
  "bytecode": "6060604052341561000f57600080fd5b33601060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506002601181905550600360128190555060056013819055506611c37937e080006014819055506605543df729c00060158190555066044364c5bb00006018819055506050601681905550606260178190555062030d406019819055506001601f819055503073ffffffffffffffffffffffffffffffffffffffff1631601e819055506064601654601e54028115156100e457fe5b04601a81905550612e98806100fa6000396000f3006060604052600436106101a0576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168062f714ce146101a557806315c12d4d146101e757806327dc297e1461021057806328b2e7811461027a578063300e4b3c146102a357806338bbfa50146102c65780633b5e295c146103735780633bdf157a1461039c5780634414a5c8146103bf5780634c6226fc146103e857806350b9c428146104115780636585c27c1461043a578063676095b2146104635780636850fa6d1461048c5780636d34a775146104b5578063749ca1f31461052b5780637aaf87d21461054e5780638a1279311461065b5780638b7afe2e146106845780638da5cb5b146106ad5780639c9b117014610702578063a232155d14610725578063ac1519591461079d578063b3ff277d146107c0578063b539cd55146107e9578063d095d49914610812578063d49d18361461083b578063d4c6d9ad14610878578063ddca3f43146108d6578063f8aa0a59146108ff578063fae8529a14610909578063fca2d9f514610932578063ff01ff081461093c575b600080fd5b34156101b057600080fd5b6101e5600480803590602001909190803573ffffffffffffffffffffffffffffffffffffffff16906020019091905050610983565b005b34156101f257600080fd5b6101fa610a5a565b6040518082815260200191505060405180910390f35b341561021b57600080fd5b61027860048080356000191690602001909190803590602001908201803590602001908080601f01602080910402602001604051908101604052809392919081815260200183838082843782019150505050505091905050610a60565b005b341561028557600080fd5b61028d610d97565b6040518082815260200191505060405180910390f35b34156102ae57600080fd5b6102c46004808035906020019091905050610d9d565b005b34156102d157600080fd5b61037160048080356000191690602001909190803590602001908201803590602001908080601f0160208091040260200160405190810160405280939291908181526020018383808284378201915050505050509190803590602001908201803590602001908080601f01602080910402602001604051908101604052809392919081815260200183838082843782019150505050505091905050610e06565b005b341561037e57600080fd5b610386610e0b565b6040518082815260200191505060405180910390f35b34156103a757600080fd5b6103bd6004808035906020019091905050610e11565b005b34156103ca57600080fd5b6103d2610e7c565b6040518082815260200191505060405180910390f35b34156103f357600080fd5b6103fb610e82565b6040518082815260200191505060405180910390f35b341561041c57600080fd5b610424610e88565b6040518082815260200191505060405180910390f35b341561044557600080fd5b61044d610e8e565b6040518082815260200191505060405180910390f35b341561046e57600080fd5b610476610e98565b6040518082815260200191505060405180910390f35b341561049757600080fd5b61049f610e9e565b6040518082815260200191505060405180910390f35b34156104c057600080fd5b6104c8610ea4565b604051808d81526020018c81526020018b81526020018a81526020018981526020018881526020018781526020018681526020018581526020018481526020018381526020018281526020019c5050505050505050505050505060405180910390f35b341561053657600080fd5b61054c6004808035906020019091905050610f00565b005b341561055957600080fd5b610561610f66565b6040518086606460200280838360005b8381101561058c578082015181840152602081019050610571565b5050505090500185606460200280838360005b838110156105ba57808201518184015260208101905061059f565b5050505090500184606460200280838360005b838110156105e85780820151818401526020810190506105cd565b5050505090500183606460200280838360005b838110156106165780820151818401526020810190506105fb565b5050505090500182606460200280838360005b83811015610644578082015181840152602081019050610629565b505050509050019550505050505060405180910390f35b341561066657600080fd5b61066e6111fa565b6040518082815260200191505060405180910390f35b341561068f57600080fd5b610697611200565b6040518082815260200191505060405180910390f35b34156106b857600080fd5b6106c0611206565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b341561070d57600080fd5b610723600480803590602001909190505061122c565b005b341561073057600080fd5b61075c600480803573ffffffffffffffffffffffffffffffffffffffff16906020019091905050611295565b604051808781526020018681526020018581526020018481526020018360001916600019168152602001828152602001965050505050505060405180910390f35b34156107a857600080fd5b6107be600480803590602001909190505061137f565b005b34156107cb57600080fd5b6107d36113e8565b6040518082815260200191505060405180910390f35b34156107f457600080fd5b6107fc6113ee565b6040518082815260200191505060405180910390f35b341561081d57600080fd5b6108256113f4565b6040518082815260200191505060405180910390f35b61085a60048080359060200190919080359060200190919050506113fa565b60405180826000191660001916815260200191505060405180910390f35b341561088357600080fd5b61089d600480803560001916906020019091905050611753565b60405180878152602001868152602001858152602001848152602001838152602001828152602001965050505050505060405180910390f35b34156108e157600080fd5b6108e9611819565b6040518082815260200191505060405180910390f35b61090761181f565b005b341561091457600080fd5b61091c61186d565b6040518082815260200191505060405180910390f35b61093a611873565b005b341561094757600080fd5b610981600480803590602001909190803590602001909190803590602001909190803590602001909190803590602001909190505061191d565b005b601060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415156109df57600080fd5b8073ffffffffffffffffffffffffffffffffffffffff166108fc839081150290604051600060405180830381858888f193505050501515610a1f57600080fd5b3073ffffffffffffffffffffffffffffffffffffffff1631601e819055506064601654601e5402811515610a4f57fe5b04601a819055505050565b601d5481565b600080600080610a6e6119f2565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16141515610aa757600080fd5b600090506002600b60008860001916600019168152602001908152602001600020541415610add57603292506011549150610b22565b6003600b60008860001916600019168152602001908152602001600020541415610b135760219250600290506012549150610b21565b601492506005905060135491505b5b610b2b85611d08565b600f819055506001600960008860001916600019168152602001908152602001600020541415610d435780600a60008860001916600019168152602001908152602001600020540383610b7d87611d08565b811515610b8657fe5b041415610cd957601b60008154809291906001019190505550601854826064601754600760008b600019166000191681526020019081526020016000205402811515610bce57fe5b040203935083601d6000828254019250508190555060026009600088600019166000191681526020019081526020016000208190555083600860008860001916600019168152602001908152602001600020819055508083610c2f87611d08565b811515610c3857fe5b0401600c600088600019166000191681526020019081526020016000208190555060066000876000191660001916815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166108fc859081150290604051600060405180830381858888f193505050501515610cd457600080fd5b610d42565b6003600960008860001916600019168152602001908152602001600020819055508083610d0587611d08565b811515610d0e57fe5b0401600c6000886000191660001916815260200190815260200160002081905550601c600081548092919060010191905055505b5b3073ffffffffffffffffffffffffffffffffffffffff1631601e8190555060646016543073ffffffffffffffffffffffffffffffffffffffff163102811515610d8857fe5b04601a81905550505050505050565b60155481565b601060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16141515610df957600080fd5b6001810260158190555050565b505050565b60165481565b601060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16141515610e6d57600080fd5b610e7960018202611d1c565b50565b601c5481565b60185481565b60195481565b6000600f54905090565b60115481565b601f5481565b600080600080600080600080600080600080601a549b506015549a506014549950601154985060125497506013549650601b549550601e549350601d549450601f54925060175491506018549050909192939495969798999a9b565b601060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16141515610f5c57600080fd5b80601f8190555050565b610f6e612d39565b610f76612d39565b610f7e612d39565b610f86612d39565b610f8e612d39565b6000610f98612d39565b610fa0612d39565b610fa8612d39565b610fb0612d39565b610fb8612d39565b610fc0612d39565b6000806000600560003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002080549050995060008a11151561101957600080fd5b60009250600091505b898210156111da5760648310156111c557600560003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206001838c030381548110151561108457fe5b90600052602060002090015490506009600082600019166000191681526020019081526020016000205489836064811015156110bc57fe5b6020020181815250506007600082600019166000191681526020019081526020016000205488836064811015156110ef57fe5b60200201818152505060086000826000191660001916815260200190815260200160002054878360648110151561112257fe5b602002018181525050600a6000826000191660001916815260200190815260200160002054868360648110151561115557fe5b602002018181525050600b6000826000191660001916815260200190815260200160002054858360648110151561118857fe5b602002018181525050600c600082600019166000191681526020019081526020016000205484836064811015156111bb57fe5b6020020181815250505b82806001019350508180600101925050611022565b88888888879e509e509e509e509e50505050505050505050509091929394565b60135481565b601e5481565b601060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b601060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614151561128857600080fd5b6001810260198190555050565b600080600080600080600e60008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549150600960008360001916600019168152602001908152602001600020549550600c60008360001916600019168152602001908152602001600020549450600a60008360001916600019168152602001908152602001600020549350600860008360001916600019168152602001908152602001600020549250600b6000836000191660001916815260200190815260200160002054905091939550919395565b601060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415156113db57600080fd5b6001810260148190555050565b601b5481565b601a5481565b60125481565b60008060008060003493506001601f5414151561141657600080fd5b60028614806114255750600386145b806114305750600586145b151561143b57600080fd5b601554841015801561144f57506014548411155b151561145a57600080fd5b60115492506003861415611472576012549250611482565b60058614156114815760135492505b5b828402601a5411151561149457600080fd5b61150b6040805190810160405280600c81526020017f576f6c6672616d416c70686100000000000000000000000000000000000000008152506040805190810160405280601f81526020017f72616e646f6d206e756d626572206265747765656e203020616e64203130300081525060195461202a565b9150600560003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020805480919060010161155e9190612d62565b905081600560003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020828154811015156115ad57fe5b906000526020600020900181600019169055503360066000846000191660001916815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550836007600084600019166000191681526020019081526020016000208190555086600a600084600019166000191681526020019081526020016000208190555085600b60008460001916600019168152602001908152602001600020819055506000600860008460001916600019168152602001908152602001600020819055506001600960008460001916600019168152602001908152602001600020819055506103e7600c600084600019166000191681526020019081526020016000208190555042600d600084600019166000191681526020019081526020016000208190555081600e60003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081600019169055508194505050505092915050565b600080600080600080600960008860001916600019168152602001908152602001600020549550600a60008860001916600019168152602001908152602001600020549450600860008860001916600019168152602001908152602001600020549350600c60008860001916600019168152602001908152602001600020549250600b60008860001916600019168152602001908152602001600020549150600d6000886000191660001916815260200190815260200160002054905091939550919395565b60175481565b3073ffffffffffffffffffffffffffffffffffffffff1631601e8190555060646016543073ffffffffffffffffffffffffffffffffffffffff16310281151561186457fe5b04601a81905550565b60145481565b601060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415156118cf57600080fd5b3073ffffffffffffffffffffffffffffffffffffffff1631601e8190555060646016543073ffffffffffffffffffffffffffffffffffffffff16310281151561191457fe5b04601a81905550565b601060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614151561197957600080fd5b846011819055508360128190555082601381905550816017819055506001810260188190555060646016543073ffffffffffffffffffffffffffffffffffffffff1631028115156119c657fe5b04601a819055503073ffffffffffffffffffffffffffffffffffffffff1631601e819055505050505050565b6000806000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff161480611a6257506000611a606000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1661257a565b145b15611a7357611a716000612585565b505b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166338cc48316000604051602001526040518163ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401602060405180830381600087803b1515611b0057600080fd5b6102c65a03f11515611b1157600080fd5b5050506040518051905073ffffffffffffffffffffffffffffffffffffffff16600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16141515611c5a576000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166338cc48316000604051602001526040518163ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401602060405180830381600087803b1515611bfe57600080fd5b6102c65a03f11515611c0f57600080fd5b50505060405180519050600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663c281d19e6000604051602001526040518163ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401602060405180830381600087803b1515611ce857600080fd5b6102c65a03f11515611cf957600080fd5b50505060405180519050905090565b6000611d15826000612596565b9050919050565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff161480611d8b57506000611d896000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1661257a565b145b15611d9c57611d9a6000612585565b505b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166338cc48316000604051602001526040518163ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401602060405180830381600087803b1515611e2957600080fd5b6102c65a03f11515611e3a57600080fd5b5050506040518051905073ffffffffffffffffffffffffffffffffffffffff16600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16141515611f83576000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166338cc48316000604051602001526040518163ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401602060405180830381600087803b1515611f2757600080fd5b6102c65a03f11515611f3857600080fd5b50505060405180519050600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663ca6ad1e4826040518263ffffffff167c010000000000000000000000000000000000000000000000000000000002815260040180828152602001915050600060405180830381600087803b151561201357600080fd5b6102c65a03f1151561202457600080fd5b50505050565b60008060008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16148061209c5750600061209a6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1661257a565b145b156120ad576120ab6000612585565b505b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166338cc48316000604051602001526040518163ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401602060405180830381600087803b151561213a57600080fd5b6102c65a03f1151561214b57600080fd5b5050506040518051905073ffffffffffffffffffffffffffffffffffffffff16600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16141515612294576000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166338cc48316000604051602001526040518163ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401602060405180830381600087803b151561223857600080fd5b6102c65a03f1151561224957600080fd5b50505060405180519050600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16632ef3accc86856000604051602001526040518363ffffffff167c01000000000000000000000000000000000000000000000000000000000281526004018080602001838152602001828103825284818151815260200191508051906020019080838360005b8381101561234e578082015181840152602081019050612333565b50505050905090810190601f16801561237b5780820380516001836020036101000a031916815260200191505b509350505050602060405180830381600087803b151561239a57600080fd5b6102c65a03f115156123ab57600080fd5b505050604051805190509050823a02670de0b6b3a7640000018111156123d75760006001029150612572565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663c51be90f8260008888886000604051602001526040518663ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808581526020018060200180602001848152602001838103835286818151815260200191508051906020019080838360005b8381101561249f578082015181840152602081019050612484565b50505050905090810190601f1680156124cc5780820380516001836020036101000a031916815260200191505b50838103825285818151815260200191508051906020019080838360005b838110156125055780820151818401526020810190506124ea565b50505050905090810190601f1680156125325780820380516001836020036101000a031916815260200191505b5096505050505050506020604051808303818588803b151561255357600080fd5b6125ee5a03f1151561256457600080fd5b505050506040518051905091505b509392505050565b6000813b9050919050565b600061258f612890565b9050919050565b60006125a0612d8e565b60008060008693506000925060009150600090505b83518110156128715760307f01000000000000000000000000000000000000000000000000000000000000000284828151811015156125f057fe5b9060200101517f010000000000000000000000000000000000000000000000000000000000000090047f0100000000000000000000000000000000000000000000000000000000000000027effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191610158015612708575060397f010000000000000000000000000000000000000000000000000000000000000002848281518110151561269857fe5b9060200101517f010000000000000000000000000000000000000000000000000000000000000090047f0100000000000000000000000000000000000000000000000000000000000000027effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191611155b156127b957811561272b57600086141561272157612871565b8580600190039650505b600a830292506030848281518110151561274157fe5b9060200101517f010000000000000000000000000000000000000000000000000000000000000090047f0100000000000000000000000000000000000000000000000000000000000000027f010000000000000000000000000000000000000000000000000000000000000090040383019250612864565b602e7f01000000000000000000000000000000000000000000000000000000000000000284828151811015156127eb57fe5b9060200101517f010000000000000000000000000000000000000000000000000000000000000090047f0100000000000000000000000000000000000000000000000000000000000000027effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916141561286357600191505b5b80806001019150506125b5565b60008611156128835785600a0a830292505b8294505050505092915050565b6000806128b0731d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed61257a565b111561295157731d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed6000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506129486040805190810160405280600b81526020017f6574685f6d61696e6e6574000000000000000000000000000000000000000000815250612d1f565b60019050612d1c565b600061297073c03a2615d5efaf5f49f60b7bb6583eaec212fdf161257a565b1115612a115773c03a2615d5efaf5f49f60b7bb6583eaec212fdf16000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550612a086040805190810160405280600c81526020017f6574685f726f707374656e330000000000000000000000000000000000000000815250612d1f565b60019050612d1c565b6000612a3073b7a07bcf2ba2f2703b24c0691b5278999c59ac7e61257a565b1115612ad15773b7a07bcf2ba2f2703b24c0691b5278999c59ac7e6000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550612ac86040805190810160405280600981526020017f6574685f6b6f76616e0000000000000000000000000000000000000000000000815250612d1f565b60019050612d1c565b6000612af073146500cfd35b22e4a392fe0adc06de1a1368ed4861257a565b1115612b915773146500cfd35b22e4a392fe0adc06de1a1368ed486000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550612b886040805190810160405280600b81526020017f6574685f72696e6b656279000000000000000000000000000000000000000000815250612d1f565b60019050612d1c565b6000612bb0736f485c8bf6fc43ea212e93bbf8ce046c7f1cb47561257a565b1115612c1357736f485c8bf6fc43ea212e93bbf8ce046c7f1cb4756000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060019050612d1c565b6000612c327320e12a1f859b3feae5fb2a0a32c18f5a65555bbf61257a565b1115612c95577320e12a1f859b3feae5fb2a0a32c18f5a65555bbf6000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060019050612d1c565b6000612cb47351efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa61257a565b1115612d17577351efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa6000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060019050612d1c565b600090505b90565b8060029080519060200190612d35929190612da2565b5050565b610c80604051908101604052806064905b6000815260200190600190039081612d4a5790505090565b815481835581811511612d8957818360005260206000209182019101612d889190612e22565b5b505050565b602060405190810160405280600081525090565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f10612de357805160ff1916838001178555612e11565b82800160010185558215612e11579182015b82811115612e10578251825591602001919060010190612df5565b5b509050612e1e9190612e47565b5090565b612e4491905b80821115612e40576000816000905550600101612e28565b5090565b90565b612e6991905b80821115612e65576000816000905550600101612e4d565b5090565b905600a165627a7a7230582097828e661fcd82e35586cf433f2f99154c25369734b2e5f7fde56af78938d55c0029"
}