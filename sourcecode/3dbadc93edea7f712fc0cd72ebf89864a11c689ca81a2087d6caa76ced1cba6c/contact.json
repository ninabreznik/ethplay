{
  "address": "0x1556a3ddb4fa2e9e8d6355380e4d22f9d32592cc",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "SCI: Old Token",
  "contractName": "ScienceBlockchainToken",
  "compilerVersion": "v0.4.16+commit.d7661dd9",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2017-12-13\n*/\n\n/*\n * Safe Math Smart Contract.\n * Author: Mikhail Vladimirov <[email protected]>\n */\npragma solidity ^0.4.16;\n\n/**\n * Provides methods to safely add, subtract and multiply uint256 numbers.\n */\ncontract SafeMath {\n  uint256 constant private MAX_UINT256 =\n    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n  /**\n   * Add two uint256 values, throw in case of overflow.\n   *\n   * @param x first value to add\n   * @param y second value to add\n   * @return x + y\n   */\n  function safeAdd (uint256 x, uint256 y)\n  constant internal\n  returns (uint256 z) {\n    assert (x <= MAX_UINT256 - y);\n    return x + y;\n  }\n\n  /**\n   * Subtract one uint256 value from another, throw in case of underflow.\n   *\n   * @param x value to subtract from\n   * @param y value to subtract\n   * @return x - y\n   */\n  function safeSub (uint256 x, uint256 y)\n  constant internal\n  returns (uint256 z) {\n    assert (x >= y);\n    return x - y;\n  }\n\n  /**\n   * Multiply two uint256 values, throw in case of overflow.\n   *\n   * @param x first value to multiply\n   * @param y second value to multiply\n   * @return x * y\n   */\n  function safeMul (uint256 x, uint256 y)\n  constant internal\n  returns (uint256 z) {\n    if (y == 0) return 0; // Prevent division by zero at the next line\n    assert (x <= MAX_UINT256 / y);\n    return x * y;\n  }\n} \n\n/*\n * ERC-20 Standard Token Smart Contract Interface.\n * Author: Mikhail Vladimirov <[email protected]>\n */\npragma solidity ^0.4.16;\n\n/**\n * ERC-20 standard token interface, as defined\n * <a href=\"http://github.com/ethereum/EIPs/issues/20\">here</a>.\n */\ncontract Token {\n  /**\n   * Get total number of tokens in circulation.\n   *\n   * @return total number of tokens in circulation\n   */\n  function totalSupply () constant returns (uint256 supply);\n\n  /**\n   * Get number of tokens currently belonging to given owner.\n   *\n   * @param _owner address to get number of tokens currently belonging to the\n   *        owner of\n   * @return number of tokens currently belonging to the owner of given address\n   */\n  function balanceOf (address _owner) constant returns (uint256 balance);\n\n  /**\n   * Transfer given number of tokens from message sender to given recipient.\n   *\n   * @param _to address to transfer tokens to the owner of\n   * @param _value number of tokens to transfer to the owner of given address\n   * @return true if tokens were transferred successfully, false otherwise\n   */\n  function transfer (address _to, uint256 _value) returns (bool success);\n\n  /**\n   * Transfer given number of tokens from given owner to given recipient.\n   *\n   * @param _from address to transfer tokens from the owner of\n   * @param _to address to transfer tokens to the owner of\n   * @param _value number of tokens to transfer from given owner to given\n   *        recipient\n   * @return true if tokens were transferred successfully, false otherwise\n   */\n  function transferFrom (address _from, address _to, uint256 _value)\n  returns (bool success);\n\n  /**\n   * Allow given spender to transfer given number of tokens from message sender.\n   *\n   * @param _spender address to allow the owner of to transfer tokens from\n   *        message sender\n   * @param _value number of tokens to allow to transfer\n   * @return true if token transfer was successfully approved, false otherwise\n   */\n  function approve (address _spender, uint256 _value) returns (bool success);\n\n  /**\n   * Tell how many tokens given spender is currently allowed to transfer from\n   * given owner.\n   *\n   * @param _owner address to get number of tokens allowed to be transferred\n   *        from the owner of\n   * @param _spender address to get number of tokens allowed to be transferred\n   *        by the owner of\n   * @return number of tokens given spender is currently allowed to transfer\n   *         from given owner\n   */\n  function allowance (address _owner, address _spender) constant\n  returns (uint256 remaining);\n\n  /**\n   * Logged when tokens were transferred from one owner to another.\n   *\n   * @param _from address of the owner, tokens were transferred from\n   * @param _to address of the owner, tokens were transferred to\n   * @param _value number of tokens transferred\n   */\n  event Transfer (address indexed _from, address indexed _to, uint256 _value);\n\n  /**\n   * Logged when owner approved his tokens to be transferred by some spender.\n   *\n   * @param _owner owner who approved his tokens to be transferred\n   * @param _spender spender who were allowed to transfer the tokens belonging\n   *        to the owner\n   * @param _value number of tokens belonging to the owner, approved to be\n   *        transferred by the spender\n   */\n  event Approval (\n    address indexed _owner, address indexed _spender, uint256 _value);\n} \n\n/*\n * Abstract base contract for Token Smart Contracts that may create snapshots of\n * token holder balances.\n * Author: Mikhail Vladimirov <[email protected]>\n */\npragma solidity ^0.4.16;\n\n\n/**\n * Abstract base contract Token Smart Contracts that support snapshots of token\n * holder balances.\n */\ncontract AbstractSnapshottableToken is SafeMath, Token {\n  /**\n   * Maximum number of tokens in circulation (2^256 - 1).\n   */\n  uint256 constant MAX_TOKENS = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n  /**\n   * Maximum value of uint256 type, i.e. 2^256-1.\n   */\n  uint256 constant MAX_UINT256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n  /**\n   * Maximum value of address represented as uint256, i.e. 2^160-1.\n   */\n  uint256 constant MAX_ADDRESS = 0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n  /**\n   * 2^160.\n   */\n  uint256 constant TWO_160 = 0x00010000000000000000000000000000000000000000;\n\n  /**\n   * Create new Abstract Snapshottable Token smart contract.\n   */\n  function AbstractSnapshottableToken () {\n    snapshots.length = 1; // Reserve zero ID.\n  }\n\n  /**\n   * Get total number of tokens in circulation.\n   *\n   * @return total number of tokens in circulation\n   */\n  function totalSupply () constant returns (uint256 supply) {\n    return tokensCount;\n  }\n\n  /**\n   * Get total number of tokens in circulation as is was at the moment when\n   * snapshot with given index was created.\n   *\n   * @param _index index of the snapshot to get total number of tokens in\n   *        circulation at the moment of\n   * @return total number of tokens in circulation at the moment snapshot with\n   *         given index was created\n   */\n  function totalSupplyAt (uint256 _index) constant returns (uint256 supply) {\n    require (_index > 0);\n    require (_index < snapshots.length);\n\n    return snapshots [_index].tokensCount;\n  }\n\n  /**\n   * Get number of tokens currently belonging to the owner of given address.\n   *\n   * @param _owner address to get number of tokens currently belonging to the\n   *        owner of\n   * @return number of tokens currently belonging to the owner of given address\n   */\n  function balanceOf (address _owner) constant returns (uint256 balance) {\n    return accounts [_owner].balance;\n  }\n\n  /**\n   * Get number of tokens owner of the given address had at the moment when\n   * snapshot with given index was created.\n   *\n   * @param _owner address to get number of tokens for the owner of\n   * @param _index index of the snapshot to get number of tokens at the time of\n   * @return number of tokens owner of the given address had at the moment the\n   *         snapshot with given index was created\n   */\n  function balanceOfAt (address _owner, uint256 _index)\n    constant returns (uint256 balance) {\n    require (_index > 0);\n    require (_index < snapshots.length);\n\n    if (_index > accounts [_owner].lastSnapshotIndex)\n      return accounts [_owner].balance;\n    else {\n      uint8 level = 0;\n      while (_index > 0) {\n        uint256 v = historicalBalances [_owner][level][_index];\n        if (v != 0) return v;\n\n        _index >>= 1;\n        level += 1; // Overflow is possible here, but is harmless\n      }\n\n      return 0;\n    }\n  }\n\n  /**\n   * Get first address that probably had non-zero token balance at the moment\n   * snapshot with given index was created.\n   *\n   * @param _index index of the snapshot to get first address the probably had\n   *        non-zero token balance at the moment of\n   * @return flag that tells whether there is at least one address that probably\n   *         had non-zero token balance at the moment of snapshot with given\n   *         index (hasResult); and the fist address that probably had non-zero\n   *         token balance at the moment snapshot with given index was created\n   *         or zero if there are no such addresses (result)\n   */\n  function firstAddressAt (uint256 _index)\n    constant returns (bool hasResult, address result) {\n    require (_index > 0);\n    require (_index < snapshots.length);\n    uint256 rawFirstAddress = snapshots [_index].firstAddress;\n    hasResult = rawFirstAddress != MAX_UINT256;\n    result = hasResult ?\n      address (rawFirstAddress & MAX_ADDRESS) :\n        0;\n  }\n\n  /**\n   * Get next address that probably had non-zero token balance at the moment\n   * certain snapshot was created.\n   *\n   * @param _address previous address that probably had non-zero token balance\n   *        at the moment of certain snapshot\n   * @return flag that tells whether there is next address that probably had\n   *         non-zero token balance at the moment of snapshot with given index\n   *         (hasResult); and the next address that probably had non-zero\n   *         token balance at the moment of snapshot with given index was\n   *         created or zero if there are no such addresses (result)\n   */\n  function nextAddress (address _address)\n    constant returns (bool hasResult, address result) {\n    uint256 rawNextAddress = nextAddresses [_address];\n    require (rawNextAddress != 0);\n    hasResult = rawNextAddress != MAX_UINT256;\n    result = hasResult ?\n      address (rawNextAddress & MAX_ADDRESS) :\n        0;\n  }\n\n  /**\n   * Transfer given number of tokens from message sender to given recipient.\n   *\n   * @param _to address to transfer tokens to the owner of\n   * @param _value number of tokens to transfer to the owner of given address\n   * @return true if tokens were transferred successfully, false otherwise\n   */\n  function transfer (address _to, uint256 _value) returns (bool success) {\n    return doTransfer (msg.sender, _to, _value);\n  }\n\n  /**\n   * Transfer given number of tokens from given owner to given recipient.\n   *\n   * @param _from address to transfer tokens from the owner of\n   * @param _to address to transfer tokens to the owner of\n   * @param _value number of tokens to transfer from given owner to given\n   *        recipient\n   * @return true if tokens were transferred successfully, false otherwise\n   */\n  function transferFrom (address _from, address _to, uint256 _value)\n  returns (bool success) {\n    if (_value > approved [_from][msg.sender]) return false;\n    else if (doTransfer (_from, _to, _value)) {\n      approved [_from][msg.sender] =\n        safeSub (approved[_from][msg.sender], _value);\n      return true;\n    } else return false;\n  }\n\n  /**\n   * Allow given spender to transfer given number of tokens from message sender.\n   *\n   * @param _spender address to allow the owner of to transfer tokens from\n   *        message sender\n   * @param _value number of tokens to allow to transfer\n   * @return true if token transfer was successfully approved, false otherwise\n   */\n  function approve (address _spender, uint256 _value) returns (bool success) {\n    approved [msg.sender][_spender] = _value;\n    Approval (msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * Tell how many tokens given spender is currently allowed to transfer from\n   * given owner.\n   *\n   * @param _owner address to get number of tokens allowed to be transferred\n   *        from the owner of\n   * @param _spender address to get number of tokens allowed to be transferred\n   *        by the owner of\n   * @return number of tokens given spender is currently allowed to transfer\n   *         from given owner\n   */\n  function allowance (address _owner, address _spender) constant\n  returns (uint256 remaining) {\n    return approved [_owner][_spender];\n  }\n\n  /**\n   * Create snapshot of token holder balances.\n   *\n   * @return index of new created snapshot\n   */\n  function snapshot () returns (uint256 index) {\n    index = snapshots.length++;\n    snapshots [index].tokensCount = tokensCount;\n    snapshots [index].firstAddress = firstAddress;\n    Snapshot (index);\n  }\n\n  /**\n   * Transfer given number of tokens from the owner of given from address to the\n   * owner of given to address.\n   *\n   * @param _from address to transfer tokens from the owner of\n   * @param _to address to transfer tokens to the owner of\n   * @param _value number of tokens to transfer\n   * @return true if tokens were transferred successfully, false otherwise\n   */\n  function doTransfer (address _from, address _to, uint256 _value)\n    internal returns (bool success) {\n    if (_value > accounts [_from].balance) return false;\n    else if (_value > 0 && _from != _to) {\n      saveAddress (_to);\n      updateHistoricalBalances (_from);\n      updateHistoricalBalances (_to);\n      accounts [_from].balance = safeSub (accounts [_from].balance, _value);\n      accounts [_to].balance = safeAdd (accounts [_to].balance, _value);\n      Transfer (_from, _to, _value);\n      return true;\n    } else return true;\n  }\n\n  /**\n   * Create given number of tokens and give them to message sender.\n   *\n   * @param _value number of tokens to create\n   * @return true on success, false on error\n   */\n  function doCreateTokens (uint256 _value) internal returns (bool success) {\n    if (_value > safeSub (MAX_TOKENS, tokensCount)) return false;\n    else if (_value > 0) {\n      saveAddress (msg.sender);\n      updateHistoricalBalances (msg.sender);\n      accounts [msg.sender].balance =\n        safeAdd (accounts [msg.sender].balance, _value);\n      tokensCount = safeAdd (tokensCount, _value);\n      return true;\n    } else return true;\n  }\n\n  /**\n   * Update historical balances for given token owner.\n   *\n   * @param _owner token owner to update historical balances for\n   */\n  function updateHistoricalBalances (address _owner) internal {\n    uint256 balance = accounts [_owner].balance;\n    uint256 nextSnapshotIndex = snapshots.length;\n    uint256 lastNextSnapshotIndex =\n      safeAdd (accounts [_owner].lastSnapshotIndex, 1);\n    if (nextSnapshotIndex > lastNextSnapshotIndex) {\n      if (balance > 0) {\n        setHistoricalBalance (\n          _owner, lastNextSnapshotIndex, nextSnapshotIndex, balance);\n      }\n      accounts [_owner].lastSnapshotIndex =\n        safeSub (nextSnapshotIndex, 1);\n    }\n  }\n\n  /**\n   * Set historical balance for the owner of given address as it was at the\n   * moments of snapshots with indexes in given range.\n   *\n   * @param _owner address to set the historical balance for the owner of\n   * @param _from beginning of the snapshot index range (inclusive)\n   * @param _to end of the snapshot index range (exclusive)\n   * @param _balance value to set balance to\n   */\n  function setHistoricalBalance (\n    address _owner, uint256 _from, uint256 _to, uint256 _balance)\n    internal {\n    assert (_from > 0);\n    assert (_to >= _from);\n    assert (_balance > 0);\n\n    uint8 level = 0;\n    while (_from < _to) {\n      if (_from & 1 == 1) {\n        // Overflow is not possible here because _from < _to\n        historicalBalances [_owner][level][_from++] = _balance;\n      }\n\n      if (_to & 1 == 1) {\n        // Underflow is not possible here, because _to & 1 == 1\n        historicalBalances [_owner][level][--_to] = _balance;\n      }\n\n      _from >>= 1;\n      _to >>= 1;\n      level += 1; // Even for snapshot index range 1..2^256-1 overflow will\n                  // not happen here\n    }\n  }\n\n  /**\n   * Add address to the list of addresses that ever had non-zero token balance.\n   *\n   * @param _address address to be added to the list of addresses that ever had\n   *        non-zero token balance\n   */\n  function saveAddress (address _address) internal {\n    if (nextAddresses [_address] == 0) {\n      nextAddresses [_address] = firstAddress;\n      firstAddress = TWO_160 | uint256(_address);\n    }\n  }\n\n  /**\n   * Total number of tokens in circulation.\n   */\n  uint256 tokensCount;\n\n  /**\n   * All snapshots ever created.\n   */\n  SnapshotInfo [] snapshots;\n\n  /**\n   * Maps addresses of token owners to states of their accounts.\n   */\n  mapping (address => Account) accounts;\n\n  /**\n   * First address that ever had non-zero token balance plus 2^160, or 2^256-1\n   * if there are no such addresses.\n   */\n  uint256 firstAddress = MAX_UINT256;\n\n  /**\n   * Mapping from address that ever had non-zero token balance to the next\n   * address that ever had non-zero token balance plus 2^160 or 2^256-1 if there\n   * are no more such addresses.\n   */\n  mapping (address => uint256) nextAddresses;\n\n  /**\n   * Historical balances of token owners.  If for some address, level and index,\n   * where level >= 0 and index > 0, historicalBalances[address][level][index]\n   * is non-zero, then owner of given address had this many tokens at the\n   * time moments of snapshots with indexes from (index * 2^level) to\n   * ((index + 1) * 2^level - 1) inclusive.\n   * For each snapshot, there should be at most one level with non-zero\n   * value at corresponding index.\n   */\n  mapping (address => mapping (uint8 => mapping (uint256 => uint256)))\n    historicalBalances;\n\n  /**\n   * Maps addresses of token owners to mappings from addresses of spenders to\n   * how many tokens belonging to the owner, the spender is currently allowed to\n   * transfer.\n   */\n  mapping (address => mapping (address => uint256)) approved;\n\n  /**\n   * Encapsulates information about snapshot.\n   */\n  struct SnapshotInfo {\n    /**\n     * Total number of tokens in circulation at the moment of snapshot.\n     */\n    uint256 tokensCount;\n\n    /**\n     * Value of firstAddress field at the moment of snapshot.\n     */\n    uint256 firstAddress;\n  }\n\n  /**\n   * Encapsulates information about token owner's balance.\n   */\n  struct Account {\n    /**\n     * Number of tokens currently belonging to the token owner.\n     */\n    uint256 balance;\n\n    /**\n     * Index of the last snapshot before the moment historical balances were\n     * last updated for this token owner.\n     */\n    uint256 lastSnapshotIndex;\n  }\n\n  /**\n   * Logged when new snapshot was created.\n   *\n   * @param _index index of the new snapshot\n   */\n  event Snapshot (uint256 indexed _index);\n}\n\n\n/*\n * Standard Snapshottable Token Smart Contract.\n * Author: Mikhail Vladimirov <[email protected]>\n */\n\n/**\n * Standard Snapshottable Token Smart Contract.\n */\ncontract StandardSnapshottableToken is AbstractSnapshottableToken {\n  /**\n   * Create new Standard Snapshottable Token Smart Contract and make\n   * message sender the owner of the smart contract.\n   */\n  function StandardSnapshottableToken ()\n    AbstractSnapshottableToken () {\n    owner = msg.sender;\n  }\n\n  /**\n   * Transfer given number of tokens from message sender to given recipient.\n   *\n   * @param _to address to transfer tokens to the owner of\n   * @param _value number of tokens to transfer to the owner of given address\n   * @return true if tokens were transferred successfully, false otherwise\n   */\n  function transfer (address _to, uint256 _value) returns (bool success) {\n    if (frozen) return false;\n    else return AbstractSnapshottableToken.transfer (_to, _value);\n  }\n\n  /**\n   * Transfer given number of tokens from given owner to given recipient.\n   *\n   * @param _from address to transfer tokens from the owner of\n   * @param _to address to transfer tokens to the owner of\n   * @param _value number of tokens to transfer from given owner to given\n   *        recipient\n   * @return true if tokens were transferred successfully, false otherwise\n   */\n  function transferFrom (address _from, address _to, uint256 _value)\n  returns (bool success) {\n    if (frozen) return false;\n    else\n      return AbstractSnapshottableToken.transferFrom (_from, _to, _value);\n  }\n\n  /**\n   * Create given number of tokens and give them to message sender.  May only be\n   * called by the owner of the smart contract.\n   *\n   * @param _value number of tokens to create\n   * @return true on success, false on error\n   */\n  function createTokens (uint256 _value) returns (bool success) {\n    require (msg.sender == owner);\n\n    return doCreateTokens (_value);\n  }\n\n  /**\n   * Freeze token transfers.  May only be called by the owner of the smart\n   * contract.\n   */\n  function freezeTransfers () {\n    require (msg.sender == owner);\n\n    if (!frozen)\n    {\n      frozen = true;\n      Freeze ();\n    }\n  }\n\n  /**\n   * Unfreeze token transfers.  May only be called by the owner of the smart\n   * contract.\n   */\n  function unfreezeTransfers () {\n    require (msg.sender == owner);\n\n    if (frozen) {\n      frozen = false;\n      Unfreeze ();\n    }\n  }\n\n  /**\n   * Set new owner address.  May only be called by the owner of the smart\n   * contract.\n   *\n   * @param _newOwner new owner address\n   */\n  function setOwner (address _newOwner) {\n    require (msg.sender == owner);\n\n    owner = _newOwner;\n  }\n\n  /**\n   * Owner of this smart contract.\n   */\n  address owner;\n\n  /**\n   * Whether token transfers are currently frozen.\n   */\n  bool frozen;\n\n  /**\n   * Logged when token transfers were frozen.\n   */\n  event Freeze ();\n\n  /**\n   * Logged when token transfers were unfrozen.\n   */\n  event Unfreeze ();\n}\n\n\n/*\n * Science Blockchain Token Smart Contract.\n * Author: Mikhail Vladimirov <[email protected]>\n */\n\n/**\n * Science Blockchain Token Smart Contract.\n */\ncontract ScienceBlockchainToken is StandardSnapshottableToken {\n  /**\n   * Create new Science Blockchain Token smart contract and make message sender\n   * to be the owner of smart contract and to be a snapshot creator.\n   */\n  function ScienceBlockchainToken ()\n    StandardSnapshottableToken () {\n    snapshotCreator = msg.sender;\n  }\n\n  /**\n   * Create snapshot of token holder balances.\n   *\n   * @return index of new created snapshot\n   */\n  function snapshot () returns (uint256 index) {\n    require (msg.sender == snapshotCreator);\n    return AbstractSnapshottableToken.snapshot ();\n  }\n\n  /**\n   * Get name of this token.\n   *\n   * @return name of this token\n   */\n  function name () constant returns (string result) {\n    return \"SCIENCE BLOCKCHAIN\";\n  }\n\n  /**\n   * Get symbol of this token.\n   *\n   * @return symbol of this token\n   */\n  function symbol () constant returns (string result) {\n    return \"SCI\";\n  }\n\n  /**\n   * Get number of decimals for this token.\n   *\n   * @return number of decimals for this token\n   */\n  function decimals () constant returns (uint8 result) {\n    return 0;\n  }\n\n  /**\n   * Burn given number of tokens belonging to message sender.\n   *\n   * @param _value number of tokens to burn\n   * @return true if tokens were burned successfully, false otherwise\n   */\n  function burnTokens (uint256 _value) returns (bool success) {\n    uint256 balance = accounts [msg.sender].balance;\n    if (_value > balance) return false;\n    if (_value > 0) {\n      updateHistoricalBalances (msg.sender);\n      accounts [msg.sender].balance = safeSub (balance, _value);\n      tokensCount = safeSub (tokensCount, _value);\n      return true;\n    }\n    return true;\n  }\n\n  /**\n   * Set new snapshot creator address.\n   *\n   * @param _snapshotCreator new snapshot creator address\n   */\n  function setSnapshotCreator (address _snapshotCreator) {\n    require (msg.sender == owner);\n    snapshotCreator = _snapshotCreator;\n  }\n\n  /**\n   * Address of snapshot creator, i.e. the one allowed to create snapshots.\n   */\n  address snapshotCreator;\n}",
  "bytecode": "6060604052600019600355341561001557600080fd5b5b5b5b60016100248180610063565b505b60078054600160a060020a03191633600160a060020a03161790555b60088054600160a060020a03191633600160a060020a03161790555b6100bc565b81548183558181151161008f5760020281600202836000526020600020918201910161008f9190610095565b5b505050565b6100b991905b808211156100b5576000808255600182015560020161009b565b5090565b90565b6110ba806100cb6000396000f3006060604052361561010f5763ffffffff7c010000000000000000000000000000000000000000000000000000000060003504166301502460811461011457806306fdde0314610129578063095ea7b3146101b457806313af4035146101ea57806318160ddd1461020b57806323b872dd14610230578063313ce5671461026c57806331c420d4146102955780634ee2cd7e146102aa578063584fc102146102de578063618765d8146103175780636d1b229d1461033857806370a08231146103625780637e1f2bb81461039357806395d89b41146103bd5780639711715a14610448578063981b24d01461046d5780639d9bd2b414610495578063a9059cbb146104d7578063dd62ed3e1461050d575b600080fd5b341561011f57600080fd5b610127610544565b005b341561013457600080fd5b61013c6105c6565b60405160208082528190810183818151815260200191508051906020019080838360005b838110156101795780820151818401525b602001610160565b50505050905090810190601f1680156101a65780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b34156101bf57600080fd5b6101d6600160a060020a0360043516602435610608565b604051901515815260200160405180910390f35b34156101f557600080fd5b610127600160a060020a0360043516610675565b005b341561021657600080fd5b61021e6106bc565b60405190815260200160405180910390f35b341561023b57600080fd5b6101d6600160a060020a03600435811690602435166044356106c3565b604051901515815260200160405180910390f35b341561027757600080fd5b61027f6106f6565b60405160ff909116815260200160405180910390f35b34156102a057600080fd5b6101276106fc565b005b34156102b557600080fd5b61021e600160a060020a0360043516602435610777565b60405190815260200160405180910390f35b34156102e957600080fd5b6102f4600435610844565b6040519115158252600160a060020a031660208201526040908101905180910390f35b341561032257600080fd5b610127600160a060020a03600435166108b0565b005b341561034357600080fd5b6101d66004356108f7565b604051901515815260200160405180910390f35b341561036d57600080fd5b61021e600160a060020a036004351661097b565b60405190815260200160405180910390f35b341561039e57600080fd5b6101d660043561099a565b604051901515815260200160405180910390f35b34156103c857600080fd5b61013c6109c9565b60405160208082528190810183818151815260200191508051906020019080838360005b838110156101795780820151818401525b602001610160565b50505050905090810190601f1680156101a65780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b341561045357600080fd5b61021e610a0b565b60405190815260200160405180910390f35b341561047857600080fd5b61021e600435610a37565b60405190815260200160405180910390f35b34156104a057600080fd5b6102f4600160a060020a0360043516610a7c565b6040519115158252600160a060020a031660208201526040908101905180910390f35b34156104e257600080fd5b6101d6600160a060020a0360043516602435610acb565b604051901515815260200160405180910390f35b341561051857600080fd5b61021e600160a060020a0360043581169060243516610b00565b60405190815260200160405180910390f35b60075433600160a060020a0390811691161461055f57600080fd5b60075460a060020a900460ff1615156105c3576007805474ff0000000000000000000000000000000000000000191660a060020a1790557f615acbaede366d76a8b8cb2a9ada6a71495f0786513d71aa97aaf0c3910b78de60405160405180910390a15b5b565b6105ce611023565b60408051908101604052601281527f534349454e434520424c4f434b434841494e0000000000000000000000000000602082015290505b90565b600160a060020a03338116600081815260066020908152604080832094871680845294909152808220859055909291907f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b9259085905190815260200160405180910390a35060015b92915050565b60075433600160a060020a0390811691161461069057600080fd5b6007805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0383161790555b50565b6000545b90565b60075460009060a060020a900460ff16156106e0575060006106ee565b6106eb848484610b2d565b90505b5b9392505050565b60005b90565b60075433600160a060020a0390811691161461071757600080fd5b60075460a060020a900460ff16156105c3576007805474ff0000000000000000000000000000000000000000191690557f2f05ba71d0df11bf5fa562a6569d70c4f80da84284badbe015ce1456063d0ded60405160405180910390a15b5b565b6000808080841161078757600080fd5b600154841061079557600080fd5b600160a060020a0385166000908152600260205260409020600101548411156107d857600160a060020a038516600090815260026020526040902054925061083b565b600091505b60008411156108365750600160a060020a038416600090815260056020908152604080832060ff85168452825280832086845290915290205480156108245780925061083b565b600290930492600191909101906107dd565b600092505b5b505092915050565b6000808080841161085457600080fd5b600154841061086257600080fd5b600180548590811061087057fe5b906000526020600020906002020160005b5060010154905060001981141592508261089c5760006108a7565b600160a060020a0381165b91505b50915091565b60075433600160a060020a039081169116146108cb57600080fd5b6008805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0383161790555b50565b600160a060020a033316600090815260026020526040812054808311156109215760009150610975565b60008311156109705761093333610be6565b61093d8184610c63565b600160a060020a033316600090815260026020526040812091909155546109649084610c63565b60005560019150610975565b600191505b50919050565b600160a060020a0381166000908152600260205260409020545b919050565b60075460009033600160a060020a039081169116146109b857600080fd5b6109c182610c7a565b90505b919050565b6109d1611023565b60408051908101604052600381527f5343490000000000000000000000000000000000000000000000000000000000602082015290505b90565b60085460009033600160a060020a03908116911614610a2957600080fd5b610a31610d18565b90505b90565b6000808211610a4557600080fd5b6001548210610a5357600080fd5b6001805483908110610a6157fe5b906000526020600020906002020160005b505490505b919050565b600160a060020a0381166000908152600460205260408120548190801515610aa357600080fd5b60001981141592508261089c5760006108a7565b600160a060020a0381165b91505b50915091565b60075460009060a060020a900460ff1615610ae85750600061066f565b610af28383610daa565b905061066f565b5b92915050565b600160a060020a038083166000908152600660209081526040808320938516835292905220545b92915050565b600160a060020a03808416600090815260066020908152604080832033909416835292905290812054821115610b65575060006106ee565b610b70848484610dc0565b15610bd557600160a060020a0380851660009081526006602090815260408083203390941683529290522054610ba69083610c63565b600160a060020a03808616600090815260066020908152604080832033909416835292905220555060016106ee565b5060006106ee565b5b5b9392505050565b600160a060020a038116600090815260026020526040812080546001805492810154919391610c1491610eec565b905080821115610c5c576000831115610c3357610c3384828486610f08565b5b610c3f826001610c63565b600160a060020a0385166000908152600260205260409020600101555b5b50505050565b600081831015610c6f57fe5b508082035b92915050565b6000610c8a600019600054610c63565b821115610c9957506000610995565b6000821115610d0957610cab33610fd7565b610cb433610be6565b600160a060020a033316600090815260026020526040902054610cd79083610eec565b600160a060020a03331660009081526002602052604081209190915554610cfe9083610eec565b600055506001610995565b506001610995565b5b5b919050565b60018054600091610d2b90828101611035565b9050600054600182815481101515610d3f57fe5b906000526020600020906002020160005b50556003546001805483908110610d6357fe5b906000526020600020906002020160005b5060010155807f8030e83b04d87bef53480e26263266d6ca66863aa8506aca6f2559d18aa1cb6760405160405180910390a25b90565b6000610db7338484610dc0565b90505b92915050565b600160a060020a038316600090815260026020526040812054821115610de8575060006106ee565b600082118015610e0a575082600160a060020a031684600160a060020a031614155b15610edb57610e1883610fd7565b610e2184610be6565b610e2a83610be6565b600160a060020a038416600090815260026020526040902054610e4d9083610c63565b600160a060020a038086166000908152600260205260408082209390935590851681522054610e7c9083610eec565b600160a060020a03808516600081815260026020526040908190209390935591908616907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef9085905190815260200160405180910390a35060016106ee565b5060016106ee565b5b5b9392505050565b6000600019829003831115610efd57fe5b508181015b92915050565b6000808411610f1357fe5b83831015610f1d57fe5b60008211610f2757fe5b5060005b82841015610fcf578360011660011415610f7757600160a060020a038516600090815260056020908152604080832060ff85168452825280832087845290915290208290556001909301925b8260011660011415610fbc57600160a060020a038516600090815260056020908152604080832060ff8516845282528083206000199096018084529590915290208290555b6002938490049390920491600101610f2b565b5b5050505050565b600160a060020a03811660009081526004602052604090205415156106b95760038054600160a060020a03831660008181526004602052604090209190915560a060020a1790555b5b50565b60206040519081016040526000815290565b815481835581811511611061576002028160020283600052602060002091820191016110619190611067565b5b505050565b61060591905b80821115611087576000808255600182015560020161106d565b5090565b905600a165627a7a7230582071702e78d22ba963c26375689926cdce2ee288ee9dd4c5f0b6a5e82c2f4dc5c20029"
}