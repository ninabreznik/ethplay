{
  "address": "0x12704eac473edeb63a4c696d63badd0337d8997b",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "Predel",
  "compilerVersion": "v0.4.21+commit.dfe3193c",
  "optimization": false,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2019-04-03\n*/\n\npragma solidity ^0.4.21;\n\ncontract Zamok {\n\n    // MEMBERS\n    uint256 public zamokCount;\n\n    // CONSTRUCTOR\n    function Zamok() public {\n        zamokCount = 0;\n    }\n\n    // FUNCTIONS\n    function generateZamokId() internal returns (bytes32 zamokId) {\n        return keccak256(block.blockhash(block.number - 1), address(this), ++zamokCount);\n    }\n}\n\n\ncontract CustodianCanBeReplaced is Zamok {\n\n    // TYPES\n    struct CustodianChangeRequest {\n        address proposedNew;\n    }\n\n    // MEMBERS\n    address public custodian;\n\n    mapping (bytes32 => CustodianChangeRequest) public custodianChangeRequests;\n\n    // CONSTRUCTOR\n    function CustodianCanBeReplaced(\n        address _custodian\n    )\n    \n\tZamok() public\n    {\n        custodian = _custodian;\n    }\n\n    // MODIFIERS\n    modifier onlyCustodian {\n        require(msg.sender == custodian);\n        _;\n    }\n\n    // PUBLIC FUNCTIONS\n    // (UPGRADE)\n\n    function requestCustodianChange(address _proposedCustodian) public returns (bytes32 zamokId) {\n        require(_proposedCustodian != address(0));\n\n        zamokId = generateZamokId();\n\n        custodianChangeRequests[zamokId] = CustodianChangeRequest({\n            proposedNew: _proposedCustodian\n        });\n\n        emit CustodianChangeRequested(zamokId, msg.sender, _proposedCustodian);\n    }\n\n    function confirmCustodianChange(bytes32 _zamokId) public onlyCustodian {\n        custodian = getCustodianChangeRequest(_zamokId);\n\n        delete custodianChangeRequests[_zamokId];\n\n        emit CustodianChangeConfirmed(_zamokId, custodian);\n    }\n\n    // PRIVATE FUNCTIONS\n    function getCustodianChangeRequest(bytes32 _zamokId) private view returns (address _proposedNew) {\n        CustodianChangeRequest storage changeRequest = custodianChangeRequests[_zamokId];\n\n        // reject ‘null’ results from the map lookup\n        // this can only be the case if an unknown `_zamokId` is received\n        require(changeRequest.proposedNew != 0);\n\n        return changeRequest.proposedNew;\n    }\n\n    event CustodianChangeRequested(\n        bytes32 _zamokId,\n        address _msgSender,\n        address _proposedCustodian\n    );\n\n    event CustodianChangeConfirmed(bytes32 _zamokId, address _newCustodian);\n}\n\n\ncontract DeloCanBeReplaced is CustodianCanBeReplaced  {\n\n    // TYPES\n    struct DeloChangeRequest {\n        address proposedNew;\n    }\n\n    // MEMBERS\n    // @dev  The reference to the active token implementation.\n    Delo public delo;\n\n    mapping (bytes32 => DeloChangeRequest) public deloChangeRequests;\n\n    // CONSTRUCTOR\n    function DeloCanBeReplaced(address _custodian) CustodianCanBeReplaced(_custodian) public {\n        delo = Delo(0x0);\n    }\n\n    // MODIFIERS\n    modifier onlyDelo {\n        require(msg.sender == address(delo));\n        _;\n    }\n\n    // PUBLIC FUNCTIONS\n    // (UPGRADE)\n    function requestDeloChange(address _proposedDelo) public returns (bytes32 zamokId) {\n        require(_proposedDelo != address(0));\n\n        zamokId = generateZamokId();\n\n        deloChangeRequests[zamokId] = DeloChangeRequest({\n            proposedNew: _proposedDelo\n        });\n\n        emit DeloChangeRequested(zamokId, msg.sender, _proposedDelo);\n    }\n\n    function confirmDeloChange(bytes32 _zamokId) public onlyCustodian {\n        delo = getDeloChangeRequest(_zamokId);\n\n        delete deloChangeRequests[_zamokId];\n\n        emit DeloChangeConfirmed(_zamokId, address(delo));\n    }\n\n    // PRIVATE FUNCTIONS\n    function getDeloChangeRequest(bytes32 _zamokId) private view returns (Delo _proposedNew) {\n        DeloChangeRequest storage changeRequest = deloChangeRequests[_zamokId];\n\n        // reject ‘null’ results from the map lookup\n        // this can only be the case if an unknown `_zamokId` is received\n        require(changeRequest.proposedNew != address(0));\n\n        return Delo(changeRequest.proposedNew);\n    }\n\n    event DeloChangeRequested(\n        bytes32 _zamokId,\n        address _msgSender,\n        address _proposedDelo\n    );\n\n    event DeloChangeConfirmed(bytes32 _zamokId, address _newImpl);\n}\n\n\ncontract ERC20Interface {\n  // METHODS\n\n  // NOTE:\n  //   public getter functions are not currently recognised as an\n  //   implementation of the matching abstract function by the compiler.\n\n  // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#name\n  // function name() public view returns (string);\n\n  // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#symbol\n  // function symbol() public view returns (string);\n\n  // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#totalsupply\n  // function decimals() public view returns (uint8);\n\n  // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#totalsupply\n  function totalSupply() public view returns (uint256);\n\n  // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#balanceof\n  function balanceOf(address _owner) public view returns (uint256 balance);\n\n  // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#transfer\n  function transfer(address _to, uint256 _value) public returns (bool success);\n\n  // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#transferfrom\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n\n  // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#approve\n  function approve(address _spender, uint256 _value) public returns (bool success);\n\n  // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#allowance\n  function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n\n  // EVENTS\n  // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#transfer-1\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n  // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#approval\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\ncontract Front is ERC20Interface, DeloCanBeReplaced {\n\n    // MEMBERS\n    string public name;\n\n    string public symbol;\n\n    uint8 public decimals;\n\n    // CONSTRUCTOR\n    function Front(\n        string _name,\n        string _symbol,\n        uint8 _decimals,\n        address _custodian\n    )\n        DeloCanBeReplaced(_custodian)\n        public\n    {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n    }\n\n    // PUBLIC FUNCTIONS\n    // (ERC20Interface)\n    function totalSupply() public view returns (uint256) {\n        return delo.totalSupply();\n    }\n\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return delo.balanceOf(_owner);\n    }\n\n    function emitTransfer(address _from, address _to, uint256 _value) public onlyDelo {\n        emit Transfer(_from, _to, _value);\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        return delo.transferWithSender(msg.sender, _to, _value);\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        return delo.transferFromWithSender(msg.sender, _from, _to, _value);\n    }\n\n    function emitApproval(address _owner, address _spender, uint256 _value) public onlyDelo {\n        emit Approval(_owner, _spender, _value);\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        return delo.approveWithSender(msg.sender, _spender, _value);\n    }\n\n    function increaseApproval(address _spender, uint256 _addedValue) public returns (bool success) {\n        return delo.increaseApprovalWithSender(msg.sender, _spender, _addedValue);\n    }\n\n    function decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool success) {\n        return delo.decreaseApprovalWithSender(msg.sender, _spender, _subtractedValue);\n    }\n\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return delo.allowance(_owner, _spender);\n    }\n}\n\n\ncontract Delo is CustodianCanBeReplaced {\n\n    // TYPES\n    struct PendingPrint {\n        address receiver;\n        uint256 value;\n    }\n\n    // MEMBERS\n    Front public front;\n\n    Grossbuch public grossbuch;\n\n    address public sweeper;\n\n    bytes32 public sweepMsg;\n\n    mapping (address => bool) public sweptSet;\n\n    mapping (bytes32 => PendingPrint) public pendingPrintMap;\n\n    // CONSTRUCTOR\n    function Delo(\n          address _front,\n          address _grossbuch,\n          address _custodian,\n          address _sweeper\n    )\n        CustodianCanBeReplaced(_custodian)\n        public\n    {\n        require(_sweeper != 0);\n        front = Front(_front);\n        grossbuch = Grossbuch(_grossbuch);\n\n        sweeper = _sweeper;\n        sweepMsg = keccak256(address(this), \"sweep\");\n    }\n\n    // MODIFIERS\n    modifier onlyFront {\n        require(msg.sender == address(front));\n        _;\n    }\n    modifier onlySweeper {\n        require(msg.sender == sweeper);\n        _;\n    }\n\n\n    function approveWithSender(\n        address _sender,\n        address _spender,\n        uint256 _value\n    )\n        public\n        onlyFront\n        returns (bool success)\n    {\n        require(_spender != address(0)); // disallow unspendable approvals\n        grossbuch.setAllowance(_sender, _spender, _value);\n        front.emitApproval(_sender, _spender, _value);\n        return true;\n    }\n\n    function increaseApprovalWithSender(\n        address _sender,\n        address _spender,\n        uint256 _addedValue\n    )\n        public\n        onlyFront\n        returns (bool success)\n    {\n        require(_spender != address(0)); // disallow unspendable approvals\n        uint256 currentAllowance = grossbuch.allowed(_sender, _spender);\n        uint256 newAllowance = currentAllowance + _addedValue;\n\n        require(newAllowance >= currentAllowance);\n\n        grossbuch.setAllowance(_sender, _spender, newAllowance);\n        front.emitApproval(_sender, _spender, newAllowance);\n        return true;\n    }\n\n    function decreaseApprovalWithSender(\n        address _sender,\n        address _spender,\n        uint256 _subtractedValue\n    )\n        public\n        onlyFront\n        returns (bool success)\n    {\n        require(_spender != address(0)); // disallow unspendable approvals\n        uint256 currentAllowance = grossbuch.allowed(_sender, _spender);\n        uint256 newAllowance = currentAllowance - _subtractedValue;\n\n        require(newAllowance <= currentAllowance);\n\n        grossbuch.setAllowance(_sender, _spender, newAllowance);\n        front.emitApproval(_sender, _spender, newAllowance);\n        return true;\n    }\n\n\n    function requestPrint(address _receiver, uint256 _value) public returns (bytes32 zamokId) {\n        require(_receiver != address(0));\n\n        zamokId = generateZamokId();\n\n        pendingPrintMap[zamokId] = PendingPrint({\n            receiver: _receiver,\n            value: _value\n        });\n\n        emit PrintingLocked(zamokId, _receiver, _value);\n    }\n\n\n    function confirmPrint(bytes32 _zamokId) public onlyCustodian {\n        PendingPrint storage print = pendingPrintMap[_zamokId];\n\n        // reject ‘null’ results from the map lookup\n        // this can only be the case if an unknown `_zamokId` is received\n        address receiver = print.receiver;\n        require (receiver != address(0));\n        uint256 value = print.value;\n\n        delete pendingPrintMap[_zamokId];\n\n        uint256 supply = grossbuch.totalSupply();\n        uint256 newSupply = supply + value;\n        if (newSupply >= supply) {\n          grossbuch.setTotalSupply(newSupply);\n          grossbuch.addBalance(receiver, value);\n\n          emit PrintingConfirmed(_zamokId, receiver, value);\n          front.emitTransfer(address(0), receiver, value);\n        }\n    }\n\n\n    function burn(uint256 _value) public returns (bool success) {\n        uint256 balanceOfSender = grossbuch.balances(msg.sender);\n        require(_value <= balanceOfSender);\n\n        grossbuch.setBalance(msg.sender, balanceOfSender - _value);\n        grossbuch.setTotalSupply(grossbuch.totalSupply() - _value);\n\n        front.emitTransfer(msg.sender, address(0), _value);\n\n        return true;\n    }\n\n\n    function batchTransfer(address[] _tos, uint256[] _values) public returns (bool success) {\n        require(_tos.length == _values.length);\n\n        uint256 numTransfers = _tos.length;\n        uint256 senderBalance = grossbuch.balances(msg.sender);\n\n        for (uint256 i = 0; i < numTransfers; i++) {\n          address to = _tos[i];\n          require(to != address(0));\n          uint256 v = _values[i];\n          require(senderBalance >= v);\n\n          if (msg.sender != to) {\n            senderBalance -= v;\n            grossbuch.addBalance(to, v);\n          }\n          front.emitTransfer(msg.sender, to, v);\n        }\n\n        grossbuch.setBalance(msg.sender, senderBalance);\n\n        return true;\n    }\n\n    function enableSweep(uint8[] _vs, bytes32[] _rs, bytes32[] _ss, address _to) public onlySweeper {\n        require(_to != address(0));\n        require((_vs.length == _rs.length) && (_vs.length == _ss.length));\n\n        uint256 numSignatures = _vs.length;\n        uint256 sweptBalance = 0;\n\n        for (uint256 i=0; i<numSignatures; ++i) {\n          address from = ecrecover(sweepMsg, _vs[i], _rs[i], _ss[i]);\n\n          // ecrecover returns 0 on malformed input\n          if (from != address(0)) {\n            sweptSet[from] = true;\n\n            uint256 fromBalance = grossbuch.balances(from);\n\n            if (fromBalance > 0) {\n              sweptBalance += fromBalance;\n\n              grossbuch.setBalance(from, 0);\n\n              front.emitTransfer(from, _to, fromBalance);\n            }\n          }\n        }\n\n        if (sweptBalance > 0) {\n          grossbuch.addBalance(_to, sweptBalance);\n        }\n    }\n\n    function replaySweep(address[] _froms, address _to) public onlySweeper {\n        require(_to != address(0));\n        uint256 lenFroms = _froms.length;\n        uint256 sweptBalance = 0;\n\n        for (uint256 i=0; i<lenFroms; ++i) {\n            address from = _froms[i];\n\n            if (sweptSet[from]) {\n                uint256 fromBalance = grossbuch.balances(from);\n\n                if (fromBalance > 0) {\n                    sweptBalance += fromBalance;\n\n                    grossbuch.setBalance(from, 0);\n\n                    front.emitTransfer(from, _to, fromBalance);\n                }\n            }\n        }\n\n        if (sweptBalance > 0) {\n            grossbuch.addBalance(_to, sweptBalance);\n        }\n    }\n\n    function transferFromWithSender(\n        address _sender,\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        public\n        onlyFront\n        returns (bool success)\n    {\n        require(_to != address(0)); // ensure burn is the cannonical transfer to 0x0\n\n        uint256 balanceOfFrom = grossbuch.balances(_from);\n        require(_value <= balanceOfFrom);\n\n        uint256 senderAllowance = grossbuch.allowed(_from, _sender);\n        require(_value <= senderAllowance);\n\n        grossbuch.setBalance(_from, balanceOfFrom - _value);\n        grossbuch.addBalance(_to, _value);\n\n        grossbuch.setAllowance(_from, _sender, senderAllowance - _value);\n\n        front.emitTransfer(_from, _to, _value);\n\n        return true;\n    }\n\n    function transferWithSender(\n        address _sender,\n        address _to,\n        uint256 _value\n    )\n        public\n        onlyFront\n        returns (bool success)\n    {\n        require(_to != address(0)); // ensure burn is the cannonical transfer to 0x0\n\n        uint256 balanceOfSender = grossbuch.balances(_sender);\n        require(_value <= balanceOfSender);\n\n        grossbuch.setBalance(_sender, balanceOfSender - _value);\n        grossbuch.addBalance(_to, _value);\n\n        front.emitTransfer(_sender, _to, _value);\n\n        return true;\n    }\n\n    // METHODS (ERC20 sub interface impl.)\n    function totalSupply() public view returns (uint256) {\n        return grossbuch.totalSupply();\n    }\n\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return grossbuch.balances(_owner);\n    }\n\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return grossbuch.allowed(_owner, _spender);\n    }\n\n    // EVENTS\n    event PrintingLocked(bytes32 _zamokId, address _receiver, uint256 _value);\n\n    event PrintingConfirmed(bytes32 _zamokId, address _receiver, uint256 _value);\n}\n\n\n\ncontract Grossbuch is DeloCanBeReplaced {\n\n    // MEMBERS\n    uint256 public totalSupply;\n\n    mapping (address => uint256) public balances;\n\n    mapping (address => mapping (address => uint256)) public allowed;\n\n    // CONSTRUCTOR\n    function Grossbuch(address _custodian) DeloCanBeReplaced(_custodian) public {\n        totalSupply = 0;\n    }\n\n\n    // PUBLIC FUNCTIONS\n\n    function setTotalSupply(\n        uint256 _newTotalSupply\n    )\n        public\n        onlyDelo\n    {\n        totalSupply = _newTotalSupply;\n    }\n\n\n    function setAllowance(\n        address _owner,\n        address _spender,\n        uint256 _value\n    )\n        public\n        onlyDelo\n    {\n        allowed[_owner][_spender] = _value;\n    }\n\n\n    function setBalance(\n        address _owner,\n        uint256 _newBalance\n    )\n        public\n        onlyDelo\n    {\n        balances[_owner] = _newBalance;\n    }\n\n\n    function addBalance(\n        address _owner,\n        uint256 _balanceIncrease\n    )\n        public\n        onlyDelo\n    {\n        balances[_owner] = balances[_owner] + _balanceIncrease;\n    }\n}\n\n\n\ncontract Predel is Zamok {\n\n    // TYPES\n    struct PendingCeilingRaise {\n        uint256 raiseBy;\n    }\n\n    // MEMBERS\n    Delo public delo;\n\n    address public custodian;\n\n    address public predel;\n\n    uint256 public totalSupplyCeiling;\n\n    mapping (bytes32 => PendingCeilingRaise) public pendingRaiseMap;\n\n    // CONSTRUCTOR\n    function Predel(\n        address _delo,\n        address _custodian,\n        address _predel,\n        uint256 _initialCeiling\n    )\n        public\n    {\n        delo = Delo(_delo);\n        custodian = _custodian;\n        predel = _predel;\n        totalSupplyCeiling = _initialCeiling;\n    }\n\n    // MODIFIERS\n    modifier onlyCustodian {\n        require(msg.sender == custodian);\n        _;\n    }\n    modifier onlyPredel {\n        require(msg.sender == predel);\n        _;\n    }\n\n    function limitedPrint(address _receiver, uint256 _value) public onlyPredel {\n        uint256 totalSupply = delo.totalSupply();\n        uint256 newTotalSupply = totalSupply + _value;\n\n        require(newTotalSupply >= totalSupply);\n        require(newTotalSupply <= totalSupplyCeiling);\n        delo.confirmPrint(delo.requestPrint(_receiver, _value));\n    }\n\n    function requestCeilingRaise(uint256 _raiseBy) public returns (bytes32 zamokId) {\n        require(_raiseBy != 0);\n\n        zamokId = generateZamokId();\n\n        pendingRaiseMap[zamokId] = PendingCeilingRaise({\n            raiseBy: _raiseBy\n        });\n\n        emit CeilingRaiseLocked(zamokId, _raiseBy);\n    }\n\n    function confirmCeilingRaise(bytes32 _zamokId) public onlyCustodian {\n        PendingCeilingRaise storage pendingRaise = pendingRaiseMap[_zamokId];\n\n        // copy locals of references to struct members\n        uint256 raiseBy = pendingRaise.raiseBy;\n        // accounts for a gibberish _zamokId\n        require(raiseBy != 0);\n\n        delete pendingRaiseMap[_zamokId];\n\n        uint256 newCeiling = totalSupplyCeiling + raiseBy;\n        // overflow check\n        if (newCeiling >= totalSupplyCeiling) {\n            totalSupplyCeiling = newCeiling;\n\n            emit CeilingRaiseConfirmed(_zamokId, raiseBy, newCeiling);\n        }\n    }\n\n    function lowerCeiling(uint256 _lowerBy) public onlyPredel {\n        uint256 newCeiling = totalSupplyCeiling - _lowerBy;\n        // overflow check\n        require(newCeiling <= totalSupplyCeiling);\n        totalSupplyCeiling = newCeiling;\n\n        emit CeilingLowered(_lowerBy, newCeiling);\n    }\n\n    function confirmPrintProxy(bytes32 _zamokId) public onlyCustodian {\n        delo.confirmPrint(_zamokId);\n    }\n\n\n    function confirmCustodianChangeProxy(bytes32 _zamokId) public onlyCustodian {\n        delo.confirmCustodianChange(_zamokId);\n    }\n\n    // EVENTS\n    event CeilingRaiseLocked(bytes32 _zamokId, uint256 _raiseBy);\n\n    event CeilingRaiseConfirmed(bytes32 _zamokId, uint256 _raiseBy, uint256 _newCeiling);\n\n    event CeilingLowered(uint256 _lowerBy, uint256 _newCeiling);\n}",
  "abi": "[{\"constant\":false,\"inputs\":[{\"name\":\"_zamokId\",\"type\":\"bytes32\"}],\"name\":\"confirmCustodianChangeProxy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_zamokId\",\"type\":\"bytes32\"}],\"name\":\"confirmCeilingRaise\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"pendingRaiseMap\",\"outputs\":[{\"name\":\"raiseBy\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_lowerBy\",\"type\":\"uint256\"}],\"name\":\"lowerCeiling\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"custodian\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"delo\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"zamokCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"predel\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_zamokId\",\"type\":\"bytes32\"}],\"name\":\"confirmPrintProxy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupplyCeiling\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"limitedPrint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_raiseBy\",\"type\":\"uint256\"}],\"name\":\"requestCeilingRaise\",\"outputs\":[{\"name\":\"zamokId\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_delo\",\"type\":\"address\"},{\"name\":\"_custodian\",\"type\":\"address\"},{\"name\":\"_predel\",\"type\":\"address\"},{\"name\":\"_initialCeiling\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_zamokId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_raiseBy\",\"type\":\"uint256\"}],\"name\":\"CeilingRaiseLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_zamokId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_raiseBy\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newCeiling\",\"type\":\"uint256\"}],\"name\":\"CeilingRaiseConfirmed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_lowerBy\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newCeiling\",\"type\":\"uint256\"}],\"name\":\"CeilingLowered\",\"type\":\"event\"}]",
  "bytecode": "6060604052341561000f57600080fd5b604051608080610d18833981016040528080519060200190919080519060200190919080519060200190919080519060200190919050506000808190555083600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555082600260006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555081600360006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508060048190555050505050610bee8061012a6000396000f3006060604052600436106100ba576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063051d9955146100bf57806312460fdd146100e6578063264da19e1461010d5780633351373914610148578063375b74c31461016b57806346f08fc0146101c0578063486cefbb146102155780638bcacf961461023e5780638cbf41451461029357806395a51233146102ba578063a94c7c65146102e3578063c9bc5dbd14610325575b600080fd5b34156100ca57600080fd5b6100e4600480803560001916906020019091905050610364565b005b34156100f157600080fd5b61010b60048080356000191690602001909190505061046b565b005b341561011857600080fd5b610132600480803560001916906020019091905050610595565b6040518082815260200191505060405180910390f35b341561015357600080fd5b61016960048080359060200190919050506105b3565b005b341561017657600080fd5b61017e610673565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b34156101cb57600080fd5b6101d3610699565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b341561022057600080fd5b6102286106bf565b6040518082815260200191505060405180910390f35b341561024957600080fd5b6102516106c5565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b341561029e57600080fd5b6102b86004808035600019169060200190919050506106eb565b005b34156102c557600080fd5b6102cd6107f2565b6040518082815260200191505060405180910390f35b34156102ee57600080fd5b610323600480803573ffffffffffffffffffffffffffffffffffffffff169060200190919080359060200190919050506107f8565b005b341561033057600080fd5b6103466004808035906020019091905050610aa2565b60405180826000191660001916815260200191505060405180910390f35b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415156103c057600080fd5b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16633a8343ee826040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808260001916600019168152602001915050600060405180830381600087803b151561045857600080fd5b5af1151561046557600080fd5b50505050565b6000806000600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415156104cc57600080fd5b6005600085600019166000191681526020019081526020016000209250826000015491506000821415151561050057600080fd5b6005600085600019166000191681526020019081526020016000206000808201600090555050816004540190506004548110151561058f57806004819055507f3779579f908c94480802e9c026789736b5c6a0382577c15f94feb7e23eafcfd2848383604051808460001916600019168152602001838152602001828152602001935050505060405180910390a15b50505050565b60056020528060005260406000206000915090508060000154905081565b6000600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614151561061157600080fd5b81600454039050600454811115151561062957600080fd5b806004819055507f76f283ae36a7f1bcca5e9475a544804430c59279a8b72325d56fb5ade52ab6328282604051808381526020018281526020019250505060405180910390a15050565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b60005481565b600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614151561074757600080fd5b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663380ba30c826040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808260001916600019168152602001915050600060405180830381600087803b15156107df57600080fd5b5af115156107ec57600080fd5b50505050565b60045481565b600080600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614151561085757600080fd5b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166318160ddd6040518163ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401602060405180830381600087803b15156108dc57600080fd5b5af115156108e957600080fd5b505050604051805190509150828201905081811015151561090957600080fd5b600454811115151561091a57600080fd5b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663380ba30c600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663be23d29187876040518363ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200182815260200192505050602060405180830381600087803b1515610a1c57600080fd5b5af11515610a2957600080fd5b505050604051805190506040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808260001916600019168152602001915050600060405180830381600087803b1515610a8c57600080fd5b5af11515610a9957600080fd5b50505050505050565b6000808214151515610ab357600080fd5b610abb610b41565b905060206040519081016040528083815250600560008360001916600019168152602001908152602001600020600082015181600001559050507f938f54351a24c466787f903e29b0590fe701da10a63db9b78c2a10ad8a8e1f6781836040518083600019166000191681526020018281526020019250505060405180910390a1919050565b600060014303403060008081546001019190508190556040518084600019166000191681526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166c01000000000000000000000000028152601401828152602001935050505060405180910390209050905600a165627a7a7230582059ab69ef7ce0db5a9c0a07909895a0b99d7e9c2ec9ae0c29954a50c32fb95e810029000000000000000000000000c10b919e5a2d2d5ad2241ddfa851345cb8bf4d0e0000000000000000000000003bef6e4b3177d1c8c128013d0ae3540f331e43c3000000000000000000000000c0380379ca1ef6b1a0d6aadb5c12ea3d30329936000000000000000000000000000000000000000000000000000000517da02c00",
  "constructorArguments": "000000000000000000000000c10b919e5a2d2d5ad2241ddfa851345cb8bf4d0e0000000000000000000000003bef6e4b3177d1c8c128013d0ae3540f331e43c3000000000000000000000000c0380379ca1ef6b1a0d6aadb5c12ea3d30329936000000000000000000000000000000000000000000000000000000517da02c00"
}