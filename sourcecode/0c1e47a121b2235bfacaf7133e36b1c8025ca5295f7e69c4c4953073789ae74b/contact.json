{
  "address": "0xfa45a09e17056d352bfe7f75d5d2c9debeddaee5",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "RealToken",
  "compilerVersion": "v0.5.4+commit.9549d8ff",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2019-02-20\n*/\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @return the address of the owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner());\n        _;\n    }\n\n    /**\n     * @return true if `msg.sender` is the owner of the contract.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Allows the current owner to relinquish control of the contract.\n     * @notice Renouncing to ownership will leave the contract without an owner.\n     * It will not be possible to call the functions with the `onlyOwner`\n     * modifier anymore.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n/**\n * @title SafeMath\n * @dev Unsigned math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    /**\n     * @dev Multiplies two unsigned integers, reverts on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two unsigned integers, reverts on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n     * reverts when dividing by zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\ncontract SimpleToken is Ownable {\n    using SafeMath for uint256;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    mapping (address => uint256) private _balances;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev Total number of tokens in existence\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev Gets the balance of the specified address.\n     * @param owner The address to query the balance of.\n     * @return An uint256 representing the amount owned by the passed address.\n     */\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\n\n    /**\n     * @dev Transfer token for a specified address\n     * @param to The address to transfer to.\n     * @param value The amount to be transferred.\n     */\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n\n    /**\n     * @dev Transfer token for a specified addresses\n     * @param from The address to transfer from.\n     * @param to The address to transfer to.\n     * @param value The amount to be transferred.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        require(to != address(0));\n        require(value <= _balances[from]); // Check there is enough balance.\n\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev public function that mints an amount of the token and assigns it to\n     * an account. This encapsulates the modification of balances such that the\n     * proper events are emitted.\n     * @param account The account that will receive the created tokens.\n     * @param value The amount that will be created.\n     */\n    function _mint(address account, uint256 value) internal {\n        require(account != address(0));\n\n        _totalSupply = _totalSupply.add(value);\n        _balances[account] = _balances[account].add(value);\n        emit Transfer(address(0), account, value);\n    }\n}\ncontract Manageable is Ownable {\n    mapping(address => bool) public listOfManagers;\n\n    modifier onlyManager() {\n        require(listOfManagers[msg.sender], \"\");\n        _;\n    }\n\n    function addManager(address _manager) public onlyOwner returns (bool success) {\n        if (!listOfManagers[_manager]) {\n            require(_manager != address(0), \"\");\n            listOfManagers[_manager] = true;\n            success = true;\n        }\n    }\n\n    function removeManager(address _manager) public onlyOwner returns (bool success) {\n        if (listOfManagers[_manager]) {\n            listOfManagers[_manager] = false;\n            success = true;\n        }\n    }\n\n    function getInfo(address _manager) public view returns (bool) {\n        return listOfManagers[_manager];\n    }\n}\n\n\ncontract iRNG {\n    function update(uint roundNumber, uint additionalNonce, uint period) public payable;\n    function __callback(bytes32 _queryId, uint _result) public;\n}\n\n\ncontract iKYCWhitelist {\n    function isWhitelisted(address _participant) public view returns (bool);\n}\n\ncontract BaseLottery is Manageable {\n    using SafeMath for uint;\n\n    enum RoundState {NOT_STARTED, ACCEPT_FUNDS, WAIT_RESULT, SUCCESS, REFUND}\n\n    struct Round {\n        RoundState state;\n        uint ticketsCount;\n        uint participantCount;\n        TicketsInterval[] tickets;\n        address[] participants;\n        uint random;\n        uint nonce; //xored participants addresses\n        uint startRoundTime;\n        uint[] winningTickets;\n        address[] winners;\n        uint roundFunds;\n        mapping(address => uint) winnersFunds;\n        mapping(address => uint) participantFunds;\n        mapping(address => bool) sendGain;\n    }\n\n    struct TicketsInterval {\n        address participant;\n        uint firstTicket;\n        uint lastTicket;\n    }\n\n    uint constant public NUMBER_OF_WINNERS = 10;\n    uint constant public SHARE_DENOMINATOR = 10000;\n    //uint constant public ORACLIZE_TIMEOUT = 86400;  // one day\n    uint public ORACLIZE_TIMEOUT = 86400;  // only for tests\n    uint[] public shareOfWinners = [5000, 2500, 1250, 620, 320, 160, 80, 40, 20, 10];\n    address payable public organiser;\n    uint constant public ORGANISER_PERCENT = 20;\n    uint constant public ROUND_FUND_PERCENT = 80;\n\n    iKYCWhitelist public KYCWhitelist;\n\n    uint public period;\n    address public mainLottery;\n    address public management;\n    address payable public rng;\n\n    mapping (uint => Round) public rounds;\n\n    uint public ticketPrice;\n    uint public currentRound;\n\n    event LotteryStarted(uint start);\n    event RoundStateChanged(uint currentRound, RoundState state);\n    event ParticipantAdded(uint round, address participant, uint ticketsCount, uint funds);\n    event RoundProcecced(uint round, address[] winners, uint[] winningTickets, uint roundFunds);\n    event RefundIsSuccess(uint round, address participant, uint funds);\n    event RefundIsFailed(uint round, address participant);\n    event Withdraw(address participant, uint funds, uint fromRound, uint toRound);\n    event AddressIsNotAddedInKYC(address participant);\n    event TicketPriceChanged(uint price);\n\n    modifier onlyRng {\n        require(msg.sender == address(rng), \"\");\n        _;\n    }\n\n    modifier onlyLotteryContract {\n        require(msg.sender == address(mainLottery) || msg.sender == management, \"\");\n        _;\n    }\n\n    constructor (address payable _rng, uint _period) public {\n        require(_rng != address(0), \"\");\n        require(_period >= 60, \"\");\n\n        rng = _rng;\n        period = _period;\n    }\n\n    function setContracts(address payable _rng, address _mainLottery, address _management) public onlyOwner {\n        require(_rng != address(0), \"\");\n        require(_mainLottery != address(0), \"\");\n        require(_management != address(0), \"\");\n\n        rng = _rng;\n        mainLottery = _mainLottery;\n        management = _management;\n    }\n\n    function startLottery(uint _startPeriod) public payable onlyLotteryContract {\n        currentRound = 1;\n        uint time = getCurrentTime().add(_startPeriod).sub(period);\n        rounds[currentRound].startRoundTime = time;\n        rounds[currentRound].state = RoundState.ACCEPT_FUNDS;\n\n        iRNG(rng).update.value(msg.value)(currentRound, 0, _startPeriod);\n\n        emit LotteryStarted(time);\n    }\n\n    function buyTickets(address _participant) public payable onlyLotteryContract {\n        uint funds = msg.value;\n\n        updateRoundTimeAndState();\n        addParticipant(_participant, funds.div(ticketPrice));\n        updateRoundFundsAndParticipants(_participant, funds);\n\n        if (getCurrentTime() > rounds[currentRound].startRoundTime.add(period) &&\n            rounds[currentRound].participantCount >= 10\n        ) {\n            _restartLottery();\n        }\n    }\n\n    function buyBonusTickets(address _participant, uint _ticketsCount) public payable onlyLotteryContract {\n        updateRoundTimeAndState();\n        addParticipant(_participant, _ticketsCount);\n        updateRoundFundsAndParticipants(_participant, uint(0));\n\n        if (getCurrentTime() > rounds[currentRound].startRoundTime.add(period) &&\n            rounds[currentRound].participantCount >= 10\n        ) {\n            _restartLottery();\n        }\n    }\n\n    function processRound(uint _round, uint _randomNumber) public payable onlyRng returns (bool) {\n        if (rounds[_round].winners.length != 0) {\n            return true;\n        }\n\n        if (checkRoundState(_round) == RoundState.REFUND) {\n            return true;\n        }\n\n        if (rounds[_round].participantCount < 10) {\n            rounds[_round].state = RoundState.ACCEPT_FUNDS;\n            emit RoundStateChanged(_round, rounds[_round].state);\n            return true;\n        }\n\n        rounds[_round].random = _randomNumber;\n        findWinTickets(_round);\n        findWinners(_round);\n        rounds[_round].state = RoundState.SUCCESS;\n        emit RoundStateChanged(_round, rounds[_round].state);\n\n        if (rounds[_round.add(1)].state == RoundState.NOT_STARTED) {\n            currentRound = _round.add(1);\n            rounds[currentRound].state = RoundState.ACCEPT_FUNDS;\n            emit RoundStateChanged(currentRound, rounds[currentRound].state);\n        }\n\n        emit RoundProcecced(_round, rounds[_round].winners, rounds[_round].winningTickets, rounds[_round].roundFunds);\n        getRandomNumber(_round + 1, rounds[_round].nonce);\n        return true;\n    }\n\n    function restartLottery() public payable onlyOwner {\n        _restartLottery();\n    }\n\n    function getRandomNumber(uint _round, uint _nonce) public payable onlyRng {\n        iRNG(rng).update(_round, _nonce, period);\n    }\n\n    function setTicketPrice(uint _ticketPrice) public onlyLotteryContract {\n        require(_ticketPrice > 0, \"\");\n\n        emit TicketPriceChanged(_ticketPrice);\n        ticketPrice = _ticketPrice;\n    }\n\n    function findWinTickets(uint _round) public {\n        uint[10] memory winners = _findWinTickets(rounds[_round].random, rounds[_round].ticketsCount);\n\n        for (uint i = 0; i < 10; i++) {\n            rounds[_round].winningTickets.push(winners[i]);\n        }\n    }\n\n    function _findWinTickets(uint _random, uint _ticketsNum) public pure returns (uint[10] memory) {\n        uint random = _random;//uint(keccak256(abi.encodePacked(_random)));\n        uint winnersNum = 10;\n\n        uint[10] memory winTickets;\n        uint shift = uint(256).div(winnersNum);\n\n        for (uint i = 0; i < 10; i++) {\n            winTickets[i] =\n            uint(keccak256(abi.encodePacked(((random << (i.mul(shift))) >> (shift.mul(winnersNum.sub(1)).add(6)))))).mod(_ticketsNum);\n        }\n\n        return winTickets;\n    }\n\n    function refund(uint _round) public {\n        if (checkRoundState(_round) == RoundState.REFUND\n        && rounds[_round].participantFunds[msg.sender] > 0\n        ) {\n            uint amount = rounds[_round].participantFunds[msg.sender];\n            rounds[_round].participantFunds[msg.sender] = 0;\n            address(msg.sender).transfer(amount);\n            emit RefundIsSuccess(_round, msg.sender, amount);\n        } else {\n            emit RefundIsFailed(_round, msg.sender);\n        }\n    }\n\n    function checkRoundState(uint _round) public returns (RoundState) {\n        if (rounds[_round].state == RoundState.WAIT_RESULT\n        && getCurrentTime() > rounds[_round].startRoundTime.add(ORACLIZE_TIMEOUT)\n        ) {\n            rounds[_round].state = RoundState.REFUND;\n            emit RoundStateChanged(_round, rounds[_round].state);\n        }\n        return rounds[_round].state;\n    }\n\n    function setOrganiser(address payable _organiser) public onlyOwner {\n        require(_organiser != address(0), \"\");\n\n        organiser = _organiser;\n    }\n\n    function setKYCWhitelist(address _KYCWhitelist) public onlyOwner {\n        require(_KYCWhitelist != address(0), \"\");\n\n        KYCWhitelist = iKYCWhitelist(_KYCWhitelist);\n    }\n\n    function getGain(uint _fromRound, uint _toRound) public {\n        _transferGain(msg.sender, _fromRound, _toRound);\n    }\n\n    function sendGain(address payable _participant, uint _fromRound, uint _toRound) public onlyManager {\n        _transferGain(_participant, _fromRound, _toRound);\n    }\n\n    function getTicketsCount(uint _round) public view returns (uint) {\n        return rounds[_round].ticketsCount;\n    }\n\n    function getTicketPrice() public view returns (uint) {\n        return ticketPrice;\n    }\n\n    function getCurrentTime() public view returns (uint) {\n        return now;\n    }\n\n    function getPeriod() public view returns (uint) {\n        return period;\n    }\n\n    function getRoundWinners(uint _round) public view returns (address[] memory) {\n        return rounds[_round].winners;\n    }\n\n    function getRoundWinningTickets(uint _round) public view returns (uint[] memory) {\n        return rounds[_round].winningTickets;\n    }\n\n    function getRoundParticipants(uint _round) public view returns (address[] memory) {\n        return rounds[_round].participants;\n    }\n\n    function getWinningFunds(uint _round, address _winner) public view returns  (uint) {\n        return rounds[_round].winnersFunds[_winner];\n    }\n\n    function getRoundFunds(uint _round) public view returns (uint) {\n        return rounds[_round].roundFunds;\n    }\n\n    function getParticipantFunds(uint _round, address _participant) public view returns (uint) {\n        return rounds[_round].participantFunds[_participant];\n    }\n\n    function getCurrentRound() public view returns (uint) {\n        return currentRound;\n    }\n\n    function getRoundStartTime(uint _round) public view returns (uint) {\n        return rounds[_round].startRoundTime;\n    }\n\n    function _restartLottery() internal {\n        uint _now = getCurrentTime().sub(rounds[1].startRoundTime);\n        rounds[currentRound].startRoundTime = getCurrentTime().sub(_now.mod(period));\n        rounds[currentRound].state = RoundState.ACCEPT_FUNDS;\n        emit RoundStateChanged(currentRound, rounds[currentRound].state);\n        iRNG(rng).update(currentRound, 0, period.sub(_now.mod(period)));\n    }\n\n    function _transferGain(address payable _participant, uint _fromRound, uint _toRound) internal {\n        require(_fromRound <= _toRound, \"\");\n        require(_participant != address(0), \"\");\n\n        if (KYCWhitelist.isWhitelisted(_participant)) {\n            uint funds;\n\n            for (uint i = _fromRound; i <= _toRound; i++) {\n\n                if (rounds[i].state == RoundState.SUCCESS\n                && rounds[i].sendGain[_participant] == false) {\n\n                    rounds[i].sendGain[_participant] = true;\n                    funds = funds.add(getWinningFunds(i, _participant));\n                }\n            }\n\n            require(funds > 0, \"\");\n            _participant.transfer(funds);\n            emit Withdraw(_participant, funds, _fromRound, _toRound);\n        } else {\n            emit AddressIsNotAddedInKYC(_participant);\n        }\n    }\n\n    // find participant who has winning ticket\n    // to start: _begin is 0, _end is last index in ticketsInterval array\n    function getWinner(\n        uint _round,\n        uint _beginInterval,\n        uint _endInterval,\n        uint _winningTicket\n    )\n        internal\n        returns (address)\n    {\n        if (_beginInterval == _endInterval) {\n            return rounds[_round].tickets[_beginInterval].participant;\n        }\n\n        uint len = _endInterval.add(1).sub(_beginInterval);\n        uint mid = _beginInterval.add((len.div(2))).sub(1);\n        TicketsInterval memory interval = rounds[_round].tickets[mid];\n\n        if (_winningTicket < interval.firstTicket) {\n            return getWinner(_round, _beginInterval, mid, _winningTicket);\n        } else if (_winningTicket > interval.lastTicket) {\n            return getWinner(_round, mid.add(1), _endInterval, _winningTicket);\n        } else {\n            return interval.participant;\n        }\n    }\n\n    function addParticipant(address _participant, uint _ticketsCount) internal {\n        rounds[currentRound].participants.push(_participant);\n        uint currTicketsCount = rounds[currentRound].ticketsCount;\n        rounds[currentRound].ticketsCount = currTicketsCount.add(_ticketsCount);\n        rounds[currentRound].tickets.push(TicketsInterval(\n                _participant,\n                currTicketsCount,\n                rounds[currentRound].ticketsCount.sub(1))\n        );\n        rounds[currentRound].nonce = rounds[currentRound].nonce + uint(keccak256(abi.encodePacked(_participant)));\n        emit ParticipantAdded(currentRound, _participant, _ticketsCount, _ticketsCount.mul(ticketPrice));\n    }\n\n    function updateRoundTimeAndState() internal {\n        if (getCurrentTime() > rounds[currentRound].startRoundTime.add(period)\n            && rounds[currentRound].participantCount >= 10\n        ) {\n            rounds[currentRound].state = RoundState.WAIT_RESULT;\n            emit RoundStateChanged(currentRound, rounds[currentRound].state);\n            currentRound = currentRound.add(1);\n            rounds[currentRound].startRoundTime = rounds[currentRound-1].startRoundTime.add(period);\n            rounds[currentRound].state = RoundState.ACCEPT_FUNDS;\n            emit RoundStateChanged(currentRound, rounds[currentRound].state);\n        }\n    }\n\n    function updateRoundFundsAndParticipants(address _participant, uint _funds) internal {\n\n        if (rounds[currentRound].participantFunds[_participant] == 0) {\n            rounds[currentRound].participantCount = rounds[currentRound].participantCount.add(1);\n        }\n\n        rounds[currentRound].participantFunds[_participant] =\n        rounds[currentRound].participantFunds[_participant].add(_funds);\n\n        rounds[currentRound].roundFunds =\n        rounds[currentRound].roundFunds.add(_funds);\n    }\n\n    function findWinners(uint _round) internal {\n        address winner;\n        uint fundsToWinner;\n        for (uint i = 0; i < NUMBER_OF_WINNERS; i++) {\n            winner = getWinner(\n                _round,\n                0,\n                (rounds[_round].tickets.length).sub(1),\n                rounds[_round].winningTickets[i]\n            );\n\n            rounds[_round].winners.push(winner);\n            fundsToWinner = rounds[_round].roundFunds.mul(shareOfWinners[i]).div(SHARE_DENOMINATOR);\n            rounds[_round].winnersFunds[winner] = rounds[_round].winnersFunds[winner].add(fundsToWinner);\n        }\n    }\n\n}contract FiatContract {\n  function USD(uint _id) public pure returns (uint256);\n}\n\ncontract RealToken is Ownable, SimpleToken {\n  FiatContract public price;\n  BaseLottery public lottery;\n    \n  using SafeMath for uint256;\n\n  string public constant name = \"DreamPot Token\";\n  string public constant symbol = \"DPT\";\n  uint32 public constant decimals = 0;\n\n  address payable public ethBank;\n\n  uint256 public factor;\n\n  event GetEth(address indexed from, uint256 value);\n\n  constructor() public {\n    price = FiatContract(0x8055d0504666e2B6942BeB8D6014c964658Ca591);\n    ethBank = address(uint160(owner()));\n    factor = 100;\n  }\n\n  function setLotteryBank(address bank) public onlyOwner {\n    require(bank != address(0));\n    ethBank = address(uint160(bank));\n  }\n\n  function setRoundFactor(uint256 newFactor) public onlyOwner {\n    factor = newFactor;\n  }\n  \n  function AddTokens(address addrTo) public payable {\n    uint256 ethCent = price.USD(0);\n    uint256 usdv = ethCent.div(1000);\n    usdv = usdv.mul(factor);\n    \n    uint256 tokens = msg.value.div(usdv);\n    ethBank.transfer(msg.value);\n    emit GetEth(addrTo, msg.value);\n    _mint(addrTo, tokens);\n  }\n  \n  function() external payable {\n  }\n}\ncontract IChecker {\n    function update() public payable;\n}\n\n\ncontract SuperJackPot is BaseLottery {\n\n    IChecker public checker;\n\n    modifier onlyChecker {\n        require(msg.sender == address(checker), \"\");\n        _;\n    }\n\n    constructor(\n        address payable _rng,\n        uint _period,\n        address _checker\n    )\n        public\n        BaseLottery(_rng, _period) {\n            require(_checker != address(0), \"\");\n\n            checker = IChecker(_checker);\n    }\n\n    function () external payable {\n\n    }\n\n    function processLottery() public payable onlyChecker {\n        rounds[currentRound].state = RoundState.WAIT_RESULT;\n        emit RoundStateChanged(currentRound, rounds[currentRound].state);\n        currentRound = currentRound.add(1);\n        rounds[currentRound].startRoundTime = getCurrentTime();\n        rounds[currentRound].state = RoundState.ACCEPT_FUNDS;\n        emit RoundStateChanged(currentRound, rounds[currentRound].state);\n        iRNG(rng).update.value(msg.value)(currentRound, rounds[currentRound].nonce, 0);\n    }\n\n    function startLottery(uint _startPeriod) public payable onlyLotteryContract {\n        _startPeriod;\n        currentRound = 1;\n        uint time = getCurrentTime();\n        rounds[currentRound].startRoundTime = time;\n        rounds[currentRound].state = RoundState.ACCEPT_FUNDS;\n        emit RoundStateChanged(currentRound, rounds[currentRound].state);\n        emit LotteryStarted(time);\n        checker.update.value(msg.value)();\n    }\n\n    function setChecker(address _checker) public onlyOwner {\n        require(_checker != address(0), \"\");\n\n        checker = IChecker(_checker);\n    }\n\n    function processRound(uint _round, uint _randomNumber) public payable onlyRng returns (bool) {\n        rounds[_round].random = _randomNumber;\n        rounds[_round].winningTickets.push(_randomNumber.mod(rounds[_round].ticketsCount));\n\n        address winner = getWinner(\n            _round,\n            0,\n            (rounds[_round].tickets.length).sub(1),\n            rounds[_round].winningTickets[0]\n        );\n\n        rounds[_round].winners.push(winner);\n        rounds[_round].winnersFunds[winner] = rounds[_round].roundFunds;\n        rounds[_round].state = RoundState.SUCCESS;\n\n        emit RoundStateChanged(_round, rounds[_round].state);\n        emit RoundProcecced(_round, rounds[_round].winners, rounds[_round].winningTickets, rounds[_round].roundFunds);\n\n        currentRound = currentRound.add(1);\n        rounds[currentRound].state = RoundState.ACCEPT_FUNDS;\n\n        emit RoundStateChanged(_round, rounds[_round].state);\n        return true;\n    }\n\n    function buyTickets(address _participant) public payable onlyLotteryContract {\n        require(msg.value > 0, \"\");\n\n        uint ticketsCount = msg.value.div(ticketPrice);\n        addParticipant(_participant, ticketsCount);\n\n        updateRoundFundsAndParticipants(_participant, msg.value);\n    }\n}",
  "bytecode": "608060405234801561001057600080fd5b5060008054600160a060020a0319163317808255604051600160a060020a039190911691907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0908290a360038054600160a060020a031916738055d0504666e2b6942beb8d6014c964658ca5911790556100916401000000006100bb810204565b60058054600160a060020a031916600160a060020a039290921691909117905560646006556100ca565b600054600160a060020a031690565b610a10806100d96000396000f3fe60806040526004361061011b576000357c01000000000000000000000000000000000000000000000000000000009004806371d5573e116100b257806395d89b411161008157806395d89b411461034b578063a035b1fe14610360578063a9059cbb14610375578063ba13a572146103ae578063f2fde38b146103c35761011b565b806371d5573e146102a957806376b12c37146102dc5780638da5cb5b1461030d5780638f32d59b146103225761011b565b806354f703f8116100ee57806354f703f8146102225780636923a80a1461023757806370a0823114610261578063715018a6146102945761011b565b8063024ec3eb1461011d57806306fdde031461014357806318160ddd146101cd578063313ce567146101f4575b005b61011b6004803603602081101561013357600080fd5b5035600160a060020a03166103f6565b34801561014f57600080fd5b50610158610554565b6040805160208082528351818301528351919283929083019185019080838360005b8381101561019257818101518382015260200161017a565b50505050905090810190601f1680156101bf5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b3480156101d957600080fd5b506101e261058b565b60408051918252519081900360200190f35b34801561020057600080fd5b50610209610591565b6040805163ffffffff9092168252519081900360200190f35b34801561022e57600080fd5b506101e2610596565b34801561024357600080fd5b5061011b6004803603602081101561025a57600080fd5b503561059c565b34801561026d57600080fd5b506101e26004803603602081101561028457600080fd5b5035600160a060020a03166105b4565b3480156102a057600080fd5b5061011b6105cf565b3480156102b557600080fd5b5061011b600480360360208110156102cc57600080fd5b5035600160a060020a0316610639565b3480156102e857600080fd5b506102f1610690565b60408051600160a060020a039092168252519081900360200190f35b34801561031957600080fd5b506102f161069f565b34801561032e57600080fd5b506103376106ae565b604080519115158252519081900360200190f35b34801561035757600080fd5b506101586106bf565b34801561036c57600080fd5b506102f16106f6565b34801561038157600080fd5b506103376004803603604081101561039857600080fd5b50600160a060020a038135169060200135610705565b3480156103ba57600080fd5b506102f161071c565b3480156103cf57600080fd5b5061011b600480360360208110156103e657600080fd5b5035600160a060020a031661072b565b600354604080517f0c560c6400000000000000000000000000000000000000000000000000000000815260006004820181905291519192600160a060020a031691630c560c6491602480820192602092909190829003018186803b15801561045d57600080fd5b505afa158015610471573d6000803e3d6000fd5b505050506040513d602081101561048757600080fd5b50519050600061049f826103e863ffffffff61074a16565b90506104b66006548261076e90919063ffffffff16565b905060006104ca348363ffffffff61074a16565b600554604051919250600160a060020a0316903480156108fc02916000818181858888f19350505050158015610504573d6000803e3d6000fd5b50604080513481529051600160a060020a038616917ff8e2143eb748296f19b49a53daeee7f6074d83267e5d67b46b55bf7a7dd177ea919081900360200190a261054e84826107a0565b50505050565b60408051808201909152600e81527f447265616d506f7420546f6b656e000000000000000000000000000000000000602082015281565b60025490565b600081565b60065481565b6105a46106ae565b15156105af57600080fd5b600655565b600160a060020a031660009081526001602052604090205490565b6105d76106ae565b15156105e257600080fd5b60008054604051600160a060020a03909116907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0908390a36000805473ffffffffffffffffffffffffffffffffffffffff19169055565b6106416106ae565b151561064c57600080fd5b600160a060020a038116151561066157600080fd5b6005805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b600554600160a060020a031681565b600054600160a060020a031690565b600054600160a060020a0316331490565b60408051808201909152600381527f4450540000000000000000000000000000000000000000000000000000000000602082015281565b600354600160a060020a031681565b600061071233848461084c565b5060015b92915050565b600454600160a060020a031681565b6107336106ae565b151561073e57600080fd5b61074781610940565b50565b600080821161075857600080fd5b6000828481151561076557fe5b04949350505050565b600082151561077f57506000610716565b82820282848281151561078e57fe5b041461079957600080fd5b9392505050565b600160a060020a03821615156107b557600080fd5b6002546107c8908263ffffffff6109bd16565b600255600160a060020a0382166000908152600160205260409020546107f4908263ffffffff6109bd16565b600160a060020a03831660008181526001602090815260408083209490945583518581529351929391927fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef9281900390910190a35050565b600160a060020a038216151561086157600080fd5b600160a060020a03831660009081526001602052604090205481111561088657600080fd5b600160a060020a0383166000908152600160205260409020546108af908263ffffffff6109cf16565b600160a060020a0380851660009081526001602052604080822093909355908416815220546108e4908263ffffffff6109bd16565b600160a060020a0380841660008181526001602090815260409182902094909455805185815290519193928716927fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef92918290030190a3505050565b600160a060020a038116151561095557600080fd5b60008054604051600160a060020a03808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a36000805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b60008282018381101561079957600080fd5b6000828211156109de57600080fd5b5090039056fea165627a7a723058205d103d810f9ad4457958aa6ad15f061ee1d6459fa5af1efb5464a513997f317d0029"
}