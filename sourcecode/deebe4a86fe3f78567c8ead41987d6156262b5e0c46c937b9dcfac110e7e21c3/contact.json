{
  "address": "0x26135e15482b65845418e084f614bd340ddb3b8a",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "LikeChainRelayLogic",
  "compilerVersion": "v0.4.25+commit.59dbf8f1",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2019-04-16\n*/\n\n//    Copyright (C) 2018 LikeCoin Foundation Limited\n//\n//    This file is part of LikeCoin Smart Contract.\n//\n//    LikeCoin Smart Contract is free software: you can redistribute it and/or modify\n//    it under the terms of the GNU General Public License as published by\n//    the Free Software Foundation, either version 3 of the License, or\n//    (at your option) any later version.\n//\n//    LikeCoin Smart Contract is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//    GNU General Public License for more details.\n//\n//    You should have received a copy of the GNU General Public License\n//    along with LikeCoin Smart Contract.  If not, see <http://www.gnu.org/licenses/>.\n\n// Introduction\n// \n// This smart contract (the Relay contract) acts as the gateway between LikeChain and Ethereum.\n// When LikeCoin is transferred into this smart contract, the Transfer event will be received by the\n// background services of LikeChain, which will then fire corresponding Deposit transaction onto\n// LikeChain through Tendermint, minting LikeCoin on LikeChain.\n// When someone withdraw on LikeChain, it will create a record in the Merkle tree in LikeChain.\n// The Merkle root of the tree will be committed onto this smart contract periodically. Then, the user\n// (or operators of LikeChain, or other third-parties) can commit the Merkle proof to prove that there\n// exists such a withdraw record, releasing the LikeCoin previously transferred and locked in this contract.\n//\n// The main flow is as follows:\n// 1. Someone calls commitWithdrawHash with a payload containing votes, app hash, Merkle proof, etc.\n// 2. The contract checks if the votes from the validators are valid.\n// 3. The contract extracts block hash from the votes.\n// 4. The contract checks if the app hash is in the block hash by validating the Merkle proof.\n// 5. If everything are fine, the contract extracts the withdraw hash from app hash.\n// 6. When someone calls withdraw, the contract checks the Merkle proof from the call data to see if\n//    the withdraw data is actually in the Merkle tree of the withdraw hash committed previously.\n// 7. After checking, the contract transfers LikeCoin according to the withdraw info.\n// \n//\n// Tendermint sign bytes format:\n// Tendermint runs using BFT algorithms. Every block produced is signed by >2/3 of validators before\n// being a valid block.\n// The signatures are signed on the SHA-256 hash of the \"sign bytes\" of the vote. Therefore the contract\n// needs to reconstruct the sign bytes before validating the signatures.\n// The sign bytes in the votes starting from Tendermint v0.26 is changed to amino encoding.\n// The structure and field-order is as follows:\n//\n// type CanonicalVote struct {\n//     Type      SignedMsgType // type alias for byte\n//     Height    int64         `binary:\"fixed64\"`\n//     Round     int64         `binary:\"fixed64\"`\n//     Timestamp time.Time\n//     BlockID   CanonicalBlockID\n//     ChainID   string\n// }\n// \n// type CanonicalBlockID struct {\n//     Hash        cmn.HexBytes\n//     PartsHeader CanonicalPartSetHeader\n// }\n// \n// type CanonicalPartSetHeader struct {\n//     Hash  cmn.HexBytes\n//     Total int\n// }\n//\n// (cmn.HexBytes is defined as []byte)\n//\n// Type is encoded into one single byte.\n// Height and Round are encoded as 64-bit fixed-length integers, in little endian.\n// Timestamp is specially handled as a struct roughly as follows:\n//\n// type Time struct {\n//     Second int64 // Varint\n//     Nanosecond int32 // Varint, ranged from 0 to 999,999,999\n// }\n//\n// Varint encoding: (see https://developers.google.com/protocol-buffers/docs/encoding#varints)\n// \n// Varint is used a lot in amino, so we will first explain the encoding of varint.\n// In a varint, only the last 7 bits of a byte is used as the encoding of the integer.\n// The first bit indicates whether the varint still has succeeding bytes.\n// For example: 10111011 11011000 10111101 00101011\n// The first byte is 10111011. The value part is 0111011. Since the first bit is 1, we still need other bytes.\n// The second byte is 11011000. The value part is 1011000. Since the first bit is 1, we still need other bytes.\n// The third byte is 10111101. The value part is 0111101. Since the first bit is 1, we still need other bytes.\n// The fourth byte is 00101011. The value part is 0101011. Since the first bit is 0, this is the end of this varint.\n// So the value of the varint will be 0111011 1011000 0111101 0101011 reversed and concatenated, which is 91188283 in decimals.\n// \n// \n// In amino, structs are serialized into binary in a way similar to Protobuf.\n// Basically, it is a key-value structure, where the key is the index of the field in the struct (starting from 1),\n// encoeded as varint.\n// For example, in CanonicalVote, Type has field index 1, Height has 2, etc. So the encoding could be decoded as a mapping:\n// {\n//     Field 1 => Type 2,\n//     Field 2 => Height 1337,\n//     Field 3 => Round 2345,\n//     Field 4 => {\n//         Field 1 => 1234 Seconds,\n//         Field 2 => 5678 Nanoseconds\n//     },\n//     ...\n// }\n//\n// If a field has default value (e.g. 0 in numbers), amino will not encode that field by default.\n// Amino encodes the fields in sequential order.\n//\n// Typ3: (see https://developers.google.com/protocol-buffers/docs/encoding#structure)\n// In addition to field index, 3 bits (called Typ3) are used in the key to indicate the length of the value:\n//\n// 0 - the field itself is a varint\n// 1 - fixed 8-byte length\n// 2 - Length prefixed (using varint)\n// 5 - fixed 4-byte length (not used in CanonicalVote)\n//\n// For example, the Type field has field index 1, and it is encoded as varint.\n// Therefore the key will be 00001|000 (Field 1, Typ3 0) = 0x08.\n// The Height field has field index 2, and it is encoded as 8 byte fixed length integer.\n// Therefore the key will be 00010|001 (Field 2, Typ3 1) = 0x11.\n// The Timestamp field has field index 4, and it is variable length.\n// Therefore the key will be 00100|010 (Field 4, Typ3 2) = 0x22.\n// Timestamp will be encoded in a length-prefixed format. Therefore if the length of the encoded value of\n// the timestamp is 14, then 14 will appear right after 0x22.\n//\n// Below is an example of sign bytes:\n// \n// 0x760802110200000000000000220C08E881CADF0510E8A9E088032A480A2042288B2C20A42426A9E80F2B6D7BAA7DCEC8F7DC5B63FF5360CE8B9B7C78B5DE12240A2052F24411779931CCF793D9C222B48EFB63C034CCACBB336B655FCB3F331EBCF310013211746573742D636861696E2D77467A62616B\n// \n// which is disassembled below:\n//\n// 76 # length of the sign bytes (in varint, not including the length field itself), which is 0x76 = 118 bytes\n//     08 # 00001000 = 00001|000 = Field 1 (Type), Typ3 0 (varint)\n//         02 # value of Type field = 2\n//     11 # 00010001 = 00010|001 = Field 2 (Height), Typ3 1 (8 bytes)\n//         0200000000000000 # value of Height field (in int64, little endian) = 2\n//     22 # 00100010 = 00100|010 = Field 4 (Timestamp), Typ3 2 (length prefixed) (note that Field 3 (Round) is missing, hence the value is default value, which is 0)\n//         0C # length of the Timestamp field = 0x0C = 12\n//             08 # 00001000 = 00001|000 = Field 1 (Timestamp.Second), Typ3 0 (varint)\n//                 E881CADF05 # value of the Timestamp.Second field = 11101000 10000001 11001010 11011111 00000101, actual value = 0000101 1011111 1001010 0000001 1101000 = 1542619368\n//             10 # 00010000 = 00010|000 = Field 2 (Timestamp.Nanosecond), Typ3 0 (varint)\n//                 E8A9E08803 # value of the Timestamp.Nanosecond field = 11101000 10101001 11100000 10001000 00000011, actual value = 0000011 0001000 1100000 0101001 1101000 = 823661800\n//     2A # 00101010 = 00101|010 = Field 5 (BlockID), Typ3 2 (length prefixed)\n//         48 # length of the BlockID field = 0x48 = 72\n//             0A # 00001010 = 00001|010 = Field 1 (BlockID.Hash), Typ3 2 (length prefixed)\n//                 20 # length of the BlockID.Hash field = 0x20 = 32\n//                     42288B2C20A42426A9E80F2B6D7BAA7DCEC8F7DC5B63FF5360CE8B9B7C78B5DE # Value of the BlockID.Hash field\n//             12 # 00010010 = 00010|010 = Field 2 (BlockID.PartsHeader), Typ3 2 (length prefixed)\n//                 24 # length of the BlockID.Hash field = 0x24 = 36\n//                     0A # 00001010 = 00001|010 = Field 1 (BlockID.PartsHeader.Hash), Typ3 2 (length prefixed)\n//                         20 # length of the BlockID.PartsHeader.Hash field = 0x20 = 32\n//                             52F24411779931CCF793D9C222B48EFB63C034CCACBB336B655FCB3F331EBCF3 # Value of the BlockID.PartsHeader.Hash field\n//                     10 # 00010000 = 00010|000 = Field 2 (BlockID.PartsHeader.Total), Typ3 0 (varint)\n//                         01 # value of BlockID.PartsHeader.Total field = 1\n//     32 # 00110010 = 00110|010 = Field 6 (ChainID), Typ3 2 (length prefixed)\n//         11 # length of the ChainID field = 0x11 = 17\n//             746573742D636861696E2D77467A62616B # value of the ChainID field = \"test-chain-wFzbak\"\n//\n// A few points to note:\n// 1. Every field except the Timestamp field in the sign bytes should be the same among all the votes of the validators on the same block number\n// 2. Timestamp has varint, therefore could affect the length of the sign bytes, and also the offsets of the fields afterwards\n// 3. After confirming the offset of the BlockID part, the offset of t he block hash could also be confirmed, since every hash has fixed length 32\n//\n// Application hash:\n// In Tendermint, the application logic is defined by developer. The state of the application is reported\n// to Tendermint by application hash (app hash).\n// LikeChain defines the app hash as the concatenation of 2 hashes: withdraw hash and state hash.\n// Withdraw hash is the Merkle root of a tree containing info which the Relay contract should know.\n// State hash is the Merkle root of the tree containing the remaining states.\n// The reason of splitting them into 2 trees is to reduce the length of Merkle proof when doing withdraw.\n// \n// The app hash will be in the block header of a block. The fields in the block header will be aggregated\n// into a simple Merkle tree, which the tree root will be the block hash. Therefore we can use a Merkle proof\n// to prove that the app hash is really inside the header with specific block hash.\n//\n// Details could be found at https://github.com/tendermint/tendermint/blob/master/types/block.go#L388\n//\n//\n// Payload encoding to the contract:\n// The encoding of the votes onto the contract is as follows:\n// 1. the Height and Round are passed onto the contract by function parameters directly\n// 2. the remaining parts are encoded into a big bytes\n// 3. by the Height and Round, we can construct the parts before Timestamp (Type is fixed as 2)\n// 4. for every validators in this block, Timestamp and the signature is encoded\n// 5. the remaining parts after Timestamp (called \"suffix\") is encoded\n// 6. the Merkle proof for proving the app hash in the block hash is encoded\n//\n// The structure is like this:\n//\n// type AppHashContractProof struct {\n// \tHeight     uint64\n// \tRound      uint64\n// \tPayload struct {\n// \t\tSuffixLen  uint8\n// \t\tSuffix     []byte\n// \t\tVotesCount uint8\n// \t\tVotes      []struct {\n// \t\t\tTimeLen uint8\n// \t\t\tTime    []byte\n// \t\t\tSig     [65]byte\n// \t\t}\n// \t\tAppHashLen   uint8\n// \t\tAppHash      []byte\n// \t\tAppHashProof [4][32]byte\n// \t}\n// }\n//\n// We assume that the total length of the sign bytes are <= 127, so uint8 could be used as varint prefix.\n// The length restriction could be calculated as follows:\n//\n// Type: 1 byte field number + 1 byte value = 2 bytes\n// Height: 1 byte field numnber + 8 bytes value = 9 bytes\n// Round: 1 byte field numnber + 8 bytes value = 9 bytes\n// Timestamp: 1 byte field numnber + 1 byte length +\n//           1 byte field number + 6 bytes varint second (at most 43 bits, enough for ~278,731 years since 1970) +\n//           1 byte field number + 5 bytes varint nanosecond (at most 36 bits, enough since maximum value is 999,999,999, which is < 2^36)\n// = 15 bytes\n// BlockID: 1 byte field numnber + 1 byte length +\n//              1 byte field number + 1 byte length + 32 bytes value +\n//              1 byte field number + 1 bytes length +\n//                  1 byte field number + 1 byte length + 32 byte value +\n//                  1 byte field number + 1 byte value\n// = 74 bytes\n// ChainID: 1 byte field numnber + 1 byte length + n bytes value = (n + 2) bytes\n// Total = 111 + n bytes\n// \n// So we have 111 + n <= 127, which means ChainID should have length <= 16.\n// In practice, Timestamp is shorter than the maximum (until ~year 4140), and Round usually have default value 0,\n// therefore the restriction is not that strict, but should still be considered.\n//\n//\n//  \n// IAVL RangeProof:\n// In IAVL tree, RangeProof is used to prove that a range of values (\"sibling\" leaves) are inside the tree.\n// It is also possible to prove that a value is absent in the tree, by proving a range is in the tree and the\n// value should appear in that range if it is present.\n// In this contract, we are only using RangeProof with only one leaf.\n//\n// The definition of RangeProof struct is as follows:\n// (See https://github.com/tendermint/iavl/blob/master/proof_range.go#L216 for source code)\n//\n// type RangeProof struct {\n// \t// You don't need the right path because\n// \t// it can be derived from what we have.\n// \tLeftPath   PathToLeaf      `json:\"left_path\"`\n// \tInnerNodes []PathToLeaf    `json:\"inner_nodes\"`\n// \tLeaves     []proofLeafNode `json:\"leaves\"`\n//\n// \t// memoize\n// \trootVerified bool\n// \trootHash     []byte // valid iff rootVerified is true\n// \ttreeEnd      bool   // valid iff rootVerified is true\n//\n// }\n//\n// type PathToLeaf []proofInnerNode\n//\n// type proofInnerNode struct {\n// \tHeight  int8   `json:\"height\"`\n// \tSize    int64  `json:\"size\"`\n// \tVersion int64  `json:\"version\"`\n// \tLeft    []byte `json:\"left\"`\n// \tRight   []byte `json:\"right\"`\n// }\n//\n// type proofLeafNode struct {\n// \tKey       cmn.HexBytes `json:\"key\"`\n// \tValueHash cmn.HexBytes `json:\"value\"`\n// \tVersion   int64        `json:\"version\"`\n// }\n//\n// In case of there is only one leaf in the RangeProof, InnerNodes will be empty and Leaves will only contain one node.\n// In this case, the procedure of computing root hash is as follows:\n// \n// 1. Encode leaf node in binary.\n//   1.1. Encode Height (0) as int8 (one single byte).\n//   1.2. Encode Size (1) as varint.\n//        (note that it is an integer, which could be negative, and is encoded in zigzag encoding in varint, so positive\n//        number n will be encoded as 2n, i.e. 0x02 is used for encoding 1)\n//   1.3. Encode Version as varint.\n//   1.4. Encode Key by prefixing length in varint, then encode the bytes.\n//   1.5. Encode ValueHash by prefixing length in varint, then encode the bytes.\n// 2. Hash the encoded binary by SHA-256 to get current hash.\n// 3. Repeatedly mix inner nodes (from bottom to up) into current hash to update current hash, until reaching the top.\n//   3.1. Encode Height as int8 (one single byte).\n//   3.2. Encode Size as varint.\n//   3.3. Encode Version as varint.\n//   3.4. Encode current hash and one of Left or Right. (One of Left or Right must be empty)\n//     3.4.1. If Left is empty, then first encode current hash (prefix length), then encode Right (prefix length).\n//     3.4.2. If Right is empty, then first encode Left (prefix length), then encode current hash (prefix length).\n//\n// Payload encoding to the contract:\n// The proof has 2 parts: leaf and inner nodes.\n// For leaf, only the version is needed. However, since it is varint, we also need to know the length of the version field.\n// For inner nodes, we need to know all the info, plus whether current hash should be Left or Right, to decide the hashing order.\n// There we need to encode the followings:\n//\n// 1. Length of leaf Version\n// 2. Leaf version\n// 3. Number of inner nodes\n// 4. Inner nodes\n//   4.1. Length of all the parts except Left or Right. This part is called \"prefix\".\n//   4.2. One bit for indicating whether current hash should be Left or Right.\n//   4.3. The prefix\n//   4.4. The Left or Right in the inner node. This is called \"sibling\".\n//\n// Further investigation shows that the prefix part of inner nodes will never exceed 127 bytes.\n// Therefore the \"one bit\" is encoded together with the prefix length.\n// The final format is as follows:\n//\n// type ContractIAVLTreeProof struct {\n// \tVersionLength    uint8\n// \tLeafVersionBytes []byte\n// \tPathLength       uint8\n// \tPath             []struct {\n// \t\tPrefixLengthAndOrder uint8 // first bit indicates the node is left or right\n// \t\tPrefix               []byte\n// \t\tSibling              []byte\n// \t}\n// }\n\n\n\n\n\n\npragma solidity ^0.4.25;\n\n// Source: https://github.com/OpenZeppelin/openzeppelin-solidity/blob/5471fc808a17342d738853d7bf3e9e5ef3108074/contracts/token/ERC20/IERC20.sol\n// Copied here to avoid incompatibility with Solidity v0.5.x in latest master branch\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address who) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\ncontract LikeChainRelayLogicInterface {\n    function commitWithdrawHash(uint64 height, uint64 round, bytes _payload) public;\n    function updateValidator(address[] _newValidators, bytes _proof) public;\n    function withdraw(bytes _withdrawInfo, bytes _proof) public;\n    function upgradeLogicContract(address _newLogicContract, bytes _proof) public;\n    event Upgraded(uint256 _newLogicContractIndex, address _newLogicContract);\n}\n\ncontract LikeChainRelayState {\n    uint256 public logicContractIndex;\n    address public logicContract;\n\n    IERC20 public tokenContract;\n\n    address[] public validators;\n    \n    struct ValidatorInfo {\n        uint8 index;\n        uint32 power;\n    }\n    \n    mapping(address => ValidatorInfo) public validatorInfo;\n    uint256 public totalVotingPower;\n    uint public lastValidatorUpdateTime;\n\n    uint public latestBlockHeight;\n    bytes32 public latestWithdrawHash;\n\n    mapping(bytes32 => bool) public consumedIds;\n    mapping(bytes32 => bytes32) public reserved;\n}\n\ncontract LikeChainRelayLogic is LikeChainRelayState, LikeChainRelayLogicInterface {\n    constructor(address[] _validators, uint32[] _votingPowers, address _tokenContract) public {\n        uint len = _validators.length;\n        require(len > 0);\n        require(len < 256);\n        require(_votingPowers.length == len);\n\n        for (uint8 i = 0; i < len; i += 1) {\n            address v = _validators[i];\n            require(validatorInfo[v].power == 0);\n            uint32 power = _votingPowers[i];\n            require(power > 0);\n            validators.push(v);\n            validatorInfo[v] = ValidatorInfo({\n                index: i,\n                power: power\n            });\n            totalVotingPower += power;\n        }\n        \n        tokenContract = IERC20(_tokenContract);\n    }\n    \n    function _proofRootHash(bytes32 _key, bytes32 _value, bytes _proof) internal view returns (bytes32 rootHash) {\n        assembly {\n            let start := mload(0x40)\n            let p := start\n            let curHashStart := add(start, 128)\n            let data := add(_proof, 33) // 32 byte length + 1 byte reserved\n            \n            let len := and(mload(sub(data, 31)), 0xff) // version length\n            if gt(len, 9) { revert(0, 0) } // version is uint64, so the varint encoded should never longer than 9 bytes\n            data := add(data, 1)\n            mstore(p, hex\"0002\")\n            p := add(p, 2)\n            mstore(p, mload(data))\n            data := add(data, len)\n            p := add(p, len)\n            mstore8(p, 32) // amino length-prefixed encoding for []byte (length 32)\n            p := add(p, 1)\n            mstore(p, _key)\n            p := add(p, 32)\n            mstore8(p, 32) // amino length-prefixed encoding for []byte (length 32)\n            p := add(p, 1)\n            mstore(p, _value)\n            p := add(p, 32)\n            let _ := staticcall(gas, 2, start, sub(p, start), curHashStart, 32)\n            \n            len := and(mload(sub(data, 31)), 0xff) // number of path nodes\n            data := add(data, 1)\n            for { let i := len } gt(i, 0) { i := sub(i, 1) } {\n                p := start\n                len := and(mload(sub(data, 31)), 0xff) // 1 bit left-right indicator, 7 bits length\n                let order := and(len, 0x80)\n                len := and(len, 0x7f)\n                if gt(len, 19) { revert(0, 0) } // 1-byte height (< 128) + 9-byte 64-bit varint-encoded numbers * 2\n                data := add(data, 1)\n                mstore(p, mload(data))\n                p := add(p, len)\n                data := add(data, len)\n                switch order\n                case 0 {\n                    mstore8(p, 32) // amino length-prefixed encoding for []byte\n                    p := add(p, 1)\n                    mstore(p, mload(curHashStart))\n                    p := add(p, 32)\n                    mstore8(p, 32) // amino length-prefixed encoding for []byte\n                    p := add(p, 1)\n                    mstore(p, mload(data))\n                    p := add(p, 32)\n                } default {\n                    mstore8(p, 32) // amino length-prefixed encoding for []byte\n                    p := add(p, 1)\n                    mstore(p, mload(data))\n                    p := add(p, 32)\n                    mstore8(p, 32) // amino length-prefixed encoding for []byte\n                    p := add(p, 1)\n                    mstore(p, mload(curHashStart))\n                    p := add(p, 32)\n                }\n                data := add(data, 32)\n                _ := staticcall(gas, 2, start, sub(p, start), curHashStart, 32)\n            }\n            len := mload(_proof)\n            if gt(sub(data, add(_proof, 32)), len) {\n                revert(0, 0)\n            }\n            rootHash := mload(curHashStart)\n        }\n        return rootHash;\n    }\n    \n    // See https://tendermint.com/docs/spec/blockchain/blockchain.html#lastcommit\n    function commitWithdrawHash(uint64 height, uint64 round, bytes _payload) public {\n        // Memory layout:\n        // 0..127: sign bytes\n        // 128..: temporary storage e.g. computing mapping storage position by hash, recovering address\n        assembly {\n            // The n bytes are at the beginning of a 32-byte word, with zeros following\n            function getNByte(p, n) -> bs {\n                if gt(n, 32) {\n                    revert(0, 0)\n                }\n                let numberOfOnes := mul(n, 8)\n                let numberOfZeros := sub(256, numberOfOnes)\n                // mask == 111111...11100000...000, with (8*n) 1s and (256 - 8*n) 0s\n                let mask := 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n                mask := xor(mask, sub(exp(2, numberOfZeros), 1))\n                bs := and(mload(p), mask)\n            }\n            \n            // The byte is at the end of a 32-byte word\n            function getOneByte(p) -> b {\n                // b := and(mload(sub(p, 31)), 0xFF)\n                b := byte(0, mload(p))\n            }\n            \n            // Takes the height and round, reconstruct the prefix part of the amino-encoded sign bytes,\n            // which contains type (0x02), height, round\n            function reconstructPrefix(p, height, round) -> next {\n                mstore8(p, 0x00) // place-holder for length prefix\n                p := add(p, 1)\n                mstore8(p, 0x08) // field number for `type`\n                p := add(p, 1)\n                mstore8(p, 0x02) // value for `precommit` type\n                p := add(p, 1)\n                if gt(height, 0) {\n                    mstore8(p, 0x11) // field number for `height`\n                    p := add(p, 1)\n                    for { let i := 0 } lt(i, 8) { i := add(i, 1) } {\n                        mstore8(p, mod(height, 0x100))\n                        height := div(height, 0x100)\n                        p := add(p, 1)\n                    }\n                }\n                if gt(round, 0) {\n                    mstore8(p, 0x19) // field number for `round`\n                    p := add(p, 1)\n                    for { let i := 0 } lt(i, 8) { i := add(i, 1) } {\n                        mstore8(p, mod(round, 0x100))\n                        height := div(round, 0x100)\n                        p := add(p, 1)\n                    }\n                }\n                next := p\n            }\n            \n            function extractBlockHash(suffix) -> blockHash {\n                blockHash := mload(add(suffix, 4))\n            }\n            \n            // Note that copy is done in words, so the last word may overwrite some bytes\n            function memcpy(dst, src, len) {\n                let dstEnd := add(dst, len)\n                for { } lt(dst, dstEnd) { dst := add(dst, 32) src := add(src, 32) } {\n                    mstore(dst, mload(src))\n                }\n            }\n            \n            // 1. copy `timeLength` bytes from `timeSource` to `timeStart`\n            // 2. copy `suffixLength` bytes from `suffixSource` to the location next to time\n            // 3. calculate the total length of the content and write to starting position\n            function reconstructSignBytes(p, timeStart, time, timeLen, suffixSrc, suffixLen) -> end {\n                let start := p\n                mstore(timeStart, time)\n                p := add(timeStart, timeLen)\n                memcpy(p, suffixSrc, suffixLen)\n                end := add(p, suffixLen)\n                let len := sub(end, add(start, 1))\n                mstore8(start, len)\n            }\n            \n            function getVoter(p, timeStart, suffixSrc, suffixLen) -> voter, next {\n                let msgStart := mload(0x40)\n                let timeLen := getOneByte(p)\n                if gt(timeLen, 15) { revert(0, 0) }\n                p := add(p, 1)\n                let time := getNByte(p, timeLen)\n                p := add(p, timeLen)\n                let msgEnd := reconstructSignBytes(msgStart, timeStart, time, timeLen, suffixSrc, suffixLen)\n                \n                // ecrecover precompiled contract\n                // Contract address: 1\n                // Input: bytes32 hash, uint v, bytes32 r, bytes32 s\n                // Output: address signer\n\n                let buf := add(msgStart, 128)\n                let _ := staticcall(gas, 2, msgStart, sub(msgEnd, msgStart), buf, 32) // SHA-256 hash, at buf[0:32]\n                mstore(add(buf, 32), getOneByte(p)) // v at buf[32:64]\n                p := add(p, 1)\n                mstore(add(buf, 64), mload(p)) // r at buf[64:96]\n                p := add(p, 32)\n                mstore(add(buf, 96), mload(p)) // s at buf[96:128]\n                p := add(p, 32)\n                let succ := staticcall(gas, 1, buf, 128, buf, 32)\n                if iszero(succ) {\n                    revert(0, 0)\n                }\n                voter := mload(buf)\n                next := p\n            }\n            \n            // For layout of mapping, see\n            // https://solidity.readthedocs.io/en/v0.4.24/miscellaneous.html#layout-of-state-variables-in-storage\n            function getVoterInfo(addr) -> index, power {\n                let buf := add(mload(0x40), 128)\n                mstore(buf, addr)\n                mstore(add(buf, 32), validatorInfo_slot)\n                let slot := keccak256(buf, 64)\n                let votingInfo := sload(slot)\n                if eq(votingInfo, 0) {\n                    revert(0, 0)\n                }\n                index := and(votingInfo, 0xFF)\n                power := and(div(votingInfo, 0x100), 0xFFFFFFFF)\n            }\n            \n            function accumulateVoterPower(voter, votedSet, power) -> newVotedSet, newPower {\n                let voterIndex, voterPower := getVoterInfo(voter)\n                let mask := exp(2, voterIndex)\n                if iszero(eq(0, and(votedSet, mask))) {\n                    revert(0, 0)\n                }\n                newVotedSet := or(votedSet, mask)\n                newPower := add(power, voterPower)\n            }\n            \n            function checkVotes(p, height, round) -> blockHash, next {\n                let votedSet := 0\n                let voterPower := 0\n                \n                let suffixLen := getOneByte(p)\n                if gt(suffixLen, 92) { revert(0, 0) }\n                p := add(p, 1)\n                let suffixSrc := p\n                p := add(p, suffixLen)\n                blockHash := extractBlockHash(suffixSrc)\n                \n                let msgStart := mload(0x40)\n                let timeStart := reconstructPrefix(msgStart, height, round)\n                \n                let votesCount := getOneByte(p)\n                p := add(p, 1)\n                for {} gt(votesCount, 0) { votesCount := sub(votesCount, 1) } {\n                    let voter\n                    voter, p := getVoter(p, timeStart, suffixSrc, suffixLen)\n                    votedSet, voterPower := accumulateVoterPower(voter, votedSet, voterPower)\n                }\n                // Need strictly more than 2/3 of total voting power\n                if iszero(gt(mul(voterPower, 3), mul(sload(totalVotingPower_slot), 2))) {\n                    revert(0, 0)\n                }\n                next := p\n            }\n            \n            // The blockHash is the Merkle root of 16 fields (including AppHash) in the block header.\n            // Therefore we can use a Merkle proof to prove the appHash is in the block header.\n            // The Merkle root is computed as follows:\n            // 1. Each field is amino-encoded into a []byte. For []byte, it is done by prefixing len(bs).\n            // 2. The resulting []byte will be hashed again to get a leaf node in the Merkle tree.\n            // 3. Each pair of leaf nodes are amino-encoded and concated, then hashed into the parent of these 2 nodes.\n            // 4. Repeat the process until reaching the root, which will be blockHash.\n            //\n            // So to verify the Merkle proof of the \"App\" field, the contract needs to:\n            // 1. hash \"\\x{appHashLen}{appHashLen-byte-appHash}\" to get the leaf node for AppHash\n            // 2. Hash \"\\x20{leaf-node}\\x20{proof-1}\" to get new leaf node.\n            // 3. Hash \"\\x20{leaf-node}\\x20{proof-2}\" to get new leaf node.\n            // 4. Hash \"\\x20{proof-3}\\x20{leaf-node}\" to get new leaf node.\n            // 5. Hash \"\\x20{proof-4}\\x20{leaf-node}\" to get root hash.\n            // 6. Check if the root hash equals to blockHash\n            //\n            // Then the first 32 bytes of the AppHash will be extracted as the withdrawHash.\n            function extractAndProofWithdrawHash(p, blockHash) -> withdrawHash {\n                let buf := mload(0x40)\n                let aminoEncodedAppHashLen := add(getOneByte(p), 1)\n                // No need to `p := add(p, 1)`, as the amino-encoded appHash needs length prefix\n                memcpy(buf, p, aminoEncodedAppHashLen)\n                withdrawHash := mload(add(p, 1))\n                p := add(p, aminoEncodedAppHashLen)\n                \n                let left := add(buf, 1)\n                let right := add(buf, 34)\n                // 1. hash \"\\x{appHashLen}{appHashLen-byte-appHash}\" to get the leaf node for AppHash\n                let _ := staticcall(gas, 2, buf, aminoEncodedAppHashLen, left, 32)\n                // 2. Hash \"\\x20{leaf-node}\\x20{proof-1}\" to get new leaf node.\n                mstore8(sub(left, 1), 32)\n                mstore8(sub(right, 1), 32)\n                mstore(right, mload(p))\n                p := add(p, 32)\n                _ := staticcall(gas, 2, buf, 66, left, 32)\n                // 3. Hash \"\\x20{leaf-node}\\x20{proof-2}\" to get new leaf node.\n                mstore(right, mload(p))\n                p := add(p, 32)\n                _ := staticcall(gas, 2, buf, 66, right, 32)\n                // 4. Hash \"\\x20{proof-3}\\x20{leaf-node}\" to get new leaf node.\n                mstore(left, mload(p))\n                p := add(p, 32)\n                _ := staticcall(gas, 2, buf, 66, right, 32)\n                // 5. Hash \"\\x20{proof-4}\\x20{leaf-node}\" to get root hash.\n                mstore(left, mload(p))\n                p := add(p, 32)\n                _ := staticcall(gas, 2, buf, 66, buf, 32)\n                // 6. Check if the root hash equals to blockHash\n                if iszero(eq(blockHash, mload(buf))) {\n                    revert(0, 0)\n                }\n            }\n            \n            if iszero(gt(height, sload(latestBlockHeight_slot))) {\n                revert(0, 0)\n            }\n            let blockHash\n            let p := add(_payload, 32)\n            blockHash, p := checkVotes(p, height, round)\n            let withdrawHash := extractAndProofWithdrawHash(p, blockHash)\n            sstore(latestBlockHeight_slot, height)\n            sstore(latestWithdrawHash_slot, withdrawHash)\n        }\n    }\n\n    // In the IAVL tree, the key is the hash of the withdraw information ({ from, to, value, fee, nonce }) and the value is\n    // 0x01 (only as an indicator of key existence). Therefore the proving process is as follows:\n    // 1. reconstruct key from { from, to, value, fee, nonce }\n    // 2. pack lead node: [0, 1, leafVersionBytes, key, sha256(0x01)]\n    //    (Note that the `1` is encoded as signed varint, so is 0x02 in binary. See line 275 for details)\n    // 3. hash packed output to get current hash\n    // 4. repeat the followings:\n    //    1. extract prefixBytes and suffixBytes\n    //    2. pack [prefixBytes, currentHash, suffixBytes]\n    //    3. hash packed output and update current hash\n    // 5. output current hash as root hash\n    // 6. check if root hash from the proof is equal to the withdraw hash recorded previously from commitWithdrawHash\n    \n    function _proofAndExtractWithdraw(bytes _withdrawInfo, bytes _proof) internal returns (address to, uint256 value, uint256 fee) {\n        bytes32 id = sha256(_withdrawInfo);\n        require(!consumedIds[id]);\n        consumedIds[id] = true;\n        bytes32 proofValueHash = hex\"4bf5122f344554c53bde2ebb8cd2b7e3d1600ad631c385a5d7cce23c7785459a\"; // sha256 of hex\"01\"\n        bytes32 rootHash = _proofRootHash(id, proofValueHash, _proof);\n        require(rootHash == latestWithdrawHash);\n        assembly {\n            to := mload(add(_withdrawInfo, 40))\n            value := mload(add(_withdrawInfo, 72))\n            fee := mload(add(_withdrawInfo, 104))\n        }\n        return (to, value, fee);\n    }\n\n    function withdraw(bytes _withdrawInfo, bytes _proof) public {\n        address to;\n        uint256 value;\n        uint256 fee;\n        (to, value, fee) = _proofAndExtractWithdraw(_withdrawInfo, _proof);\n        tokenContract.transfer(msg.sender, fee);\n        tokenContract.transfer(to, value);\n    }\n\n    function updateValidator(address[] _newValidators, bytes _proof) public {\n        // TODO\n    }\n    \n    // 1. reconstruct key by the format sha256(\"exec{big-endian encoded 64-bit contract index})\"\n    // 2. get value hash by sha256(contract address)\n    // 3. prove that the key-value pair is in withdraw tree\n    // 4. update the contract and contract index\n    function upgradeLogicContract(address _newLogicContract, bytes _proof) public {\n        logicContractIndex += 1;\n        bytes12 keyBeforeHash = bytes12(uint96(bytes12(\"exec\")) | uint96(logicContractIndex));\n        bytes32 key = sha256(abi.encodePacked(keyBeforeHash));\n        bytes32 proofValueHash = sha256(abi.encodePacked(_newLogicContract));\n        bytes32 rootHash = _proofRootHash(key, proofValueHash, _proof);\n        require(rootHash == latestWithdrawHash);\n        logicContract = _newLogicContract;\n        emit Upgraded(logicContractIndex, _newLogicContract);\n    }\n}",
  "abi": "[{\"constant\":false,\"inputs\":[{\"name\":\"_newValidators\",\"type\":\"address[]\"},{\"name\":\"_proof\",\"type\":\"bytes\"}],\"name\":\"updateValidator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"validators\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"latestWithdrawHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"validatorInfo\",\"outputs\":[{\"name\":\"index\",\"type\":\"uint8\"},{\"name\":\"power\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_withdrawInfo\",\"type\":\"bytes\"},{\"name\":\"_proof\",\"type\":\"bytes\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastValidatorUpdateTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalVotingPower\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLogicContract\",\"type\":\"address\"},{\"name\":\"_proof\",\"type\":\"bytes\"}],\"name\":\"upgradeLogicContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"reserved\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"height\",\"type\":\"uint64\"},{\"name\":\"round\",\"type\":\"uint64\"},{\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"commitWithdrawHash\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"logicContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"logicContractIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"consumedIds\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"latestBlockHeight\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_validators\",\"type\":\"address[]\"},{\"name\":\"_votingPowers\",\"type\":\"uint32[]\"},{\"name\":\"_tokenContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_newLogicContractIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newLogicContract\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"}]",
  "bytecode": "608060405234801561001057600080fd5b5060405161114738038061114783398101604090815281516020830151918301519083018051909392909201916000808080841161004d57600080fd5b610100841061005b57600080fd5b8551841461006857600080fd5b600092505b838360ff1610156101ad57868360ff1681518110151561008957fe5b6020908102909101810151600160a060020a0381166000908152600490925260409091205490925063ffffffff61010090910416156100c757600080fd5b858360ff168151811015156100d857fe5b602090810290910101519050600063ffffffff8216116100f757600080fd5b6003805460018082019092557fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b018054600160a060020a031916600160a060020a03851690811790915560408051808201825260ff878116825263ffffffff8681166020808501828152600097885260049091529490952092518354945160ff1990951692169190911764ffffffff0019166101009390911692909202919091179055600580549091019055929092019161006d565b505060028054600160a060020a03909416600160a060020a03199094169390931790925550505050610f63806101e46000396000f3006080604052600436106100da5763ffffffff7c01000000000000000000000000000000000000000000000000000000006000350416632277e53a81146100df57806335aa2e44146101745780633cd3f6a7146101a85780634f1811dd146101cf57806350fbe2d91461021257806355a373d6146102a9578063568873ad146102be578063671b3793146102d35780637ed93957146102e8578063926988141461034f578063945ac86314610367578063cc0e97c9146103d7578063d889df34146103ec578063f21a211614610401578063f3f39ee51461042d575b600080fd5b3480156100eb57600080fd5b50604080516020600480358082013583810280860185019096528085526101729536959394602494938501929182918501908490808284375050604080516020601f89358b018035918201839004830284018301909452808352979a9998810197919650918201945092508291508401838280828437509497506104429650505050505050565b005b34801561018057600080fd5b5061018c600435610446565b60408051600160a060020a039092168252519081900360200190f35b3480156101b457600080fd5b506101bd61046e565b60408051918252519081900360200190f35b3480156101db57600080fd5b506101f0600160a060020a0360043516610474565b6040805160ff909316835263ffffffff90911660208301528051918290030190f35b34801561021e57600080fd5b506040805160206004803580820135601f810184900484028501840190955284845261017294369492936024939284019190819084018382808284375050604080516020601f89358b018035918201839004830284018301909452808352979a9998810197919650918201945092508291508401838280828437509497506104969650505050505050565b3480156102b557600080fd5b5061018c6105e7565b3480156102ca57600080fd5b506101bd6105f6565b3480156102df57600080fd5b506101bd6105fc565b3480156102f457600080fd5b5060408051602060046024803582810135601f8101859004850286018501909652858552610172958335600160a060020a03169536956044949193909101919081908401838280828437509497506106029650505050505050565b34801561035b57600080fd5b506101bd60043561084e565b34801561037357600080fd5b50604080516020600460443581810135601f810184900484028501840190955284845261017294823567ffffffffffffffff908116956024803590921695369594606494929301919081908401838280828437509497506108609650505050505050565b3480156103e357600080fd5b5061018c610c6f565b3480156103f857600080fd5b506101bd610c7e565b34801561040d57600080fd5b50610419600435610c84565b604080519115158252519081900360200190f35b34801561043957600080fd5b506101bd610c99565b5050565b600380548290811061045457fe5b600091825260209091200154600160a060020a0316905081565b60085481565b60046020526000908152604090205460ff811690610100900463ffffffff1682565b60008060006104a58585610c9f565b600254604080517fa9059cbb000000000000000000000000000000000000000000000000000000008152336004820152602481018490529051949750929550909350600160a060020a03169163a9059cbb916044808201926020929091908290030181600087803b15801561051957600080fd5b505af115801561052d573d6000803e3d6000fd5b505050506040513d602081101561054357600080fd5b5050600254604080517fa9059cbb000000000000000000000000000000000000000000000000000000008152600160a060020a038681166004830152602482018690529151919092169163a9059cbb9160448083019260209291908290030181600087803b1580156105b457600080fd5b505af11580156105c8573d6000803e3d6000fd5b505050506040513d60208110156105de57600080fd5b50505050505050565b600254600160a060020a031681565b60065481565b60055481565b600080546001018082556040805173ffffffffffffffffffffffffffffffffffffffff196b65786563000000000000000090931774010000000000000000000000000000000000000000029283166020808301919091528251808303600c018152602c90920192839052815193949384938493600293909282918401908083835b602083106106a25780518252601f199092019160209182019101610683565b51815160209384036101000a600019018019909216911617905260405191909301945091925050808303816000865af11580156106e3573d6000803e3d6000fd5b5050506040513d60208110156106f857600080fd5b5051604080516c01000000000000000000000000600160a060020a038a160260208281019190915282518083036014018152603490920192839052815193965060029391929182918401908083835b602083106107665780518252601f199092019160209182019101610747565b51815160209384036101000a600019018019909216911617905260405191909301945091925050808303816000865af11580156107a7573d6000803e3d6000fd5b5050506040513d60208110156107bc57600080fd5b505191506107cb838387610dc7565b60085490915081146107dc57600080fd5b6001805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a03881690811790915560005460408051918252602082019290925281517f4289d6195cf3c2d2174adf98d0e19d4d2d08887995b99cb7b100e7ffe795820e929181900390910190a1505050505050565b600a6020526000908152604090205481565b61088f565b6000602083111561087557600080fd5b50516008919091026101000360020a600019908101181690565b61089b565b5160001a90565b61093c565b6000808253600182019150600882536001820191506002825360018201915060008311156108fa576011825360018201915060005b60088110156108f8576101008406835361010090930492600192830192016108d5565b505b6000841115610935576019825360018201915060005b600881101561093357610100850683536101008504935060019283019201610910565b505b5092915050565b610948565b6004015190565b610972565b8281015b8082101561096c578251825260209283019290910190610951565b50505050565b6109a6565b8282528382019060009061098c88888561094d565b878301915060018101820380825350509695505050505050565b610a50565b6000806040516109ba84610894565b600f8111156109c857600080fd5b6001850194506109d88186610865565b948101946109ea898984848b88610977565b608084016020818684038760025afa610a0289610894565b6020830152600189019850885160408301526020890198508851606083015260208901985060208260808460015afa801515610a3d57600080fd5b5050519a96995095975050505050505050565b610a96565b600080608060405101838152600460208201526040812080546000811415610a7c57600080fd5b60ff81169661010090910463ffffffff1695509350505050565b610aca565b600080610aa783610a55565b600282900a86811615610ab957600080fd5b959095179695909401949350505050565b610b79565b600080600080610ade85610894565b605c811115610aec57600080fd5b600186820181019601610afe81610941565b9550604051610b0e8a8a836108a0565b610b1789610894565b60018a0199505b6000811115610b53576000610b358686858e6109ab565b9b509050610b44878983610a9b565b90985096505060001901610b1e565b6005546002026003870211610b6757600080fd5b89975050505050505050935093915050565b610c32565b60006040516001610b8e84610894565b01610b9a81858461094d565b600184810151948201949350820160228301602082848660025afa6020600184035360206001830353865182526020968701968360428760025afa90508651825260208701965060208260428760025afa90508651835260208701965060208260428760025afa90508651835260208701965060208560428760025afa85519091508814610c2757600080fd5b505050505092915050565b6007548311610c4057600080fd5b600060208201610c51848683610acf565b91509150610c5f8282610b7e565b8560075580600855505050505050565b600154600160a060020a031681565b60005481565b60096020526000908152604090205460ff1681565b60075481565b6000806000806000806002886040518082805190602001908083835b60208310610cda5780518252601f199092019160209182019101610cbb565b51815160209384036101000a600019018019909216911617905260405191909301945091925050808303816000865af1158015610d1b573d6000803e3d6000fd5b5050506040513d6020811015610d3057600080fd5b505160008181526009602052604090205490935060ff1615610d5157600080fd5b6000838152600960205260409020805460ff191660011790557f4bf5122f344554c53bde2ebb8cd2b7e3d1600ad631c385a5d7cce23c7785459a9150610d98838389610dc7565b6008549091508114610da957600080fd5b50505050602884015160488501516068909501519095909350915050565b600060405180608082016021850160ff601f820351166009811115610deb57600080fd5b6001820191507e02000000000000000000000000000000000000000000000000000000000000845260028401935081518452808201915080840193506020845360018401899052602190930192602084536001840193508784526020840193506020838686038760025afa60ff601f840351169150600183019250815b6000811115610f1157601e19840151879650607f811693506080166013841115610e9157600080fd5b60018581015188529684019694840190940193808015610ed25760208853855160018901526021909701966020885386516001890152602190970196610ef5565b602088538651600189015260219097019660208853855160018901526021909701965b50602094850194868989038a60025afa92505060001901610e68565b5087519150816020890184031115610f2857600080fd5b505090519796505050505050505600a165627a7a7230582028cc1d4d922e49da40fdbb2a7a9bdc996e552363d6837d45cf07c4bf166b97c300290000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000014000000000000000000000000002f61fd266da6e8b102d4121f5ce7b992640cf98000000000000000000000000000000000000000000000000000000000000000600000000000000000000000062be52bd46aaeb2bdcd2d123478b1acbfb1d2346000000000000000000000000d2df2a279f931d57042440f694b27048f618b319000000000000000000000000db53bc6aa6cf634669e704c49568d18d539e830d0000000000000000000000001aef7c26e48e5ed83024bcb122931fb30a99d54b000000000000000000000000c6720a4b73ad41ab7147b8ac42eca62250d8fb9a00000000000000000000000049a116b7eda1a5eae5e56a4e285d4dbdfd18aa5e0000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000411a000000000000000000000000000000000000000000000000000000000000411a000000000000000000000000000000000000000000000000000000000000411a000000000000000000000000000000000000000000000000000000000000411a000000000000000000000000000000000000000000000000000000000000411a000000000000000000000000000000000000000000000000000000000000411e",
  "constructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000014000000000000000000000000002f61fd266da6e8b102d4121f5ce7b992640cf98000000000000000000000000000000000000000000000000000000000000000600000000000000000000000062be52bd46aaeb2bdcd2d123478b1acbfb1d2346000000000000000000000000d2df2a279f931d57042440f694b27048f618b319000000000000000000000000db53bc6aa6cf634669e704c49568d18d539e830d0000000000000000000000001aef7c26e48e5ed83024bcb122931fb30a99d54b000000000000000000000000c6720a4b73ad41ab7147b8ac42eca62250d8fb9a00000000000000000000000049a116b7eda1a5eae5e56a4e285d4dbdfd18aa5e0000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000411a000000000000000000000000000000000000000000000000000000000000411a000000000000000000000000000000000000000000000000000000000000411a000000000000000000000000000000000000000000000000000000000000411a000000000000000000000000000000000000000000000000000000000000411a000000000000000000000000000000000000000000000000000000000000411e"
}