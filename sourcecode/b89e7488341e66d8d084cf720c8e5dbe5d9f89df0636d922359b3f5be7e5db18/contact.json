{
  "address": "0x97b82e42a0c04bad5e61e7cfb4806317d608d809",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "WrapConversionRate",
  "compilerVersion": "v0.4.18+commit.9cf6e910",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2018-03-12\n*/\n\npragma solidity 0.4.18;\n\n// File: ../../wrapConvRate/smart-contracts/contracts/ERC20Interface.sol\n\n// https://github.com/ethereum/EIPs/issues/20\ninterface ERC20 {\n    function totalSupply() public view returns (uint supply);\n    function balanceOf(address _owner) public view returns (uint balance);\n    function transfer(address _to, uint _value) public returns (bool success);\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n    function approve(address _spender, uint _value) public returns (bool success);\n    function allowance(address _owner, address _spender) public view returns (uint remaining);\n    function decimals() public view returns(uint digits);\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\n\n// File: ../../wrapConvRate/smart-contracts/contracts/ConversionRatesInterface.sol\n\ninterface ConversionRatesInterface {\n\n    function recordImbalance(\n        ERC20 token,\n        int buyAmount,\n        uint rateUpdateBlock,\n        uint currentBlock\n    )\n        public;\n\n    function getRate(ERC20 token, uint currentBlockNumber, bool buy, uint qty) public view returns(uint);\n}\n\n// File: ../../wrapConvRate/smart-contracts/contracts/Utils.sol\n\n/// @title Kyber constants contract\ncontract Utils {\n\n    ERC20 constant internal ETH_TOKEN_ADDRESS = ERC20(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\n    uint  constant internal PRECISION = (10**18);\n    uint  constant internal MAX_QTY   = (10**28); // 10B tokens\n    uint  constant internal MAX_RATE  = (PRECISION * 10**6); // up to 1M tokens per ETH\n    uint  constant internal MAX_DECIMALS = 18;\n    uint  constant internal ETH_DECIMALS = 18;\n    mapping(address=>uint) internal decimals;\n\n    function setDecimals(ERC20 token) internal {\n        if (token == ETH_TOKEN_ADDRESS) decimals[token] = ETH_DECIMALS;\n        else decimals[token] = token.decimals();\n    }\n\n    function getDecimals(ERC20 token) internal view returns(uint) {\n        if (token == ETH_TOKEN_ADDRESS) return ETH_DECIMALS; // save storage access\n        uint tokenDecimals = decimals[token];\n        // technically, there might be token with decimals 0\n        // moreover, very possible that old tokens have decimals 0\n        // these tokens will just have higher gas fees.\n        if(tokenDecimals == 0) return token.decimals();\n\n        return tokenDecimals;\n    }\n\n    function calcDstQty(uint srcQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\n        require(srcQty <= MAX_QTY);\n        require(rate <= MAX_RATE);\n\n        if (dstDecimals >= srcDecimals) {\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\n            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\n        } else {\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\n            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\n        }\n    }\n\n    function calcSrcQty(uint dstQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\n        require(dstQty <= MAX_QTY);\n        require(rate <= MAX_RATE);\n        \n        //source quantity is rounded up. to avoid dest quantity being too low.\n        uint numerator;\n        uint denominator;\n        if (srcDecimals >= dstDecimals) {\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\n            numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)));\n            denominator = rate;\n        } else {\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\n            numerator = (PRECISION * dstQty);\n            denominator = (rate * (10**(dstDecimals - srcDecimals)));\n        }\n        return (numerator + denominator - 1) / denominator; //avoid rounding down errors\n    }\n}\n\n// File: ../../wrapConvRate/smart-contracts/contracts/PermissionGroups.sol\n\ncontract PermissionGroups {\n\n    address public admin;\n    address public pendingAdmin;\n    mapping(address=>bool) internal operators;\n    mapping(address=>bool) internal alerters;\n    address[] internal operatorsGroup;\n    address[] internal alertersGroup;\n    uint constant internal MAX_GROUP_SIZE = 50;\n\n    function PermissionGroups() public {\n        admin = msg.sender;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin);\n        _;\n    }\n\n    modifier onlyOperator() {\n        require(operators[msg.sender]);\n        _;\n    }\n\n    modifier onlyAlerter() {\n        require(alerters[msg.sender]);\n        _;\n    }\n\n    function getOperators () external view returns(address[]) {\n        return operatorsGroup;\n    }\n\n    function getAlerters () external view returns(address[]) {\n        return alertersGroup;\n    }\n\n    event TransferAdminPending(address pendingAdmin);\n\n    /**\n     * @dev Allows the current admin to set the pendingAdmin address.\n     * @param newAdmin The address to transfer ownership to.\n     */\n    function transferAdmin(address newAdmin) public onlyAdmin {\n        require(newAdmin != address(0));\n        TransferAdminPending(pendingAdmin);\n        pendingAdmin = newAdmin;\n    }\n\n    /**\n     * @dev Allows the current admin to set the admin in one tx. Useful initial deployment.\n     * @param newAdmin The address to transfer ownership to.\n     */\n    function transferAdminQuickly(address newAdmin) public onlyAdmin {\n        require(newAdmin != address(0));\n        TransferAdminPending(newAdmin);\n        AdminClaimed(newAdmin, admin);\n        admin = newAdmin;\n    }\n\n    event AdminClaimed( address newAdmin, address previousAdmin);\n\n    /**\n     * @dev Allows the pendingAdmin address to finalize the change admin process.\n     */\n    function claimAdmin() public {\n        require(pendingAdmin == msg.sender);\n        AdminClaimed(pendingAdmin, admin);\n        admin = pendingAdmin;\n        pendingAdmin = address(0);\n    }\n\n    event AlerterAdded (address newAlerter, bool isAdd);\n\n    function addAlerter(address newAlerter) public onlyAdmin {\n        require(!alerters[newAlerter]); // prevent duplicates.\n        require(alertersGroup.length < MAX_GROUP_SIZE);\n\n        AlerterAdded(newAlerter, true);\n        alerters[newAlerter] = true;\n        alertersGroup.push(newAlerter);\n    }\n\n    function removeAlerter (address alerter) public onlyAdmin {\n        require(alerters[alerter]);\n        alerters[alerter] = false;\n\n        for (uint i = 0; i < alertersGroup.length; ++i) {\n            if (alertersGroup[i] == alerter) {\n                alertersGroup[i] = alertersGroup[alertersGroup.length - 1];\n                alertersGroup.length--;\n                AlerterAdded(alerter, false);\n                break;\n            }\n        }\n    }\n\n    event OperatorAdded(address newOperator, bool isAdd);\n\n    function addOperator(address newOperator) public onlyAdmin {\n        require(!operators[newOperator]); // prevent duplicates.\n        require(operatorsGroup.length < MAX_GROUP_SIZE);\n\n        OperatorAdded(newOperator, true);\n        operators[newOperator] = true;\n        operatorsGroup.push(newOperator);\n    }\n\n    function removeOperator (address operator) public onlyAdmin {\n        require(operators[operator]);\n        operators[operator] = false;\n\n        for (uint i = 0; i < operatorsGroup.length; ++i) {\n            if (operatorsGroup[i] == operator) {\n                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];\n                operatorsGroup.length -= 1;\n                OperatorAdded(operator, false);\n                break;\n            }\n        }\n    }\n}\n\n// File: ../../wrapConvRate/smart-contracts/contracts/Withdrawable.sol\n\n/**\n * @title Contracts that should be able to recover tokens or ethers\n * @author Ilan Doron\n * @dev This allows to recover any tokens or Ethers received in a contract.\n * This will prevent any accidental loss of tokens.\n */\ncontract Withdrawable is PermissionGroups {\n\n    event TokenWithdraw(ERC20 token, uint amount, address sendTo);\n\n    /**\n     * @dev Withdraw all ERC20 compatible tokens\n     * @param token ERC20 The address of the token contract\n     */\n    function withdrawToken(ERC20 token, uint amount, address sendTo) external onlyAdmin {\n        require(token.transfer(sendTo, amount));\n        TokenWithdraw(token, amount, sendTo);\n    }\n\n    event EtherWithdraw(uint amount, address sendTo);\n\n    /**\n     * @dev Withdraw Ethers\n     */\n    function withdrawEther(uint amount, address sendTo) external onlyAdmin {\n        sendTo.transfer(amount);\n        EtherWithdraw(amount, sendTo);\n    }\n}\n\n// File: ../../wrapConvRate/smart-contracts/contracts/VolumeImbalanceRecorder.sol\n\ncontract VolumeImbalanceRecorder is Withdrawable {\n\n    uint constant internal SLIDING_WINDOW_SIZE = 5;\n    uint constant internal POW_2_64 = 2 ** 64;\n\n    struct TokenControlInfo {\n        uint minimalRecordResolution; // can be roughly 1 cent\n        uint maxPerBlockImbalance; // in twei resolution\n        uint maxTotalImbalance; // max total imbalance (between rate updates)\n                            // before halting trade\n    }\n\n    mapping(address => TokenControlInfo) internal tokenControlInfo;\n\n    struct TokenImbalanceData {\n        int  lastBlockBuyUnitsImbalance;\n        uint lastBlock;\n\n        int  totalBuyUnitsImbalance;\n        uint lastRateUpdateBlock;\n    }\n\n    mapping(address => mapping(uint=>uint)) public tokenImbalanceData;\n\n    function VolumeImbalanceRecorder(address _admin) public {\n        require(_admin != address(0));\n        admin = _admin;\n    }\n\n    function setTokenControlInfo(\n        ERC20 token,\n        uint minimalRecordResolution,\n        uint maxPerBlockImbalance,\n        uint maxTotalImbalance\n    )\n        public\n        onlyAdmin\n    {\n        tokenControlInfo[token] =\n            TokenControlInfo(\n                minimalRecordResolution,\n                maxPerBlockImbalance,\n                maxTotalImbalance\n            );\n    }\n\n    function getTokenControlInfo(ERC20 token) public view returns(uint, uint, uint) {\n        return (tokenControlInfo[token].minimalRecordResolution,\n                tokenControlInfo[token].maxPerBlockImbalance,\n                tokenControlInfo[token].maxTotalImbalance);\n    }\n\n    function addImbalance(\n        ERC20 token,\n        int buyAmount,\n        uint rateUpdateBlock,\n        uint currentBlock\n    )\n        internal\n    {\n        uint currentBlockIndex = currentBlock % SLIDING_WINDOW_SIZE;\n        int recordedBuyAmount = int(buyAmount / int(tokenControlInfo[token].minimalRecordResolution));\n\n        int prevImbalance = 0;\n\n        TokenImbalanceData memory currentBlockData =\n            decodeTokenImbalanceData(tokenImbalanceData[token][currentBlockIndex]);\n\n        // first scenario - this is not the first tx in the current block\n        if (currentBlockData.lastBlock == currentBlock) {\n            if (uint(currentBlockData.lastRateUpdateBlock) == rateUpdateBlock) {\n                // just increase imbalance\n                currentBlockData.lastBlockBuyUnitsImbalance += recordedBuyAmount;\n                currentBlockData.totalBuyUnitsImbalance += recordedBuyAmount;\n            } else {\n                // imbalance was changed in the middle of the block\n                prevImbalance = getImbalanceInRange(token, rateUpdateBlock, currentBlock);\n                currentBlockData.totalBuyUnitsImbalance = int(prevImbalance) + recordedBuyAmount;\n                currentBlockData.lastBlockBuyUnitsImbalance += recordedBuyAmount;\n                currentBlockData.lastRateUpdateBlock = uint(rateUpdateBlock);\n            }\n        } else {\n            // first tx in the current block\n            int currentBlockImbalance;\n            (prevImbalance, currentBlockImbalance) = getImbalanceSinceRateUpdate(token, rateUpdateBlock, currentBlock);\n\n            currentBlockData.lastBlockBuyUnitsImbalance = recordedBuyAmount;\n            currentBlockData.lastBlock = uint(currentBlock);\n            currentBlockData.lastRateUpdateBlock = uint(rateUpdateBlock);\n            currentBlockData.totalBuyUnitsImbalance = int(prevImbalance) + recordedBuyAmount;\n        }\n\n        tokenImbalanceData[token][currentBlockIndex] = encodeTokenImbalanceData(currentBlockData);\n    }\n\n    function setGarbageToVolumeRecorder(ERC20 token) internal {\n        for (uint i = 0; i < SLIDING_WINDOW_SIZE; i++) {\n            tokenImbalanceData[token][i] = 0x1;\n        }\n    }\n\n    function getImbalanceInRange(ERC20 token, uint startBlock, uint endBlock) internal view returns(int buyImbalance) {\n        // check the imbalance in the sliding window\n        require(startBlock <= endBlock);\n\n        buyImbalance = 0;\n\n        for (uint windowInd = 0; windowInd < SLIDING_WINDOW_SIZE; windowInd++) {\n            TokenImbalanceData memory perBlockData = decodeTokenImbalanceData(tokenImbalanceData[token][windowInd]);\n\n            if (perBlockData.lastBlock <= endBlock && perBlockData.lastBlock >= startBlock) {\n                buyImbalance += int(perBlockData.lastBlockBuyUnitsImbalance);\n            }\n        }\n    }\n\n    function getImbalanceSinceRateUpdate(ERC20 token, uint rateUpdateBlock, uint currentBlock)\n        internal view\n        returns(int buyImbalance, int currentBlockImbalance)\n    {\n        buyImbalance = 0;\n        currentBlockImbalance = 0;\n        uint latestBlock = 0;\n        int imbalanceInRange = 0;\n        uint startBlock = rateUpdateBlock;\n        uint endBlock = currentBlock;\n\n        for (uint windowInd = 0; windowInd < SLIDING_WINDOW_SIZE; windowInd++) {\n            TokenImbalanceData memory perBlockData = decodeTokenImbalanceData(tokenImbalanceData[token][windowInd]);\n\n            if (perBlockData.lastBlock <= endBlock && perBlockData.lastBlock >= startBlock) {\n                imbalanceInRange += perBlockData.lastBlockBuyUnitsImbalance;\n            }\n\n            if (perBlockData.lastRateUpdateBlock != rateUpdateBlock) continue;\n            if (perBlockData.lastBlock < latestBlock) continue;\n\n            latestBlock = perBlockData.lastBlock;\n            buyImbalance = perBlockData.totalBuyUnitsImbalance;\n            if (uint(perBlockData.lastBlock) == currentBlock) {\n                currentBlockImbalance = perBlockData.lastBlockBuyUnitsImbalance;\n            }\n        }\n\n        if (buyImbalance == 0) {\n            buyImbalance = imbalanceInRange;\n        }\n    }\n\n    function getImbalance(ERC20 token, uint rateUpdateBlock, uint currentBlock)\n        internal view\n        returns(int totalImbalance, int currentBlockImbalance)\n    {\n\n        int resolution = int(tokenControlInfo[token].minimalRecordResolution);\n\n        (totalImbalance, currentBlockImbalance) =\n            getImbalanceSinceRateUpdate(\n                token,\n                rateUpdateBlock,\n                currentBlock);\n\n        totalImbalance *= resolution;\n        currentBlockImbalance *= resolution;\n    }\n\n    function getMaxPerBlockImbalance(ERC20 token) internal view returns(uint) {\n        return tokenControlInfo[token].maxPerBlockImbalance;\n    }\n\n    function getMaxTotalImbalance(ERC20 token) internal view returns(uint) {\n        return tokenControlInfo[token].maxTotalImbalance;\n    }\n\n    function encodeTokenImbalanceData(TokenImbalanceData data) internal pure returns(uint) {\n        // check for overflows\n        require(data.lastBlockBuyUnitsImbalance < int(POW_2_64 / 2));\n        require(data.lastBlockBuyUnitsImbalance > int(-1 * int(POW_2_64) / 2));\n        require(data.lastBlock < POW_2_64);\n        require(data.totalBuyUnitsImbalance < int(POW_2_64 / 2));\n        require(data.totalBuyUnitsImbalance > int(-1 * int(POW_2_64) / 2));\n        require(data.lastRateUpdateBlock < POW_2_64);\n\n        // do encoding\n        uint result = uint(data.lastBlockBuyUnitsImbalance) & (POW_2_64 - 1);\n        result |= data.lastBlock * POW_2_64;\n        result |= (uint(data.totalBuyUnitsImbalance) & (POW_2_64 - 1)) * POW_2_64 * POW_2_64;\n        result |= data.lastRateUpdateBlock * POW_2_64 * POW_2_64 * POW_2_64;\n\n        return result;\n    }\n\n    function decodeTokenImbalanceData(uint input) internal pure returns(TokenImbalanceData) {\n        TokenImbalanceData memory data;\n\n        data.lastBlockBuyUnitsImbalance = int(int64(input & (POW_2_64 - 1)));\n        data.lastBlock = uint(uint64((input / POW_2_64) & (POW_2_64 - 1)));\n        data.totalBuyUnitsImbalance = int(int64((input / (POW_2_64 * POW_2_64)) & (POW_2_64 - 1)));\n        data.lastRateUpdateBlock = uint(uint64((input / (POW_2_64 * POW_2_64 * POW_2_64))));\n\n        return data;\n    }\n}\n\n// File: ../../wrapConvRate/smart-contracts/contracts/ConversionRates.sol\n\ncontract ConversionRates is ConversionRatesInterface, VolumeImbalanceRecorder, Utils {\n\n    // bps - basic rate steps. one step is 1 / 10000 of the rate.\n    struct StepFunction {\n        int[] x; // quantity for each step. Quantity of each step includes previous steps.\n        int[] y; // rate change per quantity step  in bps.\n    }\n\n    struct TokenData {\n        bool listed;  // was added to reserve\n        bool enabled; // whether trade is enabled\n\n        // position in the compact data\n        uint compactDataArrayIndex;\n        uint compactDataFieldIndex;\n\n        // rate data. base and changes according to quantity and reserve balance.\n        // generally speaking. Sell rate is 1 / buy rate i.e. the buy in the other direction.\n        uint baseBuyRate;  // in PRECISION units. see KyberConstants\n        uint baseSellRate; // PRECISION units. without (sell / buy) spread it is 1 / baseBuyRate\n        StepFunction buyRateQtyStepFunction; // in bps. higher quantity - bigger the rate.\n        StepFunction sellRateQtyStepFunction;// in bps. higher the qua\n        StepFunction buyRateImbalanceStepFunction; // in BPS. higher reserve imbalance - bigger the rate.\n        StepFunction sellRateImbalanceStepFunction;\n    }\n\n    /*\n    this is the data for tokenRatesCompactData\n    but solidity compiler optimizer is sub-optimal, and cannot write this structure in a single storage write\n    so we represent it as bytes32 and do the byte tricks ourselves.\n    struct TokenRatesCompactData {\n        bytes14 buy;  // change buy rate of token from baseBuyRate in 10 bps\n        bytes14 sell; // change sell rate of token from baseSellRate in 10 bps\n\n        uint32 blockNumber;\n    } */\n    uint public validRateDurationInBlocks = 10; // rates are valid for this amount of blocks\n    ERC20[] internal listedTokens;\n    mapping(address=>TokenData) internal tokenData;\n    bytes32[] internal tokenRatesCompactData;\n    uint public numTokensInCurrentCompactData = 0;\n    address public reserveContract;\n    uint constant internal NUM_TOKENS_IN_COMPACT_DATA = 14;\n    uint constant internal BYTES_14_OFFSET = (2 ** (8 * NUM_TOKENS_IN_COMPACT_DATA));\n    uint constant internal MAX_STEPS_IN_FUNCTION = 10;\n    int  constant internal MAX_BPS_ADJUSTMENT = 10 ** 11; // 1B %\n    int  constant internal MIN_BPS_ADJUSTMENT = -100 * 100; // cannot go down by more than 100%\n\n    function ConversionRates(address _admin) public VolumeImbalanceRecorder(_admin)\n        { } // solhint-disable-line no-empty-blocks\n\n    function addToken(ERC20 token) public onlyAdmin {\n\n        require(!tokenData[token].listed);\n        tokenData[token].listed = true;\n        listedTokens.push(token);\n\n        if (numTokensInCurrentCompactData == 0) {\n            tokenRatesCompactData.length++; // add new structure\n        }\n\n        tokenData[token].compactDataArrayIndex = tokenRatesCompactData.length - 1;\n        tokenData[token].compactDataFieldIndex = numTokensInCurrentCompactData;\n\n        numTokensInCurrentCompactData = (numTokensInCurrentCompactData + 1) % NUM_TOKENS_IN_COMPACT_DATA;\n\n        setGarbageToVolumeRecorder(token);\n\n        setDecimals(token);\n    }\n\n    function setCompactData(bytes14[] buy, bytes14[] sell, uint blockNumber, uint[] indices) public onlyOperator {\n\n        require(buy.length == sell.length);\n        require(indices.length == buy.length);\n        require(blockNumber <= 0xFFFFFFFF);\n\n        uint bytes14Offset = BYTES_14_OFFSET;\n\n        for (uint i = 0; i < indices.length; i++) {\n            require(indices[i] < tokenRatesCompactData.length);\n            uint data = uint(buy[i]) | uint(sell[i]) * bytes14Offset | (blockNumber * (bytes14Offset * bytes14Offset));\n            tokenRatesCompactData[indices[i]] = bytes32(data);\n        }\n    }\n\n    function setBaseRate(\n        ERC20[] tokens,\n        uint[] baseBuy,\n        uint[] baseSell,\n        bytes14[] buy,\n        bytes14[] sell,\n        uint blockNumber,\n        uint[] indices\n    )\n        public\n        onlyOperator\n    {\n        require(tokens.length == baseBuy.length);\n        require(tokens.length == baseSell.length);\n        require(sell.length == buy.length);\n        require(sell.length == indices.length);\n\n        for (uint ind = 0; ind < tokens.length; ind++) {\n            require(tokenData[tokens[ind]].listed);\n            tokenData[tokens[ind]].baseBuyRate = baseBuy[ind];\n            tokenData[tokens[ind]].baseSellRate = baseSell[ind];\n        }\n\n        setCompactData(buy, sell, blockNumber, indices);\n    }\n\n    function setQtyStepFunction(\n        ERC20 token,\n        int[] xBuy,\n        int[] yBuy,\n        int[] xSell,\n        int[] ySell\n    )\n        public\n        onlyOperator\n    {\n        require(xBuy.length == yBuy.length);\n        require(xSell.length == ySell.length);\n        require(xBuy.length <= MAX_STEPS_IN_FUNCTION);\n        require(xSell.length <= MAX_STEPS_IN_FUNCTION);\n        require(tokenData[token].listed);\n\n        tokenData[token].buyRateQtyStepFunction = StepFunction(xBuy, yBuy);\n        tokenData[token].sellRateQtyStepFunction = StepFunction(xSell, ySell);\n    }\n\n    function setImbalanceStepFunction(\n        ERC20 token,\n        int[] xBuy,\n        int[] yBuy,\n        int[] xSell,\n        int[] ySell\n    )\n        public\n        onlyOperator\n    {\n        require(xBuy.length == yBuy.length);\n        require(xSell.length == ySell.length);\n        require(xBuy.length <= MAX_STEPS_IN_FUNCTION);\n        require(xSell.length <= MAX_STEPS_IN_FUNCTION);\n        require(tokenData[token].listed);\n\n        tokenData[token].buyRateImbalanceStepFunction = StepFunction(xBuy, yBuy);\n        tokenData[token].sellRateImbalanceStepFunction = StepFunction(xSell, ySell);\n    }\n\n    function setValidRateDurationInBlocks(uint duration) public onlyAdmin {\n        validRateDurationInBlocks = duration;\n    }\n\n    function enableTokenTrade(ERC20 token) public onlyAdmin {\n        require(tokenData[token].listed);\n        require(tokenControlInfo[token].minimalRecordResolution != 0);\n        tokenData[token].enabled = true;\n    }\n\n    function disableTokenTrade(ERC20 token) public onlyAlerter {\n        require(tokenData[token].listed);\n        tokenData[token].enabled = false;\n    }\n\n    function setReserveAddress(address reserve) public onlyAdmin {\n        reserveContract = reserve;\n    }\n\n    function recordImbalance(\n        ERC20 token,\n        int buyAmount,\n        uint rateUpdateBlock,\n        uint currentBlock\n    )\n        public\n    {\n        require(msg.sender == reserveContract);\n\n        if (rateUpdateBlock == 0) rateUpdateBlock = getRateUpdateBlock(token);\n\n        return addImbalance(token, buyAmount, rateUpdateBlock, currentBlock);\n    }\n\n    /* solhint-disable function-max-lines */\n    function getRate(ERC20 token, uint currentBlockNumber, bool buy, uint qty) public view returns(uint) {\n        // check if trade is enabled\n        if (!tokenData[token].enabled) return 0;\n        if (tokenControlInfo[token].minimalRecordResolution == 0) return 0; // token control info not set\n\n        // get rate update block\n        bytes32 compactData = tokenRatesCompactData[tokenData[token].compactDataArrayIndex];\n\n        uint updateRateBlock = getLast4Bytes(compactData);\n        if (currentBlockNumber >= updateRateBlock + validRateDurationInBlocks) return 0; // rate is expired\n        // check imbalance\n        int totalImbalance;\n        int blockImbalance;\n        (totalImbalance, blockImbalance) = getImbalance(token, updateRateBlock, currentBlockNumber);\n\n        // calculate actual rate\n        int imbalanceQty;\n        int extraBps;\n        int8 rateUpdate;\n        uint rate;\n\n        if (buy) {\n            // start with base rate\n            rate = tokenData[token].baseBuyRate;\n\n            // add rate update\n            rateUpdate = getRateByteFromCompactData(compactData, token, true);\n            extraBps = int(rateUpdate) * 10;\n            rate = addBps(rate, extraBps);\n\n            // compute token qty\n            qty = getTokenQty(token, rate, qty);\n            imbalanceQty = int(qty);\n            totalImbalance += imbalanceQty;\n\n            // add qty overhead\n            extraBps = executeStepFunction(tokenData[token].buyRateQtyStepFunction, int(qty));\n            rate = addBps(rate, extraBps);\n\n            // add imbalance overhead\n            extraBps = executeStepFunction(tokenData[token].buyRateImbalanceStepFunction, totalImbalance);\n            rate = addBps(rate, extraBps);\n        } else {\n            // start with base rate\n            rate = tokenData[token].baseSellRate;\n\n            // add rate update\n            rateUpdate = getRateByteFromCompactData(compactData, token, false);\n            extraBps = int(rateUpdate) * 10;\n            rate = addBps(rate, extraBps);\n\n            // compute token qty\n            imbalanceQty = -1 * int(qty);\n            totalImbalance += imbalanceQty;\n\n            // add qty overhead\n            extraBps = executeStepFunction(tokenData[token].sellRateQtyStepFunction, int(qty));\n            rate = addBps(rate, extraBps);\n\n            // add imbalance overhead\n            extraBps = executeStepFunction(tokenData[token].sellRateImbalanceStepFunction, totalImbalance);\n            rate = addBps(rate, extraBps);\n        }\n\n        if (abs(totalImbalance) >= getMaxTotalImbalance(token)) return 0;\n        if (abs(blockImbalance + imbalanceQty) >= getMaxPerBlockImbalance(token)) return 0;\n\n        return rate;\n    }\n    /* solhint-enable function-max-lines */\n\n    function getBasicRate(ERC20 token, bool buy) public view returns(uint) {\n        if (buy)\n            return tokenData[token].baseBuyRate;\n        else\n            return tokenData[token].baseSellRate;\n    }\n\n    function getCompactData(ERC20 token) public view returns(uint, uint, byte, byte) {\n        require(tokenData[token].listed);\n\n        uint arrayIndex = tokenData[token].compactDataArrayIndex;\n        uint fieldOffset = tokenData[token].compactDataFieldIndex;\n\n        return (\n            arrayIndex,\n            fieldOffset,\n            byte(getRateByteFromCompactData(tokenRatesCompactData[arrayIndex], token, true)),\n            byte(getRateByteFromCompactData(tokenRatesCompactData[arrayIndex], token, false))\n        );\n    }\n\n    function getTokenBasicData(ERC20 token) public view returns(bool, bool) {\n        return (tokenData[token].listed, tokenData[token].enabled);\n    }\n\n    /* solhint-disable code-complexity */\n    function getStepFunctionData(ERC20 token, uint command, uint param) public view returns(int) {\n        if (command == 0) return int(tokenData[token].buyRateQtyStepFunction.x.length);\n        if (command == 1) return tokenData[token].buyRateQtyStepFunction.x[param];\n        if (command == 2) return int(tokenData[token].buyRateQtyStepFunction.y.length);\n        if (command == 3) return tokenData[token].buyRateQtyStepFunction.y[param];\n\n        if (command == 4) return int(tokenData[token].sellRateQtyStepFunction.x.length);\n        if (command == 5) return tokenData[token].sellRateQtyStepFunction.x[param];\n        if (command == 6) return int(tokenData[token].sellRateQtyStepFunction.y.length);\n        if (command == 7) return tokenData[token].sellRateQtyStepFunction.y[param];\n\n        if (command == 8) return int(tokenData[token].buyRateImbalanceStepFunction.x.length);\n        if (command == 9) return tokenData[token].buyRateImbalanceStepFunction.x[param];\n        if (command == 10) return int(tokenData[token].buyRateImbalanceStepFunction.y.length);\n        if (command == 11) return tokenData[token].buyRateImbalanceStepFunction.y[param];\n\n        if (command == 12) return int(tokenData[token].sellRateImbalanceStepFunction.x.length);\n        if (command == 13) return tokenData[token].sellRateImbalanceStepFunction.x[param];\n        if (command == 14) return int(tokenData[token].sellRateImbalanceStepFunction.y.length);\n        if (command == 15) return tokenData[token].sellRateImbalanceStepFunction.y[param];\n\n        revert();\n    }\n    /* solhint-enable code-complexity */\n\n    function getRateUpdateBlock(ERC20 token) public view returns(uint) {\n        bytes32 compactData = tokenRatesCompactData[tokenData[token].compactDataArrayIndex];\n        return getLast4Bytes(compactData);\n    }\n\n    function getListedTokens() public view returns(ERC20[]) {\n        return listedTokens;\n    }\n\n    function getTokenQty(ERC20 token, uint ethQty, uint rate) internal view returns(uint) {\n        uint dstDecimals = getDecimals(token);\n        uint srcDecimals = ETH_DECIMALS;\n\n        return calcDstQty(ethQty, srcDecimals, dstDecimals, rate);\n    }\n\n    function getLast4Bytes(bytes32 b) internal pure returns(uint) {\n        // cannot trust compiler with not turning bit operations into EXP opcode\n        return uint(b) / (BYTES_14_OFFSET * BYTES_14_OFFSET);\n    }\n\n    function getRateByteFromCompactData(bytes32 data, ERC20 token, bool buy) internal view returns(int8) {\n        uint fieldOffset = tokenData[token].compactDataFieldIndex;\n        uint byteOffset;\n        if (buy)\n            byteOffset = 32 - NUM_TOKENS_IN_COMPACT_DATA + fieldOffset;\n        else\n            byteOffset = 4 + fieldOffset;\n\n        return int8(data[byteOffset]);\n    }\n\n    function executeStepFunction(StepFunction f, int x) internal pure returns(int) {\n        uint len = f.y.length;\n        for (uint ind = 0; ind < len; ind++) {\n            if (x <= f.x[ind]) return f.y[ind];\n        }\n\n        return f.y[len-1];\n    }\n\n    function addBps(uint rate, int bps) internal pure returns(uint) {\n        require(rate <= MAX_RATE);\n        require(bps >= MIN_BPS_ADJUSTMENT);\n        require(bps <= MAX_BPS_ADJUSTMENT);\n\n        uint maxBps = 100 * 100;\n        return (rate * uint(int(maxBps) + bps)) / maxBps;\n    }\n\n    function abs(int x) internal pure returns(uint) {\n        if (x < 0)\n            return uint(-1 * x);\n        else\n            return uint(x);\n    }\n}\n\n// File: ../../wrapConvRate/smart-contracts/contracts/wrapperContracts/WrapperBase.sol\n\ncontract WrapperBase is Withdrawable {\n\n    PermissionGroups public wrappedContract;\n\n    struct DataTracker {\n        address [] approveSignatureArray;\n        uint lastSetNonce;\n    }\n\n    DataTracker[] internal dataInstances;\n\n    function WrapperBase(PermissionGroups _wrappedContract, address _admin, uint _numDataInstances) public {\n        require(_wrappedContract != address(0));\n        require(_admin != address(0));\n        wrappedContract = _wrappedContract;\n        admin = _admin;\n\n        for (uint i = 0; i < _numDataInstances; i++){\n            addDataInstance();\n        }\n    }\n\n    function claimWrappedContractAdmin() public onlyOperator {\n        wrappedContract.claimAdmin();\n    }\n\n    function transferWrappedContractAdmin (address newAdmin) public onlyAdmin {\n        wrappedContract.transferAdmin(newAdmin);\n    }\n\n    function addDataInstance() internal {\n        address[] memory add = new address[](0);\n        dataInstances.push(DataTracker(add, 0));\n    }\n\n    function setNewData(uint dataIndex) internal {\n        require(dataIndex < dataInstances.length);\n        dataInstances[dataIndex].lastSetNonce++;\n        dataInstances[dataIndex].approveSignatureArray.length = 0;\n    }\n\n    function addSignature(uint dataIndex, uint signedNonce, address signer) internal returns(bool allSigned) {\n        require(dataIndex < dataInstances.length);\n        require(dataInstances[dataIndex].lastSetNonce == signedNonce);\n\n        for(uint i = 0; i < dataInstances[dataIndex].approveSignatureArray.length; i++) {\n            if (signer == dataInstances[dataIndex].approveSignatureArray[i]) revert();\n        }\n        dataInstances[dataIndex].approveSignatureArray.push(signer);\n\n        if (dataInstances[dataIndex].approveSignatureArray.length == operatorsGroup.length) {\n            allSigned = true;\n        } else {\n            allSigned = false;\n        }\n    }\n\n    function getDataTrackingParameters(uint index) internal view returns (address[], uint) {\n        require(index < dataInstances.length);\n        return(dataInstances[index].approveSignatureArray, dataInstances[index].lastSetNonce);\n    }\n}\n\n// File: ../../wrapConvRate/smart-contracts/contracts/wrapperContracts/WrapConversionRate.sol\n\ncontract WrapConversionRate is WrapperBase {\n\n    ConversionRates internal conversionRates;\n\n    //add token parameters\n    struct AddTokenData {\n        ERC20     token;\n        uint      minimalResolution; // can be roughly 1 cent\n        uint      maxPerBlockImbalance; // in twei resolution\n        uint      maxTotalImbalance;\n    }\n\n    AddTokenData internal addTokenData;\n\n    //set token control info parameters.\n    struct TokenControlInfoData {\n        ERC20[] tokens;\n        uint[] perBlockImbalance; // in twei resolution\n        uint[] maxTotalImbalance;\n    }\n\n    TokenControlInfoData internal tokenControlInfoData;\n\n    //valid duration\n    struct ValidDurationData {\n        uint durationInBlocks;\n    }\n\n    ValidDurationData internal validDurationData;\n\n    //data indexes\n    uint constant internal ADD_TOKEN_DATA_INDEX = 0;\n    uint constant internal TOKEN_INFO_DATA_INDEX = 1;\n    uint constant internal VALID_DURATION_DATA_INDEX = 2;\n    uint constant internal NUM_DATA_INDEX = 3;\n\n    //general functions\n    function WrapConversionRate(ConversionRates _conversionRates, address _admin) public\n        WrapperBase(PermissionGroups(address(_conversionRates)), _admin, NUM_DATA_INDEX)\n    {\n        require(_conversionRates != address(0));\n        conversionRates = _conversionRates;\n    }\n\n    // add token functions\n    //////////////////////\n    function setAddTokenData(\n        ERC20 token,\n        uint minRecordResolution,\n        uint maxPerBlockImbalance,\n        uint maxTotalImbalance\n        ) public onlyOperator\n    {\n        require(token != address(0));\n        require(minRecordResolution != 0);\n        require(maxPerBlockImbalance != 0);\n        require(maxTotalImbalance != 0);\n\n        //update data tracking\n        setNewData(ADD_TOKEN_DATA_INDEX);\n\n        addTokenData.token = token;\n        addTokenData.minimalResolution = minRecordResolution; // can be roughly 1 cent\n        addTokenData.maxPerBlockImbalance = maxPerBlockImbalance; // in twei resolution\n        addTokenData.maxTotalImbalance = maxTotalImbalance;\n    }\n\n    function approveAddTokenData(uint nonce) public onlyOperator {\n        if (addSignature(ADD_TOKEN_DATA_INDEX, nonce, msg.sender)) {\n            // can perform operation.\n            performAddToken();\n        }\n    }\n\n    function getAddTokenData() public view\n        returns(uint nonce, ERC20 token, uint minRecordResolution, uint maxPerBlockImbalance, uint maxTotalImbalance)\n    {\n        address[] memory signatures;\n        (signatures, nonce) = getDataTrackingParameters(ADD_TOKEN_DATA_INDEX);\n        token = addTokenData.token;\n        minRecordResolution = addTokenData.minimalResolution;\n        maxPerBlockImbalance = addTokenData.maxPerBlockImbalance; // in twei resolution\n        maxTotalImbalance = addTokenData.maxTotalImbalance;\n        return(nonce, token, minRecordResolution, maxPerBlockImbalance, maxTotalImbalance);\n    }\n\n    function getAddTokenSignatures() public view returns (address[] memory signatures) {\n        uint nonce;\n        (signatures, nonce) = getDataTrackingParameters(ADD_TOKEN_DATA_INDEX);\n        return(signatures);\n    }\n\n    //set token control info\n    ////////////////////////\n    function setTokenInfoData(ERC20[] tokens, uint[] maxPerBlockImbalanceValues, uint[] maxTotalImbalanceValues)\n        public\n        onlyOperator\n    {\n        require(maxPerBlockImbalanceValues.length == tokens.length);\n        require(maxTotalImbalanceValues.length == tokens.length);\n\n        //update data tracking\n        setNewData(TOKEN_INFO_DATA_INDEX);\n\n        tokenControlInfoData.tokens = tokens;\n        tokenControlInfoData.perBlockImbalance = maxPerBlockImbalanceValues;\n        tokenControlInfoData.maxTotalImbalance = maxTotalImbalanceValues;\n    }\n\n    function approveTokenControlInfo(uint nonce) public onlyOperator {\n        if (addSignature(TOKEN_INFO_DATA_INDEX, nonce, msg.sender)) {\n            // can perform operation.\n            performSetTokenControlInfo();\n        }\n    }\n\n    function getControlInfoPerToken (uint index) public view\n        returns(ERC20 token, uint _maxPerBlockImbalance, uint _maxTotalImbalance, uint nonce)\n    {\n        require(tokenControlInfoData.tokens.length > index);\n        require(tokenControlInfoData.perBlockImbalance.length > index);\n        require(tokenControlInfoData.maxTotalImbalance.length > index);\n        address[] memory signatures;\n        (signatures, nonce) = getDataTrackingParameters(TOKEN_INFO_DATA_INDEX);\n\n        return(\n            tokenControlInfoData.tokens[index],\n            tokenControlInfoData.perBlockImbalance[index],\n            tokenControlInfoData.maxTotalImbalance[index],\n            nonce\n        );\n    }\n\n    function getTokenInfoNumToknes() public view returns(uint numSetTokens) {\n        return tokenControlInfoData.tokens.length;\n    }\n\n    function getTokenInfoData() public view\n        returns(uint nonce, uint numSetTokens, ERC20[] tokenAddress, uint[] maxPerBlock, uint[] maxTotal)\n    {\n        address[] memory signatures;\n        (signatures, nonce) = getDataTrackingParameters(TOKEN_INFO_DATA_INDEX);\n\n        return(\n            nonce,\n            tokenControlInfoData.tokens.length,\n            tokenControlInfoData.tokens,\n            tokenControlInfoData.perBlockImbalance,\n            tokenControlInfoData.maxTotalImbalance);\n    }\n\n    function getTokenInfoSignatures() public view returns (address[] memory signatures) {\n        uint nonce;\n        (signatures, nonce) = getDataTrackingParameters(TOKEN_INFO_DATA_INDEX);\n        return(signatures);\n    }\n\n    function getTokenInfoNonce() public view returns(uint nonce) {\n        address[] memory signatures;\n        (signatures, nonce) = getDataTrackingParameters(TOKEN_INFO_DATA_INDEX);\n        return nonce;\n    }\n\n    //valid duration blocks\n    ///////////////////////\n    function setValidDurationData(uint validDurationBlocks) public onlyOperator {\n        require(validDurationBlocks > 5);\n\n        //update data tracking\n        setNewData(VALID_DURATION_DATA_INDEX);\n\n        validDurationData.durationInBlocks = validDurationBlocks;\n    }\n\n    function approveValidDurationData(uint nonce) public onlyOperator {\n        if (addSignature(VALID_DURATION_DATA_INDEX, nonce, msg.sender)) {\n            // can perform operation.\n            conversionRates.setValidRateDurationInBlocks(validDurationData.durationInBlocks);\n        }\n    }\n\n    function getValidDurationBlocksData() public view returns(uint validDuration, uint nonce) {\n        address[] memory signatures;\n        (signatures, nonce) = getDataTrackingParameters(VALID_DURATION_DATA_INDEX);\n        return(nonce, validDurationData.durationInBlocks);\n    }\n\n    function getValidDurationSignatures() public view returns (address[] memory signatures) {\n        uint nonce;\n        (signatures, nonce) = getDataTrackingParameters(VALID_DURATION_DATA_INDEX);\n        return(signatures);\n    }\n\n    function performAddToken() internal {\n        conversionRates.addToken(addTokenData.token);\n\n        conversionRates.addOperator(this);\n\n        //token control info\n        conversionRates.setTokenControlInfo(\n            addTokenData.token,\n            addTokenData.minimalResolution,\n            addTokenData.maxPerBlockImbalance,\n            addTokenData.maxTotalImbalance\n        );\n\n        //step functions\n        int[] memory zeroArr = new int[](1);\n        zeroArr[0] = 0;\n\n        conversionRates.setQtyStepFunction(addTokenData.token, zeroArr, zeroArr, zeroArr, zeroArr);\n        conversionRates.setImbalanceStepFunction(addTokenData.token, zeroArr, zeroArr, zeroArr, zeroArr);\n\n        conversionRates.enableTokenTrade(addTokenData.token);\n\n        conversionRates.removeOperator(this);\n    }\n\n    function performSetTokenControlInfo() internal {\n        require(tokenControlInfoData.tokens.length == tokenControlInfoData.perBlockImbalance.length);\n        require(tokenControlInfoData.tokens.length == tokenControlInfoData.maxTotalImbalance.length);\n\n        uint minRecordResolution;\n\n        for (uint i = 0; i < tokenControlInfoData.tokens.length; i++) {\n            uint maxPerBlock;\n            uint maxTotal;\n            (minRecordResolution, maxPerBlock, maxTotal) =\n                conversionRates.getTokenControlInfo(tokenControlInfoData.tokens[i]);\n            require(minRecordResolution != 0);\n\n            conversionRates.setTokenControlInfo(tokenControlInfoData.tokens[i],\n                minRecordResolution,\n                tokenControlInfoData.perBlockImbalance[i],\n                tokenControlInfoData.maxTotalImbalance[i]);\n        }\n    }\n}",
  "bytecode": "606060405234156200001057600080fd5b6040516040806200258c833981016040528080519190602001805160008054600160a060020a03191633600160a060020a03908116919091178255919350849250839160039190841615156200006557600080fd5b600160a060020a03831615156200007b57600080fd5b5060068054600160a060020a03808616600160a060020a03199283161790925560008054928516929091169190911781555b81811015620000d757620000ce640100000000620021666200011882021704565b600101620000ad565b50505050600160a060020a0382161515620000f157600080fd5b5060088054600160a060020a031916600160a060020a0392909216919091179055620002f4565b62000122620001a9565b6000604051805910620001325750595b90808252806020026020018201604052509050600780548060010182816200015b9190620001bb565b91600052602060002090600202016000604080519081016040528481526000602082015291905081518190805162000198929160200190620001ef565b506020820151816001015550505050565b60206040519081016040526000815290565b815481835581811511620001ea57600202816002028360005260206000209182019101620001ea91906200025b565b505050565b82805482825590600052602060002090810192821562000249579160200282015b82811115620002495782518254600160a060020a031916600160a060020a03919091161782556020929092019160019091019062000210565b50620002579291506200028d565b5090565b6200028a91905b8082111562000257576000620002798282620002b4565b506000600182015560020162000262565b90565b6200028a91905b8082111562000257578054600160a060020a031916815560010162000294565b5080546000825590600052602060002090810190620002d49190620002d7565b50565b6200028a91905b80821115620002575760008155600101620002de565b61228880620003046000396000f3006060604052600436106101715763ffffffff60e060020a600035041663010afc20811461017657806301a12fd31461018b57806326782247146101aa57806327a099d8146101d95780633be1212b1461023f5780633ccdbb2814610255578063408ee7fe1461027e5780634fd1519c1461029d57806350ca6227146102c85780636aad70b6146103c757806370835f6b146103da57806375829def146103f057806376f9b8d91461040f57806377f50f971461042257806378b8c58c146104355780637acc86781461045a5780637c423f54146104795780638d7cffb71461048c5780639870d7fe146104ab578063aaa1f91d146104ca578063ac8a584a146104f2578063bb78d15914610511578063bd467b6e14610527578063c8d172d6146105f6578063ce56c45414610609578063e9c268931461062b578063f77b185614610641578063f7f9cb1c1461068d578063f851a440146106a0578063fd56d4c8146106b3578063ffcab3e914610706575b600080fd5b341561018157600080fd5b610189610719565b005b341561019657600080fd5b610189600160a060020a0360043516610795565b34156101b557600080fd5b6101bd610905565b604051600160a060020a03909116815260200160405180910390f35b34156101e457600080fd5b6101ec610914565b60405160208082528190810183818151815260200191508051906020019060200280838360005b8381101561022b578082015183820152602001610213565b505050509050019250505060405180910390f35b341561024a57600080fd5b61018960043561097d565b341561026057600080fd5b610189600160a060020a036004358116906024359060443516610a1b565b341561028957600080fd5b610189600160a060020a0360043516610b12565b34156102a857600080fd5b6102b0610c0e565b60405191825260208201526040908101905180910390f35b34156102d357600080fd5b6102db610c31565b60405180868152602001858152602001806020018060200180602001848103845287818151815260200191508051906020019060200280838360005b8381101561032f578082015183820152602001610317565b50505050905001848103835286818151815260200191508051906020019060200280838360005b8381101561036e578082015183820152602001610356565b50505050905001848103825285818151815260200191508051906020019060200280838360005b838110156103ad578082015183820152602001610395565b505050509050019850505050505050505060405180910390f35b34156103d257600080fd5b6101ec610d7e565b34156103e557600080fd5b610189600435610d9c565b34156103fb57600080fd5b610189600160a060020a0360043516610ddc565b341561041a57600080fd5b6101ec610e77565b341561042d57600080fd5b610189610e8b565b341561044057600080fd5b610448610f25565b60405190815260200160405180910390f35b341561046557600080fd5b610189600160a060020a0360043516610f2b565b341561048457600080fd5b6101ec61100d565b341561049757600080fd5b610189600160a060020a0360043516611073565b34156104b657600080fd5b610189600160a060020a03600435166110de565b34156104d557600080fd5b610189600160a060020a03600435166024356044356064356111ae565b34156104fd57600080fd5b610189600160a060020a0360043516611247565b341561051c57600080fd5b6101896004356113b3565b341561053257600080fd5b610189600460248135818101908301358060208181020160405190810160405280939291908181526020018383602002808284378201915050505050509190803590602001908201803590602001908080602002602001604051908101604052809392919081815260200183836020028082843782019150505050505091908035906020019082018035906020019080806020026020016040519081016040528093929190818152602001838360200280828437509496506113f395505050505050565b341561060157600080fd5b61044861147b565b341561061457600080fd5b610189600435600160a060020a0360243516611496565b341561063657600080fd5b610189600435611529565b341561064c57600080fd5b61065461156c565b604051948552600160a060020a0390931660208501526040808501929092526060840152608083019190915260a0909101905180910390f35b341561069857600080fd5b6101bd6115af565b34156106ab57600080fd5b6101bd6115be565b34156106be57600080fd5b6106c96004356115cd565b6040518085600160a060020a0316600160a060020a0316815260200184815260200183815260200182815260200194505050505060405180910390f35b341561071157600080fd5b6101ec611681565b600160a060020a03331660009081526002602052604090205460ff16151561074057600080fd5b600654600160a060020a03166377f50f976040518163ffffffff1660e060020a028152600401600060405180830381600087803b151561077f57600080fd5b6102c65a03f1151561079057600080fd5b505050565b6000805433600160a060020a039081169116146107b157600080fd5b600160a060020a03821660009081526003602052604090205460ff1615156107d857600080fd5b50600160a060020a0381166000908152600360205260408120805460ff191690555b6005548110156109015781600160a060020a031660058281548110151561081d57fe5b600091825260209091200154600160a060020a031614156108f95760058054600019810190811061084a57fe5b60009182526020909120015460058054600160a060020a03909216918390811061087057fe5b60009182526020909120018054600160a060020a031916600160a060020a039290921691909117905560058054906108ac90600019830161204c565b507f5611bf3e417d124f97bf2c788843ea8bb502b66079fbee02158ef30b172cb762826000604051600160a060020a039092168252151560208201526040908101905180910390a1610901565b6001016107fa565b5050565b600154600160a060020a031681565b61091c612070565b600480548060200260200160405190810160405280929190818152602001828054801561097257602002820191906000526020600020905b8154600160a060020a03168152600190910190602001808311610954575b505050505090505b90565b600160a060020a03331660009081526002602052604090205460ff1615156109a457600080fd5b6109b060028233611695565b15610a1857600854601054600160a060020a0390911690636c6295b89060405160e060020a63ffffffff84160281526004810191909152602401600060405180830381600087803b1515610a0357600080fd5b6102c65a03f11515610a1457600080fd5b5050505b50565b60005433600160a060020a03908116911614610a3657600080fd5b82600160a060020a031663a9059cbb828460006040516020015260405160e060020a63ffffffff8516028152600160a060020a0390921660048301526024820152604401602060405180830381600087803b1515610a9357600080fd5b6102c65a03f11515610aa457600080fd5b505050604051805190501515610ab957600080fd5b7f72cb8a894ddb372ceec3d2a7648d86f17d5a15caae0e986c53109b8a9a9385e6838383604051600160a060020a03938416815260208101929092529091166040808301919091526060909101905180910390a1505050565b60005433600160a060020a03908116911614610b2d57600080fd5b600160a060020a03811660009081526003602052604090205460ff1615610b5357600080fd5b60055460329010610b6357600080fd5b7f5611bf3e417d124f97bf2c788843ea8bb502b66079fbee02158ef30b172cb762816001604051600160a060020a039092168252151560208201526040908101905180910390a1600160a060020a0381166000908152600360205260409020805460ff191660019081179091556005805490918101610be2838261204c565b5060009182526020909120018054600160a060020a031916600160a060020a0392909216919091179055565b600080610c19612070565b610c2360026117e9565b601054909590945092505050565b600080610c3c612070565b610c44612070565b610c4c612070565b610c54612070565b610c5e60016117e9565b600d80549198509192508791600e600f8284602080820201604051908101604052809291908181526020018280548015610cc157602002820191906000526020600020905b8154600160a060020a03168152600190910190602001808311610ca3575b5050505050925081805480602002602001604051908101604052809291908181526020018280548015610d1357602002820191906000526020600020905b815481526020019060010190808311610cff575b5050505050915080805480602002602001604051908101604052809291908181526020018280548015610d6557602002820191906000526020600020905b815481526020019060010190808311610d51575b5050505050905095509550955095509550509091929394565b610d86612070565b6000610d9260006117e9565b90925090505b5090565b600160a060020a03331660009081526002602052604090205460ff161515610dc357600080fd5b610dcf60008233611695565b15610a1857610a186118a7565b60005433600160a060020a03908116911614610df757600080fd5b600160a060020a0381161515610e0c57600080fd5b6001547f3b81caf78fa51ecbc8acb482fd7012a277b428d9b80f9d156e8a54107496cc4090600160a060020a0316604051600160a060020a03909116815260200160405180910390a160018054600160a060020a031916600160a060020a0392909216919091179055565b610e7f612070565b6000610d9260016117e9565b60015433600160a060020a03908116911614610ea657600080fd5b6001546000547f65da1cfc2c2e81576ad96afb24a581f8e109b7a403b35cbd3243a1c99efdb9ed91600160a060020a039081169116604051600160a060020a039283168152911660208201526040908101905180910390a16001805460008054600160a060020a0319908116600160a060020a03841617909155169055565b600d5490565b60005433600160a060020a03908116911614610f4657600080fd5b600160a060020a0381161515610f5b57600080fd5b7f3b81caf78fa51ecbc8acb482fd7012a277b428d9b80f9d156e8a54107496cc4081604051600160a060020a03909116815260200160405180910390a16000547f65da1cfc2c2e81576ad96afb24a581f8e109b7a403b35cbd3243a1c99efdb9ed908290600160a060020a0316604051600160a060020a039283168152911660208201526040908101905180910390a160008054600160a060020a031916600160a060020a0392909216919091179055565b611015612070565b600580548060200260200160405190810160405280929190818152602001828054801561097257602002820191906000526020600020908154600160a060020a03168152600190910190602001808311610954575050505050905090565b60005433600160a060020a0390811691161461108e57600080fd5b600654600160a060020a03166375829def8260405160e060020a63ffffffff8416028152600160a060020a039091166004820152602401600060405180830381600087803b1515610a0357600080fd5b60005433600160a060020a039081169116146110f957600080fd5b600160a060020a03811660009081526002602052604090205460ff161561111f57600080fd5b6004546032901061112f57600080fd5b7f091a7a4b85135fdd7e8dbc18b12fabe5cc191ea867aa3c2e1a24a102af61d58b816001604051600160a060020a039092168252151560208201526040908101905180910390a1600160a060020a0381166000908152600260205260409020805460ff191660019081179091556004805490918101610be2838261204c565b600160a060020a03331660009081526002602052604090205460ff1615156111d557600080fd5b600160a060020a03841615156111ea57600080fd5b8215156111f657600080fd5b81151561120257600080fd5b80151561120e57600080fd5b6112186000611e1d565b60098054600160a060020a031916600160a060020a039590951694909417909355600a91909155600b55600c55565b6000805433600160a060020a0390811691161461126357600080fd5b600160a060020a03821660009081526002602052604090205460ff16151561128a57600080fd5b50600160a060020a0381166000908152600260205260408120805460ff191690555b6004548110156109015781600160a060020a03166004828154811015156112cf57fe5b600091825260209091200154600160a060020a031614156113ab576004805460001981019081106112fc57fe5b60009182526020909120015460048054600160a060020a03909216918390811061132257fe5b60009182526020909120018054600160a060020a031916600160a060020a039290921691909117905560048054600019019061135e908261204c565b507f091a7a4b85135fdd7e8dbc18b12fabe5cc191ea867aa3c2e1a24a102af61d58b826000604051600160a060020a039092168252151560208201526040908101905180910390a1610901565b6001016112ac565b600160a060020a03331660009081526002602052604090205460ff1615156113da57600080fd5b6113e660018233611695565b15610a1857610a18611e79565b600160a060020a03331660009081526002602052604090205460ff16151561141a57600080fd5b825182511461142857600080fd5b825181511461143657600080fd5b6114406001611e1d565b600d838051611453929160200190612082565b50600e8280516114679291602001906120e5565b50600f818051610a149291602001906120e5565b6000611485612070565b61148f60016117e9565b9392505050565b60005433600160a060020a039081169116146114b157600080fd5b600160a060020a03811682156108fc0283604051600060405180830381858888f1935050505015156114e257600080fd5b7fec47e7ed86c86774d1a72c19f35c639911393fe7c1a34031fdbd260890da90de8282604051918252600160a060020a031660208201526040908101905180910390a15050565b600160a060020a03331660009081526002602052604090205460ff16151561155057600080fd5b6005811161155d57600080fd5b6115676002611e1d565b601055565b600080600080600061157c612070565b61158660006117e9565b600954600a54600b54600c54939b600160a060020a039093169a50909850965090945092505050565b600654600160a060020a031681565b600054600160a060020a031681565b6000806000806115db612070565b600d548690116115ea57600080fd5b600e548690116115f957600080fd5b600f5486901161160857600080fd5b61161260016117e9565b600d80549194509192508790811061162657fe5b600091825260209091200154600e8054600160a060020a03909216918890811061164c57fe5b600091825260209091200154600f80548990811061166657fe5b60009182526020909120015491965094509250509193509193565b611689612070565b6000610d9260026117e9565b600754600090819085106116a857600080fd5b836007868154811015156116b857fe5b9060005260206000209060020201600101541415156116d657600080fd5b5060005b60078054869081106116e857fe5b600091825260209091206002909102015481101561175857600780548690811061170e57fe5b90600052602060002090600202016000018181548110151561172c57fe5b600091825260209091200154600160a060020a038481169116141561175057600080fd5b6001016116da565b600780548690811061176657fe5b60009182526020909120600290910201805460018101611786838261204c565b5060009182526020909120018054600160a060020a031916600160a060020a03851617905560045460078054879081106117bc57fe5b600091825260209091206002909102015414156117dc57600191506117e1565b600091505b509392505050565b6117f1612070565b600754600090831061180257600080fd5b600780548490811061181057fe5b906000526020600020906002020160000160078481548110151561183057fe5b9060005260206000209060020201600101548180548060200260200160405190810160405280929190818152602001828054801561189757602002820191906000526020600020905b8154600160a060020a03168152600190910190602001808311611879575b5050505050915091509150915091565b6118af612070565b600854600954600160a060020a039182169163d48bfca7911660405160e060020a63ffffffff8416028152600160a060020a039091166004820152602401600060405180830381600087803b151561190657600080fd5b6102c65a03f1151561191757600080fd5b5050600854600160a060020a03169050639870d7fe3060405160e060020a63ffffffff8416028152600160a060020a039091166004820152602401600060405180830381600087803b151561196b57600080fd5b6102c65a03f1151561197c57600080fd5b5050600854600954600a54600b54600c54600160a060020a03948516955063bfee3569949093169260405160e060020a63ffffffff8716028152600160a060020a039094166004850152602484019290925260448301526064820152608401600060405180830381600087803b15156119f457600080fd5b6102c65a03f11515611a0557600080fd5b5050506001604051805910611a175750595b90808252806020026020018201604052509050600081600081518110611a3957fe5b60209081029091010152600854600954600160a060020a03918216916380d8b3809116838080806040518663ffffffff1660e060020a0281526004018086600160a060020a0316600160a060020a0316815260200180602001806020018060200180602001858103855289818151815260200191508051906020019060200280838360005b83811015611ad6578082015183820152602001611abe565b50505050905001858103845288818151815260200191508051906020019060200280838360005b83811015611b15578082015183820152602001611afd565b50505050905001858103835287818151815260200191508051906020019060200280838360005b83811015611b54578082015183820152602001611b3c565b50505050905001858103825286818151815260200191508051906020019060200280838360005b83811015611b93578082015183820152602001611b7b565b505050509050019950505050505050505050600060405180830381600087803b1515611bbe57600080fd5b6102c65a03f11515611bcf57600080fd5b5050600854600954600160a060020a03918216925063bc9cbcc89116838080806040518663ffffffff1660e060020a0281526004018086600160a060020a0316600160a060020a0316815260200180602001806020018060200180602001858103855289818151815260200191508051906020019060200280838360005b83811015611c65578082015183820152602001611c4d565b50505050905001858103845288818151815260200191508051906020019060200280838360005b83811015611ca4578082015183820152602001611c8c565b50505050905001858103835287818151815260200191508051906020019060200280838360005b83811015611ce3578082015183820152602001611ccb565b50505050905001858103825286818151815260200191508051906020019060200280838360005b83811015611d22578082015183820152602001611d0a565b505050509050019950505050505050505050600060405180830381600087803b1515611d4d57600080fd5b6102c65a03f11515611d5e57600080fd5b5050600854600954600160a060020a039182169250631d6a8bda911660405160e060020a63ffffffff8416028152600160a060020a039091166004820152602401600060405180830381600087803b1515611db857600080fd5b6102c65a03f11515611dc957600080fd5b5050600854600160a060020a0316905063ac8a584a3060405160e060020a63ffffffff8416028152600160a060020a039091166004820152602401600060405180830381600087803b1515610a0357600080fd5b6007548110611e2b57600080fd5b6007805482908110611e3957fe5b60009182526020822060016002909202018101805490910190556007805483908110611e6157fe5b6000918252602090912061090191600202018261204c565b600e54600d5460009182918291829114611e9257600080fd5b600f54600d5414611ea257600080fd5b600092505b600d54831015610a1457600854600d8054600160a060020a039092169163e7d4fd91919086908110611ed557fe5b6000918252602082200154600160a060020a0316906040516060015260405160e060020a63ffffffff8416028152600160a060020a039091166004820152602401606060405180830381600087803b1515611f2f57600080fd5b6102c65a03f11515611f4057600080fd5b505050604051805190602001805190602001805192965090935090915050831515611f6a57600080fd5b600854600d8054600160a060020a039092169163bfee3569919086908110611f8e57fe5b600091825260209091200154600e8054600160a060020a039092169188919088908110611fb757fe5b600091825260209091200154600f805489908110611fd157fe5b90600052602060002090015460405160e060020a63ffffffff8716028152600160a060020a039094166004850152602484019290925260448301526064820152608401600060405180830381600087803b151561202d57600080fd5b6102c65a03f1151561203e57600080fd5b505060019093019250611ea7565b81548183558181151161079057600083815260209020610790918101908301612128565b60206040519081016040526000815290565b8280548282559060005260206000209081019282156120d9579160200282015b828111156120d95782518254600160a060020a031916600160a060020a0391909116178255602092909201916001909101906120a2565b50610d98929150612142565b828054828255906000526020600020908101928215612120579160200282015b82811115612120578251825591602001919060010190612105565b50610d989291505b61097a91905b80821115610d98576000815560010161212e565b61097a91905b80821115610d98578054600160a060020a0319168155600101612148565b61216e612070565b600060405180591061217d5750595b90808252806020026020018201604052509050600780548060010182816121a491906121f0565b9160005260206000209060020201600060408051908101604052848152600060208201529190508151819080516121df929160200190612082565b506020820151816001015550505050565b815481835581811511610790576000838152602090206107909161097a9160029182028101918502015b80821115610d9857600061222e828261223e565b506000600182015560020161221a565b5080546000825590600052602060002090810190610a1891906121285600a165627a7a72305820194c545fcddf158488f3ab549412312c0eaaa595ba0e476b435d33a98e7a6f240029000000000000000000000000798abda6cc246d0edba912092a2a3dbd3d11191b000000000000000000000000d63b6031bd6f81332104c93b430f0d5897106a33",
  "constructorArguments": "000000000000000000000000798abda6cc246d0edba912092a2a3dbd3d11191b000000000000000000000000d63b6031bd6f81332104c93b430f0d5897106a33"
}