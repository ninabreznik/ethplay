{
  "address": "0x40ae4acd08e65714b093bf2495fd7941aedfa231",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "SmartzToken",
  "compilerVersion": "v0.4.18+commit.9cf6e910",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2018-03-29\n*/\n\npragma solidity ^0.4.18;\n\ninterface IApprovalRecipient {\n    /**\n     * @notice Signals that token holder approved spending of tokens and some action should be taken.\n     *\n     * @param _sender token holder which approved spending of his tokens\n     * @param _value amount of tokens approved to be spent\n     * @param _extraData any extra data token holder provided to the call\n     *\n     * @dev warning: implementors should validate sender of this message (it should be the token) and make no further\n     *      assumptions unless validated them via ERC20 methods.\n     */\n    function receiveApproval(address _sender, uint256 _value, bytes _extraData) public;\n}\n\ninterface IKYCProvider {\n    function isKYCPassed(address _address) public view returns (bool);\n}\n\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\ncontract ArgumentsChecker {\n\n    /// @dev check which prevents short address attack\n    modifier payloadSizeIs(uint size) {\n       require(msg.data.length == size + 4 /* function selector */);\n       _;\n    }\n\n    /// @dev check that address is valid\n    modifier validAddress(address addr) {\n        require(addr != address(0));\n        _;\n    }\n}\n\ncontract multiowned {\n\n\t// TYPES\n\n    // struct for the status of a pending operation.\n    struct MultiOwnedOperationPendingState {\n        // count of confirmations needed\n        uint yetNeeded;\n\n        // bitmap of confirmations where owner #ownerIndex's decision corresponds to 2**ownerIndex bit\n        uint ownersDone;\n\n        // position of this operation key in m_multiOwnedPendingIndex\n        uint index;\n    }\n\n\t// EVENTS\n\n    event Confirmation(address owner, bytes32 operation);\n    event Revoke(address owner, bytes32 operation);\n    event FinalConfirmation(address owner, bytes32 operation);\n\n    // some others are in the case of an owner changing.\n    event OwnerChanged(address oldOwner, address newOwner);\n    event OwnerAdded(address newOwner);\n    event OwnerRemoved(address oldOwner);\n\n    // the last one is emitted if the required signatures change\n    event RequirementChanged(uint newRequirement);\n\n\t// MODIFIERS\n\n    // simple single-sig function modifier.\n    modifier onlyowner {\n        require(isOwner(msg.sender));\n        _;\n    }\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\n    // that later attempts can be realised as the same underlying operation and\n    // thus count as confirmations.\n    modifier onlymanyowners(bytes32 _operation) {\n        if (confirmAndCheck(_operation)) {\n            _;\n        }\n        // Even if required number of confirmations has't been collected yet,\n        // we can't throw here - because changes to the state have to be preserved.\n        // But, confirmAndCheck itself will throw in case sender is not an owner.\n    }\n\n    modifier validNumOwners(uint _numOwners) {\n        require(_numOwners > 0 && _numOwners <= c_maxOwners);\n        _;\n    }\n\n    modifier multiOwnedValidRequirement(uint _required, uint _numOwners) {\n        require(_required > 0 && _required <= _numOwners);\n        _;\n    }\n\n    modifier ownerExists(address _address) {\n        require(isOwner(_address));\n        _;\n    }\n\n    modifier ownerDoesNotExist(address _address) {\n        require(!isOwner(_address));\n        _;\n    }\n\n    modifier multiOwnedOperationIsActive(bytes32 _operation) {\n        require(isOperationActive(_operation));\n        _;\n    }\n\n\t// METHODS\n\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\n    // as well as the selection of addresses capable of confirming them (msg.sender is not added to the owners!).\n    function multiowned(address[] _owners, uint _required)\n        public\n        validNumOwners(_owners.length)\n        multiOwnedValidRequirement(_required, _owners.length)\n    {\n        assert(c_maxOwners <= 255);\n\n        m_numOwners = _owners.length;\n        m_multiOwnedRequired = _required;\n\n        for (uint i = 0; i < _owners.length; ++i)\n        {\n            address owner = _owners[i];\n            // invalid and duplicate addresses are not allowed\n            require(0 != owner && !isOwner(owner) /* not isOwner yet! */);\n\n            uint currentOwnerIndex = checkOwnerIndex(i + 1 /* first slot is unused */);\n            m_owners[currentOwnerIndex] = owner;\n            m_ownerIndex[owner] = currentOwnerIndex;\n        }\n\n        assertOwnersAreConsistent();\n    }\n\n    /// @notice replaces an owner `_from` with another `_to`.\n    /// @param _from address of owner to replace\n    /// @param _to address of new owner\n    // All pending operations will be canceled!\n    function changeOwner(address _from, address _to)\n        external\n        ownerExists(_from)\n        ownerDoesNotExist(_to)\n        onlymanyowners(keccak256(msg.data))\n    {\n        assertOwnersAreConsistent();\n\n        clearPending();\n        uint ownerIndex = checkOwnerIndex(m_ownerIndex[_from]);\n        m_owners[ownerIndex] = _to;\n        m_ownerIndex[_from] = 0;\n        m_ownerIndex[_to] = ownerIndex;\n\n        assertOwnersAreConsistent();\n        OwnerChanged(_from, _to);\n    }\n\n    /// @notice adds an owner\n    /// @param _owner address of new owner\n    // All pending operations will be canceled!\n    function addOwner(address _owner)\n        external\n        ownerDoesNotExist(_owner)\n        validNumOwners(m_numOwners + 1)\n        onlymanyowners(keccak256(msg.data))\n    {\n        assertOwnersAreConsistent();\n\n        clearPending();\n        m_numOwners++;\n        m_owners[m_numOwners] = _owner;\n        m_ownerIndex[_owner] = checkOwnerIndex(m_numOwners);\n\n        assertOwnersAreConsistent();\n        OwnerAdded(_owner);\n    }\n\n    /// @notice removes an owner\n    /// @param _owner address of owner to remove\n    // All pending operations will be canceled!\n    function removeOwner(address _owner)\n        external\n        ownerExists(_owner)\n        validNumOwners(m_numOwners - 1)\n        multiOwnedValidRequirement(m_multiOwnedRequired, m_numOwners - 1)\n        onlymanyowners(keccak256(msg.data))\n    {\n        assertOwnersAreConsistent();\n\n        clearPending();\n        uint ownerIndex = checkOwnerIndex(m_ownerIndex[_owner]);\n        m_owners[ownerIndex] = 0;\n        m_ownerIndex[_owner] = 0;\n        //make sure m_numOwners is equal to the number of owners and always points to the last owner\n        reorganizeOwners();\n\n        assertOwnersAreConsistent();\n        OwnerRemoved(_owner);\n    }\n\n    /// @notice changes the required number of owner signatures\n    /// @param _newRequired new number of signatures required\n    // All pending operations will be canceled!\n    function changeRequirement(uint _newRequired)\n        external\n        multiOwnedValidRequirement(_newRequired, m_numOwners)\n        onlymanyowners(keccak256(msg.data))\n    {\n        m_multiOwnedRequired = _newRequired;\n        clearPending();\n        RequirementChanged(_newRequired);\n    }\n\n    /// @notice Gets an owner by 0-indexed position\n    /// @param ownerIndex 0-indexed owner position\n    function getOwner(uint ownerIndex) public constant returns (address) {\n        return m_owners[ownerIndex + 1];\n    }\n\n    /// @notice Gets owners\n    /// @return memory array of owners\n    function getOwners() public constant returns (address[]) {\n        address[] memory result = new address[](m_numOwners);\n        for (uint i = 0; i < m_numOwners; i++)\n            result[i] = getOwner(i);\n\n        return result;\n    }\n\n    /// @notice checks if provided address is an owner address\n    /// @param _addr address to check\n    /// @return true if it's an owner\n    function isOwner(address _addr) public constant returns (bool) {\n        return m_ownerIndex[_addr] > 0;\n    }\n\n    /// @notice Tests ownership of the current caller.\n    /// @return true if it's an owner\n    // It's advisable to call it by new owner to make sure that the same erroneous address is not copy-pasted to\n    // addOwner/changeOwner and to isOwner.\n    function amIOwner() external constant onlyowner returns (bool) {\n        return true;\n    }\n\n    /// @notice Revokes a prior confirmation of the given operation\n    /// @param _operation operation value, typically keccak256(msg.data)\n    function revoke(bytes32 _operation)\n        external\n        multiOwnedOperationIsActive(_operation)\n        onlyowner\n    {\n        uint ownerIndexBit = makeOwnerBitmapBit(msg.sender);\n        var pending = m_multiOwnedPending[_operation];\n        require(pending.ownersDone & ownerIndexBit > 0);\n\n        assertOperationIsConsistent(_operation);\n\n        pending.yetNeeded++;\n        pending.ownersDone -= ownerIndexBit;\n\n        assertOperationIsConsistent(_operation);\n        Revoke(msg.sender, _operation);\n    }\n\n    /// @notice Checks if owner confirmed given operation\n    /// @param _operation operation value, typically keccak256(msg.data)\n    /// @param _owner an owner address\n    function hasConfirmed(bytes32 _operation, address _owner)\n        external\n        constant\n        multiOwnedOperationIsActive(_operation)\n        ownerExists(_owner)\n        returns (bool)\n    {\n        return !(m_multiOwnedPending[_operation].ownersDone & makeOwnerBitmapBit(_owner) == 0);\n    }\n\n    // INTERNAL METHODS\n\n    function confirmAndCheck(bytes32 _operation)\n        private\n        onlyowner\n        returns (bool)\n    {\n        if (512 == m_multiOwnedPendingIndex.length)\n            // In case m_multiOwnedPendingIndex grows too much we have to shrink it: otherwise at some point\n            // we won't be able to do it because of block gas limit.\n            // Yes, pending confirmations will be lost. Dont see any security or stability implications.\n            // TODO use more graceful approach like compact or removal of clearPending completely\n            clearPending();\n\n        var pending = m_multiOwnedPending[_operation];\n\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\n        if (! isOperationActive(_operation)) {\n            // reset count of confirmations needed.\n            pending.yetNeeded = m_multiOwnedRequired;\n            // reset which owners have confirmed (none) - set our bitmap to 0.\n            pending.ownersDone = 0;\n            pending.index = m_multiOwnedPendingIndex.length++;\n            m_multiOwnedPendingIndex[pending.index] = _operation;\n            assertOperationIsConsistent(_operation);\n        }\n\n        // determine the bit to set for this owner.\n        uint ownerIndexBit = makeOwnerBitmapBit(msg.sender);\n        // make sure we (the message sender) haven't confirmed this operation previously.\n        if (pending.ownersDone & ownerIndexBit == 0) {\n            // ok - check if count is enough to go ahead.\n            assert(pending.yetNeeded > 0);\n            if (pending.yetNeeded == 1) {\n                // enough confirmations: reset and run interior.\n                delete m_multiOwnedPendingIndex[m_multiOwnedPending[_operation].index];\n                delete m_multiOwnedPending[_operation];\n                FinalConfirmation(msg.sender, _operation);\n                return true;\n            }\n            else\n            {\n                // not enough: record that this owner in particular confirmed.\n                pending.yetNeeded--;\n                pending.ownersDone |= ownerIndexBit;\n                assertOperationIsConsistent(_operation);\n                Confirmation(msg.sender, _operation);\n            }\n        }\n    }\n\n    // Reclaims free slots between valid owners in m_owners.\n    // TODO given that its called after each removal, it could be simplified.\n    function reorganizeOwners() private {\n        uint free = 1;\n        while (free < m_numOwners)\n        {\n            // iterating to the first free slot from the beginning\n            while (free < m_numOwners && m_owners[free] != 0) free++;\n\n            // iterating to the first occupied slot from the end\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\n\n            // swap, if possible, so free slot is located at the end after the swap\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\n            {\n                // owners between swapped slots should't be renumbered - that saves a lot of gas\n                m_owners[free] = m_owners[m_numOwners];\n                m_ownerIndex[m_owners[free]] = free;\n                m_owners[m_numOwners] = 0;\n            }\n        }\n    }\n\n    function clearPending() private onlyowner {\n        uint length = m_multiOwnedPendingIndex.length;\n        // TODO block gas limit\n        for (uint i = 0; i < length; ++i) {\n            if (m_multiOwnedPendingIndex[i] != 0)\n                delete m_multiOwnedPending[m_multiOwnedPendingIndex[i]];\n        }\n        delete m_multiOwnedPendingIndex;\n    }\n\n    function checkOwnerIndex(uint ownerIndex) private pure returns (uint) {\n        assert(0 != ownerIndex && ownerIndex <= c_maxOwners);\n        return ownerIndex;\n    }\n\n    function makeOwnerBitmapBit(address owner) private constant returns (uint) {\n        uint ownerIndex = checkOwnerIndex(m_ownerIndex[owner]);\n        return 2 ** ownerIndex;\n    }\n\n    function isOperationActive(bytes32 _operation) private constant returns (bool) {\n        return 0 != m_multiOwnedPending[_operation].yetNeeded;\n    }\n\n\n    function assertOwnersAreConsistent() private constant {\n        assert(m_numOwners > 0);\n        assert(m_numOwners <= c_maxOwners);\n        assert(m_owners[0] == 0);\n        assert(0 != m_multiOwnedRequired && m_multiOwnedRequired <= m_numOwners);\n    }\n\n    function assertOperationIsConsistent(bytes32 _operation) private constant {\n        var pending = m_multiOwnedPending[_operation];\n        assert(0 != pending.yetNeeded);\n        assert(m_multiOwnedPendingIndex[pending.index] == _operation);\n        assert(pending.yetNeeded <= m_multiOwnedRequired);\n    }\n\n\n   \t// FIELDS\n\n    uint constant c_maxOwners = 250;\n\n    // the number of owners that must confirm the same operation before it is run.\n    uint public m_multiOwnedRequired;\n\n\n    // pointer used to find a free slot in m_owners\n    uint public m_numOwners;\n\n    // list of owners (addresses),\n    // slot 0 is unused so there are no owner which index is 0.\n    // TODO could we save space at the end of the array for the common case of <10 owners? and should we?\n    address[256] internal m_owners;\n\n    // index on the list of owners to allow reverse lookup: owner address => index in m_owners\n    mapping(address => uint) internal m_ownerIndex;\n\n\n    // the ongoing operations.\n    mapping(bytes32 => MultiOwnedOperationPendingState) internal m_multiOwnedPending;\n    bytes32[] internal m_multiOwnedPendingIndex;\n}\n\ncontract ERC20Basic {\n  uint256 public totalSupply;\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}\n\ncontract BurnableToken is BasicToken {\n\n    event Burn(address indexed from, uint256 amount);\n\n    /**\n     * Function to burn msg.sender's tokens.\n     *\n     * @param _amount amount of tokens to burn\n     *\n     * @return boolean that indicates if the operation was successful\n     */\n    function burn(uint256 _amount)\n        public\n        returns (bool)\n    {\n        address from = msg.sender;\n\n        require(_amount > 0);\n        require(_amount <= balances[from]);\n\n        totalSupply = totalSupply.sub(_amount);\n        balances[from] = balances[from].sub(_amount);\n        Burn(from, _amount);\n        Transfer(from, address(0), _amount);\n\n        return true;\n    }\n}\n\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\ncontract TokenWithApproveAndCallMethod is StandardToken {\n\n    /**\n     * @notice Approves spending tokens and immediately triggers token recipient logic.\n     *\n     * @param _spender contract which supports IApprovalRecipient and allowed to receive tokens\n     * @param _value amount of tokens approved to be spent\n     * @param _extraData any extra data which to be provided to the _spender\n     *\n     * By invoking this utility function token holder could do two things in one transaction: approve spending his\n     * tokens and execute some external contract which spends them on token holder's behalf.\n     * It can't be known if _spender's invocation succeed or not.\n     * This function will throw if approval failed.\n     */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public {\n        require(approve(_spender, _value));\n        IApprovalRecipient(_spender).receiveApproval(msg.sender, _value, _extraData);\n    }\n}\n\ncontract SmartzToken is ArgumentsChecker, multiowned, BurnableToken, StandardToken, TokenWithApproveAndCallMethod {\n\n    /// @title Unit of frozen tokens - tokens which can't be spent until certain conditions is met.\n    struct FrozenCell {\n        /// @notice amount of frozen tokens\n        uint amount;\n\n        /// @notice until this unix time the cell is considered frozen\n        uint128 thawTS;\n\n        /// @notice is KYC required for a token holder to spend this cell?\n        uint128 isKYCRequired;\n    }\n\n\n    // MODIFIERS\n\n    modifier onlySale(address account) {\n        require(isSale(account));\n        _;\n    }\n\n    modifier validUnixTS(uint ts) {\n        require(ts >= 1522046326 && ts <= 1800000000);\n        _;\n    }\n\n    modifier checkTransferInvariant(address from, address to) {\n        uint initial = balanceOf(from).add(balanceOf(to));\n        _;\n        assert(balanceOf(from).add(balanceOf(to)) == initial);\n    }\n\n    modifier privilegedAllowed {\n        require(m_allowPrivileged);\n        _;\n    }\n\n\n    // PUBLIC FUNCTIONS\n\n    /**\n     * @notice Constructs token.\n     *\n     * Initial owners have power over the token contract only during bootstrap phase (early investments and token\n     * sales). To be precise, the owners can set KYC provider and sales (which can freeze transfered tokens) during\n     * bootstrap phase. After final token sale any control over the token removed by issuing disablePrivileged call.\n     */\n    function SmartzToken()\n        public\n        payable\n        multiowned(getInitialOwners(), 2)\n    {\n        if (0 != 150000000000000000000000000) {\n            totalSupply = 150000000000000000000000000;\n            balances[msg.sender] = totalSupply;\n            Transfer(address(0), msg.sender, totalSupply);\n        }\n\n\ntotalSupply = totalSupply.add(0);\n\n        address(0xaacf78f8e1fbdcf7d941e80ff8b817be1f054af4).transfer(300000000000000000 wei);\n    }\n\n    function getInitialOwners() private pure returns (address[]) {\n        address[] memory result = new address[](3);\nresult[0] = address(0x4ff9A68a832398c6b013633BB5682595ebb7B92E);\nresult[1] = address(0xE4074bB7bD4828bAeD9d2beCe1e386408428dfB7);\nresult[2] = address(0xAACf78F8e1fbDcf7d941E80Ff8B817BE1F054Af4);\n        return result;\n    }\n\n    /**\n     * @notice Version of balanceOf() which includes all frozen tokens.\n     *\n     * @param _owner the address to query the balance of\n     *\n     * @return an uint256 representing the amount owned by the passed address\n     */\n    function balanceOf(address _owner) public view returns (uint256) {\n        uint256 balance = balances[_owner];\n\n        for (uint cellIndex = 0; cellIndex < frozenBalances[_owner].length; ++cellIndex) {\n            balance = balance.add(frozenBalances[_owner][cellIndex].amount);\n        }\n\n        return balance;\n    }\n\n    /**\n     * @notice Version of balanceOf() which includes only currently spendable tokens.\n     *\n     * @param _owner the address to query the balance of\n     *\n     * @return an uint256 representing the amount spendable by the passed address\n     */\n    function availableBalanceOf(address _owner) public view returns (uint256) {\n        uint256 balance = balances[_owner];\n\n        for (uint cellIndex = 0; cellIndex < frozenBalances[_owner].length; ++cellIndex) {\n            if (isSpendableFrozenCell(_owner, cellIndex))\n                balance = balance.add(frozenBalances[_owner][cellIndex].amount);\n        }\n\n        return balance;\n    }\n\n    /**\n     * @notice Standard transfer() overridden to have a chance to thaw sender's tokens.\n     *\n     * @param _to the address to transfer to\n     * @param _value the amount to be transferred\n     *\n     * @return true iff operation was successfully completed\n     */\n    function transfer(address _to, uint256 _value)\n        public\n        payloadSizeIs(2 * 32)\n        returns (bool)\n    {\n        thawSomeTokens(msg.sender, _value);\n        return super.transfer(_to, _value);\n    }\n\n    /**\n     * @notice Standard transferFrom overridden to have a chance to thaw sender's tokens.\n     *\n     * @param _from address the address which you want to send tokens from\n     * @param _to address the address which you want to transfer to\n     * @param _value uint256 the amount of tokens to be transferred\n     *\n     * @return true iff operation was successfully completed\n     */\n    function transferFrom(address _from, address _to, uint256 _value)\n        public\n        payloadSizeIs(3 * 32)\n        returns (bool)\n    {\n        thawSomeTokens(_from, _value);\n        return super.transferFrom(_from, _to, _value);\n    }\n\n\n    /**\n     * Function to burn msg.sender's tokens. Overridden to have a chance to thaw sender's tokens.\n     *\n     * @param _amount amount of tokens to burn\n     *\n     * @return boolean that indicates if the operation was successful\n     */\n    function burn(uint256 _amount)\n        public\n        payloadSizeIs(1 * 32)\n        returns (bool)\n    {\n        thawSomeTokens(msg.sender, _amount);\n        return super.burn(_amount);\n    }\n\n\n    // INFORMATIONAL FUNCTIONS (VIEWS)\n\n    /**\n     * @notice Number of frozen cells of an account.\n     *\n     * @param owner account address\n     *\n     * @return number of frozen cells\n     */\n    function frozenCellCount(address owner) public view returns (uint) {\n        return frozenBalances[owner].length;\n    }\n\n    /**\n     * @notice Retrieves information about account frozen tokens.\n     *\n     * @param owner account address\n     * @param index index of so-called frozen cell from 0 (inclusive) up to frozenCellCount(owner) exclusive\n     *\n     * @return amount amount of tokens frozen in this cell\n     * @return thawTS unix timestamp at which tokens'll become available\n     * @return isKYCRequired it's required to pass KYC to spend tokens iff isKYCRequired is true\n     */\n    function frozenCell(address owner, uint index) public view returns (uint amount, uint thawTS, bool isKYCRequired) {\n        require(index < frozenCellCount(owner));\n\n        amount = frozenBalances[owner][index].amount;\n        thawTS = uint(frozenBalances[owner][index].thawTS);\n        isKYCRequired = decodeKYCFlag(frozenBalances[owner][index].isKYCRequired);\n    }\n\n\n    // ADMINISTRATIVE FUNCTIONS\n\n    /**\n     * @notice Sets current KYC provider of the token.\n     *\n     * @param KYCProvider address of the IKYCProvider-compatible contract\n     *\n     * Function is used only during token sale phase, before disablePrivileged() is called.\n     */\n    function setKYCProvider(address KYCProvider)\n        external\n        validAddress(KYCProvider)\n        privilegedAllowed\n        onlymanyowners(keccak256(msg.data))\n    {\n        m_KYCProvider = IKYCProvider(KYCProvider);\n    }\n\n    /**\n     * @notice Sets sale status of an account.\n     *\n     * @param account account address\n     * @param isSale is this account has access to frozen* functions\n     *\n     * Function is used only during token sale phase, before disablePrivileged() is called.\n     */\n    function setSale(address account, bool isSale)\n        external\n        validAddress(account)\n        privilegedAllowed\n        onlymanyowners(keccak256(msg.data))\n    {\n        m_sales[account] = isSale;\n    }\n\n\n    /**\n     * @notice Transfers tokens to a recipient and freezes it.\n     *\n     * @param _to account to which tokens are sent\n     * @param _value amount of tokens to send\n     * @param thawTS unix timestamp at which tokens'll become available\n     * @param isKYCRequired it's required to pass KYC to spend tokens iff isKYCRequired is true\n     *\n     * Function is used only during token sale phase and available only to sale accounts.\n     */\n    function frozenTransfer(address _to, uint256 _value, uint thawTS, bool isKYCRequired)\n        external\n        validAddress(_to)\n        validUnixTS(thawTS)\n        payloadSizeIs(4 * 32)\n        privilegedAllowed\n        onlySale(msg.sender)\n        checkTransferInvariant(msg.sender, _to)\n        returns (bool)\n    {\n        require(_value <= balances[msg.sender]);\n\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        addFrozen(_to, _value, thawTS, isKYCRequired);\n        Transfer(msg.sender, _to, _value);\n\n        return true;\n    }\n\n    /**\n     * @notice Transfers frozen tokens back.\n     *\n     * @param _from account to send tokens from\n     * @param _to account to which tokens are sent\n     * @param _value amount of tokens to send\n     * @param thawTS unix timestamp at which tokens'll become available\n     * @param isKYCRequired it's required to pass KYC to spend tokens iff isKYCRequired is true\n     *\n     * Function is used only during token sale phase to make a refunds and available only to sale accounts.\n     * _from account has to explicitly approve spending with the approve() call.\n     * thawTS and isKYCRequired parameters are required to withdraw exact \"same\" tokens (to not affect availability of\n     * other tokens of the account).\n     */\n    function frozenTransferFrom(address _from, address _to, uint256 _value, uint thawTS, bool isKYCRequired)\n        external\n        validAddress(_to)\n        validUnixTS(thawTS)\n        payloadSizeIs(5 * 32)\n        privilegedAllowed\n        //onlySale(msg.sender) too many local variables - compiler fails\n        //onlySale(_to)\n        checkTransferInvariant(_from, _to)\n        returns (bool)\n    {\n        require(isSale(msg.sender) && isSale(_to));\n        require(_value <= allowed[_from][msg.sender]);\n\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n        subFrozen(_from, _value, thawTS, isKYCRequired);\n        balances[_to] = balances[_to].add(_value);\n        Transfer(_from, _to, _value);\n\n        return true;\n    }\n\n    /// @notice Disables further use of any privileged functions like freezing tokens.\n    function disablePrivileged()\n        external\n        privilegedAllowed\n        onlymanyowners(keccak256(msg.data))\n    {\n        m_allowPrivileged = false;\n    }\n\n\n    // INTERNAL FUNCTIONS\n\n    function isSale(address account) private view returns (bool) {\n        return m_sales[account];\n    }\n\n    /**\n     * @dev Tries to find existent FrozenCell that matches (thawTS, isKYCRequired).\n     *\n     * @return index in frozenBalances[_owner] which equals to frozenBalances[_owner].length in case cell is not found\n     *\n     * Because frozen* functions are only for token sales and token sale number is limited, expecting cellIndex\n     * to be ~ 1-5 and the following loop to be O(1).\n     */\n    function findFrozenCell(address owner, uint128 thawTSEncoded, uint128 isKYCRequiredEncoded)\n        private\n        view\n        returns (uint cellIndex)\n    {\n        for (cellIndex = 0; cellIndex < frozenBalances[owner].length; ++cellIndex) {\n            FrozenCell storage checkedCell = frozenBalances[owner][cellIndex];\n            if (checkedCell.thawTS == thawTSEncoded && checkedCell.isKYCRequired == isKYCRequiredEncoded)\n                break;\n        }\n\n        assert(cellIndex <= frozenBalances[owner].length);\n    }\n\n    /// @dev Says if the given cell could be spent now\n    function isSpendableFrozenCell(address owner, uint cellIndex)\n        private\n        view\n        returns (bool)\n    {\n        FrozenCell storage cell = frozenBalances[owner][cellIndex];\n        if (uint(cell.thawTS) > getTime())\n            return false;\n\n        if (0 == cell.amount)   // already spent\n            return false;\n\n        if (decodeKYCFlag(cell.isKYCRequired) && !m_KYCProvider.isKYCPassed(owner))\n            return false;\n\n        return true;\n    }\n\n    /// @dev Internal function to increment or create frozen cell.\n    function addFrozen(address _to, uint256 _value, uint thawTS, bool isKYCRequired)\n        private\n        validAddress(_to)\n        validUnixTS(thawTS)\n    {\n        uint128 thawTSEncoded = uint128(thawTS);\n        uint128 isKYCRequiredEncoded = encodeKYCFlag(isKYCRequired);\n\n        uint cellIndex = findFrozenCell(_to, thawTSEncoded, isKYCRequiredEncoded);\n\n        // In case cell is not found - creating new.\n        if (cellIndex == frozenBalances[_to].length) {\n            frozenBalances[_to].length++;\n            targetCell = frozenBalances[_to][cellIndex];\n            assert(0 == targetCell.amount);\n\n            targetCell.thawTS = thawTSEncoded;\n            targetCell.isKYCRequired = isKYCRequiredEncoded;\n        }\n\n        FrozenCell storage targetCell = frozenBalances[_to][cellIndex];\n        assert(targetCell.thawTS == thawTSEncoded && targetCell.isKYCRequired == isKYCRequiredEncoded);\n\n        targetCell.amount = targetCell.amount.add(_value);\n    }\n\n    /// @dev Internal function to decrement frozen cell.\n    function subFrozen(address _from, uint256 _value, uint thawTS, bool isKYCRequired)\n        private\n        validUnixTS(thawTS)\n    {\n        uint cellIndex = findFrozenCell(_from, uint128(thawTS), encodeKYCFlag(isKYCRequired));\n        require(cellIndex != frozenBalances[_from].length);   // has to be found\n\n        FrozenCell storage cell = frozenBalances[_from][cellIndex];\n        require(cell.amount >= _value);\n\n        cell.amount = cell.amount.sub(_value);\n    }\n\n    /// @dev Thaws tokens of owner until enough tokens could be spent or no more such tokens found.\n    function thawSomeTokens(address owner, uint requiredAmount)\n        private\n    {\n        if (balances[owner] >= requiredAmount)\n            return;     // fast path\n\n        // Checking that our goal is reachable before issuing expensive storage modifications.\n        require(availableBalanceOf(owner) >= requiredAmount);\n\n        for (uint cellIndex = 0; cellIndex < frozenBalances[owner].length; ++cellIndex) {\n            if (isSpendableFrozenCell(owner, cellIndex)) {\n                uint amount = frozenBalances[owner][cellIndex].amount;\n                frozenBalances[owner][cellIndex].amount = 0;\n                balances[owner] = balances[owner].add(amount);\n            }\n        }\n\n        assert(balances[owner] >= requiredAmount);\n    }\n\n    /// @dev to be overridden in tests\n    function getTime() internal view returns (uint) {\n        return now;\n    }\n\n    function encodeKYCFlag(bool isKYCRequired) private pure returns (uint128) {\n        return isKYCRequired ? uint128(1) : uint128(0);\n    }\n\n    function decodeKYCFlag(uint128 isKYCRequired) private pure returns (bool) {\n        return isKYCRequired != uint128(0);\n    }\n\n\n    // FIELDS\n\n    /// @notice current KYC provider of the token\n    IKYCProvider public m_KYCProvider;\n\n    /// @notice set of sale accounts which can freeze tokens\n    mapping (address => bool) public m_sales;\n\n    /// @notice frozen tokens\n    mapping (address => FrozenCell[]) public frozenBalances;\n\n    /// @notice allows privileged functions (token sale phase)\n    bool public m_allowPrivileged = true;\n\n\n    // CONSTANTS\n\n    string public constant name = 'Smartz token';\n    string public constant symbol = 'SMR';\n    uint8 public constant decimals = 18;\n}",
  "bytecode": "606060405261010b805460ff191660011790556200002a640100000000620028666200023582021704565b60026000806000845160008111801562000045575060fa8111155b15156200005157600080fd5b848651600082118015620000655750808211155b15156200007157600080fd5b8751600155600087815595505b875186101562000146578786815181106200009557fe5b906020019060200201519450600160a060020a03851615801590620000d05750620000ce8564010000000062000af36200031f82021704565b155b1515620000dc57600080fd5b620000f86001870164010000000062001be96200033c82021704565b93508460028561010081106200010a57fe5b018054600160a060020a031916600160a060020a039283161790558516600090815261010260205260409020849055600195909501946200007e565b6200015e64010000000062001afc6200035c82021704565b50505050505050506a7c13bc4b2c133c56000000610105819055600160a060020a03331660008181526101066020526040808220849055919290917fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef91905190815260200160405180910390a361010554620001ea9060006401000000006200217e620003ae82021704565b6101055573aacf78f8e1fbdcf7d941e80ff8b817be1f054af46000670429d069189e0000604051600060405180830381858888f1935050505015156200022f57600080fd5b620003d7565b6200023f620003c5565b62000249620003c5565b6003604051805910620002595750595b90808252806020026020018201604052509050734ff9a68a832398c6b013633bb5682595ebb7b92e816000815181106200028f57fe5b600160a060020a0390921660209283029091019091015273e4074bb7bd4828baed9d2bece1e386408428dfb781600181518110620002c957fe5b600160a060020a0390921660209283029091019091015273aacf78f8e1fbdcf7d941e80ff8b817be1f054af4816002815181106200030357fe5b600160a060020a03909216602092830290910190910152905090565b600160a060020a0316600090815261010260205260408120541190565b600081158015906200034f575060fa8211155b15156200035857fe5b5090565b600154600090116200036a57fe5b60015460fa9011156200037957fe5b600254600160a060020a0316156200038d57fe5b60005415801590620003a3575060015460005411155b1515620003ac57fe5b565b600082820183811015620003be57fe5b9392505050565b60206040519081016040526000815290565b61299480620003e76000396000f3006060604052600436106101b35763ffffffff60e060020a60003504166306fdde0381146101b8578063095ea7b3146102425780631019dc5914610278578063173825d91461029e57806318160ddd146102bd5780632090b0a8146102e257806323b872dd146102f557806325d998bb1461031d5780632f54bf6e1461033c578063313ce5671461035b5780634123cb6b1461038457806342966c68146103975780634e4ab830146103ad5780635ab92022146103c057806366188463146103ea5780637065cb481461040c57806370a082311461042b5780637696f0db1461044a578063787d64e414610469578063803403141461047c57806395d89b41146104cb578063a0e67e2b146104de578063a9059cbb14610544578063b51fdb9a14610566578063b75c7dc614610585578063ba51a6df1461059b578063c24366f0146105b1578063c2cf7326146105d0578063c41a360a146105f2578063cae9ca5114610624578063d73dd62314610689578063dd62ed3e146106ab578063e2ba6ce8146106d0578063ef18e458146106e3578063f00d4b5d14610713578063f27a73ca14610738578063f450cfee14610780575b600080fd5b34156101c357600080fd5b6101cb610793565b60405160208082528190810183818151815260200191508051906020019080838360005b838110156102075780820151838201526020016101ef565b50505050905090810190601f1680156102345780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b341561024d57600080fd5b610264600160a060020a03600435166024356107ca565b604051901515815260200160405180910390f35b341561028357600080fd5b61029c600160a060020a03600435166024351515610837565b005b34156102a957600080fd5b61029c600160a060020a03600435166108b7565b34156102c857600080fd5b6102d0610a07565b60405190815260200160405180910390f35b34156102ed57600080fd5b610264610a0e565b341561030057600080fd5b610264600160a060020a0360043581169060243516604435610a18565b341561032857600080fd5b6102d0600160a060020a0360043516610a49565b341561034757600080fd5b610264600160a060020a0360043516610af3565b341561036657600080fd5b61036e610b10565b60405160ff909116815260200160405180910390f35b341561038f57600080fd5b6102d0610b15565b34156103a257600080fd5b610264600435610b1b565b34156103b857600080fd5b610264610b46565b34156103cb57600080fd5b610264600160a060020a03600435166024356044356064351515610b63565b34156103f557600080fd5b610264600160a060020a0360043516602435610cd8565b341561041757600080fd5b61029c600160a060020a0360043516610dd8565b341561043657600080fd5b6102d0600160a060020a0360043516610ef4565b341561045557600080fd5b6102d0600160a060020a0360043516610f65565b341561047457600080fd5b6102d0610f81565b341561048757600080fd5b61049e600160a060020a0360043516602435610f87565b6040519283526001608060020a039182166020840152166040808301919091526060909101905180910390f35b34156104d657600080fd5b6101cb610fd7565b34156104e957600080fd5b6104f161100e565b60405160208082528190810183818151815260200191508051906020019060200280838360005b83811015610530578082015183820152602001610518565b505050509050019250505060405180910390f35b341561054f57600080fd5b610264600160a060020a036004351660243561108c565b341561057157600080fd5b610264600160a060020a03600435166110b9565b341561059057600080fd5b61029c6004356110cf565b34156105a657600080fd5b61029c600435611198565b34156105bc57600080fd5b61029c600160a060020a0360043516611229565b34156105db57600080fd5b610264600435600160a060020a036024351661129f565b34156105fd57600080fd5b6106086004356112f4565b604051600160a060020a03909116815260200160405180910390f35b341561062f57600080fd5b61029c60048035600160a060020a03169060248035919060649060443590810190830135806020601f8201819004810201604051908101604052818152929190602084018383808284375094965061131895505050505050565b341561069457600080fd5b610264600160a060020a0360043516602435611412565b34156106b657600080fd5b6102d0600160a060020a03600435811690602435166114b8565b34156106db57600080fd5b6106086114e4565b34156106ee57600080fd5b610264600160a060020a036004358116906024351660443560643560843515156114f4565b341561071e57600080fd5b61029c600160a060020a03600435811690602435166116be565b341561074357600080fd5b61075a600160a060020a03600435166024356117e9565b604051928352602083019190915215156040808301919091526060909101905180910390f35b341561078b57600080fd5b61029c6118df565b60408051908101604052600c81527f536d6172747a20746f6b656e0000000000000000000000000000000000000000602082015281565b600160a060020a0333811660008181526101076020908152604080832094871680845294909152808220859055909291907f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b9259085905190815260200160405180910390a350600192915050565b81600160a060020a038116151561084d57600080fd5b61010b5460ff16151561085f57600080fd5b6000366040518083838082843782019150509250505060405180910390206108868161192c565b156108b157600160a060020a038416600090815261010960205260409020805460ff19168415151790555b50505050565b6000816108c381610af3565b15156108ce57600080fd5b60018054036000811180156108e4575060fa8111155b15156108ef57600080fd5b60005460018054036000821180156109075750808211155b151561091257600080fd5b6000366040518083838082843782019150509250505060405180910390206109398161192c565b156109fe57610946611afc565b61094e611b49565b600160a060020a0387166000908152610102602052604090205461097190611be9565b95506000600287610100811061098357fe5b018054600160a060020a031916600160a060020a039283161790558716600090815261010260205260408120556109b8611c07565b6109c0611afc565b7f58619076adf5bb0943d100ef88d52d7c3fd691b19d3a9071b555b651fbf418da87604051600160a060020a03909116815260200160405180910390a15b50505050505050565b6101055481565b61010b5460ff1681565b6000606036606414610a2957600080fd5b610a338584611d8e565b610a3e858585611ee5565b91505b509392505050565b600160a060020a03811660009081526101066020526040812054815b600160a060020a038416600090815261010a6020526040902054811015610ae857610a90848261205c565b15610ae057600160a060020a038416600090815261010a602052604090208054610add919083908110610abf57fe5b6000918252602090912060029091020154839063ffffffff61217e16565b91505b600101610a65565b8192505b5050919050565b600160a060020a0316600090815261010260205260408120541190565b601281565b60015481565b6000602036602414610b2c57600080fd5b610b363384611d8e565b610b3f8361218d565b9392505050565b6000610b5133610af3565b1515610b5c57600080fd5b5060015b90565b600084600160a060020a0381161515610b7b57600080fd5b83635ab895768110158015610b945750636b49d2008111155b1515610b9f57600080fd5b608036608414610bae57600080fd5b61010b5460ff161515610bc057600080fd5b33610bca8161228d565b1515610bd557600080fd5b33896000610bfa610be583610ef4565b610bee85610ef4565b9063ffffffff61217e16565b600160a060020a033316600090815261010660205260409020549091508b1115610c2357600080fd5b600160a060020a03331660009081526101066020526040902054610c4d908c63ffffffff6122ac16565b600160a060020a03331660009081526101066020526040902055610c738c8c8c8c6122be565b8b600160a060020a031633600160a060020a03166000805160206129498339815191528d60405190815260200160405180910390a36001975080610cc2610cb984610ef4565b610bee86610ef4565b14610cc957fe5b50505050505050949350505050565b600160a060020a0333811660009081526101076020908152604080832093861683529290529081205480831115610d3757600160a060020a03338116600090815261010760209081526040808320938816835292905290812055610d6f565b610d47818463ffffffff6122ac16565b600160a060020a03338116600090815261010760209081526040808320938916835292905220555b600160a060020a033381166000818152610107602090815260408083209489168084529490915290819020547f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925915190815260200160405180910390a3600191505b5092915050565b80610de281610af3565b15610dec57600080fd5b600154600101600081118015610e03575060fa8111155b1515610e0e57600080fd5b600036604051808383808284378201915050925050506040518091039020610e358161192c565b156108b157610e42611afc565b610e4a611b49565b6001805481019081905584906002906101008110610e6457fe5b018054600160a060020a031916600160a060020a0392909216919091179055600154610e8f90611be9565b600160a060020a03851660009081526101026020526040902055610eb1611afc565b7f994a936646fe87ffe4f1e469d3d6aa417d6b855598397f323de5b449f765f0c384604051600160a060020a03909116815260200160405180910390a150505050565b600160a060020a03811660009081526101066020526040812054815b600160a060020a038416600090815261010a6020526040902054811015610ae857600160a060020a038416600090815261010a602052604090208054610f5b919083908110610abf57fe5b9150600101610f10565b600160a060020a0316600090815261010a602052604090205490565b60005481565b61010a60205281600052604060002081815481101515610fa357fe5b6000918252602090912060029091020180546001909101549092506001608060020a038082169250608060020a9091041683565b60408051908101604052600381527f534d520000000000000000000000000000000000000000000000000000000000602082015281565b6110166127ac565b61101e6127ac565b60006001546040518059106110305750595b90808252806020026020018201604052509150600090505b6001548110156110865761105b816112f4565b82828151811061106757fe5b600160a060020a03909216602092830290910190910152600101611048565b50919050565b600060403660441461109d57600080fd5b6110a73384611d8e565b6110b18484612472565b949350505050565b6101096020526000908152604090205460ff1681565b600080826110dc8161255f565b15156110e757600080fd5b6110f033610af3565b15156110fb57600080fd5b61110433612574565b600085815261010360205260408120600181015492955093509084161161112a57600080fd5b611133846125a3565b81546001908101835582018054849003905561114e846125a3565b7fc7fb647e59b18047309aa15aad418e5d7ca96d173ad704f1031a2c3d7591734b3385604051600160a060020a03909216825260208201526040908101905180910390a150505050565b806001546000821180156111ac5750808211155b15156111b757600080fd5b6000366040518083838082843782019150509250505060405180910390206111de8161192c565b156108b15760008490556111f0611b49565b7facbdb084c721332ac59f9b8e392196c9eb0e4932862da8eb9beaf0dad4f550da8460405190815260200160405180910390a150505050565b80600160a060020a038116151561123f57600080fd5b61010b5460ff16151561125157600080fd5b6000366040518083838082843782019150509250505060405180910390206112788161192c565b1561129a576101088054600160a060020a031916600160a060020a0385161790555b505050565b6000826112ab8161255f565b15156112b657600080fd5b826112c081610af3565b15156112cb57600080fd5b6112d484612574565b600086815261010360205260409020600101541615159250505092915050565b6000600260018301610100811061130757fe5b0154600160a060020a031692915050565b61132283836107ca565b151561132d57600080fd5b82600160a060020a031663a2d578533384846040518463ffffffff1660e060020a0281526004018084600160a060020a0316600160a060020a0316815260200183815260200180602001828103825283818151815260200191508051906020019080838360005b838110156113ac578082015183820152602001611394565b50505050905090810190601f1680156113d95780820380516001836020036101000a031916815260200191505b50945050505050600060405180830381600087803b15156113f957600080fd5b6102c65a03f1151561140a57600080fd5b505050505050565b600160a060020a0333811660009081526101076020908152604080832093861683529290529081205461144b908363ffffffff61217e16565b600160a060020a033381166000818152610107602090815260408083209489168084529490915290819020849055919290917f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92591905190815260200160405180910390a350600192915050565b600160a060020a0391821660009081526101076020908152604080832093909416825291909152205490565b61010854600160a060020a031681565b600084600160a060020a038116151561150c57600080fd5b83635ab8957681101580156115255750636b49d2008111155b151561153057600080fd5b60a03660a41461153f57600080fd5b61010b5460ff16151561155157600080fd5b88886000611561610be583610ef4565b905061156c3361228d565b801561157c575061157c8b61228d565b151561158757600080fd5b600160a060020a03808d1660009081526101076020908152604080832033909416835292905220548a11156115bb57600080fd5b600160a060020a03808d1660009081526101076020908152604080832033909416835292905220546115f3908b63ffffffff6122ac16565b600160a060020a03808e1660009081526101076020908152604080832033909416835292905220556116278c8b8b8b6125f1565b600160a060020a038b1660009081526101066020526040902054611651908b63ffffffff61217e16565b600160a060020a03808d1660008181526101066020526040908190209390935591908e1690600080516020612949833981519152908d905190815260200160405180910390a360019650806116a8610cb984610ef4565b146116af57fe5b50505050505095945050505050565b6000826116ca81610af3565b15156116d557600080fd5b826116df81610af3565b156116e957600080fd5b6000366040518083838082843782019150509250505060405180910390206117108161192c565b1561140a5761171d611afc565b611725611b49565b600160a060020a0386166000908152610102602052604090205461174890611be9565b935084600285610100811061175957fe5b018054600160a060020a031916600160a060020a039283161790558681166000908152610102602052604080822082905591871681522084905561179b611afc565b7fb532073b38c83145e3e5135377a08bf9aab55bc0fd7c1179cd4fb995d2a5159c8686604051600160a060020a039283168152911660208201526040908101905180910390a1505050505050565b60008060006117f785610f65565b841061180257600080fd5b600160a060020a038516600090815261010a6020526040902080548590811061182757fe5b60009182526020808320600290920290910154600160a060020a038816835261010a90915260409091208054919450908590811061186157fe5b6000918252602080832060016002909302019190910154600160a060020a038816835261010a909152604090912080546001608060020a0390921693506118d691869081106118ac57fe5b906000526020600020906002020160010160109054906101000a90046001608060020a03166126b9565b90509250925092565b61010b5460ff1615156118f157600080fd5b6000366040518083838082843782019150509250505060405180910390206119188161192c565b156119295761010b805460ff191690555b50565b600080600061193a33610af3565b151561194557600080fd5b61010454610200141561195a5761195a611b49565b60008481526101036020526040902091506119748461255f565b15156119c75760008054835560018084019190915561010480549161199b919083016127be565b60028301819055610104805486929081106119b257fe5b6000918252602090912001556119c7846125a3565b6119d033612574565b90508082600101541660001415610aec578154600090116119ed57fe5b815460011415611a96576000848152610103602052604090206002015461010480549091908110611a1a57fe5b600091825260208083209091018290558582526101039052604080822082815560018101839055600201919091557f367569357efc39b74a025c4ba1d64068b2b574e3b0d081c48d42f7feeca4cd16903390869051600160a060020a03909216825260208201526040908101905180910390a160019250610aec565b815460001901825560018201805482179055611ab1846125a3565b7fe1c52dc63b719ade82e8bea94cc41a0d5d28e4aaf536adb5e9cccc9ff8c1aeda3385604051600160a060020a03909216825260208201526040908101905180910390a15050919050565b60015460009011611b0957fe5b60015460fa901115611b1757fe5b600254600160a060020a031615611b2a57fe5b60005415801590611b3f575060015460005411155b1515611b4757fe5b565b600080611b5533610af3565b1515611b6057600080fd5b50506101045460005b81811015611bd857610104805482908110611b8057fe5b60009182526020909120015415611bd057610103600061010483815481101515611ba657fe5b60009182526020808320909101548352820192909252604001812081815560018101829055600201555b600101611b69565b611be561010460006127e2565b5050565b60008115801590611bfb575060fa8211155b1515611c0357fe5b5090565b60015b600154811015611929575b60015481108015611c3d57506002816101008110611c2f57fe5b0154600160a060020a031615155b15611c4a57600101611c15565b60018054118015611c7457506001546002906101008110611c6757fe5b0154600160a060020a0316155b15611c885760018054600019019055611c4a565b60015481108015611cb357506001546002906101008110611ca557fe5b0154600160a060020a031615155b8015611cd557506002816101008110611cc857fe5b0154600160a060020a0316155b15611d89576001546002906101008110611ceb57fe5b0154600160a060020a03166002826101008110611d0457fe5b018054600160a060020a031916600160a060020a03929092169190911790558061010260006002836101008110611d3757fe5b0154600160a060020a0316815260208101919091526040016000908120919091556001546002906101008110611d6957fe5b018054600160a060020a031916600160a060020a03929092169190911790555b611c0a565b600160a060020a038216600090815261010660205260408120548190839010611db6576108b1565b82611dc085610a49565b1015611dcb57600080fd5b600091505b600160a060020a038416600090815261010a6020526040902054821015611ec157611dfb848361205c565b15611eb657600160a060020a038416600090815261010a60205260409020805483908110611e2557fe5b60009182526020808320600290920290910154600160a060020a038716835261010a9091526040822080549193509084908110611e5e57fe5b60009182526020808320600290920290910192909255600160a060020a03861681526101069091526040902054611e9b908263ffffffff61217e16565b600160a060020a038516600090815261010660205260409020555b816001019150611dd0565b600160a060020a03841660009081526101066020526040902054839010156108b157fe5b6000600160a060020a0383161515611efc57600080fd5b600160a060020a03841660009081526101066020526040902054821115611f2257600080fd5b600160a060020a038085166000908152610107602090815260408083203390941683529290522054821115611f5657600080fd5b600160a060020a03841660009081526101066020526040902054611f80908363ffffffff6122ac16565b600160a060020a03808616600090815261010660205260408082209390935590851681522054611fb6908363ffffffff61217e16565b600160a060020a038085166000908152610106602090815260408083209490945587831682526101078152838220339093168252919091522054612000908363ffffffff6122ac16565b600160a060020a0380861660008181526101076020908152604080832033861684529091529081902093909355908516916000805160206129498339815191529085905190815260200160405180910390a35060019392505050565b600160a060020a038216600090815261010a6020526040812080548291908490811061208457fe5b9060005260206000209060020201905061209c6126c7565b60018201546001608060020a031611156120b95760009150610dd1565b805415156120ca5760009150610dd1565b60018101546120e890608060020a90046001608060020a03166126b9565b8015612166575061010854600160a060020a031663b35be68c8560006040516020015260405160e060020a63ffffffff8416028152600160a060020a039091166004820152602401602060405180830381600087803b151561214957600080fd5b6102c65a03f1151561215a57600080fd5b50505060405180519050155b156121745760009150610dd1565b5060019392505050565b600082820183811015610b3f57fe5b60003381831161219c57600080fd5b600160a060020a038116600090815261010660205260409020548311156121c257600080fd5b610105546121d6908463ffffffff6122ac16565b61010555600160a060020a03811660009081526101066020526040902054612204908463ffffffff6122ac16565b600160a060020a038216600081815261010660205260409081902092909255907fcc16f5dbb4873280815c1ee09dbd06736cffcc184412cf7a71a0fdb75d397ca59085905190815260200160405180910390a26000600160a060020a0382166000805160206129498339815191528560405190815260200160405180910390a350600192915050565b600160a060020a03166000908152610109602052604090205460ff1690565b6000828211156122b857fe5b50900390565b600080808087600160a060020a03811615156122d957600080fd5b86635ab8957681101580156122f25750636b49d2008111155b15156122fd57600080fd5b879550612309876126cb565b94506123168a87876126e2565b600160a060020a038b16600090815261010a60205260409020549094508414156123dd57600160a060020a038a16600090815261010a602052604090208054906123639060018301612800565b50600160a060020a038a16600090815261010a6020526040902080548590811061238957fe5b600091825260209091206002909102018054909350156123a557fe5b6001830180546001608060020a03878116608060020a02818a166fffffffffffffffffffffffffffffffff1990931692909217161790555b600160a060020a038a16600090815261010a6020526040902080548590811061240257fe5b6000918252602090912060029091020160018101549093506001608060020a03878116911614801561244a575060018301546001608060020a03868116608060020a90920416145b151561245257fe5b8254612464908a63ffffffff61217e16565b909255505050505050505050565b6000600160a060020a038316151561248957600080fd5b600160a060020a033316600090815261010660205260409020548211156124af57600080fd5b600160a060020a033316600090815261010660205260409020546124d9908363ffffffff6122ac16565b600160a060020a0333811660009081526101066020526040808220939093559085168152205461250f908363ffffffff61217e16565b600160a060020a038085166000818152610106602052604090819020939093559133909116906000805160206129498339815191529085905190815260200160405180910390a350600192915050565b60009081526101036020526040902054151590565b600160a060020a03811660009081526101026020526040812054819061259990611be9565b60020a9392505050565b600081815261010360205260409020805415156125bc57fe5b6002810154610104805484929081106125d157fe5b600091825260209091200154146125e457fe5b60005481541115611be557fe5b60008083635ab89576811015801561260d5750636b49d2008111155b151561261857600080fd5b61262b8786612626876126cb565b6126e2565b600160a060020a038816600090815261010a602052604090205490935083141561265457600080fd5b600160a060020a038716600090815261010a6020526040902080548490811061267957fe5b906000526020600020906002020191508582600001541015151561269c57600080fd5b81546126ae908763ffffffff6122ac16565b909155505050505050565b6001608060020a0316151590565b4290565b6000816126d95760006126dc565b60015b92915050565b6000805b600160a060020a038516600090815261010a602052604090205482101561278957600160a060020a038516600090815261010a6020526040902080548390811061272c57fe5b6000918252602090912060029091020160018101549091506001608060020a038581169116148015612774575060018101546001608060020a03848116608060020a90920416145b1561277e57612789565b8160010191506126e6565b600160a060020a038516600090815261010a6020526040902054821115610a4157fe5b60206040519081016040526000815290565b81548183558181151161129a5760008381526020902061129a91810190830161282c565b5080546000825590600052602060002090810190611929919061282c565b81548183558181151161129a5760020281600202836000526020600020918201910161129a9190612846565b610b6091905b80821115611c035760008155600101612832565b610b6091905b80821115611c03576000808255600182015560020161284c565b61286e6127ac565b6128766127ac565b60036040518059106128855750595b90808252806020026020018201604052509050734ff9a68a832398c6b013633bb5682595ebb7b92e816000815181106128ba57fe5b600160a060020a0390921660209283029091019091015273e4074bb7bd4828baed9d2bece1e386408428dfb7816001815181106128f357fe5b600160a060020a0390921660209283029091019091015273aacf78f8e1fbdcf7d941e80ff8b817be1f054af48160028151811061292c57fe5b600160a060020a039092166020928302909101909101529050905600ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa165627a7a7230582035b1ef3b969dd6707adb6b616aabbafa2971de1f46d7ace2103ecbc2b214f1780029"
}