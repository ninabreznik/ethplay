{
  "address": "0x4ffadba9d6ab927d445af9933045a5110f78cff9",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "Blockpit: Token Sale",
  "contractName": "AssetTokenCrowdsaleT001",
  "compilerVersion": "v0.5.0+commit.1d4f565a",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2019-03-28\n*/\n\npragma solidity ^0.5.0;\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n\n/**\n * @title SafeMath\n * @dev Unsigned math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    /**\n    * @dev Multiplies two unsigned integers, reverts on overflow.\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n    * @dev Adds two unsigned integers, reverts on overflow.\n    */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n    * reverts when dividing by zero.\n    */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @return the address of the owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner());\n        _;\n    }\n\n    /**\n     * @return true if `msg.sender` is the owner of the contract.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Allows the current owner to relinquish control of the contract.\n     * @notice Renouncing to ownership will leave the contract without an owner.\n     * It will not be possible to call the functions with the `onlyOwner`\n     * modifier anymore.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ninterface IERC20 {\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address who) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n * Originally based on code by FirstBlood:\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n *\n * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\n * all accounts just by listening to said events. Note that this isn't required by the specification, and other\n * compliant implementations may not do it.\n */\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowed;\n\n    uint256 private _totalSupply;\n\n    /**\n    * @dev Total number of tokens in existence\n    */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n    * @dev Gets the balance of the specified address.\n    * @param owner The address to query the balance of.\n    * @return An uint256 representing the amount owned by the passed address.\n    */\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\n\n    /**\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n     * @param owner address The address which owns the funds.\n     * @param spender address The address which will spend the funds.\n     * @return A uint256 specifying the amount of tokens still available for the spender.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\n\n    /**\n    * @dev Transfer token for a specified address\n    * @param to The address to transfer to.\n    * @param value The amount to be transferred.\n    */\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     */\n    function approve(address spender, uint256 value) public returns (bool) {\n        require(spender != address(0));\n\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev Transfer tokens from one address to another.\n     * Note that while this function emits an Approval event, this is not required as per the specification,\n     * and other compliant implementations may not emit the event.\n     * @param from address The address which you want to send tokens from\n     * @param to address The address which you want to transfer to\n     * @param value uint256 the amount of tokens to be transferred\n     */\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n        _transfer(from, to, value);\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\n        return true;\n    }\n\n    /**\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\n     * approve should be called when allowed_[_spender] == 0. To increment\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * Emits an Approval event.\n     * @param spender The address which will spend the funds.\n     * @param addedValue The amount of tokens to increase the allowance by.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0));\n\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n    /**\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n     * approve should be called when allowed_[_spender] == 0. To decrement\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * Emits an Approval event.\n     * @param spender The address which will spend the funds.\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        require(spender != address(0));\n\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n    /**\n    * @dev Transfer token for a specified addresses\n    * @param from The address to transfer from.\n    * @param to The address to transfer to.\n    * @param value The amount to be transferred.\n    */\n    function _transfer(address from, address to, uint256 value) internal {\n        require(to != address(0));\n\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Internal function that mints an amount of the token and assigns it to\n     * an account. This encapsulates the modification of balances such that the\n     * proper events are emitted.\n     * @param account The account that will receive the created tokens.\n     * @param value The amount that will be created.\n     */\n    function _mint(address account, uint256 value) internal {\n        require(account != address(0));\n\n        _totalSupply = _totalSupply.add(value);\n        _balances[account] = _balances[account].add(value);\n        emit Transfer(address(0), account, value);\n    }\n\n    /**\n     * @dev Internal function that burns an amount of the token of a given\n     * account.\n     * @param account The account whose tokens will be burnt.\n     * @param value The amount that will be burnt.\n     */\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0));\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    /**\n     * @dev Internal function that burns an amount of the token of a given\n     * account, deducting from the sender's allowance for said account. Uses the\n     * internal burn function.\n     * Emits an Approval event (reflecting the reduced allowance).\n     * @param account The account whose tokens will be burnt.\n     * @param value The amount that will be burnt.\n     */\n    function _burnFrom(address account, uint256 value) internal {\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\n        _burn(account, value);\n        emit Approval(account, msg.sender, _allowed[account][msg.sender]);\n    }\n}\n\n// File: contracts/crowdsale/interfaces/IGlobalIndexControllerLocation.sol\n\ninterface IGlobalIndexControllerLocation {\n    function getControllerAddress() external view returns (address);\n}\n\n// File: contracts/crowdsale/interfaces/ICRWDControllerTokenSale.sol\n\ninterface ICRWDControllerTokenSale {\n    function buyFromCrowdsale(address _to, uint256 _amountInWei) external returns (uint256 _tokensCreated, uint256 _overpaidRefund);\n    function assignFromCrowdsale(address _to, uint256 _tokenAmount, bytes8 _tag) external returns (uint256 _tokensCreated);\n    function calcTokensForEth(uint256 _amountInWei) external view returns (uint256 _tokensWouldBeCreated);\n}\n\n// File: openzeppelin-solidity/contracts/ownership/Secondary.sol\n\n/**\n * @title Secondary\n * @dev A Secondary contract can only be used by its primary account (the one that created it)\n */\ncontract Secondary {\n    address private _primary;\n\n    event PrimaryTransferred(\n        address recipient\n    );\n\n    /**\n     * @dev Sets the primary account to the one that is creating the Secondary contract.\n     */\n    constructor () internal {\n        _primary = msg.sender;\n        emit PrimaryTransferred(_primary);\n    }\n\n    /**\n     * @dev Reverts if called from any account other than the primary.\n     */\n    modifier onlyPrimary() {\n        require(msg.sender == _primary);\n        _;\n    }\n\n    /**\n     * @return the address of the primary.\n     */\n    function primary() public view returns (address) {\n        return _primary;\n    }\n\n    /**\n     * @dev Transfers contract to a new primary.\n     * @param recipient The address of new primary.\n     */\n    function transferPrimary(address recipient) public onlyPrimary {\n        require(recipient != address(0));\n        _primary = recipient;\n        emit PrimaryTransferred(_primary);\n    }\n}\n\n// File: openzeppelin-solidity/contracts/payment/escrow/Escrow.sol\n\n/**\n * @title Escrow\n * @dev Base escrow contract, holds funds designated for a payee until they\n * withdraw them.\n * @dev Intended usage: This contract (and derived escrow contracts) should be a\n * standalone contract, that only interacts with the contract that instantiated\n * it. That way, it is guaranteed that all Ether will be handled according to\n * the Escrow rules, and there is no need to check for payable functions or\n * transfers in the inheritance tree. The contract that uses the escrow as its\n * payment method should be its primary, and provide public methods redirecting\n * to the escrow's deposit and withdraw.\n */\ncontract Escrow is Secondary {\n    using SafeMath for uint256;\n\n    event Deposited(address indexed payee, uint256 weiAmount);\n    event Withdrawn(address indexed payee, uint256 weiAmount);\n\n    mapping(address => uint256) private _deposits;\n\n    function depositsOf(address payee) public view returns (uint256) {\n        return _deposits[payee];\n    }\n\n    /**\n    * @dev Stores the sent amount as credit to be withdrawn.\n    * @param payee The destination address of the funds.\n    */\n    function deposit(address payee) public onlyPrimary payable {\n        uint256 amount = msg.value;\n        _deposits[payee] = _deposits[payee].add(amount);\n\n        emit Deposited(payee, amount);\n    }\n\n    /**\n    * @dev Withdraw accumulated balance for a payee.\n    * @param payee The address whose funds will be withdrawn and transferred to.\n    */\n    function withdraw(address payable payee) public onlyPrimary {\n        uint256 payment = _deposits[payee];\n\n        _deposits[payee] = 0;\n\n        payee.transfer(payment);\n\n        emit Withdrawn(payee, payment);\n    }\n}\n\n// File: openzeppelin-solidity/contracts/payment/escrow/ConditionalEscrow.sol\n\n/**\n * @title ConditionalEscrow\n * @dev Base abstract escrow to only allow withdrawal if a condition is met.\n * @dev Intended usage: See Escrow.sol. Same usage guidelines apply here.\n */\ncontract ConditionalEscrow is Escrow {\n    /**\n    * @dev Returns whether an address is allowed to withdraw their funds. To be\n    * implemented by derived contracts.\n    * @param payee The destination address of the funds.\n    */\n    function withdrawalAllowed(address payee) public view returns (bool);\n\n    function withdraw(address payable payee) public {\n        require(withdrawalAllowed(payee));\n        super.withdraw(payee);\n    }\n}\n\n// File: openzeppelin-solidity/contracts/payment/escrow/RefundEscrow.sol\n\n/**\n * @title RefundEscrow\n * @dev Escrow that holds funds for a beneficiary, deposited from multiple\n * parties.\n * @dev Intended usage: See Escrow.sol. Same usage guidelines apply here.\n * @dev The primary account (that is, the contract that instantiates this\n * contract) may deposit, close the deposit period, and allow for either\n * withdrawal by the beneficiary, or refunds to the depositors. All interactions\n * with RefundEscrow will be made through the primary contract. See the\n * RefundableCrowdsale contract for an example of RefundEscrow’s use.\n */\ncontract RefundEscrow is ConditionalEscrow {\n    enum State { Active, Refunding, Closed }\n\n    event RefundsClosed();\n    event RefundsEnabled();\n\n    State private _state;\n    address payable private _beneficiary;\n\n    /**\n     * @dev Constructor.\n     * @param beneficiary The beneficiary of the deposits.\n     */\n    constructor (address payable beneficiary) public {\n        require(beneficiary != address(0));\n        _beneficiary = beneficiary;\n        _state = State.Active;\n    }\n\n    /**\n     * @return the current state of the escrow.\n     */\n    function state() public view returns (State) {\n        return _state;\n    }\n\n    /**\n     * @return the beneficiary of the escrow.\n     */\n    function beneficiary() public view returns (address) {\n        return _beneficiary;\n    }\n\n    /**\n     * @dev Stores funds that may later be refunded.\n     * @param refundee The address funds will be sent to if a refund occurs.\n     */\n    function deposit(address refundee) public payable {\n        require(_state == State.Active);\n        super.deposit(refundee);\n    }\n\n    /**\n     * @dev Allows for the beneficiary to withdraw their funds, rejecting\n     * further deposits.\n     */\n    function close() public onlyPrimary {\n        require(_state == State.Active);\n        _state = State.Closed;\n        emit RefundsClosed();\n    }\n\n    /**\n     * @dev Allows for refunds to take place, rejecting further deposits.\n     */\n    function enableRefunds() public onlyPrimary {\n        require(_state == State.Active);\n        _state = State.Refunding;\n        emit RefundsEnabled();\n    }\n\n    /**\n     * @dev Withdraws the beneficiary's funds.\n     */\n    function beneficiaryWithdraw() public {\n        require(_state == State.Closed);\n        _beneficiary.transfer(address(this).balance);\n    }\n\n    /**\n     * @dev Returns whether refundees can withdraw their deposits (be refunded). The overriden function receives a\n     * 'payee' argument, but we ignore it here since the condition is global, not per-payee.\n     */\n    function withdrawalAllowed(address) public view returns (bool) {\n        return _state == State.Refunding;\n    }\n}\n\n// File: contracts/crowdsale/library/CrowdsaleL.sol\n\n/*\n    Copyright 2018, CONDA\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n/** @title CrowdsaleL library. */\nlibrary CrowdsaleL {\n    using SafeMath for uint256;\n\n///////////////////\n// Structs\n///////////////////\n\n    /// @dev All crowdsale states.\n    enum State { Draft, Started, Ended, Finalized, Refunding, Closed }\n\n    struct Data {\n        // The token being sold type ERC20\n        address token;\n\n        // status of crowdsale\n        State state;\n\n        // the max cap of tokens being sold\n        uint256 cap;\n\n        // the start time of crowdsale.\n        uint256 startTime;\n        \n        // the end time of crowdsale\n        uint256 endTime;\n\n        // address where funds are collected\n        address payable wallet;\n\n        // the global index holding contract addresses\n        IGlobalIndexControllerLocation globalIndex;\n\n        // amount of tokens raised by money in all allowed currencies\n        uint256 tokensRaised;\n    }\n\n    struct Roles {\n        // can assign tokens on off-chain payments\n        address tokenAssignmentControl;\n\n        // role that can rescue accidentally sent tokens\n        address tokenRescueControl;\n    }\n\n///////////////////\n// Functions\n///////////////////\n\n    /// @notice Initialize function for initial setup (during construction).\n    /// @param _assetToken The asset token being sold.\n    function init(Data storage _self, address _assetToken) public {\n        _self.token = _assetToken;\n        _self.state = State.Draft;\n    }\n\n    /// @notice Confiugure function for setup (during negotiations).\n    /// @param _wallet beneficiary wallet on successful crowdsale.\n    /// @param _globalIndex the contract holding current contract addresses.\n    function configure(\n        Data storage _self, \n        address payable _wallet, \n        address _globalIndex)\n    public \n    {\n        require(_self.state == CrowdsaleL.State.Draft, \"not draft state\");\n        require(_wallet != address(0), \"wallet zero addr\");\n        require(_globalIndex != address(0), \"globalIdx zero addr\");\n\n        _self.wallet = _wallet;\n        _self.globalIndex = IGlobalIndexControllerLocation(_globalIndex);\n\n        emit CrowdsaleConfigurationChanged(_wallet, _globalIndex);\n    }\n\n    /// @notice Set roles/operators.\n    /// @param _tokenAssignmentControl token assignment control (off-chain payment).\n    /// @param _tokenRescueControl token rescue control (accidentally assigned tokens).\n    function setRoles(Roles storage _self, address _tokenAssignmentControl, address _tokenRescueControl) public {\n        require(_tokenAssignmentControl != address(0), \"addr0\");\n        require(_tokenRescueControl != address(0), \"addr0\");\n        \n        _self.tokenAssignmentControl = _tokenAssignmentControl;\n        _self.tokenRescueControl = _tokenRescueControl;\n\n        emit RolesChanged(msg.sender, _tokenAssignmentControl, _tokenRescueControl);\n    }\n\n    /// @notice gets current controller address.\n    function getControllerAddress(Data storage _self) public view returns (address) {\n        return IGlobalIndexControllerLocation(_self.globalIndex).getControllerAddress();\n    }\n\n    /// @dev gets controller with interface for internal use.\n    function getController(Data storage _self) private view returns (ICRWDControllerTokenSale) {\n        return ICRWDControllerTokenSale(getControllerAddress(_self));\n    }\n\n    /// @notice set cap.\n    /// @param _cap token cap of tokens being sold.\n    function setCap(Data storage _self, uint256 _cap) public {\n        // require(requireActiveOrDraftState(_self), \"require active/draft\"); // No! Could have been changed by AT owner...\n        // require(_cap > 0, \"cap 0\"); // No! Decided by AssetToken owner...\n        _self.cap = _cap;\n    }\n\n    /// @notice Low level token purchase function with ether.\n    /// @param _beneficiary who receives tokens.\n    /// @param _investedAmount the invested ETH amount.\n    function buyTokensFor(Data storage _self, address _beneficiary, uint256 _investedAmount) \n    public \n    returns (uint256)\n    {\n        require(validPurchasePreCheck(_self), \"invalid purchase precheck\");\n\n        (uint256 tokenAmount, uint256 overpaidRefund) = getController(_self).buyFromCrowdsale(_beneficiary, _investedAmount);\n\n        if(tokenAmount == 0) {\n            // Special handling full refund if too little ETH (could be small drift depending on off-chain API accuracy)\n            overpaidRefund = _investedAmount;\n        }\n\n        require(validPurchasePostCheck(_self, tokenAmount), \"invalid purchase postcheck\");\n        _self.tokensRaised = _self.tokensRaised.add(tokenAmount);\n\n        emit TokenPurchase(msg.sender, _beneficiary, tokenAmount, overpaidRefund, \"ETH\");\n\n        return overpaidRefund;\n    }\n\n    /// @dev Fails if not active or draft state\n    function requireActiveOrDraftState(Data storage _self) public view returns (bool) {\n        require((_self.state == State.Draft) || (_self.state == State.Started), \"only active or draft state\");\n\n        return true;\n    }\n\n    /// @notice Valid start basic logic.\n    /// @dev In contract could be extended logic e.g. checking goal)\n    function validStart(Data storage _self) public view returns (bool) {\n        require(_self.wallet != address(0), \"wallet is zero addr\");\n        require(_self.token != address(0), \"token is zero addr\");\n        require(_self.cap > 0, \"cap is 0\");\n        require(_self.startTime != 0, \"time not set\");\n        require(now >= _self.startTime, \"too early\");\n\n        return true;\n    }\n\n    /// @notice Set the timeframe.\n    /// @param _startTime the start time of crowdsale.\n    /// @param _endTime the end time of crowdsale.\n    function setTime(Data storage _self, uint256 _startTime, uint256 _endTime) public\n    {\n        _self.startTime = _startTime;\n        _self.endTime = _endTime;\n\n        emit CrowdsaleTimeChanged(_startTime, _endTime);\n    }\n\n    /// @notice crowdsale has ended check.\n    /// @dev Same code if goal is used.\n    /// @return true if crowdsale event has ended\n    function hasEnded(Data storage _self) public view returns (bool) {\n        bool capReached = _self.tokensRaised >= _self.cap; \n        bool endStateReached = (_self.state == CrowdsaleL.State.Ended || _self.state == CrowdsaleL.State.Finalized || _self.state == CrowdsaleL.State.Closed || _self.state == CrowdsaleL.State.Refunding);\n        \n        return endStateReached || capReached || now > _self.endTime;\n    }\n\n    /// @notice Set from finalized to state closed.\n    /// @dev Must be called to close the crowdsale manually\n    function closeCrowdsale(Data storage _self) public {\n        require((_self.state == State.Finalized) || (_self.state == State.Refunding), \"state\");\n\n        _self.state = State.Closed;\n    }\n\n    /// @notice Checks if valid purchase before other ecosystem contracts roundtrip (fail early).\n    /// @return true if the transaction can buy tokens\n    function validPurchasePreCheck(Data storage _self) private view returns (bool) {\n        require(_self.state == State.Started, \"not in state started\");\n        bool withinPeriod = now >= _self.startTime && _self.endTime >= now;\n        require(withinPeriod, \"not within period\");\n\n        return true;\n    }\n\n    /// @notice Checks if valid purchase after other ecosystem contracts roundtrip (double check).\n    /// @return true if the transaction can buy tokens\n    function validPurchasePostCheck(Data storage _self, uint256 _tokensCreated) private view returns (bool) {\n        require(_self.state == State.Started, \"not in state started\");\n        bool withinCap = _self.tokensRaised.add(_tokensCreated) <= _self.cap; \n        require(withinCap, \"not within cap\");\n\n        return true;\n    }\n\n    /// @notice simple token assignment.\n    function assignTokens(\n        Data storage _self, \n        address _beneficiaryWallet, \n        uint256 _tokenAmount, \n        bytes8 _tag) \n        public returns (uint256 _tokensCreated)\n    {\n        _tokensCreated = getController(_self).assignFromCrowdsale(\n            _beneficiaryWallet, \n            _tokenAmount,\n            _tag);\n        \n        emit TokenPurchase(msg.sender, _beneficiaryWallet, _tokensCreated, 0, _tag);\n\n        return _tokensCreated;\n    }\n\n    /// @notice calc how much tokens you would receive for given ETH amount (all in unit WEI)\n    /// @dev no view keyword even if it SHOULD not change the state. But let's not trust other contracts...\n    function calcTokensForEth(Data storage _self, uint256 _ethAmountInWei) public view returns (uint256 _tokensWouldBeCreated) {\n        return getController(_self).calcTokensForEth(_ethAmountInWei);\n    }\n\n    /// @notice If this contract gets a balance in some other ERC20 contract - or even iself - then we can rescue it.\n    /// @param _foreignTokenAddress token where contract has balance.\n    /// @param _to the beneficiary.\n    function rescueToken(Data storage _self, address _foreignTokenAddress, address _to) public\n    {\n        ERC20(_foreignTokenAddress).transfer(_to, ERC20(_foreignTokenAddress).balanceOf(address(this)));\n    }\n\n///////////////////\n// Events (must be redundant in calling contract to work!)\n///////////////////\n\n    event TokenPurchase(address indexed invoker, address indexed beneficiary, uint256 tokenAmount, uint256 overpaidRefund, bytes8 tag);\n    event CrowdsaleTimeChanged(uint256 startTime, uint256 endTime);\n    event CrowdsaleConfigurationChanged(address wallet, address globalIndex);\n    event RolesChanged(address indexed initiator, address tokenAssignmentControl, address tokenRescueControl);\n}\n\n// File: contracts/crowdsale/library/VaultGeneratorL.sol\n\n/*\n    Copyright 2018, CONDA\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n/** @title VaultGeneratorL library. */\nlibrary VaultGeneratorL {\n\n    /// @notice generate RefundEscrow vault.\n    /// @param _wallet beneficiary on success.\n    /// @return vault address that can be casted to interface.\n    function generateEthVault(address payable _wallet) public returns (address ethVaultInterface) {\n        return address(new RefundEscrow(_wallet));\n    }\n}\n\n// File: contracts/crowdsale/interfaces/IBasicAssetToken.sol\n\ninterface IBasicAssetToken {\n    //AssetToken specific\n    function getLimits() external view returns (uint256, uint256, uint256, uint256);\n    function isTokenAlive() external view returns (bool);\n\n    //Mintable\n    function mint(address _to, uint256 _amount) external returns (bool);\n    function finishMinting() external returns (bool);\n}\n\n// File: contracts/crowdsale/interface/EthVaultInterface.sol\n\n/**\n * Based on OpenZeppelin RefundEscrow.sol\n */\ninterface EthVaultInterface {\n\n    event Closed();\n    event RefundsEnabled();\n\n    /// @dev Stores funds that may later be refunded.\n    /// @param _refundee The address funds will be sent to if a refund occurs.\n    function deposit(address _refundee) external payable;\n\n    /// @dev Allows for the beneficiary to withdraw their funds, rejecting\n    /// further deposits.\n    function close() external;\n\n    /// @dev Allows for refunds to take place, rejecting further deposits.\n    function enableRefunds() external;\n\n    /// @dev Withdraws the beneficiary's funds.\n    function beneficiaryWithdraw() external;\n\n    /// @dev Returns whether refundees can withdraw their deposits (be refunded).\n    function withdrawalAllowed(address _payee) external view returns (bool);\n\n    /// @dev Withdraw what someone paid into vault.\n    function withdraw(address _payee) external;\n}\n\n// File: contracts/crowdsale/BasicAssetTokenCrowdsaleNoFeature.sol\n\n/*\n    Copyright 2018, CONDA\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\n\n/** @title BasicCompanyCrowdsale. Investment is stored in vault and forwarded to wallet on end. */\ncontract BasicAssetTokenCrowdsaleNoFeature is Ownable {\n    using SafeMath for uint256;\n    using CrowdsaleL for CrowdsaleL.Data;\n    using CrowdsaleL for CrowdsaleL.Roles;\n\n    /**\n    * Crowdsale process has the following steps:\n    *   1) startCrowdsale\n    *   2) buyTokens\n    *   3) endCrowdsale\n    *   4) finalizeCrowdsale\n    */\n\n///////////////////\n// Variables\n///////////////////\n\n    CrowdsaleL.Data crowdsaleData;\n    CrowdsaleL.Roles roles;\n\n///////////////////\n// Constructor\n///////////////////\n\n    constructor(address _assetToken) public {\n        crowdsaleData.init(_assetToken);\n    }\n\n///////////////////\n// Modifier\n///////////////////\n\n    modifier onlyTokenRescueControl() {\n        require(msg.sender == roles.tokenRescueControl, \"rescueCtrl\");\n        _;\n    }\n\n///////////////////\n// Simple state getters\n///////////////////\n\n    function token() public view returns (address) {\n        return crowdsaleData.token;\n    }\n\n    function wallet() public view returns (address) {\n        return crowdsaleData.wallet;\n    }\n\n    function tokensRaised() public view returns (uint256) {\n        return crowdsaleData.tokensRaised;\n    }\n\n    function cap() public view returns (uint256) {\n        return crowdsaleData.cap;\n    }\n\n    function state() public view returns (CrowdsaleL.State) {\n        return crowdsaleData.state;\n    }\n\n    function startTime() public view returns (uint256) {\n        return crowdsaleData.startTime;\n    }\n\n    function endTime() public view returns (uint256) {\n        return crowdsaleData.endTime;\n    }\n\n    function getControllerAddress() public view returns (address) {\n        return address(crowdsaleData.getControllerAddress());\n    }\n\n///////////////////\n// Events\n///////////////////\n\n    event TokenPurchase(address indexed invoker, address indexed beneficiary, uint256 tokenAmount, uint256 overpaidRefund, bytes8 tag);\n    event CrowdsaleTimeChanged(uint256 startTime, uint256 endTime);\n    event CrowdsaleConfigurationChanged(address wallet, address globalIndex);\n    event RolesChanged(address indexed initiator, address tokenAssignmentControl, address tokenRescueControl);\n    event Started();\n    event Ended();\n    event Finalized();\n\n///////////////////\n// Modifiers\n///////////////////\n\n    modifier onlyTokenAssignmentControl() {\n        require(_isTokenAssignmentControl(), \"only tokenAssignmentControl\");\n        _;\n    }\n\n    modifier onlyDraftState() {\n        require(crowdsaleData.state == CrowdsaleL.State.Draft, \"only draft state\");\n        _;\n    }\n\n    modifier onlyActive() {\n        require(_isActive(), \"only when active\");\n        _;\n    }\n\n    modifier onlyActiveOrDraftState() {\n        require(_isActiveOrDraftState(), \"only active/draft\");\n        _;\n    }\n\n    modifier onlyUnfinalized() {\n        require(crowdsaleData.state != CrowdsaleL.State.Finalized, \"only unfinalized\");\n        _;\n    }\n\n    /**\n    * @dev is crowdsale active or draft state that can be overriden.\n    */\n    function _isActiveOrDraftState() internal view returns (bool) {\n        return crowdsaleData.requireActiveOrDraftState();\n    }\n\n    /**\n    * @dev is token assignmentcontrol that can be overriden.\n    */\n    function _isTokenAssignmentControl() internal view returns (bool) {\n        return msg.sender == roles.tokenAssignmentControl;\n    }\n\n    /**\n    * @dev is active check that can be overriden.\n    */\n    function _isActive() internal view returns (bool) {\n        return crowdsaleData.state == CrowdsaleL.State.Started;\n    }\n \n///////////////////\n// Status Draft\n///////////////////\n\n    /// @notice set required data like wallet and global index.\n    /// @param _wallet beneficiary of crowdsale.\n    /// @param _globalIndex global index contract holding up2date contract addresses.\n    function setCrowdsaleData(\n        address payable _wallet,\n        address _globalIndex)\n    public\n    onlyOwner \n    {\n        crowdsaleData.configure(_wallet, _globalIndex);\n    }\n\n    /// @notice get token AssignmenControl who can assign tokens (off-chain payments).\n    function getTokenAssignmentControl() public view returns (address) {\n        return roles.tokenAssignmentControl;\n    }\n\n    /// @notice get token RescueControl who can rescue accidentally assigned tokens to this contract.\n    function getTokenRescueControl() public view returns (address) {\n        return roles.tokenRescueControl;\n    }\n\n    /// @notice set cap. That's the limit how much is accepted.\n    /// @param _cap the cap in unit token (minted AssetToken)\n    function setCap(uint256 _cap) internal onlyUnfinalized {\n        crowdsaleData.setCap(_cap);\n    }\n\n    /// @notice set roles/operators.\n    /// @param _tokenAssignmentControl can assign tokens (off-chain payments).\n    /// @param _tokenRescueControl address that is allowed rescue tokens.\n    function setRoles(address _tokenAssignmentControl, address _tokenRescueControl) public onlyOwner {\n        roles.setRoles(_tokenAssignmentControl, _tokenRescueControl);\n    }\n\n    /// @notice set crowdsale timeframe.\n    /// @param _startTime crowdsale start time.\n    /// @param _endTime crowdsale end time.\n    function setCrowdsaleTime(uint256 _startTime, uint256 _endTime) internal onlyUnfinalized {\n        // require(_startTime >= now, \"starTime in the past\"); //when getting from AT that is possible\n        require(_endTime >= _startTime, \"endTime smaller start\");\n\n        crowdsaleData.setTime(_startTime, _endTime);\n    }\n\n    /// @notice Update metadata like cap, time etc. from AssetToken.\n    /// @dev It is essential that this method is at least called before start and before end.\n    function updateFromAssetToken() public {\n        (uint256 _cap, /*goal*/, uint256 _startTime, uint256 _endTime) = IBasicAssetToken(crowdsaleData.token).getLimits();\n        setCap(_cap);\n        setCrowdsaleTime(_startTime, _endTime);\n    }\n\n///\n// Status Started\n///\n\n    /// @notice checks all variables and starts crowdsale\n    function startCrowdsale() public onlyDraftState {\n        updateFromAssetToken(); //IMPORTANT\n        \n        require(validStart(), \"validStart\");\n        prepareStart();\n        crowdsaleData.state = CrowdsaleL.State.Started;\n        emit Started();\n    }\n\n    /// @dev Calc how many tokens you would receive for given ETH amount (all in unit WEI)\n    function calcTokensForEth(uint256 _ethAmountInWei) public view returns (uint256 _tokensWouldBeCreated) {\n        return crowdsaleData.calcTokensForEth(_ethAmountInWei);\n    }\n\n    /// @dev Can be overridden to add start validation logic. The overriding function\n    ///  should call super.validStart() to ensure the chain of validation is\n    ///  executed entirely.\n    function validStart() internal view returns (bool) {\n        return crowdsaleData.validStart();\n    }\n\n    /// @dev Can be overridden to add preparation logic. The overriding function\n    ///  should call super.prepareStart() to ensure the chain of finalization is\n    ///  executed entirely.\n    function prepareStart() internal {\n    }\n\n    /// @dev Determines how ETH is stored/forwarded on purchases.\n    /// @param _overpaidRefund overpaid ETH amount (because AssetToken is 0 decimals)\n    function forwardWeiFunds(uint256 _overpaidRefund) internal {\n        require(_overpaidRefund <= msg.value, \"unrealistic overpay\");\n        crowdsaleData.wallet.transfer(msg.value.sub(_overpaidRefund));\n        \n        //send overpayment back to sender. notice: only safe because executed in the end!\n        msg.sender.transfer(_overpaidRefund);\n    }\n\n///\n// Status Ended\n///\n\n    /// @dev Can be called by owner to end the crowdsale manually\n    function endCrowdsale() public onlyOwner onlyActive {\n        updateFromAssetToken();\n\n        crowdsaleData.state = CrowdsaleL.State.Ended;\n\n        emit Ended();\n    }\n\n\n///\n// Status Finalized\n///\n\n    /// @dev Must be called after crowdsale ends, to do some extra finalization.\n    function finalizeCrowdsale() public {\n        updateFromAssetToken(); //IMPORTANT\n\n        require(crowdsaleData.state == CrowdsaleL.State.Ended || crowdsaleData.state == CrowdsaleL.State.Started, \"state\");\n        require(hasEnded(), \"not ended\");\n        crowdsaleData.state = CrowdsaleL.State.Finalized;\n        \n        finalization();\n        emit Finalized();\n    }\n\n    /// @notice status if crowdsale has ended yet.\n    /// @return true if crowdsale event has ended.\n    function hasEnded() public view returns (bool) {\n        return crowdsaleData.hasEnded();\n    }\n\n    /// @dev Can be overridden to add finalization logic. The overriding function\n    ///  should call super.finalization() to ensure the chain of finalization is\n    ///  executed entirely.\n    function finalization() internal {\n    }\n    \n///\n// Status Closed\n///\n\n    /// @dev Must be called to close the crowdsale manually. The overriding function\n    /// should call super.closeCrowdsale()\n    function closeCrowdsale() public onlyOwner {\n        crowdsaleData.closeCrowdsale();\n    }\n\n////////////////\n// Rescue Tokens \n////////////////\n\n    /// @dev Can rescue tokens accidentally assigned to this contract\n    /// @param _foreignTokenAddress The address from which the balance will be retrieved\n    /// @param _to beneficiary\n    function rescueToken(address _foreignTokenAddress, address _to)\n    public\n    onlyTokenRescueControl\n    {\n        crowdsaleData.rescueToken(_foreignTokenAddress, _to);\n    }\n}\n\n// File: contracts/crowdsale/feature/AssignTokensOffChainPaymentFeature.sol\n\n/*\n    Copyright 2018, CONDA\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/** @title AssignTokensOffChainPaymentFeature that if inherited adds possibility mintFor(investorXY) without ETH payment. */\ncontract AssignTokensOffChainPaymentFeature {\n\n///////////////////\n// Modifiers\n///////////////////\n\n    modifier assignTokensPrerequisit {\n        require(_assignTokensPrerequisit(), \"assign prerequisit\");\n        _;\n    }\n\n///////////////////\n// Functions\n///////////////////\n\n    /// @notice If entitled call this method to assign tokens to beneficiary (use case: off-chain payment)\n    /// @dev Token amount is assigned unmodified (no rate etc. on top)\n    function assignTokensOffChainPayment(\n        address _beneficiaryWallet, \n        uint256 _tokenAmount,\n        bytes8 _tag) \n        public \n        assignTokensPrerequisit\n    {\n        _assignTokensOffChainPaymentAct(_beneficiaryWallet, _tokenAmount, _tag);\n    }\n\n///////////////////\n// Functions to override\n///////////////////\n\n    /// @dev Checks prerequisits (e.g. if active/draft crowdsale, permission) ***MUST OVERRIDE***\n    function _assignTokensPrerequisit() internal view returns (bool) {\n        revert(\"override assignTokensPrerequisit\");\n    }\n\n    /// @dev Assign tokens act ***MUST OVERRIDE***\n    function _assignTokensOffChainPaymentAct(address /*_beneficiaryWallet*/, uint256 /*_tokenAmount*/, bytes8 /*_tag*/) \n        internal returns (bool)\n    {\n        revert(\"override buyTokensWithEtherAct\");\n    }\n}\n\n// File: contracts/crowdsale/STOs/AssetTokenCrowdsaleT001.sol\n\n/// @title AssetTokenCrowdsaleT001. Functionality of BasicAssetTokenNoFeatures with the AssignTokensOffChainPaymentFeature feature.\ncontract AssetTokenCrowdsaleT001 is BasicAssetTokenCrowdsaleNoFeature, AssignTokensOffChainPaymentFeature {\n\n///////////////////\n// Constructor\n///////////////////\n\n    constructor(address _assetToken) public BasicAssetTokenCrowdsaleNoFeature(_assetToken) {\n\n    }\n\n///////////////////\n// Feature functions internal overrides\n///////////////////\n\n    /// @dev override of assign tokens prerequisit of possible features.\n    function _assignTokensPrerequisit() internal view returns (bool) {\n        return (_isTokenAssignmentControl() && _isActiveOrDraftState());\n    }\n\n    /// @dev method executed on assign tokens because of off-chain payment (if feature is inherited).\n    function _assignTokensOffChainPaymentAct(address _beneficiaryWallet, uint256 _tokenAmount, bytes8 _tag)\n        internal returns (bool) \n    {\n        crowdsaleData.assignTokens(_beneficiaryWallet, _tokenAmount, _tag);\n        return true;\n    }\n}",
  "abi": "[{\"constant\":true,\"inputs\":[{\"name\":\"_ethAmountInWei\",\"type\":\"uint256\"}],\"name\":\"calcTokensForEth\",\"outputs\":[{\"name\":\"_tokensWouldBeCreated\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalizeCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenRescueControl\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenAssignmentControl\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_globalIndex\",\"type\":\"address\"}],\"name\":\"setCrowdsaleData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_foreignTokenAddress\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"rescueToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiaryWallet\",\"type\":\"address\"},{\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"name\":\"_tag\",\"type\":\"bytes8\"}],\"name\":\"assignTokensOffChainPayment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getControllerAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateFromAssetToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasEnded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAssignmentControl\",\"type\":\"address\"},{\"name\":\"_tokenRescueControl\",\"type\":\"address\"}],\"name\":\"setRoles\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_assetToken\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"invoker\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"overpaidRefund\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tag\",\"type\":\"bytes8\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"CrowdsaleTimeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"globalIndex\",\"type\":\"address\"}],\"name\":\"CrowdsaleConfigurationChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenAssignmentControl\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenRescueControl\",\"type\":\"address\"}],\"name\":\"RolesChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Started\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Ended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Finalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]",
  "bytecode": "608060405234801561001057600080fd5b506040516020806114348339810180604052602081101561003057600080fd5b505160008054600160a060020a03191633178082556040518392600160a060020a039290921691907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0908290a3604080517f83366da000000000000000000000000000000000000000000000000000000000815260016004820152600160a060020a0383166024820152905173a40d3608bd6c272052220e18d5d6672158f55668916383366da0916044808301926000929190829003018186803b1580156100f757600080fd5b505af415801561010b573d6000803e3d6000fd5b505050505050611314806101206000396000f3fe60806040526004361061012f5763ffffffff60e060020a60003504166304138e6b81146101345780630bf318a3146101705780631fc6fd02146101875780632095f2d4146101b857806327749b64146101cd578063302cabba146101e25780633197cbb61461021d578063355274ea146102325780634707d000146102475780635054db8714610282578063521eb273146102dc5780636ea6b71b146102f1578063715018a61461030657806378e979251461031b5780638da5cb5b146103305780638f32d59b14610345578063983c0a011461036e578063a39953b214610383578063c19d93fb14610398578063c57380a2146103d1578063e640359f146103e6578063ecb70fb7146103fb578063f2fde38b14610410578063f6072a1014610443578063fc0c546a1461047e575b600080fd5b34801561014057600080fd5b5061015e6004803603602081101561015757600080fd5b5035610493565b60408051918252519081900360200190f35b34801561017c57600080fd5b50610185610524565b005b34801561019357600080fd5b5061019c610684565b60408051600160a060020a039092168252519081900360200190f35b3480156101c457600080fd5b50610185610693565b3480156101d957600080fd5b5061019c61076c565b3480156101ee57600080fd5b506101856004803603604081101561020557600080fd5b50600160a060020a038135811691602001351661077b565b34801561022957600080fd5b5061015e61082c565b34801561023e57600080fd5b5061015e610832565b34801561025357600080fd5b506101856004803603604081101561026a57600080fd5b50600160a060020a0381358116916020013516610838565b34801561028e57600080fd5b50610185600480360360608110156102a557600080fd5b508035600160a060020a0316906020810135906040013577ffffffffffffffffffffffffffffffffffffffffffffffff191661091c565b3480156102e857600080fd5b5061019c61098b565b3480156102fd57600080fd5b5061015e61099a565b34801561031257600080fd5b506101856109a0565b34801561032757600080fd5b5061015e610a0a565b34801561033c57600080fd5b5061019c610a10565b34801561035157600080fd5b5061035a610a1f565b604080519115158252519081900360200190f35b34801561037a57600080fd5b50610185610a30565b34801561038f57600080fd5b50610185610ac2565b3480156103a457600080fd5b506103ad610bee565b604051808260058111156103bd57fe5b60ff16815260200191505060405180910390f35b3480156103dd57600080fd5b5061019c610bfe565b3480156103f257600080fd5b50610185610c86565b34801561040757600080fd5b5061035a610d37565b34801561041c57600080fd5b506101856004803603602081101561043357600080fd5b5035600160a060020a0316610d8e565b34801561044f57600080fd5b506101856004803603604081101561046657600080fd5b50600160a060020a0381358116916020013516610dad565b34801561048a57600080fd5b5061019c610e42565b6000600173a40d3608bd6c272052220e18d5d6672158f5566863f8efb47d9091846040518363ffffffff1660e060020a028152600401808381526020018281526020019250505060206040518083038186803b1580156104f257600080fd5b505af4158015610506573d6000803e3d6000fd5b505050506040513d602081101561051c57600080fd5b505192915050565b61052c610c86565b600260015460a060020a900460ff16600581111561054657fe5b148061056857506001805460a060020a900460ff16600581111561056657fe5b145b15156105be576040805160e560020a62461bcd02815260206004820152600560248201527f7374617465000000000000000000000000000000000000000000000000000000604482015290519081900360640190fd5b6105c6610d37565b151561061c576040805160e560020a62461bcd02815260206004820152600960248201527f6e6f7420656e6465640000000000000000000000000000000000000000000000604482015290519081900360640190fd5b6001805474ff0000000000000000000000000000000000000000191674030000000000000000000000000000000000000000179055610659610e51565b6040517f6823b073d48d6e3a7d385eeb601452d680e74bb46afe3255a7d778f3a9b1768190600090a1565b600954600160a060020a031690565b61069b610a1f565b15156106a657600080fd5b6106ae610e53565b1515610704576040805160e560020a62461bcd02815260206004820152601060248201527f6f6e6c79207768656e2061637469766500000000000000000000000000000000604482015290519081900360640190fd5b61070c610c86565b6001805474ff00000000000000000000000000000000000000001916740200000000000000000000000000000000000000001790556040517f477383f34069ce6129e1b6e0cbbdedb319ee49ef85677e403c26c37405ada46d90600090a1565b600854600160a060020a031690565b610783610a1f565b151561078e57600080fd5b604080517fc078f35300000000000000000000000000000000000000000000000000000000815260016004820152600160a060020a03808516602483015283166044820152905173a40d3608bd6c272052220e18d5d6672158f556689163c078f353916064808301926000929190829003018186803b15801561081057600080fd5b505af4158015610824573d6000803e3d6000fd5b505050505050565b60045490565b60025490565b600954600160a060020a0316331461089a576040805160e560020a62461bcd02815260206004820152600a60248201527f7265736375654374726c00000000000000000000000000000000000000000000604482015290519081900360640190fd5b604080517f37159bfb00000000000000000000000000000000000000000000000000000000815260016004820152600160a060020a03808516602483015283166044820152905173a40d3608bd6c272052220e18d5d6672158f55668916337159bfb916064808301926000929190829003018186803b15801561081057600080fd5b610924610e74565b151561097a576040805160e560020a62461bcd02815260206004820152601260248201527f61737369676e2070726572657175697369740000000000000000000000000000604482015290519081900360640190fd5b610985838383610e92565b50505050565b600554600160a060020a031690565b60075490565b6109a8610a1f565b15156109b357600080fd5b60008054604051600160a060020a03909116907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0908390a36000805473ffffffffffffffffffffffffffffffffffffffff19169055565b60035490565b600054600160a060020a031690565b600054600160a060020a0316331490565b610a38610a1f565b1515610a4357600080fd5b604080517f8332601200000000000000000000000000000000000000000000000000000000815260016004820152905173a40d3608bd6c272052220e18d5d6672158f55668916383326012916024808301926000929190829003018186803b158015610aae57600080fd5b505af4158015610985573d6000803e3d6000fd5b600060015460a060020a900460ff166005811115610adc57fe5b14610b31576040805160e560020a62461bcd02815260206004820152601060248201527f6f6e6c7920647261667420737461746500000000000000000000000000000000604482015290519081900360640190fd5b610b39610c86565b610b41610f6e565b1515610b97576040805160e560020a62461bcd02815260206004820152600a60248201527f76616c6964537461727400000000000000000000000000000000000000000000604482015290519081900360640190fd5b610b9f610e51565b6001805474ff0000000000000000000000000000000000000000191660a060020a1790556040517fd8cea0ecd56872ff072e771658b5682ffe4de16d752947f79597d600ea56f7a990600090a1565b60015460a060020a900460ff1690565b6000600173a40d3608bd6c272052220e18d5d6672158f5566863e201487b90916040518263ffffffff1660e060020a0281526004018082815260200191505060206040518083038186803b158015610c5557600080fd5b505af4158015610c69573d6000803e3d6000fd5b505050506040513d6020811015610c7f57600080fd5b5051905090565b6000806000600160000160009054906101000a9004600160a060020a0316600160a060020a0316636f89e4096040518163ffffffff1660e060020a02815260040160806040518083038186803b158015610cdf57600080fd5b505afa158015610cf3573d6000803e3d6000fd5b505050506040513d6080811015610d0957600080fd5b50805160408201516060909201519094509092509050610d2883610fc5565b610d3282826110c2565b505050565b6000600173a40d3608bd6c272052220e18d5d6672158f55668631d8c3c4590916040518263ffffffff1660e060020a0281526004018082815260200191505060206040518083038186803b158015610c5557600080fd5b610d96610a1f565b1515610da157600080fd5b610daa81611203565b50565b610db5610a1f565b1515610dc057600080fd5b604080517f3bd160bf00000000000000000000000000000000000000000000000000000000815260086004820152600160a060020a03808516602483015283166044820152905173a40d3608bd6c272052220e18d5d6672158f5566891633bd160bf916064808301926000929190829003018186803b15801561081057600080fd5b600154600160a060020a031690565b565b60006001805460a060020a900460ff166005811115610e6e57fe5b14905090565b6000610e7e611280565b8015610e8d5750610e8d611291565b905090565b604080517f3f781a7300000000000000000000000000000000000000000000000000000000815260016004820152600160a060020a03851660248201526044810184905277ffffffffffffffffffffffffffffffffffffffffffffffff1983166064820152905160009173a40d3608bd6c272052220e18d5d6672158f5566891633f781a7391608480820192602092909190829003018186803b158015610f3857600080fd5b505af4158015610f4c573d6000803e3d6000fd5b505050506040513d6020811015610f6257600080fd5b50600195945050505050565b6000600173a40d3608bd6c272052220e18d5d6672158f556686320b6c9bc90916040518263ffffffff1660e060020a0281526004018082815260200191505060206040518083038186803b158015610c5557600080fd5b600360015460a060020a900460ff166005811115610fdf57fe5b1415611035576040805160e560020a62461bcd02815260206004820152601060248201527f6f6e6c7920756e66696e616c697a656400000000000000000000000000000000604482015290519081900360640190fd5b604080517fddf84c800000000000000000000000000000000000000000000000000000000081526001600482015260248101839052905173a40d3608bd6c272052220e18d5d6672158f556689163ddf84c80916044808301926000929190829003018186803b1580156110a757600080fd5b505af41580156110bb573d6000803e3d6000fd5b5050505050565b600360015460a060020a900460ff1660058111156110dc57fe5b1415611132576040805160e560020a62461bcd02815260206004820152601060248201527f6f6e6c7920756e66696e616c697a656400000000000000000000000000000000604482015290519081900360640190fd5b8181101561118a576040805160e560020a62461bcd02815260206004820152601560248201527f656e6454696d6520736d616c6c65722073746172740000000000000000000000604482015290519081900360640190fd5b604080517fd4f10f10000000000000000000000000000000000000000000000000000000008152600160048201526024810184905260448101839052905173a40d3608bd6c272052220e18d5d6672158f556689163d4f10f10916064808301926000929190829003018186803b15801561081057600080fd5b600160a060020a038116151561121857600080fd5b60008054604051600160a060020a03808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a36000805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b600854600160a060020a0316331490565b6000600173a40d3608bd6c272052220e18d5d6672158f5566863c913516b90916040518263ffffffff1660e060020a0281526004018082815260200191505060206040518083038186803b158015610c5557600080fdfea165627a7a72305820ec0b7aecd007572dcbdabc66bf9aa1265a01c9b590c3523cffafe0db3fb611240029000000000000000000000000e9990eda9e478ded1f8318d7002ed08d5073e71d",
  "constructorArguments": "000000000000000000000000e9990eda9e478ded1f8318d7002ed08d5073e71d",
  "libraries": [
    {
      "name": "CrowdsaleL",
      "address": "0xA40d3608bd6C272052220E18d5D6672158F55668"
    }
  ]
}