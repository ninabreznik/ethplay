{
  "address": "0xA30F0c9470904a59b2A288E6209633090Af1A2A3",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "PacketVerify",
  "compilerVersion": "v0.5.0+commit.1d4f565a",
  "optimization": false,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2019-05-21\n*/\n\npragma solidity ^0.5.0;\npragma experimental ABIEncoderV2;\n// File: contracts/ECDSA.sol\n\n// pragma solidity >=0.4.21 <0.6.0;\npragma solidity ^0.5.0;\n\n/**\n * @title Elliptic curve signature operations\n * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\n * TODO Remove this library once solidity supports passing a signature to ecrecover.\n * See https://github.com/ethereum/solidity/issues/864\n */\n\nlibrary ECDSA {\n\n/**\n  * @dev Recover signer address from a message by using their signature\n  * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\n  * @param signature bytes signature, the signature is generated using web3.eth.sign()\n  */\nfunction recover(bytes32 hash, bytes memory signature)\n    internal\n    pure\n    returns (address)\n{\n    bytes32 r;\n    bytes32 s;\n    uint8 v;\n\n    // Check the signature length\n    if (signature.length != 65) {\n        return (address(0));\n    }\n\n    // Divide the signature in r, s and v variables\n    // ecrecover takes the signature parameters, and the only way to get them\n    // currently is to use assembly.\n    // solium-disable-next-line security/no-inline-assembly\n    assembly {\n        r := mload(add(signature, 0x20))\n        s := mload(add(signature, 0x40))\n        v := byte(0, mload(add(signature, 0x60)))\n    }\n\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n    if (v < 27) {\n        v += 27;\n    }\n\n    // If the version is correct return the signer address\n    if (v != 27 && v != 28) {\n        return (address(0));\n    } else {\n        // solium-disable-next-line arg-overflow\n        return ecrecover(hash, v, r, s);\n    }\n}\n\n    /**\n    * toEthSignedMessageHash\n    * @dev prefix a bytes32 value with \"\\x19Ethereum Signed Message:\"\n    * and hash the result\n    */\n    function toEthSignedMessageHash(bytes32 hash)\n      internal\n      pure\n      returns (bytes32)\n    {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(\n            abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)\n        );\n    }\n}\n\n// File: contracts/lib/RLPReader.sol\n\n/*\n* @author Hamdi Allam [emailÂ protected]\n* Please reach out with any questions or concerns\n*/\npragma solidity ^0.5.0;\n\nlibrary RLPReader {\n    uint8 constant STRING_SHORT_START = 0x80;\n    uint8 constant STRING_LONG_START  = 0xb8;\n    uint8 constant LIST_SHORT_START   = 0xc0;\n    uint8 constant LIST_LONG_START    = 0xf8;\n\n    uint8 constant WORD_SIZE = 32;\n\n    struct RLPItem {\n        uint len;\n        uint memPtr;\n    }\n\n    /*\n    * @param item RLP encoded bytes\n    */\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n        uint memPtr;\n        assembly {\n            memPtr := add(item, 0x20)\n        }\n\n        return RLPItem(item.length, memPtr);\n    }\n\n    /*\n    * @param item RLP encoded bytes\n    */\n    function rlpLen(RLPItem memory item) internal pure returns (uint) {\n        return item.len;\n    }\n\n    /*\n    * @param item RLP encoded bytes\n    */\n    function payloadLen(RLPItem memory item) internal pure returns (uint) {\n        return item.len - _payloadOffset(item.memPtr);\n    }\n\n    /*\n    * @param item RLP encoded list in bytes\n    */\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory result) {\n        require(isList(item));\n\n        uint items = numItems(item);\n        result = new RLPItem[](items);\n\n        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint dataLen;\n        for (uint i = 0; i < items; i++) {\n            dataLen = _itemLength(memPtr);\n            result[i] = RLPItem(dataLen, memPtr); \n            memPtr = memPtr + dataLen;\n        }\n    }\n\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\n    function isList(RLPItem memory item) internal pure returns (bool) {\n        if (item.len == 0) return false;\n\n        uint8 byte0;\n        uint memPtr = item.memPtr;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < LIST_SHORT_START)\n            return false;\n        return true;\n    }\n\n    /** RLPItem conversions into data types **/\n\n    // @returns raw rlp encoding in bytes\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        bytes memory result = new bytes(item.len);\n        if (result.length == 0) return result;\n        \n        uint ptr;\n        assembly {\n            ptr := add(0x20, result)\n        }\n\n        copy(item.memPtr, ptr, item.len);\n        return result;\n    }\n\n    // any non-zero byte is considered true\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\n        require(item.len == 1);\n        uint result;\n        uint memPtr = item.memPtr;\n        assembly {\n            result := byte(0, mload(memPtr))\n        }\n\n        return result == 0 ? false : true;\n    }\n\n    function toAddress(RLPItem memory item) internal pure returns (address) {\n        // 1 byte for the length prefix\n        require(item.len == 21);\n\n        return address(toUint(item));\n    }\n\n    function toUint(RLPItem memory item) internal pure returns (uint) {\n        require(item.len > 0 && item.len <= 33);\n\n        uint offset = _payloadOffset(item.memPtr);\n        uint len = item.len - offset;\n\n        uint result;\n        uint memPtr = item.memPtr + offset;\n        assembly {\n            result := mload(memPtr)\n\n            // shfit to the correct location if neccesary\n            if lt(len, 32) {\n                result := div(result, exp(256, sub(32, len)))\n            }\n        }\n\n        return result;\n    }\n\n    // enforces 32 byte length\n    function toUintStrict(RLPItem memory item) internal pure returns (uint) {\n        // one byte prefix\n        require(item.len == 33);\n\n        uint result;\n        uint memPtr = item.memPtr + 1;\n        assembly {\n            result := mload(memPtr)\n        }\n\n        return result;\n    }\n\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        require(item.len > 0);\n\n        uint offset = _payloadOffset(item.memPtr);\n        uint len = item.len - offset; // data length\n        bytes memory result = new bytes(len);\n\n        uint destPtr;\n        assembly {\n            destPtr := add(0x20, result)\n        }\n\n        copy(item.memPtr + offset, destPtr, len);\n        return result;\n    }\n\n    /*\n    * Private Helpers\n    */\n\n    // @return number of payload items inside an encoded list.\n    function numItems(RLPItem memory item) private pure returns (uint) {\n        if (item.len == 0) return 0;\n\n        uint count = 0;\n        uint currPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint endPtr = item.memPtr + item.len;\n        while (currPtr < endPtr) {\n           currPtr = currPtr + _itemLength(currPtr); // skip over an item\n           count++;\n        }\n\n        return count;\n    }\n\n    // @return entire rlp item byte length\n    function _itemLength(uint memPtr) private pure returns (uint len) {\n        uint byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START)\n            return 1;\n        \n        else if (byte0 < STRING_LONG_START)\n            return byte0 - STRING_SHORT_START + 1;\n\n        else if (byte0 < LIST_SHORT_START) {\n            assembly {\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\n                memPtr := add(memPtr, 1) // skip over the first byte\n                \n                /* 32 byte word size */\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\n                len := add(dataLen, add(byteLen, 1))\n            }\n        }\n\n        else if (byte0 < LIST_LONG_START) {\n            return byte0 - LIST_SHORT_START + 1;\n        } \n\n        else {\n            assembly {\n                let byteLen := sub(byte0, 0xf7)\n                memPtr := add(memPtr, 1)\n\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\n                len := add(dataLen, add(byteLen, 1))\n            }\n        }\n    }\n\n    // @return number of bytes until the data\n    function _payloadOffset(uint memPtr) private pure returns (uint) {\n        uint byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) \n            return 0;\n        else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START))\n            return 1;\n        else if (byte0 < LIST_SHORT_START)  // being explicit\n            return byte0 - (STRING_LONG_START - 1) + 1;\n        else\n            return byte0 - (LIST_LONG_START - 1) + 1;\n    }\n\n    /*\n    * @param src Pointer to source\n    * @param dest Pointer to destination\n    * @param len Amount of memory to copy from the source\n    */\n    function copy(uint src, uint dest, uint len) private pure {\n        if (len == 0) return;\n\n        // copy as many word sizes as possible\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n\n            src += WORD_SIZE;\n            dest += WORD_SIZE;\n        }\n\n        // left over bytes. Mask is used to remove unwanted bytes from the word\n        uint mask = 256 ** (WORD_SIZE - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask)) // zero out src\n            let destpart := and(mload(dest), mask) // retrieve the bytes\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n}\n\n// File: contracts/lib/MsDecoder.sol\n\n// pragma experimental ABIEncoderV2;\n\n/*\n* Used to proxy function calls to the RLPReader for testing\n*/\n\n\nlibrary MsDecoder {\n    using RLPReader for bytes;\n    using RLPReader for uint;\n    using RLPReader for RLPReader.RLPItem;\n\n    struct Message {\n        address from;\n        address to;\n        bytes32 sessionID;\n        uint mType;\n        bytes content;\n        bytes signature;\n        // balance proof\n        bytes32 channelID;\n        uint256 balance;\n        uint256 nonce;\n        // hash of data related to transfer\n        uint256 amount;\n        bytes32 additionalHash;\n        bytes paymentSignature;\n    }\n\n    function decode(bytes memory data) internal view returns (Message[] memory) {\n        RLPReader.RLPItem[] memory messages = data.toRlpItem().toList();\n        Message[] memory ms = new Message[](messages.length);\n        RLPReader.RLPItem[] memory items;\n        for(uint i=0; i<messages.length; i++) {\n            items = messages[i].toList();\n            ms[i] = Message(items[0].toAddress(), items[1].toAddress(), toBytes32(items[2].toBytes()), items[3].toUint(), items[4].toBytes(), items[5].toBytes(), toBytes32(items[6].toBytes()), items[7].toUint(), items[8].toUint(), items[9].toUint(), toBytes32(items[10].toBytes()), items[11].toBytes());\n        }\n        return ms;\n    }\n\n    function toBytes32(bytes memory source) internal pure returns (bytes32 result) {\n        if (source.length == 0) {\n            return 0x0;\n        }\n        assembly {\n            result := mload(add(source, 32))\n        }\n    }\n}\n\n// File: contracts/PacketVerify.sol\n\n// pragma experimental ABIEncoderV2;\n\n\n\n\n\ncontract PacketVerify {\n    using RLPReader for bytes;\n    using RLPReader for uint;\n    using RLPReader for RLPReader.RLPItem;\n\n    uint256 constant rate = 98;\n\n    struct State {\n        bytes32 prh;\n        address token;\n        uint256 amount;\n        address provider;\n        bytes32 pr;\n        address loser;\n    }\n    struct URHash {\n        bytes32 urh;\n        address user;\n        bytes32 urr;\n        uint256 m;\n    }\n    struct PSettle{\n        address user;\n        uint amount;\n    }\n\n    function verify (\n        bytes memory data\n    )\n        public\n        view\n        returns(string memory verifyResult, string memory gameInformation, address loser, address[5] memory users, bytes32[5] memory userSecretHashs, bytes32[5] memory userSecrets, uint[5] memory userModules, uint[5] memory userSettleAmounts) //0=success, 1xxx=invalid data, 2xxx=wrong result\n    {\n        MsDecoder.Message[] memory ms = MsDecoder.decode(data);\n        State memory s;\n        URHash[] memory urHash = new URHash[](5);\n        PSettle[] memory pSettle = new PSettle[](5);\n        uint idx = 0;\n        // provider start game message\n        if (ms[0].mType == 1) {\n            RLPReader.RLPItem[] memory items = ms[0].content.toRlpItem().toList();\n            s.prh = toBytes32(items[0].toBytes());\n            s.token = items[1].toAddress();\n            s.amount = items[2].toUint();\n            s.provider = ms[0].from;\n            gameInformation = string(abi.encodePacked(\"provider: \", addressToString(s.provider), \", token: \", addressToString(s.token), \", wager: \", uintToString(s.amount), \", provider secret hash: \", bytes32ToString(s.prh)));\n            // token = s.token;\n        } else {\n            verifyResult = \"error(-1001): provider should send game information message first\\n\";\n            return (verifyResult, gameInformation, loser, users, userSecretHashs, userSecrets, userModules, userSettleAmounts);\n        }\n        // provider cancel game\n        for(uint i=1; i<ms.length; i++){\n            if(ms[i].mType == 6 && ms[i].from == s.provider){\n                if(verifyCancel(s, ms, i)){\n                    verifyResult = \"game canceled, refund success\\n\";\n                    return (verifyResult, gameInformation, loser, users, userSecretHashs, userSecrets, userModules, userSettleAmounts);\n                } else {\n                    verifyResult = \"game canceled, refund failed\\n\";\n                    return (verifyResult, gameInformation, loser, users, userSecretHashs, userSecrets, userModules, userSettleAmounts);    \n                }\n            }\n        }\n        // provider send hash ready message\n        for(uint i=1; i<ms.length; i++){ \n            if(ms[i].mType == 3 && ms[i].from == s.provider){\n                RLPReader.RLPItem[] memory items = ms[i].content.toRlpItem().toList();\n                for(uint k=0; k<5; k++) {\n                    urHash[k].user = items[k].toAddress();\n                    users[k] = items[k].toAddress();\n                }\n                idx = 0;\n                for(uint j=1; j<i&&idx<5; j++){\n                    if(ms[j].mType == 2 && ms[j].to == s.provider && ms[j].from == urHash[idx].user && ms[j].amount == s.amount){\n                        urHash[idx].urh = toBytes32(ms[j].content.toRlpItem().toList()[0].toBytes());\n                        userSecretHashs[idx] = urHash[idx].urh;\n                        idx++;\n                    }\n                }\n                if(idx < 5){\n                    verifyResult = \"error(-1002): users provider picked was wrong\\n\";\n                    return (verifyResult, gameInformation, loser, users, userSecretHashs, userSecrets, userModules, userSettleAmounts);\n                }\n                break;\n            }\n        }\n        if(urHash[0].user == address(0)) {\n            verifyResult = \"error(-1003): provider did not pick users\\n\";\n            return (verifyResult, gameInformation, loser, users, userSecretHashs, userSecrets, userModules, userSettleAmounts);\n        }\n        // provider settle game\n        idx = 0;\n        for(uint i=1; i<ms.length&&idx<5; i++){\n            if(ms[i].mType == 5 && ms[i].from == s.provider){\n                if(idx == 0) {\n                    s.pr = toBytes32(ms[i].content.toRlpItem().toList()[0].toBytes());\n                    gameInformation = string(abi.encodePacked(gameInformation, \", provider secret: \", bytes32ToString(s.pr)));\n                    if (keccak256(abi.encodePacked(s.pr)) != s.prh) {\n                        verifyResult = \"error(-1004): provider random was not matched with hash of random\\n\";\n                        return (verifyResult, gameInformation, loser, users, userSecretHashs, userSecrets, userModules, userSettleAmounts);\n                    }\n                } else if(toBytes32(ms[i].content.toRlpItem().toList()[0].toBytes()) != s.pr) {\n                    verifyResult = \"error(-1004): provider random was not matched with hash of random\\n\";\n                    return (verifyResult, gameInformation, loser, users, userSecretHashs, userSecrets, userModules, userSettleAmounts);\n                }\n                pSettle[idx].user = ms[i].to;\n                pSettle[idx].amount = ms[i].amount;\n                userSettleAmounts[idx] = ms[i].amount;\n                idx++;\n            }\n        }\n        if(!verifyProviderSettle(urHash, pSettle)) {\n            verifyResult = \"error(-1005): provider settle order was not matched with order of users\\n\";\n            return (verifyResult, gameInformation, loser, users, userSecretHashs, userSecrets, userModules, userSettleAmounts);\n        }\n        // provider send random message\n        for(uint i=1; i<ms.length; i++){\n            if(ms[i].mType == 4 && ms[i].from == s.provider){\n                RLPReader.RLPItem[] memory items = ms[i].content.toRlpItem().toList();\n                for(uint j=0; j<5; j++){\n                    if(keccak256(abi.encodePacked(toBytes32(items[j].toBytes()))) != urHash[j].urh) {\n                        verifyResult = \"error(-1006): user random was not matched with hash of random\\n\";\n                        return (verifyResult, gameInformation, loser, users, userSecretHashs, userSecrets, userModules, userSettleAmounts);\n                    }\n                    urHash[j].urr = toBytes32(items[j].toBytes());\n                    userSecrets[j] = urHash[j].urr;\n                }\n            }\n        }\n        uint256 m = uint256(urHash[0].urr^urHash[1].urr^urHash[2].urr^urHash[3].urr^urHash[4].urr^s.pr)%100 + 100;\n        gameInformation = string(abi.encodePacked(gameInformation, \", module: \", uintToString(m)));\n        uint256 minRand = 0;\n        for (uint i=0; i<5; i++) {\n            // uint i = 4 - j;\n            // urHash[i].m = uint256(urHash[i].urr)%m;\n            urHash[i].m = selectNumber(uint256(urHash[i].urr)%(m-i) + 1, userModules, m);\n            userModules[i] = urHash[i].m;\n            if(i == 0) {\n                s.loser = urHash[i].user;\n                minRand = urHash[i].m;\n            } else if(urHash[i].m < minRand) {\n                minRand = urHash[i].m;\n                s.loser = urHash[i].user;\n            }\n        }\n        loser = s.loser;\n        // verify if settlement was correct\n        for (uint i=0; i<5; i++) {\n            if(pSettle[i].user == s.loser) {\n                if(pSettle[i].amount != (s.amount*rate/100)*urHash[i].m/(urHash[0].m+urHash[1].m+urHash[2].m+urHash[3].m+urHash[4].m)) {\n                    verifyResult = \"error(-1007): wrong settle amount\\n\";\n                    return (verifyResult, gameInformation, loser, users, userSecretHashs, userSecrets, userModules, userSettleAmounts);\n                }\n            } else {\n                if(pSettle[i].amount != ((s.amount*rate/100)*urHash[i].m/(urHash[0].m+urHash[1].m+urHash[2].m+urHash[3].m+urHash[4].m)) + s.amount) {\n                    verifyResult = \"error(-1007): wrong settle amount\\n\";\n                    return (verifyResult, gameInformation, loser, users, userSecretHashs, userSecrets, userModules, userSettleAmounts);\n                }\n            }\n        }\n        verifyResult = \"Success!\\n\";\n        return (verifyResult, gameInformation, loser, users, userSecretHashs, userSecrets, userModules, userSettleAmounts);\n    }\n\n    function selectNumber(\n        uint rand,\n        uint[5] memory userModules,\n        uint module\n    )\n        internal\n        view\n        returns(uint)\n    {\n        uint temp = rand;\n        for(uint i = 1; i < module + 1; i++){\n\n            bool included = false;\n            for(uint j = 0; j < 5; j ++){\n                if(userModules[j] == i){\n                    included = true;\n                    break;\n                }\n            }\n            if(!included) {\n                temp --;\n            }\n            if(temp <= 0){\n                return i;\n            }\n        }\n        return module;\n    }\n\n    function verifyCancel (\n        State memory s,\n        MsDecoder.Message[] memory ms,\n        uint cIdx\n    )\n        internal\n        view\n        returns(bool)\n    {\n        address[] memory users = new address[](cIdx);\n        uint userLength = 0;\n        for(uint i=0; i<cIdx; i++) {\n            if(ms[i].mType == 2 && ms[i].to == s.provider  && ms[i].amount == s.amount){\n                users[userLength] = ms[i].from;\n                userLength++;\n            }\n        }\n        uint idx = 0;\n        for(uint j=cIdx; j<ms.length&&idx<userLength; j++) {\n            if(ms[j].mType == 7 && ms[j].to == users[idx] && ms[j].amount == s.amount){\n                idx++;\n            }\n        }\n        if(idx < userLength) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    function verifyProviderSettle (\n        URHash[] memory urHash,\n        PSettle[] memory pSettle \n    )\n        internal\n        pure\n        returns(bool)\n    {\n        for(uint i=0; i<5; i++) {\n            uint j = 0;\n            while(urHash[i].user != pSettle[j].user && j<5) j++;\n            if(j==5) return false;\n        }\n        return true;\n    }\n\n    function toBytes32(\n        bytes memory source\n    ) \n        internal \n        pure \n        returns (bytes32 result) \n    {\n        if (source.length == 0) {\n            return 0x0;\n        }\n        assembly {\n            result := mload(add(source, 32))\n        }\n    }\n\n\n    function addressToString(address _addr) internal pure returns(string memory) {\n        bytes32 value = bytes32(uint256(_addr));\n        bytes memory alphabet = \"0123456789abcdef\";\n    \n        bytes memory str = new bytes(42);\n        str[0] = '0';\n        str[1] = 'x';\n        for (uint i = 0; i < 20; i++) {\n            str[2+i*2] = alphabet[uint(uint8(value[i + 12]) >> 4)];\n            str[3+i*2] = alphabet[uint(uint8(value[i + 12]) & 0x0f)];\n        }\n        return string(str);\n    }\n    \n    function bytes32ToString(bytes32 value) internal view returns (string memory) {\n        bytes memory alphabet = \"0123456789abcdef\";\n        bytes memory str = new bytes(66);\n        str[0] = '0';\n        str[1] = 'x';\n        for (uint i = 0; i < 32; i++) {\n            str[2+i*2] = alphabet[uint(uint8(value[i]) >> 4)];\n            str[3+i*2] = alphabet[uint(uint8(value[i]) & 0x0f)];\n        }\n        return string(str);\n    }\n    \n    function uintToString(uint _i) internal pure returns (string memory _uintAsString) {\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint j = _i;\n        uint len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint k = len - 1;\n        while (_i != 0) {\n            bstr[k--] = byte(uint8(48 + _i % 10));\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n}",
  "bytecode": "608060405234801561001057600080fd5b5061350e806100206000396000f3fe608060405260043610610041576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680638e760afe14610046575b600080fd5b34801561005257600080fd5b5061006d6004803603610068919081019061315c565b61008a565b6040516100819897969594939291906132e1565b60405180910390f35b6060806000610097612ede565b61009f612f01565b6100a7612f01565b6100af612f24565b6100b7612f24565b60606100c28a611b25565b90506100cc612f47565b6060600560405190808252806020026020018201604052801561010957816020015b6100f6612fc6565b8152602001906001900390816100ee5790505b5090506060600560405190808252806020026020018201604052801561014957816020015b61013661300b565b81526020019060019003908161012e5790505b5090506000809050600185600081518110151561016257fe5b906020019060200201516060015114156104f35760606101a56101a087600081518110151561018d57fe5b9060200190602002015160800151611df9565b611e27565b90506101d06101cb8260008151811015156101bc57fe5b90602001906020020151611f04565b611f92565b8560000181815250506101fa8160018151811015156101eb57fe5b90602001906020020151611fb6565b856020019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff168152505061025281600281518110151561024357fe5b90602001906020020151611fdb565b85604001818152505085600081518110151561026a57fe5b9060200190602002015160000151856060019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250506102bc856060015161204e565b6102c9866020015161204e565b6102d687604001516123c7565b6102e38860000151612520565b60405160200180807f70726f76696465723a2000000000000000000000000000000000000000000000815250600a0185805190602001908083835b602083101515610343578051825260208201915060208101905060208303925061031e565b6001836020036101000a038019825116818451168082178552505050505050905001807f2c20746f6b656e3a20000000000000000000000000000000000000000000000081525060090184805190602001908083835b6020831015156103be5780518252602082019150602081019050602083039250610399565b6001836020036101000a038019825116818451168082178552505050505050905001807f2c2077616765723a20000000000000000000000000000000000000000000000081525060090183805190602001908083835b6020831015156104395780518252602082019150602081019050602083039250610414565b6001836020036101000a038019825116818451168082178552505050505050905001807f2c2070726f76696465722073656372657420686173683a20000000000000000081525060180182805190602001908083835b6020831015156104b4578051825260208201915060208101905060208303925061048f565b6001836020036101000a0380198251168184511680821785525050505050509050019450505050506040516020818303038152906040529c505061059a565b608060405190810160405280604281526020017f6572726f72282d31303031293a2070726f76696465722073686f756c6420736581526020017f6e642067616d6520696e666f726d6174696f6e206d657373616765206669727381526020017f740a0000000000000000000000000000000000000000000000000000000000008152509c508c8c8c8c8c8c8c8c9c509c509c509c509c509c509c509c505050505050611b1a565b6000600190505b85518110156106f757600686828151811015156105ba57fe5b906020019060200201516060015114801561061f5750846060015173ffffffffffffffffffffffffffffffffffffffff1686828151811015156105f957fe5b906020019060200201516000015173ffffffffffffffffffffffffffffffffffffffff16145b156106ea5761062f858783612873565b1561068f576040805190810160405280601e81526020017f67616d652063616e63656c65642c20726566756e6420737563636573730a00008152509d508d8d8d8d8d8d8d8d9d509d509d509d509d509d509d509d50505050505050611b1a565b6040805190810160405280601d81526020017f67616d652063616e63656c65642c20726566756e64206661696c65640a0000008152509d508d8d8d8d8d8d8d8d9d509d509d509d509d509d509d509d50505050505050611b1a565b80806001019150506105a1565b506000600190505b8551811015610b30576003868281518110151561071857fe5b906020019060200201516060015114801561077d5750846060015173ffffffffffffffffffffffffffffffffffffffff16868281518110151561075757fe5b906020019060200201516000015173ffffffffffffffffffffffffffffffffffffffff16145b15610b235760606107b06107ab888481518110151561079857fe5b9060200190602002015160800151611df9565b611e27565b905060008090505b60058110156108a1576107e182828151811015156107d257fe5b90602001906020020151611fb6565b86828151811015156107ef57fe5b906020019060200201516020019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff168152505061084f828281518110151561084057fe5b90602001906020020151611fb6565b8d8260058110151561085d57fe5b602002019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff168152505080806001019150506107b8565b50600092506000600190505b82811080156108bc5750600584105b15610a9057600288828151811015156108d157fe5b90602001906020020151606001511480156109365750866060015173ffffffffffffffffffffffffffffffffffffffff16888281518110151561091057fe5b906020019060200201516020015173ffffffffffffffffffffffffffffffffffffffff16145b80156109a35750858481518110151561094b57fe5b906020019060200201516020015173ffffffffffffffffffffffffffffffffffffffff16888281518110151561097d57fe5b906020019060200201516000015173ffffffffffffffffffffffffffffffffffffffff16145b80156109ce5750866040015188828151811015156109bd57fe5b906020019060200201516101200151145b15610a8357610a27610a22610a05610a008b858151811015156109ed57fe5b9060200190602002015160800151611df9565b611e27565b6000815181101515610a1357fe5b90602001906020020151611f04565b611f92565b8685815181101515610a3557fe5b9060200190602002015160000181815250508584815181101515610a5557fe5b90602001906020020151600001518c85600581101515610a7157fe5b60200201818152505083806001019450505b80806001019150506108ad565b506005831015610b1d57606060405190810160405280602e81526020017f6572726f72282d31303032293a2075736572732070726f76696465722070696381526020017f6b6564207761732077726f6e670a0000000000000000000000000000000000008152509e508e8e8e8e8e8e8e8e9e509e509e509e509e509e509e509e5050505050505050611b1a565b50610b30565b80806001019150506106ff565b50600073ffffffffffffffffffffffffffffffffffffffff16836000815181101515610b5857fe5b906020019060200201516020015173ffffffffffffffffffffffffffffffffffffffff161415610c0357606060405190810160405280602a81526020017f6572726f72282d31303033293a2070726f766964657220646964206e6f74207081526020017f69636b2075736572730a000000000000000000000000000000000000000000008152509c508c8c8c8c8c8c8c8c9c509c509c509c509c509c509c509c505050505050611b1a565b600090506000600190505b855181108015610c1e5750600582105b156110d95760058682815181101515610c3357fe5b9060200190602002015160600151148015610c985750846060015173ffffffffffffffffffffffffffffffffffffffff168682815181101515610c7257fe5b906020019060200201516000015173ffffffffffffffffffffffffffffffffffffffff16145b156110cc576000821415610edf57610cfa610cf5610cd8610cd38985815181101515610cc057fe5b9060200190602002015160800151611df9565b611e27565b6000815181101515610ce657fe5b90602001906020020151611f04565b611f92565b8560800181815250508c610d118660800151612520565b6040516020018083805190602001908083835b602083101515610d495780518252602082019150602081019050602083039250610d24565b6001836020036101000a038019825116818451168082178552505050505050905001807f2c2070726f7669646572207365637265743a200000000000000000000000000081525060130182805190602001908083835b602083101515610dc45780518252602082019150602081019050602083039250610d9f565b6001836020036101000a038019825116818451168082178552505050505050905001925050506040516020818303038152906040529c50846000015185608001516040516020018082815260200191505060405160208183030381529060405280519060200120141515610eda57608060405190810160405280604281526020017f6572726f72282d31303034293a2070726f76696465722072616e646f6d20776181526020017f73206e6f74206d61746368656420776974682068617368206f662072616e646f81526020017f6d0a0000000000000000000000000000000000000000000000000000000000008152509d508d8d8d8d8d8d8d8d9d509d509d509d509d509d509d509d50505050505050611b1a565b610fe8565b8460800151610f38610f33610f16610f118a86815181101515610efe57fe5b9060200190602002015160800151611df9565b611e27565b6000815181101515610f2457fe5b90602001906020020151611f04565b611f92565b141515610fe757608060405190810160405280604281526020017f6572726f72282d31303034293a2070726f76696465722072616e646f6d20776181526020017f73206e6f74206d61746368656420776974682068617368206f662072616e646f81526020017f6d0a0000000000000000000000000000000000000000000000000000000000008152509d508d8d8d8d8d8d8d8d9d509d509d509d509d509d509d509d50505050505050611b1a565b5b8581815181101515610ff657fe5b9060200190602002015160200151838381518110151561101257fe5b906020019060200201516000019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff1681525050858181518110151561106057fe5b906020019060200201516101200151838381518110151561107d57fe5b906020019060200201516020018181525050858181518110151561109d57fe5b90602001906020020151610120015187836005811015156110ba57fe5b60200201818152505081806001019250505b8080600101915050610c0e565b506110e48383612aef565b151561119157608060405190810160405280604881526020017f6572726f72282d31303035293a2070726f766964657220736574746c65206f7281526020017f64657220776173206e6f74206d6174636865642077697468206f72646572206f81526020017f662075736572730a0000000000000000000000000000000000000000000000008152509c508c8c8c8c8c8c8c8c9c509c509c509c509c509c509c509c505050505050611b1a565b6000600190505b85518110156113e757600486828151811015156111b157fe5b90602001906020020151606001511480156112165750846060015173ffffffffffffffffffffffffffffffffffffffff1686828151811015156111f057fe5b906020019060200201516000015173ffffffffffffffffffffffffffffffffffffffff16145b156113da576060611249611244888481518110151561123157fe5b9060200190602002015160800151611df9565b611e27565b905060008090505b60058110156113d757858181518110151561126857fe5b906020019060200201516000015161129e611299848481518110151561128a57fe5b90602001906020020151611f04565b611f92565b604051602001808281526020019150506040516020818303038152906040528051906020012014151561134f57606060405190810160405280603e81526020017f6572726f72282d31303036293a20757365722072616e646f6d20776173206e6f81526020017f74206d61746368656420776974682068617368206f662072616e646f6d0a00008152509f508f8f8f8f8f8f8f8f9f509f509f509f509f509f509f509f505050505050505050611b1a565b611377611372838381518110151561136357fe5b90602001906020020151611f04565b611f92565b868281518110151561138557fe5b90602001906020020151604001818152505085818151811015156113a557fe5b90602001906020020151604001518b826005811015156113c157fe5b6020020181815250508080600101915050611251565b50505b8080600101915050611198565b506000606480866080015186600481518110151561140157fe5b906020019060200201516040015187600381518110151561141e57fe5b906020019060200201516040015188600281518110151561143b57fe5b906020019060200201516040015189600181518110151561145857fe5b90602001906020020151604001518a600081518110151561147557fe5b906020019060200201516040015118181818186001900481151561149557fe5b060190508c6114a3826123c7565b6040516020018083805190602001908083835b6020831015156114db57805182526020820191506020810190506020830392506114b6565b6001836020036101000a038019825116818451168082178552505050505050905001807f2c206d6f64756c653a2000000000000000000000000000000000000000000000815250600a0182805190602001908083835b6020831015156115565780518252602082019150602081019050602083039250611531565b6001836020036101000a038019825116818451168082178552505050505050905001925050506040516020818303038152906040529c50600080905060008090505b6005811015611750576115db600182850388848151811015156115b757fe5b9060200190602002015160400151600190048115156115d257fe5b06018b85612bb8565b86828151811015156115e957fe5b906020019060200201516060018181525050858181518110151561160957fe5b90602001906020020151606001518a8260058110151561162557fe5b60200201818152505060008114156116ad57858181518110151561164557fe5b90602001906020020151602001518760a0019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff1681525050858181518110151561169857fe5b90602001906020020151606001519150611743565b8186828151811015156116bc57fe5b906020019060200201516060015110156117425785818151811015156116de57fe5b9060200190602002015160600151915085818151811015156116fc57fe5b90602001906020020151602001518760a0019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250505b5b8080600101915050611598565b508560a001519c5060008090505b6005811015611ac1578660a0015173ffffffffffffffffffffffffffffffffffffffff16858281518110151561179057fe5b906020019060200201516000015173ffffffffffffffffffffffffffffffffffffffff161415611936578560048151811015156117c957fe5b90602001906020020151606001518660038151811015156117e657fe5b906020019060200201516060015187600281518110151561180357fe5b906020019060200201516060015188600181518110151561182057fe5b906020019060200201516060015189600081518110151561183d57fe5b906020019060200201516060015101010101868281518110151561185d57fe5b9060200190602002015160600151606460628a604001510281151561187e57fe5b040281151561188957fe5b04858281518110151561189857fe5b906020019060200201516020015114151561193157606060405190810160405280602281526020017f6572726f72282d31303037293a2077726f6e6720736574746c6520616d6f756e81526020017f740a0000000000000000000000000000000000000000000000000000000000008152509f508f8f8f8f8f8f8f8f9f509f509f509f509f509f509f509f505050505050505050611b1a565b611ab4565b866040015186600481518110151561194a57fe5b906020019060200201516060015187600381518110151561196757fe5b906020019060200201516060015188600281518110151561198457fe5b90602001906020020151606001518960018151811015156119a157fe5b90602001906020020151606001518a60008151811015156119be57fe5b90602001906020020151606001510101010187838151811015156119de57fe5b9060200190602002015160600151606460628b60400151028115156119ff57fe5b0402811515611a0a57fe5b04018582815181101515611a1a57fe5b9060200190602002015160200151141515611ab357606060405190810160405280602281526020017f6572726f72282d31303037293a2077726f6e6720736574746c6520616d6f756e81526020017f740a0000000000000000000000000000000000000000000000000000000000008152509f508f8f8f8f8f8f8f8f9f509f509f509f509f509f509f509f505050505050505050611b1a565b5b808060010191505061175e565b506040805190810160405280600981526020017f53756363657373210a00000000000000000000000000000000000000000000008152509e508e8e8e8e8e8e8e8e9e509e509e509e509e509e509e509e50505050505050505b919395975091939597565b606080611b39611b3484611df9565b611e27565b905060608151604051908082528060200260200182016040528015611b7857816020015b611b6561303b565b815260200190600190039081611b5d5790505b509050606060008090505b8351811015611ded57611bac8482815181101515611b9d57fe5b90602001906020020151611e27565b915061018060405190810160405280611bdc846000815181101515611bcd57fe5b90602001906020020151611fb6565b73ffffffffffffffffffffffffffffffffffffffff168152602001611c18846001815181101515611c0957fe5b90602001906020020151611fb6565b73ffffffffffffffffffffffffffffffffffffffff168152602001611c5c611c57856002815181101515611c4857fe5b90602001906020020151611f04565b612c56565b8152602001611c82846003815181101515611c7357fe5b90602001906020020151611fdb565b8152602001611ca8846004815181101515611c9957fe5b90602001906020020151611f04565b8152602001611cce846005815181101515611cbf57fe5b90602001906020020151611f04565b8152602001611cfc611cf7856006815181101515611ce857fe5b90602001906020020151611f04565b612c56565b8152602001611d22846007815181101515611d1357fe5b90602001906020020151611fdb565b8152602001611d48846008815181101515611d3957fe5b90602001906020020151611fdb565b8152602001611d6e846009815181101515611d5f57fe5b90602001906020020151611fdb565b8152602001611d9c611d9785600a815181101515611d8857fe5b90602001906020020151611f04565b612c56565b8152602001611dc284600b815181101515611db357fe5b90602001906020020151611f04565b8152508382815181101515611dd357fe5b906020019060200201819052508080600101915050611b83565b50819350505050919050565b611e016130d2565b600060208301905060408051908101604052808451815260200182815250915050919050565b6060611e3282612c7a565b1515611e3d57600080fd5b6000611e4883612cc8565b905080604051908082528060200260200182016040528015611e8457816020015b611e716130ec565b815260200190600190039081611e695790505b5091506000611e968460200151612d39565b8460200151019050600080600090505b83811015611efb57611eb783612dc2565b91506040805190810160405280838152602001848152508582815181101515611edc57fe5b9060200190602002018190525081830192508080600101915050611ea6565b50505050919050565b606060008260000151111515611f1957600080fd5b6000611f288360200151612d39565b905060008184600001510390506060816040519080825280601f01601f191660200182016040528015611f6a5781602001600182028038833980820191505090505b5090506000816020019050611f86848760200151018285612e75565b81945050505050919050565b60008082511415611fa95760006001029050611fb1565b602082015190505b919050565b600060158260000151141515611fcb57600080fd5b611fd482611fdb565b9050919050565b6000808260000151118015611ff557506021826000015111155b151561200057600080fd5b600061200f8360200151612d39565b9050600081846000015103905060008083866020015101905080519150602083101561204257826020036101000a820491505b81945050505050919050565b606060008273ffffffffffffffffffffffffffffffffffffffff16600102905060606040805190810160405280601081526020017f303132333435363738396162636465660000000000000000000000000000000081525090506060602a6040519080825280601f01601f1916602001820160405280156120de5781602001600182028038833980820191505090505b5090507f300000000000000000000000000000000000000000000000000000000000000081600081518110151561211157fe5b9060200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053507f780000000000000000000000000000000000000000000000000000000000000081600181518110151561217157fe5b9060200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535060008090505b60148110156123bb5782600485600c84016020811015156121c457fe5b1a7f0100000000000000000000000000000000000000000000000000000000000000027f0100000000000000000000000000000000000000000000000000000000000000900460ff16908060020a820491505060ff1681518110151561222657fe5b9060200101517f010000000000000000000000000000000000000000000000000000000000000090047f010000000000000000000000000000000000000000000000000000000000000002826002830260020181518110151561228557fe5b9060200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535082600f85600c84016020811015156122c957fe5b1a7f0100000000000000000000000000000000000000000000000000000000000000027f010000000000000000000000000000000000000000000000000000000000000090041660ff1681518110151561231f57fe5b9060200101517f010000000000000000000000000000000000000000000000000000000000000090047f010000000000000000000000000000000000000000000000000000000000000002826002830260030181518110151561237e57fe5b9060200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535080806001019150506121a7565b50809350505050919050565b6060600082141561240f576040805190810160405280600181526020017f3000000000000000000000000000000000000000000000000000000000000000815250905061251b565b600082905060005b60008214151561243d578080600101915050600a8281151561243557fe5b049150612417565b6060816040519080825280601f01601f1916602001820160405280156124725781602001600182028038833980820191505090505b50905060006001830390505b60008614151561251357600a8681151561249457fe5b066030017f0100000000000000000000000000000000000000000000000000000000000000028282806001900393508151811015156124cf57fe5b9060200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a905350600a8681151561250b57fe5b04955061247e565b819450505050505b919050565b6060806040805190810160405280601081526020017f30313233343536373839616263646566000000000000000000000000000000008152509050606060426040519080825280601f01601f1916602001820160405280156125915781602001600182028038833980820191505090505b5090507f30000000000000000000000000000000000000000000000000000000000000008160008151811015156125c457fe5b9060200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053507f780000000000000000000000000000000000000000000000000000000000000081600181518110151561262457fe5b9060200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535060008090505b602081101561286857826004868360208110151561267457fe5b1a7f0100000000000000000000000000000000000000000000000000000000000000027f0100000000000000000000000000000000000000000000000000000000000000900460ff16908060020a820491505060ff168151811015156126d657fe5b9060200101517f010000000000000000000000000000000000000000000000000000000000000090047f010000000000000000000000000000000000000000000000000000000000000002826002830260020181518110151561273557fe5b9060200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535082600f868360208110151561277657fe5b1a7f0100000000000000000000000000000000000000000000000000000000000000027f010000000000000000000000000000000000000000000000000000000000000090041660ff168151811015156127cc57fe5b9060200101517f010000000000000000000000000000000000000000000000000000000000000090047f010000000000000000000000000000000000000000000000000000000000000002826002830260030181518110151561282b57fe5b9060200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a905350808060010191505061265a565b508092505050919050565b60006060826040519080825280602002602001820160405280156128a65781602001602082028038833980820191505090505b509050600080905060008090505b848110156129dd57600286828151811015156128cc57fe5b90602001906020020151606001511480156129315750866060015173ffffffffffffffffffffffffffffffffffffffff16868281518110151561290b57fe5b906020019060200201516020015173ffffffffffffffffffffffffffffffffffffffff16145b801561295c57508660400151868281518110151561294b57fe5b906020019060200201516101200151145b156129d057858181518110151561296f57fe5b9060200190602002015160000151838381518110151561298b57fe5b9060200190602002019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff168152505081806001019250505b80806001019150506128b4565b50600080905060008590505b8651811080156129f857508282105b15612acb5760078782815181101515612a0d57fe5b9060200190602002015160600151148015612a8557508382815181101515612a3157fe5b9060200190602002015173ffffffffffffffffffffffffffffffffffffffff168782815181101515612a5f57fe5b906020019060200201516020015173ffffffffffffffffffffffffffffffffffffffff16145b8015612ab0575087604001518782815181101515612a9f57fe5b906020019060200201516101200151145b15612abe5781806001019250505b80806001019150506129e9565b5081811015612ae05760009350505050612ae8565b600193505050505b9392505050565b600080600090505b6005811015612bac5760008090505b8381815181101515612b1457fe5b906020019060200201516000015173ffffffffffffffffffffffffffffffffffffffff168583815181101515612b4657fe5b906020019060200201516020015173ffffffffffffffffffffffffffffffffffffffff1614158015612b785750600581105b15612b8a578080600101915050612b06565b6005811415612b9e57600092505050612bb2565b508080600101915050612af7565b50600190505b92915050565b6000808490506000600190505b60018401811015612c4957600080905060008090505b6005811015612c1457828782600581101515612bf357fe5b60200201511415612c075760019150612c14565b8080600101915050612bdb565b50801515612c26578280600190039350505b600083111515612c3b57819350505050612c4f565b508080600101915050612bc5565b50829150505b9392505050565b60008082511415612c6d5760006001029050612c75565b602082015190505b919050565b60008082600001511415612c915760009050612cc3565b60008083602001519050805160001a915060c060ff168260ff161015612cbc57600092505050612cc3565b6001925050505b919050565b60008082600001511415612cdf5760009050612d34565b60008090506000612cf38460200151612d39565b84602001510190506000846000015185602001510190505b80821015612d2d57612d1c82612dc2565b820191508280600101935050612d0b565b8293505050505b919050565b600080825160001a9050608060ff16811015612d59576000915050612dbd565b60b860ff16811080612d7e575060c060ff168110158015612d7d575060f860ff1681105b5b15612d8d576001915050612dbd565b60c060ff16811015612dad5760018060b80360ff16820301915050612dbd565b60018060f80360ff168203019150505b919050565b600080825160001a9050608060ff16811015612de2576001915050612e70565b60b860ff16811015612e00576001608060ff16820301915050612e70565b60c060ff16811015612e305760b78103600184019350806020036101000a84510460018201810193505050612e6e565b60f860ff16811015612e4e57600160c060ff16820301915050612e70565b60f78103600184019350806020036101000a845104600182018101935050505b505b919050565b6000811415612e8357612ed9565b5b602060ff1681101515612eb55782518252602060ff1683019250602060ff1682019150602060ff1681039050612e84565b6000600182602060ff16036101000a03905080198451168184511681811785525050505b505050565b60a060405190810160405280600590602082028038833980820191505090505090565b60a060405190810160405280600590602082028038833980820191505090505090565b60a060405190810160405280600590602082028038833980820191505090505090565b60c06040519081016040528060008019168152602001600073ffffffffffffffffffffffffffffffffffffffff16815260200160008152602001600073ffffffffffffffffffffffffffffffffffffffff16815260200160008019168152602001600073ffffffffffffffffffffffffffffffffffffffff1681525090565b60806040519081016040528060008019168152602001600073ffffffffffffffffffffffffffffffffffffffff16815260200160008019168152602001600081525090565b6040805190810160405280600073ffffffffffffffffffffffffffffffffffffffff168152602001600081525090565b61018060405190810160405280600073ffffffffffffffffffffffffffffffffffffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff168152602001600080191681526020016000815260200160608152602001606081526020016000801916815260200160008152602001600081526020016000815260200160008019168152602001606081525090565b604080519081016040528060008152602001600081525090565b604080519081016040528060008152602001600081525090565b600082601f830112151561311957600080fd5b813561312c6131278261339e565b613371565b9150808252602083016020830185838301111561314857600080fd5b613153838284613481565b50505092915050565b60006020828403121561316e57600080fd5b600082013567ffffffffffffffff81111561318857600080fd5b61319484828501613106565b91505092915050565b6131a68161343b565b82525050565b6131b5816133e8565b6131be826133ca565b60005b828110156131f0576131d485835161319d565b6131dd82613414565b91506020850194506001810190506131c1565b5050505050565b613200816133f3565b613209826133d4565b60005b8281101561323b5761321f85835161328d565b61322882613421565b915060208501945060018101905061320c565b5050505050565b61324b816133fe565b613254826133de565b60005b828110156132865761326a8583516132d2565b6132738261342e565b9150602085019450600181019050613257565b5050505050565b6132968161344d565b82525050565b60006132a782613409565b8084526132bb816020860160208601613490565b6132c4816134c3565b602085010191505092915050565b6132db81613477565b82525050565b60006103808201905081810360008301526132fc818b61329c565b90508181036020830152613310818a61329c565b905061331f604083018961319d565b61332c60608301886131ac565b61333a6101008301876131f7565b6133486101a08301866131f7565b613356610240830185613242565b6133646102e0830184613242565b9998505050505050505050565b6000604051905081810181811067ffffffffffffffff8211171561339457600080fd5b8060405250919050565b600067ffffffffffffffff8211156133b557600080fd5b601f19601f8301169050602081019050919050565b6000819050919050565b6000819050919050565b6000819050919050565b600060059050919050565b600060059050919050565b600060059050919050565b600081519050919050565b6000602082019050919050565b6000602082019050919050565b6000602082019050919050565b600061344682613457565b9050919050565b6000819050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b82818337600083830152505050565b60005b838110156134ae578082015181840152602081019050613493565b838111156134bd576000848401525b50505050565b6000601f19601f830116905091905056fea265627a7a72305820e7783d983890609b007d7a33e4bec02e14515de4fc3a8bad8a146c6f968cae6b6c6578706572696d656e74616cf50037"
}