{
  "address": "0xd2f7a3cbcc4aa43de3cd23f19bd5d9ce4524e135",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "SaturnPresale",
  "compilerVersion": "v0.4.21+commit.dfe3193c",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2018-04-13\n*/\n\npragma solidity ^0.4.18;\n\n// SATURN strategic exchange program\n\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\ncontract ERC223 {\n  uint public totalSupply;\n  function balanceOf(address who) constant returns (uint);\n\n  function name() constant returns (string _name);\n  function symbol() constant returns (string _symbol);\n  function decimals() constant returns (uint8 _decimals);\n  function totalSupply() constant returns (uint256 _supply);\n\n  function transfer(address to, uint value) returns (bool ok);\n  function transfer(address to, uint value, bytes data) returns (bool ok);\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n  event ERC223Transfer(address indexed _from, address indexed _to, uint256 _value, bytes _data);\n}\n\ncontract ContractReceiver {\n  function tokenFallback(address _from, uint _value, bytes _data);\n}\n\ncontract ERC223Token is ERC223 {\n  using SafeMath for uint;\n\n  mapping(address => uint) balances;\n\n  string public name;\n  string public symbol;\n  uint8 public decimals;\n  uint256 public totalSupply;\n\n\n  // Function to access name of token .\n  function name() constant returns (string _name) {\n      return name;\n  }\n  // Function to access symbol of token .\n  function symbol() constant returns (string _symbol) {\n      return symbol;\n  }\n  // Function to access decimals of token .\n  function decimals() constant returns (uint8 _decimals) {\n      return decimals;\n  }\n  // Function to access total supply of tokens .\n  function totalSupply() constant returns (uint256 _totalSupply) {\n      return totalSupply;\n  }\n\n  // Function that is called when a user or another contract wants to transfer funds .\n  function transfer(address _to, uint _value, bytes _data) returns (bool success) {\n    if(isContract(_to)) {\n        return transferToContract(_to, _value, _data);\n    }\n    else {\n        return transferToAddress(_to, _value, _data);\n    }\n}\n\n  // Standard function transfer similar to ERC20 transfer with no _data .\n  // Added due to backwards compatibility reasons .\n  function transfer(address _to, uint _value) returns (bool success) {\n\n    //standard function transfer similar to ERC20 transfer with no _data\n    //added due to backwards compatibility reasons\n    bytes memory empty;\n    if(isContract(_to)) {\n        return transferToContract(_to, _value, empty);\n    }\n    else {\n        return transferToAddress(_to, _value, empty);\n    }\n}\n\n//assemble the given address bytecode. If bytecode exists then the _addr is a contract.\n  function isContract(address _addr) private returns (bool is_contract) {\n      uint length;\n      assembly {\n            //retrieve the size of the code on target address, this needs assembly\n            length := extcodesize(_addr)\n        }\n        if(length>0) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n\n  //function that is called when transaction target is an address\n  function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) {\n    if (balanceOf(msg.sender) < _value) revert();\n    balances[msg.sender] = balanceOf(msg.sender).sub(_value);\n    balances[_to] = balanceOf(_to).add(_value);\n    Transfer(msg.sender, _to, _value);\n    ERC223Transfer(msg.sender, _to, _value, _data);\n    return true;\n  }\n\n  //function that is called when transaction target is a contract\n  function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) {\n    if (balanceOf(msg.sender) < _value) revert();\n    balances[msg.sender] = balanceOf(msg.sender).sub(_value);\n    balances[_to] = balanceOf(_to).add(_value);\n    ContractReceiver reciever = ContractReceiver(_to);\n    reciever.tokenFallback(msg.sender, _value, _data);\n    Transfer(msg.sender, _to, _value);\n    ERC223Transfer(msg.sender, _to, _value, _data);\n    return true;\n  }\n\n\n  function balanceOf(address _owner) constant returns (uint balance) {\n    return balances[_owner];\n  }\n}\n\ncontract SaturnPresale is ContractReceiver {\n  using SafeMath for uint256;\n\n  bool    public active = false;\n  address public tokenAddress;\n  uint256 public hardCap;\n  uint256 public sold;\n\n  struct Order {\n    address owner;\n    uint256 amount;\n    uint256 lockup;\n    bool    claimed;\n  }\n\n  mapping(uint256 => Order) private orders;\n  uint256 private latestOrderId = 0;\n  address private owner;\n  address private treasury;\n\n  event Activated(uint256 time);\n  event Finished(uint256 time);\n  event Purchase(address indexed purchaser, uint256 id, uint256 amount, uint256 purchasedAt, uint256 redeemAt);\n  event Claim(address indexed purchaser, uint256 id, uint256 amount);\n\n  function SaturnPresale(address token, address ethRecepient, uint256 presaleHardCap) public {\n    tokenAddress  = token;\n    owner         = msg.sender;\n    treasury      = ethRecepient;\n    hardCap       = presaleHardCap;\n  }\n\n  function tokenFallback(address /* _from */, uint _value, bytes /* _data */) public {\n    // Accept only SATURN ERC223 token\n    if (msg.sender != tokenAddress) { revert(); }\n    // If the Presale is active do not accept incoming transactions\n    if (active) { revert(); }\n    // Only accept one transaction of the right amount\n    if (_value != hardCap) { revert(); }\n\n    active = true;\n    Activated(now);\n  }\n\n  function amountOf(uint256 orderId) constant public returns (uint256 amount) {\n    return orders[orderId].amount;\n  }\n\n  function lockupOf(uint256 orderId) constant public returns (uint256 timestamp) {\n    return orders[orderId].lockup;\n  }\n\n  function ownerOf(uint256 orderId) constant public returns (address orderOwner) {\n    return orders[orderId].owner;\n  }\n\n  function isClaimed(uint256 orderId) constant public returns (bool claimed) {\n    return orders[orderId].claimed;\n  }\n\n  function () external payable {\n    revert();\n  }\n\n  function shortBuy() public payable {\n    // 10% bonus\n    uint256 lockup = now + 12 weeks;\n    uint256 priceDiv = 1818181818;\n    processPurchase(priceDiv, lockup);\n  }\n\n  function mediumBuy() public payable {\n    // 25% bonus\n    uint256 lockup = now + 24 weeks;\n    uint256 priceDiv = 1600000000;\n    processPurchase(priceDiv, lockup);\n  }\n\n  function longBuy() public payable {\n    // 50% bonus\n    uint256 lockup = now + 52 weeks;\n    uint256 priceDiv = 1333333333;\n    processPurchase(priceDiv, lockup);\n  }\n\n  function processPurchase(uint256 priceDiv, uint256 lockup) private {\n    if (!active) { revert(); }\n    if (msg.value == 0) { revert(); }\n    ++latestOrderId;\n\n    uint256 purchasedAmount = msg.value.div(priceDiv);\n    if (purchasedAmount == 0) { revert(); } // not enough ETH sent\n    if (purchasedAmount > hardCap - sold) { revert(); } // too much ETH sent\n\n    orders[latestOrderId] = Order(msg.sender, purchasedAmount, lockup, false);\n    sold += purchasedAmount;\n\n    treasury.transfer(msg.value);\n    Purchase(msg.sender, latestOrderId, purchasedAmount, now, lockup);\n  }\n\n  function redeem(uint256 orderId) public {\n    if (orderId > latestOrderId) { revert(); }\n    Order storage order = orders[orderId];\n\n    // only owner can withdraw\n    if (msg.sender != order.owner) { revert(); }\n    if (now < order.lockup) { revert(); }\n    if (order.claimed) { revert(); }\n    order.claimed = true;\n\n    ERC223 token = ERC223(tokenAddress);\n    token.transfer(order.owner, order.amount);\n\n    Claim(order.owner, orderId, order.amount);\n  }\n\n  function endPresale() public {\n    // only the creator of the smart contract\n    // can end the crowdsale prematurely\n    if (msg.sender != owner) { revert(); }\n    // can only stop an active crowdsale\n    if (!active) { revert(); }\n    _end();\n  }\n\n  function _end() private {\n    // if there are any tokens remaining - return them to the owner\n    if (sold < hardCap) {\n      ERC223 token = ERC223(tokenAddress);\n      token.transfer(treasury, hardCap.sub(sold));\n    }\n    active = false;\n    Finished(now);\n  }\n}",
  "bytecode": "60606040526000805460ff19168155600455341561001c57600080fd5b60405160608061086d83398101604052808051919060200180519190602001805160008054600160a060020a039687166101000261010060a860020a031990911617905560058054338716600160a060020a031991821617909155600680549590961694169390931790935550600155506107d18061009c6000396000f3006060604052600436106100b65763ffffffff60e060020a60003504166302c7e7af81146100bb57806302fb0c5e146100e05780630ab4debd146101075780636352211e146101115780636ff26ebb146101435780639956a28c1461014b5780639d76ea58146101535780639e34070f14610166578063a43be57b1461017c578063bede4bd81461018f578063c0ee0b8a146101a5578063db006a751461020a578063e8eb228414610220578063fb86a40414610236575b600080fd5b34156100c657600080fd5b6100ce610249565b60405190815260200160405180910390f35b34156100eb57600080fd5b6100f361024f565b604051901515815260200160405180910390f35b61010f610258565b005b341561011c57600080fd5b610127600435610271565b604051600160a060020a03909116815260200160405180910390f35b61010f61028c565b61010f6102a2565b341561015e57600080fd5b6101276102b7565b341561017157600080fd5b6100f36004356102cb565b341561018757600080fd5b61010f6102e4565b341561019a57600080fd5b6100ce60043561031a565b34156101b057600080fd5b61010f60048035600160a060020a03169060248035919060649060443590810190830135806020601f8201819004810201604051908101604052818152929190602084018383808284375094965061032f95505050505050565b341561021557600080fd5b61010f6004356103b2565b341561022b57600080fd5b6100ce6004356104f7565b341561024157600080fd5b6100ce61050c565b60025481565b60005460ff1681565b626ebe004201636c5f40ba61026d8183610512565b5050565b600090815260036020526040902054600160a060020a031690565b6301dfe2004201634f790d5561026d8183610512565b62dd7c004201635f5e100061026d8183610512565b6000546101009004600160a060020a031681565b6000908152600360208190526040909120015460ff1690565b60055433600160a060020a039081169116146102ff57600080fd5b60005460ff16151561031057600080fd5b61031861069b565b565b60009081526003602052604090206002015490565b60005433600160a060020a03908116610100909204161461034f57600080fd5b60005460ff161561035f57600080fd5b600154821461036d57600080fd5b6000805460ff191660011790557f3ec796be1be7d03bff3a62b9fa594a60e947c1809bced06d929f145308ae57ce4260405190815260200160405180910390a1505050565b6000806004548311156103c457600080fd5b6000838152600360205260409020805490925033600160a060020a039081169116146103ef57600080fd5b816002015442101561040057600080fd5b600382015460ff161561041257600080fd5b5060038101805460ff19166001908117909155600054825491830154600160a060020a03610100909204821692839263a9059cbb9291169060405160e060020a63ffffffff8516028152600160a060020a0390921660048301526024820152604401602060405180830381600087803b151561048d57600080fd5b5af1151561049a57600080fd5b5050506040518051505081546001830154600160a060020a03909116907f34fcbac0073d7c3d388e51312faf357774904998eeb8fca628b9e6f65ee1cbf790859060405191825260208201526040908101905180910390a2505050565b60009081526003602052604090206001015490565b60015481565b6000805460ff16151561052457600080fd5b34151561053057600080fd5b600480546001019055610549348463ffffffff61077c16565b905080151561055757600080fd5b6002546001540381111561056a57600080fd5b60806040519081016040908152600160a060020a0333168252602080830184905281830185905260006060840181905260045481526003909152208151815473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0391909116178155602082015181600101556040820151816002015560608201516003909101805491151560ff19909216919091179055506002805482019055600654600160a060020a03163480156108fc0290604051600060405180830381858888f19350505050151561063b57600080fd5b33600160a060020a03167fd721454499cf9c37b757e03b9d675df451c229048129d6e2d552216a035e6a556004548342866040518085815260200184815260200183815260200182815260200194505050505060405180910390a2505050565b6000600154600254101561073c5750600054600654600254600154600160a060020a03610100909404841693849363a9059cbb939116916106e19163ffffffff61079316565b60405160e060020a63ffffffff8516028152600160a060020a0390921660048301526024820152604401602060405180830381600087803b151561072457600080fd5b5af1151561073157600080fd5b505050604051805150505b6000805460ff191690557f86954ecc0ae072157fcf7f87a425a1461295a4cc9cc3122d2efc73bf32d98e1a4260405190815260200160405180910390a150565b600080828481151561078a57fe5b04949350505050565b60008282111561079f57fe5b509003905600a165627a7a72305820eb281fc14231771bbb6209415c41b47b58ae1acf418e7895d8fc3bdebf47ad210029000000000000000000000000b9440022a095343b440d590fcd2d7a3794bd76c8000000000000000000000000d7537928b6ad4185c63f52050ab2f1d0068f8abc0000000000000000000000000000000000000000000000000000015d3ef79800",
  "constructorArguments": "000000000000000000000000b9440022a095343b440d590fcd2d7a3794bd76c8000000000000000000000000d7537928b6ad4185c63f52050ab2f1d0068f8abc0000000000000000000000000000000000000000000000000000015d3ef79800"
}