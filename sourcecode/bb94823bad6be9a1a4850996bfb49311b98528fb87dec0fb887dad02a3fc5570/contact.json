{
  "address": "0x8dbc20fae8a51b035be3f22162ce962cf4ec9c60",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "MigrateController",
  "compilerVersion": "v0.4.13+commit.fb4cb1a",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2017-10-24\n*/\n\npragma solidity ^0.4.13;\n\ncontract DSAuthority {\n    function canCall(\n        address src, address dst, bytes4 sig\n    ) constant returns (bool);\n}\n\ncontract DSAuthEvents {\n    event LogSetAuthority (address indexed authority);\n    event LogSetOwner     (address indexed owner);\n}\n\ncontract DSAuth is DSAuthEvents {\n    DSAuthority  public  authority;\n    address      public  owner;\n\n    function DSAuth() {\n        owner = msg.sender;\n        LogSetOwner(msg.sender);\n    }\n\n    function setOwner(address owner_)\n        auth\n    {\n        owner = owner_;\n        LogSetOwner(owner);\n    }\n\n    function setAuthority(DSAuthority authority_)\n        auth\n    {\n        authority = authority_;\n        LogSetAuthority(authority);\n    }\n\n    modifier auth {\n        require(isAuthorized(msg.sender, msg.sig));\n        _;\n    }\n\n    function isAuthorized(address src, bytes4 sig) internal returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else if (authority == DSAuthority(0)) {\n            return false;\n        } else {\n            return authority.canCall(src, this, sig);\n        }\n    }\n}\n\ncontract DSNote {\n    event LogNote(\n        bytes4   indexed  sig,\n        address  indexed  guy,\n        bytes32  indexed  foo,\n        bytes32  indexed  bar,\n        uint              wad,\n        bytes             fax\n    ) anonymous;\n\n    modifier note {\n        bytes32 foo;\n        bytes32 bar;\n\n        assembly {\n            foo := calldataload(4)\n            bar := calldataload(36)\n        }\n\n        LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\n\n        _;\n    }\n}\n\ncontract DSStop is DSNote, DSAuth {\n\n    bool public stopped;\n\n    modifier stoppable {\n        require(!stopped);\n        _;\n    }\n    function stop() auth note {\n        stopped = true;\n    }\n    function start() auth note {\n        stopped = false;\n    }\n\n}\n\n/// base.sol -- basic ERC20 implementation\n\n// Token standard API\n// https://github.com/ethereum/EIPs/issues/20\n\ncontract ERC20 {\n    function totalSupply() constant returns (uint supply);\n    function balanceOf( address who ) constant returns (uint value);\n    function allowance( address owner, address spender ) constant returns (uint _allowance);\n\n    function transfer( address to, uint value) returns (bool ok);\n    function transferFrom( address from, address to, uint value) returns (bool ok);\n    function approve( address spender, uint value ) returns (bool ok);\n\n    event Transfer( address indexed from, address indexed to, uint value);\n    event Approval( address indexed owner, address indexed spender, uint value);\n}\ncontract DSMath {\n    function add(uint x, uint y) internal returns (uint z) {\n        require((z = x + y) >= x);\n    }\n    function sub(uint x, uint y) internal returns (uint z) {\n        require((z = x - y) <= x);\n    }\n    function mul(uint x, uint y) internal returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n\n    function min(uint x, uint y) internal returns (uint z) {\n        return x <= y ? x : y;\n    }\n    function max(uint x, uint y) internal returns (uint z) {\n        return x >= y ? x : y;\n    }\n    function imin(int x, int y) internal returns (int z) {\n        return x <= y ? x : y;\n    }\n    function imax(int x, int y) internal returns (int z) {\n        return x >= y ? x : y;\n    }\n\n    uint constant WAD = 10 ** 18;\n    uint constant RAY = 10 ** 27;\n\n    function wmul(uint x, uint y) internal returns (uint z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n    function rmul(uint x, uint y) internal returns (uint z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n    function wdiv(uint x, uint y) internal returns (uint z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n    function rdiv(uint x, uint y) internal returns (uint z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    // This famous algorithm is called \"exponentiation by squaring\"\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\n    //\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\n    //\n    // These facts are why it works:\n    //\n    //  If n is even, then x^n = (x^2)^(n/2).\n    //  If n is odd,  then x^n = x * x^(n-1),\n    //   and applying the equation for even x gives\n    //    x^n = x * (x^2)^((n-1) / 2).\n    //\n    //  Also, EVM division is flooring and\n    //    floor[(n-1) / 2] = floor[n / 2].\n    //\n    function rpow(uint x, uint n) internal returns (uint z) {\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n}\n\n\ncontract DSTokenBase is ERC20, DSMath {\n    uint256                                            _supply;\n    mapping (address => uint256)                       _balances;\n    mapping (address => mapping (address => uint256))  _approvals;\n\n    function DSTokenBase(uint supply) {\n        _balances[msg.sender] = supply;\n        _supply = supply;\n    }\n\n    function totalSupply() constant returns (uint) {\n        return _supply;\n    }\n    function balanceOf(address src) constant returns (uint) {\n        return _balances[src];\n    }\n    function allowance(address src, address guy) constant returns (uint) {\n        return _approvals[src][guy];\n    }\n\n    function transfer(address dst, uint wad) returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(address src, address dst, uint wad) returns (bool) {\n        if (src != msg.sender) {\n            _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);\n        }\n\n        _balances[src] = sub(_balances[src], wad);\n        _balances[dst] = add(_balances[dst], wad);\n\n        Transfer(src, dst, wad);\n\n        return true;\n    }\n\n    function approve(address guy, uint wad) returns (bool) {\n        _approvals[msg.sender][guy] = wad;\n\n        Approval(msg.sender, guy, wad);\n\n        return true;\n    }\n}\n\ncontract DSToken is DSTokenBase(0), DSStop {\n\n    mapping (address => mapping (address => bool)) _trusted;\n\n    bytes32  public  symbol;\n    uint256  public  decimals = 18; // standard token precision. override to customize\n\n    function DSToken(bytes32 symbol_) {\n        symbol = symbol_;\n    }\n\n    event Trust(address indexed src, address indexed guy, bool wat);\n    event Mint(address indexed guy, uint wad);\n    event Burn(address indexed guy, uint wad);\n\n    function trusted(address src, address guy) constant returns (bool) {\n        return _trusted[src][guy];\n    }\n    function trust(address guy, bool wat) stoppable {\n        _trusted[msg.sender][guy] = wat;\n        Trust(msg.sender, guy, wat);\n    }\n\n    function approve(address guy, uint wad) stoppable returns (bool) {\n        return super.approve(guy, wad);\n    }\n    function transferFrom(address src, address dst, uint wad)\n        stoppable\n        returns (bool)\n    {\n        if (src != msg.sender && !_trusted[src][msg.sender]) {\n            _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);\n        }\n\n        _balances[src] = sub(_balances[src], wad);\n        _balances[dst] = add(_balances[dst], wad);\n\n        Transfer(src, dst, wad);\n\n        return true;\n    }\n\n    function push(address dst, uint wad) {\n        transferFrom(msg.sender, dst, wad);\n    }\n    function pull(address src, uint wad) {\n        transferFrom(src, msg.sender, wad);\n    }\n    function move(address src, address dst, uint wad) {\n        transferFrom(src, dst, wad);\n    }\n\n    function mint(uint wad) {\n        mint(msg.sender, wad);\n    }\n    function burn(uint wad) {\n        burn(msg.sender, wad);\n    }\n    function mint(address guy, uint wad) auth stoppable {\n        _balances[guy] = add(_balances[guy], wad);\n        _supply = add(_supply, wad);\n        Mint(guy, wad);\n    }\n    function burn(address guy, uint wad) auth stoppable {\n        if (guy != msg.sender && !_trusted[guy][msg.sender]) {\n            _approvals[guy][msg.sender] = sub(_approvals[guy][msg.sender], wad);\n        }\n\n        _balances[guy] = sub(_balances[guy], wad);\n        _supply = sub(_supply, wad);\n        Burn(guy, wad);\n    }\n\n    // Optional token name\n    bytes32   public  name = \"\";\n\n    function setName(bytes32 name_) auth {\n        name = name_;\n    }\n}\n\n/// @title ERC223ReceivingContract - Standard contract implementation for compatibility with ERC223 tokens.\ncontract ERC223ReceivingContract {\n\n    /// @dev Function that is called when a user or another contract wants to transfer funds.\n    /// @param _from Transaction initiator, analogue of msg.sender\n    /// @param _value Number of tokens to transfer.\n    /// @param _data Data containig a function signature and/or parameters\n    function tokenFallback(address _from, uint256 _value, bytes _data) public;\n}\n\n/// @dev The token controller contract must implement these functions\ncontract TokenController {\n    /// @notice Called when `_owner` sends ether to the MiniMe Token contract\n    /// @param _owner The address that sent the ether to create tokens\n    /// @return True if the ether is accepted, false if it throws\n    function proxyPayment(address _owner) payable returns(bool);\n\n    /// @notice Notifies the controller about a token transfer allowing the\n    ///  controller to react if desired\n    /// @param _from The origin of the transfer\n    /// @param _to The destination of the transfer\n    /// @param _amount The amount of the transfer\n    /// @return False if the controller does not authorize the transfer\n    function onTransfer(address _from, address _to, uint _amount) returns(bool);\n\n    /// @notice Notifies the controller about an approval allowing the\n    ///  controller to react if desired\n    /// @param _owner The address that calls `approve()`\n    /// @param _spender The spender in the `approve()` call\n    /// @param _amount The amount in the `approve()` call\n    /// @return False if the controller does not authorize the approval\n    function onApprove(address _owner, address _spender, uint _amount)\n        returns(bool);\n}\n\ncontract Controlled {\n    /// @notice The address of the controller is the only address that can call\n    ///  a function with this modifier\n    modifier onlyController { if (msg.sender != controller) throw; _; }\n\n    address public controller;\n\n    function Controlled() { controller = msg.sender;}\n\n    /// @notice Changes the controller of the contract\n    /// @param _newController The new controller of the contract\n    function changeController(address _newController) onlyController {\n        controller = _newController;\n    }\n}\n\ncontract ApproveAndCallFallBack {\n    function receiveApproval(address from, uint256 _amount, address _token, bytes _data);\n}\n\ncontract PLS is DSToken(\"PLS\"), Controlled {\n\n    function PLS() {\n        setName(\"DACPLAY Token\");\n    }\n\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\n    ///  is approved by `_from`\n    /// @param _from The address holding the tokens being transferred\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transferred\n    /// @return True if the transfer was successful\n    function transferFrom(address _from, address _to, uint256 _amount\n    ) returns (bool success) {\n        // Alerts the token controller of the transfer\n        if (isContract(controller)) {\n            if (!TokenController(controller).onTransfer(_from, _to, _amount))\n               throw;\n        }\n\n        success = super.transferFrom(_from, _to, _amount);\n\n        if (success && isContract(_to))\n        {\n            // Refer Contract Interface ApproveAndCallFallBack, using keccak256 since sha3 has been deprecated.\n            if(!_to.call(bytes4(bytes32(keccak256(\"receiveToken(address,uint256,address)\"))), _from, _amount, this)) {\n                // do nothing when error in call in case that the _to contract is not inherited from ReceiveAndCallFallBack\n                // revert();\n                // TODO: Log Some Event here to record the fail.\n                // Even the fallback failed if there is such one, the transfer will not be revert since \"revert()\" is not called.\n            }\n        }\n    }\n\n    /*\n     * ERC 223\n     * Added support for the ERC 223 \"tokenFallback\" method in a \"transfer\" function with a payload.\n     * https://github.com/ethereum/EIPs/issues/223\n     * function transfer(address _to, uint256 _value, bytes _data) public returns (bool success);\n     */\n\n    /// @notice Send `_value` tokens to `_to` from `msg.sender` and trigger\n    /// tokenFallback if sender is a contract.\n    /// @dev Function that is called when a user or another contract wants to transfer funds.\n    /// @param _to Address of token receiver.\n    /// @param _value Number of tokens to transfer.\n    /// @param _data Data to be sent to tokenFallback\n    /// @return Returns success of function call.\n    function transfer(\n        address _to,\n        uint256 _value,\n        bytes _data)\n        public\n        returns (bool)\n    {\n        require(transfer(_to, _value));\n\n        if (isContract(_to)) {\n            ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\n            receiver.tokenFallback(msg.sender, _value, _data);\n        }\n\n        return true;\n    }\n\n    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\n    ///  its behalf. This is a modified version of the ERC20 approve function\n    ///  to be a little bit safer\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _amount The amount of tokens to be approved for transfer\n    /// @return True if the approval was successful\n    function approve(address _spender, uint256 _amount) returns (bool success) {\n        // Alerts the token controller of the approve function call\n        if (isContract(controller)) {\n            if (!TokenController(controller).onApprove(msg.sender, _spender, _amount))\n                throw;\n        }\n        \n        return super.approve(_spender, _amount);\n    }\n\n    function mint(address _guy, uint _wad) auth stoppable {\n        super.mint(_guy, _wad);\n\n        Transfer(0, _guy, _wad);\n    }\n    function burn(address _guy, uint _wad) auth stoppable {\n        super.burn(_guy, _wad);\n\n        Transfer(_guy, 0, _wad);\n    }\n\n    /// @notice `msg.sender` approves `_spender` to send `_amount` tokens on\n    ///  its behalf, and then a function is triggered in the contract that is\n    ///  being approved, `_spender`. This allows users to use their tokens to\n    ///  interact with contracts in one function call instead of two\n    /// @param _spender The address of the contract able to transfer the tokens\n    /// @param _amount The amount of tokens to be approved for transfer\n    /// @return True if the function call was successful\n    function approveAndCall(address _spender, uint256 _amount, bytes _extraData\n    ) returns (bool success) {\n        if (!approve(_spender, _amount)) throw;\n\n        ApproveAndCallFallBack(_spender).receiveApproval(\n            msg.sender,\n            _amount,\n            this,\n            _extraData\n        );\n\n        return true;\n    }\n\n    /// @dev Internal function to determine if an address is a contract\n    /// @param _addr The address being queried\n    /// @return True if `_addr` is a contract\n    function isContract(address _addr) constant internal returns(bool) {\n        uint size;\n        if (_addr == 0) return false;\n        assembly {\n            size := extcodesize(_addr)\n        }\n        return size>0;\n    }\n\n    /// @notice The fallback function: If the contract's controller has not been\n    ///  set to 0, then the `proxyPayment` method is called which relays the\n    ///  ether and creates tokens as described in the token controller contract\n    function ()  payable {\n        if (isContract(controller)) {\n            if (! TokenController(controller).proxyPayment.value(msg.value)(msg.sender))\n                throw;\n        } else {\n            throw;\n        }\n    }\n\n//////////\n// Safety Methods\n//////////\n\n    /// @notice This method can be used by the controller to extract mistakenly\n    ///  sent tokens to this contract.\n    /// @param _token The address of the token contract that you want to recover\n    ///  set to 0 in case you want to extract ether.\n    function claimTokens(address _token) onlyController {\n        if (_token == 0x0) {\n            controller.transfer(this.balance);\n            return;\n        }\n\n        ERC20 token = ERC20(_token);\n        uint balance = token.balanceOf(this);\n        token.transfer(controller, balance);\n        ClaimedTokens(_token, controller, balance);\n    }\n\n////////////////\n// Events\n////////////////\n\n    event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\n\n}\n\ncontract MigrateController is DSAuth, TokenController {\n    PLS public  pls;\n\n    function MigrateController(address _pls) {\n        pls = PLS(_pls);\n    }\n\n    /// @notice The owner of this contract can change the controller of the PLS token\n    ///  Please, be sure that the owner is a trusted agent or 0x0 address.\n    /// @param _newController The address of the new controller\n    function changeController(address _newController) public auth {\n        require(_newController != 0x0);\n        pls.changeController(_newController);\n        ControllerChanged(_newController);\n    }\n    \n    // In between the offering and the network. Default settings for allowing token transfers.\n    function proxyPayment(address) public payable returns (bool) {\n        return false;\n    }\n    \n    function onTransfer(address, address, uint256) public returns (bool) {\n        return true;\n    }\n\n    function onApprove(address, address, uint256) public returns (bool) {\n        return true;\n    }\n\n    function mint(address _th, uint256 _amount, bytes data) auth {\n        pls.mint(_th, _amount);\n\n        NewIssue(_th, _amount, data);\n    }\n  \n    /// @dev Internal function to determine if an address is a contract\n    /// @param _addr The address being queried\n    /// @return True if `_addr` is a contract\n    function isContract(address _addr) constant internal returns (bool) {\n        if (_addr == 0) return false;\n        uint256 size;\n        assembly {\n            size := extcodesize(_addr)\n        }\n        return (size > 0);\n    }\n\n    function time() constant returns (uint) {\n        return block.timestamp;\n    }\n\n    //////////\n    // Testing specific methods\n    //////////\n\n    /// @notice This function is overridden by the test Mocks.\n    function getBlockNumber() internal constant returns (uint256) {\n        return block.number;\n    }\n\n    //////////\n    // Safety Methods\n    //////////\n\n    /// @notice This method can be used by the controller to extract mistakenly\n    ///  sent tokens to this contract.\n    /// @param _token The address of the token contract that you want to recover\n    ///  set to 0 in case you want to extract ether.\n    function claimTokens(address _token) public auth {\n        if (pls.controller() == address(this)) {\n            pls.claimTokens(_token);\n        }\n        if (_token == 0x0) {\n            owner.transfer(this.balance);\n            return;\n        }\n\n        ERC20 token = ERC20(_token);\n        uint256 balance = token.balanceOf(this);\n        token.transfer(owner, balance);\n        ClaimedTokens(_token, owner, balance);\n    }\n\n    event ClaimedTokens(address indexed _token, address indexed _controller, uint256 _amount);\n    event NewIssue(address indexed _th, uint256 _amount, bytes data);\n    event ControllerChanged(address indexed _newController);\n}",
  "bytecode": "6060604052341561000f57600080fd5b604051602080610a95833981016040528080519150505b5b60018054600160a060020a03191633600160a060020a03169081179091557fce241d7ca1f669fee44b6fc00b8eba2df3bb514eed0f6f668f8f89096e81ed9460405160405180910390a25b60028054600160a060020a031916600160a060020a0383161790555b505b6109f68061009f6000396000f3006060604052361561009e5763ffffffff60e060020a60003504166313af403581146100a357806316ada547146100c4578063223e5a9d146100e95780633cebb823146101185780634a393149146101395780637a9e5e4b146101755780638da5cb5b1461019657806394d008ef146101c5578063bf7e214f1461022c578063da682aeb14610139578063df8de3e714610297578063f48c3054146102b8575b600080fd5b34156100ae57600080fd5b6100c2600160a060020a03600435166102e0565b005b34156100cf57600080fd5b6100d7610361565b60405190815260200160405180910390f35b34156100f457600080fd5b6100fc610366565b604051600160a060020a03909116815260200160405180910390f35b341561012357600080fd5b6100c2600160a060020a0360043516610375565b005b341561014457600080fd5b610161600160a060020a036004358116906024351660443561044a565b604051901515815260200160405180910390f35b341561018057600080fd5b6100c2600160a060020a0360043516610454565b005b34156101a157600080fd5b6100fc6104d5565b604051600160a060020a03909116815260200160405180910390f35b34156101d057600080fd5b6100c260048035600160a060020a03169060248035919060649060443590810190830135806020601f820181900481020160405190810160405281815292919060208401838380828437509496506104e495505050505050565b005b341561023757600080fd5b6100fc610621565b604051600160a060020a03909116815260200160405180910390f35b341561014457600080fd5b610161600160a060020a036004358116906024351660443561044a565b604051901515815260200160405180910390f35b34156102a257600080fd5b6100c2600160a060020a036004351661063a565b005b610161600160a060020a03600435166108c7565b604051901515815260200160405180910390f35b6102f633600035600160e060020a0319166108cf565b151561030157600080fd5b6001805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a038381169190911791829055167fce241d7ca1f669fee44b6fc00b8eba2df3bb514eed0f6f668f8f89096e81ed9460405160405180910390a25b5b50565b425b90565b600254600160a060020a031681565b61038b33600035600160e060020a0319166108cf565b151561039657600080fd5b600160a060020a03811615156103ab57600080fd5b600254600160a060020a0316633cebb8238260405160e060020a63ffffffff8416028152600160a060020a039091166004820152602401600060405180830381600087803b15156103fb57600080fd5b6102c65a03f1151561040c57600080fd5b50505080600160a060020a03167f027c3e080ed9215f564a9455a666f7e459b3edc0bb6e02a1bf842fde4d0ccfc160405160405180910390a25b5b50565b60015b9392505050565b61046a33600035600160e060020a0319166108cf565b151561047557600080fd5b6000805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a038381169190911791829055167f1abebea81bfa2637f28358c371278fb15ede7ea8dd28d2e03b112ff6d936ada460405160405180910390a25b5b50565b600154600160a060020a031681565b6104fa33600035600160e060020a0319166108cf565b151561050557600080fd5b600254600160a060020a03166340c10f19848460405160e060020a63ffffffff8516028152600160a060020a0390921660048301526024820152604401600060405180830381600087803b151561055b57600080fd5b6102c65a03f1151561056c57600080fd5b50505082600160a060020a03167ff4b0ce039ec5c89fcad91f235beb5f788e7ffdf9325cc02314194dbffa58fca2838360405182815260406020820181815290820183818151815260200191508051906020019080838360005b838110156105df5780820151818401525b6020016105c6565b50505050905090810190601f16801561060c5780820380516001836020036101000a031916815260200191505b50935050505060405180910390a25b5b505050565b600054600160a060020a031681565b60015b9392505050565b60008061065333600035600160e060020a0319166108cf565b151561065e57600080fd5b600254600160a060020a03308116911663f77c47916000604051602001526040518163ffffffff1660e060020a028152600401602060405180830381600087803b15156106aa57600080fd5b6102c65a03f115156106bb57600080fd5b50505060405180519050600160a060020a0316141561073957600254600160a060020a031663df8de3e78460405160e060020a63ffffffff8416028152600160a060020a039091166004820152602401600060405180830381600087803b151561072457600080fd5b6102c65a03f1151561073557600080fd5b5050505b600160a060020a038316151561078757600154600160a060020a039081169030163180156108fc0290604051600060405180830381858888f19350505050151561078257600080fd5b61061b565b82915081600160a060020a03166370a082313060006040516020015260405160e060020a63ffffffff8416028152600160a060020a039091166004820152602401602060405180830381600087803b15156107e157600080fd5b6102c65a03f115156107f257600080fd5b5050506040518051600154909250600160a060020a03808516925063a9059cbb91168360006040516020015260405160e060020a63ffffffff8516028152600160a060020a0390921660048301526024820152604401602060405180830381600087803b151561086157600080fd5b6102c65a03f1151561087257600080fd5b50505060405180515050600154600160a060020a039081169084167ff931edb47c50b4b4104c187b5814a9aef5f709e17e2ecf9617e860cacade929c8360405190815260200160405180910390a35b5b505050565b60005b919050565b600030600160a060020a031683600160a060020a031614156108f3575060016109c1565b600154600160a060020a0384811691161415610911575060016109c1565b600054600160a060020a0316151561092b575060006109c1565b60008054600160a060020a03169063b7009613908590309086906040516020015260405160e060020a63ffffffff8616028152600160a060020a039384166004820152919092166024820152600160e060020a03199091166044820152606401602060405180830381600087803b15156109a457600080fd5b6102c65a03f115156109b557600080fd5b50505060405180519150505b5b5b5b929150505600a165627a7a72305820e71cda50ab493ce2f14ad01e4f77bf7376972b1abab019875da9fe587a8412000029000000000000000000000000e43ac1714f7394173b15e7cff31a63d523ce4fb9",
  "constructorArguments": "000000000000000000000000e43ac1714f7394173b15e7cff31a63d523ce4fb9"
}