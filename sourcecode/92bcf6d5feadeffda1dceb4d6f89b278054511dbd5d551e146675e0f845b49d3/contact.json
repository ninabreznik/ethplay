{
  "address": "0x81c04a2a864d6e50244a869a8f5e9b639eaff498",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "Reward",
  "compilerVersion": "v0.4.25+commit.59dbf8f1",
  "optimization": false,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2019-01-12\n*/\n\npragma solidity ^0.4.24;\n\n/*\n*   gibmireinbier\n*   0xA4a799086aE18D7db6C4b57f496B081b44888888\n*   [emailÂ protected]\n*/\n\nlibrary SafeMath {\n    int256 constant private INT256_MIN = -2**255;\n\n    /**\n    * @dev Multiplies two unsigned integers, reverts on overflow.\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n    * @dev Multiplies two signed integers, reverts on overflow.\n    */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        require(!(a == -1 && b == INT256_MIN)); // This is the only case of overflow not detected by the check below\n\n        int256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\n    */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        require(b != 0); // Solidity only automatically asserts when dividing by 0\n        require(!(b == -1 && a == INT256_MIN)); // This is the only case of overflow\n\n        int256 c = a / b;\n\n        return c;\n    }\n\n    /**\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n    * @dev Subtracts two signed integers, reverts on overflow.\n    */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\n\n        return c;\n    }\n\n    /**\n    * @dev Adds two unsigned integers, reverts on overflow.\n    */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n    * @dev Adds two signed integers, reverts on overflow.\n    */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\n\n        return c;\n    }\n\n    /**\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n    * reverts when dividing by zero.\n    */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n\nlibrary Helper {\n    using SafeMath for uint256;\n\n    uint256 constant public ZOOM = 1000;\n    uint256 constant public SDIVIDER = 3450000;\n    uint256 constant public PDIVIDER = 3450000;\n    uint256 constant public RDIVIDER = 1580000;\n    // Starting LS price (SLP)\n    uint256 constant public SLP = 0.002 ether;\n    // Starting Added Time (SAT)\n    uint256 constant public SAT = 30; // seconds\n    // Price normalization (PN)\n    uint256 constant public PN = 777;\n    // EarlyIncome base\n    uint256 constant public PBASE = 13;\n    uint256 constant public PMULTI = 26;\n    uint256 constant public LBase = 15;\n\n    uint256 constant public ONE_HOUR = 3600;\n    uint256 constant public ONE_DAY = 24 * ONE_HOUR;\n    //uint256 constant public TIMEOUT0 = 3 * ONE_HOUR;\n    uint256 constant public TIMEOUT1 = 12 * ONE_HOUR;\n    \n    function bytes32ToString (bytes32 data)\n        public\n        pure\n        returns (string) \n    {\n        bytes memory bytesString = new bytes(32);\n        for (uint j=0; j<32; j++) {\n            byte char = byte(bytes32(uint(data) * 2 ** (8 * j)));\n            if (char != 0) {\n                bytesString[j] = char;\n            }\n        }\n        return string(bytesString);\n    }\n    \n    function uintToBytes32(uint256 n)\n        public\n        pure\n        returns (bytes32) \n    {\n        return bytes32(n);\n    }\n    \n    function bytes32ToUint(bytes32 n) \n        public\n        pure\n        returns (uint256) \n    {\n        return uint256(n);\n    }\n    \n    function stringToBytes32(string memory source) \n        public\n        pure\n        returns (bytes32 result) \n    {\n        bytes memory tempEmptyStringTest = bytes(source);\n        if (tempEmptyStringTest.length == 0) {\n            return 0x0;\n        }\n\n        assembly {\n            result := mload(add(source, 32))\n        }\n    }\n    \n    function stringToUint(string memory source) \n        public\n        pure\n        returns (uint256)\n    {\n        return bytes32ToUint(stringToBytes32(source));\n    }\n    \n    function uintToString(uint256 _uint) \n        public\n        pure\n        returns (string)\n    {\n        return bytes32ToString(uintToBytes32(_uint));\n    }\n\n/*     \n    function getSlice(uint256 begin, uint256 end, string text) public pure returns (string) {\n        bytes memory a = new bytes(end-begin+1);\n        for(uint i = 0; i <= end - begin; i++){\n            a[i] = bytes(text)[i + begin - 1];\n        }\n        return string(a);    \n    }\n */\n    function validUsername(string _username)\n        public\n        pure\n        returns(bool)\n    {\n        uint256 len = bytes(_username).length;\n        // Im Raum [4, 18]\n        if ((len < 4) || (len > 18)) return false;\n        // Letzte Char != ' '\n        if (bytes(_username)[len-1] == 32) return false;\n        // Erste Char != '0'\n        return uint256(bytes(_username)[0]) != 48;\n    }\n\n    // Lottery Helper\n\n    // Seconds added per LT = SAT - ((Current no. of LT + 1) / SDIVIDER)^6\n    function getAddedTime(uint256 _rTicketSum, uint256 _tAmount)\n        public\n        pure\n        returns (uint256)\n    {\n        //Luppe = 10000 = 10^4\n        uint256 base = (_rTicketSum + 1).mul(10000) / SDIVIDER;\n        uint256 expo = base;\n        expo = expo.mul(expo).mul(expo); // ^3\n        expo = expo.mul(expo); // ^6\n        // div 10000^6\n        expo = expo / (10**24);\n\n        if (expo > SAT) return 0;\n        return (SAT - expo).mul(_tAmount);\n    }\n\n    function getNewEndTime(uint256 toAddTime, uint256 slideEndTime, uint256 fixedEndTime)\n        public\n        view\n        returns(uint256)\n    {\n        uint256 _slideEndTime = (slideEndTime).add(toAddTime);\n        uint256 timeout = _slideEndTime.sub(block.timestamp);\n        // timeout capped at TIMEOUT1\n        if (timeout > TIMEOUT1) timeout = TIMEOUT1;\n        _slideEndTime = (block.timestamp).add(timeout);\n        // Capped at fixedEndTime\n        if (_slideEndTime > fixedEndTime)  return fixedEndTime;\n        return _slideEndTime;\n    }\n\n    // get random in range [1, _range] with _seed\n    function getRandom(uint256 _seed, uint256 _range)\n        public\n        pure\n        returns(uint256)\n    {\n        if (_range == 0) return _seed;\n        return (_seed % _range) + 1;\n    }\n\n\n    function getEarlyIncomeMul(uint256 _ticketSum)\n        public\n        pure\n        returns(uint256)\n    {\n        // Early-Multiplier = 1 + PBASE / (1 + PMULTI * ((Current No. of LT)/RDIVIDER)^6)\n        uint256 base = _ticketSum * ZOOM / RDIVIDER;\n        uint256 expo = base.mul(base).mul(base); //^3\n        expo = expo.mul(expo) / (ZOOM**6); //^6\n        return (1 + PBASE / (1 + expo.mul(PMULTI)));\n    }\n\n    // get reveiced Tickets, based on current round ticketSum\n    function getTAmount(uint256 _ethAmount, uint256 _ticketSum) \n        public\n        pure\n        returns(uint256)\n    {\n        uint256 _tPrice = getTPrice(_ticketSum);\n        return _ethAmount.div(_tPrice);\n    }\n\n    // Lotto-Multiplier = 1 + LBase * (Current No. of Tickets / PDivider)^6\n    function getTMul(uint256 _ticketSum) // Unit Wei\n        public\n        pure\n        returns(uint256)\n    {\n        uint256 base = _ticketSum * ZOOM / PDIVIDER;\n        uint256 expo = base.mul(base).mul(base);\n        expo = expo.mul(expo); // ^6\n        return 1 + expo.mul(LBase) / (10**18);\n    }\n\n    // get ticket price, based on current round ticketSum\n    //unit in ETH, no need / zoom^6\n    function getTPrice(uint256 _ticketSum)\n        public\n        pure\n        returns(uint256)\n    {\n        uint256 base = (_ticketSum + 1).mul(ZOOM) / PDIVIDER;\n        uint256 expo = base;\n        expo = expo.mul(expo).mul(expo); // ^3\n        expo = expo.mul(expo); // ^6\n        uint256 tPrice = SLP + expo / PN;\n        return tPrice;\n    }\n\n    // get weight of slot, chance to win grandPot\n    function getSlotWeight(uint256 _ethAmount, uint256 _ticketSum)\n        public\n        pure\n        returns(uint256)\n    {\n        uint256 _tAmount = getTAmount(_ethAmount, _ticketSum);\n        uint256 _tMul = getTMul(_ticketSum);\n        return (_tAmount).mul(_tMul);\n    }\n\n    // used to draw grandpot results\n    // weightRange = roundWeight * grandpot / (grandpot - initGrandPot)\n    // grandPot = initGrandPot + round investedSum(for grandPot)\n    function getWeightRange(uint256 grandPot, uint256 initGrandPot, uint256 curRWeight)\n        public\n        pure\n        returns(uint256)\n    {\n        //calculate round grandPot-investedSum\n        uint256 grandPotInvest = grandPot - initGrandPot;\n        if (grandPotInvest == 0) return 8;\n        uint256 zoomMul = grandPot * ZOOM / grandPotInvest;\n        uint256 weightRange = zoomMul * curRWeight / ZOOM;\n        if (weightRange < curRWeight) weightRange = curRWeight;\n        return weightRange;\n    }\n}\n\ninterface DevTeamInterface {\n    function setF2mAddress(address _address) public;\n    function setLotteryAddress(address _address) public;\n    function setCitizenAddress(address _address) public;\n    function setBankAddress(address _address) public;\n    function setRewardAddress(address _address) public;\n    function setWhitelistAddress(address _address) public;\n\n    function setupNetwork() public;\n}\n\ninterface LotteryInterface {\n    function joinNetwork(address[6] _contract) public;\n    // call one time\n    function activeFirstRound() public;\n    // Core Functions\n    function pushToPot() public payable;\n    function finalizeable() public view returns(bool);\n    // bounty\n    function finalize() public;\n    function buy(string _sSalt) public payable;\n    function buyFor(string _sSalt, address _sender) public payable;\n    //function withdraw() public;\n    function withdrawFor(address _sender) public returns(uint256);\n\n    function getRewardBalance(address _buyer) public view returns(uint256);\n    function getTotalPot() public view returns(uint256);\n    // EarlyIncome\n    function getEarlyIncomeByAddress(address _buyer) public view returns(uint256);\n    // included claimed amount\n    // function getEarlyIncomeByAddressRound(address _buyer, uint256 _rId) public view returns(uint256);\n    function getCurEarlyIncomeByAddress(address _buyer) public view returns(uint256);\n    // function getCurEarlyIncomeByAddressRound(address _buyer, uint256 _rId) public view returns(uint256);\n    function getCurRoundId() public view returns(uint256);\n    // set endRound, prepare to upgrade new version\n    function setLastRound(uint256 _lastRoundId) public;\n    function getPInvestedSumByRound(uint256 _rId, address _buyer) public view returns(uint256);\n    function cashoutable(address _address) public view returns(bool);\n    function isLastRound() public view returns(bool);\n}\n\ncontract Reward {\n    using SafeMath for uint256;\n\n    event NewReward(address indexed _lucker, uint256[5] _info);\n    \n    modifier onlyOwner() {\n        require(msg.sender == address(lotteryContract), \"This is just log for lottery contract\");\n        _;\n    }\n\n    modifier claimable() {\n        require(\n            rest > 1 && \n            block.number > lastBlock &&\n            lastRoundClaim[msg.sender] < lastRoundId,\n            \"out of stock in this round, block or already claimed\");\n        _;\n    }\n\n/*     \n    enum RewardType {\n        Minor, 0\n        Major, 1\n        Grand, 2\n        Bounty 3\n        SBounty 4 // smal bounty\n    } \n*/\n\n    struct Rewards {\n        address lucker;\n        uint256 time;\n        uint256 rId;\n        uint256 value;\n        uint256 winNumber;\n        uint256 rewardType;\n    }\n\n    Rewards[] public rewardList;\n    // reward array by address\n    mapping( address => uint256[]) public pReward;\n    // reward sum by address\n    mapping( address => uint256) public pRewardedSum;\n    // reward sum by address, round\n    mapping( address => mapping(uint256 => uint256)) public pRewardedSumPerRound;\n    // reward sum by round\n    mapping( uint256 => uint256) public rRewardedSum;\n    // reward sum all round, all addresses\n    uint256 public rewardedSum;\n    \n    // last claimed round by address to check timeout\n    // timeout balance will be pushed to dividends\n    mapping(address => uint256) lastRoundClaim;\n\n    LotteryInterface lotteryContract;\n\n    //////////////////////////////////////////////////////////\n    \n    // rest times for sBounty, small bountys free for all (round-players) after each round\n    uint256 public rest = 0;\n    // last block that sBounty claimed, to prevent 2 time claimed in same block\n    uint256 public lastBlock = 0;\n    // sBounty will be saved in logs of last round\n    // new round will be started after sBountys pushed\n    uint256 public lastRoundId;\n\n    constructor (address _devTeam)\n        public\n    {\n        // register address in network\n        DevTeamInterface(_devTeam).setRewardAddress(address(this));\n    }\n\n    // _contract = [f2mAddress, bankAddress, citizenAddress, lotteryAddress, rewardAddress, whitelistAddress];\n    function joinNetwork(address[6] _contract)\n        public\n    {\n        require((address(lotteryContract) == 0x0),\"already setup\");\n        lotteryContract = LotteryInterface(_contract[3]);\n    }\n\n    // sBounty program\n    // rules :\n    // 1. accept only eth from lottery contract\n    // 2. one claim per block\n    // 3. one claim per address (reset each round)\n\n    function getSBounty()\n        public\n        view\n        returns(uint256, uint256, uint256)\n    {\n        uint256 sBountyAmount = rest < 2 ? 0 : address(this).balance / (rest-1);\n        return (rest, sBountyAmount, lastRoundId);\n    }\n\n    // pushed from lottery contract only\n    function pushBounty(uint256 _curRoundId) \n        public \n        payable \n        onlyOwner() \n    {\n        rest = 8;\n        lastBlock = block.number;\n        lastRoundId = _curRoundId;\n    }\n\n    function claim()\n        public\n        claimable()\n    {\n        address _sender = msg.sender;\n        uint256 rInvested = lotteryContract.getPInvestedSumByRound(lastRoundId, _sender);\n        require(rInvested > 0, \"sorry, not invested no bounty\");\n        lastBlock = block.number;\n        lastRoundClaim[_sender] = lastRoundId;\n        rest = rest - 1;\n        uint256 claimAmount = address(this).balance / rest;\n        _sender.transfer(claimAmount);\n        mintRewardCore(\n            _sender,\n            lastRoundId,\n            0,\n            0,\n            claimAmount,\n            4\n        );\n    }\n\n    // rewards sealed by lottery contract\n    function mintReward(\n        address _lucker,\n        uint256 _curRoundId,\n        uint256 _tNumberFrom,\n        uint256 _tNumberTo,\n        uint256 _value,\n        uint256 _rewardType)\n        public\n        onlyOwner()\n    {\n        mintRewardCore(\n            _lucker,\n            _curRoundId,\n            _tNumberFrom,\n            _tNumberTo,\n            _value,\n            _rewardType);\n    }\n\n    // reward logs generator\n    function mintRewardCore(\n        address _lucker,\n        uint256 _curRoundId,\n        uint256 _tNumberFrom,\n        uint256 _tNumberTo,\n        uint256 _value,\n        uint256 _rewardType)\n        private\n    {\n        Rewards memory _reward;\n        _reward.lucker = _lucker;\n        _reward.time = block.timestamp;\n        _reward.rId = _curRoundId;\n        _reward.value = _value;\n\n        // get winning number if rewardType is not bounty or sBounty\n        // seed = rewardList.length to be sure that seed changed after\n        // every reward minting\n        if (_rewardType < 3)\n        _reward.winNumber = getWinNumberBySlot(_tNumberFrom, _tNumberTo);\n\n        _reward.rewardType = _rewardType;\n        rewardList.push(_reward);\n        pReward[_lucker].push(rewardList.length - 1);\n        // reward sum logs\n        pRewardedSum[_lucker] += _value;\n        rRewardedSum[_curRoundId] += _value;\n        rewardedSum += _value;\n        pRewardedSumPerRound[_lucker][_curRoundId] += _value;\n        emit NewReward(_reward.lucker, [_reward.time, _reward.rId, _reward.value, _reward.winNumber, uint256(_reward.rewardType)]);\n    }\n\n    function getWinNumberBySlot(uint256 _tNumberFrom, uint256 _tNumberTo)\n        public\n        view\n        returns(uint256)\n    {\n        //uint256 _seed = uint256(keccak256(rewardList.length));\n        uint256 _seed = rewardList.length * block.number + block.timestamp;\n        // get random number in range (1, _to - _from + 1)\n        uint256 _winNr = Helper.getRandom(_seed, _tNumberTo + 1 - _tNumberFrom);\n        return _tNumberFrom + _winNr - 1;\n    }\n\n    function getPRewardLength(address _sender)\n        public\n        view\n        returns(uint256)\n    {\n        return pReward[_sender].length;\n    }\n\n    function getRewardListLength()\n        public\n        view\n        returns(uint256)\n    {\n        return rewardList.length;\n    }\n\n    function getPRewardId(address _sender, uint256 i)\n        public\n        view\n        returns(uint256)\n    {\n        return pReward[_sender][i];\n    }\n\n    function getPRewardedSumByRound(uint256 _rId, address _buyer)\n        public\n        view\n        returns(uint256)\n    {\n        return pRewardedSumPerRound[_buyer][_rId];\n    }\n\n    function getRewardedSumByRound(uint256 _rId)\n        public\n        view\n        returns(uint256)\n    {\n        return rRewardedSum[_rId];\n    }\n\n    function getRewardInfo(uint256 _id)\n        public\n        view\n        returns(\n            address,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        Rewards memory _reward = rewardList[_id];\n        return (\n            _reward.lucker,\n            _reward.winNumber,\n            _reward.time,\n            _reward.rId,\n            _reward.value,\n            _reward.rewardType\n        );\n    }\n}",
  "bytecode": "60806040526000600855600060095534801561001a57600080fd5b506040516020806116c4833981018060405281019080805190602001909291905050508073ffffffffffffffffffffffffffffffffffffffff16635e00e679306040518263ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001915050600060405180830381600087803b1580156100d857600080fd5b505af11580156100ec573d6000803e3d6000fd5b50505050506115c4806101006000396000f30060806040526004361061011d576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680630a1871f91461012257806310d6667714610183578063243d38271461021357806327578a5b146102a35780633865bf3a14610304578063388ca80f1461035657806347b112f9146103815780634e71d92d146103d85780635a87c380146103ef578063664ec0cd1461041a578063806b984f1461045b578063834be97814610486578063ad6dfe5c146104c7578063afcd7dad14610528578063b1c9cc6c14610553578063bfbbfb1d1461058c578063c0ea09d7146105d7578063d6026ac114610602578063ed6d916914610663578063f2980eb214610683578063f9a01e94146106da575b600080fd5b34801561012e57600080fd5b5061016d600480360381019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291908035906020019092919050505061074f565b6040518082815260200191505060405180910390f35b34801561018f57600080fd5b506101ae6004803603810190808035906020019092919050505061077f565b604051808773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001868152602001858152602001848152602001838152602001828152602001965050505050505060405180910390f35b34801561021f57600080fd5b5061023e600480360381019080803590602001909291905050506107ea565b604051808773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001868152602001858152602001848152602001838152602001828152602001965050505050505060405180910390f35b3480156102af57600080fd5b506102ee600480360381019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803590602001909291905050506108e2565b6040518082815260200191505060405180910390f35b34801561031057600080fd5b506103546004803603810190808060c00190600680602002604051908101604052809291908260066020028082843782019150505050509192919290505050610907565b005b34801561036257600080fd5b5061036b610a0e565b6040518082815260200191505060405180910390f35b34801561038d57600080fd5b506103c2600480360381019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610a14565b6040518082815260200191505060405180910390f35b3480156103e457600080fd5b506103ed610a2c565b005b3480156103fb57600080fd5b50610404610d87565b6040518082815260200191505060405180910390f35b34801561042657600080fd5b5061044560048036038101908080359060200190929190505050610d93565b6040518082815260200191505060405180910390f35b34801561046757600080fd5b50610470610dab565b6040518082815260200191505060405180910390f35b34801561049257600080fd5b506104b160048036038101908080359060200190929190505050610db1565b6040518082815260200191505060405180910390f35b3480156104d357600080fd5b50610512600480360381019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050610dce565b6040518082815260200191505060405180910390f35b34801561053457600080fd5b5061053d610e2f565b6040518082815260200191505060405180910390f35b34801561055f57600080fd5b50610568610e35565b60405180848152602001838152602001828152602001935050505060405180910390f35b34801561059857600080fd5b506105c16004803603810190808035906020019092919080359060200190929190505050610e8a565b6040518082815260200191505060405180910390f35b3480156105e357600080fd5b506105ec610f60565b6040518082815260200191505060405180910390f35b34801561060e57600080fd5b5061064d60048036038101908080359060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610f66565b6040518082815260200191505060405180910390f35b61068160048036038101908080359060200190929190505050610fc1565b005b34801561068f57600080fd5b506106c4600480360381019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506110c4565b6040518082815260200191505060405180910390f35b3480156106e657600080fd5b5061074d600480360381019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291908035906020019092919080359060200190929190803590602001909291908035906020019092919080359060200190929190505050611110565b005b60016020528160005260406000208181548110151561076a57fe5b90600052602060002001600091509150505481565b60008181548110151561078e57fe5b90600052602060002090600602016000915090508060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16908060010154908060020154908060030154908060040154908060050154905086565b6000806000806000806107fb61154b565b60008881548110151561080a57fe5b906000526020600020906006020160c060405190810160405290816000820160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600182015481526020016002820154815260200160038201548152602001600482015481526020016005820154815250509050806000015181608001518260200151836040015184606001518560a001519650965096509650965096505091939550919395565b6003602052816000526040600020602052806000526040600020600091509150505481565b6000600760009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff161415156109b7576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252600d8152602001807f616c72656164792073657475700000000000000000000000000000000000000081525060200191505060405180910390fd5b8060036006811015156109c657fe5b6020020151600760006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b600a5481565b60026020528060005260406000206000915090505481565b60008060006001600854118015610a44575060095443115b8015610a905750600a54600660003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054105b1515610b2a576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260348152602001807f6f7574206f662073746f636b20696e207468697320726f756e642c20626c6f6381526020017f6b206f7220616c726561647920636c61696d656400000000000000000000000081525060400191505060405180910390fd5b339250600760009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663ba63abd6600a54856040518363ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808381526020018273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200192505050602060405180830381600087803b158015610bf457600080fd5b505af1158015610c08573d6000803e3d6000fd5b505050506040513d6020811015610c1e57600080fd5b81019080805190602001909291905050509150600082111515610ca9576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601d8152602001807f736f7272792c206e6f7420696e766573746564206e6f20626f756e747900000081525060200191505060405180910390fd5b43600981905550600a54600660008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055506001600854036008819055506008543073ffffffffffffffffffffffffffffffffffffffff1631811515610d2657fe5b0490508273ffffffffffffffffffffffffffffffffffffffff166108fc829081150290604051600060405180830381858888f19350505050158015610d6f573d6000803e3d6000fd5b50610d8283600a54600080856004611211565b505050565b60008080549050905090565b60046020528060005260406000206000915090505481565b60095481565b600060046000838152602001908152602001600020549050919050565b6000600160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002082815481101515610e1c57fe5b9060005260206000200154905092915050565b60055481565b600080600080600260085410610e72576001600854033073ffffffffffffffffffffffffffffffffffffffff1631811515610e6c57fe5b04610e75565b60005b905060085481600a5493509350935050909192565b600080600042436000805490500201915073c85ca9fdfcf2193f2f2f34969aba95826bfe126063655b08eb838760018801036040518363ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808381526020018281526020019250505060206040518083038186803b158015610f1357600080fd5b505af4158015610f27573d6000803e3d6000fd5b505050506040513d6020811015610f3d57600080fd5b810190808051906020019092919050505090506001818601039250505092915050565b60085481565b6000600360008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600084815260200190815260200160002054905092915050565b600760009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415156110ac576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260258152602001807f54686973206973206a757374206c6f6720666f72206c6f747465727920636f6e81526020017f747261637400000000000000000000000000000000000000000000000000000081525060400191505060405180910390fd5b600880819055504360098190555080600a8190555050565b6000600160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020805490509050919050565b600760009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415156111fb576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260258152602001807f54686973206973206a757374206c6f6720666f72206c6f747465727920636f6e81526020017f747261637400000000000000000000000000000000000000000000000000000081525060400191505060405180910390fd5b611209868686868686611211565b505050505050565b61121961154b565b86816000019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff1681525050428160200181815250508581604001818152505082816060018181525050600382101561128c576112828585610e8a565b8160800181815250505b818160a00181815250506000819080600181540180825580915050906001820390600052602060002090600602016000909192909190915060008201518160000160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506020820151816001015560408201518160020155606082015181600301556080820151816004015560a08201518160050155505050600160008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600160008054905003908060018154018082558091505090600182039060005260206000200160009091929091909150555082600260008973ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055508260046000888152602001908152602001600020600082825401925050819055508260056000828254019250508190555082600360008973ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600088815260200190815260200160002060008282540192505081905550806000015173ffffffffffffffffffffffffffffffffffffffff167fcb4641b36158555e26a85489ac44d6a79b32be480fc1a47ff5ef627e6d012d5360a060405190810160405280846020015181526020018460400151815260200184606001518152602001846080015181526020018460a001518152506040518082600560200280838360005b83811015611530578082015181840152602081019050611515565b5050505090500191505060405180910390a250505050505050565b60c060405190810160405280600073ffffffffffffffffffffffffffffffffffffffff168152602001600081526020016000815260200160008152602001600081526020016000815250905600a165627a7a72305820140a144f3701eb3b6f26c715797b9bbb32cfcf5f28b9638684fc71a99b82f62e002900000000000000000000000096504e1f83e380984b1d4eccc0e8b9f0559b2ad2",
  "constructorArguments": "00000000000000000000000096504e1f83e380984b1d4eccc0e8b9f0559b2ad2",
  "libraries": [
    {
      "name": "Helper",
      "address": "0xc85ca9fdfcf2193f2f2f34969aba95826bfe1260"
    }
  ]
}