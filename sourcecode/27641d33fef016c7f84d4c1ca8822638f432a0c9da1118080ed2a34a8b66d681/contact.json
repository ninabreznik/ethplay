{
  "address": "0xeab64b2320a1fc1e65f4c7253385ec18e4b4313b",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "AtomicBroker",
  "compilerVersion": "v0.4.25+commit.59dbf8f1",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2019-04-05\n*/\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n\npragma solidity ^0.4.24;\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (_a == 0) {\n      return 0;\n    }\n\n    c = _a * _b;\n    assert(c / _a == _b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = _a / _b;\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n    return _a / _b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    assert(_b <= _a);\n    return _a - _b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    c = _a + _b;\n    assert(c >= _a);\n    return c;\n  }\n}\n\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n\npragma solidity ^0.4.24;\n\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipRenounced(address indexed previousOwner);\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to relinquish control of the contract.\n   * @notice Renouncing to ownership will leave the contract without an owner.\n   * It will not be possible to call the functions with the `onlyOwner`\n   * modifier anymore.\n   */\n  function renounceOwnership() public onlyOwner {\n    emit OwnershipRenounced(owner);\n    owner = address(0);\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address _newOwner) public onlyOwner {\n    _transferOwnership(_newOwner);\n  }\n\n  /**\n   * @dev Transfers control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function _transferOwnership(address _newOwner) internal {\n    require(_newOwner != address(0));\n    emit OwnershipTransferred(owner, _newOwner);\n    owner = _newOwner;\n  }\n}\n\n// File: openzeppelin-solidity/contracts/ownership/Claimable.sol\n\npragma solidity ^0.4.24;\n\n\n\n/**\n * @title Claimable\n * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\n * This allows the new owner to accept the transfer.\n */\ncontract Claimable is Ownable {\n  address public pendingOwner;\n\n  /**\n   * @dev Modifier throws if called by any account other than the pendingOwner.\n   */\n  modifier onlyPendingOwner() {\n    require(msg.sender == pendingOwner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to set the pendingOwner address.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    pendingOwner = newOwner;\n  }\n\n  /**\n   * @dev Allows the pendingOwner address to finalize the transfer.\n   */\n  function claimOwnership() public onlyPendingOwner {\n    emit OwnershipTransferred(owner, pendingOwner);\n    owner = pendingOwner;\n    pendingOwner = address(0);\n  }\n}\n\n// File: contracts/Broker.sol\n\npragma solidity 0.4.25;\n\n\n\n/// @title The Broker + Vault contract for Switcheo Exchange\n/// @author Switcheo Network\n/// @notice This contract faciliates Ethereum and ERC-20 trades\n/// between users. Users can trade with each other by making\n/// and taking offers without giving up custody of their tokens.\n/// Users should first deposit tokens, then communicate off-chain\n/// with the exchange coordinator, in order to place orders\n/// (make / take offers). This allows trades to be confirmed\n/// immediately by the coordinator, and settled on-chain through\n/// this contract at a later time.\ncontract Broker is Claimable {\n    using SafeMath for uint256;\n\n    struct Offer {\n        address maker;\n        address offerAsset;\n        address wantAsset;\n        uint64 nonce;\n        uint256 offerAmount;\n        uint256 wantAmount;\n        uint256 availableAmount; // the remaining offer amount\n    }\n\n    struct AnnouncedWithdrawal {\n        uint256 amount;\n        uint256 canWithdrawAt;\n    }\n\n    // Exchange states\n    enum State { Active, Inactive }\n    State public state;\n\n    // The maximum announce delay in seconds\n    // (7 days * 24 hours * 60 mins * 60 seconds)\n    uint32 constant maxAnnounceDelay = 604800;\n    // Ether token \"address\" is set as the constant 0x00\n    address constant etherAddr = address(0);\n\n    // deposits\n    uint8 constant ReasonDeposit = 0x01;\n    // making an offer\n    uint8 constant ReasonMakerGive = 0x02;\n    uint8 constant ReasonMakerFeeGive = 0x10;\n    uint8 constant ReasonMakerFeeReceive = 0x11;\n    // filling an offer\n    uint8 constant ReasonFillerGive = 0x03;\n    uint8 constant ReasonFillerFeeGive = 0x04;\n    uint8 constant ReasonFillerReceive = 0x05;\n    uint8 constant ReasonMakerReceive = 0x06;\n    uint8 constant ReasonFillerFeeReceive = 0x07;\n    // cancelling an offer\n    uint8 constant ReasonCancel = 0x08;\n    uint8 constant ReasonCancelFeeGive = 0x12;\n    uint8 constant ReasonCancelFeeReceive = 0x13;\n    // withdrawals\n    uint8 constant ReasonWithdraw = 0x09;\n    uint8 constant ReasonWithdrawFeeGive = 0x14;\n    uint8 constant ReasonWithdrawFeeReceive = 0x15;\n\n    // The coordinator sends trades (balance transitions) to the exchange\n    address public coordinator;\n    // The operator receives fees\n    address public operator;\n    // The time required to wait after a cancellation is announced\n    // to let the operator detect it in non-byzantine conditions\n    uint32 public cancelAnnounceDelay;\n    // The time required to wait after a withdrawal is announced\n    // to let the operator detect it in non-byzantine conditions\n    uint32 public withdrawAnnounceDelay;\n\n    // User balances by: userAddress => assetHash => balance\n    mapping(address => mapping(address => uint256)) public balances;\n    // Offers by the creation transaction hash: transactionHash => offer\n    mapping(bytes32 => Offer) public offers;\n    // A record of which hashes have been used before\n    mapping(bytes32 => bool) public usedHashes;\n    // Set of whitelisted spender addresses allowed by the owner\n    mapping(address => bool) public whitelistedSpenders;\n    // Spenders which have been approved by individual user as: userAddress => spenderAddress => true\n    mapping(address => mapping(address => bool)) public approvedSpenders;\n    // Announced withdrawals by: userAddress => assetHash => data\n    mapping(address => mapping(address => AnnouncedWithdrawal)) public announcedWithdrawals;\n    // Announced cancellations by: offerHash => data\n    mapping(bytes32 => uint256) public announcedCancellations;\n\n    // Emitted when new offers made\n    event Make(address indexed maker, bytes32 indexed offerHash);\n    // Emitted when offers are filled\n    event Fill(address indexed filler, bytes32 indexed offerHash, uint256 amountFilled, uint256 amountTaken, address indexed maker);\n    // Emitted when offers are cancelled\n    event Cancel(address indexed maker, bytes32 indexed offerHash);\n    // Emitted on any balance state transition (+ve)\n    event BalanceIncrease(address indexed user, address indexed token, uint256 amount, uint8 indexed reason);\n    // Emitted on any balance state transition (-ve)\n    event BalanceDecrease(address indexed user, address indexed token, uint256 amount, uint8 indexed reason);\n    // Emitted when a withdrawal is annnounced\n    event WithdrawAnnounce(address indexed user, address indexed token, uint256 amount, uint256 canWithdrawAt);\n    // Emitted when a cancellation is annnounced\n    event CancelAnnounce(address indexed user, bytes32 indexed offerHash, uint256 canCancelAt);\n    // Emitted when a user approved a spender\n    event SpenderApprove(address indexed user, address indexed spender);\n    // Emitted when a user rescinds approval for a spender\n    event SpenderRescind(address indexed user, address indexed spender);\n\n    /// @notice Initializes the Broker contract\n    /// @dev The coordinator and operator is initialized\n    /// to be the address of the sender. The Broker is immediately\n    /// put into an active state, with maximum exit delays set.\n    constructor()\n        public\n    {\n        coordinator = msg.sender;\n        operator = msg.sender;\n        cancelAnnounceDelay = maxAnnounceDelay;\n        withdrawAnnounceDelay = maxAnnounceDelay;\n        state = State.Active;\n    }\n\n    modifier onlyCoordinator() {\n        require(\n            msg.sender == coordinator,\n            \"Invalid sender\"\n        );\n        _;\n    }\n\n    modifier onlyActiveState() {\n        require(\n            state == State.Active,\n            \"Invalid state\"\n        );\n        _;\n    }\n\n    modifier onlyInactiveState() {\n        require(\n            state == State.Inactive,\n            \"Invalid state\"\n        );\n        _;\n    }\n\n    modifier notMoreThanMaxDelay(uint32 _delay) {\n        require(\n            _delay <= maxAnnounceDelay,\n            \"Invalid delay\"\n        );\n        _;\n    }\n\n    modifier unusedReasonCode(uint8 _reasonCode) {\n        require(\n            _reasonCode > ReasonWithdrawFeeReceive,\n            \"Invalid reason code\"\n        );\n        _;\n    }\n\n    /// @notice Sets the Broker contract state\n    /// @dev There are only two states - Active & Inactive.\n    ///\n    /// The Active state is the normal operating state for the contract -\n    /// deposits, trading and withdrawals can be carried out.\n    ///\n    /// In the Inactive state, the coordinator can invoke additional\n    /// emergency methods such as emergencyCancel and emergencyWithdraw,\n    /// without the cooperation of users. However, deposits and trading\n    /// methods cannot be invoked at that time. This state is meant\n    /// primarily to terminate and upgrade the contract, or to be used\n    /// in the event that the contract is considered no longer viable\n    /// to continue operation, and held tokens should be immediately\n    /// withdrawn to their respective owners.\n    /// @param _state The state to transition the contract into\n    function setState(State _state) external onlyOwner { state = _state; }\n\n    /// @notice Sets the coordinator address.\n    /// @dev All standard operations (except `depositEther`)\n    /// must be invoked by the coordinator.\n    /// @param _coordinator The address to set as the coordinator\n    function setCoordinator(address _coordinator) external onlyOwner {\n        _validateAddress(_coordinator);\n        coordinator = _coordinator;\n    }\n\n    /// @notice Sets the operator address.\n    /// @dev All fees are paid to the operator.\n    /// @param _operator The address to set as the operator\n    function setOperator(address _operator) external onlyOwner {\n        _validateAddress(operator);\n        operator = _operator;\n    }\n\n    /// @notice Sets the delay between when a cancel\n    /// intention must be announced, and when the cancellation\n    /// can actually be executed on-chain\n    /// @dev This delay exists so that the coordinator has time to\n    /// respond when a user is attempting to bypass it and cancel\n    /// offers directly on-chain.\n    /// Note that this is an direct on-chain cancellation\n    /// is an atypical operation - see `slowCancel`\n    /// for more details.\n    /// @param _delay The delay in seconds\n    function setCancelAnnounceDelay(uint32 _delay)\n        external\n        onlyOwner\n        notMoreThanMaxDelay(_delay)\n    {\n        cancelAnnounceDelay = _delay;\n    }\n\n    /// @notice Sets the delay (in seconds) between when a withdrawal\n    /// intention must be announced, and when the withdrawal\n    /// can actually be executed on-chain.\n    /// @dev This delay exists so that the coordinator has time to\n    /// respond when a user is attempting to bypass it and cancel\n    /// offers directly on-chain. See `announceWithdraw` and\n    /// `slowWithdraw` for more details.\n    /// @param _delay The delay in seconds\n    function setWithdrawAnnounceDelay(uint32 _delay)\n        external\n        onlyOwner\n        notMoreThanMaxDelay(_delay)\n    {\n        withdrawAnnounceDelay = _delay;\n    }\n\n    /// @notice Adds an address to the set of allowed spenders.\n    /// @dev Spenders are meant to be additional EVM contracts that\n    /// will allow adding or upgrading of trading functionality, without\n    /// having to cancel all offers and withdraw all tokens for all users.\n    /// This whitelist ensures that all approved spenders are contracts\n    /// that have been verified by the owner. Note that each user also\n    /// has to invoke `approveSpender` to actually allow the `_spender`\n    /// to spend his/her balance, so that they can examine / verify\n    /// the new spender contract first.\n    /// @param _spender The address to add as a whitelisted spender\n    function addSpender(address _spender)\n        external\n        onlyOwner\n    {\n        _validateAddress(_spender);\n        whitelistedSpenders[_spender] = true;\n    }\n\n    /// @notice Removes an address from the set of allowed spenders.\n    /// @dev Note that removing a spender from the whitelist will not\n    /// prevent already approved spenders from spending a user's balance.\n    /// This is to ensure that the spender contracts can be certain that once\n    /// an approval is done, the owner cannot rescient spending priviledges,\n    /// and cause tokens to be withheld or locked in the spender contract.\n    /// Users must instead manually rescind approvals using `rescindApproval`\n    /// after the `_spender` has been removed from the whitelist.\n    /// @param _spender The address to remove as a whitelisted spender\n    function removeSpender(address _spender)\n        external\n        onlyOwner\n    {\n        _validateAddress(_spender);\n        delete whitelistedSpenders[_spender];\n    }\n\n    /// @notice Deposits Ethereum tokens under the `msg.sender`'s balance\n    /// @dev Allows sending ETH to the contract, and increasing\n    /// the user's contract balance by the amount sent in.\n    /// This operation is only usable in an Active state to prevent\n    /// a terminated contract from receiving tokens.\n    function depositEther()\n        external\n        payable\n        onlyActiveState\n    {\n        require(\n            msg.value > 0,\n            'Invalid value'\n        );\n        balances[msg.sender][etherAddr] = balances[msg.sender][etherAddr].add(msg.value);\n        emit BalanceIncrease(msg.sender, etherAddr, msg.value, ReasonDeposit);\n    }\n\n    /// @notice Deposits ERC20 tokens under the `_user`'s balance\n    /// @dev Allows sending ERC20 tokens to the contract, and increasing\n    /// the user's contract balance by the amount sent in. This operation\n    /// can only be used after an ERC20 `approve` operation for a\n    /// sufficient amount has been carried out.\n    ///\n    /// Note that this operation does not require user signatures as\n    /// a valid ERC20 `approve` call is considered as intent to deposit\n    /// the tokens. This is as there is no other ERC20 methods that this\n    /// contract can call.\n    ///\n    /// This operation can only be called by the coordinator,\n    /// and should be autoamtically done so whenever an `approve` event\n    /// from a ERC20 token (that the coordinator deems valid)\n    /// approving this contract to spend tokens on behalf of a user is seen.\n    ///\n    /// This operation is only usable in an Active state to prevent\n    /// a terminated contract from receiving tokens.\n    /// @param _user The address of the user that is depositing tokens\n    /// @param _token The address of the ERC20 token to deposit\n    /// @param _amount The (approved) amount to deposit\n    function depositERC20(\n        address _user,\n        address _token,\n        uint256 _amount\n    )\n        external\n        onlyCoordinator\n        onlyActiveState\n    {\n        require(\n            _amount > 0,\n            'Invalid value'\n        );\n        balances[_user][_token] = balances[_user][_token].add(_amount);\n\n        _validateIsContract(_token);\n        require(\n            _token.call(\n                bytes4(keccak256(\"transferFrom(address,address,uint256)\")),\n                _user,\n                address(this),\n                _amount\n            ),\n            \"transferFrom call failed\"\n        );\n        require(\n            _getSanitizedReturnValue(),\n            \"transferFrom failed.\"\n        );\n\n        emit BalanceIncrease(_user, _token, _amount, ReasonDeposit);\n    }\n\n    /// @notice Withdraws `_amount` worth of `_token`s to the `_withdrawer`\n    /// @dev This is the standard withdraw operation. Tokens can only be\n    /// withdrawn directly to the token balance owner's address.\n    /// Fees can be paid to cover network costs, as the operation must\n    /// be invoked by the coordinator. The hash of all parameters, prefixed\n    /// with the operation name \"withdraw\" must be signed by the withdrawer\n    /// to validate the withdrawal request. A nonce that is issued by the\n    /// coordinator is used to prevent replay attacks.\n    /// See `slowWithdraw` for withdrawing without requiring the coordinator's\n    /// involvement.\n    /// @param _withdrawer The address of the user that is withdrawing tokens\n    /// @param _token The address of the token to withdraw\n    /// @param _amount The number of tokens to withdraw\n    /// @param _feeAsset The address of the token to use for fee payment\n    /// @param _feeAmount The amount of tokens to pay as fees to the operator\n    /// @param _nonce The nonce to prevent replay attacks\n    /// @param _v The `v` component of the `_withdrawer`'s signature\n    /// @param _r The `r` component of the `_withdrawer`'s signature\n    /// @param _s The `s` component of the `_withdrawer`'s signature\n    function withdraw(\n        address _withdrawer,\n        address _token,\n        uint256 _amount,\n        address _feeAsset,\n        uint256 _feeAmount,\n        uint64 _nonce,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    )\n        external\n        onlyCoordinator\n    {\n        bytes32 msgHash = keccak256(abi.encodePacked(\n            \"withdraw\",\n            _withdrawer,\n            _token,\n            _amount,\n            _feeAsset,\n            _feeAmount,\n            _nonce\n        ));\n\n        require(\n            _recoverAddress(msgHash, _v, _r, _s) == _withdrawer,\n            \"Invalid signature\"\n        );\n\n        _validateAndAddHash(msgHash);\n\n        _withdraw(_withdrawer, _token, _amount, _feeAsset, _feeAmount);\n    }\n\n    /// @notice Announces intent to withdraw tokens using `slowWithdraw`\n    /// @dev Allows a user to invoke `slowWithdraw` after a minimum of\n    /// `withdrawAnnounceDelay` seconds has passed.\n    /// This announcement and delay is necessary so that the operator has time\n    /// to respond if a user attempts to invoke a `slowWithdraw` even though\n    /// the exchange is operating normally. In that case, the coordinator would respond\n    /// by not allowing the announced amount of tokens to be used in future trades\n    /// the moment a `WithdrawAnnounce` is seen.\n    /// @param _token The address of the token to withdraw after the required exit delay\n    /// @param _amount The number of tokens to withdraw after the required exit delay\n    function announceWithdraw(\n        address _token,\n        uint256 _amount\n    )\n        external\n    {\n        require(\n            _amount <= balances[msg.sender][_token],\n            \"Amount too high\"\n        );\n\n        AnnouncedWithdrawal storage announcement = announcedWithdrawals[msg.sender][_token];\n        uint256 canWithdrawAt = now + withdrawAnnounceDelay;\n\n        announcement.canWithdrawAt = canWithdrawAt;\n        announcement.amount = _amount;\n\n        emit WithdrawAnnounce(msg.sender, _token, _amount, canWithdrawAt);\n    }\n\n    /// @notice Withdraw tokens without requiring the coordinator\n    /// @dev This operation is meant to be used if the operator becomes \"byzantine\",\n    /// so that users can still exit tokens locked in this contract.\n    /// The `announceWithdraw` operation has to be invoked first, and a minimum time of\n    /// `withdrawAnnounceDelay` seconds have to pass, before this operation can be carried out.\n    /// Note that this direct on-chain withdrawal is an atypical operation, and\n    /// the normal `withdraw` operation should be used in non-byzantine states.\n    /// @param _withdrawer The address of the user that is withdrawing tokens\n    /// @param _token The address of the token to withdraw\n    /// @param _amount The number of tokens to withdraw\n    function slowWithdraw(\n        address _withdrawer,\n        address _token,\n        uint256 _amount\n    )\n        external\n    {\n        AnnouncedWithdrawal memory announcement = announcedWithdrawals[_withdrawer][_token];\n\n        require(\n            announcement.canWithdrawAt != 0 && announcement.canWithdrawAt <= now,\n            \"Insufficient delay\"\n        );\n\n        require(\n            announcement.amount == _amount,\n            \"Invalid amount\"\n        );\n\n        delete announcedWithdrawals[_withdrawer][_token];\n\n        _withdraw(_withdrawer, _token, _amount, etherAddr, 0);\n    }\n\n    /// @notice Withdraws tokens to the owner without requiring the owner's signature\n    /// @dev Can only be invoked in an Inactive state by the coordinator.\n    /// This operation is meant to be used in emergencies only.\n    /// @param _withdrawer The address of the user that should have tokens withdrawn\n    /// @param _token The address of the token to withdraw\n    /// @param _amount The number of tokens to withdraw\n    function emergencyWithdraw(\n        address _withdrawer,\n        address _token,\n        uint256 _amount\n    )\n        external\n        onlyCoordinator\n        onlyInactiveState\n    {\n        _withdraw(_withdrawer, _token, _amount, etherAddr, 0);\n    }\n\n    /// @notice Makes an offer which can be filled by other users.\n    /// @dev Makes an offer for `_offerAmount` of `offerAsset` tokens\n    /// for `wantAmount` of `wantAsset` tokens, that can be filled later\n    /// by one or more counterparties using `fillOffer` or `fillOffers`.\n    /// The offer can be later cancelled using `cancel` or `slowCancel` as long\n    /// as it has not completely been filled.\n    /// A fee of `_feeAmount` of `_feeAsset` tokens can be paid to the operator\n    /// to cover orderbook maintenance and network costs.\n    /// The hash of all parameters, prefixed with the operation name \"makeOffer\"\n    /// must be signed by the `_maker` to validate the offer request.\n    /// A nonce that is issued by the coordinator is used to prevent replay attacks.\n    /// This operation can only be invoked by the coordinator in an Active state.\n    /// @param _maker The address of the user that is making the offer\n    /// @param _offerAsset The address of the token being offered\n    /// @param _wantAsset The address of the token asked in return\n    /// @param _offerAmount The number of tokens being offered\n    /// @param _wantAmount The number of tokens asked for in return\n    /// @param _feeAsset The address of the token to use for fee payment\n    /// @param _feeAmount The amount of tokens to pay as fees to the operator\n    /// @param _nonce The nonce to prevent replay attacks\n    /// @param _v The `v` component of the `_maker`'s signature\n    /// @param _r The `r` component of the `_maker`'s signature\n    /// @param _s The `s` component of the `_maker`'s signature\n    function makeOffer(\n        address _maker,\n        address _offerAsset,\n        address _wantAsset,\n        uint256 _offerAmount,\n        uint256 _wantAmount,\n        address _feeAsset,\n        uint256 _feeAmount,\n        uint64 _nonce,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    )\n        external\n        onlyCoordinator\n        onlyActiveState\n    {\n        require(\n            _offerAmount > 0 && _wantAmount > 0,\n            \"Invalid amounts\"\n        );\n\n        require(\n            _offerAsset != _wantAsset,\n            \"Invalid assets\"\n        );\n\n        bytes32 offerHash = keccak256(abi.encodePacked(\n            \"makeOffer\",\n            _maker,\n            _offerAsset,\n            _wantAsset,\n            _offerAmount,\n            _wantAmount,\n            _feeAsset,\n            _feeAmount,\n            _nonce\n        ));\n\n        require(\n            _recoverAddress(offerHash, _v, _r, _s) == _maker,\n            \"Invalid signature\"\n        );\n\n        _validateAndAddHash(offerHash);\n\n        // Reduce maker's balance\n        _decreaseBalanceAndPayFees(\n            _maker,\n            _offerAsset,\n            _offerAmount,\n            _feeAsset,\n            _feeAmount,\n            ReasonMakerGive,\n            ReasonMakerFeeGive,\n            ReasonMakerFeeReceive\n        );\n\n        // Store the offer\n        Offer storage offer = offers[offerHash];\n        offer.maker = _maker;\n        offer.offerAsset = _offerAsset;\n        offer.wantAsset = _wantAsset;\n        offer.offerAmount = _offerAmount;\n        offer.wantAmount = _wantAmount;\n        offer.availableAmount = _offerAmount;\n        offer.nonce = _nonce;\n\n        emit Make(_maker, offerHash);\n    }\n\n    /// @notice Fills a offer that has been previously made using `makeOffer`.\n    /// @dev Fill an offer with `_offerHash` by giving `_amountToTake` of\n    /// the offers' `wantAsset` tokens.\n    /// A fee of `_feeAmount` of `_feeAsset` tokens can be paid to the operator\n    /// to cover orderbook maintenance and network costs.\n    /// The hash of all parameters, prefixed with the operation name \"fillOffer\"\n    /// must be signed by the `_filler` to validate the fill request.\n    /// A nonce that is issued by the coordinator is used to prevent replay attacks.\n    /// This operation can only be invoked by the coordinator in an Active state.\n    /// @param _filler The address of the user that is filling the offer\n    /// @param _offerHash The hash of the offer to fill\n    /// @param _amountToTake The number of tokens to take from the offer\n    /// @param _feeAsset The address of the token to use for fee payment\n    /// @param _feeAmount The amount of tokens to pay as fees to the operator\n    /// @param _nonce The nonce to prevent replay attacks\n    /// @param _v The `v` component of the `_filler`'s signature\n    /// @param _r The `r` component of the `_filler`'s signature\n    /// @param _s The `s` component of the `_filler`'s signature\n    function fillOffer(\n        address _filler,\n        bytes32 _offerHash,\n        uint256 _amountToTake,\n        address _feeAsset,\n        uint256 _feeAmount,\n        uint64 _nonce,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    )\n        external\n        onlyCoordinator\n        onlyActiveState\n    {\n        bytes32 msgHash = keccak256(\n            abi.encodePacked(\n                \"fillOffer\",\n                _filler,\n                _offerHash,\n                _amountToTake,\n                _feeAsset,\n                _feeAmount,\n                _nonce\n            )\n        );\n\n        require(\n            _recoverAddress(msgHash, _v, _r, _s) == _filler,\n            \"Invalid signature\"\n        );\n\n        _validateAndAddHash(msgHash);\n\n        _fill(_filler, _offerHash, _amountToTake, _feeAsset, _feeAmount);\n    }\n\n    /// @notice Fills multiple offers that have been previously made using `makeOffer`.\n    /// @dev Fills multiple offers with hashes in `_offerHashes` for amounts in\n    /// `_amountsToTake`. This method allows conserving of the base gas cost.\n    /// A fee of `_feeAmount` of `_feeAsset`  tokens can be paid to the operator\n    /// to cover orderbook maintenance and network costs.\n    /// The hash of all parameters, prefixed with the operation name \"fillOffers\"\n    /// must be signed by the maker to validate the fill request.\n    /// A nonce that is issued by the coordinator is used to prevent replay attacks.\n    /// This operation can only be invoked by the coordinator in an Active state.\n    /// @param _filler The address of the user that is filling the offer\n    /// @param _offerHashes The hashes of the offers to fill\n    /// @param _amountsToTake The number of tokens to take for each offer\n    /// (each index corresponds to the entry with the same index in _offerHashes)\n    /// @param _feeAsset The address of the token to use for fee payment\n    /// @param _feeAmount The amount of tokens to pay as fees to the operator\n    /// @param _nonce The nonce to prevent replay attacks\n    /// @param _v The `v` component of the `_filler`'s signature\n    /// @param _r The `r` component of the `_filler`'s signature\n    /// @param _s The `s` component of the `_filler`'s signature\n    function fillOffers(\n        address _filler,\n        bytes32[] _offerHashes,\n        uint256[] _amountsToTake,\n        address _feeAsset,\n        uint256 _feeAmount,\n        uint64 _nonce,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    )\n        external\n        onlyCoordinator\n        onlyActiveState\n    {\n        require(\n            _offerHashes.length > 0,\n            'Invalid input'\n        );\n        require(\n            _offerHashes.length == _amountsToTake.length,\n            'Invalid inputs'\n        );\n\n        bytes32 msgHash = keccak256(\n            abi.encodePacked(\n                \"fillOffers\",\n                _filler,\n                _offerHashes,\n                _amountsToTake,\n                _feeAsset,\n                _feeAmount,\n                _nonce\n            )\n        );\n\n        require(\n            _recoverAddress(msgHash, _v, _r, _s) == _filler,\n            \"Invalid signature\"\n        );\n\n        _validateAndAddHash(msgHash);\n\n        for (uint32 i = 0; i < _offerHashes.length; i++) {\n            _fill(_filler, _offerHashes[i], _amountsToTake[i], etherAddr, 0);\n        }\n\n        _paySeparateFees(\n            _filler,\n            _feeAsset,\n            _feeAmount,\n            ReasonFillerFeeGive,\n            ReasonFillerFeeReceive\n        );\n    }\n\n    /// @notice Cancels an offer that was preivously made using `makeOffer`.\n    /// @dev Cancels the offer with `_offerHash`. An `_expectedAvailableAmount`\n    /// is provided to allow the coordinator to ensure that the offer is not accidentally\n    /// cancelled ahead of time (where there is a pending fill that has not been settled).\n    /// The hash of the _offerHash, _feeAsset, `_feeAmount` prefixed with the\n    /// operation name \"cancel\" must be signed by the offer maker to validate\n    /// the cancellation request. Only the coordinator can invoke this operation.\n    /// See `slowCancel` for cancellation without requiring the coordinator's\n    /// involvement.\n    /// @param _offerHash The hash of the offer to cancel\n    /// @param _expectedAvailableAmount The number of tokens that should be present when cancelling\n    /// @param _feeAsset The address of the token to use for fee payment\n    /// @param _feeAmount The amount of tokens to pay as fees to the operator\n    /// @param _v The `v` component of the offer maker's signature\n    /// @param _r The `r` component of the offer maker's signature\n    /// @param _s The `s` component of the offer maker's signature\n    function cancel(\n        bytes32 _offerHash,\n        uint256 _expectedAvailableAmount,\n        address _feeAsset,\n        uint256 _feeAmount,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    )\n        external\n        onlyCoordinator\n    {\n        require(\n            _recoverAddress(keccak256(abi.encodePacked(\n                \"cancel\",\n                _offerHash,\n                _feeAsset,\n                _feeAmount\n            )), _v, _r, _s) == offers[_offerHash].maker,\n            \"Invalid signature\"\n        );\n\n        _cancel(_offerHash, _expectedAvailableAmount, _feeAsset, _feeAmount);\n    }\n\n    /// @notice Announces intent to cancel tokens using `slowCancel`\n    /// @dev Allows a user to invoke `slowCancel` after a minimum of\n    /// `cancelAnnounceDelay` seconds has passed.\n    /// This announcement and delay is necessary so that the operator has time\n    /// to respond if a user attempts to invoke a `slowCancel` even though\n    /// the exchange is operating normally.\n    /// In that case, the coordinator would simply stop matching the offer to\n    /// viable counterparties the moment the `CancelAnnounce` is seen.\n    /// @param _offerHash The hash of the offer that will be cancelled\n    function announceCancel(bytes32 _offerHash)\n        external\n    {\n        Offer memory offer = offers[_offerHash];\n\n        require(\n            offer.maker == msg.sender,\n            \"Invalid sender\"\n        );\n\n        require(\n            offer.availableAmount > 0,\n            \"Offer already cancelled\"\n        );\n\n        uint256 canCancelAt = now + cancelAnnounceDelay;\n        announcedCancellations[_offerHash] = canCancelAt;\n\n        emit CancelAnnounce(offer.maker, _offerHash, canCancelAt);\n    }\n\n    /// @notice Cancel an offer without requiring the coordinator\n    /// @dev This operation is meant to be used if the operator becomes \"byzantine\",\n    /// so that users can still cancel offers in this contract, and withdraw tokens\n    /// using `slowWithdraw`.\n    /// The `announceCancel` operation has to be invoked first, and a minimum time of\n    /// `cancelAnnounceDelay` seconds have to pass, before this operation can be carried out.\n    /// Note that this direct on-chain cancellation is an atypical operation, and\n    /// the normal `cancel` operation should be used in non-byzantine states.\n    /// @param _offerHash The hash of the offer to cancel\n    function slowCancel(bytes32 _offerHash)\n        external\n    {\n        require(\n            announcedCancellations[_offerHash] != 0 && announcedCancellations[_offerHash] <= now,\n            \"Insufficient delay\"\n        );\n\n        delete announcedCancellations[_offerHash];\n\n        Offer memory offer = offers[_offerHash];\n        _cancel(_offerHash, offer.availableAmount, etherAddr, 0);\n    }\n\n    /// @notice Cancels an offer immediately once cancellation intent\n    /// has been announced.\n    /// @dev Can only be invoked by the coordinator. This allows\n    /// the coordinator to quickly remove offers that it has already\n    /// acknowledged, and move its offer book into a consistent state.\n    function fastCancel(bytes32 _offerHash, uint256 _expectedAvailableAmount)\n        external\n        onlyCoordinator\n    {\n        require(\n            announcedCancellations[_offerHash] != 0,\n            \"Missing annoncement\"\n        );\n\n        delete announcedCancellations[_offerHash];\n\n        _cancel(_offerHash, _expectedAvailableAmount, etherAddr, 0);\n    }\n\n    /// @notice Cancels an offer without requiring the owner's signature,\n    /// so that the tokens can be withdrawn using `emergencyWithdraw`.\n    /// @dev Can only be invoked in an Inactive state by the coordinator.\n    /// This operation is meant to be used in emergencies only.\n    function emergencyCancel(bytes32 _offerHash, uint256 _expectedAvailableAmount)\n        external\n        onlyCoordinator\n        onlyInactiveState\n    {\n        _cancel(_offerHash, _expectedAvailableAmount, etherAddr, 0);\n    }\n\n    /// @notice Approve an address for spending any amount of\n    /// any token from the `msg.sender`'s balances\n    /// @dev Analogous to ERC-20 `approve`, with the following differences:\n    ///     - `_spender` must be whitelisted by owner\n    ///     - approval can be rescinded at a later time by the user\n    ///       iff it has been removed from the whitelist\n    ///     - spending amount is unlimited\n    /// @param _spender The address to approve spending\n    function approveSpender(address _spender)\n        external\n    {\n        require(\n            whitelistedSpenders[_spender],\n            \"Spender is not whitelisted\"\n        );\n\n        approvedSpenders[msg.sender][_spender] = true;\n        emit SpenderApprove(msg.sender, _spender);\n    }\n\n    /// @notice Rescinds a previous approval for spending the `msg.sender`'s contract balance.\n    /// @dev Rescinds approval for a spender, after it has been removed from\n    /// the `whitelistedSpenders` set. This allows an approval to be removed\n    /// if both the owner and user agrees that the previously approved spender\n    /// contract should no longer be used.\n    /// @param _spender The address to rescind spending approval\n    function rescindApproval(address _spender)\n        external\n    {\n        require(\n            approvedSpenders[msg.sender][_spender],\n            \"Spender has not been approved\"\n        );\n\n        require(\n            whitelistedSpenders[_spender] != true,\n            \"Spender must be removed from the whitelist\"\n        );\n\n        delete approvedSpenders[msg.sender][_spender];\n        emit SpenderRescind(msg.sender, _spender);\n    }\n\n    /// @notice Transfers tokens from one address to another\n    /// @dev Analogous to ERC-20 `transferFrom`, with the following differences:\n    ///     - the address of the token to transfer must be specified\n    ///     - any amount of token can be transferred, as long as it is less or equal\n    ///       to `_from`'s balance\n    ///     - reason codes can be attached and they must not use reasons specified in\n    ///       this contract\n    /// @param _from The address to transfer tokens from\n    /// @param _to The address to transfer tokens to\n    /// @param _amount The number of tokens to transfer\n    /// @param _token The address of the token to transfer\n    /// @param _decreaseReason A reason code to emit in the `BalanceDecrease` event\n    /// @param _increaseReason A reason code to emit in the `BalanceIncrease` event\n    function spendFrom(\n        address _from,\n        address _to,\n        uint256 _amount,\n        address _token,\n        uint8 _decreaseReason,\n        uint8 _increaseReason\n    )\n        external\n        unusedReasonCode(_decreaseReason)\n        unusedReasonCode(_increaseReason)\n    {\n        require(\n            approvedSpenders[_from][msg.sender],\n            \"Spender has not been approved\"\n        );\n\n        _validateAddress(_to);\n\n        balances[_from][_token] = balances[_from][_token].sub(_amount);\n        emit BalanceDecrease(_from, _token, _amount, _decreaseReason);\n\n        balances[_to][_token] = balances[_to][_token].add(_amount);\n        emit BalanceIncrease(_to, _token, _amount, _increaseReason);\n    }\n\n    /// @dev Overrides ability to renounce ownership as this contract is\n    /// meant to always have an owner.\n    function renounceOwnership() public { require(false, \"Cannot have no owner\"); }\n\n    /// @dev The actual withdraw logic that is used internally by multiple operations.\n    function _withdraw(\n        address _withdrawer,\n        address _token,\n        uint256 _amount,\n        address _feeAsset,\n        uint256 _feeAmount\n    )\n        private\n    {\n        // SafeMath.sub checks that balance is sufficient already\n        _decreaseBalanceAndPayFees(\n            _withdrawer,\n            _token,\n            _amount,\n            _feeAsset,\n            _feeAmount,\n            ReasonWithdraw,\n            ReasonWithdrawFeeGive,\n            ReasonWithdrawFeeReceive\n        );\n\n        if (_token == etherAddr) // ether\n        {\n            _withdrawer.transfer(_amount);\n        }\n        else\n        {\n            _validateIsContract(_token);\n            require(\n                _token.call(\n                    bytes4(keccak256(\"transfer(address,uint256)\")), _withdrawer, _amount\n                ),\n                \"transfer call failed\"\n            );\n            require(\n                _getSanitizedReturnValue(),\n                \"transfer failed\"\n            );\n        }\n    }\n\n    /// @dev The actual fill logic that is used internally by multiple operations.\n    function _fill(\n        address _filler,\n        bytes32 _offerHash,\n        uint256 _amountToTake,\n        address _feeAsset,\n        uint256 _feeAmount\n    )\n        private\n    {\n        require(\n            _amountToTake > 0,\n            \"Invalid input\"\n        );\n\n        Offer storage offer = offers[_offerHash];\n        require(\n            offer.maker != _filler,\n            \"Invalid filler\"\n        );\n\n        require(\n            offer.availableAmount != 0,\n            \"Offer already filled\"\n        );\n\n        uint256 amountToFill = (_amountToTake.mul(offer.wantAmount)).div(offer.offerAmount);\n\n        // transfer amountToFill in fillAsset from filler to maker\n        balances[_filler][offer.wantAsset] = balances[_filler][offer.wantAsset].sub(amountToFill);\n        emit BalanceDecrease(_filler, offer.wantAsset, amountToFill, ReasonFillerGive);\n\n        balances[offer.maker][offer.wantAsset] = balances[offer.maker][offer.wantAsset].add(amountToFill);\n        emit BalanceIncrease(offer.maker, offer.wantAsset, amountToFill, ReasonMakerReceive);\n\n        // deduct amountToTake in takeAsset from offer\n        offer.availableAmount = offer.availableAmount.sub(_amountToTake);\n        _increaseBalanceAndPayFees(\n            _filler,\n            offer.offerAsset,\n            _amountToTake,\n            _feeAsset,\n            _feeAmount,\n            ReasonFillerReceive,\n            ReasonFillerFeeGive,\n            ReasonFillerFeeReceive\n        );\n        emit Fill(_filler, _offerHash, amountToFill, _amountToTake, offer.maker);\n\n        if (offer.availableAmount == 0)\n        {\n            delete offers[_offerHash];\n        }\n    }\n\n    /// @dev The actual cancellation logic that is used internally by multiple operations.\n    function _cancel(\n        bytes32 _offerHash,\n        uint256 _expectedAvailableAmount,\n        address _feeAsset,\n        uint256 _feeAmount\n    )\n        private\n    {\n        Offer memory offer = offers[_offerHash];\n\n        require(\n            offer.availableAmount > 0,\n            \"Offer already cancelled\"\n        );\n\n        require(\n            offer.availableAmount == _expectedAvailableAmount,\n            \"Invalid input\"\n        );\n\n        delete offers[_offerHash];\n\n        _increaseBalanceAndPayFees(\n            offer.maker,\n            offer.offerAsset,\n            offer.availableAmount,\n            _feeAsset,\n            _feeAmount,\n            ReasonCancel,\n            ReasonCancelFeeGive,\n            ReasonCancelFeeReceive\n        );\n\n        emit Cancel(offer.maker, _offerHash);\n    }\n\n    /// @dev Performs an `ecrecover` operation for signed message hashes\n    /// in accordance to EIP-191.\n    function _recoverAddress(bytes32 _hash, uint8 _v, bytes32 _r, bytes32 _s)\n        private\n        pure\n        returns (address)\n    {\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n        bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, _hash));\n        return ecrecover(prefixedHash, _v, _r, _s);\n    }\n\n    /// @dev Decreases a user's balance while adding a cut from the decrement\n    /// to be paid as fees to the operator. Reason codes should be provided\n    /// to be emitted with events for tracking.\n    function _decreaseBalanceAndPayFees(\n        address _user,\n        address _token,\n        uint256 _amount,\n        address _feeAsset,\n        uint256 _feeAmount,\n        uint8 _reason,\n        uint8 _feeGiveReason,\n        uint8 _feeReceiveReason\n    )\n        private\n    {\n        uint256 totalAmount = _amount;\n\n        if (_feeAsset == _token) {\n            totalAmount = _amount.add(_feeAmount);\n        }\n\n        balances[_user][_token] = balances[_user][_token].sub(totalAmount);\n        emit BalanceDecrease(_user, _token, totalAmount, _reason);\n\n        _payFees(_user, _token, _feeAsset, _feeAmount, _feeGiveReason, _feeReceiveReason);\n    }\n\n    /// @dev Increases a user's balance while deducting a cut from the increment\n    /// to be paid as fees to the operator. Reason codes should be provided\n    /// to be emitted with events for tracking.\n    function _increaseBalanceAndPayFees(\n        address _user,\n        address _token,\n        uint256 _amount,\n        address _feeAsset,\n        uint256 _feeAmount,\n        uint8 _reason,\n        uint8 _feeGiveReason,\n        uint8 _feeReceiveReason\n    )\n        private\n    {\n        uint256 totalAmount = _amount;\n\n        if (_feeAsset == _token) {\n            totalAmount = _amount.sub(_feeAmount);\n        }\n\n        balances[_user][_token] = balances[_user][_token].add(totalAmount);\n        emit BalanceIncrease(_user, _token, totalAmount, _reason);\n\n        _payFees(_user, _token, _feeAsset, _feeAmount, _feeGiveReason, _feeReceiveReason);\n    }\n\n    /// @dev Pays fees to the operator, attaching the specified reason codes\n    /// to the emitted event, only deducting from the `_user` balance if the\n    /// `_token` does not match `_feeAsset`.\n    /// IMPORTANT: In the event that the `_token` matches `_feeAsset`,\n    /// there should a reduction in balance increment carried out separately,\n    /// to ensure balance consistency.\n    function _payFees(\n        address _user,\n        address _token,\n        address _feeAsset,\n        uint256 _feeAmount,\n        uint8 _feeGiveReason,\n        uint8 _feeReceiveReason\n    )\n        private\n    {\n        if (_feeAmount == 0) {\n            return;\n        }\n\n        // if the feeAsset does not match the token then the feeAmount needs to be separately deducted\n        if (_feeAsset != _token) {\n            balances[_user][_feeAsset] = balances[_user][_feeAsset].sub(_feeAmount);\n            emit BalanceDecrease(_user, _feeAsset, _feeAmount, _feeGiveReason);\n        }\n\n        balances[operator][_feeAsset] = balances[operator][_feeAsset].add(_feeAmount);\n        emit BalanceIncrease(operator, _feeAsset, _feeAmount, _feeReceiveReason);\n    }\n\n    /// @dev Pays fees to the operator, attaching the specified reason codes to the emitted event.\n    function _paySeparateFees(\n        address _user,\n        address _feeAsset,\n        uint256 _feeAmount,\n        uint8 _feeGiveReason,\n        uint8 _feeReceiveReason\n    )\n        private\n    {\n        if (_feeAmount == 0) {\n            return;\n        }\n\n        balances[_user][_feeAsset] = balances[_user][_feeAsset].sub(_feeAmount);\n        emit BalanceDecrease(_user, _feeAsset, _feeAmount, _feeGiveReason);\n\n        balances[operator][_feeAsset] = balances[operator][_feeAsset].add(_feeAmount);\n        emit BalanceIncrease(operator, _feeAsset, _feeAmount, _feeReceiveReason);\n    }\n\n    /// @dev Ensures that the address is a valid user address.\n    function _validateAddress(address _address)\n        private\n        pure\n    {\n        require(\n            _address != address(0),\n            'Invalid address'\n        );\n    }\n\n    /// @dev Ensures a hash hasn't been already used, which would mean\n    /// a repeated set of arguments and nonce was used. This prevents\n    /// replay attacks.\n    function _validateAndAddHash(bytes32 _hash)\n        private\n    {\n        require(\n            usedHashes[_hash] != true,\n            \"hash already used\"\n        );\n\n        usedHashes[_hash] = true;\n    }\n\n    /// @dev Ensure that the address is a deployed contract\n    function _validateIsContract(address addr) private view {\n        assembly {\n            if iszero(extcodesize(addr)) { revert(0, 0) }\n        }\n    }\n\n    /// @dev Fix for ERC-20 tokens that do not have proper return type\n    /// See: https://github.com/ethereum/solidity/issues/4116\n    /// https://medium.com/loopring-protocol/an-incompatibility-in-smart-contract-threatening-dapp-ecosystem-72b8ca5db4da\n    /// https://github.com/sec-bit/badERC20Fix/blob/master/badERC20Fix.sol\n    function _getSanitizedReturnValue()\n        private\n        pure\n        returns (bool)\n    {\n        uint256 result = 0;\n        assembly {\n            switch returndatasize\n            case 0 {    // this is an non-standard ERC-20 token\n                result := 1 // assume success on no revert\n            }\n            case 32 {   // this is a standard ERC-20 token\n                returndatacopy(0, 0, 32)\n                result := mload(0)\n            }\n            default {   // this is not an ERC-20 token\n                revert(0, 0) // revert for safety\n            }\n        }\n        return result != 0;\n    }\n}\n\n// File: contracts/AtomicBroker.sol\n\npragma solidity 0.4.25;\n\n\n\n/// @title The Atomic Swap contract for Switcheo Exchange\n/// @author Switcheo Network\n/// @notice This contract faciliates crosschain trades\n/// between users through a time locked Atomic Swap.\n/// The contract transfers assets by updating the balances\n/// in the Switcheo Broker contract.\ncontract AtomicBroker {\n    using SafeMath for uint256;\n\n    // The Switcheo Broker contract\n    Broker public broker;\n\n    // Creating a swap\n    uint8 constant ReasonSwapMakerGive = 0x30;\n    uint8 constant ReasonSwapHolderReceive = 0x31;\n    uint8 constant ReasonSwapMakerFeeGive = 0x32;\n    uint8 constant ReasonSwapHolderFeeReceive = 0x33;\n\n    // Executing a swap\n    uint8 constant ReasonSwapHolderGive = 0x34;\n    uint8 constant ReasonSwapTakerReceive = 0x35;\n    uint8 constant ReasonSwapFeeGive = 0x36;\n    uint8 constant ReasonSwapFeeReceive = 0x37;\n\n    // Cancelling a swap\n    uint8 constant ReasonSwapCancelMakerReceive = 0x38;\n    uint8 constant ReasonSwapCancelHolderGive = 0x39;\n    uint8 constant ReasonSwapCancelFeeGive = 0x3A;\n    uint8 constant ReasonSwapCancelFeeReceive = 0x3B;\n    uint8 constant ReasonSwapCancelFeeRefundGive = 0x3C;\n    uint8 constant ReasonSwapCancelFeeRefundReceive = 0x3D;\n\n    // Swaps by: swapHash => swapIsActive\n    mapping(bytes32 => bool) public swaps;\n    // A record of which hashes have been used before\n    mapping(bytes32 => bool) public usedHashes;\n\n    // Emitted when a new swap is created\n    event CreateSwap(\n        address indexed maker,\n        address indexed taker,\n        address token,\n        uint256 amount,\n        bytes32 indexed hashedSecret,\n        uint256 expiryTime,\n        address feeAsset,\n        uint256 feeAmount\n    );\n\n    // Emitted when a swap is executed\n    event ExecuteSwap(bytes32 indexed hashedSecret);\n\n    // Emitted when a swap is cancelled\n    event CancelSwap(bytes32 indexed hashedSecret);\n\n    /// @notice Initializes the Atomic Broker contract\n    /// @dev The broker is initialized to the Switcheo Broker\n    constructor(address brokerAddress)\n        public\n    {\n        broker = Broker(brokerAddress);\n    }\n\n    modifier onlyCoordinator() {\n        require(\n            msg.sender == address(broker.coordinator()),\n            \"Invalid sender\"\n        );\n        _;\n    }\n\n    /// @notice Approves the Broker contract to update balances for this contract\n    /// @dev The swap maker's balances are locked by transferring the balance to be\n    /// locked to this contract within the Broker contract.\n    /// To release the locked balances to the swap taker, this contract must approve\n    /// itself as a spender of its own balances within the Broker contract.\n    function approveBroker()\n        external\n    {\n        broker.approveSpender(address(this));\n    }\n\n    /// @notice Creates a swap to initiate the transfer of assets.\n    /// @dev Creates a swap to transfer `_amount` of `_token` to `_taker`\n    /// The transfer is completed when executeSwap is called with the correct\n    /// preimage matching the `_hashedSecret`.\n    /// If executeSwap is not called, the transfer can be cancelled after\n    /// `expiryTime` has passed.\n    /// This operation can only be invoked by the coordinator.\n    /// @param _maker The address of the user making the swap\n    /// @param _taker The address of the user taking the swap\n    /// @param _token The address of the token to be transferred\n    /// @param _amount The number of tokens to be transferred\n    /// @param _hashedSecret The hash of the secret decided on by the maker\n    /// @param _expiryTime The epoch time of when the swap becomes cancellable\n    /// @param _feeAsset The address of the token to use for fee payment\n    /// @param _feeAmount The amount of tokens to pay as fees to the operator\n    /// @param _v The `v` component of the `_maker`'s signature\n    /// @param _r The `r` component of the `_maker`'s signature\n    /// @param _s The `s` component of the `_maker`'s signature\n    function createSwap(\n        address _maker,\n        address _taker,\n        address _token,\n        uint256 _amount,\n        bytes32 _hashedSecret,\n        uint256 _expiryTime,\n        address _feeAsset,\n        uint256 _feeAmount,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    )\n        external\n        onlyCoordinator\n    {\n        require(\n            _amount > 0,\n            \"Invalid amount\"\n        );\n\n        require(\n            _expiryTime > now,\n            \"Invalid expiry time\"\n        );\n\n        _validateAndAddHash(_hashedSecret);\n\n        bytes32 msgHash = _hashSwapParams(\n            _maker,\n            _taker,\n            _token,\n            _amount,\n            _hashedSecret,\n            _expiryTime,\n            _feeAsset,\n            _feeAmount\n        );\n\n        require(\n            _recoverAddress(msgHash, _v, _r, _s) == _maker,\n            \"Invalid signature\"\n        );\n\n        // This is needed because the _feeAmount is deducted from the locked _amount\n        // when the swap is executed\n        if (_feeAsset == _token) {\n            require(\n                _feeAmount < _amount,\n                \"Fee amount exceeds amount\"\n            );\n        }\n\n        // Lock swap amount into this contract\n        broker.spendFrom(\n            _maker,\n            address(this),\n            _amount,\n            _token,\n            ReasonSwapMakerGive,\n            ReasonSwapHolderReceive\n        );\n\n        // Lock fee amount into this contract\n        if (_feeAsset != _token)\n        {\n            broker.spendFrom(\n                _maker,\n                address(this),\n                _feeAmount,\n                _feeAsset,\n                ReasonSwapMakerFeeGive,\n                ReasonSwapHolderFeeReceive\n            );\n        }\n\n        // Mark swap as active\n        swaps[msgHash] = true;\n\n        emit CreateSwap(\n            _maker,\n            _taker,\n            _token,\n            _amount,\n            _hashedSecret,\n            _expiryTime,\n            _feeAsset,\n            _feeAmount\n        );\n    }\n\n    /// @notice Executes a swap that had been previously made using `createSwap`.\n    /// @dev Transfers the previously locked asset from createSwap to the swap taker.\n    /// The original swap parameters need to be resent as only the hash of these\n    /// parameters are stored in `swaps`.\n    /// @param _maker The address of the user making the swap\n    /// @param _taker The address of the user taking the swap\n    /// @param _token The address of the token to be transferred\n    /// @param _amount The number of tokens to be transferred\n    /// @param _hashedSecret The hash of the secret decided on by the maker\n    /// @param _expiryTime The epoch time of when the swap becomes cancellable\n    /// @param _feeAsset The address of the token to use for fee payment\n    /// @param _feeAmount The amount of tokens to pay as fees to the operator\n    /// @param _preimage The preimage matching the _hashedSecret\n    function executeSwap (\n        address _maker,\n        address _taker,\n        address _token,\n        uint256 _amount,\n        bytes32 _hashedSecret,\n        uint256 _expiryTime,\n        address _feeAsset,\n        uint256 _feeAmount,\n        bytes _preimage\n    )\n        external\n    {\n        bytes32 msgHash = _hashSwapParams(\n            _maker,\n            _taker,\n            _token,\n            _amount,\n            _hashedSecret,\n            _expiryTime,\n            _feeAsset,\n            _feeAmount\n        );\n\n        require(\n            swaps[msgHash] == true,\n            \"Swap is inactive\"\n        );\n\n        require(\n            sha256(abi.encodePacked(sha256(_preimage))) == _hashedSecret,\n            \"Invalid preimage\"\n        );\n\n        uint256 takeAmount = _amount;\n\n        if (_token == _feeAsset) {\n            takeAmount -= _feeAmount;\n        }\n\n        // Mark swap as inactive\n        delete swaps[msgHash];\n\n        // Transfer take amount to taker\n        broker.spendFrom(\n            address(this),\n            _taker,\n            takeAmount,\n            _token,\n            ReasonSwapHolderGive,\n            ReasonSwapTakerReceive\n        );\n\n        // Transfer fee amount to operator\n        if (_feeAmount > 0) {\n            broker.spendFrom(\n                address(this),\n                address(broker.operator()),\n                _feeAmount,\n                _feeAsset,\n                ReasonSwapFeeGive,\n                ReasonSwapFeeReceive\n            );\n        }\n\n        emit ExecuteSwap(_hashedSecret);\n    }\n\n\n    /// @notice Cancels a swap that had been previously made using `createSwap`.\n    /// @dev Cancels the swap with matching msgHash, releasing the locked assets\n    /// back to the maker.\n    /// The original swap parameters need to be resent as only the hash of these\n    /// parameters are stored in `swaps`.\n    /// The `_cancelFeeAmount` is deducted from the `_feeAmount` of the original swap.\n    /// The remaining fee amount is refunded to the user.\n    /// If the sender is not the coordinator, then the full `_feeAmount` is deducted.\n    /// This gives the coordinator control to incentivise users to complete a swap once initiated.\n    /// @param _maker The address of the user making the swap\n    /// @param _taker The address of the user taking the swap\n    /// @param _token The address of the token to be transferred\n    /// @param _amount The number of tokens to be transferred\n    /// @param _hashedSecret The hash of the secret decided on by the maker\n    /// @param _expiryTime The epoch time of when the swap becomes cancellable\n    /// @param _feeAsset The address of the token to use for fee payment\n    /// @param _feeAmount The amount of tokens to pay as fees to the operator\n    /// @param _cancelFeeAmount The number of tokens from the original `_feeAmount` to be deducted as\n    /// cancellation fees\n    function cancelSwap (\n        address _maker,\n        address _taker,\n        address _token,\n        uint256 _amount,\n        bytes32 _hashedSecret,\n        uint256 _expiryTime,\n        address _feeAsset,\n        uint256 _feeAmount,\n        uint256 _cancelFeeAmount\n    )\n        external\n    {\n        require(\n            _expiryTime <= now,\n            \"Cancellation time not yet reached\"\n        );\n\n        bytes32 msgHash = _hashSwapParams(\n            _maker,\n            _taker,\n            _token,\n            _amount,\n            _hashedSecret,\n            _expiryTime,\n            _feeAsset,\n            _feeAmount\n        );\n\n        require(\n            swaps[msgHash] == true,\n            \"Swap is inactive\"\n        );\n\n        uint256 cancelFeeAmount = _cancelFeeAmount;\n\n        // Charge the maximum cancelFeeAmount if not invoked by the coordinator\n        if (msg.sender != address(broker.coordinator())) {\n            cancelFeeAmount = _feeAmount;\n        }\n\n        require(\n            cancelFeeAmount <= _feeAmount,\n            \"Cancel fee must be less than swap fee\"\n        );\n\n        uint256 refundAmount = _amount;\n\n        if (_token == _feeAsset) {\n            refundAmount -= cancelFeeAmount;\n        }\n\n        // Mark the swap as inactive\n        delete swaps[msgHash];\n\n        // Refund the swap maker\n        broker.spendFrom(\n            address(this),\n            _maker,\n            refundAmount,\n            _token,\n            ReasonSwapCancelHolderGive,\n            ReasonSwapCancelMakerReceive\n        );\n\n        // Transfer cancel fee to operator\n        if (cancelFeeAmount > 0) {\n            broker.spendFrom(\n                address(this),\n                address(broker.operator()),\n                cancelFeeAmount,\n                _feeAsset,\n                ReasonSwapCancelFeeGive,\n                ReasonSwapCancelFeeReceive\n            );\n        }\n\n        // If the fee asset is different from the swap asset\n        // then the remaining fee must be separately refunded to the maker\n        uint256 refundFeeAmount = _feeAmount - cancelFeeAmount;\n        if (_token != _feeAsset && refundFeeAmount > 0) {\n            broker.spendFrom(\n                address(this),\n                _maker,\n                refundFeeAmount,\n                _feeAsset,\n                ReasonSwapCancelFeeRefundGive,\n                ReasonSwapCancelFeeRefundReceive\n            );\n        }\n\n        emit CancelSwap(_hashedSecret);\n    }\n\n    function _hashSwapParams(\n        address _maker,\n        address _taker,\n        address _token,\n        uint256 _amount,\n        bytes32 _hashedSecret,\n        uint256 _expiryTime,\n        address _feeAsset,\n        uint256 _feeAmount\n    )\n        private\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(\n            \"swap\",\n            _maker,\n            _taker,\n            _token,\n            _amount,\n            _hashedSecret,\n            _expiryTime,\n            _feeAsset,\n            _feeAmount\n        ));\n    }\n\n    /// @dev Performs an `ecrecover` operation for signed message hashes\n    /// in accordance to EIP-191.\n    function _recoverAddress(bytes32 _hash, uint8 _v, bytes32 _r, bytes32 _s)\n        private\n        pure\n        returns (address)\n    {\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n        bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, _hash));\n        return ecrecover(prefixedHash, _v, _r, _s);\n    }\n\n    /// @dev Ensures a hash hasn't been already used.\n    /// This prevents replay attacks.\n    function _validateAndAddHash(bytes32 _hash)\n        private\n    {\n        require(\n            usedHashes[_hash] != true,\n            \"hash already used\"\n        );\n\n        usedHashes[_hash] = true;\n    }\n}",
  "abi": "[{\"constant\":false,\"inputs\":[{\"name\":\"_maker\",\"type\":\"address\"},{\"name\":\"_taker\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_hashedSecret\",\"type\":\"bytes32\"},{\"name\":\"_expiryTime\",\"type\":\"uint256\"},{\"name\":\"_feeAsset\",\"type\":\"address\"},{\"name\":\"_feeAmount\",\"type\":\"uint256\"},{\"name\":\"_preimage\",\"type\":\"bytes\"}],\"name\":\"executeSwap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maker\",\"type\":\"address\"},{\"name\":\"_taker\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_hashedSecret\",\"type\":\"bytes32\"},{\"name\":\"_expiryTime\",\"type\":\"uint256\"},{\"name\":\"_feeAsset\",\"type\":\"address\"},{\"name\":\"_feeAmount\",\"type\":\"uint256\"},{\"name\":\"_cancelFeeAmount\",\"type\":\"uint256\"}],\"name\":\"cancelSwap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maker\",\"type\":\"address\"},{\"name\":\"_taker\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_hashedSecret\",\"type\":\"bytes32\"},{\"name\":\"_expiryTime\",\"type\":\"uint256\"},{\"name\":\"_feeAsset\",\"type\":\"address\"},{\"name\":\"_feeAmount\",\"type\":\"uint256\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"createSwap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"approveBroker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"broker\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"usedHashes\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"swaps\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"brokerAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"taker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"hashedSecret\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"expiryTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"feeAsset\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"name\":\"CreateSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"hashedSecret\",\"type\":\"bytes32\"}],\"name\":\"ExecuteSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"hashedSecret\",\"type\":\"bytes32\"}],\"name\":\"CancelSwap\",\"type\":\"event\"}]",
  "bytecode": "608060405234801561001057600080fd5b506040516020806114e1833981016040525160008054600160a060020a03909216600160a060020a031990921691909117905561148f806100526000396000f3006080604052600436106100695763ffffffff60e060020a6000350416630977873b811461006e57806327eabac3146100c0578063571e76f71461010657806390a6ba8814610157578063abff01101461016c578063aef18bf71461019d578063eb84e7f2146101c9575b600080fd5b34801561007a57600080fd5b506100be600160a060020a036004803582169160248035821692604435831692606435926084359260a4359260c435169160e43591610104359182019101356101e1565b005b3480156100cc57600080fd5b506100be600160a060020a03600435811690602435811690604435811690606435906084359060a4359060c4351660e435610104356105dd565b34801561011257600080fd5b506100be600160a060020a03600435811690602435811690604435811690606435906084359060a4359060c4351660e43560ff61010435166101243561014435610b8d565b34801561016357600080fd5b506100be6110c6565b34801561017857600080fd5b50610181611140565b60408051600160a060020a039092168252519081900360200190f35b3480156101a957600080fd5b506101b560043561114f565b604080519115158252519081900360200190f35b3480156101d557600080fd5b506101b5600435611164565b6000806101f48c8c8c8c8c8c8c8c611179565b60008181526001602081905260409091205491935060ff909116151514610265576040805160e560020a62461bcd02815260206004820152601060248201527f5377617020697320696e61637469766500000000000000000000000000000000604482015290519081900360640190fd5b87600019166002808686604051808383808284378201915050925050506020604051808303816000865af11580156102a1573d6000803e3d6000fd5b5050506040513d60208110156102b657600080fd5b50516040805160208181019390935281518082038401815290820191829052805190928291908401908083835b602083106103025780518252601f1990920191602091820191016102e3565b51815160209384036101000a600019018019909216911617905260405191909301945091925050808303816000865af1158015610343573d6000803e3d6000fd5b5050506040513d602081101561035857600080fd5b5051146103af576040805160e560020a62461bcd02815260206004820152601060248201527f496e76616c696420707265696d61676500000000000000000000000000000000604482015290519081900360640190fd5b88905085600160a060020a03168a600160a060020a031614156103d0578490035b600082815260016020526040808220805460ff19169055815481517f66acab4c000000000000000000000000000000000000000000000000000000008152306004820152600160a060020a038f81166024830152604482018690528e8116606483015260346084830152603560a4830152925192909116926366acab4c9260c48084019382900301818387803b15801561046957600080fd5b505af115801561047d573d6000803e3d6000fd5b5050505060008511156105a45760008054604080517f570ca7350000000000000000000000000000000000000000000000000000000081529051600160a060020a03909216926366acab4c923092859263570ca735926004808401936020939083900390910190829087803b1580156104f557600080fd5b505af1158015610509573d6000803e3d6000fd5b505050506040513d602081101561051f57600080fd5b50516040805160e060020a63ffffffff8616028152600160a060020a0393841660048201529183166024830152604482018a9052918a16606482015260366084820152603760a4820152905160c480830192600092919082900301818387803b15801561058b57600080fd5b505af115801561059f573d6000803e3d6000fd5b505050505b60405188907fb8f777c2682f5c8db9eca27195e9f2a08abba31865831209927a9e282ca1007e90600090a2505050505050505050505050565b600080808042881115610660576040805160e560020a62461bcd02815260206004820152602160248201527f43616e63656c6c6174696f6e2074696d65206e6f74207965742072656163686560448201527f6400000000000000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b6106708d8d8d8d8d8d8d8d611179565b60008181526001602081905260409091205491955060ff9091161515146106e1576040805160e560020a62461bcd02815260206004820152601060248201527f5377617020697320696e61637469766500000000000000000000000000000000604482015290519081900360640190fd5b8492506000809054906101000a9004600160a060020a0316600160a060020a0316630a0090976040518163ffffffff1660e060020a028152600401602060405180830381600087803b15801561073657600080fd5b505af115801561074a573d6000803e3d6000fd5b505050506040513d602081101561076057600080fd5b5051600160a060020a03163314610775578592505b858311156107f3576040805160e560020a62461bcd02815260206004820152602560248201527f43616e63656c20666565206d757374206265206c657373207468616e2073776160448201527f7020666565000000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b89915086600160a060020a03168b600160a060020a031614156108165782820391505b60016000856000191660001916815260200190815260200160002060006101000a81549060ff02191690556000809054906101000a9004600160a060020a0316600160a060020a03166366acab4c308f858f603960386040518763ffffffff1660e060020a0281526004018087600160a060020a0316600160a060020a0316815260200186600160a060020a0316600160a060020a0316815260200185815260200184600160a060020a0316600160a060020a031681526020018360ff1660ff1681526020018260ff1660ff1681526020019650505050505050600060405180830381600087803b15801561090a57600080fd5b505af115801561091e573d6000803e3d6000fd5b505050506000831115610a455760008054604080517f570ca7350000000000000000000000000000000000000000000000000000000081529051600160a060020a03909216926366acab4c923092859263570ca735926004808401936020939083900390910190829087803b15801561099657600080fd5b505af11580156109aa573d6000803e3d6000fd5b505050506040513d60208110156109c057600080fd5b50516040805160e060020a63ffffffff8616028152600160a060020a039384166004820152918316602483015260448201889052918b166064820152603a6084820152603b60a4820152905160c480830192600092919082900301818387803b158015610a2c57600080fd5b505af1158015610a40573d6000803e3d6000fd5b505050505b828603905086600160a060020a03168b600160a060020a031614158015610a6c5750600081115b15610b53576000809054906101000a9004600160a060020a0316600160a060020a03166366acab4c308f848b603c603d6040518763ffffffff1660e060020a0281526004018087600160a060020a0316600160a060020a0316815260200186600160a060020a0316600160a060020a0316815260200185815260200184600160a060020a0316600160a060020a031681526020018360ff1660ff1681526020018260ff1660ff1681526020019650505050505050600060405180830381600087803b158015610b3a57600080fd5b505af1158015610b4e573d6000803e3d6000fd5b505050505b60405189907fad8f5783ccaf65c71de9f05c4204da5e5586193083754a5955a1604dc1aedc3790600090a250505050505050505050505050565b60008060009054906101000a9004600160a060020a0316600160a060020a0316630a0090976040518163ffffffff1660e060020a028152600401602060405180830381600087803b158015610be157600080fd5b505af1158015610bf5573d6000803e3d6000fd5b505050506040513d6020811015610c0b57600080fd5b5051600160a060020a03163314610c6c576040805160e560020a62461bcd02815260206004820152600e60248201527f496e76616c69642073656e646572000000000000000000000000000000000000604482015290519081900360640190fd5b60008911610cc4576040805160e560020a62461bcd02815260206004820152600e60248201527f496e76616c696420616d6f756e74000000000000000000000000000000000000604482015290519081900360640190fd5b428711610d1b576040805160e560020a62461bcd02815260206004820152601360248201527f496e76616c6964206578706972792074696d6500000000000000000000000000604482015290519081900360640190fd5b610d248861127b565b610d348c8c8c8c8c8c8c8c611179565b90508b600160a060020a0316610d4c82868686611302565b600160a060020a031614610daa576040805160e560020a62461bcd02815260206004820152601160248201527f496e76616c6964207369676e6174757265000000000000000000000000000000604482015290519081900360640190fd5b89600160a060020a031686600160a060020a03161415610e1b57888510610e1b576040805160e560020a62461bcd02815260206004820152601960248201527f46656520616d6f756e74206578636565647320616d6f756e7400000000000000604482015290519081900360640190fd5b6000809054906101000a9004600160a060020a0316600160a060020a03166366acab4c8d308c8e603060316040518763ffffffff1660e060020a0281526004018087600160a060020a0316600160a060020a0316815260200186600160a060020a0316600160a060020a0316815260200185815260200184600160a060020a0316600160a060020a031681526020018360ff1660ff1681526020018260ff1660ff1681526020019650505050505050600060405180830381600087803b158015610ee457600080fd5b505af1158015610ef8573d6000803e3d6000fd5b50505050600160a060020a03868116908b1614610ff1576000809054906101000a9004600160a060020a0316600160a060020a03166366acab4c8d30888a603260336040518763ffffffff1660e060020a0281526004018087600160a060020a0316600160a060020a0316815260200186600160a060020a0316600160a060020a0316815260200185815260200184600160a060020a0316600160a060020a031681526020018360ff1660ff1681526020018260ff1660ff1681526020019650505050505050600060405180830381600087803b158015610fd857600080fd5b505af1158015610fec573d6000803e3d6000fd5b505050505b6001806000836000191660001916815260200190815260200160002060006101000a81548160ff02191690831515021790555087600019168b600160a060020a03168d600160a060020a03167f8fdd4312601e56c11831f8c000540bf66966b7c19933ec42f44d81e56cd3df368d8d8c8c8c6040518086600160a060020a0316600160a060020a0316815260200185815260200184815260200183600160a060020a0316600160a060020a031681526020018281526020019550505050505060405180910390a4505050505050505050505050565b60008054604080517f099a0aae0000000000000000000000000000000000000000000000000000000081523060048201529051600160a060020a039092169263099a0aae9260248084019382900301818387803b15801561112657600080fd5b505af115801561113a573d6000803e3d6000fd5b50505050565b600054600160a060020a031681565b60026020526000908152604090205460ff1681565b60016020526000908152604090205460ff1681565b604080517f73776170000000000000000000000000000000000000000000000000000000006020808301919091526c01000000000000000000000000600160a060020a03808d1682026024850152808c1682026038850152808b168202604c850152606084018a90526080840189905260a0840188905286160260c083015260d48083018590528351808403909101815260f4909201928390528151600093918291908401908083835b602083106112425780518252601f199092019160209182019101611223565b5181516020939093036101000a600019018019909116921691909117905260405192018290039091209c9b505050505050505050505050565b60008181526002602052604090205460ff161515600114156112e7576040805160e560020a62461bcd02815260206004820152601160248201527f6861736820616c72656164792075736564000000000000000000000000000000604482015290519081900360640190fd5b6000908152600260205260409020805460ff19166001179055565b604080518082018252601c8082527f19457468657265756d205369676e6564204d6573736167653a0a33320000000060208084019182529351600094859385938b939092019182918083835b6020831061136d5780518252601f19909201916020918201910161134e565b51815160209384036101000a600019018019909216911617905292019384525060408051808503815293820190819052835193945092839250908401908083835b602083106113cd5780518252601f1990920191602091820191016113ae565b51815160209384036101000a600019018019909216911617905260408051929094018290038220600080845283830180875282905260ff8e1684870152606084018d9052608084018c905294519097506001965060a080840196509194601f19820194509281900390910191865af115801561144d573d6000803e3d6000fd5b5050604051601f190151989750505050505050505600a165627a7a72305820e9b64cdcb95efc18cbd3f73ca584dcb3d3c56644dbb4bab9de27d9940eaf6ede0029000000000000000000000000ba3ed686cc32ffa8664628b1e96d8022e40543de",
  "constructorArguments": "000000000000000000000000ba3ed686cc32ffa8664628b1e96d8022e40543de"
}