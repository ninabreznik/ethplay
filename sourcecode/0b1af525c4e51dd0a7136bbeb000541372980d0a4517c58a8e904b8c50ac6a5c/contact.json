{
  "address": "0xfdb1b5adf9cc13d8434f3d493f345a8bc46afcdc",
  "chain": "ETH",
  "chainID": 1,
  "verifier": "etherscan.io",
  "commonName": "",
  "contractName": "Library",
  "compilerVersion": "v0.4.24+commit.e67f0147",
  "optimization": true,
  "runs": "200",
  "evmVersion": "default",
  "sourceCode": "/**\n *Submitted for verification at Etherscan.io on 2019-05-30\n*/\n\npragma solidity ^0.4.24;\n\n// File: contracts/SafeMath32.sol\n\nlibrary SafeMath32 {\n\n  function mul(uint32 a, uint32 b) internal pure returns (uint32) {\n    if (a == 0) {\n      return 0;\n    }\n\n    uint32 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function div(uint32 a, uint32 b) internal pure returns (uint32) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint32 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesnâ€™t hold\n    return c;\n  }\n\n  function sub(uint32 a, uint32 b) internal pure returns (uint32) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint32 a, uint32 b) internal pure returns (uint32) {\n    uint32 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: contracts/AraProxy.sol\n\n/**\n * @title AraProxy\n * @dev Gives the possibility to delegate any call to a foreign implementation.\n */\ncontract AraProxy {\n\n  bytes32 private constant registryPosition_ = keccak256(\"io.ara.proxy.registry\");\n  bytes32 private constant implementationPosition_ = keccak256(\"io.ara.proxy.implementation\");\n\n  modifier restricted() {\n    bytes32 registryPosition = registryPosition_;\n    address registryAddress;\n    assembly {\n      registryAddress := sload(registryPosition)\n    }\n    require(\n      msg.sender == registryAddress,\n      \"Only the AraRegistry can upgrade this proxy.\"\n    );\n    _;\n  }\n\n  /**\n  * @dev the constructor sets the AraRegistry address\n  */\n  constructor(address _registryAddress, address _implementationAddress) public {\n    bytes32 registryPosition = registryPosition_;\n    bytes32 implementationPosition = implementationPosition_;\n    assembly {\n      sstore(registryPosition, _registryAddress)\n      sstore(implementationPosition, _implementationAddress)\n    }\n  }\n\n  function setImplementation(address _newImplementation) public restricted {\n    require(_newImplementation != address(0));\n    bytes32 implementationPosition = implementationPosition_;\n    assembly {\n      sstore(implementationPosition, _newImplementation)\n    }\n  }\n\n  /**\n  * @dev Fallback function allowing to perform a delegatecall to the given implementation.\n  * This function will return whatever the implementation call returns\n  */\n  function () payable public {\n    bytes32 implementationPosition = implementationPosition_;\n    address _impl;\n    assembly {\n      _impl := sload(implementationPosition)\n    }\n\n    assembly {\n      let ptr := mload(0x40)\n      calldatacopy(ptr, 0, calldatasize)\n      let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\n      let size := returndatasize\n      returndatacopy(ptr, 0, size)\n\n      switch result\n      case 0 { revert(ptr, size) }\n      default { return(ptr, size) }\n    }\n  }\n}\n\n// File: contracts/ignored_contracts/Registry.sol\n\ncontract Registry {\n  address public owner_;\n  mapping (bytes32 => address) private proxies_; // contentId (unhashed) => proxy\n  mapping (bytes32 => address) private proxyOwners_; // contentId (unhashed) => owner\n  mapping (string => address) private versions_; // version => implementation\n  mapping (address => string) public proxyImpls_; // proxy => version\n  string public latestVersion_;\n\n  event ProxyDeployed(address indexed _owner, bytes32 indexed _contentId, address _address);\n  event ProxyUpgraded(bytes32 indexed _contentId, string indexed _version);\n  event StandardAdded(string indexed _version, address _address);\n\n  function init(bytes _data) public {\n    require(owner_ == address(0), 'Registry has already been initialized.');\n\n    uint256 btsptr;\n    address ownerAddr;\n    assembly {\n      btsptr := add(_data, 32)\n      ownerAddr := mload(btsptr)\n    }\n    owner_ = ownerAddr;\n  }\n\n  modifier restricted() {\n    require (\n      msg.sender == owner_,\n      \"Sender not authorized.\"\n    );\n    _;\n  }\n\n  modifier onlyProxyOwner(bytes32 _contentId) {\n    require(\n      proxyOwners_[_contentId] == msg.sender,\n      \"Sender not authorized.\"\n    );\n    _;\n  }\n\n  function getProxyAddress(bytes32 _contentId) public view returns (address) {\n    return proxies_[_contentId];\n  }\n\n  function getProxyOwner(bytes32 _contentId) public view returns (address) {\n    return proxyOwners_[_contentId];\n  }\n\n  function getImplementation(string _version) public view returns (address) {\n    return versions_[_version];\n  }\n\n  function getProxyVersion(bytes32 _contentId) public view returns (string) {\n    return proxyImpls_[getProxyAddress(_contentId)];\n  }\n  \n  /**\n   * @dev AFS Proxy Factory\n   * @param _contentId The unhashed methodless content DID\n   * @param _version The implementation version to use with this Proxy\n   * @param _data AFS initialization data\n   * @return address of the newly deployed Proxy\n   */\n  function createAFS(bytes32 _contentId, string _version, bytes _data) public {\n    require(proxies_[_contentId] == address(0), \"Proxy already exists for this content.\");\n    require(versions_[_version] != address(0), \"Version does not exist.\");\n    AraProxy proxy = new AraProxy(address(this), versions_[_version]);\n    proxies_[_contentId] = proxy;\n    proxyOwners_[_contentId] = msg.sender;\n    upgradeProxyAndCall(_contentId, _version, _data);\n    emit ProxyDeployed(msg.sender, _contentId, address(proxy));\n  }\n\n  /**\n   * @dev Upgrades proxy implementation version\n   * @param _contentId The unhashed methodless content DID\n   * @param _version The implementation version to upgrade this Proxy to\n   */\n  function upgradeProxy(bytes32 _contentId, string _version) public onlyProxyOwner(_contentId) {\n    require(versions_[_version] != address(0), \"Version does not exist.\");\n    AraProxy proxy = AraProxy(proxies_[_contentId]);\n    proxy.setImplementation(versions_[_version]);\n    proxyImpls_[proxies_[_contentId]] = _version;\n    emit ProxyUpgraded(_contentId, _version);\n  }\n\n  /**\n   * @dev Upgrades proxy implementation version with initialization\n   * @param _contentId The unhashed methodless content DID\n   * @param _version The implementation version to upgrade this Proxy to\n   * @param _data AFS initialization data\n   */\n  function upgradeProxyAndCall(bytes32 _contentId, string _version, bytes _data) public onlyProxyOwner(_contentId) {\n    require(versions_[_version] != address(0), \"Version does not exist.\");\n    require(keccak256(abi.encodePacked(proxyImpls_[proxy])) != keccak256(abi.encodePacked(_version)), \"Proxy is already on this version.\");\n    AraProxy proxy = AraProxy(proxies_[_contentId]);\n    proxy.setImplementation(versions_[_version]);\n    proxyImpls_[proxy] = _version;\n    require(address(proxy).call(abi.encodeWithSignature(\"init(bytes)\", _data)), \"Init failed.\");\n    emit ProxyUpgraded(_contentId, _version);\n  }\n\n  /**\n   * @dev Adds a new AFS implementation standard\n   * @param _version The implementation version name\n   * @param _address The address of the new AFS implementation\n   */\n  function addStandardVersion(string _version, address _address) public restricted {\n    require(versions_[_version] == address(0), \"Version already exists.\");\n    versions_[_version] = _address;\n    latestVersion_ = _version;\n    emit StandardAdded(_version, _address);\n  }\n}\n\n// File: contracts/ignored_contracts/Library.sol\n\ncontract Library {\n  using SafeMath32 for uint32;\n\n  address public owner_;\n  mapping (bytes32 => Lib) private libraries_; // hashed methodless owner did => library\n  Registry registry_;\n\n  struct Lib {\n    uint32 size;\n    mapping (uint32 => bytes32) content; // index => contentId (unhashed)\n  }\n\n  event AddedToLib(bytes32 indexed _identity, bytes32 indexed _contentId);\n\n  function init(bytes _data) public {\n    require(owner_ == address(0), 'Library has already been initialized.');\n\n    uint256 btsptr;\n    address ownerAddr;\n    address registryAddr;\n    assembly {\n      btsptr := add(_data, 32)\n      ownerAddr := mload(btsptr)\n      btsptr := add(_data, 64)\n      registryAddr := mload(btsptr)\n    }\n    owner_ = ownerAddr;\n    registry_ = Registry(registryAddr);\n  }\n\n  modifier restricted() {\n    require (msg.sender == owner_, \"Sender not authorized.\");\n     _;\n  }\n\n  modifier fromProxy(bytes32 _contentId) {\n    require (msg.sender == registry_.getProxyAddress(_contentId), \"Proxy not authorized.\");\n     _;\n  }\n\n  function getLibrarySize(bytes32 _identity) public view returns (uint32 size) {\n    return libraries_[_identity].size;\n  }\n\n  function getLibraryItem(bytes32 _identity, uint32 _index) public view returns (bytes32 contentId) {\n    require (_index < libraries_[_identity].size, \"Index does not exist.\");\n    return libraries_[_identity].content[_index];\n  }\n\n  function addLibraryItem(bytes32 _identity, bytes32 _contentId) public fromProxy(_contentId) {\n    uint32 libSize = libraries_[_identity].size;\n    assert (libraries_[_identity].content[libSize] == bytes32(0));\n    libraries_[_identity].content[libSize] = _contentId;\n    libraries_[_identity].size++;\n    emit AddedToLib(_identity, _contentId);\n  }\n}",
  "abi": "[{\"constant\":false,\"inputs\":[{\"name\":\"_identity\",\"type\":\"bytes32\"},{\"name\":\"_contentId\",\"type\":\"bytes32\"}],\"name\":\"addLibraryItem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_identity\",\"type\":\"bytes32\"},{\"name\":\"_index\",\"type\":\"uint32\"}],\"name\":\"getLibraryItem\",\"outputs\":[{\"name\":\"contentId\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_identity\",\"type\":\"bytes32\"}],\"name\":\"getLibrarySize\",\"outputs\":[{\"name\":\"size\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner_\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_identity\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"_contentId\",\"type\":\"bytes32\"}],\"name\":\"AddedToLib\",\"type\":\"event\"}]",
  "bytecode": "608060405234801561001057600080fd5b5061056c806100206000396000f30060806040526004361061006c5763ffffffff7c01000000000000000000000000000000000000000000000000000000006000350416630c2bb965811461007157806328e3bac71461008e5780634ddf47d4146100c157806396cd472d1461011a578063e76630791461014b575b600080fd5b34801561007d57600080fd5b5061008c600435602435610189565b005b34801561009a57600080fd5b506100af60043563ffffffff60243516610354565b60408051918252519081900360200190f35b3480156100cd57600080fd5b506040805160206004803580820135601f810184900484028501840190955284845261008c9436949293602493928401919081908401838280828437509497506104039650505050505050565b34801561012657600080fd5b5061013260043561050c565b6040805163ffffffff9092168252519081900360200190f35b34801561015757600080fd5b50610160610524565b6040805173ffffffffffffffffffffffffffffffffffffffff9092168252519081900360200190f35b600254604080517f92d00a4a000000000000000000000000000000000000000000000000000000008152600481018490529051600092849273ffffffffffffffffffffffffffffffffffffffff909116916392d00a4a9160248082019260209290919082900301818887803b15801561020157600080fd5b505af1158015610215573d6000803e3d6000fd5b505050506040513d602081101561022b57600080fd5b505173ffffffffffffffffffffffffffffffffffffffff1633146102b057604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f50726f7879206e6f7420617574686f72697a65642e0000000000000000000000604482015290519081900360640190fd5b6000848152600160208181526040808420805463ffffffff16808652930190915290912054909250156102df57fe5b600084815260016020818152604080842063ffffffff8781168652818501845282862089905589865292849052805463ffffffff19811690841690940190921692909217905551849186917f7a8d1104507665c9970d0220690917a47395021f263da0042243d55c358957099190a350505050565b60008281526001602052604081205463ffffffff908116908316106103da57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f496e64657820646f6573206e6f742065786973742e0000000000000000000000604482015290519081900360640190fd5b50600082815260016020818152604080842063ffffffff86168552909201905290205492915050565b600080548190819073ffffffffffffffffffffffffffffffffffffffff16156104b357604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602560248201527f4c6962726172792068617320616c7265616479206265656e20696e697469616c60448201527f697a65642e000000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b50505060208101516040909101516000805473ffffffffffffffffffffffffffffffffffffffff93841673ffffffffffffffffffffffffffffffffffffffff199182161790915560028054939092169216919091179055565b60009081526001602052604090205463ffffffff1690565b60005473ffffffffffffffffffffffffffffffffffffffff16815600a165627a7a72305820b89f4596f8cd6e298e89cfabd69cab2f9a4904e1f3cd22ecb511f6d0241999d50029000000000000000000000000e4127f775e738f30ca3672f62d0f63fd3aab66b800000000000000000000000017a6033535b1ab8cbbb430c62782d164d8f6ac45",
  "constructorArguments": "000000000000000000000000e4127f775e738f30ca3672f62d0f63fd3aab66b800000000000000000000000017a6033535b1ab8cbbb430c62782d164d8f6ac45"
}